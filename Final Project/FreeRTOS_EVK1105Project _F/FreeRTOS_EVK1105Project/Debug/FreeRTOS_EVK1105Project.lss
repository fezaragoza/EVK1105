
FreeRTOS_EVK1105Project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00008f94  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000b000  8000b000  0000b400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000b200  8000b200  0000b600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       0000a1c0  8000b218  8000b218  0000b618  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  800153d8  00015808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  800153e0  00015810  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  800153e8  00015818  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  800153ec  0001581c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         0000051c  0000001c  800153ec  0001581c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .balign       00000000  00000538  80015908  00015d38  2**0
                  ALLOC
 14 .bss          00001188  00000538  00000538  00000000  2**2
                  ALLOC
 15 .heap         0000d940  000016c0  000016c0  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00015d38  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00001b00  00000000  00000000  00015d68  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 000047af  00000000  00000000  00017868  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00027d5a  00000000  00000000  0001c017  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 000061fd  00000000  00000000  00043d71  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   00016fdd  00000000  00000000  00049f6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00004cd4  00000000  00000000  00060f4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00008fd7  00000000  00000000  00065c20  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    0000e5f1  00000000  00000000  0006ebf7  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 01f4f80a  00000000  00000000  0007d1e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00001d38  00000000  00000000  01fcc9f2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 47 c5 	rcall	8000afa8 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 38 	mov	r10,1336
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 16 c0 	mov	r10,5824
8000204c:	e0 6c 05 38 	mov	r12,1336
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 2a 27 	rcall	800074a8 <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 42 a6 	rcall	8000a5ac <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 45 a8 	rcall	8000abba <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 35 2d 	rcall	80008ad4 <main>
8000207e:	e0 a0 42 9f 	rcall	8000a5bc <exit>
80002082:	d7 03       	nop
80002084:	80 01       	ld.sh	r1,r0[0x0]
80002086:	53 d8       	stdsp	sp[0xf4],r8
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	b2 00       	st.h	r9[0x0],r0

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 38 	mov	r8,1336
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 3c 	mov	r7,1340
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 38 	mov	r8,1336
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <tpa6130_abdac_tx_pdca_int_handler>:
  .output_impedance    = TPA6130_OUTPUT_IMPEDANCE_DEFAULT,
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
800020e0:	d4 01       	pushm	lr
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
800020e2:	30 0c       	mov	r12,0
800020e4:	f0 1f 00 13 	mcall	80002130 <tpa6130_abdac_tx_pdca_int_handler+0x50>
800020e8:	e2 1c 00 02 	andl	r12,0x2,COH
800020ec:	c0 d0       	breq	80002106 <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
800020ee:	30 0c       	mov	r12,0
800020f0:	f0 1f 00 11 	mcall	80002134 <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
800020f4:	49 18       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
800020f6:	70 28       	ld.w	r8,r8[0x8]
800020f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800020fc:	c0 50       	breq	80002106 <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
800020fe:	48 f8       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002100:	70 18       	ld.w	r8,r8[0x4]
80002102:	30 1c       	mov	r12,1
80002104:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
80002106:	30 0c       	mov	r12,0
80002108:	f0 1f 00 0a 	mcall	80002130 <tpa6130_abdac_tx_pdca_int_handler+0x50>
8000210c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002110:	c0 d0       	breq	8000212a <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002112:	30 0c       	mov	r12,0
80002114:	f0 1f 00 0a 	mcall	8000213c <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002118:	48 88       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
8000211a:	70 28       	ld.w	r8,r8[0x8]
8000211c:	e2 18 00 02 	andl	r8,0x2,COH
80002120:	c0 50       	breq	8000212a <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
80002122:	48 68       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002124:	70 18       	ld.w	r8,r8[0x4]
80002126:	30 2c       	mov	r12,2
80002128:	5d 18       	icall	r8
  }
}
8000212a:	d4 02       	popm	lr
8000212c:	d6 03       	rete
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	40 d4       	lddsp	r4,sp[0x34]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	41 0c       	lddsp	r12,sp[0x40]
80002138:	00 00       	add	r0,r0
8000213a:	05 40       	ld.w	r0,--r2
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	40 e4       	lddsp	r4,sp[0x38]

80002140 <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80002140:	d4 21       	pushm	r4-r7,lr
80002142:	20 5d       	sub	sp,20
80002144:	18 94       	mov	r4,r12
80002146:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80002148:	f7 ec 10 88 	or	r8,r11,r12<<0x8
8000214c:	fb 58 00 12 	st.h	sp[18],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80002150:	30 08       	mov	r8,0
80002152:	30 09       	mov	r9,0
80002154:	fa e9 00 00 	st.d	sp[0],r8
80002158:	36 08       	mov	r8,96
8000215a:	ba 88       	st.b	sp[0x0],r8
8000215c:	fa c8 ff ee 	sub	r8,sp,-18
80002160:	50 28       	stdsp	sp[0x8],r8
80002162:	30 28       	mov	r8,2
80002164:	50 38       	stdsp	sp[0xc],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
80002166:	1a 96       	mov	r6,sp
80002168:	fe 77 2c 00 	mov	r7,-54272
8000216c:	1a 9b       	mov	r11,sp
8000216e:	0e 9c       	mov	r12,r7
80002170:	f0 1f 00 05 	mcall	80002184 <tpa6130_write_data+0x44>
  }
  while( twi_status != TWI_SUCCESS );
80002174:	cf c1       	brne	8000216c <tpa6130_write_data+0x2c>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
80002176:	48 58       	lddpc	r8,80002188 <tpa6130_write_data+0x48>
80002178:	f0 04 00 04 	add	r4,r8,r4
8000217c:	e9 65 ff ff 	st.b	r4[-1],r5
}
80002180:	2f bd       	sub	sp,-20
80002182:	d8 22       	popm	r4-r7,pc
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	45 cc       	lddsp	r12,sp[0x170]
80002188:	00 00       	add	r0,r0
8000218a:	00 1c       	sub	r12,r0

8000218c <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
8000218c:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
8000218e:	33 f8       	mov	r8,63
80002190:	f0 0c 18 00 	cp.b	r12,r8
80002194:	e0 8a 00 04 	brle	8000219c <tpa6130_set_volume+0x10>
80002198:	33 fb       	mov	r11,63
8000219a:	c0 b8       	rjmp	800021b0 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
8000219c:	30 08       	mov	r8,0
8000219e:	f0 0c 18 00 	cp.b	r12,r8
800021a2:	e0 89 00 05 	brgt	800021ac <tpa6130_set_volume+0x20>
800021a6:	e0 6b 00 c0 	mov	r11,192
800021aa:	c0 38       	rjmp	800021b0 <tpa6130_set_volume+0x24>
800021ac:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
800021b0:	30 2c       	mov	r12,2
800021b2:	f0 1f 00 02 	mcall	800021b8 <tpa6130_set_volume+0x2c>
}
800021b6:	d8 02       	popm	pc
800021b8:	80 00       	ld.sh	r0,r0[0x0]
800021ba:	21 40       	sub	r0,20

800021bc <tpa6130_dac_output>:
 * which contain two (16-bit) samples, one for each channel.
 *
 * \note The DACs must have been started beforehand.
 */
bool tpa6130_dac_output(void *sample_buffer, size_t sample_length)
{
800021bc:	eb cd 40 c0 	pushm	r6-r7,lr
800021c0:	18 96       	mov	r6,r12
800021c2:	16 97       	mov	r7,r11
  //int global_interrupt_enabled;

  /*Wait until the PDCA loads the reload value to its transfer
   * counter register(TCRR=0). Then we are ready to set up a new
   * transfer */
  if(!(pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) &
800021c4:	30 0c       	mov	r12,0
800021c6:	f0 1f 00 11 	mcall	80002208 <tpa6130_dac_output+0x4c>
800021ca:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800021ce:	c1 b0       	breq	80002204 <tpa6130_dac_output+0x48>
  {
    return false;
  }

  /* Nothing to do if we get no data. */
  if(sample_length)
800021d0:	58 07       	cp.w	r7,0
800021d2:	c1 80       	breq	80002202 <tpa6130_dac_output+0x46>
    //if((global_interrupt_enabled = cpu_irq_is_enabled()))
    //  cpu_irq_disable();

    /*FIXME This assumes a stereo 16-bit sample size */
    // one sample here consists of 2x16-bit (16-bit stereo)
    pdca_reload_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800021d4:	0e 9a       	mov	r10,r7
800021d6:	0c 9b       	mov	r11,r6
800021d8:	30 0c       	mov	r12,0
800021da:	f0 1f 00 0d 	mcall	8000220c <tpa6130_dac_output+0x50>
    //if(global_interrupt_enabled)
    //  cpu_irq_enable();

    /*TODO enable transfer complete interrupt
     * Is it possible to move this to setup or other places?*/
    if(tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
800021de:	48 d8       	lddpc	r8,80002210 <tpa6130_dac_output+0x54>
800021e0:	70 28       	ld.w	r8,r8[0x8]
800021e2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800021e6:	c0 40       	breq	800021ee <tpa6130_dac_output+0x32>
      pdca_enable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
800021e8:	30 0c       	mov	r12,0
800021ea:	f0 1f 00 0b 	mcall	80002214 <tpa6130_dac_output+0x58>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
800021ee:	48 98       	lddpc	r8,80002210 <tpa6130_dac_output+0x54>
800021f0:	70 28       	ld.w	r8,r8[0x8]
800021f2:	e2 18 00 02 	andl	r8,0x2,COH
800021f6:	c0 60       	breq	80002202 <tpa6130_dac_output+0x46>
      pdca_enable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
800021f8:	30 0c       	mov	r12,0
800021fa:	f0 1f 00 08 	mcall	80002218 <tpa6130_dac_output+0x5c>
800021fe:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002202:	30 1c       	mov	r12,1
  }
  return true;
}
80002204:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	40 d4       	lddsp	r4,sp[0x34]
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	41 34       	lddsp	r4,sp[0x4c]
80002210:	00 00       	add	r0,r0
80002212:	05 40       	ld.w	r0,--r2
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	40 b4       	lddsp	r4,sp[0x2c]
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	40 c4       	lddsp	r4,sp[0x30]

8000221c <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
8000221c:	d4 01       	pushm	lr
8000221e:	20 5d       	sub	sp,20
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
80002220:	58 0b       	cp.w	r11,0
80002222:	c0 90       	breq	80002234 <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
80002224:	48 f8       	lddpc	r8,80002260 <tpa6130_read_data+0x44>
80002226:	f0 0c 00 0c 	add	r12,r8,r12
8000222a:	f9 38 ff ff 	ld.ub	r8,r12[-1]
8000222e:	fb 68 00 13 	st.b	sp[19],r8
80002232:	c1 38       	rjmp	80002258 <tpa6130_read_data+0x3c>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr[0] = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
80002234:	30 08       	mov	r8,0
80002236:	30 09       	mov	r9,0
80002238:	fa e9 00 00 	st.d	sp[0],r8
8000223c:	36 08       	mov	r8,96
8000223e:	ba 88       	st.b	sp[0x0],r8
80002240:	ba 9c       	st.b	sp[0x1],r12
80002242:	30 18       	mov	r8,1
80002244:	50 18       	stdsp	sp[0x4],r8
80002246:	fa c9 ff ed 	sub	r9,sp,-19
8000224a:	50 29       	stdsp	sp[0x8],r9
8000224c:	50 38       	stdsp	sp[0xc],r8
    twi_master_read(TPA6130_TWI, &twi_package);
8000224e:	1a 9b       	mov	r11,sp
80002250:	fe 7c 2c 00 	mov	r12,-54272
80002254:	f0 1f 00 04 	mcall	80002264 <tpa6130_read_data+0x48>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80002258:	fb 3c 00 13 	ld.ub	r12,sp[19]
8000225c:	2f bd       	sub	sp,-20
8000225e:	d8 02       	popm	pc
80002260:	00 00       	add	r0,r0
80002262:	00 1c       	sub	r12,r0
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	46 a4       	lddsp	r4,sp[0x1a8]

80002268 <tpa6130_get_volume>:
/*! \brief Gets the current volume settings.
 *  \returns Current volume settings. Value is between 0 (-59dB) and
 *  63 (4dB).
 */
int8_t tpa6130_get_volume(void)
{
80002268:	d4 01       	pushm	lr
  return tpa6130_read_data(TPA6130_VOLUME_AND_MUTE, TWI_READ_SR);
8000226a:	30 1b       	mov	r11,1
8000226c:	30 2c       	mov	r12,2
8000226e:	f0 1f 00 03 	mcall	80002278 <tpa6130_get_volume+0x10>
}
80002272:	5c 5c       	castu.b	r12
80002274:	d8 02       	popm	pc
80002276:	00 00       	add	r0,r0
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	22 1c       	sub	r12,33

8000227c <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
8000227c:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
8000227e:	30 0b       	mov	r11,0
80002280:	30 1c       	mov	r12,1
80002282:	f0 1f 00 05 	mcall	80002294 <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
80002286:	18 9b       	mov	r11,r12
80002288:	e2 1b 00 fe 	andl	r11,0xfe,COH
8000228c:	30 1c       	mov	r12,1
8000228e:	f0 1f 00 03 	mcall	80002298 <tpa6130_powerup+0x1c>
}
80002292:	d8 02       	popm	pc
80002294:	80 00       	ld.sh	r0,r0[0x0]
80002296:	22 1c       	sub	r12,33
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	21 40       	sub	r0,20

8000229c <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
8000229c:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
8000229e:	30 0b       	mov	r11,0
800022a0:	30 1c       	mov	r12,1
800022a2:	f0 1f 00 05 	mcall	800022b4 <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
800022a6:	18 9b       	mov	r11,r12
800022a8:	a1 ab       	sbr	r11,0x0
800022aa:	5c 5b       	castu.b	r11
800022ac:	30 1c       	mov	r12,1
800022ae:	f0 1f 00 03 	mcall	800022b8 <tpa6130_shutdown+0x1c>
}
800022b2:	d8 02       	popm	pc
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	22 1c       	sub	r12,33
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	21 40       	sub	r0,20

800022bc <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
800022bc:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
800022be:	f0 1f 00 0b 	mcall	800022e8 <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
800022c2:	fe 7c 40 00 	mov	r12,-49152
800022c6:	f0 1f 00 0a 	mcall	800022ec <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
800022ca:	30 0c       	mov	r12,0
800022cc:	f0 1f 00 09 	mcall	800022f0 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
800022d0:	30 4b       	mov	r11,4
800022d2:	48 9c       	lddpc	r12,800022f4 <tpa6130_dac_stop+0x38>
800022d4:	f0 1f 00 09 	mcall	800022f8 <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
800022d8:	48 98       	lddpc	r8,800022fc <tpa6130_dac_stop+0x40>
800022da:	30 09       	mov	r9,0
800022dc:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
800022de:	30 09       	mov	r9,0
800022e0:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
800022e2:	91 29       	st.w	r8[0x8],r9
}
800022e4:	d8 02       	popm	pc
800022e6:	00 00       	add	r0,r0
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	22 9c       	sub	r12,41
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	3b 10       	mov	r0,-79
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	40 94       	lddsp	r4,sp[0x24]
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	b2 30       	st.h	r9[0x6],r0
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	9d d0       	st.w	lr[0x34],r0
800022fc:	00 00       	add	r0,r0
800022fe:	05 40       	ld.w	r0,--r2

80002300 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
80002300:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
80002302:	36 0b       	mov	r11,96
80002304:	fe 7c 2c 00 	mov	r12,-54272
80002308:	f0 1f 00 0e 	mcall	80002340 <tpa6130_init+0x40>
8000230c:	c0 40       	breq	80002314 <tpa6130_init+0x14>
8000230e:	e0 6c 00 fd 	mov	r12,253
80002312:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
80002314:	30 0b       	mov	r11,0
80002316:	30 4c       	mov	r12,4
80002318:	f0 1f 00 0b 	mcall	80002344 <tpa6130_init+0x44>
8000231c:	30 28       	mov	r8,2
8000231e:	f0 0c 18 00 	cp.b	r12,r8
80002322:	c0 40       	breq	8000232a <tpa6130_init+0x2a>
80002324:	e0 6c 00 f8 	mov	r12,248
80002328:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
8000232a:	48 88       	lddpc	r8,80002348 <tpa6130_init+0x48>
8000232c:	11 9b       	ld.ub	r11,r8[0x1]
8000232e:	30 2c       	mov	r12,2
80002330:	f0 1f 00 07 	mcall	8000234c <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
80002334:	e0 6b 00 c0 	mov	r11,192
80002338:	30 1c       	mov	r12,1
8000233a:	f0 1f 00 05 	mcall	8000234c <tpa6130_init+0x4c>
8000233e:	d8 0a       	popm	pc,r12=0
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	46 7c       	lddsp	r12,sp[0x19c]
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	22 1c       	sub	r12,33
80002348:	00 00       	add	r0,r0
8000234a:	00 1c       	sub	r12,r0
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	21 40       	sub	r0,20

80002350 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002350:	eb cd 40 c0 	pushm	r6-r7,lr
80002354:	20 6d       	sub	sp,24
80002356:	18 97       	mov	r7,r12
80002358:	12 96       	mov	r6,r9
8000235a:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
8000235c:	49 a9       	lddpc	r9,800023c4 <tpa6130_dac_setup+0x74>
8000235e:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80002360:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
80002362:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
80002364:	f0 1f 00 19 	mcall	800023c8 <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
80002368:	0e 9c       	mov	r12,r7
8000236a:	f0 1f 00 19 	mcall	800023cc <tpa6130_dac_setup+0x7c>
8000236e:	c0 a1       	brne	80002382 <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
80002370:	0e 9a       	mov	r10,r7
80002372:	e0 6b 44 00 	mov	r11,17408
80002376:	ea 1b 00 ac 	orh	r11,0xac
8000237a:	fe 7c 40 00 	mov	r12,-49152
8000237e:	f0 1f 00 15 	mcall	800023d0 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
80002382:	58 06       	cp.w	r6,0
80002384:	c0 50       	breq	8000238e <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
80002386:	fe 7c 40 00 	mov	r12,-49152
8000238a:	f0 1f 00 13 	mcall	800023d4 <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
8000238e:	fe 7c 40 00 	mov	r12,-49152
80002392:	f0 1f 00 12 	mcall	800023d8 <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
80002396:	49 28       	lddpc	r8,800023dc <tpa6130_dac_setup+0x8c>
80002398:	1a 9b       	mov	r11,sp
8000239a:	f0 e6 00 00 	ld.d	r6,r8[0]
8000239e:	fa e7 00 00 	st.d	sp[0],r6
800023a2:	f0 e6 00 08 	ld.d	r6,r8[8]
800023a6:	fa e7 00 08 	st.d	sp[8],r6
800023aa:	f0 e8 00 10 	ld.d	r8,r8[16]
800023ae:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800023b2:	30 0c       	mov	r12,0
800023b4:	f0 1f 00 0b 	mcall	800023e0 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
800023b8:	30 0c       	mov	r12,0
800023ba:	f0 1f 00 0b 	mcall	800023e4 <tpa6130_dac_setup+0x94>

}
800023be:	2f ad       	sub	sp,-24
800023c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800023c4:	00 00       	add	r0,r0
800023c6:	05 40       	ld.w	r0,--r2
800023c8:	80 00       	ld.sh	r0,r0[0x0]
800023ca:	23 00       	sub	r0,48
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	3b bc       	mov	r12,-69
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	3b 3e       	mov	lr,-77
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	3b 26       	mov	r6,-78
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	3a fc       	mov	r12,-81
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	b2 18       	st.h	r9[0x2],r8
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	41 6c       	lddsp	r12,sp[0x58]
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	40 a4       	lddsp	r4,sp[0x28]

800023e8 <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
800023e8:	eb cd 40 fe 	pushm	r1-r7,lr
800023ec:	fa c4 ff e0 	sub	r4,sp,-32
800023f0:	18 92       	mov	r2,r12
800023f2:	16 93       	mov	r3,r11
800023f4:	14 95       	mov	r5,r10
800023f6:	12 97       	mov	r7,r9
800023f8:	10 96       	mov	r6,r8
800023fa:	68 01       	ld.w	r1,r4[0x0]
800023fc:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
800023fe:	f0 1f 00 0d 	mcall	80002430 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
80002402:	30 4b       	mov	r11,4
80002404:	48 cc       	lddpc	r12,80002434 <tpa6130_dac_start+0x4c>
80002406:	f0 1f 00 0d 	mcall	80002438 <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
8000240a:	1a d4       	st.w	--sp,r4
8000240c:	1a d1       	st.w	--sp,r1
8000240e:	0c 98       	mov	r8,r6
80002410:	0e 99       	mov	r9,r7
80002412:	0a 9a       	mov	r10,r5
80002414:	06 9b       	mov	r11,r3
80002416:	04 9c       	mov	r12,r2
80002418:	f0 1f 00 09 	mcall	8000243c <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
8000241c:	30 1a       	mov	r10,1
8000241e:	36 0b       	mov	r11,96
80002420:	48 8c       	lddpc	r12,80002440 <tpa6130_dac_start+0x58>
80002422:	f0 1f 00 09 	mcall	80002444 <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
80002426:	f0 1f 00 09 	mcall	80002448 <tpa6130_dac_start+0x60>
8000242a:	2f ed       	sub	sp,-8

}
8000242c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	22 bc       	sub	r12,43
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	b2 30       	st.h	r9[0x6],r0
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	9d 88       	st.w	lr[0x20],r8
8000243c:	80 00       	ld.sh	r0,r0[0x0]
8000243e:	23 50       	sub	r0,53
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	20 e0       	sub	r0,14
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	9e a8       	ld.uh	r8,pc[0x4]
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	22 7c       	sub	r12,39

8000244c <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
8000244c:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002450:	fc 1e c0 00 	movh	lr,0xc000
80002454:	30 28       	mov	r8,2
80002456:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002458:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
8000245c:	fc 18 c0 20 	movh	r8,0xc020
80002460:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002462:	30 37       	mov	r7,3
80002464:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002466:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002468:	30 4c       	mov	r12,4
8000246a:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000246c:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80002470:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002472:	30 5c       	mov	r12,5
80002474:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002476:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002478:	30 6a       	mov	r10,6
8000247a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000247c:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80002480:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002482:	30 7a       	mov	r10,7
80002484:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002486:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002488:	30 8a       	mov	r10,8
8000248a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000248c:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80002490:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002492:	30 9a       	mov	r10,9
80002494:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002496:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80002498:	e3 cd 80 80 	ldm	sp++,r7,pc

8000249c <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000249c:	fc 19 c0 00 	movh	r9,0xc000
800024a0:	30 28       	mov	r8,2
800024a2:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024a4:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
800024a8:	fc 18 c0 20 	movh	r8,0xc020
800024ac:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024ae:	30 3a       	mov	r10,3
800024b0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024b2:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024b4:	30 6a       	mov	r10,6
800024b6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024b8:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
800024bc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024be:	30 7a       	mov	r10,7
800024c0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024c2:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
800024c4:	5e fc       	retal	r12
800024c6:	d7 03       	nop

800024c8 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
800024c8:	eb cd 40 80 	pushm	r7,lr
800024cc:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
800024ce:	5c 7b       	castu.h	r11
800024d0:	5c 7c       	castu.h	r12
800024d2:	f0 1f 00 06 	mcall	800024e8 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024d6:	32 29       	mov	r9,34
800024d8:	fc 18 c0 00 	movh	r8,0xc000
800024dc:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
800024de:	fc 18 c0 20 	movh	r8,0xc020
800024e2:	b0 07       	st.h	r8[0x0],r7
#endif

}
800024e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	24 9c       	sub	r12,73

800024ec <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
800024ec:	d4 31       	pushm	r0-r7,lr
800024ee:	20 dd       	sub	sp,52
800024f0:	18 97       	mov	r7,r12
800024f2:	50 6b       	stdsp	sp[0x18],r11
800024f4:	50 8a       	stdsp	sp[0x20],r10
800024f6:	50 29       	stdsp	sp[0x8],r9
800024f8:	10 94       	mov	r4,r8
800024fa:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
800024fc:	19 89       	ld.ub	r9,r12[0x0]
800024fe:	30 08       	mov	r8,0
80002500:	f0 09 18 00 	cp.b	r9,r8
80002504:	e0 80 01 0c 	breq	8000271c <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
80002508:	16 98       	mov	r8,r11
8000250a:	11 3a       	ld.ub	r10,r8++
8000250c:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
8000250e:	11 89       	ld.ub	r9,r8[0x0]
80002510:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
80002512:	11 98       	ld.ub	r8,r8[0x1]
80002514:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
80002516:	5b f3       	cp.w	r3,-1
80002518:	e0 81 00 8d 	brne	80002632 <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
8000251c:	e0 69 00 ef 	mov	r9,239
80002520:	e0 6a 01 3f 	mov	r10,319
80002524:	30 0b       	mov	r11,0
80002526:	16 9c       	mov	r12,r11
80002528:	f0 1f 00 7e 	mcall	80002720 <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
8000252c:	40 58       	lddsp	r8,sp[0x14]
8000252e:	50 c8       	stdsp	sp[0x30],r8
80002530:	f0 08 00 18 	add	r8,r8,r8<<0x1
80002534:	a5 78       	lsl	r8,0x5
80002536:	40 69       	lddsp	r9,sp[0x18]
80002538:	10 09       	add	r9,r8
8000253a:	50 b9       	stdsp	sp[0x2c],r9
8000253c:	ee c8 ff ff 	sub	r8,r7,-1
80002540:	50 98       	stdsp	sp[0x24],r8
80002542:	40 8a       	lddsp	r10,sp[0x20]
80002544:	5c 8a       	casts.h	r10
80002546:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002548:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000254a:	08 90       	mov	r0,r4
8000254c:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
8000254e:	40 99       	lddsp	r9,sp[0x24]
80002550:	f3 38 ff ff 	ld.ub	r8,r9[-1]
80002554:	30 aa       	mov	r10,10
80002556:	f4 08 18 00 	cp.b	r8,r10
8000255a:	c0 b1       	brne	80002570 <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
8000255c:	40 28       	lddsp	r8,sp[0x8]
8000255e:	40 39       	lddsp	r9,sp[0xc]
80002560:	12 08       	add	r8,r9
80002562:	5c 88       	casts.h	r8
80002564:	50 28       	stdsp	sp[0x8],r8
80002566:	40 98       	lddsp	r8,sp[0x24]
80002568:	40 8a       	lddsp	r10,sp[0x20]
8000256a:	5c 8a       	casts.h	r10
8000256c:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000256e:	c5 a8       	rjmp	80002622 <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
80002570:	30 99       	mov	r9,9
80002572:	f2 08 18 00 	cp.b	r8,r9
80002576:	c0 81       	brne	80002586 <et024006_PrintString+0x9a>
        x += xfont;
80002578:	40 a8       	lddsp	r8,sp[0x28]
8000257a:	40 49       	lddsp	r9,sp[0x10]
8000257c:	12 08       	add	r8,r9
8000257e:	5c 88       	casts.h	r8
80002580:	50 a8       	stdsp	sp[0x28],r8
80002582:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80002584:	c4 f8       	rjmp	80002622 <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80002586:	f0 ca 00 20 	sub	r10,r8,32
8000258a:	35 f9       	mov	r9,95
8000258c:	f2 0a 18 00 	cp.b	r10,r9
80002590:	e0 88 00 04 	brls	80002598 <et024006_PrintString+0xac>
80002594:	40 b5       	lddsp	r5,sp[0x2c]
80002596:	c0 a8       	rjmp	800025aa <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80002598:	22 08       	sub	r8,32
8000259a:	40 ca       	lddsp	r10,sp[0x30]
8000259c:	f0 0a 02 45 	mul	r5,r8,r10
800025a0:	40 59       	lddsp	r9,sp[0x14]
800025a2:	12 05       	add	r5,r9
800025a4:	40 68       	lddsp	r8,sp[0x18]
800025a6:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800025aa:	40 22       	lddsp	r2,sp[0x8]
800025ac:	5c 72       	castu.h	r2
800025ae:	40 3a       	lddsp	r10,sp[0xc]
800025b0:	e4 0a 00 0a 	add	r10,r2,r10
800025b4:	50 1a       	stdsp	sp[0x4],r10
800025b6:	04 3a       	cp.w	r10,r2
800025b8:	e0 8a 00 2f 	brle	80002616 <et024006_PrintString+0x12a>
800025bc:	40 21       	lddsp	r1,sp[0x8]
800025be:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800025c0:	40 a9       	lddsp	r9,sp[0x28]
800025c2:	5c 79       	castu.h	r9
800025c4:	50 09       	stdsp	sp[0x0],r9
800025c6:	12 94       	mov	r4,r9
800025c8:	40 48       	lddsp	r8,sp[0x10]
800025ca:	10 04       	add	r4,r8
800025cc:	40 aa       	lddsp	r10,sp[0x28]
800025ce:	5c 8a       	casts.h	r10
800025d0:	50 7a       	stdsp	sp[0x1c],r10
800025d2:	c1 b8       	rjmp	80002608 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
800025d4:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
800025d6:	0b 88       	ld.ub	r8,r5[0x0]
800025d8:	ed e8 00 08 	and	r8,r6,r8
800025dc:	e6 08 18 00 	cp.b	r8,r3
800025e0:	c0 50       	breq	800025ea <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800025e2:	00 9a       	mov	r10,r0
800025e4:	04 9b       	mov	r11,r2
800025e6:	f0 1f 00 50 	mcall	80002724 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800025ea:	2f f7       	sub	r7,-1
800025ec:	5c 87       	casts.h	r7
800025ee:	0e 9c       	mov	r12,r7
800025f0:	5c 7c       	castu.h	r12
800025f2:	08 3c       	cp.w	r12,r4
800025f4:	cf 05       	brlt	800025d4 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800025f6:	2f f1       	sub	r1,-1
800025f8:	5c 81       	casts.h	r1
800025fa:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
800025fe:	40 19       	lddsp	r9,sp[0x4]
80002600:	04 39       	cp.w	r9,r2
80002602:	e0 8a 00 0a 	brle	80002616 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
80002606:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80002608:	40 0c       	lddsp	r12,sp[0x0]
8000260a:	08 3c       	cp.w	r12,r4
8000260c:	cf 54       	brge	800025f6 <et024006_PrintString+0x10a>
8000260e:	40 77       	lddsp	r7,sp[0x1c]
80002610:	e0 66 00 80 	mov	r6,128
80002614:	ce 1b       	rjmp	800025d6 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
80002616:	40 a8       	lddsp	r8,sp[0x28]
80002618:	40 4a       	lddsp	r10,sp[0x10]
8000261a:	14 08       	add	r8,r10
8000261c:	5c 88       	casts.h	r8
8000261e:	50 a8       	stdsp	sp[0x28],r8
80002620:	40 98       	lddsp	r8,sp[0x24]
80002622:	40 99       	lddsp	r9,sp[0x24]
80002624:	2f f9       	sub	r9,-1
80002626:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
80002628:	11 88       	ld.ub	r8,r8[0x0]
8000262a:	e6 08 18 00 	cp.b	r8,r3
8000262e:	c9 01       	brne	8000254e <et024006_PrintString+0x62>
80002630:	c7 68       	rjmp	8000271c <et024006_PrintString+0x230>
80002632:	f8 c8 ff ff 	sub	r8,r12,-1
80002636:	50 08       	stdsp	sp[0x0],r8
80002638:	40 8c       	lddsp	r12,sp[0x20]
8000263a:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000263c:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000263e:	5c 83       	casts.h	r3
80002640:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80002644:	40 0a       	lddsp	r10,sp[0x0]
80002646:	f5 31 ff ff 	ld.ub	r1,r10[-1]
8000264a:	30 a8       	mov	r8,10
8000264c:	f0 01 18 00 	cp.b	r1,r8
80002650:	c0 b1       	brne	80002666 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
80002652:	40 28       	lddsp	r8,sp[0x8]
80002654:	40 39       	lddsp	r9,sp[0xc]
80002656:	12 08       	add	r8,r9
80002658:	5c 88       	casts.h	r8
8000265a:	50 28       	stdsp	sp[0x8],r8
8000265c:	14 98       	mov	r8,r10
8000265e:	40 8a       	lddsp	r10,sp[0x20]
80002660:	5c 8a       	casts.h	r10
80002662:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80002664:	c5 28       	rjmp	80002708 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80002666:	30 98       	mov	r8,9
80002668:	f0 01 18 00 	cp.b	r1,r8
8000266c:	c0 71       	brne	8000267a <et024006_PrintString+0x18e>
        x += xfont;
8000266e:	40 49       	lddsp	r9,sp[0x10]
80002670:	12 0c       	add	r12,r9
80002672:	5c 8c       	casts.h	r12
80002674:	50 1c       	stdsp	sp[0x4],r12
80002676:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
80002678:	c4 88       	rjmp	80002708 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000267a:	40 32       	lddsp	r2,sp[0xc]
8000267c:	40 47       	lddsp	r7,sp[0x10]
8000267e:	f8 07 00 08 	add	r8,r12,r7
80002682:	5c 88       	casts.h	r8
80002684:	50 18       	stdsp	sp[0x4],r8
80002686:	04 99       	mov	r9,r2
80002688:	20 19       	sub	r9,1
8000268a:	40 28       	lddsp	r8,sp[0x8]
8000268c:	10 09       	add	r9,r8
8000268e:	40 1a       	lddsp	r10,sp[0x4]
80002690:	20 1a       	sub	r10,1
80002692:	5c 79       	castu.h	r9
80002694:	5c 7a       	castu.h	r10
80002696:	10 9b       	mov	r11,r8
80002698:	5c 7b       	castu.h	r11
8000269a:	5c 7c       	castu.h	r12
8000269c:	f0 1f 00 21 	mcall	80002720 <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026a0:	32 29       	mov	r9,34
800026a2:	fc 18 c0 00 	movh	r8,0xc000
800026a6:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800026a8:	40 3a       	lddsp	r10,sp[0xc]
800026aa:	58 0a       	cp.w	r10,0
800026ac:	c2 d0       	breq	80002706 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
800026ae:	e2 ce 00 20 	sub	lr,r1,32
800026b2:	40 59       	lddsp	r9,sp[0x14]
800026b4:	f2 0e 02 4e 	mul	lr,r9,lr
800026b8:	12 0e       	add	lr,r9
800026ba:	40 68       	lddsp	r8,sp[0x18]
800026bc:	f0 0e 00 0e 	add	lr,r8,lr
800026c0:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800026c2:	e0 60 00 80 	mov	r0,128
800026c6:	18 91       	mov	r1,r12
800026c8:	c1 98       	rjmp	800026fa <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
800026ca:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800026cc:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
800026d0:	ec 0a 18 00 	cp.b	r10,r6
800026d4:	e8 0a 17 10 	movne	r10,r4
800026d8:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800026dc:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800026e0:	2f f8       	sub	r8,-1
800026e2:	5c 88       	casts.h	r8
800026e4:	f0 07 19 00 	cp.h	r7,r8
800026e8:	fe 9b ff f1 	brhi	800026ca <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800026ec:	2f fc       	sub	r12,-1
800026ee:	5c 8c       	casts.h	r12
800026f0:	f8 02 19 00 	cp.h	r2,r12
800026f4:	e0 88 00 09 	brls	80002706 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
800026f8:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800026fa:	58 07       	cp.w	r7,0
800026fc:	cf 80       	breq	800026ec <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
800026fe:	1d 8b       	ld.ub	r11,lr[0x0]
80002700:	00 99       	mov	r9,r0
80002702:	02 98       	mov	r8,r1
80002704:	ce 4b       	rjmp	800026cc <et024006_PrintString+0x1e0>
80002706:	40 08       	lddsp	r8,sp[0x0]
80002708:	40 09       	lddsp	r9,sp[0x0]
8000270a:	2f f9       	sub	r9,-1
8000270c:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
8000270e:	11 88       	ld.ub	r8,r8[0x0]
80002710:	ec 08 18 00 	cp.b	r8,r6
80002714:	c0 40       	breq	8000271c <et024006_PrintString+0x230>
80002716:	40 1c       	lddsp	r12,sp[0x4]
80002718:	5c 8c       	casts.h	r12
8000271a:	c9 5b       	rjmp	80002644 <et024006_PrintString+0x158>
  }
}
8000271c:	2f 3d       	sub	sp,-52
8000271e:	d8 32       	popm	r0-r7,pc
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	24 4c       	sub	r12,68
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	24 c8       	sub	r8,76

80002728 <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002728:	32 29       	mov	r9,34
8000272a:	fc 18 c0 00 	movh	r8,0xc000
8000272e:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
80002730:	58 7b       	cp.w	r11,7
80002732:	e0 88 00 13 	brls	80002758 <et024006_DuplicatePixel+0x30>
80002736:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
80002738:	fc 18 c0 20 	movh	r8,0xc020
8000273c:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000273e:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002740:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002742:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002744:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002746:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002748:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000274a:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
8000274c:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000274e:	58 79       	cp.w	r9,7
80002750:	fe 9b ff f6 	brhi	8000273c <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80002754:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002758:	58 0b       	cp.w	r11,0
8000275a:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
8000275c:	fc 18 c0 20 	movh	r8,0xc020
80002760:	b0 0c       	st.h	r8[0x0],r12
    --count;
80002762:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002764:	cf e1       	brne	80002760 <et024006_DuplicatePixel+0x38>
80002766:	5e fc       	retal	r12

80002768 <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80002768:	eb cd 40 e0 	pushm	r5-r7,lr
8000276c:	14 97       	mov	r7,r10
8000276e:	12 96       	mov	r6,r9
80002770:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80002772:	f6 c9 00 01 	sub	r9,r11,1
80002776:	0c 09       	add	r9,r6
80002778:	f8 ca 00 01 	sub	r10,r12,1
8000277c:	0e 0a       	add	r10,r7
8000277e:	5c 79       	castu.h	r9
80002780:	5c 7a       	castu.h	r10
80002782:	5c 7b       	castu.h	r11
80002784:	5c 7c       	castu.h	r12
80002786:	f0 1f 00 07 	mcall	800027a0 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000278a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000278e:	5c 77       	castu.h	r7
80002790:	af 3b       	mul	r11,r7
80002792:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80002796:	f0 1f 00 04 	mcall	800027a4 <et024006_DrawFilledRect+0x3c>
}
8000279a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	24 4c       	sub	r12,68
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	27 28       	sub	r8,114

800027a8 <et024006_DrawVertLine>:
  et024006_DrawFilledRect( x, y, length, 1, color );
}


void et024006_DrawVertLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
800027a8:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, 1, length, color );
800027aa:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800027ae:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800027b2:	30 1a       	mov	r10,1
800027b4:	5c 7b       	castu.h	r11
800027b6:	5c 7c       	castu.h	r12
800027b8:	f0 1f 00 02 	mcall	800027c0 <et024006_DrawVertLine+0x18>
}
800027bc:	d8 02       	popm	pc
800027be:	00 00       	add	r0,r0
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	27 68       	sub	r8,118

800027c4 <et024006_DrawHorizLine>:
  return color;
}


void et024006_DrawHorizLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
800027c4:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, length, 1, color );
800027c6:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800027ca:	30 19       	mov	r9,1
800027cc:	5c 7a       	castu.h	r10
800027ce:	5c 7b       	castu.h	r11
800027d0:	5c 7c       	castu.h	r12
800027d2:	f0 1f 00 02 	mcall	800027d8 <et024006_DrawHorizLine+0x14>
}
800027d6:	d8 02       	popm	pc
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	27 68       	sub	r8,118

800027dc <et024006_CopyPixelsToScreen>:
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
{
800027dc:	eb cd 40 80 	pushm	r7,lr
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027e0:	32 29       	mov	r9,34
800027e2:	fc 18 c0 00 	movh	r8,0xc000
800027e6:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
800027e8:	58 7b       	cp.w	r11,7
800027ea:	e0 88 00 23 	brls	80002830 <et024006_CopyPixelsToScreen+0x54>
800027ee:	16 9a       	mov	r10,r11
800027f0:	18 98       	mov	r8,r12
  {
    *ET024006_PARAM_ADDR = *pixels++;
800027f2:	fc 19 c0 20 	movh	r9,0xc020
800027f6:	90 0e       	ld.sh	lr,r8[0x0]
800027f8:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800027fa:	90 1e       	ld.sh	lr,r8[0x2]
800027fc:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800027fe:	90 2e       	ld.sh	lr,r8[0x4]
80002800:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80002802:	90 3e       	ld.sh	lr,r8[0x6]
80002804:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80002806:	90 4e       	ld.sh	lr,r8[0x8]
80002808:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
8000280a:	90 5e       	ld.sh	lr,r8[0xa]
8000280c:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
8000280e:	90 6e       	ld.sh	lr,r8[0xc]
80002810:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80002812:	90 7e       	ld.sh	lr,r8[0xe]
80002814:	b2 0e       	st.h	r9[0x0],lr
    }
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
80002816:	2f 08       	sub	r8,-16
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
80002818:	20 8a       	sub	r10,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
8000281a:	58 7a       	cp.w	r10,7
8000281c:	fe 9b ff ed 	brhi	800027f6 <et024006_CopyPixelsToScreen+0x1a>
    }
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
80002820:	20 8b       	sub	r11,8
80002822:	f6 08 16 03 	lsr	r8,r11,0x3
80002826:	2f f8       	sub	r8,-1
80002828:	a5 68       	lsl	r8,0x4
8000282a:	10 0c       	add	r12,r8
8000282c:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80002830:	58 0b       	cp.w	r11,0
80002832:	c0 70       	breq	80002840 <et024006_CopyPixelsToScreen+0x64>
  {
    *ET024006_PARAM_ADDR = *pixels;
80002834:	fc 18 c0 20 	movh	r8,0xc020
80002838:	19 19       	ld.sh	r9,r12++
8000283a:	b0 09       	st.h	r8[0x0],r9
    pixels++;
    count--;
8000283c:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
8000283e:	cf d1       	brne	80002838 <et024006_CopyPixelsToScreen+0x5c>
80002840:	e3 cd 80 80 	ldm	sp++,r7,pc

80002844 <et024006_PutPixmap>:
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
80002844:	eb cd 40 fe 	pushm	r1-r7,lr
80002848:	fa c4 ff e0 	sub	r4,sp,-32
8000284c:	18 97       	mov	r7,r12
8000284e:	16 95       	mov	r5,r11
80002850:	14 92       	mov	r2,r10
80002852:	12 91       	mov	r1,r9
80002854:	68 0b       	ld.w	r11,r4[0x0]
80002856:	68 13       	ld.w	r3,r4[0x4]
80002858:	68 26       	ld.w	r6,r4[0x8]
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits( x, y, x2, y2 );
8000285a:	f6 c9 00 01 	sub	r9,r11,1
8000285e:	0c 09       	add	r9,r6
80002860:	f0 ca 00 01 	sub	r10,r8,1
80002864:	06 0a       	add	r10,r3
80002866:	5c 79       	castu.h	r9
80002868:	5c 7a       	castu.h	r10
8000286a:	5c 7b       	castu.h	r11
8000286c:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80002870:	f0 1f 00 1d 	mcall	800028e4 <et024006_PutPixmap+0xa0>

  // Offset into pixmap.
  pixmap += map_x;
80002874:	f1 d2 c0 10 	bfextu	r8,r2,0x0,0x10
80002878:	ee 08 00 17 	add	r7,r7,r8<<0x1
  if (map_y > 0) {
8000287c:	58 01       	cp.w	r1,0
8000287e:	c0 70       	breq	8000288c <et024006_PutPixmap+0x48>
    pixmap += (uint32_t) map_y * map_width;
80002880:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002884:	a1 78       	lsl	r8,0x1
80002886:	5c 71       	castu.h	r1
80002888:	f0 01 03 47 	mac	r7,r8,r1
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000288c:	32 29       	mov	r9,34
8000288e:	fc 18 c0 00 	movh	r8,0xc000
80002892:	b0 09       	st.h	r8[0x0],r9
  }
  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
80002894:	e6 05 19 00 	cp.h	r5,r3
80002898:	5f 0a       	sreq	r10
8000289a:	30 08       	mov	r8,0
8000289c:	f0 02 19 00 	cp.h	r2,r8
800028a0:	5f 09       	sreq	r9
800028a2:	f5 e9 00 09 	and	r9,r10,r9
800028a6:	f0 09 18 00 	cp.b	r9,r8
800028aa:	c0 51       	brne	800028b4 <et024006_PutPixmap+0x70>
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
800028ac:	58 06       	cp.w	r6,0
800028ae:	c0 c1       	brne	800028c6 <et024006_PutPixmap+0x82>
800028b0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
800028b4:	5c 76       	castu.h	r6
800028b6:	5c 73       	castu.h	r3
800028b8:	ec 03 02 4b 	mul	r11,r6,r3
800028bc:	0e 9c       	mov	r12,r7
800028be:	f0 1f 00 0b 	mcall	800028e8 <et024006_PutPixmap+0xa4>
800028c2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
800028c6:	5c 75       	castu.h	r5
800028c8:	a1 75       	lsl	r5,0x1
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
800028ca:	e9 d3 c0 10 	bfextu	r4,r3,0x0,0x10
800028ce:	08 9b       	mov	r11,r4
800028d0:	0e 9c       	mov	r12,r7
800028d2:	f0 1f 00 06 	mcall	800028e8 <et024006_PutPixmap+0xa4>
      pixmap += map_width;
800028d6:	0a 07       	add	r7,r5
      --lines_left;
800028d8:	20 16       	sub	r6,1
800028da:	5c 86       	casts.h	r6
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
800028dc:	cf 91       	brne	800028ce <et024006_PutPixmap+0x8a>
800028de:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800028e2:	00 00       	add	r0,r0
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	24 4c       	sub	r12,68
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	27 dc       	sub	r12,125

800028ec <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028ec:	fc 19 c0 00 	movh	r9,0xc000
800028f0:	34 6a       	mov	r10,70
800028f2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800028f4:	fc 18 c0 20 	movh	r8,0xc020
800028f8:	e0 6b 00 94 	mov	r11,148
800028fc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028fe:	34 7b       	mov	r11,71
80002900:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002902:	34 1b       	mov	r11,65
80002904:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002906:	34 8b       	mov	r11,72
80002908:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000290a:	30 0b       	mov	r11,0
8000290c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000290e:	34 9b       	mov	r11,73
80002910:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002912:	33 3b       	mov	r11,51
80002914:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002916:	34 ab       	mov	r11,74
80002918:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000291a:	32 5b       	mov	r11,37
8000291c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000291e:	34 bb       	mov	r11,75
80002920:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002922:	34 5b       	mov	r11,69
80002924:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002926:	34 cb       	mov	r11,76
80002928:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000292a:	34 4b       	mov	r11,68
8000292c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000292e:	34 db       	mov	r11,77
80002930:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002932:	37 7b       	mov	r11,119
80002934:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002936:	34 eb       	mov	r11,78
80002938:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000293a:	31 2b       	mov	r11,18
8000293c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000293e:	34 fb       	mov	r11,79
80002940:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002942:	e0 6b 00 cc 	mov	r11,204
80002946:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002948:	35 0b       	mov	r11,80
8000294a:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000294c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000294e:	35 1a       	mov	r10,81
80002950:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002952:	e0 69 00 82 	mov	r9,130
80002956:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
80002958:	5e fc       	retal	r12
8000295a:	d7 03       	nop

8000295c <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
8000295c:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
80002960:	fe f7 04 80 	ld.w	r7,pc[1152]
80002964:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
80002966:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80002968:	16 9c       	mov	r12,r11
8000296a:	f0 1f 01 1f 	mcall	80002de4 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
8000296e:	35 5c       	mov	r12,85
80002970:	f0 1f 01 1e 	mcall	80002de8 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
80002974:	30 2b       	mov	r11,2
80002976:	33 2c       	mov	r12,50
80002978:	f0 1f 01 1d 	mcall	80002dec <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
8000297c:	35 2c       	mov	r12,82
8000297e:	f0 1f 01 1d 	mcall	80002df0 <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
80002982:	35 2c       	mov	r12,82
80002984:	f0 1f 01 1c 	mcall	80002df4 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002988:	6e 07       	ld.w	r7,r7[0x0]
8000298a:	33 28       	mov	r8,50
8000298c:	ee 08 06 46 	mulu.d	r6,r7,r8
80002990:	ee 78 42 40 	mov	r8,1000000
80002994:	30 09       	mov	r9,0
80002996:	ee 7a 42 3f 	mov	r10,999999
8000299a:	30 0b       	mov	r11,0
8000299c:	ec 0a 00 0a 	add	r10,r6,r10
800029a0:	ee 0b 00 4b 	adc	r11,r7,r11
800029a4:	f0 1f 01 15 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800029a8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800029ac:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800029b0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029b4:	14 38       	cp.w	r8,r10
800029b6:	e0 88 00 09 	brls	800029c8 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029ba:	12 38       	cp.w	r8,r9
800029bc:	fe 98 ff fa 	brls	800029b0 <et024006_Init+0x54>
800029c0:	12 3a       	cp.w	r10,r9
800029c2:	e0 83 00 a2 	brlo	80002b06 <et024006_Init+0x1aa>
800029c6:	cf 5b       	rjmp	800029b0 <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800029c8:	12 38       	cp.w	r8,r9
800029ca:	e0 8b 00 9e 	brhi	80002b06 <et024006_Init+0x1aa>
800029ce:	12 3a       	cp.w	r10,r9
800029d0:	e0 83 00 9b 	brlo	80002b06 <et024006_Init+0x1aa>
800029d4:	ce eb       	rjmp	800029b0 <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800029d6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029da:	14 38       	cp.w	r8,r10
800029dc:	e0 88 00 09 	brls	800029ee <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029e0:	12 38       	cp.w	r8,r9
800029e2:	fe 98 ff fa 	brls	800029d6 <et024006_Init+0x7a>
800029e6:	12 3a       	cp.w	r10,r9
800029e8:	e0 83 00 a9 	brlo	80002b3a <et024006_Init+0x1de>
800029ec:	cf 5b       	rjmp	800029d6 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800029ee:	12 38       	cp.w	r8,r9
800029f0:	e0 8b 00 a5 	brhi	80002b3a <et024006_Init+0x1de>
800029f4:	12 3a       	cp.w	r10,r9
800029f6:	e0 83 00 a2 	brlo	80002b3a <et024006_Init+0x1de>
800029fa:	ce eb       	rjmp	800029d6 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800029fc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a00:	14 38       	cp.w	r8,r10
80002a02:	e0 88 00 09 	brls	80002a14 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a06:	12 38       	cp.w	r8,r9
80002a08:	fe 98 ff fa 	brls	800029fc <et024006_Init+0xa0>
80002a0c:	12 3a       	cp.w	r10,r9
80002a0e:	e0 83 01 1e 	brlo	80002c4a <et024006_Init+0x2ee>
80002a12:	cf 5b       	rjmp	800029fc <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a14:	12 38       	cp.w	r8,r9
80002a16:	e0 8b 01 1a 	brhi	80002c4a <et024006_Init+0x2ee>
80002a1a:	12 3a       	cp.w	r10,r9
80002a1c:	e0 83 01 17 	brlo	80002c4a <et024006_Init+0x2ee>
80002a20:	ce eb       	rjmp	800029fc <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a22:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a26:	14 38       	cp.w	r8,r10
80002a28:	e0 88 00 09 	brls	80002a3a <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a2c:	12 38       	cp.w	r8,r9
80002a2e:	fe 98 ff fa 	brls	80002a22 <et024006_Init+0xc6>
80002a32:	12 3a       	cp.w	r10,r9
80002a34:	e0 83 01 29 	brlo	80002c86 <et024006_Init+0x32a>
80002a38:	cf 5b       	rjmp	80002a22 <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a3a:	12 38       	cp.w	r8,r9
80002a3c:	e0 8b 01 25 	brhi	80002c86 <et024006_Init+0x32a>
80002a40:	12 3a       	cp.w	r10,r9
80002a42:	e0 83 01 22 	brlo	80002c86 <et024006_Init+0x32a>
80002a46:	ce eb       	rjmp	80002a22 <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a48:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a4c:	14 38       	cp.w	r8,r10
80002a4e:	e0 88 00 09 	brls	80002a60 <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a52:	12 38       	cp.w	r8,r9
80002a54:	fe 98 ff fa 	brls	80002a48 <et024006_Init+0xec>
80002a58:	12 3a       	cp.w	r10,r9
80002a5a:	e0 83 01 35 	brlo	80002cc4 <et024006_Init+0x368>
80002a5e:	cf 5b       	rjmp	80002a48 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a60:	12 38       	cp.w	r8,r9
80002a62:	e0 8b 01 31 	brhi	80002cc4 <et024006_Init+0x368>
80002a66:	12 3a       	cp.w	r10,r9
80002a68:	e0 83 01 2e 	brlo	80002cc4 <et024006_Init+0x368>
80002a6c:	ce eb       	rjmp	80002a48 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a6e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a72:	14 38       	cp.w	r8,r10
80002a74:	e0 88 00 09 	brls	80002a86 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a78:	12 38       	cp.w	r8,r9
80002a7a:	fe 98 ff fa 	brls	80002a6e <et024006_Init+0x112>
80002a7e:	12 3a       	cp.w	r10,r9
80002a80:	e0 83 01 40 	brlo	80002d00 <et024006_Init+0x3a4>
80002a84:	cf 5b       	rjmp	80002a6e <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a86:	12 38       	cp.w	r8,r9
80002a88:	e0 8b 01 3c 	brhi	80002d00 <et024006_Init+0x3a4>
80002a8c:	12 3a       	cp.w	r10,r9
80002a8e:	e0 83 01 39 	brlo	80002d00 <et024006_Init+0x3a4>
80002a92:	ce eb       	rjmp	80002a6e <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a94:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a98:	14 38       	cp.w	r8,r10
80002a9a:	e0 88 00 09 	brls	80002aac <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a9e:	12 38       	cp.w	r8,r9
80002aa0:	fe 98 ff fa 	brls	80002a94 <et024006_Init+0x138>
80002aa4:	12 3a       	cp.w	r10,r9
80002aa6:	e0 83 01 4b 	brlo	80002d3c <et024006_Init+0x3e0>
80002aaa:	cf 5b       	rjmp	80002a94 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002aac:	12 38       	cp.w	r8,r9
80002aae:	e0 8b 01 47 	brhi	80002d3c <et024006_Init+0x3e0>
80002ab2:	12 3a       	cp.w	r10,r9
80002ab4:	e0 83 01 44 	brlo	80002d3c <et024006_Init+0x3e0>
80002ab8:	ce eb       	rjmp	80002a94 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002aba:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002abe:	14 38       	cp.w	r8,r10
80002ac0:	e0 88 00 09 	brls	80002ad2 <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002ac4:	12 38       	cp.w	r8,r9
80002ac6:	fe 98 ff fa 	brls	80002aba <et024006_Init+0x15e>
80002aca:	12 3a       	cp.w	r10,r9
80002acc:	e0 83 01 56 	brlo	80002d78 <et024006_Init+0x41c>
80002ad0:	cf 5b       	rjmp	80002aba <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002ad2:	12 38       	cp.w	r8,r9
80002ad4:	e0 8b 01 52 	brhi	80002d78 <et024006_Init+0x41c>
80002ad8:	12 3a       	cp.w	r10,r9
80002ada:	e0 83 01 4f 	brlo	80002d78 <et024006_Init+0x41c>
80002ade:	ce eb       	rjmp	80002aba <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002ae0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002ae4:	14 38       	cp.w	r8,r10
80002ae6:	e0 88 00 09 	brls	80002af8 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002aea:	12 38       	cp.w	r8,r9
80002aec:	fe 98 ff fa 	brls	80002ae0 <et024006_Init+0x184>
80002af0:	12 3a       	cp.w	r10,r9
80002af2:	e0 83 01 64 	brlo	80002dba <et024006_Init+0x45e>
80002af6:	cf 5b       	rjmp	80002ae0 <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002af8:	12 38       	cp.w	r8,r9
80002afa:	e0 8b 01 60 	brhi	80002dba <et024006_Init+0x45e>
80002afe:	12 3a       	cp.w	r10,r9
80002b00:	e0 83 01 5d 	brlo	80002dba <et024006_Init+0x45e>
80002b04:	ce eb       	rjmp	80002ae0 <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80002b06:	35 2c       	mov	r12,82
80002b08:	f0 1f 00 ba 	mcall	80002df0 <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002b0c:	fe f8 02 d4 	ld.w	r8,pc[724]
80002b10:	70 07       	ld.w	r7,r8[0x0]
80002b12:	30 58       	mov	r8,5
80002b14:	ee 08 06 46 	mulu.d	r6,r7,r8
80002b18:	e0 68 03 e8 	mov	r8,1000
80002b1c:	30 09       	mov	r9,0
80002b1e:	e0 6a 03 e7 	mov	r10,999
80002b22:	30 0b       	mov	r11,0
80002b24:	ec 0a 00 0a 	add	r10,r6,r10
80002b28:	ee 0b 00 4b 	adc	r11,r7,r11
80002b2c:	f0 1f 00 b3 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002b30:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002b34:	f0 0a 00 0a 	add	r10,r8,r10
80002b38:	c4 fb       	rjmp	800029d6 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
80002b3a:	f0 1f 00 b1 	mcall	80002dfc <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b3e:	fc 19 c0 00 	movh	r9,0xc000
80002b42:	30 1a       	mov	r10,1
80002b44:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b46:	fc 18 c0 20 	movh	r8,0xc020
80002b4a:	30 6b       	mov	r11,6
80002b4c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b4e:	33 ab       	mov	r11,58
80002b50:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b52:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b54:	33 bb       	mov	r11,59
80002b56:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b58:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b5a:	33 ca       	mov	r10,60
80002b5c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b5e:	e0 6a 00 f0 	mov	r10,240
80002b62:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b64:	33 db       	mov	r11,61
80002b66:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b68:	30 07       	mov	r7,0
80002b6a:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b6c:	33 eb       	mov	r11,62
80002b6e:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b70:	33 8b       	mov	r11,56
80002b72:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b74:	34 0c       	mov	r12,64
80002b76:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b78:	30 fe       	mov	lr,15
80002b7a:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b7c:	34 1e       	mov	lr,65
80002b7e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b80:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b82:	32 7a       	mov	r10,39
80002b84:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b86:	30 2a       	mov	r10,2
80002b88:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b8a:	32 8e       	mov	lr,40
80002b8c:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b8e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b90:	32 9e       	mov	lr,41
80002b92:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b94:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b96:	32 ae       	mov	lr,42
80002b98:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b9a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b9c:	32 ce       	mov	lr,44
80002b9e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002ba0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002ba2:	32 de       	mov	lr,45
80002ba4:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002ba6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002ba8:	31 9a       	mov	r10,25
80002baa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bac:	34 9a       	mov	r10,73
80002bae:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bb0:	e0 6a 00 93 	mov	r10,147
80002bb4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bb6:	30 8a       	mov	r10,8
80002bb8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bba:	31 6a       	mov	r10,22
80002bbc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bbe:	36 8a       	mov	r10,104
80002bc0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bc2:	32 3a       	mov	r10,35
80002bc4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bc6:	e0 6a 00 95 	mov	r10,149
80002bca:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bcc:	32 4e       	mov	lr,36
80002bce:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bd0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bd2:	32 5a       	mov	r10,37
80002bd4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bd6:	e0 6a 00 ff 	mov	r10,255
80002bda:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bdc:	e0 6a 00 90 	mov	r10,144
80002be0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002be2:	37 fa       	mov	r10,127
80002be4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002be6:	33 5a       	mov	r10,53
80002be8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bea:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bec:	33 6a       	mov	r10,54
80002bee:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bf0:	37 8a       	mov	r10,120
80002bf2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bf4:	31 da       	mov	r10,29
80002bf6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bf8:	30 7a       	mov	r10,7
80002bfa:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bfc:	31 ea       	mov	r10,30
80002bfe:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c00:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c02:	31 fa       	mov	r10,31
80002c04:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c06:	30 4a       	mov	r10,4
80002c08:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c0a:	32 0a       	mov	r10,32
80002c0c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c0e:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c10:	34 4a       	mov	r10,68
80002c12:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c14:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c16:	34 5a       	mov	r10,69
80002c18:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c1a:	31 29       	mov	r9,18
80002c1c:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002c1e:	4f 18       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002c20:	70 07       	ld.w	r7,r8[0x0]
80002c22:	30 a8       	mov	r8,10
80002c24:	ee 08 06 46 	mulu.d	r6,r7,r8
80002c28:	e0 68 03 e8 	mov	r8,1000
80002c2c:	30 09       	mov	r9,0
80002c2e:	e0 6a 03 e7 	mov	r10,999
80002c32:	30 0b       	mov	r11,0
80002c34:	ec 0a 00 0a 	add	r10,r6,r10
80002c38:	ee 0b 00 4b 	adc	r11,r7,r11
80002c3c:	f0 1f 00 6f 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002c40:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002c44:	f0 0a 00 0a 	add	r10,r8,r10
80002c48:	cd aa       	rjmp	800029fc <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c4a:	31 c9       	mov	r9,28
80002c4c:	fc 18 c0 00 	movh	r8,0xc000
80002c50:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c52:	30 49       	mov	r9,4
80002c54:	fc 18 c0 20 	movh	r8,0xc020
80002c58:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002c5a:	4e 28       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002c5c:	70 07       	ld.w	r7,r8[0x0]
80002c5e:	31 48       	mov	r8,20
80002c60:	ee 08 06 46 	mulu.d	r6,r7,r8
80002c64:	e0 68 03 e8 	mov	r8,1000
80002c68:	30 09       	mov	r9,0
80002c6a:	e0 6a 03 e7 	mov	r10,999
80002c6e:	30 0b       	mov	r11,0
80002c70:	ec 0a 00 0a 	add	r10,r6,r10
80002c74:	ee 0b 00 4b 	adc	r11,r7,r11
80002c78:	f0 1f 00 60 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002c7c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002c80:	f0 0a 00 0a 	add	r10,r8,r10
80002c84:	cc fa       	rjmp	80002a22 <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c86:	34 39       	mov	r9,67
80002c88:	fc 18 c0 00 	movh	r8,0xc000
80002c8c:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c8e:	e0 69 00 80 	mov	r9,128
80002c92:	fc 18 c0 20 	movh	r8,0xc020
80002c96:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002c98:	4d 28       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002c9a:	70 07       	ld.w	r7,r8[0x0]
80002c9c:	30 58       	mov	r8,5
80002c9e:	ee 08 06 46 	mulu.d	r6,r7,r8
80002ca2:	e0 68 03 e8 	mov	r8,1000
80002ca6:	30 09       	mov	r9,0
80002ca8:	e0 6a 03 e7 	mov	r10,999
80002cac:	30 0b       	mov	r11,0
80002cae:	ec 0a 00 0a 	add	r10,r6,r10
80002cb2:	ee 0b 00 4b 	adc	r11,r7,r11
80002cb6:	f0 1f 00 51 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002cba:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002cbe:	f0 0a 00 0a 	add	r10,r8,r10
80002cc2:	cc 3a       	rjmp	80002a48 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002cc4:	31 b9       	mov	r9,27
80002cc6:	fc 18 c0 00 	movh	r8,0xc000
80002cca:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002ccc:	30 89       	mov	r9,8
80002cce:	fc 18 c0 20 	movh	r8,0xc020
80002cd2:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cd4:	4c 38       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002cd6:	70 07       	ld.w	r7,r8[0x0]
80002cd8:	32 88       	mov	r8,40
80002cda:	ee 08 06 46 	mulu.d	r6,r7,r8
80002cde:	e0 68 03 e8 	mov	r8,1000
80002ce2:	30 09       	mov	r9,0
80002ce4:	e0 6a 03 e7 	mov	r10,999
80002ce8:	30 0b       	mov	r11,0
80002cea:	ec 0a 00 0a 	add	r10,r6,r10
80002cee:	ee 0b 00 4b 	adc	r11,r7,r11
80002cf2:	f0 1f 00 42 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002cf6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002cfa:	f0 0a 00 0a 	add	r10,r8,r10
80002cfe:	cb 8a       	rjmp	80002a6e <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002d00:	31 b9       	mov	r9,27
80002d02:	fc 18 c0 00 	movh	r8,0xc000
80002d06:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002d08:	31 09       	mov	r9,16
80002d0a:	fc 18 c0 20 	movh	r8,0xc020
80002d0e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002d10:	4b 48       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002d12:	70 07       	ld.w	r7,r8[0x0]
80002d14:	32 88       	mov	r8,40
80002d16:	ee 08 06 46 	mulu.d	r6,r7,r8
80002d1a:	e0 68 03 e8 	mov	r8,1000
80002d1e:	30 09       	mov	r9,0
80002d20:	e0 6a 03 e7 	mov	r10,999
80002d24:	30 0b       	mov	r11,0
80002d26:	ec 0a 00 0a 	add	r10,r6,r10
80002d2a:	ee 0b 00 4b 	adc	r11,r7,r11
80002d2e:	f0 1f 00 33 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d32:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d36:	f0 0a 00 0a 	add	r10,r8,r10
80002d3a:	ca da       	rjmp	80002a94 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002d3c:	32 69       	mov	r9,38
80002d3e:	fc 18 c0 00 	movh	r8,0xc000
80002d42:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002d44:	30 49       	mov	r9,4
80002d46:	fc 18 c0 20 	movh	r8,0xc020
80002d4a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002d4c:	4a 58       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002d4e:	70 07       	ld.w	r7,r8[0x0]
80002d50:	32 88       	mov	r8,40
80002d52:	ee 08 06 46 	mulu.d	r6,r7,r8
80002d56:	e0 68 03 e8 	mov	r8,1000
80002d5a:	30 09       	mov	r9,0
80002d5c:	e0 6a 03 e7 	mov	r10,999
80002d60:	30 0b       	mov	r11,0
80002d62:	ec 0a 00 0a 	add	r10,r6,r10
80002d66:	ee 0b 00 4b 	adc	r11,r7,r11
80002d6a:	f0 1f 00 24 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d6e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d72:	f0 0a 00 0a 	add	r10,r8,r10
80002d76:	ca 2a       	rjmp	80002aba <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002d78:	fc 19 c0 00 	movh	r9,0xc000
80002d7c:	32 6a       	mov	r10,38
80002d7e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002d80:	fc 18 c0 20 	movh	r8,0xc020
80002d84:	32 4b       	mov	r11,36
80002d86:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002d88:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002d8a:	32 c9       	mov	r9,44
80002d8c:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002d8e:	49 58       	lddpc	r8,80002de0 <et024006_Init+0x484>
80002d90:	70 07       	ld.w	r7,r8[0x0]
80002d92:	32 88       	mov	r8,40
80002d94:	ee 08 06 46 	mulu.d	r6,r7,r8
80002d98:	e0 68 03 e8 	mov	r8,1000
80002d9c:	30 09       	mov	r9,0
80002d9e:	e0 6a 03 e7 	mov	r10,999
80002da2:	30 0b       	mov	r11,0
80002da4:	ec 0a 00 0a 	add	r10,r6,r10
80002da8:	ee 0b 00 4b 	adc	r11,r7,r11
80002dac:	f0 1f 00 13 	mcall	80002df8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002db0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002db4:	f0 0a 00 0a 	add	r10,r8,r10
80002db8:	c9 4a       	rjmp	80002ae0 <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002dba:	fc 19 c0 00 	movh	r9,0xc000
80002dbe:	32 68       	mov	r8,38
80002dc0:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002dc2:	fc 18 c0 20 	movh	r8,0xc020
80002dc6:	33 ca       	mov	r10,60
80002dc8:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002dca:	37 0a       	mov	r10,112
80002dcc:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
80002dce:	90 0b       	ld.sh	r11,r8[0x0]
80002dd0:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002dd2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002dd4:	16 99       	mov	r9,r11
80002dd6:	a3 b9       	sbr	r9,0x3
80002dd8:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80002dda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002dde:	00 00       	add	r0,r0
80002de0:	00 00       	add	r0,r0
80002de2:	05 4c       	ld.w	r12,--r2
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	3f 64       	mov	r4,-10
80002de8:	80 00       	ld.sh	r0,r0[0x0]
80002dea:	9d b8       	st.w	lr[0x2c],r8
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	9d 36       	st.w	lr[0xc],r6
80002df0:	80 00       	ld.sh	r0,r0[0x0]
80002df2:	9d f8       	st.w	lr[0x3c],r8
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	9e 14       	ld.sh	r4,pc[0x2]
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	a3 48       	asr	r8,0x2
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	28 ec       	sub	r12,-114

80002e00 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80002e00:	d4 01       	pushm	lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80002e02:	4c 18       	lddpc	r8,80002f04 <sd_mmc_spi_get_capacity+0x104>
80002e04:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
80002e06:	4c 18       	lddpc	r8,80002f08 <sd_mmc_spi_get_capacity+0x108>
80002e08:	11 8a       	ld.ub	r10,r8[0x0]
80002e0a:	30 38       	mov	r8,3
80002e0c:	f0 0a 18 00 	cp.b	r10,r8
80002e10:	c2 71       	brne	80002e5e <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80002e12:	4b d8       	lddpc	r8,80002f04 <sd_mmc_spi_get_capacity+0x104>
80002e14:	f1 3a 00 08 	ld.ub	r10,r8[8]
80002e18:	f1 39 00 09 	ld.ub	r9,r8[9]
80002e1c:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80002e20:	11 fa       	ld.ub	r10,r8[0x7]
80002e22:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
80002e26:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
80002e2a:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
80002e2c:	f4 0b 16 0d 	lsr	r11,r10,0xd
80002e30:	16 99       	mov	r9,r11
80002e32:	f4 08 15 13 	lsl	r8,r10,0x13
80002e36:	4b 6a       	lddpc	r10,80002f0c <sd_mmc_spi_get_capacity+0x10c>
80002e38:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
80002e3c:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002e40:	4b 48       	lddpc	r8,80002f10 <sd_mmc_spi_get_capacity+0x110>
80002e42:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002e44:	f4 ea 00 00 	ld.d	r10,r10[0]
80002e48:	90 09       	ld.sh	r9,r8[0x0]
80002e4a:	f4 08 16 09 	lsr	r8,r10,0x9
80002e4e:	f1 eb 11 78 	or	r8,r8,r11<<0x17
80002e52:	20 18       	sub	r8,1
80002e54:	b7 79       	lsl	r9,0x17
80002e56:	12 08       	add	r8,r9
80002e58:	4a f9       	lddpc	r9,80002f14 <sd_mmc_spi_get_capacity+0x114>
80002e5a:	93 08       	st.w	r9[0x0],r8
80002e5c:	c4 28       	rjmp	80002ee0 <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002e5e:	4a a8       	lddpc	r8,80002f04 <sd_mmc_spi_get_capacity+0x104>
80002e60:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002e64:	f1 39 00 08 	ld.ub	r9,r8[8]
80002e68:	a7 89       	lsr	r9,0x6
80002e6a:	11 fe       	ld.ub	lr,r8[0x7]
80002e6c:	f2 0e 00 29 	add	r9,r9,lr<<0x2
80002e70:	11 ee       	ld.ub	lr,r8[0x6]
80002e72:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80002e76:	ab 6e       	lsl	lr,0xa
80002e78:	1c 09       	add	r9,lr
80002e7a:	2f f9       	sub	r9,-1
80002e7c:	f1 38 00 09 	ld.ub	r8,r8[9]
80002e80:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002e84:	f8 0e 16 07 	lsr	lr,r12,0x7
80002e88:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002e8c:	2f e8       	sub	r8,-2
80002e8e:	f2 08 09 49 	lsl	r9,r9,r8
80002e92:	20 19       	sub	r9,1
80002e94:	4a 08       	lddpc	r8,80002f14 <sd_mmc_spi_get_capacity+0x114>
80002e96:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80002e98:	70 0e       	ld.w	lr,r8[0x0]
80002e9a:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
80002e9e:	2f fe       	sub	lr,-1
80002ea0:	fc 0b 09 48 	lsl	r8,lr,r11
80002ea4:	30 09       	mov	r9,0
80002ea6:	49 ae       	lddpc	lr,80002f0c <sd_mmc_spi_get_capacity+0x10c>
80002ea8:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
80002eac:	49 98       	lddpc	r8,80002f10 <sd_mmc_spi_get_capacity+0x110>
80002eae:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80002eb0:	30 98       	mov	r8,9
80002eb2:	f0 0b 18 00 	cp.b	r11,r8
80002eb6:	e0 88 00 08 	brls	80002ec6 <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002eba:	49 78       	lddpc	r8,80002f14 <sd_mmc_spi_get_capacity+0x114>
80002ebc:	70 09       	ld.w	r9,r8[0x0]
80002ebe:	20 9b       	sub	r11,9
80002ec0:	f2 0b 09 4b 	lsl	r11,r9,r11
80002ec4:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
80002ec6:	58 0a       	cp.w	r10,0
80002ec8:	c0 c1       	brne	80002ee0 <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80002eca:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
80002ece:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80002ed2:	48 d9       	lddpc	r9,80002f04 <sd_mmc_spi_get_capacity+0x104>
80002ed4:	f3 39 00 0b 	ld.ub	r9,r9[11]
80002ed8:	a3 7c       	lsl	r12,0x3
80002eda:	f9 e9 12 59 	or	r9,r12,r9>>0x5
80002ede:	c0 c8       	rjmp	80002ef6 <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80002ee0:	48 9a       	lddpc	r10,80002f04 <sd_mmc_spi_get_capacity+0x104>
80002ee2:	f5 39 00 0a 	ld.ub	r9,r10[10]
80002ee6:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
80002eea:	f5 38 00 0b 	ld.ub	r8,r10[11]
80002eee:	a7 98       	lsr	r8,0x7
80002ef0:	f0 09 00 18 	add	r8,r8,r9<<0x1
80002ef4:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80002ef6:	2f f9       	sub	r9,-1
80002ef8:	2f f8       	sub	r8,-1
80002efa:	b1 39       	mul	r9,r8
80002efc:	48 78       	lddpc	r8,80002f18 <sd_mmc_spi_get_capacity+0x118>
80002efe:	b0 09       	st.h	r8[0x0],r9
}
80002f00:	d8 02       	popm	pc
80002f02:	00 00       	add	r0,r0
80002f04:	00 00       	add	r0,r0
80002f06:	13 70       	ld.ub	r0,--r9
80002f08:	00 00       	add	r0,r0
80002f0a:	13 6e       	ld.uh	lr,--r9
80002f0c:	00 00       	add	r0,r0
80002f0e:	13 5c       	ld.sh	r12,--r9
80002f10:	00 00       	add	r0,r0
80002f12:	13 64       	ld.uh	r4,--r9
80002f14:	00 00       	add	r0,r0
80002f16:	13 68       	ld.uh	r8,--r9
80002f18:	00 00       	add	r0,r0
80002f1a:	13 66       	ld.uh	r6,--r9

80002f1c <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002f1c:	5e fc       	retal	r12
80002f1e:	d7 03       	nop

80002f20 <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
80002f20:	d4 01       	pushm	lr
80002f22:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002f24:	18 9b       	mov	r11,r12
80002f26:	fe 7c 24 00 	mov	r12,-56320
80002f2a:	f0 1f 00 09 	mcall	80002f4c <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002f2e:	fa cb ff fe 	sub	r11,sp,-2
80002f32:	fe 7c 24 00 	mov	r12,-56320
80002f36:	f0 1f 00 07 	mcall	80002f50 <sd_mmc_spi_send_and_read+0x30>
80002f3a:	58 1c       	cp.w	r12,1
80002f3c:	c0 41       	brne	80002f44 <sd_mmc_spi_send_and_read+0x24>
80002f3e:	e0 6c 00 ff 	mov	r12,255
80002f42:	c0 28       	rjmp	80002f46 <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
80002f44:	1b bc       	ld.ub	r12,sp[0x3]
}
80002f46:	2f fd       	sub	sp,-4
80002f48:	d8 02       	popm	pc
80002f4a:	00 00       	add	r0,r0
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	43 0c       	lddsp	r12,sp[0xc0]
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	43 28       	lddsp	r8,sp[0xc8]

80002f54 <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
80002f54:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002f56:	30 1b       	mov	r11,1
80002f58:	fe 7c 24 00 	mov	r12,-56320
80002f5c:	f0 1f 00 10 	mcall	80002f9c <sd_mmc_spi_wait_not_busy+0x48>
80002f60:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002f62:	e0 65 00 ff 	mov	r5,255
80002f66:	48 f4       	lddpc	r4,80002fa0 <sd_mmc_spi_wait_not_busy+0x4c>
80002f68:	3f f6       	mov	r6,-1
80002f6a:	c0 b8       	rjmp	80002f80 <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80002f6c:	2f f7       	sub	r7,-1
    if (retry == 200000)
80002f6e:	e2 57 0d 40 	cp.w	r7,200000
80002f72:	c0 71       	brne	80002f80 <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002f74:	30 1b       	mov	r11,1
80002f76:	fe 7c 24 00 	mov	r12,-56320
80002f7a:	f0 1f 00 0b 	mcall	80002fa4 <sd_mmc_spi_wait_not_busy+0x50>
80002f7e:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002f80:	0a 9c       	mov	r12,r5
80002f82:	f0 1f 00 0a 	mcall	80002fa8 <sd_mmc_spi_wait_not_busy+0x54>
80002f86:	a8 8c       	st.b	r4[0x0],r12
80002f88:	ec 0c 18 00 	cp.b	r12,r6
80002f8c:	cf 01       	brne	80002f6c <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002f8e:	30 1b       	mov	r11,1
80002f90:	fe 7c 24 00 	mov	r12,-56320
80002f94:	f0 1f 00 04 	mcall	80002fa4 <sd_mmc_spi_wait_not_busy+0x50>
80002f98:	da 2a       	popm	r4-r7,pc,r12=1
80002f9a:	00 00       	add	r0,r0
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	44 74       	lddsp	r4,sp[0x11c]
80002fa0:	00 00       	add	r0,r0
80002fa2:	13 80       	ld.ub	r0,r9[0x0]
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	44 34       	lddsp	r4,sp[0x10c]
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	2f 20       	sub	r0,-14

80002fac <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
80002fac:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9; // gl_ptr_mem = pos * 512
80002fae:	48 58       	lddpc	r8,80002fc0 <sd_mmc_spi_write_open+0x14>
80002fb0:	f8 09 16 17 	lsr	r9,r12,0x17
80002fb4:	91 09       	st.w	r8[0x0],r9
80002fb6:	a9 7c       	lsl	r12,0x9
80002fb8:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002fba:	f0 1f 00 03 	mcall	80002fc4 <sd_mmc_spi_write_open+0x18>
}
80002fbe:	d8 02       	popm	pc
80002fc0:	00 00       	add	r0,r0
80002fc2:	05 54       	ld.sh	r4,--r2
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	2f 54       	sub	r4,-11

80002fc8 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
80002fc8:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
80002fca:	f0 1f 00 02 	mcall	80002fd0 <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
80002fce:	d8 02       	popm	pc
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	2f 54       	sub	r4,-11

80002fd4 <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
80002fd4:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9;        // gl_ptr_mem = pos * 512
80002fd6:	48 58       	lddpc	r8,80002fe8 <sd_mmc_spi_read_open+0x14>
80002fd8:	f8 09 16 17 	lsr	r9,r12,0x17
80002fdc:	91 09       	st.w	r8[0x0],r9
80002fde:	a9 7c       	lsl	r12,0x9
80002fe0:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002fe2:	f0 1f 00 03 	mcall	80002fec <sd_mmc_spi_read_open+0x18>
}
80002fe6:	d8 02       	popm	pc
80002fe8:	00 00       	add	r0,r0
80002fea:	05 54       	ld.sh	r4,--r2
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	2f 54       	sub	r4,-11

80002ff0 <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80002ff0:	eb cd 40 f8 	pushm	r3-r7,lr
80002ff4:	18 96       	mov	r6,r12
80002ff6:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002ff8:	e0 6b 00 ff 	mov	r11,255
80002ffc:	fe 7c 24 00 	mov	r12,-56320
80003000:	f0 1f 00 2b 	mcall	800030ac <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80003004:	0c 9b       	mov	r11,r6
80003006:	a7 ab       	sbr	r11,0x6
80003008:	5c 5b       	castu.b	r11
8000300a:	fe 7c 24 00 	mov	r12,-56320
8000300e:	f0 1f 00 28 	mcall	800030ac <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80003012:	ee 0b 16 18 	lsr	r11,r7,0x18
80003016:	fe 7c 24 00 	mov	r12,-56320
8000301a:	f0 1f 00 25 	mcall	800030ac <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
8000301e:	ee 0b 16 10 	lsr	r11,r7,0x10
80003022:	fe 7c 24 00 	mov	r12,-56320
80003026:	f0 1f 00 22 	mcall	800030ac <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
8000302a:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
8000302e:	fe 7c 24 00 	mov	r12,-56320
80003032:	f0 1f 00 1f 	mcall	800030ac <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
80003036:	0e 9b       	mov	r11,r7
80003038:	5c 7b       	castu.h	r11
8000303a:	fe 7c 24 00 	mov	r12,-56320
8000303e:	f0 1f 00 1c 	mcall	800030ac <sd_mmc_spi_command+0xbc>
  switch(command)
80003042:	30 08       	mov	r8,0
80003044:	f0 06 18 00 	cp.b	r6,r8
80003048:	c0 60       	breq	80003054 <sd_mmc_spi_command+0x64>
8000304a:	30 88       	mov	r8,8
8000304c:	f0 06 18 00 	cp.b	r6,r8
80003050:	c1 01       	brne	80003070 <sd_mmc_spi_command+0x80>
80003052:	c0 88       	rjmp	80003062 <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80003054:	e0 6b 00 95 	mov	r11,149
80003058:	fe 7c 24 00 	mov	r12,-56320
8000305c:	f0 1f 00 14 	mcall	800030ac <sd_mmc_spi_command+0xbc>
         break;
80003060:	c0 e8       	rjmp	8000307c <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80003062:	e0 6b 00 87 	mov	r11,135
80003066:	fe 7c 24 00 	mov	r12,-56320
8000306a:	f0 1f 00 11 	mcall	800030ac <sd_mmc_spi_command+0xbc>
         break;
8000306e:	c0 78       	rjmp	8000307c <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80003070:	e0 6b 00 ff 	mov	r11,255
80003074:	fe 7c 24 00 	mov	r12,-56320
80003078:	f0 1f 00 0d 	mcall	800030ac <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
8000307c:	3f f9       	mov	r9,-1
8000307e:	48 d8       	lddpc	r8,800030b0 <sd_mmc_spi_command+0xc0>
80003080:	b0 89       	st.b	r8[0x0],r9
80003082:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80003084:	e0 64 00 ff 	mov	r4,255
80003088:	10 93       	mov	r3,r8
8000308a:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
8000308c:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000308e:	c0 68       	rjmp	8000309a <sd_mmc_spi_command+0xaa>
  {
    retry++;
80003090:	2f f7       	sub	r7,-1
80003092:	5c 57       	castu.b	r7
    if(retry > 10) break;
80003094:	ea 07 18 00 	cp.b	r7,r5
80003098:	c0 80       	breq	800030a8 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000309a:	08 9c       	mov	r12,r4
8000309c:	f0 1f 00 06 	mcall	800030b4 <sd_mmc_spi_command+0xc4>
800030a0:	a6 8c       	st.b	r3[0x0],r12
800030a2:	ec 0c 18 00 	cp.b	r12,r6
800030a6:	cf 50       	breq	80003090 <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
800030a8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	43 0c       	lddsp	r12,sp[0xc0]
800030b0:	00 00       	add	r0,r0
800030b2:	13 80       	ld.ub	r0,r9[0x0]
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	2f 20       	sub	r0,-14

800030b8 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
800030b8:	eb cd 40 c0 	pushm	r6-r7,lr
800030bc:	18 97       	mov	r7,r12
800030be:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800030c0:	30 1b       	mov	r11,1
800030c2:	fe 7c 24 00 	mov	r12,-56320
800030c6:	f0 1f 00 09 	mcall	800030e8 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
800030ca:	0c 9b       	mov	r11,r6
800030cc:	0e 9c       	mov	r12,r7
800030ce:	f0 1f 00 08 	mcall	800030ec <sd_mmc_spi_send_command+0x34>
800030d2:	48 87       	lddpc	r7,800030f0 <sd_mmc_spi_send_command+0x38>
800030d4:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800030d6:	30 1b       	mov	r11,1
800030d8:	fe 7c 24 00 	mov	r12,-56320
800030dc:	f0 1f 00 06 	mcall	800030f4 <sd_mmc_spi_send_command+0x3c>
  return r1;
}
800030e0:	0f 8c       	ld.ub	r12,r7[0x0]
800030e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800030e6:	00 00       	add	r0,r0
800030e8:	80 00       	ld.sh	r0,r0[0x0]
800030ea:	44 74       	lddsp	r4,sp[0x11c]
800030ec:	80 00       	ld.sh	r0,r0[0x0]
800030ee:	2f f0       	sub	r0,-1
800030f0:	00 00       	add	r0,r0
800030f2:	13 80       	ld.ub	r0,r9[0x0]
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	44 34       	lddsp	r4,sp[0x10c]

800030f8 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
800030f8:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
800030fc:	49 a8       	lddpc	r8,80003164 <sd_mmc_spi_check_presence+0x6c>
800030fe:	11 89       	ld.ub	r9,r8[0x0]
80003100:	30 08       	mov	r8,0
80003102:	f0 09 18 00 	cp.b	r9,r8
80003106:	c1 f1       	brne	80003144 <sd_mmc_spi_check_presence+0x4c>
80003108:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000310a:	0e 94       	mov	r4,r7
8000310c:	49 73       	lddpc	r3,80003168 <sd_mmc_spi_check_presence+0x70>
8000310e:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003110:	e0 62 00 ff 	mov	r2,255
80003114:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80003118:	30 b5       	mov	r5,11
8000311a:	c0 c8       	rjmp	80003132 <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000311c:	04 9b       	mov	r11,r2
8000311e:	02 9c       	mov	r12,r1
80003120:	f0 1f 00 13 	mcall	8000316c <sd_mmc_spi_check_presence+0x74>
      retry++;
80003124:	2f f7       	sub	r7,-1
80003126:	5c 87       	casts.h	r7
      if (retry > 10)
80003128:	ea 07 19 00 	cp.h	r7,r5
8000312c:	c0 31       	brne	80003132 <sd_mmc_spi_check_presence+0x3a>
8000312e:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003132:	08 9b       	mov	r11,r4
80003134:	08 9c       	mov	r12,r4
80003136:	f0 1f 00 0f 	mcall	80003170 <sd_mmc_spi_check_presence+0x78>
8000313a:	a6 8c       	st.b	r3[0x0],r12
8000313c:	ec 0c 18 00 	cp.b	r12,r6
80003140:	ce e1       	brne	8000311c <sd_mmc_spi_check_presence+0x24>
80003142:	c0 e8       	rjmp	8000315e <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80003144:	30 0b       	mov	r11,0
80003146:	33 bc       	mov	r12,59
80003148:	f0 1f 00 0a 	mcall	80003170 <sd_mmc_spi_check_presence+0x78>
8000314c:	48 78       	lddpc	r8,80003168 <sd_mmc_spi_check_presence+0x70>
8000314e:	b0 8c       	st.b	r8[0x0],r12
80003150:	58 0c       	cp.w	r12,0
80003152:	c0 60       	breq	8000315e <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
80003154:	30 09       	mov	r9,0
80003156:	48 48       	lddpc	r8,80003164 <sd_mmc_spi_check_presence+0x6c>
80003158:	b0 89       	st.b	r8[0x0],r9
8000315a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
8000315e:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
80003162:	00 00       	add	r0,r0
80003164:	00 00       	add	r0,r0
80003166:	05 70       	ld.ub	r0,--r2
80003168:	00 00       	add	r0,r0
8000316a:	13 80       	ld.ub	r0,r9[0x0]
8000316c:	80 00       	ld.sh	r0,r0[0x0]
8000316e:	43 0c       	lddsp	r12,sp[0xc0]
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	30 b8       	mov	r8,11

80003174 <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
80003174:	eb cd 40 e0 	pushm	r5-r7,lr
80003178:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000317a:	f0 1f 00 4e 	mcall	800032b0 <sd_mmc_spi_write_sector_from_ram+0x13c>
8000317e:	e0 80 00 96 	breq	800032aa <sd_mmc_spi_write_sector_from_ram+0x136>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003182:	30 1b       	mov	r11,1
80003184:	fe 7c 24 00 	mov	r12,-56320
80003188:	f0 1f 00 4b 	mcall	800032b4 <sd_mmc_spi_write_sector_from_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000318c:	4c b8       	lddpc	r8,800032b8 <sd_mmc_spi_write_sector_from_ram+0x144>
8000318e:	11 89       	ld.ub	r9,r8[0x0]
80003190:	30 38       	mov	r8,3
80003192:	f0 09 18 00 	cp.b	r9,r8
80003196:	c0 d1       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x3c>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80003198:	4c 98       	lddpc	r8,800032bc <sd_mmc_spi_write_sector_from_ram+0x148>
8000319a:	70 0b       	ld.w	r11,r8[0x0]
8000319c:	70 18       	ld.w	r8,r8[0x4]
8000319e:	a9 98       	lsr	r8,0x9
800031a0:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
800031a4:	31 8c       	mov	r12,24
800031a6:	f0 1f 00 47 	mcall	800032c0 <sd_mmc_spi_write_sector_from_ram+0x14c>
800031aa:	4c 78       	lddpc	r8,800032c4 <sd_mmc_spi_write_sector_from_ram+0x150>
800031ac:	b0 8c       	st.b	r8[0x0],r12
800031ae:	c0 88       	rjmp	800031be <sd_mmc_spi_write_sector_from_ram+0x4a>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
800031b0:	4c 38       	lddpc	r8,800032bc <sd_mmc_spi_write_sector_from_ram+0x148>
800031b2:	70 1b       	ld.w	r11,r8[0x4]
800031b4:	31 8c       	mov	r12,24
800031b6:	f0 1f 00 43 	mcall	800032c0 <sd_mmc_spi_write_sector_from_ram+0x14c>
800031ba:	4c 38       	lddpc	r8,800032c4 <sd_mmc_spi_write_sector_from_ram+0x150>
800031bc:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
800031be:	4c 28       	lddpc	r8,800032c4 <sd_mmc_spi_write_sector_from_ram+0x150>
800031c0:	11 89       	ld.ub	r9,r8[0x0]
800031c2:	30 08       	mov	r8,0
800031c4:	f0 09 18 00 	cp.b	r9,r8
800031c8:	c0 80       	breq	800031d8 <sd_mmc_spi_write_sector_from_ram+0x64>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800031ca:	30 1b       	mov	r11,1
800031cc:	fe 7c 24 00 	mov	r12,-56320
800031d0:	f0 1f 00 3e 	mcall	800032c8 <sd_mmc_spi_write_sector_from_ram+0x154>
800031d4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800031d8:	e0 6b 00 ff 	mov	r11,255
800031dc:	fe 7c 24 00 	mov	r12,-56320
800031e0:	f0 1f 00 3b 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
800031e4:	e0 6b 00 fe 	mov	r11,254
800031e8:	fe 7c 24 00 	mov	r12,-56320
800031ec:	f0 1f 00 38 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
800031f0:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
800031f4:	fe 75 24 00 	mov	r5,-56320
800031f8:	0f 3b       	ld.ub	r11,r7++
800031fa:	0a 9c       	mov	r12,r5
800031fc:	f0 1f 00 34 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80003200:	0c 37       	cp.w	r7,r6
80003202:	cf b1       	brne	800031f8 <sd_mmc_spi_write_sector_from_ram+0x84>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
80003204:	e0 6b 00 ff 	mov	r11,255
80003208:	fe 7c 24 00 	mov	r12,-56320
8000320c:	f0 1f 00 30 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80003210:	e0 6b 00 ff 	mov	r11,255
80003214:	fe 7c 24 00 	mov	r12,-56320
80003218:	f0 1f 00 2d 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000321c:	e0 6c 00 ff 	mov	r12,255
80003220:	f0 1f 00 2c 	mcall	800032d0 <sd_mmc_spi_write_sector_from_ram+0x15c>
80003224:	4a 88       	lddpc	r8,800032c4 <sd_mmc_spi_write_sector_from_ram+0x150>
80003226:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80003228:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000322c:	58 5c       	cp.w	r12,5
8000322e:	c1 40       	breq	80003256 <sd_mmc_spi_write_sector_from_ram+0xe2>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80003230:	e0 6b 00 ff 	mov	r11,255
80003234:	fe 7c 24 00 	mov	r12,-56320
80003238:	f0 1f 00 25 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_write(SD_MMC_SPI,0xFF);
8000323c:	e0 6b 00 ff 	mov	r11,255
80003240:	fe 7c 24 00 	mov	r12,-56320
80003244:	f0 1f 00 22 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80003248:	30 1b       	mov	r11,1
8000324a:	fe 7c 24 00 	mov	r12,-56320
8000324e:	f0 1f 00 1f 	mcall	800032c8 <sd_mmc_spi_write_sector_from_ram+0x154>
80003252:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80003256:	e0 6b 00 ff 	mov	r11,255
8000325a:	fe 7c 24 00 	mov	r12,-56320
8000325e:	f0 1f 00 1c 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80003262:	e0 6b 00 ff 	mov	r11,255
80003266:	fe 7c 24 00 	mov	r12,-56320
8000326a:	f0 1f 00 19 	mcall	800032cc <sd_mmc_spi_write_sector_from_ram+0x158>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000326e:	30 1b       	mov	r11,1
80003270:	fe 7c 24 00 	mov	r12,-56320
80003274:	f0 1f 00 15 	mcall	800032c8 <sd_mmc_spi_write_sector_from_ram+0x154>
  gl_ptr_mem += 512;        // Update the memory pointer.
80003278:	49 18       	lddpc	r8,800032bc <sd_mmc_spi_write_sector_from_ram+0x148>
8000327a:	f0 e6 00 00 	ld.d	r6,r8[0]
8000327e:	e0 6a 02 00 	mov	r10,512
80003282:	30 0b       	mov	r11,0
80003284:	ec 0a 00 0a 	add	r10,r6,r10
80003288:	ee 0b 00 4b 	adc	r11,r7,r11
8000328c:	f0 eb 00 00 	st.d	r8[0],r10
80003290:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
80003292:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80003294:	c0 68       	rjmp	800032a0 <sd_mmc_spi_write_sector_from_ram+0x12c>
  {
    i++;
80003296:	2f f7       	sub	r7,-1
80003298:	5c 87       	casts.h	r7
    if (i == 10)
8000329a:	ec 07 19 00 	cp.h	r7,r6
8000329e:	c0 60       	breq	800032aa <sd_mmc_spi_write_sector_from_ram+0x136>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800032a0:	f0 1f 00 04 	mcall	800032b0 <sd_mmc_spi_write_sector_from_ram+0x13c>
800032a4:	cf 90       	breq	80003296 <sd_mmc_spi_write_sector_from_ram+0x122>
800032a6:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800032aa:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800032ae:	00 00       	add	r0,r0
800032b0:	80 00       	ld.sh	r0,r0[0x0]
800032b2:	2f 54       	sub	r4,-11
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	44 74       	lddsp	r4,sp[0x11c]
800032b8:	00 00       	add	r0,r0
800032ba:	13 6e       	ld.uh	lr,--r9
800032bc:	00 00       	add	r0,r0
800032be:	05 54       	ld.sh	r4,--r2
800032c0:	80 00       	ld.sh	r0,r0[0x0]
800032c2:	2f f0       	sub	r0,-1
800032c4:	00 00       	add	r0,r0
800032c6:	13 80       	ld.ub	r0,r9[0x0]
800032c8:	80 00       	ld.sh	r0,r0[0x0]
800032ca:	44 34       	lddsp	r4,sp[0x10c]
800032cc:	80 00       	ld.sh	r0,r0[0x0]
800032ce:	43 0c       	lddsp	r12,sp[0xc0]
800032d0:	80 00       	ld.sh	r0,r0[0x0]
800032d2:	2f 20       	sub	r0,-14

800032d4 <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
800032d4:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800032d8:	f0 1f 00 1c 	mcall	80003348 <sd_mmc_spi_check_hc+0x74>
800032dc:	c0 31       	brne	800032e2 <sd_mmc_spi_check_hc+0xe>
800032de:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800032e2:	30 1b       	mov	r11,1
800032e4:	fe 7c 24 00 	mov	r12,-56320
800032e8:	f0 1f 00 19 	mcall	8000334c <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
800032ec:	30 0b       	mov	r11,0
800032ee:	33 ac       	mov	r12,58
800032f0:	f0 1f 00 18 	mcall	80003350 <sd_mmc_spi_check_hc+0x7c>
800032f4:	49 88       	lddpc	r8,80003354 <sd_mmc_spi_check_hc+0x80>
800032f6:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
800032f8:	58 0c       	cp.w	r12,0
800032fa:	c0 80       	breq	8000330a <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800032fc:	30 1b       	mov	r11,1
800032fe:	fe 7c 24 00 	mov	r12,-56320
80003302:	f0 1f 00 16 	mcall	80003358 <sd_mmc_spi_check_hc+0x84>
80003306:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
8000330a:	e0 6c 00 ff 	mov	r12,255
8000330e:	f0 1f 00 14 	mcall	8000335c <sd_mmc_spi_check_hc+0x88>
80003312:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003314:	e0 6c 00 ff 	mov	r12,255
80003318:	f0 1f 00 11 	mcall	8000335c <sd_mmc_spi_check_hc+0x88>
8000331c:	48 e7       	lddpc	r7,80003354 <sd_mmc_spi_check_hc+0x80>
8000331e:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003320:	e0 6c 00 ff 	mov	r12,255
80003324:	f0 1f 00 0e 	mcall	8000335c <sd_mmc_spi_check_hc+0x88>
80003328:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000332a:	e0 6c 00 ff 	mov	r12,255
8000332e:	f0 1f 00 0c 	mcall	8000335c <sd_mmc_spi_check_hc+0x88>
80003332:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003334:	30 1b       	mov	r11,1
80003336:	fe 7c 24 00 	mov	r12,-56320
8000333a:	f0 1f 00 08 	mcall	80003358 <sd_mmc_spi_check_hc+0x84>
8000333e:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
80003342:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003346:	00 00       	add	r0,r0
80003348:	80 00       	ld.sh	r0,r0[0x0]
8000334a:	2f 54       	sub	r4,-11
8000334c:	80 00       	ld.sh	r0,r0[0x0]
8000334e:	44 74       	lddsp	r4,sp[0x11c]
80003350:	80 00       	ld.sh	r0,r0[0x0]
80003352:	2f f0       	sub	r0,-1
80003354:	00 00       	add	r0,r0
80003356:	13 80       	ld.ub	r0,r9[0x0]
80003358:	80 00       	ld.sh	r0,r0[0x0]
8000335a:	44 34       	lddsp	r4,sp[0x10c]
8000335c:	80 00       	ld.sh	r0,r0[0x0]
8000335e:	2f 20       	sub	r0,-14

80003360 <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80003360:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003364:	f0 1f 00 27 	mcall	80003400 <sd_mmc_spi_get_if+0xa0>
80003368:	c0 31       	brne	8000336e <sd_mmc_spi_get_if+0xe>
8000336a:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000336e:	30 1b       	mov	r11,1
80003370:	fe 7c 24 00 	mov	r12,-56320
80003374:	f0 1f 00 24 	mcall	80003404 <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80003378:	e0 6b 01 aa 	mov	r11,426
8000337c:	30 8c       	mov	r12,8
8000337e:	f0 1f 00 23 	mcall	80003408 <sd_mmc_spi_get_if+0xa8>
80003382:	4a 38       	lddpc	r8,8000340c <sd_mmc_spi_get_if+0xac>
80003384:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
80003386:	e2 1c 00 04 	andl	r12,0x4,COH
8000338a:	c0 80       	breq	8000339a <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000338c:	30 1b       	mov	r11,1
8000338e:	fe 7c 24 00 	mov	r12,-56320
80003392:	f0 1f 00 20 	mcall	80003410 <sd_mmc_spi_get_if+0xb0>
80003396:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000339a:	e0 6c 00 ff 	mov	r12,255
8000339e:	f0 1f 00 1e 	mcall	80003414 <sd_mmc_spi_get_if+0xb4>
800033a2:	49 b7       	lddpc	r7,8000340c <sd_mmc_spi_get_if+0xac>
800033a4:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800033a6:	e0 6c 00 ff 	mov	r12,255
800033aa:	f0 1f 00 1b 	mcall	80003414 <sd_mmc_spi_get_if+0xb4>
800033ae:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800033b0:	e0 6c 00 ff 	mov	r12,255
800033b4:	f0 1f 00 18 	mcall	80003414 <sd_mmc_spi_get_if+0xb4>
800033b8:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
800033ba:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800033be:	c0 81       	brne	800033ce <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800033c0:	30 1b       	mov	r11,1
800033c2:	fe 7c 24 00 	mov	r12,-56320
800033c6:	f0 1f 00 13 	mcall	80003410 <sd_mmc_spi_get_if+0xb0>
800033ca:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800033ce:	e0 6c 00 ff 	mov	r12,255
800033d2:	f0 1f 00 11 	mcall	80003414 <sd_mmc_spi_get_if+0xb4>
800033d6:	48 e8       	lddpc	r8,8000340c <sd_mmc_spi_get_if+0xac>
800033d8:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
800033da:	3a a8       	mov	r8,-86
800033dc:	f0 0c 18 00 	cp.b	r12,r8
800033e0:	c0 80       	breq	800033f0 <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800033e2:	30 1b       	mov	r11,1
800033e4:	fe 7c 24 00 	mov	r12,-56320
800033e8:	f0 1f 00 0a 	mcall	80003410 <sd_mmc_spi_get_if+0xb0>
800033ec:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800033f0:	30 1b       	mov	r11,1
800033f2:	fe 7c 24 00 	mov	r12,-56320
800033f6:	f0 1f 00 07 	mcall	80003410 <sd_mmc_spi_get_if+0xb0>
800033fa:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800033fe:	00 00       	add	r0,r0
80003400:	80 00       	ld.sh	r0,r0[0x0]
80003402:	2f 54       	sub	r4,-11
80003404:	80 00       	ld.sh	r0,r0[0x0]
80003406:	44 74       	lddsp	r4,sp[0x11c]
80003408:	80 00       	ld.sh	r0,r0[0x0]
8000340a:	2f f0       	sub	r0,-1
8000340c:	00 00       	add	r0,r0
8000340e:	13 80       	ld.ub	r0,r9[0x0]
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	44 34       	lddsp	r4,sp[0x10c]
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	2f 20       	sub	r0,-14

80003418 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80003418:	eb cd 40 f8 	pushm	r3-r7,lr
8000341c:	20 1d       	sub	sp,4
8000341e:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003420:	f0 1f 00 4d 	mcall	80003554 <sd_mmc_spi_read_sector_to_ram+0x13c>
80003424:	e0 80 00 94 	breq	8000354c <sd_mmc_spi_read_sector_to_ram+0x134>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003428:	30 1b       	mov	r11,1
8000342a:	fe 7c 24 00 	mov	r12,-56320
8000342e:	f0 1f 00 4b 	mcall	80003558 <sd_mmc_spi_read_sector_to_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80003432:	4c b8       	lddpc	r8,8000355c <sd_mmc_spi_read_sector_to_ram+0x144>
80003434:	11 89       	ld.ub	r9,r8[0x0]
80003436:	30 38       	mov	r8,3
80003438:	f0 09 18 00 	cp.b	r9,r8
8000343c:	c0 d1       	brne	80003456 <sd_mmc_spi_read_sector_to_ram+0x3e>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
8000343e:	4c 98       	lddpc	r8,80003560 <sd_mmc_spi_read_sector_to_ram+0x148>
80003440:	70 0b       	ld.w	r11,r8[0x0]
80003442:	70 18       	ld.w	r8,r8[0x4]
80003444:	a9 98       	lsr	r8,0x9
80003446:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
8000344a:	31 1c       	mov	r12,17
8000344c:	f0 1f 00 46 	mcall	80003564 <sd_mmc_spi_read_sector_to_ram+0x14c>
80003450:	4c 68       	lddpc	r8,80003568 <sd_mmc_spi_read_sector_to_ram+0x150>
80003452:	b0 8c       	st.b	r8[0x0],r12
80003454:	c0 88       	rjmp	80003464 <sd_mmc_spi_read_sector_to_ram+0x4c>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80003456:	4c 38       	lddpc	r8,80003560 <sd_mmc_spi_read_sector_to_ram+0x148>
80003458:	70 1b       	ld.w	r11,r8[0x4]
8000345a:	31 1c       	mov	r12,17
8000345c:	f0 1f 00 42 	mcall	80003564 <sd_mmc_spi_read_sector_to_ram+0x14c>
80003460:	4c 28       	lddpc	r8,80003568 <sd_mmc_spi_read_sector_to_ram+0x150>
80003462:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
80003464:	4c 18       	lddpc	r8,80003568 <sd_mmc_spi_read_sector_to_ram+0x150>
80003466:	11 89       	ld.ub	r9,r8[0x0]
80003468:	30 08       	mov	r8,0
8000346a:	f0 09 18 00 	cp.b	r9,r8
8000346e:	c1 20       	breq	80003492 <sd_mmc_spi_read_sector_to_ram+0x7a>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003470:	30 1b       	mov	r11,1
80003472:	fe 7c 24 00 	mov	r12,-56320
80003476:	f0 1f 00 3e 	mcall	8000356c <sd_mmc_spi_read_sector_to_ram+0x154>
8000347a:	30 0c       	mov	r12,0
    return false;
8000347c:	c6 88       	rjmp	8000354c <sd_mmc_spi_read_sector_to_ram+0x134>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
8000347e:	20 17       	sub	r7,1
80003480:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
80003482:	c0 e1       	brne	8000349e <sd_mmc_spi_read_sector_to_ram+0x86>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
80003484:	30 1b       	mov	r11,1
80003486:	fe 7c 24 00 	mov	r12,-56320
8000348a:	f0 1f 00 39 	mcall	8000356c <sd_mmc_spi_read_sector_to_ram+0x154>
8000348e:	30 0c       	mov	r12,0
       return false;
80003490:	c5 e8       	rjmp	8000354c <sd_mmc_spi_read_sector_to_ram+0x134>
80003492:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80003496:	e0 65 00 ff 	mov	r5,255
8000349a:	4b 44       	lddpc	r4,80003568 <sd_mmc_spi_read_sector_to_ram+0x150>
8000349c:	3f f6       	mov	r6,-1
8000349e:	0a 9c       	mov	r12,r5
800034a0:	f0 1f 00 34 	mcall	80003570 <sd_mmc_spi_read_sector_to_ram+0x158>
800034a4:	a8 8c       	st.b	r4[0x0],r12
800034a6:	ec 0c 18 00 	cp.b	r12,r6
800034aa:	ce a0       	breq	8000347e <sd_mmc_spi_read_sector_to_ram+0x66>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
800034ac:	3f e8       	mov	r8,-2
800034ae:	f0 0c 18 00 	cp.b	r12,r8
800034b2:	c0 e0       	breq	800034ce <sd_mmc_spi_read_sector_to_ram+0xb6>
  {
    spi_write(SD_MMC_SPI,0xFF);
800034b4:	e0 6b 00 ff 	mov	r11,255
800034b8:	fe 7c 24 00 	mov	r12,-56320
800034bc:	f0 1f 00 2e 	mcall	80003574 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800034c0:	30 1b       	mov	r11,1
800034c2:	fe 7c 24 00 	mov	r12,-56320
800034c6:	f0 1f 00 2a 	mcall	8000356c <sd_mmc_spi_read_sector_to_ram+0x154>
800034ca:	30 0c       	mov	r12,0
    return false;
800034cc:	c4 08       	rjmp	8000354c <sd_mmc_spi_read_sector_to_ram+0x134>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
800034ce:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
800034d0:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800034d4:	e0 64 00 ff 	mov	r4,255
800034d8:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
800034dc:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800034e0:	08 9b       	mov	r11,r4
800034e2:	0c 9c       	mov	r12,r6
800034e4:	f0 1f 00 24 	mcall	80003574 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_read(SD_MMC_SPI,&data_read);
800034e8:	06 9b       	mov	r11,r3
800034ea:	0c 9c       	mov	r12,r6
800034ec:	f0 1f 00 23 	mcall	80003578 <sd_mmc_spi_read_sector_to_ram+0x160>
    *_ram++=data_read;
800034f0:	9a 18       	ld.sh	r8,sp[0x2]
800034f2:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800034f4:	0a 37       	cp.w	r7,r5
800034f6:	cf 51       	brne	800034e0 <sd_mmc_spi_read_sector_to_ram+0xc8>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
800034f8:	49 a8       	lddpc	r8,80003560 <sd_mmc_spi_read_sector_to_ram+0x148>
800034fa:	f0 e6 00 00 	ld.d	r6,r8[0]
800034fe:	e0 6a 02 00 	mov	r10,512
80003502:	30 0b       	mov	r11,0
80003504:	ec 0a 00 0a 	add	r10,r6,r10
80003508:	ee 0b 00 4b 	adc	r11,r7,r11
8000350c:	f0 eb 00 00 	st.d	r8[0],r10

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80003510:	e0 6b 00 ff 	mov	r11,255
80003514:	fe 7c 24 00 	mov	r12,-56320
80003518:	f0 1f 00 17 	mcall	80003574 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
8000351c:	e0 6b 00 ff 	mov	r11,255
80003520:	fe 7c 24 00 	mov	r12,-56320
80003524:	f0 1f 00 14 	mcall	80003574 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80003528:	e0 6b 00 ff 	mov	r11,255
8000352c:	fe 7c 24 00 	mov	r12,-56320
80003530:	f0 1f 00 11 	mcall	80003574 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80003534:	e0 6b 00 ff 	mov	r11,255
80003538:	fe 7c 24 00 	mov	r12,-56320
8000353c:	f0 1f 00 0e 	mcall	80003574 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003540:	30 1b       	mov	r11,1
80003542:	fe 7c 24 00 	mov	r12,-56320
80003546:	f0 1f 00 0a 	mcall	8000356c <sd_mmc_spi_read_sector_to_ram+0x154>
8000354a:	30 1c       	mov	r12,1

  return true;   // Read done.
}
8000354c:	2f fd       	sub	sp,-4
8000354e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003552:	00 00       	add	r0,r0
80003554:	80 00       	ld.sh	r0,r0[0x0]
80003556:	2f 54       	sub	r4,-11
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	44 74       	lddsp	r4,sp[0x11c]
8000355c:	00 00       	add	r0,r0
8000355e:	13 6e       	ld.uh	lr,--r9
80003560:	00 00       	add	r0,r0
80003562:	05 54       	ld.sh	r4,--r2
80003564:	80 00       	ld.sh	r0,r0[0x0]
80003566:	2f f0       	sub	r0,-1
80003568:	00 00       	add	r0,r0
8000356a:	13 80       	ld.ub	r0,r9[0x0]
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	44 34       	lddsp	r4,sp[0x10c]
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	2f 20       	sub	r0,-14
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	43 0c       	lddsp	r12,sp[0xc0]
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	43 28       	lddsp	r8,sp[0xc8]

8000357c <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
8000357c:	eb cd 40 fc 	pushm	r2-r7,lr
80003580:	20 1d       	sub	sp,4
80003582:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003584:	f0 1f 00 32 	mcall	8000364c <sd_mmc_spi_get_csd+0xd0>
80003588:	c5 f0       	breq	80003646 <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000358a:	30 1b       	mov	r11,1
8000358c:	fe 7c 24 00 	mov	r12,-56320
80003590:	f0 1f 00 30 	mcall	80003650 <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80003594:	30 0b       	mov	r11,0
80003596:	30 9c       	mov	r12,9
80003598:	f0 1f 00 2f 	mcall	80003654 <sd_mmc_spi_get_csd+0xd8>
8000359c:	4a f8       	lddpc	r8,80003658 <sd_mmc_spi_get_csd+0xdc>
8000359e:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
800035a0:	58 0c       	cp.w	r12,0
800035a2:	c0 81       	brne	800035b2 <sd_mmc_spi_get_csd+0x36>
800035a4:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800035a6:	e0 64 00 ff 	mov	r4,255
800035aa:	10 93       	mov	r3,r8
800035ac:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
800035ae:	30 95       	mov	r5,9
800035b0:	c1 78       	rjmp	800035de <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800035b2:	30 1b       	mov	r11,1
800035b4:	fe 7c 24 00 	mov	r12,-56320
800035b8:	f0 1f 00 29 	mcall	8000365c <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
800035bc:	30 09       	mov	r9,0
800035be:	4a 98       	lddpc	r8,80003660 <sd_mmc_spi_get_csd+0xe4>
800035c0:	b0 89       	st.b	r8[0x0],r9
800035c2:	30 0c       	mov	r12,0
    return false;
800035c4:	c4 18       	rjmp	80003646 <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
800035c6:	ea 07 18 00 	cp.b	r7,r5
800035ca:	c0 81       	brne	800035da <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800035cc:	30 1b       	mov	r11,1
800035ce:	fe 7c 24 00 	mov	r12,-56320
800035d2:	f0 1f 00 23 	mcall	8000365c <sd_mmc_spi_get_csd+0xe0>
800035d6:	30 0c       	mov	r12,0
      return false;
800035d8:	c3 78       	rjmp	80003646 <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
800035da:	2f f7       	sub	r7,-1
800035dc:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800035de:	08 9c       	mov	r12,r4
800035e0:	f0 1f 00 21 	mcall	80003664 <sd_mmc_spi_get_csd+0xe8>
800035e4:	a6 8c       	st.b	r3[0x0],r12
800035e6:	ec 0c 18 00 	cp.b	r12,r6
800035ea:	ce e1       	brne	800035c6 <sd_mmc_spi_get_csd+0x4a>
800035ec:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800035ee:	e0 65 00 ff 	mov	r5,255
800035f2:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
800035f6:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800035fa:	0a 9b       	mov	r11,r5
800035fc:	0c 9c       	mov	r12,r6
800035fe:	f0 1f 00 1b 	mcall	80003668 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
80003602:	08 9b       	mov	r11,r4
80003604:	0c 9c       	mov	r12,r6
80003606:	f0 1f 00 1a 	mcall	8000366c <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
8000360a:	9a 18       	ld.sh	r8,sp[0x2]
8000360c:	e4 07 0b 08 	st.b	r2[r7],r8
80003610:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
80003612:	59 07       	cp.w	r7,16
80003614:	cf 31       	brne	800035fa <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80003616:	e0 6b 00 ff 	mov	r11,255
8000361a:	fe 7c 24 00 	mov	r12,-56320
8000361e:	f0 1f 00 13 	mcall	80003668 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
80003622:	e0 6b 00 ff 	mov	r11,255
80003626:	fe 7c 24 00 	mov	r12,-56320
8000362a:	f0 1f 00 10 	mcall	80003668 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
8000362e:	e0 6b 00 ff 	mov	r11,255
80003632:	fe 7c 24 00 	mov	r12,-56320
80003636:	f0 1f 00 0d 	mcall	80003668 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000363a:	30 1b       	mov	r11,1
8000363c:	fe 7c 24 00 	mov	r12,-56320
80003640:	f0 1f 00 07 	mcall	8000365c <sd_mmc_spi_get_csd+0xe0>
80003644:	30 1c       	mov	r12,1
  return true;
}
80003646:	2f fd       	sub	sp,-4
80003648:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000364c:	80 00       	ld.sh	r0,r0[0x0]
8000364e:	2f 54       	sub	r4,-11
80003650:	80 00       	ld.sh	r0,r0[0x0]
80003652:	44 74       	lddsp	r4,sp[0x11c]
80003654:	80 00       	ld.sh	r0,r0[0x0]
80003656:	2f f0       	sub	r0,-1
80003658:	00 00       	add	r0,r0
8000365a:	13 80       	ld.ub	r0,r9[0x0]
8000365c:	80 00       	ld.sh	r0,r0[0x0]
8000365e:	44 34       	lddsp	r4,sp[0x10c]
80003660:	00 00       	add	r0,r0
80003662:	05 70       	ld.ub	r0,--r2
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	2f 20       	sub	r0,-14
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	43 0c       	lddsp	r12,sp[0xc0]
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	43 28       	lddsp	r8,sp[0xc8]

80003670 <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
80003670:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
80003672:	fe fb 02 66 	ld.w	r11,pc[614]
80003676:	e6 68 1a 80 	mov	r8,400000
8000367a:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000367c:	fe f8 02 60 	ld.w	r8,pc[608]
80003680:	70 0a       	ld.w	r10,r8[0x0]
80003682:	fe 7c 24 00 	mov	r12,-56320
80003686:	f0 1f 00 97 	mcall	800038e0 <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000368a:	30 1b       	mov	r11,1
8000368c:	fe 7c 24 00 	mov	r12,-56320
80003690:	f0 1f 00 95 	mcall	800038e4 <sd_mmc_spi_internal_init+0x274>
80003694:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
80003696:	e0 66 00 ff 	mov	r6,255
8000369a:	fe 75 24 00 	mov	r5,-56320
8000369e:	0c 9b       	mov	r11,r6
800036a0:	0a 9c       	mov	r12,r5
800036a2:	f0 1f 00 92 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
800036a6:	2f f7       	sub	r7,-1
800036a8:	58 a7       	cp.w	r7,10
800036aa:	cf a1       	brne	8000369e <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800036ac:	30 1b       	mov	r11,1
800036ae:	fe 7c 24 00 	mov	r12,-56320
800036b2:	f0 1f 00 8f 	mcall	800038ec <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
800036b6:	30 08       	mov	r8,0
800036b8:	fe f9 02 38 	ld.w	r9,pc[568]
800036bc:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
800036be:	fe f9 02 36 	ld.w	r9,pc[566]
800036c2:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800036c4:	30 0b       	mov	r11,0
800036c6:	16 9c       	mov	r12,r11
800036c8:	f0 1f 00 8c 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
800036cc:	fe f8 02 30 	ld.w	r8,pc[560]
800036d0:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800036d2:	e0 6b 00 ff 	mov	r11,255
800036d6:	fe 7c 24 00 	mov	r12,-56320
800036da:	f0 1f 00 84 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
800036de:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800036e0:	fe f6 02 1c 	ld.w	r6,pc[540]
800036e4:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800036e6:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800036e8:	e0 62 00 ff 	mov	r2,255
800036ec:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
800036f0:	36 54       	mov	r4,101
800036f2:	c1 08       	rjmp	80003712 <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800036f4:	06 9b       	mov	r11,r3
800036f6:	06 9c       	mov	r12,r3
800036f8:	f0 1f 00 80 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
800036fc:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800036fe:	04 9b       	mov	r11,r2
80003700:	02 9c       	mov	r12,r1
80003702:	f0 1f 00 7a 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
80003706:	2f f7       	sub	r7,-1
80003708:	5c 87       	casts.h	r7
    if(retry > 100)
8000370a:	e8 07 19 00 	cp.h	r7,r4
8000370e:	e0 80 00 e4 	breq	800038d6 <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
80003712:	0d 88       	ld.ub	r8,r6[0x0]
80003714:	ea 08 18 00 	cp.b	r8,r5
80003718:	ce e1       	brne	800036f4 <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
8000371a:	f0 1f 00 7a 	mcall	80003900 <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
8000371e:	5b fc       	cp.w	r12,-1
80003720:	e0 80 00 db 	breq	800038d6 <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
80003724:	58 1c       	cp.w	r12,1
80003726:	c0 51       	brne	80003730 <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
80003728:	30 29       	mov	r9,2
8000372a:	4f 38       	lddpc	r8,800038f4 <sd_mmc_spi_internal_init+0x284>
8000372c:	b0 89       	st.b	r8[0x0],r9
8000372e:	c4 c8       	rjmp	800037c6 <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
80003730:	30 0b       	mov	r11,0
80003732:	33 7c       	mov	r12,55
80003734:	f0 1f 00 71 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
80003738:	4f 17       	lddpc	r7,800038fc <sd_mmc_spi_internal_init+0x28c>
8000373a:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
8000373c:	e0 6b 00 ff 	mov	r11,255
80003740:	fe 7c 24 00 	mov	r12,-56320
80003744:	f0 1f 00 69 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80003748:	30 0b       	mov	r11,0
8000374a:	32 9c       	mov	r12,41
8000374c:	f0 1f 00 6b 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
80003750:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80003752:	e0 6b 00 ff 	mov	r11,255
80003756:	fe 7c 24 00 	mov	r12,-56320
8000375a:	f0 1f 00 64 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
8000375e:	0f 88       	ld.ub	r8,r7[0x0]
80003760:	e2 18 00 fe 	andl	r8,0xfe,COH
80003764:	c0 51       	brne	8000376e <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
80003766:	30 19       	mov	r9,1
80003768:	4e 38       	lddpc	r8,800038f4 <sd_mmc_spi_internal_init+0x284>
8000376a:	b0 89       	st.b	r8[0x0],r9
8000376c:	c2 d8       	rjmp	800037c6 <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
8000376e:	30 09       	mov	r9,0
80003770:	4e 18       	lddpc	r8,800038f4 <sd_mmc_spi_internal_init+0x284>
80003772:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003774:	30 0b       	mov	r11,0
80003776:	16 9c       	mov	r12,r11
80003778:	f0 1f 00 60 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
8000377c:	4e 08       	lddpc	r8,800038fc <sd_mmc_spi_internal_init+0x28c>
8000377e:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003780:	e0 6b 00 ff 	mov	r11,255
80003784:	fe 7c 24 00 	mov	r12,-56320
80003788:	f0 1f 00 58 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
8000378c:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000378e:	4d c6       	lddpc	r6,800038fc <sd_mmc_spi_internal_init+0x28c>
80003790:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003792:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003794:	e0 62 00 ff 	mov	r2,255
80003798:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
8000379c:	36 54       	mov	r4,101
8000379e:	c1 08       	rjmp	800037be <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800037a0:	06 9b       	mov	r11,r3
800037a2:	06 9c       	mov	r12,r3
800037a4:	f0 1f 00 55 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
800037a8:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800037aa:	04 9b       	mov	r11,r2
800037ac:	02 9c       	mov	r12,r1
800037ae:	f0 1f 00 4f 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
800037b2:	2f f7       	sub	r7,-1
800037b4:	5c 87       	casts.h	r7
        if(retry > 100)
800037b6:	e8 07 19 00 	cp.h	r7,r4
800037ba:	e0 80 00 8e 	breq	800038d6 <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
800037be:	0d 88       	ld.ub	r8,r6[0x0]
800037c0:	ea 08 18 00 	cp.b	r8,r5
800037c4:	ce e1       	brne	800037a0 <sd_mmc_spi_internal_init+0x130>
800037c6:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800037c8:	4c b4       	lddpc	r4,800038f4 <sd_mmc_spi_internal_init+0x284>
800037ca:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800037cc:	0e 93       	mov	r3,r7
800037ce:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800037d0:	4c b6       	lddpc	r6,800038fc <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800037d2:	e0 62 00 ff 	mov	r2,255
800037d6:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800037da:	09 88       	ld.ub	r8,r4[0x0]
800037dc:	ea 08 18 00 	cp.b	r8,r5
800037e0:	c1 10       	breq	80003802 <sd_mmc_spi_internal_init+0x192>
800037e2:	c0 63       	brcs	800037ee <sd_mmc_spi_internal_init+0x17e>
800037e4:	30 29       	mov	r9,2
800037e6:	f2 08 18 00 	cp.b	r8,r9
800037ea:	c2 81       	brne	8000383a <sd_mmc_spi_internal_init+0x1ca>
800037ec:	c1 98       	rjmp	8000381e <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
800037ee:	06 9b       	mov	r11,r3
800037f0:	30 1c       	mov	r12,1
800037f2:	f0 1f 00 42 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
800037f6:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800037f8:	04 9b       	mov	r11,r2
800037fa:	02 9c       	mov	r12,r1
800037fc:	f0 1f 00 3b 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
      break;
80003800:	c1 d8       	rjmp	8000383a <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80003802:	06 9b       	mov	r11,r3
80003804:	00 9c       	mov	r12,r0
80003806:	f0 1f 00 3d 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000380a:	06 9b       	mov	r11,r3
8000380c:	32 9c       	mov	r12,41
8000380e:	f0 1f 00 3b 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
80003812:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003814:	04 9b       	mov	r11,r2
80003816:	02 9c       	mov	r12,r1
80003818:	f0 1f 00 34 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
      break;
8000381c:	c0 f8       	rjmp	8000383a <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000381e:	06 9b       	mov	r11,r3
80003820:	00 9c       	mov	r12,r0
80003822:	f0 1f 00 36 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
80003826:	fc 1b 40 00 	movh	r11,0x4000
8000382a:	32 9c       	mov	r12,41
8000382c:	f0 1f 00 33 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
80003830:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003832:	04 9b       	mov	r11,r2
80003834:	02 9c       	mov	r12,r1
80003836:	f0 1f 00 2d 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
8000383a:	2f f7       	sub	r7,-1
8000383c:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
8000383e:	fe 78 c3 50 	mov	r8,-15536
80003842:	f0 07 19 00 	cp.h	r7,r8
80003846:	c4 80       	breq	800038d6 <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
80003848:	0d 89       	ld.ub	r9,r6[0x0]
8000384a:	30 08       	mov	r8,0
8000384c:	f0 09 18 00 	cp.b	r9,r8
80003850:	cc 51       	brne	800037da <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80003852:	4a 98       	lddpc	r8,800038f4 <sd_mmc_spi_internal_init+0x284>
80003854:	11 89       	ld.ub	r9,r8[0x0]
80003856:	30 28       	mov	r8,2
80003858:	f0 09 18 00 	cp.b	r9,r8
8000385c:	c0 a1       	brne	80003870 <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
8000385e:	f0 1f 00 2a 	mcall	80003904 <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
80003862:	5b fc       	cp.w	r12,-1
80003864:	c3 90       	breq	800038d6 <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
80003866:	58 1c       	cp.w	r12,1
80003868:	c0 41       	brne	80003870 <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
8000386a:	30 39       	mov	r9,3
8000386c:	4a 28       	lddpc	r8,800038f4 <sd_mmc_spi_internal_init+0x284>
8000386e:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80003870:	30 0b       	mov	r11,0
80003872:	33 bc       	mov	r12,59
80003874:	f0 1f 00 21 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
80003878:	4a 17       	lddpc	r7,800038fc <sd_mmc_spi_internal_init+0x28c>
8000387a:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000387c:	e0 6b 00 ff 	mov	r11,255
80003880:	fe 7c 24 00 	mov	r12,-56320
80003884:	f0 1f 00 19 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80003888:	e0 6b 02 00 	mov	r11,512
8000388c:	31 0c       	mov	r12,16
8000388e:	f0 1f 00 1b 	mcall	800038f8 <sd_mmc_spi_internal_init+0x288>
80003892:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003894:	e0 6b 00 ff 	mov	r11,255
80003898:	fe 7c 24 00 	mov	r12,-56320
8000389c:	f0 1f 00 13 	mcall	800038e8 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
800038a0:	0f 89       	ld.ub	r9,r7[0x0]
800038a2:	30 08       	mov	r8,0
800038a4:	f0 09 18 00 	cp.b	r9,r8
800038a8:	c1 71       	brne	800038d6 <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
800038aa:	49 8c       	lddpc	r12,80003908 <sd_mmc_spi_internal_init+0x298>
800038ac:	f0 1f 00 18 	mcall	8000390c <sd_mmc_spi_internal_init+0x29c>
800038b0:	c1 30       	breq	800038d6 <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
800038b2:	f0 1f 00 18 	mcall	80003910 <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
800038b6:	30 19       	mov	r9,1
800038b8:	48 e8       	lddpc	r8,800038f0 <sd_mmc_spi_internal_init+0x280>
800038ba:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
800038bc:	48 7b       	lddpc	r11,800038d8 <sd_mmc_spi_internal_init+0x268>
800038be:	e0 68 1b 00 	mov	r8,6912
800038c2:	ea 18 00 b7 	orh	r8,0xb7
800038c6:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800038c8:	48 58       	lddpc	r8,800038dc <sd_mmc_spi_internal_init+0x26c>
800038ca:	70 0a       	ld.w	r10,r8[0x0]
800038cc:	fe 7c 24 00 	mov	r12,-56320
800038d0:	f0 1f 00 04 	mcall	800038e0 <sd_mmc_spi_internal_init+0x270>
800038d4:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
800038d6:	d8 3a       	popm	r0-r7,pc,r12=0
800038d8:	00 00       	add	r0,r0
800038da:	05 5c       	ld.sh	r12,--r2
800038dc:	00 00       	add	r0,r0
800038de:	05 6c       	ld.uh	r12,--r2
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	43 48       	lddsp	r8,sp[0xd0]
800038e4:	80 00       	ld.sh	r0,r0[0x0]
800038e6:	44 74       	lddsp	r4,sp[0x11c]
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	43 0c       	lddsp	r12,sp[0xc0]
800038ec:	80 00       	ld.sh	r0,r0[0x0]
800038ee:	44 34       	lddsp	r4,sp[0x10c]
800038f0:	00 00       	add	r0,r0
800038f2:	05 70       	ld.ub	r0,--r2
800038f4:	00 00       	add	r0,r0
800038f6:	13 6e       	ld.uh	lr,--r9
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	30 b8       	mov	r8,11
800038fc:	00 00       	add	r0,r0
800038fe:	13 80       	ld.ub	r0,r9[0x0]
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	33 60       	mov	r0,54
80003904:	80 00       	ld.sh	r0,r0[0x0]
80003906:	32 d4       	mov	r4,45
80003908:	00 00       	add	r0,r0
8000390a:	13 70       	ld.ub	r0,--r9
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	35 7c       	mov	r12,87
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	2e 00       	sub	r0,-32

80003914 <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80003914:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
80003916:	f0 1f 00 07 	mcall	80003930 <sd_mmc_spi_mem_check+0x1c>
8000391a:	c0 a0       	breq	8000392e <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
8000391c:	48 68       	lddpc	r8,80003934 <sd_mmc_spi_mem_check+0x20>
8000391e:	11 89       	ld.ub	r9,r8[0x0]
80003920:	30 08       	mov	r8,0
80003922:	f0 09 18 00 	cp.b	r9,r8
80003926:	c0 20       	breq	8000392a <sd_mmc_spi_mem_check+0x16>
80003928:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
8000392a:	f0 1f 00 04 	mcall	80003938 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
8000392e:	d8 02       	popm	pc
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	30 f8       	mov	r8,15
80003934:	00 00       	add	r0,r0
80003936:	05 70       	ld.ub	r0,--r2
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	36 70       	mov	r0,103

8000393c <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
8000393c:	eb cd 40 10 	pushm	r4,lr
80003940:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
80003944:	48 88       	lddpc	r8,80003964 <sd_mmc_spi_init+0x28>
80003946:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
80003948:	48 88       	lddpc	r8,80003968 <sd_mmc_spi_init+0x2c>
8000394a:	e8 ea 00 00 	ld.d	r10,r4[0]
8000394e:	f0 eb 00 00 	st.d	r8[0],r10
80003952:	e8 ea 00 08 	ld.d	r10,r4[8]
80003956:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
8000395a:	f0 1f 00 05 	mcall	8000396c <sd_mmc_spi_init+0x30>
}
8000395e:	e3 cd 80 10 	ldm	sp++,r4,pc
80003962:	00 00       	add	r0,r0
80003964:	00 00       	add	r0,r0
80003966:	05 6c       	ld.uh	r12,--r2
80003968:	00 00       	add	r0,r0
8000396a:	05 5c       	ld.sh	r12,--r2
8000396c:	80 00       	ld.sh	r0,r0[0x0]
8000396e:	36 70       	mov	r0,103

80003970 <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
80003970:	5e fd       	retal	0

80003972 <sd_mmc_spi_removal>:
//!/
bool  sd_mmc_spi_removal(void)
{
  return false;
//  return ((sd_mmc_spi_check_presence()) ? false : true);
}
80003972:	5e fd       	retal	0

80003974 <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
80003974:	d4 01       	pushm	lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
80003976:	49 88       	lddpc	r8,800039d4 <sd_mmc_spi_test_unit_ready+0x60>
80003978:	11 88       	ld.ub	r8,r8[0x0]
8000397a:	30 19       	mov	r9,1
8000397c:	f2 08 18 00 	cp.b	r8,r9
80003980:	c1 40       	breq	800039a8 <sd_mmc_spi_test_unit_ready+0x34>
80003982:	c0 63       	brcs	8000398e <sd_mmc_spi_test_unit_ready+0x1a>
80003984:	30 29       	mov	r9,2
80003986:	f2 08 18 00 	cp.b	r8,r9
8000398a:	c2 01       	brne	800039ca <sd_mmc_spi_test_unit_ready+0x56>
8000398c:	c1 a8       	rjmp	800039c0 <sd_mmc_spi_test_unit_ready+0x4c>
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
8000398e:	30 09       	mov	r9,0
80003990:	49 28       	lddpc	r8,800039d8 <sd_mmc_spi_test_unit_ready+0x64>
80003992:	b0 89       	st.b	r8[0x0],r9
      if (sd_mmc_spi_mem_check())
80003994:	f0 1f 00 12 	mcall	800039dc <sd_mmc_spi_test_unit_ready+0x68>
80003998:	c0 31       	brne	8000399e <sd_mmc_spi_test_unit_ready+0x2a>
8000399a:	30 2c       	mov	r12,2
8000399c:	d8 02       	popm	pc
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
8000399e:	30 19       	mov	r9,1
800039a0:	48 d8       	lddpc	r8,800039d4 <sd_mmc_spi_test_unit_ready+0x60>
800039a2:	b0 89       	st.b	r8[0x0],r9
800039a4:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
800039a6:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
800039a8:	f0 1f 00 0d 	mcall	800039dc <sd_mmc_spi_test_unit_ready+0x68>
800039ac:	c0 20       	breq	800039b0 <sd_mmc_spi_test_unit_ready+0x3c>
800039ae:	d8 0a       	popm	pc,r12=0
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
800039b0:	30 29       	mov	r9,2
800039b2:	48 98       	lddpc	r8,800039d4 <sd_mmc_spi_test_unit_ready+0x60>
800039b4:	b0 89       	st.b	r8[0x0],r9
        sd_mmc_spi_init_done = false;
800039b6:	30 09       	mov	r9,0
800039b8:	48 88       	lddpc	r8,800039d8 <sd_mmc_spi_test_unit_ready+0x64>
800039ba:	b0 89       	st.b	r8[0x0],r9
800039bc:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
800039be:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
800039c0:	30 09       	mov	r9,0
800039c2:	48 58       	lddpc	r8,800039d4 <sd_mmc_spi_test_unit_ready+0x60>
800039c4:	b0 89       	st.b	r8[0x0],r9
800039c6:	30 2c       	mov	r12,2
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
800039c8:	d8 02       	popm	pc

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
800039ca:	30 09       	mov	r9,0
800039cc:	48 28       	lddpc	r8,800039d4 <sd_mmc_spi_test_unit_ready+0x60>
800039ce:	b0 89       	st.b	r8[0x0],r9
800039d0:	30 3c       	mov	r12,3
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
800039d2:	d8 02       	popm	pc
800039d4:	00 00       	add	r0,r0
800039d6:	00 20       	rsub	r0,r0
800039d8:	00 00       	add	r0,r0
800039da:	05 70       	ld.ub	r0,--r2
800039dc:	80 00       	ld.sh	r0,r0[0x0]
800039de:	39 14       	mov	r4,-111

800039e0 <sd_mmc_spi_mem_init>:

//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
800039e0:	d4 01       	pushm	lr
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
800039e2:	f0 1f 00 02 	mcall	800039e8 <sd_mmc_spi_mem_init+0x8>
}
800039e6:	d8 02       	popm	pc
800039e8:	80 00       	ld.sh	r0,r0[0x0]
800039ea:	36 70       	mov	r0,103

800039ec <sd_mmc_spi_ram_2_mem>:
//! @return                Ctrl_status
//!   It is ready      ->    CTRL_GOOD
//!   An error occurs  ->    CTRL_FAIL
//!
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
800039ec:	eb cd 40 c0 	pushm	r6-r7,lr
800039f0:	18 96       	mov	r6,r12
800039f2:	16 97       	mov	r7,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
800039f4:	f0 1f 00 12 	mcall	80003a3c <sd_mmc_spi_ram_2_mem+0x50>

   if (!sd_mmc_spi_init_done)
800039f8:	49 28       	lddpc	r8,80003a40 <sd_mmc_spi_ram_2_mem+0x54>
800039fa:	11 89       	ld.ub	r9,r8[0x0]
800039fc:	30 08       	mov	r8,0
800039fe:	f0 09 18 00 	cp.b	r9,r8
80003a02:	c0 c1       	brne	80003a1a <sd_mmc_spi_ram_2_mem+0x2e>
   {
      sd_mmc_spi_mem_init();
80003a04:	f0 1f 00 10 	mcall	80003a44 <sd_mmc_spi_ram_2_mem+0x58>
   }

   if (sd_mmc_spi_init_done)
80003a08:	48 e8       	lddpc	r8,80003a40 <sd_mmc_spi_ram_2_mem+0x54>
80003a0a:	11 89       	ld.ub	r9,r8[0x0]
80003a0c:	30 08       	mov	r8,0
80003a0e:	f0 09 18 00 	cp.b	r9,r8
80003a12:	c0 41       	brne	80003a1a <sd_mmc_spi_ram_2_mem+0x2e>
80003a14:	30 2c       	mov	r12,2
80003a16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   {
     sd_mmc_spi_write_open(addr);
80003a1a:	0c 9c       	mov	r12,r6
80003a1c:	f0 1f 00 0b 	mcall	80003a48 <sd_mmc_spi_ram_2_mem+0x5c>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
80003a20:	0e 9c       	mov	r12,r7
80003a22:	f0 1f 00 0b 	mcall	80003a4c <sd_mmc_spi_ram_2_mem+0x60>
80003a26:	c0 61       	brne	80003a32 <sd_mmc_spi_ram_2_mem+0x46>
     {
       sd_mmc_spi_write_close();
80003a28:	f0 1f 00 0a 	mcall	80003a50 <sd_mmc_spi_ram_2_mem+0x64>
80003a2c:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
80003a2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     }
     sd_mmc_spi_write_close();
80003a32:	f0 1f 00 08 	mcall	80003a50 <sd_mmc_spi_ram_2_mem+0x64>
80003a36:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003a3a:	00 00       	add	r0,r0
80003a3c:	80 00       	ld.sh	r0,r0[0x0]
80003a3e:	30 f8       	mov	r8,15
80003a40:	00 00       	add	r0,r0
80003a42:	05 70       	ld.ub	r0,--r2
80003a44:	80 00       	ld.sh	r0,r0[0x0]
80003a46:	39 e0       	mov	r0,-98
80003a48:	80 00       	ld.sh	r0,r0[0x0]
80003a4a:	2f ac       	sub	r12,-6
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	31 74       	mov	r4,23
80003a50:	80 00       	ld.sh	r0,r0[0x0]
80003a52:	2f 1c       	sub	r12,-15

80003a54 <sd_mmc_spi_mem_2_ram>:
//------------ Standard functions for read/write 1 sector to 1 sector ram buffer -----------------

#if ACCESS_MEM_TO_RAM == true

Ctrl_status sd_mmc_spi_mem_2_ram(uint32_t addr, void *ram)
{
80003a54:	eb cd 40 c0 	pushm	r6-r7,lr
80003a58:	18 97       	mov	r7,r12
80003a5a:	16 96       	mov	r6,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
80003a5c:	f0 1f 00 12 	mcall	80003aa4 <sd_mmc_spi_mem_2_ram+0x50>

   if (!sd_mmc_spi_init_done)
80003a60:	49 28       	lddpc	r8,80003aa8 <sd_mmc_spi_mem_2_ram+0x54>
80003a62:	11 89       	ld.ub	r9,r8[0x0]
80003a64:	30 08       	mov	r8,0
80003a66:	f0 09 18 00 	cp.b	r9,r8
80003a6a:	c0 c1       	brne	80003a82 <sd_mmc_spi_mem_2_ram+0x2e>
   {
      sd_mmc_spi_mem_init();
80003a6c:	f0 1f 00 10 	mcall	80003aac <sd_mmc_spi_mem_2_ram+0x58>
   }

   if (!sd_mmc_spi_init_done)
80003a70:	48 e8       	lddpc	r8,80003aa8 <sd_mmc_spi_mem_2_ram+0x54>
80003a72:	11 89       	ld.ub	r9,r8[0x0]
80003a74:	30 08       	mov	r8,0
80003a76:	f0 09 18 00 	cp.b	r9,r8
80003a7a:	c0 41       	brne	80003a82 <sd_mmc_spi_mem_2_ram+0x2e>
80003a7c:	30 2c       	mov	r12,2
80003a7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
80003a82:	0e 9c       	mov	r12,r7
80003a84:	f0 1f 00 0b 	mcall	80003ab0 <sd_mmc_spi_mem_2_ram+0x5c>
80003a88:	c0 c0       	breq	80003aa0 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
80003a8a:	0c 9c       	mov	r12,r6
80003a8c:	f0 1f 00 0a 	mcall	80003ab4 <sd_mmc_spi_mem_2_ram+0x60>
80003a90:	c0 80       	breq	80003aa0 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
80003a92:	f0 1f 00 0a 	mcall	80003ab8 <sd_mmc_spi_mem_2_ram+0x64>
80003a96:	ec 1c 00 01 	eorl	r12,0x1
80003a9a:	5c 5c       	castu.b	r12
80003a9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003aa0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003aa4:	80 00       	ld.sh	r0,r0[0x0]
80003aa6:	30 f8       	mov	r8,15
80003aa8:	00 00       	add	r0,r0
80003aaa:	05 70       	ld.ub	r0,--r2
80003aac:	80 00       	ld.sh	r0,r0[0x0]
80003aae:	39 e0       	mov	r0,-98
80003ab0:	80 00       	ld.sh	r0,r0[0x0]
80003ab2:	2f d4       	sub	r4,-3
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	34 18       	mov	r8,65
80003ab8:	80 00       	ld.sh	r0,r0[0x0]
80003aba:	2f c8       	sub	r8,-4

80003abc <sd_mmc_spi_read_capacity>:
}



Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector)
{
80003abc:	eb cd 40 80 	pushm	r7,lr
80003ac0:	18 97       	mov	r7,r12
//   sd_mmc_spi_check_presence();   // omitted because creates interferences with "sd_mmc_spi_test_unit_ready()" function
   Sd_mmc_spi_access_signal_on();

   if (!sd_mmc_spi_init_done)
80003ac2:	48 c8       	lddpc	r8,80003af0 <sd_mmc_spi_read_capacity+0x34>
80003ac4:	11 89       	ld.ub	r9,r8[0x0]
80003ac6:	30 08       	mov	r8,0
80003ac8:	f0 09 18 00 	cp.b	r9,r8
80003acc:	c0 c1       	brne	80003ae4 <sd_mmc_spi_read_capacity+0x28>
   {
      sd_mmc_spi_mem_init();
80003ace:	f0 1f 00 0a 	mcall	80003af4 <sd_mmc_spi_read_capacity+0x38>
   }

   if (sd_mmc_spi_init_done)
80003ad2:	48 88       	lddpc	r8,80003af0 <sd_mmc_spi_read_capacity+0x34>
80003ad4:	11 89       	ld.ub	r9,r8[0x0]
80003ad6:	30 08       	mov	r8,0
80003ad8:	f0 09 18 00 	cp.b	r9,r8
80003adc:	c0 41       	brne	80003ae4 <sd_mmc_spi_read_capacity+0x28>
80003ade:	30 2c       	mov	r12,2
80003ae0:	e3 cd 80 80 	ldm	sp++,r7,pc
   {
     *nb_sector = sd_mmc_spi_last_block_address+1;
80003ae4:	48 58       	lddpc	r8,80003af8 <sd_mmc_spi_read_capacity+0x3c>
80003ae6:	70 08       	ld.w	r8,r8[0x0]
80003ae8:	2f f8       	sub	r8,-1
80003aea:	8f 08       	st.w	r7[0x0],r8
80003aec:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80003af0:	00 00       	add	r0,r0
80003af2:	05 70       	ld.ub	r0,--r2
80003af4:	80 00       	ld.sh	r0,r0[0x0]
80003af6:	39 e0       	mov	r0,-98
80003af8:	00 00       	add	r0,r0
80003afa:	13 68       	ld.uh	r8,--r9

80003afc <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80003afc:	fe 78 0c 00 	mov	r8,-62464
80003b00:	71 d9       	ld.w	r9,r8[0x74]
80003b02:	a3 a9       	sbr	r9,0x2
80003b04:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80003b08:	78 28       	ld.w	r8,r12[0x8]
80003b0a:	bf b8       	sbr	r8,0x1f
80003b0c:	99 28       	st.w	r12[0x8],r8
}
80003b0e:	5e fc       	retal	r12

80003b10 <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
80003b10:	78 28       	ld.w	r8,r12[0x8]
80003b12:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80003b16:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
80003b18:	fe 78 0c 00 	mov	r8,-62464
80003b1c:	71 d9       	ld.w	r9,r8[0x74]
80003b1e:	a3 c9       	cbr	r9,0x2
80003b20:	f1 49 00 74 	st.w	r8[116],r9
}
80003b24:	5e fc       	retal	r12

80003b26 <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
80003b26:	78 28       	ld.w	r8,r12[0x8]
80003b28:	e6 18 40 00 	andh	r8,0x4000,COH
80003b2c:	c0 50       	breq	80003b36 <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
80003b2e:	78 28       	ld.w	r8,r12[0x8]
80003b30:	bf c8       	cbr	r8,0x1e
80003b32:	99 28       	st.w	r12[0x8],r8
80003b34:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
80003b36:	78 28       	ld.w	r8,r12[0x8]
80003b38:	bf a8       	sbr	r8,0x1e
80003b3a:	99 28       	st.w	r12[0x8],r8
80003b3c:	5e fc       	retal	r12

80003b3e <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003b3e:	fe 78 0c 00 	mov	r8,-62464
80003b42:	71 d9       	ld.w	r9,r8[0x74]
80003b44:	30 0c       	mov	r12,0
80003b46:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003b4a:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
80003b4e:	71 d9       	ld.w	r9,r8[0x74]
80003b50:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003b54:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
80003b58:	a9 6a       	lsl	r10,0x8
80003b5a:	16 3a       	cp.w	r10,r11
80003b5c:	e0 88 00 09 	brls	80003b6e <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80003b60:	71 d9       	ld.w	r9,r8[0x74]
80003b62:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003b66:	f1 49 00 74 	st.w	r8[116],r9
80003b6a:	31 6c       	mov	r12,22
    return EINVAL;
80003b6c:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
80003b6e:	f6 0a 0d 08 	divu	r8,r11,r10
80003b72:	5c 88       	casts.h	r8

  if (div > 1) {
80003b74:	30 19       	mov	r9,1
80003b76:	f2 08 19 00 	cp.h	r8,r9
80003b7a:	e0 88 00 14 	brls	80003ba2 <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
80003b7e:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
80003b82:	20 1c       	sub	r12,1
80003b84:	5c 5c       	castu.b	r12
80003b86:	fe 79 0c 00 	mov	r9,-62464
80003b8a:	73 da       	ld.w	r10,r9[0x74]
80003b8c:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
80003b90:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
80003b94:	73 da       	ld.w	r10,r9[0x74]
80003b96:	30 1c       	mov	r12,1
80003b98:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003b9c:	f3 4a 00 74 	st.w	r9[116],r10
80003ba0:	c0 98       	rjmp	80003bb2 <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80003ba2:	fe 79 0c 00 	mov	r9,-62464
80003ba6:	73 da       	ld.w	r10,r9[0x74]
80003ba8:	30 0c       	mov	r12,0
80003baa:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003bae:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
80003bb2:	5c 78       	castu.h	r8
80003bb4:	a9 68       	lsl	r8,0x8
80003bb6:	f6 08 0d 0a 	divu	r10,r11,r8
80003bba:	5e fa       	retal	r10

80003bbc <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80003bbc:	e0 4c 56 22 	cp.w	r12,22050
80003bc0:	e0 80 00 8d 	breq	80003cda <abdac_set_dac_sample_rate+0x11e>
80003bc4:	e0 8b 00 12 	brhi	80003be8 <abdac_set_dac_sample_rate+0x2c>
80003bc8:	e0 4c 2b 11 	cp.w	r12,11025
80003bcc:	c3 b0       	breq	80003c42 <abdac_set_dac_sample_rate+0x86>
80003bce:	e0 8b 00 06 	brhi	80003bda <abdac_set_dac_sample_rate+0x1e>
80003bd2:	e0 4c 1f 40 	cp.w	r12,8000
80003bd6:	c1 b1       	brne	80003c0c <abdac_set_dac_sample_rate+0x50>
80003bd8:	c1 b8       	rjmp	80003c0e <abdac_set_dac_sample_rate+0x52>
80003bda:	e0 4c 2e e0 	cp.w	r12,12000
80003bde:	c4 b0       	breq	80003c74 <abdac_set_dac_sample_rate+0xb8>
80003be0:	e0 4c 3e 80 	cp.w	r12,16000
80003be4:	c1 41       	brne	80003c0c <abdac_set_dac_sample_rate+0x50>
80003be6:	c6 18       	rjmp	80003ca8 <abdac_set_dac_sample_rate+0xec>
80003be8:	e0 4c 7d 00 	cp.w	r12,32000
80003bec:	e0 80 00 aa 	breq	80003d40 <abdac_set_dac_sample_rate+0x184>
80003bf0:	e0 8b 00 06 	brhi	80003bfc <abdac_set_dac_sample_rate+0x40>
80003bf4:	e0 4c 5d c0 	cp.w	r12,24000
80003bf8:	c0 a1       	brne	80003c0c <abdac_set_dac_sample_rate+0x50>
80003bfa:	c8 98       	rjmp	80003d0c <abdac_set_dac_sample_rate+0x150>
80003bfc:	e0 4c ac 44 	cp.w	r12,44100
80003c00:	e0 80 00 b9 	breq	80003d72 <abdac_set_dac_sample_rate+0x1b6>
80003c04:	e0 4c bb 80 	cp.w	r12,48000
80003c08:	e0 80 00 ce 	breq	80003da4 <abdac_set_dac_sample_rate+0x1e8>
80003c0c:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80003c0e:	fe 78 0c 00 	mov	r8,-62464
80003c12:	71 d9       	ld.w	r9,r8[0x74]
80003c14:	30 ea       	mov	r10,14
80003c16:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003c1a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003c1e:	71 d9       	ld.w	r9,r8[0x74]
80003c20:	30 1c       	mov	r12,1
80003c22:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003c26:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003c2a:	71 d9       	ld.w	r9,r8[0x74]
80003c2c:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003c30:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003c34:	71 d9       	ld.w	r9,r8[0x74]
80003c36:	30 0a       	mov	r10,0
80003c38:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003c3c:	f1 49 00 74 	st.w	r8[116],r9
      break;
80003c40:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003c42:	fe 78 0c 00 	mov	r8,-62464
80003c46:	71 d9       	ld.w	r9,r8[0x74]
80003c48:	30 1c       	mov	r12,1
80003c4a:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003c4e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003c52:	71 d9       	ld.w	r9,r8[0x74]
80003c54:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003c58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003c5c:	71 d9       	ld.w	r9,r8[0x74]
80003c5e:	30 0a       	mov	r10,0
80003c60:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003c64:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003c68:	71 d9       	ld.w	r9,r8[0x74]
80003c6a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003c6e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003c72:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
80003c74:	fe 78 0c 00 	mov	r8,-62464
80003c78:	71 d9       	ld.w	r9,r8[0x74]
80003c7a:	30 9a       	mov	r10,9
80003c7c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003c80:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003c84:	71 d9       	ld.w	r9,r8[0x74]
80003c86:	30 1c       	mov	r12,1
80003c88:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003c8c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003c90:	71 d9       	ld.w	r9,r8[0x74]
80003c92:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003c96:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003c9a:	71 d9       	ld.w	r9,r8[0x74]
80003c9c:	30 0a       	mov	r10,0
80003c9e:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003ca2:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003ca6:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80003ca8:	fe 78 0c 00 	mov	r8,-62464
80003cac:	71 d9       	ld.w	r9,r8[0x74]
80003cae:	30 5a       	mov	r10,5
80003cb0:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003cb4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003cb8:	71 d9       	ld.w	r9,r8[0x74]
80003cba:	30 1c       	mov	r12,1
80003cbc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003cc0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003cc4:	71 d9       	ld.w	r9,r8[0x74]
80003cc6:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003cca:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003cce:	71 d9       	ld.w	r9,r8[0x74]
80003cd0:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003cd4:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003cd8:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80003cda:	fe 78 0c 00 	mov	r8,-62464
80003cde:	71 d9       	ld.w	r9,r8[0x74]
80003ce0:	30 0a       	mov	r10,0
80003ce2:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003ce6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80003cea:	71 d9       	ld.w	r9,r8[0x74]
80003cec:	30 1c       	mov	r12,1
80003cee:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003cf2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003cf6:	71 d9       	ld.w	r9,r8[0x74]
80003cf8:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003cfc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003d00:	71 d9       	ld.w	r9,r8[0x74]
80003d02:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003d06:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003d0a:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80003d0c:	fe 78 0c 00 	mov	r8,-62464
80003d10:	71 d9       	ld.w	r9,r8[0x74]
80003d12:	30 4a       	mov	r10,4
80003d14:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003d18:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d1c:	71 d9       	ld.w	r9,r8[0x74]
80003d1e:	30 1c       	mov	r12,1
80003d20:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d24:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003d28:	71 d9       	ld.w	r9,r8[0x74]
80003d2a:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003d2e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003d32:	71 d9       	ld.w	r9,r8[0x74]
80003d34:	30 0a       	mov	r10,0
80003d36:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003d3a:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003d3e:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
80003d40:	fe 78 0c 00 	mov	r8,-62464
80003d44:	71 d9       	ld.w	r9,r8[0x74]
80003d46:	30 2a       	mov	r10,2
80003d48:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003d4c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d50:	71 d9       	ld.w	r9,r8[0x74]
80003d52:	30 1c       	mov	r12,1
80003d54:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003d5c:	71 d9       	ld.w	r9,r8[0x74]
80003d5e:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003d62:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003d66:	71 d9       	ld.w	r9,r8[0x74]
80003d68:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003d6c:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003d70:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
80003d72:	fe 78 0c 00 	mov	r8,-62464
80003d76:	71 da       	ld.w	r10,r8[0x74]
80003d78:	30 09       	mov	r9,0
80003d7a:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
80003d7e:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
80003d82:	71 da       	ld.w	r10,r8[0x74]
80003d84:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80003d88:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003d8c:	71 da       	ld.w	r10,r8[0x74]
80003d8e:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
80003d92:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003d96:	71 d9       	ld.w	r9,r8[0x74]
80003d98:	30 1c       	mov	r12,1
80003d9a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003d9e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003da2:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003da4:	fe 78 0c 00 	mov	r8,-62464
80003da8:	71 d9       	ld.w	r9,r8[0x74]
80003daa:	30 1c       	mov	r12,1
80003dac:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003db0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003db4:	71 d9       	ld.w	r9,r8[0x74]
80003db6:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003dba:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003dbe:	71 d9       	ld.w	r9,r8[0x74]
80003dc0:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003dc4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003dc8:	71 d9       	ld.w	r9,r8[0x74]
80003dca:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003dce:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
80003dd2:	5e fc       	retal	r12

80003dd4 <sdramc_ck_delay>:
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
80003dd4:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
80003dd8:	f0 0c 00 0c 	add	r12,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80003ddc:	18 38       	cp.w	r8,r12
80003dde:	e0 88 00 06 	brls	80003dea <sdramc_ck_delay+0x16>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80003de2:	e1 b8 00 42 	mfsr	r8,0x108
80003de6:	10 3c       	cp.w	r12,r8
80003de8:	cf d3       	brcs	80003de2 <sdramc_ck_delay+0xe>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
80003dea:	e1 b8 00 42 	mfsr	r8,0x108
80003dee:	10 3c       	cp.w	r12,r8
80003df0:	fe 9b ff fd 	brhi	80003dea <sdramc_ck_delay+0x16>
}
80003df4:	5e fc       	retal	r12
80003df6:	d7 03       	nop

80003df8 <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
80003df8:	d4 31       	pushm	r0-r7,lr
80003dfa:	20 2d       	sub	sp,8
80003dfc:	18 91       	mov	r1,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003dfe:	ee 7b 42 3f 	mov	r11,999999
80003e02:	f8 0b 00 09 	add	r9,r12,r11
80003e06:	e0 60 de 83 	mov	r0,56963
80003e0a:	ea 10 43 1b 	orh	r0,0x431b
80003e0e:	f2 00 06 48 	mulu.d	r8,r9,r0
80003e12:	f2 06 16 12 	lsr	r6,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
80003e16:	32 7b       	mov	r11,39
80003e18:	4d 0c       	lddpc	r12,80003f58 <sdramc_init+0x160>
80003e1a:	f0 1f 00 51 	mcall	80003f5c <sdramc_init+0x164>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80003e1e:	fe 68 10 00 	mov	r8,-126976
80003e22:	f0 f9 01 24 	ld.w	r9,r8[292]
80003e26:	a1 b9       	sbr	r9,0x1
80003e28:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80003e2c:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80003e30:	ec 09 15 04 	lsl	r9,r6,0x4
80003e34:	0c 19       	sub	r9,r6
80003e36:	f2 c3 fc 19 	sub	r3,r9,-999
80003e3a:	e0 65 4d d3 	mov	r5,19923
80003e3e:	ea 15 10 62 	orh	r5,0x1062
80003e42:	e6 05 06 42 	mulu.d	r2,r3,r5
80003e46:	a7 83       	lsr	r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80003e48:	ec 02 15 05 	lsl	r2,r6,0x5
80003e4c:	0c 02       	add	r2,r6
80003e4e:	a1 72       	lsl	r2,0x1
80003e50:	e4 06 00 0b 	add	r11,r2,r6
80003e54:	f6 cb fc 19 	sub	r11,r11,-999
80003e58:	f6 05 06 4a 	mulu.d	r10,r11,r5
80003e5c:	a7 8b       	lsr	r11,0x6
80003e5e:	bd 6b       	lsl	r11,0x1c
80003e60:	16 9c       	mov	r12,r11
80003e62:	e8 1c 00 d9 	orl	r12,0xd9
80003e66:	ec 08 15 03 	lsl	r8,r6,0x3
80003e6a:	f0 06 01 0a 	sub	r10,r8,r6
80003e6e:	a1 7a       	lsl	r10,0x1
80003e70:	f4 c7 fc 19 	sub	r7,r10,-999
80003e74:	ee 05 06 4a 	mulu.d	r10,r7,r5
80003e78:	fa eb 00 00 	st.d	sp[0],r10
80003e7c:	40 0a       	lddsp	r10,sp[0x0]
80003e7e:	a3 6a       	lsl	r10,0x2
80003e80:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003e84:	14 4c       	or	r12,r10
80003e86:	a3 69       	lsl	r9,0x2
80003e88:	f2 c9 fc 19 	sub	r9,r9,-999
80003e8c:	f2 05 06 4a 	mulu.d	r10,r9,r5
80003e90:	fa eb 00 00 	st.d	sp[0],r10
80003e94:	40 09       	lddsp	r9,sp[0x0]
80003e96:	a7 69       	lsl	r9,0x6
80003e98:	e2 19 f0 00 	andl	r9,0xf000,COH
80003e9c:	f9 e9 10 0a 	or	r10,r12,r9
80003ea0:	e6 09 15 10 	lsl	r9,r3,0x10
80003ea4:	e6 19 00 0f 	andh	r9,0xf,COH
80003ea8:	12 4a       	or	r10,r9
80003eaa:	e6 09 15 14 	lsl	r9,r3,0x14
80003eae:	e6 19 00 f0 	andh	r9,0xf0,COH
80003eb2:	12 4a       	or	r10,r9
80003eb4:	f0 06 00 09 	add	r9,r8,r6
80003eb8:	ec 09 00 29 	add	r9,r6,r9<<0x2
80003ebc:	f2 c9 fc 19 	sub	r9,r9,-999
80003ec0:	f2 05 06 48 	mulu.d	r8,r9,r5
80003ec4:	b3 69       	lsl	r9,0x12
80003ec6:	e6 19 0f 00 	andh	r9,0xf00,COH
80003eca:	f5 e9 10 08 	or	r8,r10,r9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
80003ece:	fe 67 20 00 	mov	r7,-122880
80003ed2:	8f 28       	st.w	r7[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
80003ed4:	6e 28       	ld.w	r8,r7[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
80003ed6:	30 18       	mov	r8,1
80003ed8:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003eda:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003edc:	fc 14 d0 00 	movh	r4,0xd000
80003ee0:	88 08       	ld.sh	r8,r4[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
80003ee2:	ec 0c 10 64 	mul	r12,r6,100
80003ee6:	f0 1f 00 1f 	mcall	80003f60 <sdramc_init+0x168>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
80003eea:	30 28       	mov	r8,2
80003eec:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003eee:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003ef0:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
80003ef2:	06 9c       	mov	r12,r3
80003ef4:	f0 1f 00 1b 	mcall	80003f60 <sdramc_init+0x168>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
80003ef8:	30 48       	mov	r8,4
80003efa:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003efc:	6e 08       	ld.w	r8,r7[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80003efe:	e4 c3 fc 19 	sub	r3,r2,-999
80003f02:	e6 05 06 42 	mulu.d	r2,r3,r5
80003f06:	a7 83       	lsr	r3,0x6
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80003f08:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80003f0a:	06 9c       	mov	r12,r3
80003f0c:	f0 1f 00 15 	mcall	80003f60 <sdramc_init+0x168>
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80003f10:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80003f12:	06 9c       	mov	r12,r3
80003f14:	f0 1f 00 13 	mcall	80003f60 <sdramc_init+0x168>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
80003f18:	30 38       	mov	r8,3
80003f1a:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003f1c:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003f1e:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
80003f20:	ec 09 15 01 	lsl	r9,r6,0x1
80003f24:	f2 c9 fc 19 	sub	r9,r9,-999
80003f28:	f2 05 06 48 	mulu.d	r8,r9,r5
80003f2c:	f2 0c 16 06 	lsr	r12,r9,0x6
80003f30:	f0 1f 00 0c 	mcall	80003f60 <sdramc_init+0x168>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
80003f34:	30 08       	mov	r8,0
80003f36:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003f38:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003f3a:	88 08       	ld.sh	r8,r4[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
80003f3c:	e2 00 06 40 	mulu.d	r0,r1,r0
80003f40:	b3 81       	lsr	r1,0x12
80003f42:	e0 68 1e 84 	mov	r8,7812
80003f46:	b1 31       	mul	r1,r8
80003f48:	e2 05 06 44 	mulu.d	r4,r1,r5
80003f4c:	a7 85       	lsr	r5,0x6
80003f4e:	8f 15       	st.w	r7[0x4],r5
  AVR32_SDRAMC.tr;
80003f50:	6e 18       	ld.w	r8,r7[0x4]
}
80003f52:	2f ed       	sub	sp,-8
80003f54:	d8 32       	popm	r0-r7,pc
80003f56:	00 00       	add	r0,r0
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	b5 58       	asr	r8,0x15
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	9d 88       	st.w	lr[0x20],r8
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	3d d4       	mov	r4,-35

80003f64 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80003f64:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003f68:	ee 78 42 3f 	mov	r8,999999
80003f6c:	f8 08 00 09 	add	r9,r12,r8
80003f70:	e0 68 de 83 	mov	r8,56963
80003f74:	ea 18 43 1b 	orh	r8,0x431b
80003f78:	f2 08 06 48 	mulu.d	r8,r9,r8
80003f7c:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80003f80:	f0 08 00 25 	add	r5,r8,r8<<0x2
80003f84:	a3 65       	lsl	r5,0x2
80003f86:	ea c5 fc 19 	sub	r5,r5,-999
80003f8a:	e0 69 4d d3 	mov	r9,19923
80003f8e:	ea 19 10 62 	orh	r9,0x1062
80003f92:	ea 09 06 44 	mulu.d	r4,r5,r9
80003f96:	a7 85       	lsr	r5,0x6
80003f98:	f0 0a 15 04 	lsl	r10,r8,0x4
80003f9c:	f4 08 01 07 	sub	r7,r10,r8
80003fa0:	a1 77       	lsl	r7,0x1
80003fa2:	ee c7 fc 19 	sub	r7,r7,-999
80003fa6:	ee 09 06 46 	mulu.d	r6,r7,r9
80003faa:	0e 94       	mov	r4,r7
80003fac:	a7 84       	lsr	r4,0x6
80003fae:	f4 08 01 07 	sub	r7,r10,r8
80003fb2:	a3 67       	lsl	r7,0x2
80003fb4:	ee c7 fc 19 	sub	r7,r7,-999
80003fb8:	ee 09 06 46 	mulu.d	r6,r7,r9
80003fbc:	a7 87       	lsr	r7,0x6
80003fbe:	f0 03 10 5a 	mul	r3,r8,90
80003fc2:	e6 c3 fc 19 	sub	r3,r3,-999
80003fc6:	e6 09 06 42 	mulu.d	r2,r3,r9
80003fca:	e6 0c 16 06 	lsr	r12,r3,0x6
80003fce:	e0 63 00 d2 	mov	r3,210
80003fd2:	f0 03 02 43 	mul	r3,r8,r3
80003fd6:	e6 c3 fc 19 	sub	r3,r3,-999
80003fda:	e6 09 06 42 	mulu.d	r2,r3,r9
80003fde:	e6 06 16 06 	lsr	r6,r3,0x6
80003fe2:	f4 08 01 0b 	sub	r11,r10,r8
80003fe6:	a5 6b       	lsl	r11,0x4
80003fe8:	f6 cb fc 19 	sub	r11,r11,-999
80003fec:	f6 09 06 4a 	mulu.d	r10,r11,r9
80003ff0:	f6 0e 16 06 	lsr	lr,r11,0x6
80003ff4:	f0 03 10 64 	mul	r3,r8,100
80003ff8:	e6 c3 fc 19 	sub	r3,r3,-999
80003ffc:	e6 09 06 42 	mulu.d	r2,r3,r9
80004000:	a7 83       	lsr	r3,0x6
80004002:	e0 6a 01 0e 	mov	r10,270
80004006:	b5 38       	mul	r8,r10
80004008:	f0 c8 fc 19 	sub	r8,r8,-999
8000400c:	f0 09 06 48 	mulu.d	r8,r8,r9
80004010:	a7 89       	lsr	r9,0x6
80004012:	ec 04 00 0a 	add	r10,r6,r4
80004016:	1c 3a       	cp.w	r10,lr
80004018:	f4 0e 17 20 	movhs	lr,r10
8000401c:	ee 05 00 0b 	add	r11,r7,r5
80004020:	18 3b       	cp.w	r11,r12
80004022:	f6 0c 17 20 	movhs	r12,r11
80004026:	06 3b       	cp.w	r11,r3
80004028:	e6 0b 17 30 	movlo	r11,r3
8000402c:	12 3a       	cp.w	r10,r9
8000402e:	f4 09 17 20 	movhs	r9,r10
80004032:	eb e4 11 05 	or	r5,r5,r4<<0x10
80004036:	fe 6a 1c 00 	mov	r10,-123904
8000403a:	95 05       	st.w	r10[0x0],r5
8000403c:	ef e6 11 07 	or	r7,r7,r6<<0x10
80004040:	ef ec 10 87 	or	r7,r7,r12<<0x8
80004044:	ef ee 11 87 	or	r7,r7,lr<<0x18
80004048:	95 17       	st.w	r10[0x4],r7
8000404a:	1c 39       	cp.w	r9,lr
8000404c:	f2 0e 17 20 	movhs	lr,r9
80004050:	18 3b       	cp.w	r11,r12
80004052:	f8 0b 17 30 	movlo	r11,r12
80004056:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
8000405a:	95 2b       	st.w	r10[0x8],r11
8000405c:	e0 68 10 03 	mov	r8,4099
80004060:	95 38       	st.w	r10[0xc],r8
80004062:	30 19       	mov	r9,1
80004064:	48 48       	lddpc	r8,80004074 <smc_init+0x110>
80004066:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80004068:	31 4b       	mov	r11,20
8000406a:	48 4c       	lddpc	r12,80004078 <smc_init+0x114>
8000406c:	f0 1f 00 04 	mcall	8000407c <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80004070:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004074:	00 00       	add	r0,r0
80004076:	05 74       	ld.ub	r4,--r2
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	b6 90       	st.b	r11[0x1],r0
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	9d 88       	st.w	lr[0x20],r8

80004080 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80004080:	30 e8       	mov	r8,14
80004082:	f0 0c 18 00 	cp.b	r12,r8
80004086:	e0 88 00 03 	brls	8000408c <pdca_get_handler+0xc>
8000408a:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000408c:	a7 6c       	lsl	r12,0x6
8000408e:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80004092:	5e fc       	retal	r12

80004094 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80004094:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80004096:	f0 1f 00 03 	mcall	800040a0 <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000409a:	30 28       	mov	r8,2
8000409c:	99 58       	st.w	r12[0x14],r8
}
8000409e:	d8 02       	popm	pc
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	40 80       	lddsp	r0,sp[0x20]

800040a4 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
800040a4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800040a6:	f0 1f 00 03 	mcall	800040b0 <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
800040aa:	30 18       	mov	r8,1
800040ac:	99 58       	st.w	r12[0x14],r8
}
800040ae:	d8 02       	popm	pc
800040b0:	80 00       	ld.sh	r0,r0[0x0]
800040b2:	40 80       	lddsp	r0,sp[0x20]

800040b4 <pdca_enable_interrupt_transfer_complete>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800040b4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800040b6:	f0 1f 00 03 	mcall	800040c0 <pdca_enable_interrupt_transfer_complete+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
800040ba:	30 28       	mov	r8,2
800040bc:	99 88       	st.w	r12[0x20],r8
}
800040be:	d8 02       	popm	pc
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	40 80       	lddsp	r0,sp[0x20]

800040c4 <pdca_enable_interrupt_reload_counter_zero>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800040c4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800040c6:	f0 1f 00 03 	mcall	800040d0 <pdca_enable_interrupt_reload_counter_zero+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
800040ca:	30 18       	mov	r8,1
800040cc:	99 88       	st.w	r12[0x20],r8
}
800040ce:	d8 02       	popm	pc
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	40 80       	lddsp	r0,sp[0x20]

800040d4 <pdca_get_transfer_status>:

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
800040d4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800040d6:	f0 1f 00 03 	mcall	800040e0 <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
800040da:	78 bc       	ld.w	r12,r12[0x2c]
}
800040dc:	d8 02       	popm	pc
800040de:	00 00       	add	r0,r0
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	40 80       	lddsp	r0,sp[0x20]

800040e4 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800040e4:	d4 01       	pushm	lr
800040e6:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800040e8:	f0 1f 00 08 	mcall	80004108 <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800040ec:	e1 b8 00 00 	mfsr	r8,0x0
800040f0:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800040f2:	d3 03       	ssrf	0x10

	return flags;
800040f4:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800040f6:	30 19       	mov	r9,1
800040f8:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800040fa:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800040fc:	e6 18 00 01 	andh	r8,0x1,COH
80004100:	c0 21       	brne	80004104 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
80004102:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80004104:	2f fd       	sub	sp,-4
80004106:	d8 02       	popm	pc
80004108:	80 00       	ld.sh	r0,r0[0x0]
8000410a:	40 80       	lddsp	r0,sp[0x20]

8000410c <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
8000410c:	d4 01       	pushm	lr
8000410e:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80004110:	f0 1f 00 08 	mcall	80004130 <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004114:	e1 b8 00 00 	mfsr	r8,0x0
80004118:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
8000411a:	d3 03       	ssrf	0x10

	return flags;
8000411c:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
8000411e:	30 29       	mov	r9,2
80004120:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
80004122:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004124:	e6 18 00 01 	andh	r8,0x1,COH
80004128:	c0 21       	brne	8000412c <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
8000412a:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
8000412c:	2f fd       	sub	sp,-4
8000412e:	d8 02       	popm	pc
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	40 80       	lddsp	r0,sp[0x20]

80004134 <pdca_reload_channel>:
	return pdca_channel->tcrr;
}

void pdca_reload_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
80004134:	eb cd 40 c0 	pushm	r6-r7,lr
80004138:	20 1d       	sub	sp,4
8000413a:	16 96       	mov	r6,r11
8000413c:	14 97       	mov	r7,r10
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000413e:	f0 1f 00 0b 	mcall	80004168 <pdca_reload_channel+0x34>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004142:	e1 b8 00 00 	mfsr	r8,0x0
80004146:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80004148:	d3 03       	ssrf	0x10

	return flags;
8000414a:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	/* set up next memory address */
	pdca_channel->marr = (uint32_t)addr;
8000414c:	99 36       	st.w	r12[0xc],r6
	/* set up next memory size */
	pdca_channel->tcrr = size;
8000414e:	99 47       	st.w	r12[0x10],r7
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80004150:	e0 69 01 00 	mov	r9,256
80004154:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
80004156:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004158:	e6 18 00 01 	andh	r8,0x1,COH
8000415c:	c0 21       	brne	80004160 <pdca_reload_channel+0x2c>
      cpu_irq_enable();
8000415e:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80004160:	2f fd       	sub	sp,-4
80004162:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004166:	00 00       	add	r0,r0
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	40 80       	lddsp	r0,sp[0x20]

8000416c <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
8000416c:	eb cd 40 e0 	pushm	r5-r7,lr
80004170:	20 1d       	sub	sp,4
80004172:	18 95       	mov	r5,r12
80004174:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80004176:	f0 1f 00 13 	mcall	800041c0 <pdca_init_channel+0x54>
8000417a:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
8000417c:	0a 9c       	mov	r12,r5
8000417e:	f0 1f 00 12 	mcall	800041c4 <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
80004182:	0a 9c       	mov	r12,r5
80004184:	f0 1f 00 11 	mcall	800041c8 <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004188:	e1 b8 00 00 	mfsr	r8,0x0
8000418c:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
8000418e:	d3 03       	ssrf	0x10

	return flags;
80004190:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
80004192:	6c 09       	ld.w	r9,r6[0x0]
80004194:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
80004196:	6c 19       	ld.w	r9,r6[0x4]
80004198:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
8000419a:	6c 49       	ld.w	r9,r6[0x10]
8000419c:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
8000419e:	6c 29       	ld.w	r9,r6[0x8]
800041a0:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
800041a2:	6c 39       	ld.w	r9,r6[0xc]
800041a4:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
800041a6:	6c 59       	ld.w	r9,r6[0x14]
800041a8:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
800041aa:	e0 69 01 00 	mov	r9,256
800041ae:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
800041b0:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800041b2:	e6 18 00 01 	andh	r8,0x1,COH
800041b6:	c0 21       	brne	800041ba <pdca_init_channel+0x4e>
      cpu_irq_enable();
800041b8:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
800041ba:	2f fd       	sub	sp,-4
800041bc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800041c0:	80 00       	ld.sh	r0,r0[0x0]
800041c2:	40 80       	lddsp	r0,sp[0x20]
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	41 0c       	lddsp	r12,sp[0x40]
800041c8:	80 00       	ld.sh	r0,r0[0x0]
800041ca:	40 e4       	lddsp	r4,sp[0x38]

800041cc <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
800041cc:	58 0b       	cp.w	r11,0
800041ce:	c1 90       	breq	80004200 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
800041d0:	58 6c       	cp.w	r12,6
800041d2:	e0 8b 00 17 	brhi	80004200 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
800041d6:	76 0a       	ld.w	r10,r11[0x0]
800041d8:	fe 78 30 00 	mov	r8,-53248
800041dc:	f8 c9 ff f0 	sub	r9,r12,-16
800041e0:	a5 79       	lsl	r9,0x5
800041e2:	f0 09 00 09 	add	r9,r8,r9
800041e6:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
800041e8:	76 19       	ld.w	r9,r11[0x4]
800041ea:	a5 7c       	lsl	r12,0x5
800041ec:	f0 0c 00 0c 	add	r12,r8,r12
800041f0:	f8 c8 fd fc 	sub	r8,r12,-516
800041f4:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800041f6:	76 28       	ld.w	r8,r11[0x8]
800041f8:	f8 cc fd f8 	sub	r12,r12,-520
800041fc:	99 08       	st.w	r12[0x0],r8
800041fe:	5e fd       	retal	0

  return PWM_SUCCESS;
80004200:	5e ff       	retal	1

80004202 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80004202:	18 98       	mov	r8,r12
80004204:	e0 18 ff 80 	andl	r8,0xff80
80004208:	c0 20       	breq	8000420c <pwm_start_channels+0xa>
8000420a:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
8000420c:	fe 78 30 00 	mov	r8,-53248
80004210:	91 1c       	st.w	r8[0x4],r12
80004212:	5e fd       	retal	0

80004214 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80004214:	58 6c       	cp.w	r12,6
80004216:	e0 88 00 03 	brls	8000421c <pwm_async_update_channel+0x8>
8000421a:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000421c:	76 0a       	ld.w	r10,r11[0x0]
8000421e:	fe 78 30 00 	mov	r8,-53248
80004222:	f8 c9 ff f0 	sub	r9,r12,-16
80004226:	a5 79       	lsl	r9,0x5
80004228:	f0 09 00 09 	add	r9,r8,r9
8000422c:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
8000422e:	76 49       	ld.w	r9,r11[0x10]
80004230:	a5 7c       	lsl	r12,0x5
80004232:	18 08       	add	r8,r12
80004234:	f0 c8 fd f0 	sub	r8,r8,-528
80004238:	91 09       	st.w	r8[0x0],r9
8000423a:	5e fd       	retal	0

8000423c <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000423c:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80004240:	58 0c       	cp.w	r12,0
80004242:	c0 21       	brne	80004246 <pwm_init+0xa>
80004244:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004246:	e6 18 00 01 	andh	r8,0x1,COH
8000424a:	c0 91       	brne	8000425c <pwm_init+0x20>
8000424c:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000424e:	fe 78 30 00 	mov	r8,-53248
80004252:	37 f9       	mov	r9,127
80004254:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80004256:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004258:	d5 03       	csrf	0x10
8000425a:	c0 68       	rjmp	80004266 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000425c:	fe 78 30 00 	mov	r8,-53248
80004260:	37 f9       	mov	r9,127
80004262:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80004264:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80004266:	78 08       	ld.w	r8,r12[0x0]
80004268:	78 39       	ld.w	r9,r12[0xc]
8000426a:	a9 69       	lsl	r9,0x8
8000426c:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80004270:	78 18       	ld.w	r8,r12[0x4]
80004272:	10 49       	or	r9,r8
80004274:	78 28       	ld.w	r8,r12[0x8]
80004276:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000427a:	fe 78 30 00 	mov	r8,-53248
8000427e:	91 09       	st.w	r8[0x0],r9
80004280:	5e fd       	retal	0

80004282 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80004282:	f8 c8 00 01 	sub	r8,r12,1
80004286:	f0 0b 00 0b 	add	r11,r8,r11
8000428a:	f6 0c 0d 0a 	divu	r10,r11,r12
8000428e:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80004290:	f4 c8 00 01 	sub	r8,r10,1
80004294:	e0 48 00 fe 	cp.w	r8,254
80004298:	e0 88 00 03 	brls	8000429e <getBaudDiv+0x1c>
8000429c:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
8000429e:	5c 8c       	casts.h	r12
}
800042a0:	5e fc       	retal	r12

800042a2 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800042a2:	f7 39 00 0d 	ld.ub	r9,r11[13]
800042a6:	30 18       	mov	r8,1
800042a8:	f0 09 18 00 	cp.b	r9,r8
800042ac:	e0 88 00 04 	brls	800042b4 <spi_initMaster+0x12>
800042b0:	30 2c       	mov	r12,2
800042b2:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800042b4:	e0 68 00 80 	mov	r8,128
800042b8:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800042ba:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800042bc:	30 19       	mov	r9,1
800042be:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800042c2:	f7 39 00 0d 	ld.ub	r9,r11[13]
800042c6:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800042ca:	30 09       	mov	r9,0
800042cc:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800042d0:	30 fa       	mov	r10,15
800042d2:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800042d6:	99 18       	st.w	r12[0x4],r8
800042d8:	5e f9       	retal	r9

800042da <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800042da:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800042dc:	30 18       	mov	r8,1
800042de:	f0 0b 18 00 	cp.b	r11,r8
800042e2:	5f be       	srhi	lr
800042e4:	f0 0a 18 00 	cp.b	r10,r8
800042e8:	5f b8       	srhi	r8
800042ea:	fd e8 10 08 	or	r8,lr,r8
800042ee:	c0 30       	breq	800042f4 <spi_selectionMode+0x1a>
800042f0:	30 2c       	mov	r12,2
800042f2:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800042f4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800042f6:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800042fa:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800042fe:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80004302:	99 18       	st.w	r12[0x4],r8
80004304:	d8 0a       	popm	pc,r12=0

80004306 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80004306:	30 18       	mov	r8,1
80004308:	99 08       	st.w	r12[0x0],r8
}
8000430a:	5e fc       	retal	r12

8000430c <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000430c:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004310:	c0 58       	rjmp	8000431a <spi_write+0xe>
		if (!timeout--) {
80004312:	58 08       	cp.w	r8,0
80004314:	c0 21       	brne	80004318 <spi_write+0xc>
80004316:	5e ff       	retal	1
80004318:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000431a:	78 49       	ld.w	r9,r12[0x10]
8000431c:	e2 19 00 02 	andl	r9,0x2,COH
80004320:	cf 90       	breq	80004312 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80004322:	5c 7b       	castu.h	r11
80004324:	99 3b       	st.w	r12[0xc],r11
80004326:	5e fd       	retal	0

80004328 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80004328:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000432c:	c0 58       	rjmp	80004336 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000432e:	58 08       	cp.w	r8,0
80004330:	c0 21       	brne	80004334 <spi_read+0xc>
80004332:	5e ff       	retal	1
80004334:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004336:	78 49       	ld.w	r9,r12[0x10]
80004338:	e2 19 02 01 	andl	r9,0x201,COH
8000433c:	e0 49 02 01 	cp.w	r9,513
80004340:	cf 71       	brne	8000432e <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80004342:	78 28       	ld.w	r8,r12[0x8]
80004344:	b6 08       	st.h	r11[0x0],r8
80004346:	5e fd       	retal	0

80004348 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80004348:	eb cd 40 f8 	pushm	r3-r7,lr
8000434c:	18 95       	mov	r5,r12
8000434e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004350:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004354:	30 38       	mov	r8,3
80004356:	f0 06 18 00 	cp.b	r6,r8
8000435a:	e0 8b 00 5f 	brhi	80004418 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
8000435e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004362:	30 18       	mov	r8,1
80004364:	f0 04 18 00 	cp.b	r4,r8
80004368:	e0 8b 00 58 	brhi	80004418 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000436c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004370:	30 78       	mov	r8,7
80004372:	f0 03 18 00 	cp.b	r3,r8
80004376:	e0 88 00 51 	brls	80004418 <spi_setupChipReg+0xd0>
8000437a:	31 08       	mov	r8,16
8000437c:	f0 03 18 00 	cp.b	r3,r8
80004380:	e0 8b 00 4c 	brhi	80004418 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80004384:	14 9b       	mov	r11,r10
80004386:	6e 1c       	ld.w	r12,r7[0x4]
80004388:	f0 1f 00 27 	mcall	80004424 <spi_setupChipReg+0xdc>

	if (baudDiv < 0) {
8000438c:	c4 65       	brlt	80004418 <spi_setupChipReg+0xd0>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000438e:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80004390:	ec 09 16 01 	lsr	r9,r6,0x1
80004394:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80004398:	ec 16 00 01 	eorl	r6,0x1
8000439c:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800043a0:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800043a4:	20 83       	sub	r3,8
800043a6:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800043aa:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800043ae:	ef 39 00 09 	ld.ub	r9,r7[9]
800043b2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800043b6:	ef 39 00 0a 	ld.ub	r9,r7[10]
800043ba:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800043be:	0f 89       	ld.ub	r9,r7[0x0]
800043c0:	30 1a       	mov	r10,1
800043c2:	f4 09 18 00 	cp.b	r9,r10
800043c6:	c0 d0       	breq	800043e0 <spi_setupChipReg+0x98>
800043c8:	c0 a3       	brcs	800043dc <spi_setupChipReg+0x94>
800043ca:	30 2a       	mov	r10,2
800043cc:	f4 09 18 00 	cp.b	r9,r10
800043d0:	c0 a0       	breq	800043e4 <spi_setupChipReg+0x9c>
800043d2:	30 3a       	mov	r10,3
800043d4:	f4 09 18 00 	cp.b	r9,r10
800043d8:	c2 01       	brne	80004418 <spi_setupChipReg+0xd0>
800043da:	c0 78       	rjmp	800043e8 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800043dc:	8b c8       	st.w	r5[0x30],r8
		break;
800043de:	c0 68       	rjmp	800043ea <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800043e0:	8b d8       	st.w	r5[0x34],r8
		break;
800043e2:	c0 48       	rjmp	800043ea <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800043e4:	8b e8       	st.w	r5[0x38],r8
		break;
800043e6:	c0 28       	rjmp	800043ea <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800043e8:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800043ea:	49 08       	lddpc	r8,80004428 <spi_setupChipReg+0xe0>
800043ec:	70 08       	ld.w	r8,r8[0x0]
800043ee:	58 08       	cp.w	r8,0
800043f0:	c1 71       	brne	8000441e <spi_setupChipReg+0xd6>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800043f2:	30 3a       	mov	r10,3
800043f4:	30 0b       	mov	r11,0
800043f6:	30 1c       	mov	r12,1
800043f8:	f0 1f 00 0d 	mcall	8000442c <spi_setupChipReg+0xe4>
800043fc:	48 b8       	lddpc	r8,80004428 <spi_setupChipReg+0xe0>
800043fe:	91 0c       	st.w	r8[0x0],r12
80004400:	58 0c       	cp.w	r12,0
80004402:	c0 a0       	breq	80004416 <spi_setupChipReg+0xce>
80004404:	30 09       	mov	r9,0
80004406:	12 9a       	mov	r10,r9
80004408:	12 9b       	mov	r11,r9
8000440a:	f0 1f 00 0a 	mcall	80004430 <spi_setupChipReg+0xe8>
		if (!xSPIMutex) {
8000440e:	48 78       	lddpc	r8,80004428 <spi_setupChipReg+0xe0>
80004410:	70 08       	ld.w	r8,r8[0x0]
80004412:	58 08       	cp.w	r8,0
80004414:	c0 51       	brne	8000441e <spi_setupChipReg+0xd6>
80004416:	c0 08       	rjmp	80004416 <spi_setupChipReg+0xce>
80004418:	30 2c       	mov	r12,2
8000441a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000441e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004422:	00 00       	add	r0,r0
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	42 82       	lddsp	r2,sp[0xa0]
80004428:	00 00       	add	r0,r0
8000442a:	13 84       	ld.ub	r4,r9[0x0]
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	7a b8       	ld.w	r8,sp[0x2c]
80004430:	80 00       	ld.sh	r0,r0[0x0]
80004432:	79 24       	ld.w	r4,r12[0x48]

80004434 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004434:	d4 01       	pushm	lr
80004436:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000443a:	c0 58       	rjmp	80004444 <spi_unselectChip+0x10>
		if (!timeout--) {
8000443c:	58 08       	cp.w	r8,0
8000443e:	c0 21       	brne	80004442 <spi_unselectChip+0xe>
80004440:	da 0a       	popm	pc,r12=1
80004442:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004444:	78 49       	ld.w	r9,r12[0x10]
80004446:	e2 19 02 00 	andl	r9,0x200,COH
8000444a:	cf 90       	breq	8000443c <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000444c:	78 18       	ld.w	r8,r12[0x4]
8000444e:	ea 18 00 0f 	orh	r8,0xf
80004452:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80004454:	fc 18 01 00 	movh	r8,0x100
80004458:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000445a:	30 09       	mov	r9,0
8000445c:	12 9a       	mov	r10,r9
8000445e:	12 9b       	mov	r11,r9
80004460:	48 38       	lddpc	r8,8000446c <spi_unselectChip+0x38>
80004462:	70 0c       	ld.w	r12,r8[0x0]
80004464:	f0 1f 00 03 	mcall	80004470 <spi_unselectChip+0x3c>
80004468:	d8 0a       	popm	pc,r12=0
8000446a:	00 00       	add	r0,r0
8000446c:	00 00       	add	r0,r0
8000446e:	13 84       	ld.ub	r4,r9[0x0]
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	79 24       	ld.w	r4,r12[0x48]

80004474 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004474:	d4 21       	pushm	r4-r7,lr
80004476:	18 95       	mov	r5,r12
80004478:	16 94       	mov	r4,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
8000447a:	49 86       	lddpc	r6,800044d8 <spi_selectChip+0x64>
8000447c:	31 47       	mov	r7,20
8000447e:	0e 9b       	mov	r11,r7
80004480:	6c 0c       	ld.w	r12,r6[0x0]
80004482:	f0 1f 00 17 	mcall	800044dc <spi_selectChip+0x68>
80004486:	cf c0       	breq	8000447e <spi_selectChip+0xa>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004488:	6a 18       	ld.w	r8,r5[0x4]
8000448a:	ea 18 00 0f 	orh	r8,0xf
8000448e:	8b 18       	st.w	r5[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004490:	6a 18       	ld.w	r8,r5[0x4]
80004492:	e2 18 00 04 	andl	r8,0x4,COH
80004496:	c1 00       	breq	800044b6 <spi_selectChip+0x42>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80004498:	30 e8       	mov	r8,14
8000449a:	f0 04 18 00 	cp.b	r4,r8
8000449e:	e0 8b 00 1a 	brhi	800044d2 <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800044a2:	6a 19       	ld.w	r9,r5[0x4]
800044a4:	e8 08 15 10 	lsl	r8,r4,0x10
800044a8:	ea 18 ff f0 	orh	r8,0xfff0
800044ac:	e8 18 ff ff 	orl	r8,0xffff
800044b0:	12 68       	and	r8,r9
800044b2:	8b 18       	st.w	r5[0x4],r8
800044b4:	d8 2a       	popm	r4-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800044b6:	30 38       	mov	r8,3
800044b8:	f0 04 18 00 	cp.b	r4,r8
800044bc:	e0 8b 00 0b 	brhi	800044d2 <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800044c0:	6a 19       	ld.w	r9,r5[0x4]
800044c2:	2f 04       	sub	r4,-16
800044c4:	30 18       	mov	r8,1
800044c6:	f0 04 09 48 	lsl	r8,r8,r4
800044ca:	5c d8       	com	r8
800044cc:	12 68       	and	r8,r9
800044ce:	8b 18       	st.w	r5[0x4],r8
800044d0:	d8 2a       	popm	r4-r7,pc,r12=0
800044d2:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800044d4:	d8 22       	popm	r4-r7,pc
800044d6:	00 00       	add	r0,r0
800044d8:	00 00       	add	r0,r0
800044da:	13 84       	ld.ub	r4,r9[0x0]
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	77 40       	ld.w	r0,r11[0x50]

800044e0 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
800044e0:	4a 78       	lddpc	r8,8000457c <twi_master_interrupt_handler+0x9c>
800044e2:	70 08       	ld.w	r8,r8[0x0]
800044e4:	70 89       	ld.w	r9,r8[0x20]
800044e6:	4a 7a       	lddpc	r10,80004580 <twi_master_interrupt_handler+0xa0>
800044e8:	74 0a       	ld.w	r10,r10[0x0]
800044ea:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800044ee:	12 9a       	mov	r10,r9
800044f0:	e2 1a 01 00 	andl	r10,0x100,COH
800044f4:	c3 91       	brne	80004566 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800044f6:	12 9a       	mov	r10,r9
800044f8:	e2 1a 00 02 	andl	r10,0x2,COH
800044fc:	c1 70       	breq	8000452a <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800044fe:	4a 29       	lddpc	r9,80004584 <twi_master_interrupt_handler+0xa4>
80004500:	72 0a       	ld.w	r10,r9[0x0]
80004502:	70 cb       	ld.w	r11,r8[0x30]
80004504:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004506:	72 0a       	ld.w	r10,r9[0x0]
80004508:	2f fa       	sub	r10,-1
8000450a:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
8000450c:	49 f9       	lddpc	r9,80004588 <twi_master_interrupt_handler+0xa8>
8000450e:	72 0a       	ld.w	r10,r9[0x0]
80004510:	20 1a       	sub	r10,1
80004512:	93 0a       	st.w	r9[0x0],r10
80004514:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004516:	58 19       	cp.w	r9,1
80004518:	f9 b9 00 02 	moveq	r9,2
8000451c:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004520:	49 a9       	lddpc	r9,80004588 <twi_master_interrupt_handler+0xa8>
80004522:	72 09       	ld.w	r9,r9[0x0]
80004524:	58 09       	cp.w	r9,0
80004526:	c2 30       	breq	8000456c <twi_master_interrupt_handler+0x8c>
80004528:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
8000452a:	12 9a       	mov	r10,r9
8000452c:	e2 1a 00 04 	andl	r10,0x4,COH
80004530:	c1 70       	breq	8000455e <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004532:	49 79       	lddpc	r9,8000458c <twi_master_interrupt_handler+0xac>
80004534:	72 0a       	ld.w	r10,r9[0x0]
80004536:	20 1a       	sub	r10,1
80004538:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
8000453a:	72 09       	ld.w	r9,r9[0x0]
8000453c:	58 09       	cp.w	r9,0
8000453e:	e0 89 00 0a 	brgt	80004552 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004542:	49 09       	lddpc	r9,80004580 <twi_master_interrupt_handler+0xa0>
80004544:	30 1a       	mov	r10,1
80004546:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004548:	3f fa       	mov	r10,-1
8000454a:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
8000454c:	72 09       	ld.w	r9,r9[0x0]
8000454e:	91 99       	st.w	r8[0x24],r9
80004550:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004552:	49 0a       	lddpc	r10,80004590 <twi_master_interrupt_handler+0xb0>
80004554:	74 09       	ld.w	r9,r10[0x0]
80004556:	13 3b       	ld.ub	r11,r9++
80004558:	91 db       	st.w	r8[0x34],r11
8000455a:	95 09       	st.w	r10[0x0],r9
8000455c:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
8000455e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004562:	c0 51       	brne	8000456c <twi_master_interrupt_handler+0x8c>
80004564:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004566:	30 1a       	mov	r10,1
80004568:	48 b9       	lddpc	r9,80004594 <twi_master_interrupt_handler+0xb4>
8000456a:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
8000456c:	3f f9       	mov	r9,-1
8000456e:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004570:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004572:	30 09       	mov	r9,0
80004574:	48 98       	lddpc	r8,80004598 <twi_master_interrupt_handler+0xb8>
80004576:	b0 89       	st.b	r8[0x0],r9
80004578:	d6 03       	rete
8000457a:	00 00       	add	r0,r0
8000457c:	00 00       	add	r0,r0
8000457e:	05 88       	ld.ub	r8,r2[0x0]
80004580:	00 00       	add	r0,r0
80004582:	05 84       	ld.ub	r4,r2[0x0]
80004584:	00 00       	add	r0,r0
80004586:	05 94       	ld.ub	r4,r2[0x1]
80004588:	00 00       	add	r0,r0
8000458a:	05 90       	ld.ub	r0,r2[0x1]
8000458c:	00 00       	add	r0,r0
8000458e:	05 80       	ld.ub	r0,r2[0x0]
80004590:	00 00       	add	r0,r0
80004592:	05 8c       	ld.ub	r12,r2[0x0]
80004594:	00 00       	add	r0,r0
80004596:	05 7d       	ld.ub	sp,--r2
80004598:	00 00       	add	r0,r0
8000459a:	05 7c       	ld.ub	r12,--r2

8000459c <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
8000459c:	18 98       	mov	r8,r12
	uint32_t val;

	if (len == 0)
8000459e:	58 0b       	cp.w	r11,0
800045a0:	c0 21       	brne	800045a4 <twi_mk_addr+0x8>
800045a2:	5e fd       	retal	0
		return 0;

	val = addr[0];
800045a4:	19 8c       	ld.ub	r12,r12[0x0]
	if (len > 1) {
800045a6:	58 1b       	cp.w	r11,1
800045a8:	e0 8a 00 05 	brle	800045b2 <twi_mk_addr+0x16>
		val <<= 8;
		val |= addr[1];
800045ac:	11 99       	ld.ub	r9,r8[0x1]
800045ae:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
	}
	if (len > 2) {
800045b2:	58 2b       	cp.w	r11,2
800045b4:	5e ac       	retle	r12
		val <<= 8;
		val |= addr[2];
800045b6:	11 a8       	ld.ub	r8,r8[0x2]
800045b8:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	}
	return val;
}
800045bc:	5e fc       	retal	r12
800045be:	d7 03       	nop

800045c0 <twi_is_busy>:
}


bool twi_is_busy(void)
{
	if (twi_busy) {
800045c0:	48 28       	lddpc	r8,800045c8 <twi_is_busy+0x8>
800045c2:	11 8c       	ld.ub	r12,r8[0x0]
		return true;          // Still receiving/transmitting...
	} else {
		return false;
	}
}
800045c4:	5e fc       	retal	r12
800045c6:	00 00       	add	r0,r0
800045c8:	00 00       	add	r0,r0
800045ca:	05 7c       	ld.ub	r12,--r2

800045cc <twi_master_write>:
	return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800045cc:	eb cd 40 c0 	pushm	r6-r7,lr
800045d0:	18 96       	mov	r6,r12
800045d2:	16 97       	mov	r7,r11
	// No data to send
	if (package->length == 0) {
800045d4:	76 38       	ld.w	r8,r11[0xc]
800045d6:	58 08       	cp.w	r8,0
800045d8:	c0 51       	brne	800045e2 <twi_master_write+0x16>
800045da:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800045de:	fe cf ff fc 	sub	pc,pc,-4
	// No data to send
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800045e2:	f0 1f 00 1f 	mcall	8000465c <twi_master_write+0x90>
800045e6:	cf c1       	brne	800045de <twi_master_write+0x12>
		cpu_relax();
	};

	twi_nack = false;
800045e8:	30 09       	mov	r9,0
800045ea:	49 e8       	lddpc	r8,80004660 <twi_master_write+0x94>
800045ec:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800045ee:	30 19       	mov	r9,1
800045f0:	49 d8       	lddpc	r8,80004664 <twi_master_write+0x98>
800045f2:	b0 89       	st.b	r8[0x0],r9

	// Enable master transfer, disable slave
	twi->cr =   AVR32_TWI_CR_MSEN_MASK
800045f4:	32 48       	mov	r8,36
800045f6:	8d 08       	st.w	r6[0x0],r8
			| AVR32_TWI_CR_SVDIS_MASK
#endif
			;

	// set write mode, slave address and 3 internal address byte length
	twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800045f8:	6e 18       	ld.w	r8,r7[0x4]
800045fa:	a9 68       	lsl	r8,0x8
800045fc:	e2 18 03 00 	andl	r8,0x300,COH
80004600:	0f 89       	ld.ub	r9,r7[0x0]
80004602:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80004606:	8d 18       	st.w	r6[0x4],r8
			(package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

	// Set pointer to TWI instance for IT
	twi_inst = twi;
80004608:	49 88       	lddpc	r8,80004668 <twi_master_write+0x9c>
8000460a:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
8000460c:	6e 1b       	ld.w	r11,r7[0x4]
8000460e:	ee cc ff ff 	sub	r12,r7,-1
80004612:	f0 1f 00 17 	mcall	8000466c <twi_master_write+0xa0>
80004616:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_tx_data = package->buffer;
80004618:	6e 29       	ld.w	r9,r7[0x8]
8000461a:	49 68       	lddpc	r8,80004670 <twi_master_write+0xa4>
8000461c:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to write
	twi_tx_nb_bytes = package->length;
8000461e:	6e 3a       	ld.w	r10,r7[0xc]
80004620:	49 59       	lddpc	r9,80004674 <twi_master_write+0xa8>
80004622:	93 0a       	st.w	r9[0x0],r10

	// put the first byte in the Transmit Holding Register
	twi->thr = *twi_tx_data++;
80004624:	70 09       	ld.w	r9,r8[0x0]
80004626:	13 3a       	ld.ub	r10,r9++
80004628:	8d da       	st.w	r6[0x34],r10
8000462a:	91 09       	st.w	r8[0x0],r9

	// mask NACK and TXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
8000462c:	49 38       	lddpc	r8,80004678 <twi_master_write+0xac>
8000462e:	e0 69 01 04 	mov	r9,260
80004632:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
80004634:	70 08       	ld.w	r8,r8[0x0]
80004636:	8d 98       	st.w	r6[0x24],r8

	// send data
	while (twi_is_busy()) {
80004638:	c0 38       	rjmp	8000463e <twi_master_write+0x72>
		cpu_relax();
8000463a:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// send data
	while (twi_is_busy()) {
8000463e:	f0 1f 00 08 	mcall	8000465c <twi_master_write+0x90>
80004642:	cf c1       	brne	8000463a <twi_master_write+0x6e>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80004644:	30 88       	mov	r8,8
80004646:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
80004648:	48 68       	lddpc	r8,80004660 <twi_master_write+0x94>
8000464a:	11 8c       	ld.ub	r12,r8[0x0]
8000464c:	58 0c       	cp.w	r12,0
8000464e:	f9 bc 01 fb 	movne	r12,-5
80004652:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80004656:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000465a:	00 00       	add	r0,r0
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	45 c0       	lddsp	r0,sp[0x170]
80004660:	00 00       	add	r0,r0
80004662:	05 7d       	ld.ub	sp,--r2
80004664:	00 00       	add	r0,r0
80004666:	05 7c       	ld.ub	r12,--r2
80004668:	00 00       	add	r0,r0
8000466a:	05 88       	ld.ub	r8,r2[0x0]
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	45 9c       	lddsp	r12,sp[0x164]
80004670:	00 00       	add	r0,r0
80004672:	05 8c       	ld.ub	r12,r2[0x0]
80004674:	00 00       	add	r0,r0
80004676:	05 80       	ld.ub	r0,r2[0x0]
80004678:	00 00       	add	r0,r0
8000467a:	05 84       	ld.ub	r4,r2[0x0]

8000467c <twi_probe>:
	cpu_irq_restore(flags);
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
8000467c:	d4 01       	pushm	lr
8000467e:	20 5d       	sub	sp,20
	twi_package_t package;
	char data[1] = {0};
80004680:	30 08       	mov	r8,0
80004682:	ba 88       	st.b	sp[0x0],r8

	// data to send
	package.buffer = data;
80004684:	50 3d       	stdsp	sp[0xc],sp
	// chip address
	package.chip = chip_addr;
80004686:	ba cb       	st.b	sp[0x4],r11
	// frame length
	package.length = 1;
80004688:	30 19       	mov	r9,1
8000468a:	50 49       	stdsp	sp[0x10],r9
	// address length
	package.addr_length = 0;
8000468c:	30 09       	mov	r9,0
8000468e:	50 29       	stdsp	sp[0x8],r9
	// internal chip address
	package.addr[0] = 0;
80004690:	ba d8       	st.b	sp[0x5],r8
	// perform a master write access
	return (twi_master_write(twi, &package));
80004692:	fa cb ff fc 	sub	r11,sp,-4
80004696:	f0 1f 00 03 	mcall	800046a0 <twi_probe+0x24>
}
8000469a:	2f bd       	sub	sp,-20
8000469c:	d8 02       	popm	pc
8000469e:	00 00       	add	r0,r0
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	45 cc       	lddsp	r12,sp[0x170]

800046a4 <twi_master_read>:
	}
	return val;
}

int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800046a4:	eb cd 40 c0 	pushm	r6-r7,lr
800046a8:	18 96       	mov	r6,r12
800046aa:	16 97       	mov	r7,r11
	// check argument
	if (package->length == 0) {
800046ac:	76 38       	ld.w	r8,r11[0xc]
800046ae:	58 08       	cp.w	r8,0
800046b0:	c0 51       	brne	800046ba <twi_master_read+0x16>
800046b2:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800046b6:	fe cf ff fc 	sub	pc,pc,-4
	// check argument
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800046ba:	f0 1f 00 21 	mcall	8000473c <twi_master_read+0x98>
800046be:	cf c1       	brne	800046b6 <twi_master_read+0x12>
		cpu_relax();
	};

	twi_nack = false;
800046c0:	30 09       	mov	r9,0
800046c2:	4a 08       	lddpc	r8,80004740 <twi_master_read+0x9c>
800046c4:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800046c6:	30 19       	mov	r9,1
800046c8:	49 f8       	lddpc	r8,80004744 <twi_master_read+0xa0>
800046ca:	b0 89       	st.b	r8[0x0],r9

	// set read mode, slave address and 3 internal address byte length
	twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
800046cc:	0f 89       	ld.ub	r9,r7[0x0]
800046ce:	6e 18       	ld.w	r8,r7[0x4]
800046d0:	a9 68       	lsl	r8,0x8
800046d2:	e2 18 03 00 	andl	r8,0x300,COH
800046d6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800046da:	ad a8       	sbr	r8,0xc
800046dc:	8d 18       	st.w	r6[0x4],r8
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
			(1 << AVR32_TWI_MMR_MREAD_OFFSET);

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800046de:	49 b8       	lddpc	r8,80004748 <twi_master_read+0xa4>
800046e0:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800046e2:	6e 1b       	ld.w	r11,r7[0x4]
800046e4:	ee cc ff ff 	sub	r12,r7,-1
800046e8:	f0 1f 00 19 	mcall	8000474c <twi_master_read+0xa8>
800046ec:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_rx_data = package->buffer;
800046ee:	6e 29       	ld.w	r9,r7[0x8]
800046f0:	49 88       	lddpc	r8,80004750 <twi_master_read+0xac>
800046f2:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to read
	twi_rx_nb_bytes = package->length;
800046f4:	6e 39       	ld.w	r9,r7[0xc]
800046f6:	49 88       	lddpc	r8,80004754 <twi_master_read+0xb0>
800046f8:	91 09       	st.w	r8[0x0],r9

	// Enable master transfer
	twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800046fa:	30 49       	mov	r9,4
800046fc:	8d 09       	st.w	r6[0x0],r9

	// Send start condition
	twi->cr = AVR32_TWI_START_MASK;
800046fe:	30 19       	mov	r9,1
80004700:	8d 09       	st.w	r6[0x0],r9

	// only one byte to receive
	if (twi_rx_nb_bytes == 1) {
80004702:	70 08       	ld.w	r8,r8[0x0]
		// set stop bit
		twi->cr = AVR32_TWI_STOP_MASK;
80004704:	12 38       	cp.w	r8,r9
80004706:	f9 b8 00 02 	moveq	r8,2
8000470a:	ed f8 0a 00 	st.weq	r6[0x0],r8
	}

	// mask NACK and RXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
8000470e:	49 38       	lddpc	r8,80004758 <twi_master_read+0xb4>
80004710:	e0 69 01 02 	mov	r9,258
80004714:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
80004716:	70 08       	ld.w	r8,r8[0x0]
80004718:	8d 98       	st.w	r6[0x24],r8

	// get data
	while (twi_is_busy()) {
8000471a:	c0 38       	rjmp	80004720 <twi_master_read+0x7c>
		cpu_relax();
8000471c:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// get data
	while (twi_is_busy()) {
80004720:	f0 1f 00 07 	mcall	8000473c <twi_master_read+0x98>
80004724:	cf c1       	brne	8000471c <twi_master_read+0x78>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80004726:	30 88       	mov	r8,8
80004728:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
8000472a:	48 68       	lddpc	r8,80004740 <twi_master_read+0x9c>
8000472c:	11 8c       	ld.ub	r12,r8[0x0]
8000472e:	58 0c       	cp.w	r12,0
80004730:	f9 bc 01 fb 	movne	r12,-5
80004734:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80004738:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	45 c0       	lddsp	r0,sp[0x170]
80004740:	00 00       	add	r0,r0
80004742:	05 7d       	ld.ub	sp,--r2
80004744:	00 00       	add	r0,r0
80004746:	05 7c       	ld.ub	r12,--r2
80004748:	00 00       	add	r0,r0
8000474a:	05 88       	ld.ub	r8,r2[0x0]
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	45 9c       	lddsp	r12,sp[0x164]
80004750:	00 00       	add	r0,r0
80004752:	05 94       	ld.ub	r4,r2[0x1]
80004754:	00 00       	add	r0,r0
80004756:	05 90       	ld.ub	r0,r2[0x1]
80004758:	00 00       	add	r0,r0
8000475a:	05 84       	ld.ub	r4,r2[0x0]

8000475c <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
8000475c:	eb cd 40 e0 	pushm	r5-r7,lr
80004760:	20 1d       	sub	sp,4
80004762:	18 97       	mov	r7,r12
80004764:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004766:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
8000476a:	4a 29       	lddpc	r9,800047f0 <twi_master_init+0x94>
8000476c:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
8000476e:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004770:	3f f9       	mov	r9,-1
80004772:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004774:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004776:	e0 69 00 80 	mov	r9,128
8000477a:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000477c:	e6 18 00 01 	andh	r8,0x1,COH
80004780:	c0 21       	brne	80004784 <twi_master_init+0x28>
      cpu_irq_enable();
80004782:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004784:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004786:	e1 b8 00 00 	mfsr	r8,0x0
8000478a:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
8000478c:	d3 03       	ssrf	0x10

	return flags;
8000478e:	40 06       	lddsp	r6,sp[0x0]

	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();
	INTC_init_interrupts(); /**/
80004790:	f0 1f 00 19 	mcall	800047f4 <twi_master_init+0x98>
	INTC_register_interrupt(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL); /**/
80004794:	30 3a       	mov	r10,3
80004796:	e0 6b 01 60 	mov	r11,352
8000479a:	49 8c       	lddpc	r12,800047f8 <twi_master_init+0x9c>
8000479c:	f0 1f 00 18 	mcall	800047fc <twi_master_init+0xa0>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800047a0:	e6 16 00 01 	andh	r6,0x1,COH
800047a4:	c0 21       	brne	800047a8 <twi_master_init+0x4c>
      cpu_irq_enable();
800047a6:	d5 03       	csrf	0x10
	//irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE,
	//CONF_TWI_IRQ_LEVEL);
	cpu_irq_restore(flags);
	cpu_irq_enable(); /**/
800047a8:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
800047aa:	6a 19       	ld.w	r9,r5[0x4]
800047ac:	a1 79       	lsl	r9,0x1
800047ae:	6a 08       	ld.w	r8,r5[0x0]
800047b0:	f0 09 0d 08 	divu	r8,r8,r9
800047b4:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800047b6:	e0 48 00 ff 	cp.w	r8,255
800047ba:	e0 8b 00 04 	brhi	800047c2 <twi_master_init+0x66>
800047be:	30 09       	mov	r9,0
800047c0:	c0 f8       	rjmp	800047de <twi_master_init+0x82>
800047c2:	30 09       	mov	r9,0
800047c4:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
800047c6:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
800047c8:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800047ca:	e0 48 00 ff 	cp.w	r8,255
800047ce:	5f bb       	srhi	r11
800047d0:	58 69       	cp.w	r9,6
800047d2:	5f 8a       	srls	r10
800047d4:	f7 ea 00 0a 	and	r10,r11,r10
800047d8:	f8 0a 18 00 	cp.b	r10,r12
800047dc:	cf 51       	brne	800047c6 <twi_master_init+0x6a>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800047de:	b1 69       	lsl	r9,0x10
800047e0:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800047e4:	f3 e8 10 08 	or	r8,r9,r8
800047e8:	8f 48       	st.w	r7[0x10],r8

	// Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800047ea:	2f fd       	sub	sp,-4
800047ec:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800047f0:	00 00       	add	r0,r0
800047f2:	05 88       	ld.ub	r8,r2[0x0]
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	9f 28       	st.w	pc[0x8],r8
800047f8:	80 00       	ld.sh	r0,r0[0x0]
800047fa:	44 e0       	lddsp	r0,sp[0x138]
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	9e a8       	ld.uh	r8,pc[0x4]

80004800 <fat_check_open>:
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
80004800:	48 68       	lddpc	r8,80004818 <fat_check_open+0x18>
80004802:	11 89       	ld.ub	r9,r8[0x0]
80004804:	30 08       	mov	r8,0
80004806:	f0 09 18 00 	cp.b	r9,r8
8000480a:	c0 20       	breq	8000480e <fat_check_open+0xe>
8000480c:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
8000480e:	31 79       	mov	r9,23
80004810:	48 38       	lddpc	r8,8000481c <fat_check_open+0x1c>
80004812:	b0 89       	st.b	r8[0x0],r9
80004814:	5e fd       	retal	0
80004816:	00 00       	add	r0,r0
80004818:	00 00       	add	r0,r0
8000481a:	13 8c       	ld.ub	r12,r9[0x0]
8000481c:	00 00       	add	r0,r0
8000481e:	16 1c       	sub	r12,r11

80004820 <fat_check_select>:
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
80004820:	48 68       	lddpc	r8,80004838 <fat_check_select+0x18>
80004822:	90 19       	ld.sh	r9,r8[0x2]
80004824:	3f f8       	mov	r8,-1
80004826:	f0 09 19 00 	cp.h	r9,r8
8000482a:	c0 20       	breq	8000482e <fat_check_select+0xe>
8000482c:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
8000482e:	30 f9       	mov	r9,15
80004830:	48 38       	lddpc	r8,8000483c <fat_check_select+0x1c>
80004832:	b0 89       	st.b	r8[0x0],r9
80004834:	5e fd       	retal	0
80004836:	00 00       	add	r0,r0
80004838:	00 00       	add	r0,r0
8000483a:	16 18       	sub	r8,r11
8000483c:	00 00       	add	r0,r0
8000483e:	16 1c       	sub	r12,r11

80004840 <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
80004840:	48 58       	lddpc	r8,80004854 <fat_check_is_file+0x14>
80004842:	11 a8       	ld.ub	r8,r8[0x2]
80004844:	e2 18 00 18 	andl	r8,0x18,COH
80004848:	c0 21       	brne	8000484c <fat_check_is_file+0xc>
8000484a:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
8000484c:	31 39       	mov	r9,19
8000484e:	48 38       	lddpc	r8,80004858 <fat_check_is_file+0x18>
80004850:	b0 89       	st.b	r8[0x0],r9
80004852:	5e fd       	retal	0
80004854:	00 00       	add	r0,r0
80004856:	13 8c       	ld.ub	r12,r9[0x0]
80004858:	00 00       	add	r0,r0
8000485a:	16 1c       	sub	r12,r11

8000485c <fat_checkcluster>:
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
8000485c:	49 68       	lddpc	r8,800048b4 <fat_checkcluster+0x58>
8000485e:	70 18       	ld.w	r8,r8[0x4]
80004860:	58 08       	cp.w	r8,0
80004862:	c0 21       	brne	80004866 <fat_checkcluster+0xa>
80004864:	5e ff       	retal	1
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
80004866:	49 59       	lddpc	r9,800048b8 <fat_checkcluster+0x5c>
80004868:	13 89       	ld.ub	r9,r9[0x0]
8000486a:	30 3a       	mov	r10,3
8000486c:	f4 09 18 00 	cp.b	r9,r10
80004870:	c0 a1       	brne	80004884 <fat_checkcluster+0x28>
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
80004872:	e0 69 ff f7 	mov	r9,65527
80004876:	ea 19 0f ff 	orh	r9,0xfff
8000487a:	12 38       	cp.w	r8,r9
8000487c:	e0 8b 00 19 	brhi	800048ae <fat_checkcluster+0x52>
80004880:	5f 0c       	sreq	r12
80004882:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
80004884:	30 2a       	mov	r10,2
80004886:	f4 09 18 00 	cp.b	r9,r10
8000488a:	c0 71       	brne	80004898 <fat_checkcluster+0x3c>
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
8000488c:	e0 48 ff f7 	cp.w	r8,65527
80004890:	e0 8b 00 0f 	brhi	800048ae <fat_checkcluster+0x52>
80004894:	5f 0c       	sreq	r12
80004896:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
80004898:	30 1a       	mov	r10,1
8000489a:	f4 09 18 00 	cp.b	r9,r10
8000489e:	c0 20       	breq	800048a2 <fat_checkcluster+0x46>
800048a0:	5e fd       	retal	0
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
800048a2:	e0 48 0f f7 	cp.w	r8,4087
800048a6:	e0 8b 00 04 	brhi	800048ae <fat_checkcluster+0x52>
800048aa:	5f 0c       	sreq	r12
800048ac:	5e fc       	retal	r12
800048ae:	30 2c       	mov	r12,2
    else if (fs_g_cluster.u32_val == 0xFF7)
      return FS_CLUS_BAD;
  }

  return FS_CLUS_OK;
}
800048b0:	5e fc       	retal	r12
800048b2:	00 00       	add	r0,r0
800048b4:	00 00       	add	r0,r0
800048b6:	16 6c       	and	r12,r11
800048b8:	00 00       	add	r0,r0
800048ba:	16 18       	sub	r8,r11

800048bc <fat_cache_clusterlist_reset>:
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
800048bc:	30 0a       	mov	r10,0
800048be:	48 88       	lddpc	r8,800048dc <fat_cache_clusterlist_reset+0x20>
800048c0:	b0 8a       	st.b	r8[0x0],r10
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
800048c2:	48 88       	lddpc	r8,800048e0 <fat_cache_clusterlist_reset+0x24>
800048c4:	30 19       	mov	r9,1
800048c6:	b0 89       	st.b	r8[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
800048c8:	3f f9       	mov	r9,-1
800048ca:	b0 a9       	st.b	r8[0x2],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
800048cc:	b0 99       	st.b	r8[0x1],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
800048ce:	f1 6a 00 14 	st.b	r8[20],r10
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
800048d2:	f1 69 00 16 	st.b	r8[22],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
800048d6:	f1 69 00 15 	st.b	r8[21],r9
   }
}
800048da:	5e fc       	retal	r12
800048dc:	00 00       	add	r0,r0
800048de:	16 1e       	sub	lr,r11
800048e0:	00 00       	add	r0,r0
800048e2:	13 a0       	ld.ub	r0,r9[0x2]

800048e4 <fat_cache_clusterlist_update_start>:
//! This function initializes a cache in cluster list caches
//!
//! @param     b_for_file  If true then it is a file cluster list else a directory cluster list  <br>
//!
void  fat_cache_clusterlist_update_start( bool b_for_file )
{
800048e4:	48 ea       	lddpc	r10,8000491c <fat_cache_clusterlist_update_start+0x38>
800048e6:	15 88       	ld.ub	r8,r10[0x0]
800048e8:	f8 08 18 00 	cp.b	r8,r12
800048ec:	5f 18       	srne	r8
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
800048ee:	48 d9       	lddpc	r9,80004920 <fat_cache_clusterlist_update_start+0x3c>
800048f0:	b2 88       	st.b	r9[0x0],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
800048f2:	f0 0b 15 02 	lsl	r11,r8,0x2
800048f6:	f6 08 00 09 	add	r9,r11,r8
800048fa:	f4 09 00 29 	add	r9,r10,r9<<0x2
800048fe:	b2 8c       	st.b	r9[0x0],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80004900:	3f fc       	mov	r12,-1
80004902:	b2 ac       	st.b	r9[0x2],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
80004904:	f6 08 00 08 	add	r8,r11,r8
80004908:	2f f8       	sub	r8,-1
8000490a:	48 7b       	lddpc	r11,80004924 <fat_cache_clusterlist_update_start+0x40>
8000490c:	76 0b       	ld.w	r11,r11[0x0]
8000490e:	f4 08 09 2b 	st.w	r10[r8<<0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
80004912:	48 68       	lddpc	r8,80004928 <fat_cache_clusterlist_update_start+0x44>
80004914:	70 18       	ld.w	r8,r8[0x4]
80004916:	93 28       	st.w	r9[0x8],r8
}
80004918:	5e fc       	retal	r12
8000491a:	00 00       	add	r0,r0
8000491c:	00 00       	add	r0,r0
8000491e:	13 a0       	ld.ub	r0,r9[0x2]
80004920:	00 00       	add	r0,r0
80004922:	16 1e       	sub	lr,r11
80004924:	00 00       	add	r0,r0
80004926:	16 6c       	and	r12,r11
80004928:	00 00       	add	r0,r0
8000492a:	16 74       	tst	r4,r11

8000492c <fat_cache_clusterlist_update_select>:
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
8000492c:	49 88       	lddpc	r8,8000498c <fat_cache_clusterlist_update_select+0x60>
8000492e:	11 88       	ld.ub	r8,r8[0x0]
80004930:	49 8a       	lddpc	r10,80004990 <fat_cache_clusterlist_update_select+0x64>
80004932:	f0 08 00 2b 	add	r11,r8,r8<<0x2
80004936:	f4 0b 00 2b 	add	r11,r10,r11<<0x2
8000493a:	17 89       	ld.ub	r9,r11[0x0]
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
8000493c:	17 9b       	ld.ub	r11,r11[0x1]
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
8000493e:	15 8a       	ld.ub	r10,r10[0x0]
80004940:	f2 0a 18 00 	cp.b	r10,r9
80004944:	c0 a1       	brne	80004958 <fat_cache_clusterlist_update_select+0x2c>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80004946:	49 3a       	lddpc	r10,80004990 <fat_cache_clusterlist_update_select+0x64>
80004948:	15 9a       	ld.ub	r10,r10[0x1]
8000494a:	f4 0b 18 00 	cp.b	r11,r10
8000494e:	e0 88 00 05 	brls	80004958 <fat_cache_clusterlist_update_select+0x2c>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80004952:	2f fa       	sub	r10,-1
80004954:	48 fc       	lddpc	r12,80004990 <fat_cache_clusterlist_update_select+0x64>
80004956:	b8 9a       	st.b	r12[0x1],r10

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
80004958:	48 ea       	lddpc	r10,80004990 <fat_cache_clusterlist_update_select+0x64>
8000495a:	f5 3a 00 14 	ld.ub	r10,r10[20]
8000495e:	f2 0a 18 00 	cp.b	r10,r9
80004962:	c0 c1       	brne	8000497a <fat_cache_clusterlist_update_select+0x4e>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80004964:	48 b9       	lddpc	r9,80004990 <fat_cache_clusterlist_update_select+0x64>
80004966:	f3 39 00 15 	ld.ub	r9,r9[21]
8000496a:	f2 0b 18 00 	cp.b	r11,r9
8000496e:	e0 88 00 06 	brls	8000497a <fat_cache_clusterlist_update_select+0x4e>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80004972:	2f f9       	sub	r9,-1
80004974:	48 7a       	lddpc	r10,80004990 <fat_cache_clusterlist_update_select+0x64>
80004976:	f5 69 00 15 	st.b	r10[21],r9
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
8000497a:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000497e:	48 59       	lddpc	r9,80004990 <fat_cache_clusterlist_update_select+0x64>
80004980:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004984:	30 09       	mov	r9,0
80004986:	b0 99       	st.b	r8[0x1],r9
}
80004988:	5e fc       	retal	r12
8000498a:	00 00       	add	r0,r0
8000498c:	00 00       	add	r0,r0
8000498e:	16 1e       	sub	lr,r11
80004990:	00 00       	add	r0,r0
80004992:	13 a0       	ld.ub	r0,r9[0x2]

80004994 <fat_cache_clusterlist_update_finish>:


//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
80004994:	eb cd 40 c0 	pushm	r6-r7,lr
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
80004998:	49 08       	lddpc	r8,800049d8 <fat_cache_clusterlist_update_finish+0x44>
8000499a:	11 88       	ld.ub	r8,r8[0x0]
8000499c:	f0 08 00 28 	add	r8,r8,r8<<0x2
800049a0:	48 f9       	lddpc	r9,800049dc <fat_cache_clusterlist_update_finish+0x48>
800049a2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800049a6:	f0 ca ff f8 	sub	r10,r8,-8
800049aa:	48 eb       	lddpc	r11,800049e0 <fat_cache_clusterlist_update_finish+0x4c>
800049ac:	17 97       	ld.ub	r7,r11[0x1]
800049ae:	74 09       	ld.w	r9,r10[0x0]
800049b0:	f2 07 0d 06 	divu	r6,r9,r7
800049b4:	0e 99       	mov	r9,r7
800049b6:	5c 59       	castu.b	r9
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
800049b8:	17 8b       	ld.ub	r11,r11[0x0]
800049ba:	b0 ab       	st.b	r8[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
800049bc:	74 0b       	ld.w	r11,r10[0x0]
800049be:	12 1b       	sub	r11,r9
800049c0:	95 0b       	st.w	r10[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
800049c2:	48 9a       	lddpc	r10,800049e4 <fat_cache_clusterlist_update_finish+0x50>
800049c4:	74 0b       	ld.w	r11,r10[0x0]
800049c6:	12 1b       	sub	r11,r9
800049c8:	91 3b       	st.w	r8[0xc],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
800049ca:	74 1a       	ld.w	r10,r10[0x4]
800049cc:	14 09       	add	r9,r10
800049ce:	91 49       	st.w	r8[0x10],r9

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
800049d0:	f0 1f 00 06 	mcall	800049e8 <fat_cache_clusterlist_update_finish+0x54>
}
800049d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049d8:	00 00       	add	r0,r0
800049da:	16 1e       	sub	lr,r11
800049dc:	00 00       	add	r0,r0
800049de:	13 a0       	ld.ub	r0,r9[0x2]
800049e0:	00 00       	add	r0,r0
800049e2:	15 cc       	ld.ub	r12,r10[0x4]
800049e4:	00 00       	add	r0,r0
800049e6:	16 74       	tst	r4,r11
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	49 2c       	lddpc	r12,80004a30 <fat_cache_clusterlist_update_read+0x44>

800049ec <fat_cache_clusterlist_update_read>:
//!
//! @return    true  cluster list found and global variable fs_g_seg updated
//! @return    false no found in cluster list caches
//!
bool  fat_cache_clusterlist_update_read( bool b_for_file )
{
800049ec:	eb cd 40 c0 	pushm	r6-r7,lr
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
800049f0:	4c 18       	lddpc	r8,80004af4 <fat_cache_clusterlist_update_read+0x108>
800049f2:	11 89       	ld.ub	r9,r8[0x0]
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
800049f4:	4c 18       	lddpc	r8,80004af8 <fat_cache_clusterlist_update_read+0x10c>
800049f6:	70 0a       	ld.w	r10,r8[0x0]
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
800049f8:	4c 18       	lddpc	r8,80004afc <fat_cache_clusterlist_update_read+0x110>
800049fa:	70 1b       	ld.w	r11,r8[0x4]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
800049fc:	4c 18       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
800049fe:	11 88       	ld.ub	r8,r8[0x0]
80004a00:	f8 08 18 00 	cp.b	r8,r12
80004a04:	c1 11       	brne	80004a26 <fat_cache_clusterlist_update_read+0x3a>
80004a06:	4b f8       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a08:	11 a8       	ld.ub	r8,r8[0x2]
80004a0a:	f2 08 18 00 	cp.b	r8,r9
80004a0e:	c0 c1       	brne	80004a26 <fat_cache_clusterlist_update_read+0x3a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80004a10:	4b c8       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a12:	70 18       	ld.w	r8,r8[0x4]
80004a14:	14 38       	cp.w	r8,r10
80004a16:	c0 81       	brne	80004a26 <fat_cache_clusterlist_update_read+0x3a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80004a18:	4b a8       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a1a:	70 28       	ld.w	r8,r8[0x8]
80004a1c:	10 3b       	cp.w	r11,r8
80004a1e:	c0 43       	brcs	80004a26 <fat_cache_clusterlist_update_read+0x3a>
80004a20:	30 0a       	mov	r10,0
80004a22:	14 99       	mov	r9,r10
80004a24:	c1 88       	rjmp	80004a54 <fat_cache_clusterlist_update_read+0x68>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80004a26:	4b 78       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a28:	f1 38 00 14 	ld.ub	r8,r8[20]
80004a2c:	f8 08 18 00 	cp.b	r8,r12
80004a30:	c5 e1       	brne	80004aec <fat_cache_clusterlist_update_read+0x100>
80004a32:	4b 48       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a34:	f1 38 00 16 	ld.ub	r8,r8[22]
80004a38:	f2 08 18 00 	cp.b	r8,r9
80004a3c:	c5 81       	brne	80004aec <fat_cache_clusterlist_update_read+0x100>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80004a3e:	4b 18       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a40:	70 68       	ld.w	r8,r8[0x18]
80004a42:	14 38       	cp.w	r8,r10
80004a44:	c5 41       	brne	80004aec <fat_cache_clusterlist_update_read+0x100>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80004a46:	4a f8       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a48:	70 78       	ld.w	r8,r8[0x1c]
80004a4a:	16 38       	cp.w	r8,r11
80004a4c:	e0 8b 00 50 	brhi	80004aec <fat_cache_clusterlist_update_read+0x100>
80004a50:	30 1a       	mov	r10,1
80004a52:	14 99       	mov	r9,r10
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
80004a54:	f2 0e 15 02 	lsl	lr,r9,0x2
80004a58:	12 0e       	add	lr,r9
80004a5a:	4a ac       	lddpc	r12,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a5c:	f8 0e 00 2c 	add	r12,r12,lr<<0x2
80004a60:	78 4c       	ld.w	r12,r12[0x10]
80004a62:	f6 08 01 08 	sub	r8,r11,r8
80004a66:	10 3c       	cp.w	r12,r8
80004a68:	e0 88 00 16 	brls	80004a94 <fat_cache_clusterlist_update_read+0xa8>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
80004a6c:	4a 4b       	lddpc	r11,80004afc <fat_cache_clusterlist_update_read+0x110>
80004a6e:	f2 0e 15 02 	lsl	lr,r9,0x2
80004a72:	fc 09 00 09 	add	r9,lr,r9
80004a76:	4a 3e       	lddpc	lr,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004a78:	fc 09 00 29 	add	r9,lr,r9<<0x2
80004a7c:	72 39       	ld.w	r9,r9[0xc]
80004a7e:	f0 09 00 09 	add	r9,r8,r9
80004a82:	97 09       	st.w	r11[0x0],r9
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
80004a84:	10 1c       	sub	r12,r8
80004a86:	97 1c       	st.w	r11[0x4],r12
                  fs_g_u8_current_cache = u8_i;
80004a88:	49 f8       	lddpc	r8,80004b04 <fat_cache_clusterlist_update_read+0x118>
80004a8a:	b0 8a       	st.b	r8[0x0],r10
                  fat_cache_clusterlist_update_select();
80004a8c:	f0 1f 00 1f 	mcall	80004b08 <fat_cache_clusterlist_update_read+0x11c>
80004a90:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
80004a94:	49 c8       	lddpc	r8,80004b04 <fat_cache_clusterlist_update_read+0x118>
80004a96:	b0 8a       	st.b	r8[0x0],r10
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
80004a98:	f2 08 15 02 	lsl	r8,r9,0x2
80004a9c:	f0 09 00 09 	add	r9,r8,r9
80004aa0:	49 88       	lddpc	r8,80004b00 <fat_cache_clusterlist_update_read+0x114>
80004aa2:	f0 09 00 28 	add	r8,r8,r9<<0x2
80004aa6:	3f f9       	mov	r9,-1
80004aa8:	b0 a9       	st.b	r8[0x2],r9
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
80004aaa:	70 4c       	ld.w	r12,r8[0x10]
80004aac:	49 2a       	lddpc	r10,80004af4 <fat_cache_clusterlist_update_read+0x108>
80004aae:	15 99       	ld.ub	r9,r10[0x1]
80004ab0:	70 3e       	ld.w	lr,r8[0xc]
80004ab2:	f8 0e 00 0e 	add	lr,r12,lr
80004ab6:	20 1e       	sub	lr,1
80004ab8:	74 57       	ld.w	r7,r10[0x14]
80004aba:	fc 07 01 07 	sub	r7,lr,r7
80004abe:	74 4a       	ld.w	r10,r10[0x10]
80004ac0:	14 17       	sub	r7,r10
80004ac2:	ee 09 0d 06 	divu	r6,r7,r9
80004ac6:	0c 97       	mov	r7,r6
80004ac8:	2f e7       	sub	r7,-2
80004aca:	48 ca       	lddpc	r10,80004af8 <fat_cache_clusterlist_update_read+0x10c>
80004acc:	95 07       	st.w	r10[0x0],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
80004ace:	2f 88       	sub	r8,-8
80004ad0:	70 0a       	ld.w	r10,r8[0x0]
80004ad2:	14 0c       	add	r12,r10
80004ad4:	f8 c7 00 01 	sub	r7,r12,1
80004ad8:	ee 09 0d 06 	divu	r6,r7,r9
80004adc:	ad 39       	mul	r9,r6
80004ade:	48 8a       	lddpc	r10,80004afc <fat_cache_clusterlist_update_read+0x110>
80004ae0:	f6 09 01 09 	sub	r9,r11,r9
80004ae4:	95 19       	st.w	r10[0x4],r9
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
80004ae6:	91 0b       	st.w	r8[0x0],r11
80004ae8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
         }
      }
   }
   // No found in cache then read FAT and store the result in cache
   fat_cache_clusterlist_update_start(b_for_file);
80004aec:	f0 1f 00 08 	mcall	80004b0c <fat_cache_clusterlist_update_read+0x120>
80004af0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80004af4:	00 00       	add	r0,r0
80004af6:	15 cc       	ld.ub	r12,r10[0x4]
80004af8:	00 00       	add	r0,r0
80004afa:	16 6c       	and	r12,r11
80004afc:	00 00       	add	r0,r0
80004afe:	16 74       	tst	r4,r11
80004b00:	00 00       	add	r0,r0
80004b02:	13 a0       	ld.ub	r0,r9[0x2]
80004b04:	00 00       	add	r0,r0
80004b06:	16 1e       	sub	lr,r11
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	49 2c       	lddpc	r12,80004b50 <fat_clear_entry_info_and_ptr+0x28>
80004b0c:	80 00       	ld.sh	r0,r0[0x0]
80004b0e:	48 e4       	lddpc	r4,80004b44 <fat_clear_entry_info_and_ptr+0x1c>

80004b10 <fat_entry_is_dir>:
//! @return    true,    this entry is a directory
//! @return    false,   otherwise
//!
bool  fat_entry_is_dir(void)
{
   fs_g_status = FS_ERR_NO_DIR;
80004b10:	30 d9       	mov	r9,13
80004b12:	48 48       	lddpc	r8,80004b20 <fat_entry_is_dir+0x10>
80004b14:	b0 89       	st.b	r8[0x0],r9
80004b16:	48 48       	lddpc	r8,80004b24 <fat_entry_is_dir+0x14>
80004b18:	11 ac       	ld.ub	r12,r8[0x2]
   return (FS_ATTR_DIRECTORY & fs_g_nav_entry.u8_attr);
}
80004b1a:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80004b1e:	5e fc       	retal	r12
80004b20:	00 00       	add	r0,r0
80004b22:	16 1c       	sub	r12,r11
80004b24:	00 00       	add	r0,r0
80004b26:	13 8c       	ld.ub	r12,r9[0x0]

80004b28 <fat_clear_entry_info_and_ptr>:

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
80004b28:	3f f9       	mov	r9,-1
80004b2a:	48 c8       	lddpc	r8,80004b58 <fat_clear_entry_info_and_ptr+0x30>
80004b2c:	b0 19       	st.h	r8[0x2],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
80004b2e:	48 c8       	lddpc	r8,80004b5c <fat_clear_entry_info_and_ptr+0x34>
80004b30:	f1 59 00 24 	st.h	r8[36],r9
   if( !fs_g_nav.b_mode_nav_single )
80004b34:	f1 39 00 2d 	ld.ub	r9,r8[45]
80004b38:	30 08       	mov	r8,0
80004b3a:	f0 09 18 00 	cp.b	r9,r8
80004b3e:	c0 51       	brne	80004b48 <fat_clear_entry_info_and_ptr+0x20>
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
80004b40:	10 99       	mov	r9,r8
80004b42:	48 78       	lddpc	r8,80004b5c <fat_clear_entry_info_and_ptr+0x34>
80004b44:	f1 69 00 2c 	st.b	r8[44],r9
   }
   fs_g_nav_entry.u8_attr     = 0;
80004b48:	48 68       	lddpc	r8,80004b60 <fat_clear_entry_info_and_ptr+0x38>
80004b4a:	30 09       	mov	r9,0
80004b4c:	b0 a9       	st.b	r8[0x2],r9
   fs_g_nav_entry.u32_cluster = 0;
80004b4e:	30 0a       	mov	r10,0
80004b50:	91 1a       	st.w	r8[0x4],r10
   fs_g_nav_entry.u32_size    = 0;
80004b52:	91 2a       	st.w	r8[0x8],r10
   Fat_file_close();
80004b54:	b0 89       	st.b	r8[0x0],r9
}
80004b56:	5e fc       	retal	r12
80004b58:	00 00       	add	r0,r0
80004b5a:	16 18       	sub	r8,r11
80004b5c:	00 00       	add	r0,r0
80004b5e:	15 cc       	ld.ub	r12,r10[0x4]
80004b60:	00 00       	add	r0,r0
80004b62:	13 8c       	ld.ub	r12,r9[0x0]

80004b64 <fat_check_eof_name>:
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
80004b64:	30 08       	mov	r8,0
80004b66:	f0 0c 19 00 	cp.h	r12,r8
80004b6a:	5f 0a       	sreq	r10
80004b6c:	35 c9       	mov	r9,92
80004b6e:	f2 0c 19 00 	cp.h	r12,r9
80004b72:	5f 09       	sreq	r9
80004b74:	f5 e9 10 09 	or	r9,r10,r9
80004b78:	f0 09 18 00 	cp.b	r9,r8
80004b7c:	c0 20       	breq	80004b80 <fat_check_eof_name+0x1c>
80004b7e:	5e ff       	retal	1
80004b80:	32 f8       	mov	r8,47
80004b82:	f0 0c 19 00 	cp.h	r12,r8
80004b86:	5f 0c       	sreq	r12
}
80004b88:	5e fc       	retal	r12
80004b8a:	d7 03       	nop

80004b8c <fat_get_ptr_entry>:
//! This function returns a cache pointer on the current entry
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
80004b8c:	48 48       	lddpc	r8,80004b9c <fat_get_ptr_entry+0x10>
80004b8e:	90 98       	ld.uh	r8,r8[0x2]
80004b90:	a5 78       	lsl	r8,0x5
80004b92:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
}
80004b96:	48 3c       	lddpc	r12,80004ba0 <fat_get_ptr_entry+0x14>
80004b98:	10 0c       	add	r12,r8
80004b9a:	5e fc       	retal	r12
80004b9c:	00 00       	add	r0,r0
80004b9e:	16 18       	sub	r8,r11
80004ba0:	00 00       	add	r0,r0
80004ba2:	13 cc       	ld.ub	r12,r9[0x4]

80004ba4 <fat_entry_longname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_longname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case )
{
80004ba4:	d4 31       	pushm	r0-r7,lr
80004ba6:	20 3d       	sub	sp,12
80004ba8:	18 97       	mov	r7,r12
80004baa:	16 94       	mov	r4,r11
80004bac:	14 96       	mov	r6,r10
80004bae:	50 09       	stdsp	sp[0x0],r9
   uint8_t u8_pos_name;
   PTR_CACHE ptr_entry;
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();
80004bb0:	f0 1f 00 5e 	mcall	80004d28 <fat_entry_longname+0x184>

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
80004bb4:	19 88       	ld.ub	r8,r12[0x0]
80004bb6:	30 09       	mov	r9,0
80004bb8:	f2 08 18 00 	cp.b	r8,r9
80004bbc:	5f 0b       	sreq	r11
80004bbe:	3e 5a       	mov	r10,-27
80004bc0:	f4 08 18 00 	cp.b	r8,r10
80004bc4:	5f 0a       	sreq	r10
80004bc6:	f7 ea 10 0a 	or	r10,r11,r10
80004bca:	f2 0a 18 00 	cp.b	r10,r9
80004bce:	c0 71       	brne	80004bdc <fat_entry_longname+0x38>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
80004bd0:	f9 3a 00 0b 	ld.ub	r10,r12[11]
80004bd4:	30 f9       	mov	r9,15
80004bd6:	f2 0a 18 00 	cp.b	r10,r9
80004bda:	c0 60       	breq	80004be6 <fat_entry_longname+0x42>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
80004bdc:	30 b9       	mov	r9,11
80004bde:	4d 48       	lddpc	r8,80004d2c <fat_entry_longname+0x188>
80004be0:	b0 89       	st.b	r8[0x0],r9
80004be2:	30 0c       	mov	r12,0
      return false;
80004be4:	c9 c8       	rjmp	80004d1c <fat_entry_longname+0x178>
   }

   if( g_b_string_length )
80004be6:	4d 39       	lddpc	r9,80004d30 <fat_entry_longname+0x18c>
80004be8:	13 8a       	ld.ub	r10,r9[0x0]
80004bea:	30 09       	mov	r9,0
80004bec:	f2 0a 18 00 	cp.b	r10,r9
80004bf0:	c0 90       	breq	80004c02 <fat_entry_longname+0x5e>
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
80004bf2:	e2 18 00 40 	andl	r8,0x40,COH
80004bf6:	c0 61       	brne	80004c02 <fat_entry_longname+0x5e>
      {
         // no necessary -> ((FS_STR_UNICODE)sz_name)[0] = FS_SIZE_LFN_ENTRY;
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
80004bf8:	31 09       	mov	r9,16
80004bfa:	4c d8       	lddpc	r8,80004d2c <fat_entry_longname+0x188>
80004bfc:	b0 89       	st.b	r8[0x0],r9
80004bfe:	30 0c       	mov	r12,0
         return false;                          // Other entry long name
80004c00:	c8 e8       	rjmp	80004d1c <fat_entry_longname+0x178>
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
80004c02:	2f fc       	sub	r12,-1
80004c04:	30 08       	mov	r8,0

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80004c06:	fa ca ff f6 	sub	r10,sp,-10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80004c0a:	30 0b       	mov	r11,0
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
80004c0c:	4c 95       	lddpc	r5,80004d30 <fat_entry_longname+0x18c>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80004c0e:	20 14       	sub	r4,1
80004c10:	50 14       	stdsp	sp[0x4],r4
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
80004c12:	30 01       	mov	r1,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80004c14:	30 44       	mov	r4,4
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80004c16:	19 89       	ld.ub	r9,r12[0x0]
80004c18:	b4 99       	st.b	r10[0x1],r9
      MSB(u16_unicode_entry) = ptr_entry[1];
80004c1a:	19 99       	ld.ub	r9,r12[0x1]
80004c1c:	b4 89       	st.b	r10[0x0],r9
      if( FS_NAME_GET == b_mode )
80004c1e:	58 06       	cp.w	r6,0
80004c20:	c0 f0       	breq	80004c3e <fat_entry_longname+0x9a>
      {
         if( !g_b_string_length )
80004c22:	0b 89       	ld.ub	r9,r5[0x0]
80004c24:	f6 09 18 00 	cp.b	r9,r11
80004c28:	c3 91       	brne	80004c9a <fat_entry_longname+0xf6>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80004c2a:	40 1e       	lddsp	lr,sp[0x4]
80004c2c:	1c 38       	cp.w	r8,lr
80004c2e:	c0 55       	brlt	80004c38 <fat_entry_longname+0x94>
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004c30:	30 08       	mov	r8,0
80004c32:	ae 88       	st.b	r7[0x0],r8
80004c34:	30 1c       	mov	r12,1
               }
               return true;                     // the buffer is full
80004c36:	c7 38       	rjmp	80004d1c <fat_entry_longname+0x178>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
80004c38:	9a 59       	ld.sh	r9,sp[0xa]
80004c3a:	ae 89       	st.b	r7[0x0],r9
80004c3c:	c2 f8       	rjmp	80004c9a <fat_entry_longname+0xf6>
      {
         if( Is_unicode )
         {
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
80004c3e:	0f 89       	ld.ub	r9,r7[0x0]
         }
         // Check the name
         if( '*' == u16_unicode_szname )
80004c40:	32 a3       	mov	r3,42
80004c42:	e6 09 19 00 	cp.h	r9,r3
80004c46:	c6 a0       	breq	80004d1a <fat_entry_longname+0x176>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80004c48:	9a 5e       	ld.sh	lr,sp[0xa]
80004c4a:	58 0e       	cp.w	lr,0
80004c4c:	c0 e1       	brne	80004c68 <fat_entry_longname+0xc4>
80004c4e:	35 c0       	mov	r0,92
80004c50:	e0 09 19 00 	cp.h	r9,r0
80004c54:	5f 12       	srne	r2
80004c56:	32 f3       	mov	r3,47
80004c58:	e6 09 19 00 	cp.h	r9,r3
80004c5c:	5f 13       	srne	r3
80004c5e:	e5 e3 00 03 	and	r3,r2,r3
80004c62:	f6 03 18 00 	cp.b	r3,r11
80004c66:	c1 e0       	breq	80004ca2 <fat_entry_longname+0xfe>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
80004c68:	e7 d9 c0 10 	bfextu	r3,r9,0x0,0x10
80004c6c:	e5 de c0 10 	bfextu	r2,lr,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80004c70:	e4 c0 ff e0 	sub	r0,r2,-32
80004c74:	00 33       	cp.w	r3,r0
80004c76:	c0 41       	brne	80004c7e <fat_entry_longname+0xda>
80004c78:	40 00       	lddsp	r0,sp[0x0]
80004c7a:	58 00       	cp.w	r0,0
80004c7c:	c0 f0       	breq	80004c9a <fat_entry_longname+0xf6>
80004c7e:	22 02       	sub	r2,32
80004c80:	04 33       	cp.w	r3,r2
80004c82:	c0 41       	brne	80004c8a <fat_entry_longname+0xe6>
80004c84:	40 03       	lddsp	r3,sp[0x0]
80004c86:	58 03       	cp.w	r3,0
80004c88:	c0 90       	breq	80004c9a <fat_entry_longname+0xf6>
80004c8a:	fc 09 19 00 	cp.h	r9,lr
80004c8e:	c0 60       	breq	80004c9a <fat_entry_longname+0xf6>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
80004c90:	31 69       	mov	r9,22
80004c92:	4a 78       	lddpc	r8,80004d2c <fat_entry_longname+0x188>
80004c94:	b0 89       	st.b	r8[0x0],r9
80004c96:	30 0c       	mov	r12,0
           return false;
80004c98:	c4 28       	rjmp	80004d1c <fat_entry_longname+0x178>
         }
      }

      if( 0 == u16_unicode_entry)
80004c9a:	9a 59       	ld.sh	r9,sp[0xa]
80004c9c:	e2 09 19 00 	cp.h	r9,r1
80004ca0:	c0 b1       	brne	80004cb6 <fat_entry_longname+0x112>
      {
         if( g_b_string_length )
80004ca2:	4a 49       	lddpc	r9,80004d30 <fat_entry_longname+0x18c>
80004ca4:	13 8a       	ld.ub	r10,r9[0x0]
80004ca6:	30 09       	mov	r9,0
80004ca8:	f2 0a 18 00 	cp.b	r10,r9
80004cac:	c3 70       	breq	80004d1a <fat_entry_longname+0x176>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
80004cae:	2f f8       	sub	r8,-1
80004cb0:	ae 08       	st.h	r7[0x0],r8
80004cb2:	30 1c       	mov	r12,1
80004cb4:	c3 48       	rjmp	80004d1c <fat_entry_longname+0x178>
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80004cb6:	e8 08 18 00 	cp.b	r8,r4
80004cba:	c0 31       	brne	80004cc0 <fat_entry_longname+0x11c>
         ptr_entry += 3;                        // Go to second character
80004cbc:	2f dc       	sub	r12,-3
80004cbe:	c2 58       	rjmp	80004d08 <fat_entry_longname+0x164>

      if( 10 == u8_pos_name )
80004cc0:	30 a9       	mov	r9,10
80004cc2:	f2 08 18 00 	cp.b	r8,r9
80004cc6:	c0 31       	brne	80004ccc <fat_entry_longname+0x128>
         ptr_entry += 2;                        // Go to third character
80004cc8:	2f ec       	sub	r12,-2
80004cca:	c1 f8       	rjmp	80004d08 <fat_entry_longname+0x164>

      if( 12 == u8_pos_name )
80004ccc:	30 c9       	mov	r9,12
80004cce:	f2 08 18 00 	cp.b	r8,r9
80004cd2:	c1 b1       	brne	80004d08 <fat_entry_longname+0x164>
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
80004cd4:	f9 38 ff e2 	ld.ub	r8,r12[-30]
80004cd8:	e2 18 00 40 	andl	r8,0x40,COH
80004cdc:	c0 61       	brne	80004ce8 <fat_entry_longname+0x144>
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
80004cde:	31 09       	mov	r9,16
80004ce0:	49 38       	lddpc	r8,80004d2c <fat_entry_longname+0x188>
80004ce2:	b0 89       	st.b	r8[0x0],r9
80004ce4:	30 0c       	mov	r12,0
            return false;                       // Other long name entry is present
80004ce6:	c1 b8       	rjmp	80004d1c <fat_entry_longname+0x178>
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
80004ce8:	58 06       	cp.w	r6,0
80004cea:	c0 b0       	breq	80004d00 <fat_entry_longname+0x15c>
80004cec:	49 18       	lddpc	r8,80004d30 <fat_entry_longname+0x18c>
80004cee:	11 89       	ld.ub	r9,r8[0x0]
80004cf0:	30 08       	mov	r8,0
80004cf2:	f0 09 18 00 	cp.b	r9,r8
80004cf6:	c1 50       	breq	80004d20 <fat_entry_longname+0x17c>
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
80004cf8:	30 e8       	mov	r8,14
80004cfa:	ae 08       	st.h	r7[0x0],r8
80004cfc:	30 1c       	mov	r12,1
               return true;
80004cfe:	c0 f8       	rjmp	80004d1c <fat_entry_longname+0x178>
               {
                  u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
               }else{
                  u16_unicode_szname = sz_name[0];
               }
               return fat_check_eof_name(u16_unicode_szname);
80004d00:	0f 9c       	ld.ub	r12,r7[0x1]
80004d02:	f0 1f 00 0d 	mcall	80004d34 <fat_entry_longname+0x190>
80004d06:	c0 b8       	rjmp	80004d1c <fat_entry_longname+0x178>
            }
         }
      }

      if( !g_b_string_length )
80004d08:	0b 89       	ld.ub	r9,r5[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
80004d0a:	f6 09 18 00 	cp.b	r9,r11
80004d0e:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80004d12:	2f f8       	sub	r8,-1
80004d14:	5c 58       	castu.b	r8
      ptr_entry+=2;
80004d16:	2f ec       	sub	r12,-2
   }
80004d18:	c7 fb       	rjmp	80004c16 <fat_entry_longname+0x72>
80004d1a:	30 1c       	mov	r12,1
}
80004d1c:	2f dd       	sub	sp,-12
80004d1e:	d8 32       	popm	r0-r7,pc
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004d20:	30 08       	mov	r8,0
80004d22:	ae 98       	st.b	r7[0x1],r8
80004d24:	30 1c       	mov	r12,1
               }
               return true;
80004d26:	cf bb       	rjmp	80004d1c <fat_entry_longname+0x178>
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	4b 8c       	lddpc	r12,80004e08 <fat_entry_shortname+0xd0>
80004d2c:	00 00       	add	r0,r0
80004d2e:	16 1c       	sub	r12,r11
80004d30:	00 00       	add	r0,r0
80004d32:	16 1d       	sub	sp,r11
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	4b 64       	lddpc	r4,80004e0c <fat_entry_shortname+0xd4>

80004d38 <fat_entry_shortname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_shortname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode )
{
80004d38:	d4 31       	pushm	r0-r7,lr
80004d3a:	20 2d       	sub	sp,8
80004d3c:	18 97       	mov	r7,r12
80004d3e:	50 1b       	stdsp	sp[0x4],r11
80004d40:	14 96       	mov	r6,r10
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
80004d42:	31 69       	mov	r9,22
80004d44:	4b c8       	lddpc	r8,80004e34 <fat_entry_shortname+0xfc>
80004d46:	b0 89       	st.b	r8[0x0],r9

   u8_pos_name = 0;
   u8_pos_entry = 0;
   ptr_entry = fat_get_ptr_entry();
80004d48:	f0 1f 00 3c 	mcall	80004e38 <fat_entry_shortname+0x100>
80004d4c:	30 08       	mov	r8,0
80004d4e:	10 9a       	mov	r10,r8
80004d50:	30 1b       	mov	r11,1
80004d52:	50 0b       	stdsp	sp[0x0],r11

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
80004d54:	30 be       	mov	lr,11
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004d56:	10 93       	mov	r3,r8
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
80004d58:	30 85       	mov	r5,8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004d5a:	32 04       	mov	r4,32
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
80004d5c:	32 a2       	mov	r2,42
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
80004d5e:	fc 08 18 00 	cp.b	r8,lr
80004d62:	c1 90       	breq	80004d94 <fat_entry_shortname+0x5c>
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
80004d64:	f8 08 07 09 	ld.ub	r9,r12[r8]
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
80004d68:	ea 08 18 00 	cp.b	r8,r5
80004d6c:	c0 41       	brne	80004d74 <fat_entry_shortname+0x3c>
80004d6e:	40 01       	lddsp	r1,sp[0x0]
80004d70:	58 01       	cp.w	r1,0
80004d72:	c0 81       	brne	80004d82 <fat_entry_shortname+0x4a>
80004d74:	e8 09 18 00 	cp.b	r9,r4
80004d78:	c0 f1       	brne	80004d96 <fat_entry_shortname+0x5e>
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
80004d7a:	ea 08 18 00 	cp.b	r8,r5
80004d7e:	e0 8b 00 0b 	brhi	80004d94 <fat_entry_shortname+0x5c>
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004d82:	f9 39 00 08 	ld.ub	r9,r12[8]
80004d86:	e8 09 18 00 	cp.b	r9,r4
80004d8a:	c0 50       	breq	80004d94 <fat_entry_shortname+0x5c>
80004d8c:	30 78       	mov	r8,7
80004d8e:	32 e9       	mov	r9,46
80004d90:	50 03       	stdsp	sp[0x0],r3
80004d92:	c0 28       	rjmp	80004d96 <fat_entry_shortname+0x5e>
80004d94:	06 99       	mov	r9,r3
               u8_entry_char = 0;                                    // end of name
            }
         }
      }

      if( FS_NAME_GET == b_mode )
80004d96:	58 06       	cp.w	r6,0
80004d98:	c1 80       	breq	80004dc8 <fat_entry_shortname+0x90>
      {
         if( !g_b_string_length )
80004d9a:	4a 9b       	lddpc	r11,80004e3c <fat_entry_shortname+0x104>
80004d9c:	17 81       	ld.ub	r1,r11[0x0]
80004d9e:	30 0b       	mov	r11,0
80004da0:	f6 01 18 00 	cp.b	r1,r11
80004da4:	c2 c1       	brne	80004dfc <fat_entry_shortname+0xc4>
         {
            if(u8_pos_name >= (u8_size_max-1))
80004da6:	40 1b       	lddsp	r11,sp[0x4]
80004da8:	20 1b       	sub	r11,1
80004daa:	16 3a       	cp.w	r10,r11
80004dac:	c0 35       	brlt	80004db2 <fat_entry_shortname+0x7a>
80004dae:	06 99       	mov	r9,r3
80004db0:	c0 a8       	rjmp	80004dc4 <fat_entry_shortname+0x8c>
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
80004db2:	f2 c1 00 41 	sub	r1,r9,65
80004db6:	31 9b       	mov	r11,25
80004db8:	f6 01 18 00 	cp.b	r1,r11
80004dbc:	e0 8b 00 04 	brhi	80004dc4 <fat_entry_shortname+0x8c>
               u8_entry_char += ('a'-'A');                           // display short name in down case
80004dc0:	2e 09       	sub	r9,-32
80004dc2:	5c 59       	castu.b	r9

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
80004dc4:	ae 89       	st.b	r7[0x0],r9
80004dc6:	c1 b8       	rjmp	80004dfc <fat_entry_shortname+0xc4>

         if( Is_unicode )
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
80004dc8:	0f 8b       	ld.ub	r11,r7[0x0]
         }
         if ('*' == u8_szname_char)
80004dca:	e4 0b 18 00 	cp.b	r11,r2
80004dce:	c2 f0       	breq	80004e2c <fat_entry_shortname+0xf4>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
80004dd0:	58 09       	cp.w	r9,0
80004dd2:	c0 c1       	brne	80004dea <fat_entry_shortname+0xb2>
80004dd4:	35 c1       	mov	r1,92
80004dd6:	e2 0b 18 00 	cp.b	r11,r1
80004dda:	5f 10       	srne	r0
80004ddc:	32 f1       	mov	r1,47
80004dde:	e2 0b 18 00 	cp.b	r11,r1
80004de2:	5f 11       	srne	r1
80004de4:	e1 e1 00 01 	and	r1,r0,r1
80004de8:	c0 c0       	breq	80004e00 <fat_entry_shortname+0xc8>
         {
            if((u8_szname_char != u8_entry_char)
80004dea:	f2 0b 18 00 	cp.b	r11,r9
80004dee:	c0 70       	breq	80004dfc <fat_entry_shortname+0xc4>
80004df0:	f2 c1 ff e0 	sub	r1,r9,-32
80004df4:	02 3b       	cp.w	r11,r1
80004df6:	c0 30       	breq	80004dfc <fat_entry_shortname+0xc4>
80004df8:	30 0c       	mov	r12,0
80004dfa:	c1 a8       	rjmp	80004e2e <fat_entry_shortname+0xf6>
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
80004dfc:	58 09       	cp.w	r9,0
80004dfe:	c0 b1       	brne	80004e14 <fat_entry_shortname+0xdc>
      {
         if( g_b_string_length )
80004e00:	48 f8       	lddpc	r8,80004e3c <fat_entry_shortname+0x104>
80004e02:	11 89       	ld.ub	r9,r8[0x0]
80004e04:	30 08       	mov	r8,0
80004e06:	f0 09 18 00 	cp.b	r9,r8
80004e0a:	c1 10       	breq	80004e2c <fat_entry_shortname+0xf4>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
80004e0c:	2f fa       	sub	r10,-1
80004e0e:	ae 0a       	st.h	r7[0x0],r10
80004e10:	30 1c       	mov	r12,1
80004e12:	c0 e8       	rjmp	80004e2e <fat_entry_shortname+0xf6>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
80004e14:	48 a9       	lddpc	r9,80004e3c <fat_entry_shortname+0x104>
80004e16:	13 8b       	ld.ub	r11,r9[0x0]
80004e18:	30 09       	mov	r9,0
      {
         sz_name += (Is_unicode? 2 : 1 );
80004e1a:	f2 0b 18 00 	cp.b	r11,r9
80004e1e:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80004e22:	2f fa       	sub	r10,-1
80004e24:	5c 5a       	castu.b	r10
      u8_pos_entry++;
80004e26:	2f f8       	sub	r8,-1
80004e28:	5c 58       	castu.b	r8
   }
80004e2a:	c9 ab       	rjmp	80004d5e <fat_entry_shortname+0x26>
80004e2c:	30 1c       	mov	r12,1
}
80004e2e:	2f ed       	sub	sp,-8
80004e30:	d8 32       	popm	r0-r7,pc
80004e32:	00 00       	add	r0,r0
80004e34:	00 00       	add	r0,r0
80004e36:	16 1c       	sub	r12,r11
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	4b 8c       	lddpc	r12,80004f18 <fat_entry_checkext+0x90>
80004e3c:	00 00       	add	r0,r0
80004e3e:	16 1d       	sub	sp,r11

80004e40 <fat_get_entry_info>:
//! OUT:
//!   fs_g_nav_entry. u32_cluster, u8_attr, u32_size
//! @endverbatim
//!
void  fat_get_entry_info( void )
{
80004e40:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
80004e42:	f0 1f 00 10 	mcall	80004e80 <fat_get_entry_info+0x40>

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
80004e46:	49 08       	lddpc	r8,80004e84 <fat_get_entry_info+0x44>
80004e48:	f9 39 00 0b 	ld.ub	r9,r12[11]
80004e4c:	b0 a9       	st.b	r8[0x2],r9

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
80004e4e:	f8 ca ff ec 	sub	r10,r12,-20
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
80004e52:	f0 c9 ff fc 	sub	r9,r8,-4
80004e56:	15 8b       	ld.ub	r11,r10[0x0]
80004e58:	b2 9b       	st.b	r9[0x1],r11
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
80004e5a:	15 9a       	ld.ub	r10,r10[0x1]
80004e5c:	b2 8a       	st.b	r9[0x0],r10
   ptr_entry += (26-20);
80004e5e:	f8 ca ff e6 	sub	r10,r12,-26
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
80004e62:	15 8b       	ld.ub	r11,r10[0x0]
80004e64:	b2 bb       	st.b	r9[0x3],r11
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
80004e66:	15 9a       	ld.ub	r10,r10[0x1]
80004e68:	b2 aa       	st.b	r9[0x2],r10

   // Get the size of file
   ptr_entry += (28-26);
80004e6a:	2e 4c       	sub	r12,-28
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
80004e6c:	2f 88       	sub	r8,-8
80004e6e:	19 89       	ld.ub	r9,r12[0x0]
80004e70:	b0 b9       	st.b	r8[0x3],r9
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
80004e72:	19 99       	ld.ub	r9,r12[0x1]
80004e74:	b0 a9       	st.b	r8[0x2],r9
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
80004e76:	19 a9       	ld.ub	r9,r12[0x2]
80004e78:	b0 99       	st.b	r8[0x1],r9
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
80004e7a:	19 b9       	ld.ub	r9,r12[0x3]
80004e7c:	b0 89       	st.b	r8[0x0],r9
}
80004e7e:	d8 02       	popm	pc
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	4b 8c       	lddpc	r12,80004f60 <fat_entry_check+0x38>
80004e84:	00 00       	add	r0,r0
80004e86:	13 8c       	ld.ub	r12,r9[0x0]

80004e88 <fat_entry_checkext>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_checkext( FS_STRING sz_filter )
{
80004e88:	eb cd 40 fc 	pushm	r2-r7,lr
80004e8c:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();
80004e8e:	f0 1f 00 26 	mcall	80004f24 <fat_entry_checkext+0x9c>

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
80004e92:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
80004e94:	32 a9       	mov	r9,42
80004e96:	f2 08 18 00 	cp.b	r8,r9
80004e9a:	c3 f0       	breq	80004f18 <fat_entry_checkext+0x90>
80004e9c:	30 0a       	mov	r10,0
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
80004e9e:	30 25       	mov	r5,2
      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80004ea0:	30 0e       	mov	lr,0

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
80004ea2:	32 c9       	mov	r9,44
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
80004ea4:	32 03       	mov	r3,32
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004ea6:	14 94       	mov	r4,r10

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
      if ('*' == u8_filter_char)
80004ea8:	32 a6       	mov	r6,42
80004eaa:	c0 68       	rjmp	80004eb6 <fat_entry_checkext+0x2e>
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004eac:	2f f7       	sub	r7,-1
   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
80004eae:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
80004eb0:	ec 08 18 00 	cp.b	r8,r6
80004eb4:	c3 20       	breq	80004f18 <fat_entry_checkext+0x90>
         break; // All extension is good

      u8_entry_char = u8_ptr_entry[8+u8_i];
80004eb6:	f8 0a 00 0b 	add	r11,r12,r10
80004eba:	f7 3b 00 08 	ld.ub	r11,r11[8]

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
80004ebe:	f6 08 18 00 	cp.b	r8,r11
80004ec2:	c2 20       	breq	80004f06 <fat_entry_checkext+0x7e>
80004ec4:	f6 c2 ff e0 	sub	r2,r11,-32
80004ec8:	04 38       	cp.w	r8,r2
80004eca:	c1 e0       	breq	80004f06 <fat_entry_checkext+0x7e>
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80004ecc:	fc 08 18 00 	cp.b	r8,lr
80004ed0:	5f 0a       	sreq	r10

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
80004ed2:	f2 08 18 00 	cp.b	r8,r9
80004ed6:	5f 02       	sreq	r2
80004ed8:	f5 e2 10 02 	or	r2,r10,r2
80004edc:	fc 02 18 00 	cp.b	r2,lr
80004ee0:	c0 71       	brne	80004eee <fat_entry_checkext+0x66>
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
80004ee2:	f2 08 18 00 	cp.b	r8,r9
80004ee6:	c1 b0       	breq	80004f1c <fat_entry_checkext+0x94>
         {
            if (0  == u8_filter_char)
80004ee8:	58 0a       	cp.w	r10,0
80004eea:	c0 80       	breq	80004efa <fat_entry_checkext+0x72>
80004eec:	c1 48       	rjmp	80004f14 <fat_entry_checkext+0x8c>
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
80004eee:	e6 0b 18 00 	cp.b	r11,r3
80004ef2:	cf 81       	brne	80004ee2 <fat_entry_checkext+0x5a>
80004ef4:	c1 28       	rjmp	80004f18 <fat_entry_checkext+0x90>
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
         {
            if (0  == u8_filter_char)
80004ef6:	58 08       	cp.w	r8,0
80004ef8:	c0 e0       	breq	80004f14 <fat_entry_checkext+0x8c>
            {
               return false;   // it is the last filter
            }
            sz_filter++;
80004efa:	2f f7       	sub	r7,-1
            u8_filter_char = *sz_filter;
80004efc:	0f 88       	ld.ub	r8,r7[0x0]
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
80004efe:	f2 08 18 00 	cp.b	r8,r9
80004f02:	cf a1       	brne	80004ef6 <fat_entry_checkext+0x6e>
80004f04:	c0 c8       	rjmp	80004f1c <fat_entry_checkext+0x94>
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
80004f06:	2f fa       	sub	r10,-1
80004f08:	5c 5a       	castu.b	r10
80004f0a:	ea 0a 18 00 	cp.b	r10,r5
80004f0e:	fe 98 ff cf 	brls	80004eac <fat_entry_checkext+0x24>
80004f12:	c0 38       	rjmp	80004f18 <fat_entry_checkext+0x90>
80004f14:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004f18:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004f1c:	2f f7       	sub	r7,-1
80004f1e:	08 9a       	mov	r10,r4
80004f20:	cc 7b       	rjmp	80004eae <fat_entry_checkext+0x26>
80004f22:	00 00       	add	r0,r0
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	4b 8c       	lddpc	r12,80005004 <fat_check_nav_access_file+0x8>

80004f28 <fat_entry_check>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_check( bool b_type )
{
80004f28:	eb cd 40 80 	pushm	r7,lr
80004f2c:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_first_byte, u8_seconde_byte;
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();
80004f2e:	f0 1f 00 14 	mcall	80004f7c <fat_entry_check+0x54>

   u8_first_byte = u8_ptr_entry[0];
80004f32:	19 88       	ld.ub	r8,r12[0x0]
   if ( FS_ENTRY_END == u8_first_byte )
80004f34:	58 08       	cp.w	r8,0
80004f36:	c0 61       	brne	80004f42 <fat_entry_check+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
80004f38:	30 a9       	mov	r9,10
80004f3a:	49 28       	lddpc	r8,80004f80 <fat_entry_check+0x58>
80004f3c:	b0 89       	st.b	r8[0x0],r9
80004f3e:	30 07       	mov	r7,0
      return false;
80004f40:	c1 a8       	rjmp	80004f74 <fat_entry_check+0x4c>
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
80004f42:	30 ba       	mov	r10,11
80004f44:	48 f9       	lddpc	r9,80004f80 <fat_entry_check+0x58>
80004f46:	b2 8a       	st.b	r9[0x0],r10
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
80004f48:	3e 59       	mov	r9,-27
80004f4a:	f2 08 18 00 	cp.b	r8,r9
80004f4e:	c1 20       	breq	80004f72 <fat_entry_check+0x4a>
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
80004f50:	32 e9       	mov	r9,46
80004f52:	f2 08 18 00 	cp.b	r8,r9
80004f56:	c0 e0       	breq	80004f72 <fat_entry_check+0x4a>
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
80004f58:	f9 38 00 0b 	ld.ub	r8,r12[11]
80004f5c:	10 99       	mov	r9,r8
80004f5e:	e2 19 00 08 	andl	r9,0x8,COH
80004f62:	c0 81       	brne	80004f72 <fat_entry_check+0x4a>
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
80004f64:	e2 18 00 10 	andl	r8,0x10,COH
80004f68:	c0 60       	breq	80004f74 <fat_entry_check+0x4c>
   {
      return (FS_DIR == b_type);
80004f6a:	ec 17 00 01 	eorl	r7,0x1
80004f6e:	5c 57       	castu.b	r7
80004f70:	c0 28       	rjmp	80004f74 <fat_entry_check+0x4c>
80004f72:	30 07       	mov	r7,0
   }else{
      return (FS_FILE == b_type);
   }
}
80004f74:	0e 9c       	mov	r12,r7
80004f76:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f7a:	00 00       	add	r0,r0
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4b 8c       	lddpc	r12,8000505c <fat_check_nav_access_file+0x60>
80004f80:	00 00       	add	r0,r0
80004f82:	16 1c       	sub	r12,r11

80004f84 <fat_cache_reset>:

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
80004f84:	48 58       	lddpc	r8,80004f98 <fat_cache_reset+0x14>
80004f86:	3f f9       	mov	r9,-1
80004f88:	b0 89       	st.b	r8[0x0],r9
   fs_g_sectorcache.u8_dirty              = false;
80004f8a:	30 09       	mov	r9,0
80004f8c:	f1 69 00 08 	st.b	r8[8],r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
80004f90:	3f f9       	mov	r9,-1
80004f92:	91 39       	st.w	r8[0xc],r9
}
80004f94:	5e fc       	retal	r12
80004f96:	00 00       	add	r0,r0
80004f98:	00 00       	add	r0,r0
80004f9a:	16 54       	eor	r4,r11

80004f9c <fat_cache_mark_sector_as_dirty>:

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
80004f9c:	30 19       	mov	r9,1
80004f9e:	48 38       	lddpc	r8,80004fa8 <fat_cache_mark_sector_as_dirty+0xc>
80004fa0:	f1 69 00 08 	st.b	r8[8],r9
}
80004fa4:	5e fc       	retal	r12
80004fa6:	00 00       	add	r0,r0
80004fa8:	00 00       	add	r0,r0
80004faa:	16 54       	eor	r4,r11

80004fac <fat_write_entry_file>:
//! OUT:
//!   fs_g_sector    Updated
//! @endverbatim
//!
void  fat_write_entry_file( void )
{
80004fac:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   fat_cache_mark_sector_as_dirty();
80004fae:	f0 1f 00 11 	mcall	80004ff0 <fat_write_entry_file+0x44>
   ptr_entry = fat_get_ptr_entry();
80004fb2:	f0 1f 00 11 	mcall	80004ff4 <fat_write_entry_file+0x48>
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
80004fb6:	49 18       	lddpc	r8,80004ff8 <fat_write_entry_file+0x4c>
80004fb8:	11 a9       	ld.ub	r9,r8[0x2]
80004fba:	f9 69 00 0b 	st.b	r12[11],r9

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
80004fbe:	f8 ca ff ec 	sub	r10,r12,-20
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
80004fc2:	f0 c9 ff fc 	sub	r9,r8,-4
80004fc6:	13 9b       	ld.ub	r11,r9[0x1]
80004fc8:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
80004fca:	13 8b       	ld.ub	r11,r9[0x0]
80004fcc:	b4 9b       	st.b	r10[0x1],r11
   ptr_entry += (26-20);
80004fce:	f8 ca ff e6 	sub	r10,r12,-26
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
80004fd2:	13 bb       	ld.ub	r11,r9[0x3]
80004fd4:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
80004fd6:	13 a9       	ld.ub	r9,r9[0x2]
80004fd8:	b4 99       	st.b	r10[0x1],r9

   //! Write the size of file
   ptr_entry += (28-26);
80004fda:	2e 4c       	sub	r12,-28
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
80004fdc:	2f 88       	sub	r8,-8
80004fde:	11 b9       	ld.ub	r9,r8[0x3]
80004fe0:	b8 89       	st.b	r12[0x0],r9
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
80004fe2:	11 a9       	ld.ub	r9,r8[0x2]
80004fe4:	b8 99       	st.b	r12[0x1],r9
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
80004fe6:	11 99       	ld.ub	r9,r8[0x1]
80004fe8:	b8 a9       	st.b	r12[0x2],r9
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
80004fea:	11 88       	ld.ub	r8,r8[0x0]
80004fec:	b8 b8       	st.b	r12[0x3],r8
}
80004fee:	d8 02       	popm	pc
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	4f 9c       	lddpc	r12,800051d4 <fat_cache_read_sector+0x18>
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4b 8c       	lddpc	r12,800050d4 <fat_invert_nav+0x60>
80004ff8:	00 00       	add	r0,r0
80004ffa:	13 8c       	ld.ub	r12,r9[0x0]

80004ffc <fat_check_nav_access_file>:

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
80004ffc:	49 88       	lddpc	r8,8000505c <fat_check_nav_access_file+0x60>
80004ffe:	11 89       	ld.ub	r9,r8[0x0]
80005000:	30 08       	mov	r8,0
80005002:	f0 09 18 00 	cp.b	r9,r8
80005006:	c2 a0       	breq	8000505a <fat_check_nav_access_file+0x5e>
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80005008:	49 68       	lddpc	r8,80005060 <fat_check_nav_access_file+0x64>
8000500a:	11 89       	ld.ub	r9,r8[0x0]
8000500c:	49 68       	lddpc	r8,80005064 <fat_check_nav_access_file+0x68>
8000500e:	11 88       	ld.ub	r8,r8[0x0]
80005010:	f0 09 18 00 	cp.b	r9,r8
80005014:	c2 31       	brne	8000505a <fat_check_nav_access_file+0x5e>
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
80005016:	49 38       	lddpc	r8,80005060 <fat_check_nav_access_file+0x64>
80005018:	70 89       	ld.w	r9,r8[0x20]
8000501a:	49 38       	lddpc	r8,80005064 <fat_check_nav_access_file+0x68>
8000501c:	70 88       	ld.w	r8,r8[0x20]
8000501e:	10 39       	cp.w	r9,r8
80005020:	c1 d1       	brne	8000505a <fat_check_nav_access_file+0x5e>
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
80005022:	49 28       	lddpc	r8,80005068 <fat_check_nav_access_file+0x6c>
80005024:	90 19       	ld.sh	r9,r8[0x2]
80005026:	48 e8       	lddpc	r8,8000505c <fat_check_nav_access_file+0x60>
80005028:	90 18       	ld.sh	r8,r8[0x2]
8000502a:	f0 09 19 00 	cp.h	r9,r8
8000502e:	c1 61       	brne	8000505a <fat_check_nav_access_file+0x5e>
      {
         if( mode )
80005030:	58 0c       	cp.w	r12,0
80005032:	c0 b0       	breq	80005048 <fat_check_nav_access_file+0x4c>
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
80005034:	48 e8       	lddpc	r8,8000506c <fat_check_nav_access_file+0x70>
80005036:	11 89       	ld.ub	r9,r8[0x0]
80005038:	30 08       	mov	r8,0
8000503a:	f0 09 18 00 	cp.b	r9,r8
8000503e:	c0 e0       	breq	8000505a <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN;
80005040:	32 89       	mov	r9,40
80005042:	48 c8       	lddpc	r8,80005070 <fat_check_nav_access_file+0x74>
80005044:	b0 89       	st.b	r8[0x0],r9
80005046:	5e fd       	retal	0
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
80005048:	48 98       	lddpc	r8,8000506c <fat_check_nav_access_file+0x70>
8000504a:	11 88       	ld.ub	r8,r8[0x0]
8000504c:	e2 18 00 02 	andl	r8,0x2,COH
80005050:	c0 50       	breq	8000505a <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
80005052:	32 99       	mov	r9,41
80005054:	48 78       	lddpc	r8,80005070 <fat_check_nav_access_file+0x74>
80005056:	b0 89       	st.b	r8[0x0],r9
80005058:	5e fd       	retal	0
               return false;  // File opened in write mode then read access not possible
8000505a:	5e ff       	retal	1
8000505c:	00 00       	add	r0,r0
8000505e:	16 14       	sub	r4,r11
80005060:	00 00       	add	r0,r0
80005062:	15 cc       	ld.ub	r12,r10[0x4]
80005064:	00 00       	add	r0,r0
80005066:	16 20       	rsub	r0,r11
80005068:	00 00       	add	r0,r0
8000506a:	16 18       	sub	r8,r11
8000506c:	00 00       	add	r0,r0
8000506e:	16 04       	add	r4,r11
80005070:	00 00       	add	r0,r0
80005072:	16 1c       	sub	r12,r11

80005074 <fat_invert_nav>:
//! This function inverts the current navigation with another
//!
//! @param     u8_idnav    Id navigator to invert
//!
void  fat_invert_nav( uint8_t u8_idnav )
{
80005074:	d4 21       	pushm	r4-r7,lr
80005076:	20 dd       	sub	sp,52
   _MEM_TYPE_SLOW_ uint8_t Temp[Max(Max(sizeof(Fs_management),sizeof(Fs_management_entry)),sizeof(Fs_management_fast))];

   if( u8_idnav == 0 )
80005078:	58 0c       	cp.w	r12,0
8000507a:	c5 a0       	breq	8000512e <fat_invert_nav+0xba>
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
8000507c:	1a 97       	mov	r7,sp
8000507e:	4a e8       	lddpc	r8,80005134 <fat_invert_nav+0xc0>
80005080:	f0 ea 00 00 	ld.d	r10,r8[0]
80005084:	fa eb 00 00 	st.d	sp[0],r10
80005088:	f0 ea 00 08 	ld.d	r10,r8[8]
8000508c:	fa eb 00 08 	st.d	sp[8],r10
80005090:	f0 ea 00 10 	ld.d	r10,r8[16]
80005094:	fa eb 00 10 	st.d	sp[16],r10
80005098:	f0 ea 00 18 	ld.d	r10,r8[24]
8000509c:	fa eb 00 18 	st.d	sp[24],r10
800050a0:	f0 ea 00 20 	ld.d	r10,r8[32]
800050a4:	fa eb 00 20 	st.d	sp[32],r10
800050a8:	f0 ea 00 28 	ld.d	r10,r8[40]
800050ac:	fa eb 00 28 	st.d	sp[40],r10
800050b0:	70 c9       	ld.w	r9,r8[0x30]
800050b2:	50 c9       	stdsp	sp[0x30],r9
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
800050b4:	f8 c6 00 01 	sub	r6,r12,1
800050b8:	5c 56       	castu.b	r6
800050ba:	ec 04 10 34 	mul	r4,r6,52
800050be:	49 f9       	lddpc	r9,80005138 <fat_invert_nav+0xc4>
800050c0:	12 04       	add	r4,r9
800050c2:	33 45       	mov	r5,52
800050c4:	0a 9a       	mov	r10,r5
800050c6:	08 9b       	mov	r11,r4
800050c8:	10 9c       	mov	r12,r8
800050ca:	f0 1f 00 1d 	mcall	8000513c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
800050ce:	0a 9a       	mov	r10,r5
800050d0:	1a 9b       	mov	r11,sp
800050d2:	08 9c       	mov	r12,r4
800050d4:	f0 1f 00 1a 	mcall	8000513c <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
800050d8:	49 ac       	lddpc	r12,80005140 <fat_invert_nav+0xcc>
800050da:	f8 e8 00 00 	ld.d	r8,r12[0]
800050de:	fa e9 00 00 	st.d	sp[0],r8
800050e2:	f8 e8 00 08 	ld.d	r8,r12[8]
800050e6:	fa e9 00 08 	st.d	sp[8],r8
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
800050ea:	ec 04 15 04 	lsl	r4,r6,0x4
800050ee:	49 68       	lddpc	r8,80005144 <fat_invert_nav+0xd0>
800050f0:	10 04       	add	r4,r8
800050f2:	31 05       	mov	r5,16
800050f4:	0a 9a       	mov	r10,r5
800050f6:	08 9b       	mov	r11,r4
800050f8:	f0 1f 00 11 	mcall	8000513c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
800050fc:	0a 9a       	mov	r10,r5
800050fe:	1a 9b       	mov	r11,sp
80005100:	08 9c       	mov	r12,r4
80005102:	f0 1f 00 0f 	mcall	8000513c <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
80005106:	49 14       	lddpc	r4,80005148 <fat_invert_nav+0xd4>
80005108:	30 45       	mov	r5,4
8000510a:	0a 9a       	mov	r10,r5
8000510c:	08 9b       	mov	r11,r4
8000510e:	1a 9c       	mov	r12,sp
80005110:	f0 1f 00 0b 	mcall	8000513c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
80005114:	48 e8       	lddpc	r8,8000514c <fat_invert_nav+0xd8>
80005116:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000511a:	0a 9a       	mov	r10,r5
8000511c:	0c 9b       	mov	r11,r6
8000511e:	08 9c       	mov	r12,r4
80005120:	f0 1f 00 07 	mcall	8000513c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
80005124:	0a 9a       	mov	r10,r5
80005126:	1a 9b       	mov	r11,sp
80005128:	0c 9c       	mov	r12,r6
8000512a:	f0 1f 00 05 	mcall	8000513c <fat_invert_nav+0xc8>
}
8000512e:	2f 3d       	sub	sp,-52
80005130:	d8 22       	popm	r4-r7,pc
80005132:	00 00       	add	r0,r0
80005134:	00 00       	add	r0,r0
80005136:	15 cc       	ld.ub	r12,r10[0x4]
80005138:	00 00       	add	r0,r0
8000513a:	16 20       	rsub	r0,r11
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	aa 30       	st.h	r5[0x6],r0
80005140:	00 00       	add	r0,r0
80005142:	13 8c       	ld.ub	r12,r9[0x0]
80005144:	00 00       	add	r0,r0
80005146:	16 04       	add	r4,r11
80005148:	00 00       	add	r0,r0
8000514a:	16 18       	sub	r8,r11
8000514c:	00 00       	add	r0,r0
8000514e:	16 14       	sub	r4,r11

80005150 <fat_cache_flush>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
80005150:	d4 01       	pushm	lr
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
80005152:	49 08       	lddpc	r8,80005190 <fat_cache_flush+0x40>
80005154:	f1 39 00 08 	ld.ub	r9,r8[8]
80005158:	30 18       	mov	r8,1
8000515a:	f0 09 18 00 	cp.b	r9,r8
8000515e:	c1 81       	brne	8000518e <fat_cache_flush+0x3e>
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
80005160:	48 c8       	lddpc	r8,80005190 <fat_cache_flush+0x40>
80005162:	30 09       	mov	r9,0
80005164:	f1 69 00 08 	st.b	r8[8],r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
80005168:	11 8c       	ld.ub	r12,r8[0x0]
8000516a:	f0 1f 00 0b 	mcall	80005194 <fat_cache_flush+0x44>
8000516e:	c0 50       	breq	80005178 <fat_cache_flush+0x28>
      {
         fs_g_status = FS_LUN_WP;
80005170:	31 49       	mov	r9,20
80005172:	48 a8       	lddpc	r8,80005198 <fat_cache_flush+0x48>
80005174:	b0 89       	st.b	r8[0x0],r9
80005176:	d8 0a       	popm	pc,r12=0
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
80005178:	48 68       	lddpc	r8,80005190 <fat_cache_flush+0x40>
8000517a:	48 9a       	lddpc	r10,8000519c <fat_cache_flush+0x4c>
8000517c:	70 1b       	ld.w	r11,r8[0x4]
8000517e:	11 8c       	ld.ub	r12,r8[0x0]
80005180:	f0 1f 00 08 	mcall	800051a0 <fat_cache_flush+0x50>
80005184:	c0 50       	breq	8000518e <fat_cache_flush+0x3e>
      {
         fs_g_status = FS_ERR_HW;
80005186:	30 19       	mov	r9,1
80005188:	48 48       	lddpc	r8,80005198 <fat_cache_flush+0x48>
8000518a:	b0 89       	st.b	r8[0x0],r9
8000518c:	d8 0a       	popm	pc,r12=0
         return false;
8000518e:	da 0a       	popm	pc,r12=1
80005190:	00 00       	add	r0,r0
80005192:	16 54       	eor	r4,r11
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	70 c4       	ld.w	r4,r8[0x30]
80005198:	00 00       	add	r0,r0
8000519a:	16 1c       	sub	r12,r11
8000519c:	00 00       	add	r0,r0
8000519e:	13 cc       	ld.ub	r12,r9[0x4]
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	70 04       	ld.w	r4,r8[0x0]

800051a4 <fat_cache_clear>:

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
800051a4:	d4 01       	pushm	lr
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
800051a6:	e0 6a 02 00 	mov	r10,512
800051aa:	30 0b       	mov	r11,0
800051ac:	48 2c       	lddpc	r12,800051b4 <fat_cache_clear+0x10>
800051ae:	f0 1f 00 03 	mcall	800051b8 <fat_cache_clear+0x14>
}
800051b2:	d8 02       	popm	pc
800051b4:	00 00       	add	r0,r0
800051b6:	13 cc       	ld.ub	r12,r9[0x4]
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	ab 78       	lsl	r8,0xb

800051bc <fat_cache_read_sector>:
//!   fs_g_nav.u8_lun      drive number to read
//!   fs_gu32_addrsector   address to read (unit sector)
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
800051bc:	eb cd 40 80 	pushm	r7,lr
800051c0:	18 97       	mov	r7,r12
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
800051c2:	49 78       	lddpc	r8,8000521c <fat_cache_read_sector+0x60>
800051c4:	11 89       	ld.ub	r9,r8[0x0]
800051c6:	49 78       	lddpc	r8,80005220 <fat_cache_read_sector+0x64>
800051c8:	11 88       	ld.ub	r8,r8[0x0]
800051ca:	f0 09 18 00 	cp.b	r9,r8
800051ce:	c0 91       	brne	800051e0 <fat_cache_read_sector+0x24>
800051d0:	49 38       	lddpc	r8,8000521c <fat_cache_read_sector+0x60>
800051d2:	70 19       	ld.w	r9,r8[0x4]
800051d4:	49 48       	lddpc	r8,80005224 <fat_cache_read_sector+0x68>
800051d6:	70 08       	ld.w	r8,r8[0x0]
800051d8:	10 39       	cp.w	r9,r8
800051da:	c0 31       	brne	800051e0 <fat_cache_read_sector+0x24>
800051dc:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      return true;
   }

   // Write previous cache before fill cache with a new sector
   if( !fat_cache_flush())
800051e0:	f0 1f 00 12 	mcall	80005228 <fat_cache_read_sector+0x6c>
800051e4:	c1 90       	breq	80005216 <fat_cache_read_sector+0x5a>
      return false;

   // Delete informations about the caches
   fat_cache_reset();
800051e6:	f0 1f 00 12 	mcall	8000522c <fat_cache_read_sector+0x70>

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
800051ea:	48 f8       	lddpc	r8,80005224 <fat_cache_read_sector+0x68>
800051ec:	70 0b       	ld.w	r11,r8[0x0]
800051ee:	48 c8       	lddpc	r8,8000521c <fat_cache_read_sector+0x60>
800051f0:	91 1b       	st.w	r8[0x4],r11
   if( b_load )
800051f2:	58 07       	cp.w	r7,0
800051f4:	c0 c0       	breq	8000520c <fat_cache_read_sector+0x50>
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
800051f6:	48 fa       	lddpc	r10,80005230 <fat_cache_read_sector+0x74>
800051f8:	48 a8       	lddpc	r8,80005220 <fat_cache_read_sector+0x64>
800051fa:	11 8c       	ld.ub	r12,r8[0x0]
800051fc:	f0 1f 00 0e 	mcall	80005234 <fat_cache_read_sector+0x78>
80005200:	c0 60       	breq	8000520c <fat_cache_read_sector+0x50>
      {
         fs_g_status = FS_ERR_HW;
80005202:	30 19       	mov	r9,1
80005204:	48 d8       	lddpc	r8,80005238 <fat_cache_read_sector+0x7c>
80005206:	b0 89       	st.b	r8[0x0],r9
80005208:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000520c:	48 58       	lddpc	r8,80005220 <fat_cache_read_sector+0x64>
8000520e:	11 89       	ld.ub	r9,r8[0x0]
80005210:	48 38       	lddpc	r8,8000521c <fat_cache_read_sector+0x60>
80005212:	b0 89       	st.b	r8[0x0],r9
80005214:	30 1c       	mov	r12,1
   return true;
}
80005216:	e3 cd 80 80 	ldm	sp++,r7,pc
8000521a:	00 00       	add	r0,r0
8000521c:	00 00       	add	r0,r0
8000521e:	16 54       	eor	r4,r11
80005220:	00 00       	add	r0,r0
80005222:	15 cc       	ld.ub	r12,r10[0x4]
80005224:	00 00       	add	r0,r0
80005226:	13 88       	ld.ub	r8,r9[0x0]
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	51 50       	stdsp	sp[0x54],r0
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	4f 84       	lddpc	r4,8000540c <fat_cluster_val+0x13c>
80005230:	00 00       	add	r0,r0
80005232:	13 cc       	ld.ub	r12,r9[0x4]
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	70 64       	ld.w	r4,r8[0x18]
80005238:	00 00       	add	r0,r0
8000523a:	16 1c       	sub	r12,r11

8000523c <fat_cluster_readnext>:
//!   fs_g_u16_pos_fat        read cluster position in FAT
//!   fs_g_cluster.u32_val    value of cluster read
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
8000523c:	d4 01       	pushm	lr
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
8000523e:	49 f8       	lddpc	r8,800052b8 <fat_cluster_readnext+0x7c>
80005240:	11 89       	ld.ub	r9,r8[0x0]
80005242:	30 38       	mov	r8,3
80005244:	f0 09 18 00 	cp.b	r9,r8
80005248:	c0 61       	brne	80005254 <fat_cluster_readnext+0x18>
   {
      fs_g_u16_pos_fat += 4;
8000524a:	49 d8       	lddpc	r8,800052bc <fat_cluster_readnext+0x80>
8000524c:	90 09       	ld.sh	r9,r8[0x0]
8000524e:	2f c9       	sub	r9,-4
80005250:	b0 09       	st.h	r8[0x0],r9
80005252:	c0 58       	rjmp	8000525c <fat_cluster_readnext+0x20>
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
80005254:	49 a8       	lddpc	r8,800052bc <fat_cluster_readnext+0x80>
80005256:	90 09       	ld.sh	r9,r8[0x0]
80005258:	2f e9       	sub	r9,-2
8000525a:	b0 09       	st.h	r8[0x0],r9
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
8000525c:	49 88       	lddpc	r8,800052bc <fat_cluster_readnext+0x80>
8000525e:	90 09       	ld.sh	r9,r8[0x0]
80005260:	e0 68 02 00 	mov	r8,512
80005264:	f0 09 19 00 	cp.h	r9,r8
80005268:	c0 c1       	brne	80005280 <fat_cluster_readnext+0x44>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000526a:	30 09       	mov	r9,0
8000526c:	49 48       	lddpc	r8,800052bc <fat_cluster_readnext+0x80>
8000526e:	b0 09       	st.h	r8[0x0],r9
      fs_gu32_addrsector++;
80005270:	49 48       	lddpc	r8,800052c0 <fat_cluster_readnext+0x84>
80005272:	70 09       	ld.w	r9,r8[0x0]
80005274:	2f f9       	sub	r9,-1
80005276:	91 09       	st.w	r8[0x0],r9
      if( !fat_cache_read_sector( true ))
80005278:	30 1c       	mov	r12,1
8000527a:	f0 1f 00 13 	mcall	800052c4 <fat_cluster_readnext+0x88>
8000527e:	c1 b0       	breq	800052b4 <fat_cluster_readnext+0x78>
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
80005280:	49 28       	lddpc	r8,800052c8 <fat_cluster_readnext+0x8c>
80005282:	2f c8       	sub	r8,-4
80005284:	48 e9       	lddpc	r9,800052bc <fat_cluster_readnext+0x80>
80005286:	92 89       	ld.uh	r9,r9[0x0]
80005288:	49 1a       	lddpc	r10,800052cc <fat_cluster_readnext+0x90>
8000528a:	f4 09 07 0b 	ld.ub	r11,r10[r9]
8000528e:	b0 bb       	st.b	r8[0x3],r11
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
80005290:	12 0a       	add	r10,r9
80005292:	15 9a       	ld.ub	r10,r10[0x1]
80005294:	b0 aa       	st.b	r8[0x2],r10

   if ( Is_fat32 )
80005296:	48 9a       	lddpc	r10,800052b8 <fat_cluster_readnext+0x7c>
80005298:	15 8b       	ld.ub	r11,r10[0x0]
8000529a:	30 3a       	mov	r10,3
8000529c:	f4 0b 18 00 	cp.b	r11,r10
800052a0:	c0 20       	breq	800052a4 <fat_cluster_readnext+0x68>
800052a2:	da 0a       	popm	pc,r12=1
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
800052a4:	48 aa       	lddpc	r10,800052cc <fat_cluster_readnext+0x90>
800052a6:	f4 09 00 09 	add	r9,r10,r9
800052aa:	13 aa       	ld.ub	r10,r9[0x2]
800052ac:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
800052ae:	13 b9       	ld.ub	r9,r9[0x3]
800052b0:	b0 89       	st.b	r8[0x0],r9
800052b2:	30 1c       	mov	r12,1
   }
   return true;
}
800052b4:	d8 02       	popm	pc
800052b6:	00 00       	add	r0,r0
800052b8:	00 00       	add	r0,r0
800052ba:	16 18       	sub	r8,r11
800052bc:	00 00       	add	r0,r0
800052be:	13 9c       	ld.ub	r12,r9[0x1]
800052c0:	00 00       	add	r0,r0
800052c2:	13 88       	ld.ub	r8,r9[0x0]
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	51 bc       	stdsp	sp[0x6c],r12
800052c8:	00 00       	add	r0,r0
800052ca:	16 6c       	and	r12,r11
800052cc:	00 00       	add	r0,r0
800052ce:	13 cc       	ld.ub	r12,r9[0x4]

800052d0 <fat_cluster_val>:
//!   fs_g_u16_pos_fat        position in FAT of the cluster to read or write
//!                           value init in case of the fat_cluster_readnext() routine is used after
//! @endverbatim
//!
bool  fat_cluster_val( bool b_mode )
{
800052d0:	d4 31       	pushm	r0-r7,lr
800052d2:	18 95       	mov	r5,r12
   _MEM_TYPE_FAST_ uint32_t   u32_offset_fat =0;
   _MEM_TYPE_FAST_ uint8_t    u8_data1, u8_data2,u8_data3,u8_data4;
   _MEM_TYPE_FAST_ PTR_CACHE u8_ptr_cluster;

   //**** Compute the cluster position in FAT (sector address & position in sector)
   if ( Is_fat32 )
800052d4:	fe f8 02 18 	ld.w	r8,pc[536]
800052d8:	11 88       	ld.ub	r8,r8[0x0]
800052da:	30 39       	mov	r9,3
800052dc:	f2 08 18 00 	cp.b	r8,r9
800052e0:	c0 d1       	brne	800052fa <fat_cluster_val+0x2a>
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
800052e2:	fe fa 02 0e 	ld.w	r10,pc[526]
800052e6:	74 09       	ld.w	r9,r10[0x0]
800052e8:	a7 99       	lsr	r9,0x7

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
800052ea:	15 bb       	ld.ub	r11,r10[0x3]
800052ec:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800052f0:	a3 6b       	lsl	r11,0x2
800052f2:	fe fa 02 02 	ld.w	r10,pc[514]
800052f6:	b4 0b       	st.h	r10[0x0],r11
800052f8:	c2 08       	rjmp	80005338 <fat_cluster_val+0x68>
   }
   else if ( Is_fat16 )
800052fa:	30 29       	mov	r9,2
800052fc:	f2 08 18 00 	cp.b	r8,r9
80005300:	c0 81       	brne	80005310 <fat_cluster_val+0x40>
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
80005302:	4f ca       	lddpc	r10,800054f0 <fat_cluster_val+0x220>
80005304:	15 a9       	ld.ub	r9,r10[0x2]
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
80005306:	15 bb       	ld.ub	r11,r10[0x3]
80005308:	a1 7b       	lsl	r11,0x1
8000530a:	4f ba       	lddpc	r10,800054f4 <fat_cluster_val+0x224>
8000530c:	b4 0b       	st.h	r10[0x0],r11
8000530e:	c1 58       	rjmp	80005338 <fat_cluster_val+0x68>
   }
   else if ( Is_fat12 )
80005310:	30 19       	mov	r9,1
80005312:	f2 08 18 00 	cp.b	r8,r9
80005316:	c0 30       	breq	8000531c <fat_cluster_val+0x4c>
80005318:	30 09       	mov	r9,0
8000531a:	c0 f8       	rjmp	80005338 <fat_cluster_val+0x68>
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
8000531c:	4f 59       	lddpc	r9,800054f0 <fat_cluster_val+0x220>
8000531e:	72 09       	ld.w	r9,r9[0x0]
80005320:	4f 5a       	lddpc	r10,800054f4 <fat_cluster_val+0x224>
80005322:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
80005326:	12 0b       	add	r11,r9
80005328:	b4 0b       	st.h	r10[0x0],r11
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
8000532a:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
8000532e:	f6 09 16 01 	lsr	r9,r11,0x1
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
80005332:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
80005336:	b4 8b       	st.b	r10[0x0],r11
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
80005338:	58 05       	cp.w	r5,0
8000533a:	c2 20       	breq	8000537e <fat_cluster_val+0xae>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
8000533c:	4e fa       	lddpc	r10,800054f8 <fat_cluster_val+0x228>
8000533e:	74 0a       	ld.w	r10,r10[0x0]
80005340:	14 39       	cp.w	r9,r10
80005342:	c0 32       	brcc	80005348 <fat_cluster_val+0x78>
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
80005344:	4e da       	lddpc	r10,800054f8 <fat_cluster_val+0x228>
80005346:	95 09       	st.w	r10[0x0],r9
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
80005348:	4e da       	lddpc	r10,800054fc <fat_cluster_val+0x22c>
8000534a:	74 0a       	ld.w	r10,r10[0x0]
8000534c:	14 39       	cp.w	r9,r10
8000534e:	e0 88 00 04 	brls	80005356 <fat_cluster_val+0x86>
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
80005352:	4e ba       	lddpc	r10,800054fc <fat_cluster_val+0x22c>
80005354:	95 09       	st.w	r10[0x0],r9
      }
      if ( Is_fat12 )
80005356:	30 1a       	mov	r10,1
80005358:	f4 08 18 00 	cp.b	r8,r10
8000535c:	c1 11       	brne	8000537e <fat_cluster_val+0xae>
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
8000535e:	4e 68       	lddpc	r8,800054f4 <fat_cluster_val+0x224>
80005360:	90 0a       	ld.sh	r10,r8[0x0]
80005362:	e0 68 01 ff 	mov	r8,511
80005366:	f0 0a 19 00 	cp.h	r10,r8
8000536a:	c0 a1       	brne	8000537e <fat_cluster_val+0xae>
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
8000536c:	f2 c8 ff ff 	sub	r8,r9,-1
80005370:	4e 3a       	lddpc	r10,800054fc <fat_cluster_val+0x22c>
80005372:	74 0a       	ld.w	r10,r10[0x0]
80005374:	14 38       	cp.w	r8,r10
80005376:	e0 88 00 04 	brls	8000537e <fat_cluster_val+0xae>
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
8000537a:	4e 1a       	lddpc	r10,800054fc <fat_cluster_val+0x22c>
8000537c:	95 08       	st.w	r10[0x0],r8
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
8000537e:	4e 18       	lddpc	r8,80005500 <fat_cluster_val+0x230>
80005380:	70 48       	ld.w	r8,r8[0x10]
80005382:	10 09       	add	r9,r8
80005384:	4e 08       	lddpc	r8,80005504 <fat_cluster_val+0x234>
80005386:	91 09       	st.w	r8[0x0],r9
   if( !fat_cache_read_sector( true ))
80005388:	30 1c       	mov	r12,1
8000538a:	f0 1f 00 60 	mcall	80005508 <fat_cluster_val+0x238>
8000538e:	e0 80 00 ad 	breq	800054e8 <fat_cluster_val+0x218>
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
80005392:	4d 98       	lddpc	r8,800054f4 <fat_cluster_val+0x224>
80005394:	90 08       	ld.sh	r8,r8[0x0]
80005396:	ed d8 c0 10 	bfextu	r6,r8,0x0,0x10
8000539a:	4d d9       	lddpc	r9,8000550c <fat_cluster_val+0x23c>
8000539c:	12 06       	add	r6,r9
   u8_data1 = u8_ptr_cluster[0];
8000539e:	0c 97       	mov	r7,r6
800053a0:	0f 32       	ld.ub	r2,r7++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
800053a2:	0f 8b       	ld.ub	r11,r7[0x0]
   u8_data3 = u8_ptr_cluster[2];
800053a4:	ec c4 ff fe 	sub	r4,r6,-2
800053a8:	09 81       	ld.ub	r1,r4[0x0]
   u8_data4 = u8_ptr_cluster[3];
800053aa:	ec c3 ff fd 	sub	r3,r6,-3
800053ae:	07 80       	ld.ub	r0,r3[0x0]

   if ( Is_fat12 )
800053b0:	4c f9       	lddpc	r9,800054ec <fat_cluster_val+0x21c>
800053b2:	13 8a       	ld.ub	r10,r9[0x0]
800053b4:	30 19       	mov	r9,1
800053b6:	f2 0a 18 00 	cp.b	r10,r9
800053ba:	c1 11       	brne	800053dc <fat_cluster_val+0x10c>
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
800053bc:	e0 69 01 ff 	mov	r9,511
800053c0:	f2 08 19 00 	cp.h	r8,r9
800053c4:	c0 c1       	brne	800053dc <fat_cluster_val+0x10c>
      {  // Go to next sector
         fs_gu32_addrsector++;
800053c6:	4d 08       	lddpc	r8,80005504 <fat_cluster_val+0x234>
800053c8:	70 09       	ld.w	r9,r8[0x0]
800053ca:	2f f9       	sub	r9,-1
800053cc:	91 09       	st.w	r8[0x0],r9
         if( !fat_cache_read_sector( true ))
800053ce:	30 1c       	mov	r12,1
800053d0:	f0 1f 00 4e 	mcall	80005508 <fat_cluster_val+0x238>
800053d4:	e0 80 00 8a 	breq	800054e8 <fat_cluster_val+0x218>
           return false;
         u8_data2 = fs_g_sector[0];
800053d8:	4c d8       	lddpc	r8,8000550c <fat_cluster_val+0x23c>
800053da:	11 8b       	ld.ub	r11,r8[0x0]
      }
   }

   if (false == b_mode)
800053dc:	58 05       	cp.w	r5,0
800053de:	c3 11       	brne	80005440 <fat_cluster_val+0x170>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
800053e0:	4c 48       	lddpc	r8,800054f0 <fat_cluster_val+0x220>
800053e2:	f0 c9 ff fc 	sub	r9,r8,-4
800053e6:	f0 cc ff f9 	sub	r12,r8,-7
800053ea:	b8 82       	st.b	r12[0x0],r2
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
800053ec:	2f a8       	sub	r8,-6
800053ee:	b0 8b       	st.b	r8[0x0],r11

      if ( Is_fat32 )
800053f0:	4b fa       	lddpc	r10,800054ec <fat_cluster_val+0x21c>
800053f2:	15 8a       	ld.ub	r10,r10[0x0]
800053f4:	30 3b       	mov	r11,3
800053f6:	f6 0a 18 00 	cp.b	r10,r11
800053fa:	c0 61       	brne	80005406 <fat_cluster_val+0x136>
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
800053fc:	b2 91       	st.b	r9[0x1],r1
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
800053fe:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80005402:	b2 80       	st.b	r9[0x0],r0
80005404:	da 3a       	popm	r0-r7,pc,r12=1
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
80005406:	30 0b       	mov	r11,0
80005408:	b2 9b       	st.b	r9[0x1],r11
         LSB3( fs_g_cluster.u32_val ) = 0;
8000540a:	b2 8b       	st.b	r9[0x0],r11

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
8000540c:	30 19       	mov	r9,1
8000540e:	f2 0a 18 00 	cp.b	r10,r9
80005412:	c0 20       	breq	80005416 <fat_cluster_val+0x146>
80005414:	da 3a       	popm	r0-r7,pc,r12=1
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80005416:	4b 79       	lddpc	r9,800054f0 <fat_cluster_val+0x220>
80005418:	13 b9       	ld.ub	r9,r9[0x3]
8000541a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000541e:	c0 c0       	breq	80005436 <fat_cluster_val+0x166>
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
80005420:	19 8b       	ld.ub	r11,r12[0x0]
80005422:	a5 8b       	lsr	r11,0x4
80005424:	11 89       	ld.ub	r9,r8[0x0]
80005426:	f2 0a 15 04 	lsl	r10,r9,0x4
8000542a:	f6 0a 00 0a 	add	r10,r11,r10
8000542e:	b8 8a       	st.b	r12[0x0],r10
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
80005430:	a5 89       	lsr	r9,0x4
80005432:	b0 89       	st.b	r8[0x0],r9
80005434:	da 3a       	popm	r0-r7,pc,r12=1
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
80005436:	11 89       	ld.ub	r9,r8[0x0]
80005438:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
8000543c:	b0 89       	st.b	r8[0x0],r9
8000543e:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
80005440:	4a b8       	lddpc	r8,800054ec <fat_cluster_val+0x21c>
80005442:	11 88       	ld.ub	r8,r8[0x0]
80005444:	30 19       	mov	r9,1
80005446:	f2 08 18 00 	cp.b	r8,r9
8000544a:	c3 a1       	brne	800054be <fat_cluster_val+0x1ee>
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
8000544c:	4a 98       	lddpc	r8,800054f0 <fat_cluster_val+0x220>
8000544e:	11 b8       	ld.ub	r8,r8[0x3]
80005450:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005454:	c1 10       	breq	80005476 <fat_cluster_val+0x1a6>
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
80005456:	eb d2 c0 04 	bfextu	r5,r2,0x0,0x4
8000545a:	4a 68       	lddpc	r8,800054f0 <fat_cluster_val+0x220>
8000545c:	2f c8       	sub	r8,-4
8000545e:	11 b9       	ld.ub	r9,r8[0x3]
80005460:	f2 0a 15 04 	lsl	r10,r9,0x4
80005464:	14 05       	add	r5,r10
80005466:	5c 55       	castu.b	r5
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
80005468:	a5 89       	lsr	r9,0x4
8000546a:	11 a8       	ld.ub	r8,r8[0x2]
8000546c:	a5 68       	lsl	r8,0x4
8000546e:	f2 08 00 0a 	add	r10,r9,r8
80005472:	5c 5a       	castu.b	r10
80005474:	c0 c8       	rjmp	8000548c <fat_cluster_val+0x1bc>
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
80005476:	49 f8       	lddpc	r8,800054f0 <fat_cluster_val+0x220>
80005478:	2f c8       	sub	r8,-4
8000547a:	11 b5       	ld.ub	r5,r8[0x3]
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
8000547c:	16 9a       	mov	r10,r11
8000547e:	e2 1a 00 f0 	andl	r10,0xf0,COH
80005482:	11 a8       	ld.ub	r8,r8[0x2]
80005484:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005488:	10 0a       	add	r10,r8
8000548a:	5c 5a       	castu.b	r10
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
8000548c:	49 a8       	lddpc	r8,800054f4 <fat_cluster_val+0x224>
8000548e:	90 09       	ld.sh	r9,r8[0x0]
80005490:	e0 68 01 ff 	mov	r8,511
80005494:	f0 09 19 00 	cp.h	r9,r8
80005498:	c2 31       	brne	800054de <fat_cluster_val+0x20e>
         {
            fs_g_sector[0] = u8_data2;
8000549a:	49 d8       	lddpc	r8,8000550c <fat_cluster_val+0x23c>
8000549c:	b0 8a       	st.b	r8[0x0],r10
            fat_cache_mark_sector_as_dirty();
8000549e:	f0 1f 00 1d 	mcall	80005510 <fat_cluster_val+0x240>
            // Go to previous sector
            fs_gu32_addrsector--;
800054a2:	49 98       	lddpc	r8,80005504 <fat_cluster_val+0x234>
800054a4:	70 09       	ld.w	r9,r8[0x0]
800054a6:	20 19       	sub	r9,1
800054a8:	91 09       	st.w	r8[0x0],r9
            if( !fat_cache_read_sector( true ))
800054aa:	30 1c       	mov	r12,1
800054ac:	f0 1f 00 17 	mcall	80005508 <fat_cluster_val+0x238>
800054b0:	c1 c0       	breq	800054e8 <fat_cluster_val+0x218>
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
800054b2:	49 78       	lddpc	r8,8000550c <fat_cluster_val+0x23c>
800054b4:	f1 65 01 ff 	st.b	r8[511],r5
            fat_cache_mark_sector_as_dirty();
800054b8:	f0 1f 00 16 	mcall	80005510 <fat_cluster_val+0x240>
800054bc:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
800054be:	48 d9       	lddpc	r9,800054f0 <fat_cluster_val+0x220>
800054c0:	2f c9       	sub	r9,-4
800054c2:	13 b5       	ld.ub	r5,r9[0x3]
         u8_data2 = LSB1( fs_g_cluster.u32_val );
800054c4:	13 aa       	ld.ub	r10,r9[0x2]
         if ( Is_fat32 )
800054c6:	30 3b       	mov	r11,3
800054c8:	f6 08 18 00 	cp.b	r8,r11
800054cc:	c0 91       	brne	800054de <fat_cluster_val+0x20e>
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
800054ce:	13 98       	ld.ub	r8,r9[0x1]
800054d0:	a8 88       	st.b	r4[0x0],r8
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
800054d2:	e0 10 ff f0 	andl	r0,0xfff0
800054d6:	13 88       	ld.ub	r8,r9[0x0]
800054d8:	f0 00 00 00 	add	r0,r8,r0
800054dc:	a6 80       	st.b	r3[0x0],r0
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
800054de:	ac 85       	st.b	r6[0x0],r5
      u8_ptr_cluster[1] = u8_data2;
800054e0:	ae 8a       	st.b	r7[0x0],r10
      fat_cache_mark_sector_as_dirty();
800054e2:	f0 1f 00 0c 	mcall	80005510 <fat_cluster_val+0x240>
800054e6:	da 3a       	popm	r0-r7,pc,r12=1
800054e8:	d8 3a       	popm	r0-r7,pc,r12=0
800054ea:	00 00       	add	r0,r0
800054ec:	00 00       	add	r0,r0
800054ee:	16 18       	sub	r8,r11
800054f0:	00 00       	add	r0,r0
800054f2:	16 6c       	and	r12,r11
800054f4:	00 00       	add	r0,r0
800054f6:	13 9c       	ld.ub	r12,r9[0x1]
800054f8:	00 00       	add	r0,r0
800054fa:	16 00       	add	r0,r11
800054fc:	00 00       	add	r0,r0
800054fe:	13 c8       	ld.ub	r8,r9[0x4]
80005500:	00 00       	add	r0,r0
80005502:	15 cc       	ld.ub	r12,r10[0x4]
80005504:	00 00       	add	r0,r0
80005506:	13 88       	ld.ub	r8,r9[0x0]
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	51 bc       	stdsp	sp[0x6c],r12
8000550c:	00 00       	add	r0,r0
8000550e:	13 cc       	ld.ub	r12,r9[0x4]
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	4f 9c       	lddpc	r12,800056f4 <fat_cluster_list+0x1e0>

80005514 <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
80005514:	d4 31       	pushm	r0-r7,lr
80005516:	20 2d       	sub	sp,8
80005518:	18 93       	mov	r3,r12
8000551a:	16 97       	mov	r7,r11
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
8000551c:	30 89       	mov	r9,8
8000551e:	fe f8 02 8e 	ld.w	r8,pc[654]
80005522:	b0 89       	st.b	r8[0x0],r9

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
80005524:	30 38       	mov	r8,3
80005526:	f0 0c 18 00 	cp.b	r12,r8
8000552a:	5f 0a       	sreq	r10
8000552c:	50 0a       	stdsp	sp[0x0],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
8000552e:	fe f9 02 82 	ld.w	r9,pc[642]
80005532:	13 89       	ld.ub	r9,r9[0x0]
80005534:	f0 09 18 00 	cp.b	r9,r8
80005538:	5f 08       	sreq	r8
8000553a:	f5 e8 00 08 	and	r8,r10,r8
8000553e:	c0 60       	breq	8000554a <fat_cluster_list+0x36>
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80005540:	3f fc       	mov	r12,-1
80005542:	f0 1f 00 9d 	mcall	800057b4 <fat_cluster_list+0x2a0>
80005546:	e0 80 01 2f 	breq	800057a4 <fat_cluster_list+0x290>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
8000554a:	fe f8 02 6e 	ld.w	r8,pc[622]
8000554e:	70 08       	ld.w	r8,r8[0x0]
80005550:	58 08       	cp.w	r8,0
80005552:	c3 b1       	brne	800055c8 <fat_cluster_list+0xb4>
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
80005554:	40 09       	lddsp	r9,sp[0x0]
80005556:	58 09       	cp.w	r9,0
80005558:	e0 81 01 26 	brne	800057a4 <fat_cluster_list+0x290>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
8000555c:	fe f8 02 54 	ld.w	r8,pc[596]
80005560:	11 88       	ld.ub	r8,r8[0x0]
80005562:	f0 ca 00 01 	sub	r10,r8,1
80005566:	30 19       	mov	r9,1
80005568:	f2 0a 18 00 	cp.b	r10,r9
8000556c:	e0 8b 00 23 	brhi	800055b2 <fat_cluster_list+0x9e>
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
80005570:	fe f8 02 48 	ld.w	r8,pc[584]
80005574:	70 18       	ld.w	r8,r8[0x4]
80005576:	fe f9 02 46 	ld.w	r9,pc[582]
8000557a:	f3 19 00 1a 	ld.uh	r9,r9[26]
8000557e:	12 38       	cp.w	r8,r9
80005580:	c1 32       	brcc	800055a6 <fat_cluster_list+0x92>
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
80005582:	fe f9 02 36 	ld.w	r9,pc[566]
80005586:	fe fa 02 36 	ld.w	r10,pc[566]
8000558a:	74 4b       	ld.w	r11,r10[0x10]
8000558c:	16 08       	add	r8,r11
8000558e:	f5 1b 00 18 	ld.uh	r11,r10[24]
80005592:	16 08       	add	r8,r11
80005594:	93 08       	st.w	r9[0x0],r8
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
80005596:	f5 1a 00 1a 	ld.uh	r10,r10[26]
8000559a:	72 18       	ld.w	r8,r9[0x4]
8000559c:	f4 08 01 08 	sub	r8,r10,r8
800055a0:	93 18       	st.w	r9[0x4],r8
800055a2:	30 1c       	mov	r12,1
            return true;
800055a4:	c0 19       	rjmp	800057a6 <fat_cluster_list+0x292>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
800055a6:	31 a9       	mov	r9,26
800055a8:	fe f8 02 04 	ld.w	r8,pc[516]
800055ac:	b0 89       	st.b	r8[0x0],r9
800055ae:	30 0c       	mov	r12,0
            return false;        // Position outside the root area
800055b0:	cf b8       	rjmp	800057a6 <fat_cluster_list+0x292>
         }
      }
      if ( Is_fat32 )
800055b2:	30 39       	mov	r9,3
800055b4:	f2 08 18 00 	cp.b	r8,r9
800055b8:	c0 a1       	brne	800055cc <fat_cluster_list+0xb8>
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
800055ba:	fe f8 02 02 	ld.w	r8,pc[514]
800055be:	70 69       	ld.w	r9,r8[0x18]
800055c0:	fe f8 02 00 	ld.w	r8,pc[512]
800055c4:	91 09       	st.w	r8[0x0],r9
800055c6:	c0 38       	rjmp	800055cc <fat_cluster_list+0xb8>
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
800055c8:	4f e9       	lddpc	r9,800057c0 <fat_cluster_list+0x2ac>
800055ca:	93 08       	st.w	r9[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
800055cc:	30 38       	mov	r8,3
800055ce:	f0 03 18 00 	cp.b	r3,r8
800055d2:	c0 70       	breq	800055e0 <fat_cluster_list+0xcc>
   {
      if( fat_cache_clusterlist_update_read( b_for_file ) )
800055d4:	0e 9c       	mov	r12,r7
800055d6:	f0 1f 00 7c 	mcall	800057c4 <fat_cluster_list+0x2b0>
800055da:	c0 70       	breq	800055e8 <fat_cluster_list+0xd4>
800055dc:	30 1c       	mov	r12,1
800055de:	ce 48       	rjmp	800057a6 <fat_cluster_list+0x292>
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
800055e0:	f0 1f 00 7a 	mcall	800057c8 <fat_cluster_list+0x2b4>
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
800055e4:	f0 1f 00 7a 	mcall	800057cc <fat_cluster_list+0x2b8>
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
800055e8:	4f 40       	lddpc	r0,800057b8 <fat_cluster_list+0x2a4>
800055ea:	3f f8       	mov	r8,-1
800055ec:	a0 88       	st.b	r0[0x0],r8

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
800055ee:	00 96       	mov	r6,r0
800055f0:	4f 35       	lddpc	r5,800057bc <fat_cluster_list+0x2a8>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
800055f2:	4f 47       	lddpc	r7,800057c0 <fat_cluster_list+0x2ac>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
800055f4:	30 21       	mov	r1,2
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
800055f6:	e0 c8 ff f9 	sub	r8,r0,-7
800055fa:	50 18       	stdsp	sp[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
800055fc:	30 12       	mov	r2,1
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
800055fe:	6c 19       	ld.w	r9,r6[0x4]
80005600:	0b 98       	ld.ub	r8,r5[0x1]
80005602:	10 39       	cp.w	r9,r8
80005604:	c4 32       	brcc	8000568a <fat_cluster_list+0x176>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80005606:	6a 4a       	ld.w	r10,r5[0x10]
80005608:	14 09       	add	r9,r10
8000560a:	6a 5a       	ld.w	r10,r5[0x14]
8000560c:	14 09       	add	r9,r10
8000560e:	6e 0a       	ld.w	r10,r7[0x0]
80005610:	20 2a       	sub	r10,2
80005612:	f4 08 02 48 	mul	r8,r10,r8
80005616:	f2 08 00 08 	add	r8,r9,r8
8000561a:	8d 08       	st.w	r6[0x0],r8
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
8000561c:	e2 03 18 00 	cp.b	r3,r1
80005620:	c0 d1       	brne	8000563a <fat_cluster_list+0x126>
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
80005622:	4e 67       	lddpc	r7,800057b8 <fat_cluster_list+0x2a4>
80005624:	4e 68       	lddpc	r8,800057bc <fat_cluster_list+0x2a8>
80005626:	11 99       	ld.ub	r9,r8[0x1]
80005628:	6e 18       	ld.w	r8,r7[0x4]
8000562a:	f2 08 01 08 	sub	r8,r9,r8
8000562e:	8f 18       	st.w	r7[0x4],r8
            fat_cache_clusterlist_update_finish();
80005630:	f0 1f 00 68 	mcall	800057d0 <fat_cluster_list+0x2bc>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
80005634:	30 1c       	mov	r12,1
80005636:	8f 1c       	st.w	r7[0x4],r12
            return true;
80005638:	cb 78       	rjmp	800057a6 <fat_cluster_list+0x292>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
8000563a:	0b 99       	ld.ub	r9,r5[0x1]
8000563c:	40 1a       	lddsp	r10,sp[0x4]
8000563e:	15 88       	ld.ub	r8,r10[0x0]
80005640:	f2 08 01 08 	sub	r8,r9,r8
80005644:	8d 18       	st.w	r6[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80005646:	e4 03 18 00 	cp.b	r3,r2
8000564a:	c2 01       	brne	8000568a <fat_cluster_list+0x176>
8000564c:	4d 99       	lddpc	r9,800057b0 <fat_cluster_list+0x29c>
8000564e:	13 88       	ld.ub	r8,r9[0x0]
80005650:	e4 08 18 00 	cp.b	r8,r2
80005654:	c1 b0       	breq	8000568a <fat_cluster_list+0x176>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
80005656:	6e 04       	ld.w	r4,r7[0x0]
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80005658:	30 0c       	mov	r12,0
8000565a:	f0 1f 00 5f 	mcall	800057d4 <fat_cluster_list+0x2c0>
8000565e:	e0 80 00 a3 	breq	800057a4 <fat_cluster_list+0x290>
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
80005662:	6e 09       	ld.w	r9,r7[0x0]
80005664:	f2 c8 ff ff 	sub	r8,r9,-1
80005668:	8f 08       	st.w	r7[0x0],r8
8000566a:	6e 1a       	ld.w	r10,r7[0x4]
8000566c:	14 38       	cp.w	r8,r10
8000566e:	c0 a0       	breq	80005682 <fat_cluster_list+0x16e>
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
80005670:	8f 09       	st.w	r7[0x0],r9
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
80005672:	08 19       	sub	r9,r4
80005674:	0b 98       	ld.ub	r8,r5[0x1]
80005676:	b1 39       	mul	r9,r8
80005678:	6c 18       	ld.w	r8,r6[0x4]
8000567a:	f2 08 00 08 	add	r8,r9,r8
8000567e:	8d 18       	st.w	r6[0x4],r8
                  break;
80005680:	c0 58       	rjmp	8000568a <fat_cluster_list+0x176>
               }
               if( !fat_cluster_readnext() )
80005682:	f0 1f 00 56 	mcall	800057d8 <fat_cluster_list+0x2c4>
80005686:	ce e1       	brne	80005662 <fat_cluster_list+0x14e>
80005688:	c8 e8       	rjmp	800057a4 <fat_cluster_list+0x290>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
8000568a:	30 0c       	mov	r12,0
8000568c:	f0 1f 00 52 	mcall	800057d4 <fat_cluster_list+0x2c0>
80005690:	e0 80 00 8a 	breq	800057a4 <fat_cluster_list+0x290>
         return false;

      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
80005694:	f0 1f 00 52 	mcall	800057dc <fat_cluster_list+0x2c8>
80005698:	18 94       	mov	r4,r12
      if (FS_CLUS_BAD == u8_cluster_status)
8000569a:	e4 0c 18 00 	cp.b	r12,r2
8000569e:	e0 80 00 83 	breq	800057a4 <fat_cluster_list+0x290>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
800056a2:	01 89       	ld.ub	r9,r0[0x0]
800056a4:	3f f8       	mov	r8,-1
800056a6:	f0 09 18 00 	cp.b	r9,r8
800056aa:	c4 61       	brne	80005736 <fat_cluster_list+0x222>
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
800056ac:	e2 0c 18 00 	cp.b	r12,r1
800056b0:	c2 b1       	brne	80005706 <fat_cluster_list+0x1f2>
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining
800056b2:	4c 28       	lddpc	r8,800057b8 <fat_cluster_list+0x2a4>
800056b4:	70 17       	ld.w	r7,r8[0x4]

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
800056b6:	4c b9       	lddpc	r9,800057e0 <fat_cluster_list+0x2cc>
800056b8:	13 89       	ld.ub	r9,r9[0x0]
800056ba:	f2 09 00 29 	add	r9,r9,r9<<0x2
800056be:	4c aa       	lddpc	r10,800057e4 <fat_cluster_list+0x2d0>
800056c0:	f4 09 00 29 	add	r9,r10,r9<<0x2
800056c4:	72 2a       	ld.w	r10,r9[0x8]
800056c6:	0e 1a       	sub	r10,r7
800056c8:	93 2a       	st.w	r9[0x8],r10
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
800056ca:	4b d9       	lddpc	r9,800057bc <fat_cluster_list+0x2a8>
800056cc:	72 5b       	ld.w	r11,r9[0x14]
800056ce:	72 4a       	ld.w	r10,r9[0x10]
800056d0:	14 0b       	add	r11,r10
800056d2:	13 99       	ld.ub	r9,r9[0x1]
800056d4:	4b ba       	lddpc	r10,800057c0 <fat_cluster_list+0x2ac>
800056d6:	74 0a       	ld.w	r10,r10[0x0]
800056d8:	20 2a       	sub	r10,2
800056da:	f2 0a 02 4a 	mul	r10,r9,r10
800056de:	f6 0a 00 0a 	add	r10,r11,r10
800056e2:	91 0a       	st.w	r8[0x0],r10
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
800056e4:	91 19       	st.w	r8[0x4],r9
            if (FS_CLUST_ACT_CLR != opt_action)
800056e6:	30 38       	mov	r8,3
800056e8:	f0 03 18 00 	cp.b	r3,r8
800056ec:	c0 30       	breq	800056f2 <fat_cluster_list+0x1de>
               fat_cache_clusterlist_update_finish();
800056ee:	f0 1f 00 39 	mcall	800057d0 <fat_cluster_list+0x2bc>

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
800056f2:	4b 28       	lddpc	r8,800057b8 <fat_cluster_list+0x2a4>
800056f4:	4b 39       	lddpc	r9,800057c0 <fat_cluster_list+0x2ac>
800056f6:	72 09       	ld.w	r9,r9[0x0]
800056f8:	91 09       	st.w	r8[0x0],r9
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
800056fa:	91 17       	st.w	r8[0x4],r7
            fs_g_status = FS_ERR_OUT_LIST;
800056fc:	31 a9       	mov	r9,26
800056fe:	4a c8       	lddpc	r8,800057ac <fat_cluster_list+0x298>
80005700:	b0 89       	st.b	r8[0x0],r9
80005702:	30 0c       	mov	r12,0
            return false;
80005704:	c5 18       	rjmp	800057a6 <fat_cluster_list+0x292>
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
80005706:	0b 98       	ld.ub	r8,r5[0x1]
80005708:	6c 19       	ld.w	r9,r6[0x4]
8000570a:	f2 08 01 08 	sub	r8,r9,r8
8000570e:	8d 18       	st.w	r6[0x4],r8
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80005710:	40 0a       	lddsp	r10,sp[0x0]
80005712:	58 0a       	cp.w	r10,0
80005714:	c4 50       	breq	8000579e <fat_cluster_list+0x28a>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
80005716:	58 08       	cp.w	r8,0
80005718:	c4 31       	brne	8000579e <fat_cluster_list+0x28a>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
8000571a:	6e 18       	ld.w	r8,r7[0x4]
8000571c:	8d 08       	st.w	r6[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
8000571e:	e0 68 ff ff 	mov	r8,65535
80005722:	ea 18 0f ff 	orh	r8,0xfff
80005726:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80005728:	30 1c       	mov	r12,1
8000572a:	f0 1f 00 2b 	mcall	800057d4 <fat_cluster_list+0x2c0>
8000572e:	c3 b0       	breq	800057a4 <fat_cluster_list+0x290>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
80005730:	6c 08       	ld.w	r8,r6[0x0]
80005732:	8f 18       	st.w	r7[0x4],r8
80005734:	c3 58       	rjmp	8000579e <fat_cluster_list+0x28a>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
80005736:	e4 03 18 00 	cp.b	r3,r2
8000573a:	c0 a1       	brne	8000574e <fat_cluster_list+0x23a>
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
8000573c:	6e 09       	ld.w	r9,r7[0x0]
8000573e:	2f f9       	sub	r9,-1
80005740:	6e 18       	ld.w	r8,r7[0x4]
80005742:	10 39       	cp.w	r9,r8
80005744:	c1 b0       	breq	8000577a <fat_cluster_list+0x266>
            {
               // The cluster is not a continue cluster or a invalid cluster
               fat_cache_clusterlist_update_finish();
80005746:	f0 1f 00 23 	mcall	800057d0 <fat_cluster_list+0x2bc>
8000574a:	30 1c       	mov	r12,1
               return true;                              // End of segment
8000574c:	c2 d8       	rjmp	800057a6 <fat_cluster_list+0x292>
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
8000574e:	40 09       	lddsp	r9,sp[0x0]
80005750:	58 09       	cp.w	r9,0
80005752:	c1 40       	breq	8000577a <fat_cluster_list+0x266>
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
80005754:	6e 18       	ld.w	r8,r7[0x4]
80005756:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
80005758:	30 08       	mov	r8,0
8000575a:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
8000575c:	0b 98       	ld.ub	r8,r5[0x1]
8000575e:	6c 19       	ld.w	r9,r6[0x4]
80005760:	10 39       	cp.w	r9,r8
80005762:	c0 62       	brcc	8000576e <fat_cluster_list+0x25a>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
80005764:	e0 68 ff ff 	mov	r8,65535
80005768:	ea 18 0f ff 	orh	r8,0xfff
8000576c:	8f 18       	st.w	r7[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
8000576e:	30 1c       	mov	r12,1
80005770:	f0 1f 00 19 	mcall	800057d4 <fat_cluster_list+0x2c0>
80005774:	c1 80       	breq	800057a4 <fat_cluster_list+0x290>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
80005776:	6c 08       	ld.w	r8,r6[0x0]
80005778:	8f 18       	st.w	r7[0x4],r8
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
8000577a:	e2 04 18 00 	cp.b	r4,r1
8000577e:	c0 b1       	brne	80005794 <fat_cluster_list+0x280>
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
80005780:	40 0a       	lddsp	r10,sp[0x0]
80005782:	58 0a       	cp.w	r10,0
80005784:	c0 40       	breq	8000578c <fat_cluster_list+0x278>
            {
               return fat_update_fat2();
80005786:	f0 1f 00 19 	mcall	800057e8 <fat_cluster_list+0x2d4>
8000578a:	c0 e8       	rjmp	800057a6 <fat_cluster_list+0x292>
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
8000578c:	f0 1f 00 11 	mcall	800057d0 <fat_cluster_list+0x2bc>
80005790:	30 1c       	mov	r12,1
            return true; // End of segment
80005792:	c0 a8       	rjmp	800057a6 <fat_cluster_list+0x292>
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
80005794:	0b 99       	ld.ub	r9,r5[0x1]
80005796:	6c 18       	ld.w	r8,r6[0x4]
80005798:	f2 08 00 08 	add	r8,r9,r8
8000579c:	8d 18       	st.w	r6[0x4],r8
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
8000579e:	6e 18       	ld.w	r8,r7[0x4]
800057a0:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
800057a2:	c2 eb       	rjmp	800055fe <fat_cluster_list+0xea>
800057a4:	30 0c       	mov	r12,0
}
800057a6:	2f ed       	sub	sp,-8
800057a8:	d8 32       	popm	r0-r7,pc
800057aa:	00 00       	add	r0,r0
800057ac:	00 00       	add	r0,r0
800057ae:	16 1c       	sub	r12,r11
800057b0:	00 00       	add	r0,r0
800057b2:	16 18       	sub	r8,r11
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	5b 7c       	cp.w	r12,-9
800057b8:	00 00       	add	r0,r0
800057ba:	16 74       	tst	r4,r11
800057bc:	00 00       	add	r0,r0
800057be:	15 cc       	ld.ub	r12,r10[0x4]
800057c0:	00 00       	add	r0,r0
800057c2:	16 6c       	and	r12,r11
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	49 ec       	lddpc	r12,8000583c <fat_read_dir+0x50>
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	48 bc       	lddpc	r12,800057f4 <fat_read_dir+0x8>
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	5a f0       	cp.w	r0,-17
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	49 94       	lddpc	r4,80005834 <fat_read_dir+0x48>
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	52 d0       	stdsp	sp[0xb4],r0
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	52 3c       	stdsp	sp[0x8c],r12
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	48 5c       	lddpc	r12,800057f0 <fat_read_dir+0x4>
800057e0:	00 00       	add	r0,r0
800057e2:	16 1e       	sub	lr,r11
800057e4:	00 00       	add	r0,r0
800057e6:	13 a0       	ld.ub	r0,r9[0x2]
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	5b 08       	cp.w	r8,-16

800057ec <fat_read_dir>:
//!   fs_g_nav.u32_cluster_sel_dir           First cluster of current directory
//!   fs_g_nav_fast.u16_entry_pos_sel_file   Position in directory (unit entry)
//! @endverbatim
//!
bool  fat_read_dir( void )
{
800057ec:	eb cd 40 80 	pushm	r7,lr
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);
800057f0:	49 98       	lddpc	r8,80005854 <fat_read_dir+0x68>
800057f2:	90 97       	ld.uh	r7,r8[0x2]
800057f4:	a5 87       	lsr	r7,0x4

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
800057f6:	49 98       	lddpc	r8,80005858 <fat_read_dir+0x6c>
800057f8:	11 89       	ld.ub	r9,r8[0x0]
800057fa:	49 98       	lddpc	r8,8000585c <fat_read_dir+0x70>
800057fc:	11 88       	ld.ub	r8,r8[0x0]
800057fe:	f0 09 18 00 	cp.b	r9,r8
80005802:	c0 d1       	brne	8000581c <fat_read_dir+0x30>
80005804:	49 58       	lddpc	r8,80005858 <fat_read_dir+0x6c>
80005806:	70 39       	ld.w	r9,r8[0xc]
80005808:	49 58       	lddpc	r8,8000585c <fat_read_dir+0x70>
8000580a:	70 88       	ld.w	r8,r8[0x20]
8000580c:	10 39       	cp.w	r9,r8
8000580e:	c0 71       	brne	8000581c <fat_read_dir+0x30>
80005810:	49 28       	lddpc	r8,80005858 <fat_read_dir+0x6c>
80005812:	70 48       	ld.w	r8,r8[0x10]
80005814:	0e 38       	cp.w	r8,r7
80005816:	c0 31       	brne	8000581c <fat_read_dir+0x30>
80005818:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
         return true;      // The internal cache contains the sector asked
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
8000581c:	49 18       	lddpc	r8,80005860 <fat_read_dir+0x74>
8000581e:	49 09       	lddpc	r9,8000585c <fat_read_dir+0x70>
80005820:	72 89       	ld.w	r9,r9[0x20]
80005822:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
80005824:	91 17       	st.w	r8[0x4],r7
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
80005826:	30 0b       	mov	r11,0
80005828:	30 2c       	mov	r12,2
8000582a:	f0 1f 00 0f 	mcall	80005864 <fat_read_dir+0x78>
8000582e:	c1 00       	breq	8000584e <fat_read_dir+0x62>
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
80005830:	48 c8       	lddpc	r8,80005860 <fat_read_dir+0x74>
80005832:	70 09       	ld.w	r9,r8[0x0]
80005834:	48 d8       	lddpc	r8,80005868 <fat_read_dir+0x7c>
80005836:	91 09       	st.w	r8[0x0],r9
      if( fat_cache_read_sector( true ) )
80005838:	30 1c       	mov	r12,1
8000583a:	f0 1f 00 0d 	mcall	8000586c <fat_read_dir+0x80>
8000583e:	c0 80       	breq	8000584e <fat_read_dir+0x62>
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
80005840:	48 68       	lddpc	r8,80005858 <fat_read_dir+0x6c>
80005842:	48 79       	lddpc	r9,8000585c <fat_read_dir+0x70>
80005844:	72 89       	ld.w	r9,r9[0x20]
80005846:	91 39       	st.w	r8[0xc],r9
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
80005848:	91 47       	st.w	r8[0x10],r7
8000584a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
         return true;
8000584e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005852:	00 00       	add	r0,r0
80005854:	00 00       	add	r0,r0
80005856:	16 18       	sub	r8,r11
80005858:	00 00       	add	r0,r0
8000585a:	16 54       	eor	r4,r11
8000585c:	00 00       	add	r0,r0
8000585e:	15 cc       	ld.ub	r12,r10[0x4]
80005860:	00 00       	add	r0,r0
80005862:	16 74       	tst	r4,r11
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	55 14       	stdsp	sp[0x144],r4
80005868:	00 00       	add	r0,r0
8000586a:	13 88       	ld.ub	r8,r9[0x0]
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	51 bc       	stdsp	sp[0x6c],r12

80005870 <fat_read_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
{
80005870:	eb cd 40 c0 	pushm	r6-r7,lr
80005874:	18 97       	mov	r7,r12
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;
80005876:	4a e8       	lddpc	r8,8000592c <fat_read_file+0xbc>
80005878:	70 38       	ld.w	r8,r8[0xc]
8000587a:	f0 06 16 09 	lsr	r6,r8,0x9

   if(FS_CLUST_ACT_ONE  == mode)
8000587e:	30 29       	mov	r9,2
80005880:	f2 0c 18 00 	cp.b	r12,r9
80005884:	c1 31       	brne	800058aa <fat_read_file+0x3a>
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80005886:	4a b8       	lddpc	r8,80005930 <fat_read_file+0xc0>
80005888:	11 89       	ld.ub	r9,r8[0x0]
8000588a:	4a b8       	lddpc	r8,80005934 <fat_read_file+0xc4>
8000588c:	11 88       	ld.ub	r8,r8[0x0]
8000588e:	f0 09 18 00 	cp.b	r9,r8
80005892:	c1 91       	brne	800058c4 <fat_read_file+0x54>
80005894:	4a 78       	lddpc	r8,80005930 <fat_read_file+0xc0>
80005896:	70 39       	ld.w	r9,r8[0xc]
80005898:	4a 58       	lddpc	r8,8000592c <fat_read_file+0xbc>
8000589a:	70 18       	ld.w	r8,r8[0x4]
8000589c:	10 39       	cp.w	r9,r8
8000589e:	c1 31       	brne	800058c4 <fat_read_file+0x54>
800058a0:	4a 48       	lddpc	r8,80005930 <fat_read_file+0xc0>
800058a2:	70 48       	ld.w	r8,r8[0x10]
800058a4:	0c 38       	cp.w	r8,r6
800058a6:	c0 f1       	brne	800058c4 <fat_read_file+0x54>
800058a8:	c3 38       	rjmp	8000590e <fat_read_file+0x9e>
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
800058aa:	30 39       	mov	r9,3
800058ac:	f2 0c 18 00 	cp.b	r12,r9
800058b0:	c3 31       	brne	80005916 <fat_read_file+0xa6>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
800058b2:	49 f9       	lddpc	r9,8000592c <fat_read_file+0xbc>
800058b4:	72 19       	ld.w	r9,r9[0x4]
800058b6:	58 09       	cp.w	r9,0
800058b8:	c2 b0       	breq	8000590e <fat_read_file+0x9e>
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
800058ba:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800058be:	c2 c0       	breq	80005916 <fat_read_file+0xa6>
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
800058c0:	2f f6       	sub	r6,-1
800058c2:	c2 a8       	rjmp	80005916 <fat_read_file+0xa6>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
800058c4:	49 d8       	lddpc	r8,80005938 <fat_read_file+0xc8>
800058c6:	49 a9       	lddpc	r9,8000592c <fat_read_file+0xbc>
800058c8:	72 19       	ld.w	r9,r9[0x4]
800058ca:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
800058cc:	91 16       	st.w	r8[0x4],r6
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
800058ce:	30 1b       	mov	r11,1
800058d0:	16 9c       	mov	r12,r11
800058d2:	f0 1f 00 1b 	mcall	8000593c <fat_read_file+0xcc>
800058d6:	c1 e0       	breq	80005912 <fat_read_file+0xa2>
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
800058d8:	49 88       	lddpc	r8,80005938 <fat_read_file+0xc8>
800058da:	70 09       	ld.w	r9,r8[0x0]
800058dc:	49 98       	lddpc	r8,80005940 <fat_read_file+0xd0>
800058de:	91 09       	st.w	r8[0x0],r9
         if( fat_cache_read_sector( true ) )
800058e0:	30 1c       	mov	r12,1
800058e2:	f0 1f 00 19 	mcall	80005944 <fat_read_file+0xd4>
800058e6:	c1 60       	breq	80005912 <fat_read_file+0xa2>
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
800058e8:	49 28       	lddpc	r8,80005930 <fat_read_file+0xc0>
800058ea:	49 19       	lddpc	r9,8000592c <fat_read_file+0xbc>
800058ec:	72 19       	ld.w	r9,r9[0x4]
800058ee:	91 39       	st.w	r8[0xc],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
800058f0:	91 46       	st.w	r8[0x10],r6
800058f2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
800058f6:	30 38       	mov	r8,3
800058f8:	f0 07 18 00 	cp.b	r7,r8
800058fc:	c0 b1       	brne	80005912 <fat_read_file+0xa2>
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
800058fe:	49 38       	lddpc	r8,80005948 <fat_read_file+0xd8>
80005900:	11 89       	ld.ub	r9,r8[0x0]
80005902:	31 a8       	mov	r8,26
80005904:	f0 09 18 00 	cp.b	r9,r8
80005908:	5f 0c       	sreq	r12
8000590a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000590e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005912:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80005916:	48 98       	lddpc	r8,80005938 <fat_read_file+0xc8>
80005918:	48 59       	lddpc	r9,8000592c <fat_read_file+0xbc>
8000591a:	72 19       	ld.w	r9,r9[0x4]
8000591c:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
8000591e:	91 16       	st.w	r8[0x4],r6
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
80005920:	30 1b       	mov	r11,1
80005922:	0e 9c       	mov	r12,r7
80005924:	f0 1f 00 06 	mcall	8000593c <fat_read_file+0xcc>
80005928:	ce 70       	breq	800058f6 <fat_read_file+0x86>
8000592a:	cf 2b       	rjmp	8000590e <fat_read_file+0x9e>
8000592c:	00 00       	add	r0,r0
8000592e:	13 8c       	ld.ub	r12,r9[0x0]
80005930:	00 00       	add	r0,r0
80005932:	16 54       	eor	r4,r11
80005934:	00 00       	add	r0,r0
80005936:	15 cc       	ld.ub	r12,r10[0x4]
80005938:	00 00       	add	r0,r0
8000593a:	16 74       	tst	r4,r11
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	55 14       	stdsp	sp[0x144],r4
80005940:	00 00       	add	r0,r0
80005942:	13 88       	ld.ub	r8,r9[0x0]
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	51 bc       	stdsp	sp[0x6c],r12
80005948:	00 00       	add	r0,r0
8000594a:	16 1c       	sub	r12,r11

8000594c <fat_check_device>:
//! @verbatim
//! This function updates all navigator data when the device state change.
//! @endverbatim
//!
bool  fat_check_device( void )
{
8000594c:	d4 31       	pushm	r0-r7,lr
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
8000594e:	4a 28       	lddpc	r8,800059d4 <fat_check_device+0x88>
80005950:	11 89       	ld.ub	r9,r8[0x0]
80005952:	30 08       	mov	r8,0
80005954:	f0 09 18 00 	cp.b	r9,r8
80005958:	c3 c1       	brne	800059d0 <fat_check_device+0x84>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000595a:	4a 08       	lddpc	r8,800059d8 <fat_check_device+0x8c>
8000595c:	11 89       	ld.ub	r9,r8[0x0]
8000595e:	3f f8       	mov	r8,-1
80005960:	f0 09 18 00 	cp.b	r9,r8
80005964:	c0 51       	brne	8000596e <fat_check_device+0x22>
   {
      fs_g_status = FS_ERR_HW;
80005966:	30 19       	mov	r9,1
80005968:	49 d8       	lddpc	r8,800059dc <fat_check_device+0x90>
8000596a:	b0 89       	st.b	r8[0x0],r9
8000596c:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;                                // No device selected
8000596e:	30 02       	mov	r2,0
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80005970:	49 a5       	lddpc	r5,800059d8 <fat_check_device+0x8c>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005972:	49 c1       	lddpc	r1,800059e0 <fat_check_device+0x94>
80005974:	30 06       	mov	r6,0
      Fat_file_close();                            // By default the file is not open
80005976:	49 c0       	lddpc	r0,800059e4 <fat_check_device+0x98>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80005978:	49 c4       	lddpc	r4,800059e8 <fat_check_device+0x9c>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000597a:	49 d3       	lddpc	r3,800059ec <fat_check_device+0xa0>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000597c:	0b 8c       	ld.ub	r12,r5[0x0]
8000597e:	f0 1f 00 1d 	mcall	800059f0 <fat_check_device+0xa4>
80005982:	18 97       	mov	r7,r12
      if( CTRL_GOOD       == status )
80005984:	c2 60       	breq	800059d0 <fat_check_device+0x84>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005986:	a2 86       	st.b	r1[0x0],r6
      Fat_file_close();                            // By default the file is not open
80005988:	a0 86       	st.b	r0[0x0],r6
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000598a:	0b 88       	ld.ub	r8,r5[0x0]
8000598c:	09 89       	ld.ub	r9,r4[0x0]
8000598e:	f0 09 18 00 	cp.b	r9,r8
80005992:	c0 51       	brne	8000599c <fat_check_device+0x50>
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
80005994:	49 89       	lddpc	r9,800059f4 <fat_check_device+0xa8>
80005996:	b2 86       	st.b	r9[0x0],r6
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
80005998:	49 89       	lddpc	r9,800059f8 <fat_check_device+0xac>
8000599a:	b2 86       	st.b	r9[0x0],r6
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000599c:	07 89       	ld.ub	r9,r3[0x0]
8000599e:	f0 09 18 00 	cp.b	r9,r8
800059a2:	c0 31       	brne	800059a8 <fat_check_device+0x5c>
      {
         fat_cache_reset();
800059a4:	f0 1f 00 16 	mcall	800059fc <fat_check_device+0xb0>
      }
      fat_cache_clusterlist_reset();
800059a8:	f0 1f 00 16 	mcall	80005a00 <fat_check_device+0xb4>

      fs_g_status = FS_ERR_HW;                     // By default HW error
800059ac:	30 18       	mov	r8,1
800059ae:	48 c9       	lddpc	r9,800059dc <fat_check_device+0x90>
800059b0:	b2 88       	st.b	r9[0x0],r8
      if( CTRL_BUSY == status )
800059b2:	58 37       	cp.w	r7,3
800059b4:	c0 81       	brne	800059c4 <fat_check_device+0x78>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
800059b6:	10 02       	add	r2,r8
800059b8:	5c 52       	castu.b	r2
800059ba:	36 48       	mov	r8,100
800059bc:	f0 02 18 00 	cp.b	r2,r8
800059c0:	cd e1       	brne	8000597c <fat_check_device+0x30>
800059c2:	c0 88       	rjmp	800059d2 <fat_check_device+0x86>

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
800059c4:	58 27       	cp.w	r7,2
800059c6:	c0 61       	brne	800059d2 <fat_check_device+0x86>
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
800059c8:	31 89       	mov	r9,24
800059ca:	48 58       	lddpc	r8,800059dc <fat_check_device+0x90>
800059cc:	b0 89       	st.b	r8[0x0],r9
800059ce:	d8 3a       	popm	r0-r7,pc,r12=0
800059d0:	da 3a       	popm	r0-r7,pc,r12=1
800059d2:	d8 3a       	popm	r0-r7,pc,r12=0
800059d4:	00 00       	add	r0,r0
800059d6:	13 9e       	ld.ub	lr,r9[0x1]
800059d8:	00 00       	add	r0,r0
800059da:	15 cc       	ld.ub	r12,r10[0x4]
800059dc:	00 00       	add	r0,r0
800059de:	16 1c       	sub	r12,r11
800059e0:	00 00       	add	r0,r0
800059e2:	16 18       	sub	r8,r11
800059e4:	00 00       	add	r0,r0
800059e6:	13 8c       	ld.ub	r12,r9[0x0]
800059e8:	00 00       	add	r0,r0
800059ea:	16 20       	rsub	r0,r11
800059ec:	00 00       	add	r0,r0
800059ee:	16 54       	eor	r4,r11
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	71 40       	ld.w	r0,r8[0x50]
800059f4:	00 00       	add	r0,r0
800059f6:	16 14       	sub	r4,r11
800059f8:	00 00       	add	r0,r0
800059fa:	16 04       	add	r4,r11
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	4f 84       	lddpc	r4,80005bdc <fat_write_fat32_FSInfo+0x60>
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	48 bc       	lddpc	r12,80005a2c <fat_check_noopen+0x28>

80005a04 <fat_check_noopen>:
//!
//! @return    true  no file opened
//! @return    false otherwise
//!
bool  fat_check_noopen( void )
{
80005a04:	d4 01       	pushm	lr
   if( !fat_check_device() )
80005a06:	f0 1f 00 0b 	mcall	80005a30 <fat_check_noopen+0x2c>
80005a0a:	c1 10       	breq	80005a2c <fat_check_noopen+0x28>
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80005a0c:	48 a8       	lddpc	r8,80005a34 <fat_check_noopen+0x30>
80005a0e:	11 89       	ld.ub	r9,r8[0x0]
80005a10:	30 08       	mov	r8,0
80005a12:	f0 09 18 00 	cp.b	r9,r8
80005a16:	c0 b0       	breq	80005a2c <fat_check_noopen+0x28>
      return true;
   if( Fat_file_is_open() )
80005a18:	48 88       	lddpc	r8,80005a38 <fat_check_noopen+0x34>
80005a1a:	11 89       	ld.ub	r9,r8[0x0]
80005a1c:	30 08       	mov	r8,0
80005a1e:	f0 09 18 00 	cp.b	r9,r8
80005a22:	c0 50       	breq	80005a2c <fat_check_noopen+0x28>
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
80005a24:	30 59       	mov	r9,5
80005a26:	48 68       	lddpc	r8,80005a3c <fat_check_noopen+0x38>
80005a28:	b0 89       	st.b	r8[0x0],r9
80005a2a:	d8 0a       	popm	pc,r12=0
      return false;
80005a2c:	da 0a       	popm	pc,r12=1
80005a2e:	00 00       	add	r0,r0
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	59 4c       	cp.w	r12,20
80005a34:	00 00       	add	r0,r0
80005a36:	16 18       	sub	r8,r11
80005a38:	00 00       	add	r0,r0
80005a3a:	13 8c       	ld.ub	r12,r9[0x0]
80005a3c:	00 00       	add	r0,r0
80005a3e:	16 1c       	sub	r12,r11

80005a40 <fat_check_mount>:
//!
//! @return    true  partition mounted
//! @return    false otherwise
//!
bool  fat_check_mount( void )
{
80005a40:	d4 01       	pushm	lr
   if( !fat_check_device() )
80005a42:	f0 1f 00 0a 	mcall	80005a68 <fat_check_mount+0x28>
80005a46:	c0 f0       	breq	80005a64 <fat_check_mount+0x24>
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80005a48:	48 98       	lddpc	r8,80005a6c <fat_check_mount+0x2c>
80005a4a:	11 89       	ld.ub	r9,r8[0x0]
80005a4c:	30 08       	mov	r8,0
80005a4e:	f0 09 18 00 	cp.b	r9,r8
80005a52:	c0 81       	brne	80005a62 <fat_check_mount+0x22>
   {
      if( !fat_mount() )
80005a54:	f0 1f 00 07 	mcall	80005a70 <fat_check_mount+0x30>
80005a58:	c0 51       	brne	80005a62 <fat_check_mount+0x22>
      {
         fs_g_status = FS_ERR_NO_MOUNT;
80005a5a:	30 e9       	mov	r9,14
80005a5c:	48 68       	lddpc	r8,80005a74 <fat_check_mount+0x34>
80005a5e:	b0 89       	st.b	r8[0x0],r9
         return false;
80005a60:	d8 02       	popm	pc
80005a62:	30 1c       	mov	r12,1
      }
   }
   return true;
}
80005a64:	d8 02       	popm	pc
80005a66:	00 00       	add	r0,r0
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	59 4c       	cp.w	r12,20
80005a6c:	00 00       	add	r0,r0
80005a6e:	16 18       	sub	r8,r11
80005a70:	80 00       	ld.sh	r0,r0[0x0]
80005a72:	5c 1c       	scr	r12
80005a74:	00 00       	add	r0,r0
80005a76:	16 1c       	sub	r12,r11

80005a78 <fat_check_mount_select>:
//!
//! @return    true  partition mounted and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select( void )
{
80005a78:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80005a7a:	f0 1f 00 04 	mcall	80005a88 <fat_check_mount_select+0x10>
80005a7e:	c0 30       	breq	80005a84 <fat_check_mount_select+0xc>
      return false;
   return fat_check_select();
80005a80:	f0 1f 00 03 	mcall	80005a8c <fat_check_mount_select+0x14>
}
80005a84:	d8 02       	popm	pc
80005a86:	00 00       	add	r0,r0
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	5a 40       	cp.w	r0,-28
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	48 20       	lddpc	r0,80005a94 <fat_check_mount_select_open+0x4>

80005a90 <fat_check_mount_select_open>:
//!
//! @return    true  partition mounted and a file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_select_open( void )
{
80005a90:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80005a92:	f0 1f 00 06 	mcall	80005aa8 <fat_check_mount_select_open+0x18>
80005a96:	c0 70       	breq	80005aa4 <fat_check_mount_select_open+0x14>
      return false;
   if( !fat_check_select() )
80005a98:	f0 1f 00 05 	mcall	80005aac <fat_check_mount_select_open+0x1c>
80005a9c:	c0 40       	breq	80005aa4 <fat_check_mount_select_open+0x14>
      return false;
   return fat_check_open();
80005a9e:	f0 1f 00 05 	mcall	80005ab0 <fat_check_mount_select_open+0x20>
80005aa2:	d8 02       	popm	pc
80005aa4:	d8 0a       	popm	pc,r12=0
80005aa6:	00 00       	add	r0,r0
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	5a 40       	cp.w	r0,-28
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	48 20       	lddpc	r0,80005ab4 <fat_check_mount_select_noopen>
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	48 00       	lddpc	r0,80005ab0 <fat_check_mount_select_open+0x20>

80005ab4 <fat_check_mount_select_noopen>:
//!
//! @return    true  partition mounted and no file is opened and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select_noopen( void )
{
80005ab4:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80005ab6:	f0 1f 00 06 	mcall	80005acc <fat_check_mount_select_noopen+0x18>
80005aba:	c0 70       	breq	80005ac8 <fat_check_mount_select_noopen+0x14>
      return false;
   if( !fat_check_select() )
80005abc:	f0 1f 00 05 	mcall	80005ad0 <fat_check_mount_select_noopen+0x1c>
80005ac0:	c0 40       	breq	80005ac8 <fat_check_mount_select_noopen+0x14>
      return false;
   return fat_check_noopen();
80005ac2:	f0 1f 00 05 	mcall	80005ad4 <fat_check_mount_select_noopen+0x20>
80005ac6:	d8 02       	popm	pc
80005ac8:	d8 0a       	popm	pc,r12=0
80005aca:	00 00       	add	r0,r0
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	5a 40       	cp.w	r0,-28
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	48 20       	lddpc	r0,80005ad8 <fat_check_mount_noopen>
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	5a 04       	cp.w	r4,-32

80005ad8 <fat_check_mount_noopen>:
//!
//! @return    true  partition mounted and no file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_noopen( void )
{
80005ad8:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80005ada:	f0 1f 00 04 	mcall	80005ae8 <fat_check_mount_noopen+0x10>
80005ade:	c0 30       	breq	80005ae4 <fat_check_mount_noopen+0xc>
      return false;
   return fat_check_noopen();
80005ae0:	f0 1f 00 03 	mcall	80005aec <fat_check_mount_noopen+0x14>
}
80005ae4:	d8 02       	popm	pc
80005ae6:	00 00       	add	r0,r0
80005ae8:	80 00       	ld.sh	r0,r0[0x0]
80005aea:	5a 40       	cp.w	r0,-28
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	5a 04       	cp.w	r4,-32

80005af0 <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
80005af0:	3f f9       	mov	r9,-1
80005af2:	48 48       	lddpc	r8,80005b00 <fat_clear_info_fat_mod+0x10>
80005af4:	91 09       	st.w	r8[0x0],r9
   fs_g_u32_last_mod_fat = 0;
80005af6:	30 09       	mov	r9,0
80005af8:	48 38       	lddpc	r8,80005b04 <fat_clear_info_fat_mod+0x14>
80005afa:	91 09       	st.w	r8[0x0],r9
}
80005afc:	5e fc       	retal	r12
80005afe:	00 00       	add	r0,r0
80005b00:	00 00       	add	r0,r0
80005b02:	16 00       	add	r0,r11
80005b04:	00 00       	add	r0,r0
80005b06:	13 c8       	ld.ub	r8,r9[0x4]

80005b08 <fat_update_fat2>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
80005b08:	eb cd 40 fc 	pushm	r2-r7,lr
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80005b0c:	49 68       	lddpc	r8,80005b64 <fat_update_fat2+0x5c>
80005b0e:	70 08       	ld.w	r8,r8[0x0]
80005b10:	49 69       	lddpc	r9,80005b68 <fat_update_fat2+0x60>
80005b12:	72 09       	ld.w	r9,r9[0x0]
80005b14:	12 38       	cp.w	r8,r9
80005b16:	e0 8b 00 25 	brhi	80005b60 <fat_update_fat2+0x58>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
80005b1a:	49 55       	lddpc	r5,80005b6c <fat_update_fat2+0x64>
80005b1c:	49 57       	lddpc	r7,80005b70 <fat_update_fat2+0x68>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80005b1e:	30 13       	mov	r3,1
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80005b20:	49 16       	lddpc	r6,80005b64 <fat_update_fat2+0x5c>
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80005b22:	30 02       	mov	r2,0
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80005b24:	49 14       	lddpc	r4,80005b68 <fat_update_fat2+0x60>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
80005b26:	6e 49       	ld.w	r9,r7[0x10]
80005b28:	12 08       	add	r8,r9
80005b2a:	8b 08       	st.w	r5[0x0],r8
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80005b2c:	06 9c       	mov	r12,r3
80005b2e:	f0 1f 00 12 	mcall	80005b74 <fat_update_fat2+0x6c>
80005b32:	c1 50       	breq	80005b5c <fat_update_fat2+0x54>
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80005b34:	6e 19       	ld.w	r9,r7[0x4]
80005b36:	6e 48       	ld.w	r8,r7[0x10]
80005b38:	f2 08 00 08 	add	r8,r9,r8
80005b3c:	6c 09       	ld.w	r9,r6[0x0]
80005b3e:	12 08       	add	r8,r9
80005b40:	8b 08       	st.w	r5[0x0],r8
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80005b42:	04 9c       	mov	r12,r2
80005b44:	f0 1f 00 0c 	mcall	80005b74 <fat_update_fat2+0x6c>
80005b48:	c0 a0       	breq	80005b5c <fat_update_fat2+0x54>
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
80005b4a:	f0 1f 00 0c 	mcall	80005b78 <fat_update_fat2+0x70>
     fs_g_u32_first_mod_fat++;
80005b4e:	6c 08       	ld.w	r8,r6[0x0]
80005b50:	2f f8       	sub	r8,-1
80005b52:	8d 08       	st.w	r6[0x0],r8
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80005b54:	68 09       	ld.w	r9,r4[0x0]
80005b56:	10 39       	cp.w	r9,r8
80005b58:	ce 72       	brcc	80005b26 <fat_update_fat2+0x1e>
80005b5a:	c0 38       	rjmp	80005b60 <fat_update_fat2+0x58>
80005b5c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005b60:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80005b64:	00 00       	add	r0,r0
80005b66:	16 00       	add	r0,r11
80005b68:	00 00       	add	r0,r0
80005b6a:	13 c8       	ld.ub	r8,r9[0x4]
80005b6c:	00 00       	add	r0,r0
80005b6e:	13 88       	ld.ub	r8,r9[0x0]
80005b70:	00 00       	add	r0,r0
80005b72:	15 cc       	ld.ub	r12,r10[0x4]
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	51 bc       	stdsp	sp[0x6c],r12
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	4f 9c       	lddpc	r12,80005d5c <fat_mount+0x140>

80005b7c <fat_write_fat32_FSInfo>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
80005b7c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b80:	20 1d       	sub	sp,4
80005b82:	50 0c       	stdsp	sp[0x0],r12
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
80005b84:	49 c8       	lddpc	r8,80005bf4 <fat_write_fat32_FSInfo+0x78>
80005b86:	90 c9       	ld.uh	r9,r8[0x8]
80005b88:	70 4a       	ld.w	r10,r8[0x10]
80005b8a:	49 c8       	lddpc	r8,80005bf8 <fat_write_fat32_FSInfo+0x7c>
80005b8c:	12 1a       	sub	r10,r9
80005b8e:	91 0a       	st.w	r8[0x0],r10

   if( !fat_cache_read_sector( false ))
80005b90:	30 0c       	mov	r12,0
80005b92:	f0 1f 00 1b 	mcall	80005bfc <fat_write_fat32_FSInfo+0x80>
80005b96:	c2 c0       	breq	80005bee <fat_write_fat32_FSInfo+0x72>
      return false;
   fat_cache_mark_sector_as_dirty();
80005b98:	f0 1f 00 1a 	mcall	80005c00 <fat_write_fat32_FSInfo+0x84>
   fat_cache_clear();
80005b9c:	f0 1f 00 1a 	mcall	80005c04 <fat_write_fat32_FSInfo+0x88>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
80005ba0:	49 a7       	lddpc	r7,80005c08 <fat_write_fat32_FSInfo+0x8c>
80005ba2:	30 46       	mov	r6,4
80005ba4:	0c 9a       	mov	r10,r6
80005ba6:	49 ab       	lddpc	r11,80005c0c <fat_write_fat32_FSInfo+0x90>
80005ba8:	0e 9c       	mov	r12,r7
80005baa:	f0 1f 00 1a 	mcall	80005c10 <fat_write_fat32_FSInfo+0x94>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
80005bae:	0c 9a       	mov	r10,r6
80005bb0:	49 9b       	lddpc	r11,80005c14 <fat_write_fat32_FSInfo+0x98>
80005bb2:	ee cc fe 1c 	sub	r12,r7,-484
80005bb6:	f0 1f 00 17 	mcall	80005c10 <fat_write_fat32_FSInfo+0x94>
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
80005bba:	1b b9       	ld.ub	r9,sp[0x3]
80005bbc:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
80005bc0:	1b a9       	ld.ub	r9,sp[0x2]
80005bc2:	ef 69 01 e9 	st.b	r7[489],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
80005bc6:	1b 99       	ld.ub	r9,sp[0x1]
80005bc8:	ef 69 01 ea 	st.b	r7[490],r9
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
80005bcc:	1b 88       	ld.ub	r8,sp[0x0]
80005bce:	ef 68 01 eb 	st.b	r7[491],r8
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
80005bd2:	0c 9a       	mov	r10,r6
80005bd4:	e0 6b 00 ff 	mov	r11,255
80005bd8:	ee cc fe 14 	sub	r12,r7,-492
80005bdc:	f0 1f 00 0f 	mcall	80005c18 <fat_write_fat32_FSInfo+0x9c>
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
80005be0:	35 58       	mov	r8,85
80005be2:	ef 68 01 fe 	st.b	r7[510],r8
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
80005be6:	3a a8       	mov	r8,-86
80005be8:	ef 68 01 ff 	st.b	r7[511],r8
80005bec:	30 1c       	mov	r12,1
   return true;
}
80005bee:	2f fd       	sub	sp,-4
80005bf0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bf4:	00 00       	add	r0,r0
80005bf6:	15 cc       	ld.ub	r12,r10[0x4]
80005bf8:	00 00       	add	r0,r0
80005bfa:	13 88       	ld.ub	r8,r9[0x0]
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	51 bc       	stdsp	sp[0x6c],r12
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	4f 9c       	lddpc	r12,80005de4 <fat_mount+0x1c8>
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	51 a4       	stdsp	sp[0x68],r4
80005c08:	00 00       	add	r0,r0
80005c0a:	13 cc       	ld.ub	r12,r9[0x4]
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	b7 30       	mul	r0,r11
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	aa 30       	st.h	r5[0x6],r0
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	b7 34       	mul	r4,r11
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	ab 78       	lsl	r8,0xb

80005c1c <fat_mount>:
//! If the FS_MULTI_PARTITION option is disabled
//! then the mount routine selects the first partition supported by file system. <br>
//! @endverbatim
//!
bool  fat_mount( void )
{
80005c1c:	d4 31       	pushm	r0-r7,lr
80005c1e:	20 3d       	sub	sp,12
   uint8_t  u8_tmp;
   uint16_t u16_tmp;
   uint32_t u32_tmp;

   // Select the root directory
   fs_g_nav.u32_cluster_sel_dir   = 0;
80005c20:	30 07       	mov	r7,0
80005c22:	fe f8 02 d2 	ld.w	r8,pc[722]
80005c26:	91 87       	st.w	r8[0x20],r7
   // No selected file
   fat_clear_entry_info_and_ptr();
80005c28:	f0 1f 00 b4 	mcall	80005ef8 <fat_mount+0x2dc>

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
80005c2c:	fe f8 02 d0 	ld.w	r8,pc[720]
80005c30:	b0 87       	st.b	r8[0x0],r7
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory
80005c32:	fe f8 02 ce 	ld.w	r8,pc[718]
80005c36:	91 07       	st.w	r8[0x0],r7

   // Check if the drive is available
   if( !fat_check_device() )
80005c38:	f0 1f 00 b3 	mcall	80005f04 <fat_mount+0x2e8>
80005c3c:	e0 80 01 58 	breq	80005eec <fat_mount+0x2d0>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80005c40:	fe f5 02 c8 	ld.w	r5,pc[712]
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
80005c44:	ea c8 fe 42 	sub	r8,r5,-446
80005c48:	50 08       	stdsp	sp[0x0],r8
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005c4a:	38 04       	mov	r4,-128
80005c4c:	30 46       	mov	r6,4
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
80005c4e:	30 1c       	mov	r12,1
80005c50:	f0 1f 00 af 	mcall	80005f0c <fat_mount+0x2f0>
80005c54:	e0 80 01 4c 	breq	80005eec <fat_mount+0x2d0>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80005c58:	eb 39 01 fe 	ld.ub	r9,r5[510]
80005c5c:	35 58       	mov	r8,85
80005c5e:	f0 09 18 00 	cp.b	r9,r8
80005c62:	c0 d0       	breq	80005c7c <fat_mount+0x60>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
80005c64:	eb 39 01 ff 	ld.ub	r9,r5[511]
80005c68:	3a a8       	mov	r8,-86
80005c6a:	f0 09 18 00 	cp.b	r9,r8
80005c6e:	c0 70       	breq	80005c7c <fat_mount+0x60>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
80005c70:	30 29       	mov	r9,2
80005c72:	fe f8 02 9e 	ld.w	r8,pc[670]
80005c76:	b0 89       	st.b	r8[0x0],r9
80005c78:	30 0c       	mov	r12,0
         return false;
80005c7a:	c3 a9       	rjmp	80005eee <fat_mount+0x2d2>
      }

      if ( 0 == fs_gu32_addrsector )
80005c7c:	fe f8 02 84 	ld.w	r8,pc[644]
80005c80:	70 08       	ld.w	r8,r8[0x0]
80005c82:	58 08       	cp.w	r8,0
80005c84:	c5 21       	brne	80005d28 <fat_mount+0x10c>
80005c86:	40 08       	lddsp	r8,sp[0x0]
80005c88:	30 0a       	mov	r10,0
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005c8a:	30 1e       	mov	lr,1
80005c8c:	30 63       	mov	r3,6
80005c8e:	30 e2       	mov	r2,14
80005c90:	30 b1       	mov	r1,11
80005c92:	30 c0       	mov	r0,12
80005c94:	11 89       	ld.ub	r9,r8[0x0]
80005c96:	e8 09 18 00 	cp.b	r9,r4
80005c9a:	5f 0b       	sreq	r11
80005c9c:	ee 09 18 00 	cp.b	r9,r7
80005ca0:	5f 09       	sreq	r9
80005ca2:	f7 e9 10 09 	or	r9,r11,r9
80005ca6:	ee 09 18 00 	cp.b	r9,r7
80005caa:	c1 90       	breq	80005cdc <fat_mount+0xc0>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
80005cac:	11 c9       	ld.ub	r9,r8[0x4]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005cae:	fc 09 18 00 	cp.b	r9,lr
80005cb2:	5f 0c       	sreq	r12
80005cb4:	ec 09 18 00 	cp.b	r9,r6
80005cb8:	5f 0b       	sreq	r11
80005cba:	f9 eb 10 0b 	or	r11,r12,r11
80005cbe:	ee 0b 18 00 	cp.b	r11,r7
80005cc2:	c1 41       	brne	80005cea <fat_mount+0xce>
80005cc4:	e6 09 18 00 	cp.b	r9,r3
80005cc8:	c1 10       	breq	80005cea <fat_mount+0xce>
80005cca:	e4 09 18 00 	cp.b	r9,r2
80005cce:	c0 e0       	breq	80005cea <fat_mount+0xce>
80005cd0:	e2 09 18 00 	cp.b	r9,r1
80005cd4:	c0 b0       	breq	80005cea <fat_mount+0xce>
80005cd6:	e0 09 18 00 	cp.b	r9,r0
80005cda:	c0 80       	breq	80005cea <fat_mount+0xce>
         //** first sector then check a MBR structure
         // Search the first partition supported
#if (FS_MULTI_PARTITION == true)
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
80005cdc:	2f fa       	sub	r10,-1
80005cde:	5c 5a       	castu.b	r10
80005ce0:	2f 08       	sub	r8,-16
80005ce2:	ec 0a 18 00 	cp.b	r10,r6
80005ce6:	cd 71       	brne	80005c94 <fat_mount+0x78>
80005ce8:	c2 08       	rjmp	80005d28 <fat_mount+0x10c>
#else
               break;
#endif
            }
         }
         if( u8_tmp != 4 )
80005cea:	ec 0a 18 00 	cp.b	r10,r6
80005cee:	c1 d0       	breq	80005d28 <fat_mount+0x10c>
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
80005cf0:	fe f3 02 10 	ld.w	r3,pc[528]
80005cf4:	a5 6a       	lsl	r10,0x4
80005cf6:	f4 ca fe 42 	sub	r10,r10,-446
80005cfa:	ea 0a 00 0a 	add	r10,r5,r10
80005cfe:	f5 38 00 08 	ld.ub	r8,r10[8]
80005d02:	a6 b8       	st.b	r3[0x3],r8
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
80005d04:	f5 38 00 09 	ld.ub	r8,r10[9]
80005d08:	a6 a8       	st.b	r3[0x2],r8
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
80005d0a:	f5 38 00 0a 	ld.ub	r8,r10[10]
80005d0e:	a6 98       	st.b	r3[0x1],r8
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
80005d10:	f5 38 00 0b 	ld.ub	r8,r10[11]
80005d14:	a6 88       	st.b	r3[0x0],r8
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
80005d16:	4f 88       	lddpc	r8,80005ef4 <fat_mount+0x2d8>
80005d18:	11 8c       	ld.ub	r12,r8[0x0]
80005d1a:	f0 1f 00 7f 	mcall	80005f14 <fat_mount+0x2f8>
80005d1e:	66 08       	ld.w	r8,r3[0x0]
80005d20:	f8 08 02 48 	mul	r8,r12,r8
80005d24:	87 08       	st.w	r3[0x0],r8
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
80005d26:	c9 4b       	rjmp	80005c4e <fat_mount+0x32>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
80005d28:	4f 88       	lddpc	r8,80005f08 <fat_mount+0x2ec>
80005d2a:	11 89       	ld.ub	r9,r8[0x0]
80005d2c:	3e b8       	mov	r8,-21
80005d2e:	f0 09 18 00 	cp.b	r9,r8
80005d32:	c0 f1       	brne	80005d50 <fat_mount+0x134>
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
80005d34:	4f 58       	lddpc	r8,80005f08 <fat_mount+0x2ec>
80005d36:	11 a9       	ld.ub	r9,r8[0x2]
80005d38:	39 08       	mov	r8,-112
80005d3a:	f0 09 18 00 	cp.b	r9,r8
80005d3e:	c0 91       	brne	80005d50 <fat_mount+0x134>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
80005d40:	4f 28       	lddpc	r8,80005f08 <fat_mount+0x2ec>
80005d42:	f1 38 00 15 	ld.ub	r8,r8[21]
80005d46:	e2 18 00 f0 	andl	r8,0xf0,COH
80005d4a:	e0 48 00 f0 	cp.w	r8,240
80005d4e:	c0 60       	breq	80005d5a <fat_mount+0x13e>
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
80005d50:	30 39       	mov	r9,3
80005d52:	4f 08       	lddpc	r8,80005f10 <fat_mount+0x2f4>
80005d54:	b0 89       	st.b	r8[0x0],r9
80005d56:	30 0c       	mov	r12,0
      return false;
80005d58:	cc b8       	rjmp	80005eee <fat_mount+0x2d2>
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
80005d5a:	30 49       	mov	r9,4
80005d5c:	4e d8       	lddpc	r8,80005f10 <fat_mount+0x2f4>
80005d5e:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
80005d60:	4e aa       	lddpc	r10,80005f08 <fat_mount+0x2ec>
80005d62:	f5 39 00 0c 	ld.ub	r9,r10[12]
80005d66:	a1 99       	lsr	r9,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
80005d68:	f5 38 00 0d 	ld.ub	r8,r10[13]
80005d6c:	b3 38       	mul	r8,r9
80005d6e:	5c 58       	castu.b	r8
80005d70:	4e 1b       	lddpc	r11,80005ef4 <fat_mount+0x2d8>
80005d72:	b6 98       	st.b	r11[0x1],r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
80005d74:	30 0b       	mov	r11,0
80005d76:	50 1b       	stdsp	sp[0x4],r11
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
80005d78:	fa cb ff fc 	sub	r11,sp,-4
80005d7c:	fa c7 ff f9 	sub	r7,sp,-7
80005d80:	f5 3c 00 16 	ld.ub	r12,r10[22]
80005d84:	ae 8c       	st.b	r7[0x0],r12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
80005d86:	fa ce ff fa 	sub	lr,sp,-6
80005d8a:	f5 3a 00 17 	ld.ub	r10,r10[23]
80005d8e:	bc 8a       	st.b	lr[0x0],r10
   if ( 0==u32_tmp )
80005d90:	40 1a       	lddsp	r10,sp[0x4]
80005d92:	58 0a       	cp.w	r10,0
80005d94:	c0 e1       	brne	80005db0 <fat_mount+0x194>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
80005d96:	4d da       	lddpc	r10,80005f08 <fat_mount+0x2ec>
80005d98:	f5 3c 00 24 	ld.ub	r12,r10[36]
80005d9c:	ae 8c       	st.b	r7[0x0],r12
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
80005d9e:	f5 3c 00 25 	ld.ub	r12,r10[37]
80005da2:	bc 8c       	st.b	lr[0x0],r12
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
80005da4:	f5 3c 00 26 	ld.ub	r12,r10[38]
80005da8:	b6 9c       	st.b	r11[0x1],r12
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
80005daa:	f5 3a 00 27 	ld.ub	r10,r10[39]
80005dae:	b6 8a       	st.b	r11[0x0],r10
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
80005db0:	12 95       	mov	r5,r9
80005db2:	40 1c       	lddsp	r12,sp[0x4]
80005db4:	f2 0c 02 4c 	mul	r12,r9,r12
80005db8:	4c fa       	lddpc	r10,80005ef4 <fat_mount+0x2d8>
80005dba:	95 1c       	st.w	r10[0x4],r12

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80005dbc:	4d 3a       	lddpc	r10,80005f08 <fat_mount+0x2ec>
80005dbe:	f5 3a 00 13 	ld.ub	r10,r10[19]
80005dc2:	58 0a       	cp.w	r10,0
80005dc4:	c1 61       	brne	80005df0 <fat_mount+0x1d4>
80005dc6:	4d 16       	lddpc	r6,80005f08 <fat_mount+0x2ec>
80005dc8:	ed 34 00 14 	ld.ub	r4,r6[20]
80005dcc:	30 06       	mov	r6,0
80005dce:	ec 04 18 00 	cp.b	r4,r6
80005dd2:	c0 f1       	brne	80005df0 <fat_mount+0x1d4>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
80005dd4:	4c da       	lddpc	r10,80005f08 <fat_mount+0x2ec>
80005dd6:	f5 36 00 20 	ld.ub	r6,r10[32]
80005dda:	ae 86       	st.b	r7[0x0],r6
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
80005ddc:	f5 37 00 21 	ld.ub	r7,r10[33]
80005de0:	bc 87       	st.b	lr[0x0],r7
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
80005de2:	f5 3e 00 22 	ld.ub	lr,r10[34]
80005de6:	b6 9e       	st.b	r11[0x1],lr
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
80005de8:	f5 3a 00 23 	ld.ub	r10,r10[35]
80005dec:	b6 8a       	st.b	r11[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80005dee:	c0 98       	rjmp	80005e00 <fat_mount+0x1e4>
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
80005df0:	ae 8a       	st.b	r7[0x0],r10
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
80005df2:	4c 6a       	lddpc	r10,80005f08 <fat_mount+0x2ec>
80005df4:	f5 3a 00 14 	ld.ub	r10,r10[20]
80005df8:	bc 8a       	st.b	lr[0x0],r10
      LSB2( u32_tmp ) = 0;
80005dfa:	30 0a       	mov	r10,0
80005dfc:	b6 9a       	st.b	r11[0x1],r10
      LSB3( u32_tmp ) = 0;
80005dfe:	b6 8a       	st.b	r11[0x0],r10
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
80005e00:	40 14       	lddsp	r4,sp[0x4]

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
80005e02:	4b da       	lddpc	r10,80005ef4 <fat_mount+0x2d8>
80005e04:	f8 0b 15 01 	lsl	r11,r12,0x1
80005e08:	f5 5b 00 18 	st.h	r10[24],r11

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
80005e0c:	fa c6 ff f6 	sub	r6,sp,-10
80005e10:	fa c7 ff f4 	sub	r7,sp,-12
80005e14:	4b db       	lddpc	r11,80005f08 <fat_mount+0x2ec>
80005e16:	f7 3e 00 11 	ld.ub	lr,r11[17]
80005e1a:	0e fe       	st.b	--r7,lr
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
80005e1c:	f7 3e 00 12 	ld.ub	lr,r11[18]
80005e20:	ac 8e       	st.b	r6[0x0],lr
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
80005e22:	f2 03 15 04 	lsl	r3,r9,0x4
80005e26:	9a de       	ld.uh	lr,sp[0xa]
80005e28:	e6 0e 00 0e 	add	lr,r3,lr
80005e2c:	a5 7e       	lsl	lr,0x5
80005e2e:	20 1e       	sub	lr,1
80005e30:	f2 03 15 09 	lsl	r3,r9,0x9
80005e34:	fc 03 0c 02 	divs	r2,lr,r3
80005e38:	e4 09 02 4e 	mul	lr,r2,r9
80005e3c:	f5 5e 00 1a 	st.h	r10[26],lr

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
80005e40:	f7 33 00 0e 	ld.ub	r3,r11[14]
80005e44:	ae 83       	st.b	r7[0x0],r3
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
80005e46:	f7 37 00 0f 	ld.ub	r7,r11[15]
80005e4a:	ac 87       	st.b	r6[0x0],r7
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
80005e4c:	9a 57       	ld.sh	r7,sp[0xa]
80005e4e:	f7 3b 00 30 	ld.ub	r11,r11[48]
80005e52:	0e 96       	mov	r6,r7
80005e54:	ee 0b 01 0b 	sub	r11,r7,r11
80005e58:	b3 3b       	mul	r11,r9
80005e5a:	b4 4b       	st.h	r10[0x8],r11
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
80005e5c:	ee 09 02 49 	mul	r9,r7,r9
80005e60:	5c 79       	castu.h	r9
80005e62:	4a 8b       	lddpc	r11,80005f00 <fat_mount+0x2e4>
80005e64:	76 0b       	ld.w	r11,r11[0x0]
80005e66:	f2 0b 00 0b 	add	r11,r9,r11
80005e6a:	95 4b       	st.w	r10[0x10],r11

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
80005e6c:	5c 7e       	castu.h	lr
80005e6e:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
80005e72:	95 5c       	st.w	r10[0x14],r12
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
80005e74:	58 08       	cp.w	r8,0
80005e76:	c3 b0       	breq	80005eec <fat_mount+0x2d0>

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
80005e78:	a9 35       	mul	r5,r4
80005e7a:	ea 09 01 09 	sub	r9,r5,r9
80005e7e:	18 19       	sub	r9,r12
80005e80:	50 19       	stdsp	sp[0x4],r9

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005e82:	30 1a       	mov	r10,1
80005e84:	f4 08 18 00 	cp.b	r8,r10
80005e88:	c0 70       	breq	80005e96 <fat_mount+0x27a>
   {
     u32_tmp  >>= 1;   // This computation round down
80005e8a:	a1 99       	lsr	r9,0x1

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005e8c:	a1 98       	lsr	r8,0x1
80005e8e:	f4 08 18 00 	cp.b	r8,r10
80005e92:	cf c1       	brne	80005e8a <fat_mount+0x26e>
80005e94:	50 19       	stdsp	sp[0x4],r9
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
80005e96:	40 18       	lddsp	r8,sp[0x4]
80005e98:	f0 ca ff fe 	sub	r10,r8,-2
80005e9c:	49 69       	lddpc	r9,80005ef4 <fat_mount+0x2d8>
80005e9e:	93 3a       	st.w	r9[0xc],r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
80005ea0:	e0 48 0f f4 	cp.w	r8,4084
80005ea4:	e0 8b 00 07 	brhi	80005eb2 <fat_mount+0x296>
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
80005ea8:	30 19       	mov	r9,1
80005eaa:	49 58       	lddpc	r8,80005efc <fat_mount+0x2e0>
80005eac:	b0 89       	st.b	r8[0x0],r9
80005eae:	30 1c       	mov	r12,1
80005eb0:	c1 f8       	rjmp	80005eee <fat_mount+0x2d2>
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
80005eb2:	e0 48 ff f4 	cp.w	r8,65524
80005eb6:	e0 8b 00 07 	brhi	80005ec4 <fat_mount+0x2a8>
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
80005eba:	30 29       	mov	r9,2
80005ebc:	49 08       	lddpc	r8,80005efc <fat_mount+0x2e0>
80005ebe:	b0 89       	st.b	r8[0x0],r9
80005ec0:	30 1c       	mov	r12,1
80005ec2:	c1 68       	rjmp	80005eee <fat_mount+0x2d2>
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
80005ec4:	30 39       	mov	r9,3
80005ec6:	48 e8       	lddpc	r8,80005efc <fat_mount+0x2e0>
80005ec8:	b0 89       	st.b	r8[0x0],r9
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
80005eca:	48 b8       	lddpc	r8,80005ef4 <fat_mount+0x2d8>
80005ecc:	2e 88       	sub	r8,-24
80005ece:	48 f9       	lddpc	r9,80005f08 <fat_mount+0x2ec>
80005ed0:	f3 3a 00 2c 	ld.ub	r10,r9[44]
80005ed4:	b0 ba       	st.b	r8[0x3],r10
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
80005ed6:	f3 3a 00 2d 	ld.ub	r10,r9[45]
80005eda:	b0 aa       	st.b	r8[0x2],r10
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
80005edc:	f3 3a 00 2e 	ld.ub	r10,r9[46]
80005ee0:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
80005ee2:	f3 39 00 2f 	ld.ub	r9,r9[47]
80005ee6:	b0 89       	st.b	r8[0x0],r9
80005ee8:	30 1c       	mov	r12,1
80005eea:	c0 28       	rjmp	80005eee <fat_mount+0x2d2>
80005eec:	30 0c       	mov	r12,0
   }
   }

   return true;
}
80005eee:	2f dd       	sub	sp,-12
80005ef0:	d8 32       	popm	r0-r7,pc
80005ef2:	00 00       	add	r0,r0
80005ef4:	00 00       	add	r0,r0
80005ef6:	15 cc       	ld.ub	r12,r10[0x4]
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	4b 28       	lddpc	r8,80005fc0 <file_seek+0x84>
80005efc:	00 00       	add	r0,r0
80005efe:	16 18       	sub	r8,r11
80005f00:	00 00       	add	r0,r0
80005f02:	13 88       	ld.ub	r8,r9[0x0]
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	59 4c       	cp.w	r12,20
80005f08:	00 00       	add	r0,r0
80005f0a:	13 cc       	ld.ub	r12,r9[0x4]
80005f0c:	80 00       	ld.sh	r0,r0[0x0]
80005f0e:	51 bc       	stdsp	sp[0x6c],r12
80005f10:	00 00       	add	r0,r0
80005f12:	16 1c       	sub	r12,r11
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	71 08       	ld.w	r8,r8[0x40]

80005f18 <file_eof>:
//! @return    1     the position is at the end of file
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
80005f18:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
80005f1a:	f0 1f 00 07 	mcall	80005f34 <file_eof+0x1c>
80005f1e:	c0 41       	brne	80005f26 <file_eof+0xe>
80005f20:	e0 6c 00 ff 	mov	r12,255
80005f24:	d8 02       	popm	pc
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
80005f26:	48 58       	lddpc	r8,80005f38 <file_eof+0x20>
80005f28:	70 29       	ld.w	r9,r8[0x8]
80005f2a:	70 38       	ld.w	r8,r8[0xc]
80005f2c:	10 39       	cp.w	r9,r8
80005f2e:	5f 8c       	srls	r12
}
80005f30:	d8 02       	popm	pc
80005f32:	00 00       	add	r0,r0
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	5a 90       	cp.w	r0,-23
80005f38:	00 00       	add	r0,r0
80005f3a:	13 8c       	ld.ub	r12,r9[0x0]

80005f3c <file_seek>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_seek( uint32_t u32_pos , uint8_t u8_whence )
{
80005f3c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f40:	18 96       	mov	r6,r12
80005f42:	16 97       	mov	r7,r11
   if( !fat_check_mount_select_open())
80005f44:	f0 1f 00 28 	mcall	80005fe4 <file_seek+0xa8>
80005f48:	c4 c0       	breq	80005fe0 <file_seek+0xa4>
      return false;

   switch(u8_whence)
80005f4a:	30 18       	mov	r8,1
80005f4c:	f0 07 18 00 	cp.b	r7,r8
80005f50:	c2 90       	breq	80005fa2 <file_seek+0x66>
80005f52:	c1 a3       	brcs	80005f86 <file_seek+0x4a>
80005f54:	30 28       	mov	r8,2
80005f56:	f0 07 18 00 	cp.b	r7,r8
80005f5a:	c0 70       	breq	80005f68 <file_seek+0x2c>
80005f5c:	30 38       	mov	r8,3
80005f5e:	f0 07 18 00 	cp.b	r7,r8
80005f62:	c3 00       	breq	80005fc2 <file_seek+0x86>
80005f64:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   {
      case FS_SEEK_CUR_RE:
      if( fs_g_nav_entry.u32_pos_in_file < u32_pos )
80005f68:	4a 08       	lddpc	r8,80005fe8 <file_seek+0xac>
80005f6a:	70 38       	ld.w	r8,r8[0xc]
80005f6c:	0c 38       	cp.w	r8,r6
80005f6e:	c0 62       	brcc	80005f7a <file_seek+0x3e>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
80005f70:	30 79       	mov	r9,7
80005f72:	49 f8       	lddpc	r8,80005fec <file_seek+0xb0>
80005f74:	b0 89       	st.b	r8[0x0],r9
80005f76:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file -= u32_pos;
80005f7a:	49 c9       	lddpc	r9,80005fe8 <file_seek+0xac>
80005f7c:	f0 06 01 06 	sub	r6,r8,r6
80005f80:	93 36       	st.w	r9[0xc],r6
80005f82:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      break;

      case FS_SEEK_SET:
      if( fs_g_nav_entry.u32_size < u32_pos )
80005f86:	49 98       	lddpc	r8,80005fe8 <file_seek+0xac>
80005f88:	70 28       	ld.w	r8,r8[0x8]
80005f8a:	10 36       	cp.w	r6,r8
80005f8c:	e0 88 00 07 	brls	80005f9a <file_seek+0x5e>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
80005f90:	30 79       	mov	r9,7
80005f92:	49 78       	lddpc	r8,80005fec <file_seek+0xb0>
80005f94:	b0 89       	st.b	r8[0x0],r9
80005f96:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = u32_pos;
80005f9a:	49 48       	lddpc	r8,80005fe8 <file_seek+0xac>
80005f9c:	91 36       	st.w	r8[0xc],r6
80005f9e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      break;

      case FS_SEEK_END:
      if( fs_g_nav_entry.u32_size < u32_pos )
80005fa2:	49 28       	lddpc	r8,80005fe8 <file_seek+0xac>
80005fa4:	70 28       	ld.w	r8,r8[0x8]
80005fa6:	10 36       	cp.w	r6,r8
80005fa8:	e0 88 00 07 	brls	80005fb6 <file_seek+0x7a>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
80005fac:	30 79       	mov	r9,7
80005fae:	49 08       	lddpc	r8,80005fec <file_seek+0xb0>
80005fb0:	b0 89       	st.b	r8[0x0],r9
80005fb2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size - u32_pos;
80005fb6:	48 d9       	lddpc	r9,80005fe8 <file_seek+0xac>
80005fb8:	f0 06 01 06 	sub	r6,r8,r6
80005fbc:	93 36       	st.w	r9[0xc],r6
80005fbe:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      break;

      case FS_SEEK_CUR_FW:
      u32_pos += fs_g_nav_entry.u32_pos_in_file;
80005fc2:	48 a8       	lddpc	r8,80005fe8 <file_seek+0xac>
80005fc4:	70 39       	ld.w	r9,r8[0xc]
80005fc6:	12 06       	add	r6,r9
      if( fs_g_nav_entry.u32_size < u32_pos )
80005fc8:	70 28       	ld.w	r8,r8[0x8]
80005fca:	10 36       	cp.w	r6,r8
80005fcc:	e0 88 00 07 	brls	80005fda <file_seek+0x9e>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
80005fd0:	30 79       	mov	r9,7
80005fd2:	48 78       	lddpc	r8,80005fec <file_seek+0xb0>
80005fd4:	b0 89       	st.b	r8[0x0],r9
80005fd6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = u32_pos;
80005fda:	48 48       	lddpc	r8,80005fe8 <file_seek+0xac>
80005fdc:	91 36       	st.w	r8[0xc],r6
80005fde:	30 1c       	mov	r12,1
      break;
   }
   return true;
}
80005fe0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	5a 90       	cp.w	r0,-23
80005fe8:	00 00       	add	r0,r0
80005fea:	13 8c       	ld.ub	r12,r9[0x0]
80005fec:	00 00       	add	r0,r0
80005fee:	16 1c       	sub	r12,r11

80005ff0 <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
80005ff0:	d4 01       	pushm	lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
80005ff2:	f0 1f 00 0a 	mcall	80006018 <file_close+0x28>
80005ff6:	c1 00       	breq	80006016 <file_close+0x26>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
80005ff8:	48 98       	lddpc	r8,8000601c <file_close+0x2c>
80005ffa:	11 88       	ld.ub	r8,r8[0x0]
80005ffc:	e2 18 00 02 	andl	r8,0x2,COH
80006000:	c0 80       	breq	80006010 <file_close+0x20>
      {
         // Write file information
         if( !fat_read_dir() )
80006002:	f0 1f 00 08 	mcall	80006020 <file_close+0x30>
80006006:	c0 80       	breq	80006016 <file_close+0x26>
            return;           // error
         fat_write_entry_file();
80006008:	f0 1f 00 07 	mcall	80006024 <file_close+0x34>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
8000600c:	f0 1f 00 07 	mcall	80006028 <file_close+0x38>
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
80006010:	30 09       	mov	r9,0
80006012:	48 38       	lddpc	r8,8000601c <file_close+0x2c>
80006014:	b0 89       	st.b	r8[0x0],r9
80006016:	d8 02       	popm	pc
80006018:	80 00       	ld.sh	r0,r0[0x0]
8000601a:	5a 90       	cp.w	r0,-23
8000601c:	00 00       	add	r0,r0
8000601e:	13 8c       	ld.ub	r12,r9[0x0]
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	57 ec       	stdsp	sp[0x1f8],r12
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	4f ac       	lddpc	r12,8000620c <file_read_buf+0x174>
80006028:	80 00       	ld.sh	r0,r0[0x0]
8000602a:	51 50       	stdsp	sp[0x54],r0

8000602c <file_getc>:
//!
//! @return    The byte read
//! @return    EOF, in case of error or end of file
//!
uint16_t   file_getc( void )
{
8000602c:	d4 01       	pushm	lr
   uint16_t   u16_byte;

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
8000602e:	49 78       	lddpc	r8,80006088 <file_getc+0x5c>
80006030:	11 88       	ld.ub	r8,r8[0x0]
80006032:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006036:	c0 51       	brne	80006040 <file_getc+0x14>
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
80006038:	31 e9       	mov	r9,30
8000603a:	49 58       	lddpc	r8,8000608c <file_getc+0x60>
8000603c:	b0 89       	st.b	r8[0x0],r9
8000603e:	dc 0a       	popm	pc,r12=-1
         break;
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
80006040:	49 28       	lddpc	r8,80006088 <file_getc+0x5c>
80006042:	70 29       	ld.w	r9,r8[0x8]
80006044:	70 38       	ld.w	r8,r8[0xc]
80006046:	10 39       	cp.w	r9,r8
80006048:	e0 8b 00 06 	brhi	80006054 <file_getc+0x28>
      {
         fs_g_status = FS_ERR_EOF;
8000604c:	32 09       	mov	r9,32
8000604e:	49 08       	lddpc	r8,8000608c <file_getc+0x60>
80006050:	b0 89       	st.b	r8[0x0],r9
80006052:	dc 0a       	popm	pc,r12=-1
         break;
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
80006054:	30 2c       	mov	r12,2
80006056:	f0 1f 00 0f 	mcall	80006090 <file_getc+0x64>
8000605a:	c0 c1       	brne	80006072 <file_getc+0x46>
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
8000605c:	48 c8       	lddpc	r8,8000608c <file_getc+0x60>
8000605e:	11 89       	ld.ub	r9,r8[0x0]
80006060:	31 a8       	mov	r8,26
80006062:	f0 09 18 00 	cp.b	r9,r8
80006066:	c0 20       	breq	8000606a <file_getc+0x3e>
80006068:	dc 0a       	popm	pc,r12=-1
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
8000606a:	32 09       	mov	r9,32
8000606c:	48 88       	lddpc	r8,8000608c <file_getc+0x60>
8000606e:	b0 89       	st.b	r8[0x0],r9
80006070:	dc 0a       	popm	pc,r12=-1
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
80006072:	48 68       	lddpc	r8,80006088 <file_getc+0x5c>
80006074:	70 39       	ld.w	r9,r8[0xc]
80006076:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
8000607a:	48 7b       	lddpc	r11,80006094 <file_getc+0x68>
8000607c:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
      fs_g_nav_entry.u32_pos_in_file++;
80006080:	2f f9       	sub	r9,-1
80006082:	91 39       	st.w	r8[0xc],r9
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
80006084:	d8 02       	popm	pc
80006086:	00 00       	add	r0,r0
80006088:	00 00       	add	r0,r0
8000608a:	13 8c       	ld.ub	r12,r9[0x0]
8000608c:	00 00       	add	r0,r0
8000608e:	16 1c       	sub	r12,r11
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	58 70       	cp.w	r0,7
80006094:	00 00       	add	r0,r0
80006096:	13 cc       	ld.ub	r12,r9[0x4]

80006098 <file_read_buf>:
//!
//! @return    number of byte read
//! @return    0, in case of error
//!
uint16_t   file_read_buf( uint8_t _MEM_TYPE_SLOW_ *buffer , uint16_t u16_buf_size )
{
80006098:	d4 31       	pushm	r0-r7,lr
8000609a:	20 1d       	sub	sp,4
8000609c:	18 95       	mov	r5,r12
8000609e:	16 94       	mov	r4,r11
   _MEM_TYPE_FAST_ uint16_t u16_nb_read_tmp;
   _MEM_TYPE_FAST_ uint16_t u16_nb_read;
   _MEM_TYPE_FAST_ uint16_t u16_pos_in_sector;
   _MEM_TYPE_FAST_ uint32_t u32_byte_remaining;

   if( !fat_check_mount_select_open())
800060a0:	f0 1f 00 58 	mcall	80006200 <file_read_buf+0x168>
800060a4:	e0 80 00 a9 	breq	800061f6 <file_read_buf+0x15e>
      return false;

   if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
800060a8:	4d 78       	lddpc	r8,80006204 <file_read_buf+0x16c>
800060aa:	11 88       	ld.ub	r8,r8[0x0]
800060ac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800060b0:	c0 40       	breq	800060b8 <file_read_buf+0x20>
      return false;
   }

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
800060b2:	58 04       	cp.w	r4,0
800060b4:	c0 71       	brne	800060c2 <file_read_buf+0x2a>
800060b6:	ca 08       	rjmp	800061f6 <file_read_buf+0x15e>
   if( !fat_check_mount_select_open())
      return false;

   if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
   {
      fs_g_status = FS_ERR_WRITE_ONLY;
800060b8:	31 e9       	mov	r9,30
800060ba:	4d 48       	lddpc	r8,80006208 <file_read_buf+0x170>
800060bc:	b0 89       	st.b	r8[0x0],r9
800060be:	30 00       	mov	r0,0
      return false;
800060c0:	c9 c8       	rjmp	800061f8 <file_read_buf+0x160>
800060c2:	30 00       	mov	r0,0
      if ( file_eof() )
      {
         fs_g_status = FS_ERR_EOF;
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
800060c4:	4d 03       	lddpc	r3,80006204 <file_read_buf+0x16c>
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;

      if( (0== u16_pos_in_sector)
800060c6:	30 09       	mov	r9,0
800060c8:	ba b9       	st.b	sp[0x3],r9
            if( FS_ERR_OUT_LIST == fs_g_status )
               fs_g_status = FS_ERR_EOF;  // translate the error
            return u16_nb_read;
         }
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
800060ca:	4d 17       	lddpc	r7,8000620c <file_read_buf+0x174>

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
   {
      if ( file_eof() )
800060cc:	f0 1f 00 51 	mcall	80006210 <file_read_buf+0x178>
800060d0:	c0 50       	breq	800060da <file_read_buf+0x42>
      {
         fs_g_status = FS_ERR_EOF;
800060d2:	32 09       	mov	r9,32
800060d4:	4c d8       	lddpc	r8,80006208 <file_read_buf+0x170>
800060d6:	b0 89       	st.b	r8[0x0],r9
         return u16_nb_read;     // End of the file
800060d8:	c9 08       	rjmp	800061f8 <file_read_buf+0x160>
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
800060da:	66 31       	ld.w	r1,r3[0xc]
800060dc:	66 26       	ld.w	r6,r3[0x8]
800060de:	02 16       	sub	r6,r1
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;
800060e0:	e3 d1 c0 09 	bfextu	r1,r1,0x0,0x9

      if( (0== u16_pos_in_sector)
800060e4:	30 08       	mov	r8,0
800060e6:	f0 01 19 00 	cp.h	r1,r8
800060ea:	5f 09       	sreq	r9
800060ec:	e0 46 01 ff 	cp.w	r6,511
800060f0:	5f b8       	srhi	r8
800060f2:	f3 e8 00 08 	and	r8,r9,r8
800060f6:	1b b9       	ld.ub	r9,sp[0x3]
800060f8:	f2 08 18 00 	cp.b	r8,r9
800060fc:	c4 90       	breq	8000618e <file_read_buf+0xf6>
800060fe:	e0 68 01 ff 	mov	r8,511
80006102:	f0 04 19 00 	cp.h	r4,r8
80006106:	e0 88 00 44 	brls	8000618e <file_read_buf+0xf6>
8000610a:	f1 d5 c0 02 	bfextu	r8,r5,0x0,0x2
8000610e:	c4 01       	brne	8000618e <file_read_buf+0xf6>
      &&  (Test_align((uint32_t)buffer, sizeof(uint32_t)))
#endif
      )
      {
         // The file data sector can been directly transfer from memory to buffer (don't use internal cache)
         if( u16_buf_size <= u32_byte_remaining)
80006110:	08 98       	mov	r8,r4
80006112:	5c 78       	castu.h	r8
80006114:	10 36       	cp.w	r6,r8
80006116:	c0 43       	brcs	8000611e <file_read_buf+0x86>
80006118:	08 96       	mov	r6,r4
8000611a:	5c 86       	casts.h	r6
8000611c:	c0 28       	rjmp	80006120 <file_read_buf+0x88>
         {
            u16_nb_read_tmp = u16_buf_size;
         }else{
            u16_nb_read_tmp = u32_byte_remaining;
8000611e:	5c 86       	casts.h	r6
         }
         u16_nb_read_tmp = u16_nb_read_tmp / FS_512B;  // read a modulo sector size

         // Get following sector segment of file
         if( !fat_read_file(FS_CLUST_ACT_SEG))
80006120:	30 1c       	mov	r12,1
80006122:	f0 1f 00 3d 	mcall	80006214 <file_read_buf+0x17c>
80006126:	c0 b1       	brne	8000613c <file_read_buf+0xa4>
         {
            if( FS_ERR_OUT_LIST == fs_g_status )
80006128:	4b 88       	lddpc	r8,80006208 <file_read_buf+0x170>
8000612a:	11 89       	ld.ub	r9,r8[0x0]
8000612c:	31 a8       	mov	r8,26
8000612e:	f0 09 18 00 	cp.b	r9,r8
80006132:	c6 31       	brne	800061f8 <file_read_buf+0x160>
               fs_g_status = FS_ERR_EOF;  // translate the error
80006134:	32 09       	mov	r9,32
80006136:	4b 58       	lddpc	r8,80006208 <file_read_buf+0x170>
80006138:	b0 89       	st.b	r8[0x0],r9
8000613a:	c5 f8       	rjmp	800061f8 <file_read_buf+0x160>
         {
            u16_nb_read_tmp = u16_buf_size;
         }else{
            u16_nb_read_tmp = u32_byte_remaining;
         }
         u16_nb_read_tmp = u16_nb_read_tmp / FS_512B;  // read a modulo sector size
8000613c:	ed d6 c1 27 	bfextu	r6,r6,0x9,0x7
            if( FS_ERR_OUT_LIST == fs_g_status )
               fs_g_status = FS_ERR_EOF;  // translate the error
            return u16_nb_read;
         }
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
80006140:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
80006144:	6e 19       	ld.w	r9,r7[0x4]
80006146:	12 38       	cp.w	r8,r9
80006148:	e0 88 00 08 	brls	80006158 <file_read_buf+0xc0>
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
8000614c:	ed d9 b0 10 	bfexts	r6,r9,0x0,0x10
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
80006150:	6e 18       	ld.w	r8,r7[0x4]
80006152:	58 08       	cp.w	r8,0
80006154:	c0 41       	brne	8000615c <file_read_buf+0xc4>
80006156:	c1 88       	rjmp	80006186 <file_read_buf+0xee>
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
80006158:	8f 18       	st.w	r7[0x4],r8
8000615a:	cf bb       	rjmp	80006150 <file_read_buf+0xb8>
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
         {
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
8000615c:	0a 9a       	mov	r10,r5
8000615e:	6e 0b       	ld.w	r11,r7[0x0]
80006160:	4a e8       	lddpc	r8,80006218 <file_read_buf+0x180>
80006162:	11 8c       	ld.ub	r12,r8[0x0]
80006164:	f0 1f 00 2e 	mcall	8000621c <file_read_buf+0x184>
80006168:	c0 50       	breq	80006172 <file_read_buf+0xda>
            {
               fs_g_status = FS_ERR_HW;
8000616a:	30 19       	mov	r9,1
8000616c:	4a 78       	lddpc	r8,80006208 <file_read_buf+0x170>
8000616e:	b0 89       	st.b	r8[0x0],r9
               return u16_nb_read;
80006170:	c4 48       	rjmp	800061f8 <file_read_buf+0x160>
            }
            fs_g_seg.u32_size_or_pos--;
80006172:	6e 18       	ld.w	r8,r7[0x4]
80006174:	20 18       	sub	r8,1
80006176:	8f 18       	st.w	r7[0x4],r8
            fs_g_seg.u32_addr++;
80006178:	6e 09       	ld.w	r9,r7[0x0]
8000617a:	2f f9       	sub	r9,-1
8000617c:	8f 09       	st.w	r7[0x0],r9
            buffer += FS_512B;
8000617e:	ea c5 fe 00 	sub	r5,r5,-512
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
80006182:	58 08       	cp.w	r8,0
80006184:	ce c1       	brne	8000615c <file_read_buf+0xc4>
            fs_g_seg.u32_size_or_pos--;
            fs_g_seg.u32_addr++;
            buffer += FS_512B;
         }
         // Translate from sector unit to byte unit
         u16_nb_read_tmp *= FS_512B;
80006186:	a9 76       	lsl	r6,0x9
80006188:	e5 d6 b0 10 	bfexts	r2,r6,0x0,0x10
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;

      if( (0== u16_pos_in_sector)
8000618c:	c2 78       	rjmp	800061da <file_read_buf+0x142>
      else
      {
         // The file data can't been directly transfer from memory to buffer, the internal cache must be used

         // Transfer data from memory to internal cache
         if( !fat_read_file( FS_CLUST_ACT_ONE ))
8000618e:	30 2c       	mov	r12,2
80006190:	f0 1f 00 21 	mcall	80006214 <file_read_buf+0x17c>
80006194:	c0 b1       	brne	800061aa <file_read_buf+0x112>
         {
            if( FS_ERR_OUT_LIST == fs_g_status )
80006196:	49 d8       	lddpc	r8,80006208 <file_read_buf+0x170>
80006198:	11 89       	ld.ub	r9,r8[0x0]
8000619a:	31 a8       	mov	r8,26
8000619c:	f0 09 18 00 	cp.b	r9,r8
800061a0:	c2 c1       	brne	800061f8 <file_read_buf+0x160>
            {  // Translate the error
               fs_g_status = FS_ERR_EOF;   // End of file
800061a2:	32 09       	mov	r9,32
800061a4:	49 98       	lddpc	r8,80006208 <file_read_buf+0x170>
800061a6:	b0 89       	st.b	r8[0x0],r9
800061a8:	c2 88       	rjmp	800061f8 <file_read_buf+0x160>
            }
            return u16_nb_read;
         }

         // Compute the number of data to transfer
         u16_nb_read_tmp = FS_512B - u16_pos_in_sector;  // The number is limited at sector size
800061aa:	e0 62 02 00 	mov	r2,512
800061ae:	02 12       	sub	r2,r1
800061b0:	5c 82       	casts.h	r2
         if( u16_nb_read_tmp > u32_byte_remaining )
800061b2:	f1 d2 c0 10 	bfextu	r8,r2,0x0,0x10
800061b6:	10 36       	cp.w	r6,r8
800061b8:	c0 32       	brcc	800061be <file_read_buf+0x126>
            u16_nb_read_tmp = u32_byte_remaining;
800061ba:	e5 d6 b0 10 	bfexts	r2,r6,0x0,0x10
800061be:	e4 04 19 00 	cp.h	r4,r2
800061c2:	e8 02 17 30 	movlo	r2,r4
800061c6:	5c 82       	casts.h	r2
         if( u16_nb_read_tmp > u16_buf_size )
            u16_nb_read_tmp = u16_buf_size;

         // Transfer data from internal cache to buffer
         memcpy_ram2ram( buffer , &fs_g_sector[ u16_pos_in_sector ], u16_nb_read_tmp );
800061c8:	ed d2 c0 10 	bfextu	r6,r2,0x0,0x10
800061cc:	0c 9a       	mov	r10,r6
800061ce:	49 5b       	lddpc	r11,80006220 <file_read_buf+0x188>
800061d0:	02 0b       	add	r11,r1
800061d2:	0a 9c       	mov	r12,r5
800061d4:	f0 1f 00 14 	mcall	80006224 <file_read_buf+0x18c>
         buffer += u16_nb_read_tmp;
800061d8:	0c 05       	add	r5,r6
      }
      // Update positions
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
800061da:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
800061de:	66 38       	ld.w	r8,r3[0xc]
800061e0:	f2 08 00 08 	add	r8,r9,r8
800061e4:	87 38       	st.w	r3[0xc],r8
      u16_nb_read                      += u16_nb_read_tmp;
800061e6:	e4 00 00 00 	add	r0,r2,r0
800061ea:	5c 80       	casts.h	r0
      u16_buf_size                     -= u16_nb_read_tmp;
800061ec:	04 14       	sub	r4,r2
800061ee:	5c 84       	casts.h	r4
      return false;
   }

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
800061f0:	fe 91 ff 6e 	brne	800060cc <file_read_buf+0x34>
800061f4:	c0 28       	rjmp	800061f8 <file_read_buf+0x160>
800061f6:	30 00       	mov	r0,0
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
   }
   return u16_nb_read;  // Buffer is full
}
800061f8:	00 9c       	mov	r12,r0
800061fa:	2f fd       	sub	sp,-4
800061fc:	d8 32       	popm	r0-r7,pc
800061fe:	00 00       	add	r0,r0
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	5a 90       	cp.w	r0,-23
80006204:	00 00       	add	r0,r0
80006206:	13 8c       	ld.ub	r12,r9[0x0]
80006208:	00 00       	add	r0,r0
8000620a:	16 1c       	sub	r12,r11
8000620c:	00 00       	add	r0,r0
8000620e:	16 74       	tst	r4,r11
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	5f 18       	srne	r8
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	58 70       	cp.w	r0,7
80006218:	00 00       	add	r0,r0
8000621a:	15 cc       	ld.ub	r12,r10[0x4]
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	70 64       	ld.w	r4,r8[0x18]
80006220:	00 00       	add	r0,r0
80006222:	13 cc       	ld.ub	r12,r9[0x4]
80006224:	80 00       	ld.sh	r0,r0[0x0]
80006226:	aa 30       	st.h	r5[0x6],r0

80006228 <file_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
80006228:	eb cd 40 c0 	pushm	r6-r7,lr
8000622c:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_noopen())
8000622e:	f0 1f 00 20 	mcall	800062ac <file_open+0x84>
80006232:	c3 a0       	breq	800062a6 <file_open+0x7e>
      return false;

   if( !fat_check_is_file())
80006234:	f0 1f 00 1f 	mcall	800062b0 <file_open+0x88>
80006238:	c3 70       	breq	800062a6 <file_open+0x7e>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
8000623a:	0e 96       	mov	r6,r7
8000623c:	0e 98       	mov	r8,r7
8000623e:	e2 18 00 02 	andl	r8,0x2,COH
80006242:	c1 90       	breq	80006274 <file_open+0x4c>
   {
      if( !fat_check_nav_access_file( true ) )
80006244:	30 1c       	mov	r12,1
80006246:	f0 1f 00 1c 	mcall	800062b4 <file_open+0x8c>
8000624a:	c2 e0       	breq	800062a6 <file_open+0x7e>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
8000624c:	49 b8       	lddpc	r8,800062b8 <file_open+0x90>
8000624e:	11 a8       	ld.ub	r8,r8[0x2]
80006250:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006254:	c0 60       	breq	80006260 <file_open+0x38>
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
80006256:	31 59       	mov	r9,21
80006258:	49 98       	lddpc	r8,800062bc <file_open+0x94>
8000625a:	b0 89       	st.b	r8[0x0],r9
8000625c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
80006260:	49 88       	lddpc	r8,800062c0 <file_open+0x98>
80006262:	11 8c       	ld.ub	r12,r8[0x0]
80006264:	f0 1f 00 18 	mcall	800062c4 <file_open+0x9c>
80006268:	c0 a0       	breq	8000627c <file_open+0x54>
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
8000626a:	31 49       	mov	r9,20
8000626c:	49 48       	lddpc	r8,800062bc <file_open+0x94>
8000626e:	b0 89       	st.b	r8[0x0],r9
80006270:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
80006274:	30 0c       	mov	r12,0
80006276:	f0 1f 00 10 	mcall	800062b4 <file_open+0x8c>
8000627a:	c1 60       	breq	800062a6 <file_open+0x7e>
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
8000627c:	0c 98       	mov	r8,r6
8000627e:	e2 18 00 04 	andl	r8,0x4,COH
80006282:	c0 40       	breq	8000628a <file_open+0x62>
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
80006284:	30 09       	mov	r9,0
80006286:	48 d8       	lddpc	r8,800062b8 <file_open+0x90>
80006288:	91 29       	st.w	r8[0x8],r9
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
8000628a:	e2 16 00 08 	andl	r6,0x8,COH
8000628e:	c0 50       	breq	80006298 <file_open+0x70>
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
80006290:	30 09       	mov	r9,0
80006292:	48 a8       	lddpc	r8,800062b8 <file_open+0x90>
80006294:	91 39       	st.w	r8[0xc],r9
80006296:	c0 48       	rjmp	8000629e <file_open+0x76>
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
80006298:	48 88       	lddpc	r8,800062b8 <file_open+0x90>
8000629a:	70 29       	ld.w	r9,r8[0x8]
8000629c:	91 39       	st.w	r8[0xc],r9
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
8000629e:	48 78       	lddpc	r8,800062b8 <file_open+0x90>
800062a0:	b0 87       	st.b	r8[0x0],r7
800062a2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   return true;
800062a6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800062aa:	00 00       	add	r0,r0
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	5a b4       	cp.w	r4,-21
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	48 40       	lddpc	r0,800062c0 <file_open+0x98>
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	4f fc       	lddpc	r12,800064b0 <nav_filelist_set+0x70>
800062b8:	00 00       	add	r0,r0
800062ba:	13 8c       	ld.ub	r12,r9[0x0]
800062bc:	00 00       	add	r0,r0
800062be:	16 1c       	sub	r12,r11
800062c0:	00 00       	add	r0,r0
800062c2:	15 cc       	ld.ub	r12,r10[0x4]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	70 c4       	ld.w	r4,r8[0x30]

800062c8 <nav_checkdisk_disable>:
//! This check can reduce the speed access on specific disk.
//! @endverbatim
//!
void  nav_checkdisk_disable( void )
{
   g_b_no_check_disk = true;
800062c8:	30 19       	mov	r9,1
800062ca:	48 28       	lddpc	r8,800062d0 <nav_checkdisk_disable+0x8>
800062cc:	b0 89       	st.b	r8[0x0],r9
}
800062ce:	5e fc       	retal	r12
800062d0:	00 00       	add	r0,r0
800062d2:	13 9e       	ld.ub	lr,r9[0x1]

800062d4 <nav_checkdisk_enable>:
//! This check can reduce the speed access on specific disk.
//! @endverbatim
//!
void  nav_checkdisk_enable( void )
{
   g_b_no_check_disk = false;
800062d4:	30 09       	mov	r9,0
800062d6:	48 28       	lddpc	r8,800062dc <nav_checkdisk_enable+0x8>
800062d8:	b0 89       	st.b	r8[0x0],r9
}
800062da:	5e fc       	retal	r12
800062dc:	00 00       	add	r0,r0
800062de:	13 9e       	ld.ub	lr,r9[0x1]

800062e0 <nav_drive_get>:
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
800062e0:	48 28       	lddpc	r8,800062e8 <nav_drive_get+0x8>
800062e2:	11 8c       	ld.ub	r12,r8[0x0]
800062e4:	5e fc       	retal	r12
800062e6:	00 00       	add	r0,r0
800062e8:	00 00       	add	r0,r0
800062ea:	15 cc       	ld.ub	r12,r10[0x4]

800062ec <nav_drive_getname>:
//! @return    'A','B',...
//! @return    'X', in case of no drive selected
//!
uint8_t    nav_drive_getname( void )
{
   if(0xFF == fs_g_nav.u8_lun)
800062ec:	48 68       	lddpc	r8,80006304 <nav_drive_getname+0x18>
800062ee:	11 8c       	ld.ub	r12,r8[0x0]
800062f0:	3f f8       	mov	r8,-1
800062f2:	f0 0c 18 00 	cp.b	r12,r8
800062f6:	c0 31       	brne	800062fc <nav_drive_getname+0x10>
800062f8:	35 8c       	mov	r12,88
800062fa:	5e fc       	retal	r12
      return 'X';
#if (FS_MULTI_PARTITION  ==  true)
   return ('A' + (fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return ('A' + fs_g_nav.u8_lun);
800062fc:	2b fc       	sub	r12,-65
800062fe:	5c 5c       	castu.b	r12
#endif
}
80006300:	5e fc       	retal	r12
80006302:	00 00       	add	r0,r0
80006304:	00 00       	add	r0,r0
80006306:	15 cc       	ld.ub	r12,r10[0x4]

80006308 <nav_filelist_get>:
//! @return    FS_NO_SEL, in case of no file selected
//!
uint16_t   nav_filelist_get( void )
{
   return fs_g_nav.u16_pos_sel_file;
}
80006308:	48 28       	lddpc	r8,80006310 <nav_filelist_get+0x8>
8000630a:	f1 0c 00 24 	ld.sh	r12,r8[36]
8000630e:	5e fc       	retal	r12
80006310:	00 00       	add	r0,r0
80006312:	15 cc       	ld.ub	r12,r10[0x4]

80006314 <nav_file_checkext>:
//!
//! @return    true, the file extension match with extension filter
//! @return    false, in other case
//!
bool  nav_file_checkext( const FS_STRING sz_filterext )
{
80006314:	eb cd 40 80 	pushm	r7,lr
80006318:	18 97       	mov	r7,r12
   if ( fat_check_mount_select() )
8000631a:	f0 1f 00 07 	mcall	80006334 <nav_file_checkext+0x20>
8000631e:	c0 90       	breq	80006330 <nav_file_checkext+0x1c>
   {
      // Read selected entry (=short name entry) in directory
      if ( fat_read_dir())
80006320:	f0 1f 00 06 	mcall	80006338 <nav_file_checkext+0x24>
80006324:	c0 60       	breq	80006330 <nav_file_checkext+0x1c>
      {
         // Check the extension with filter
         if ( fat_entry_checkext( (FS_STRING) sz_filterext ) )
80006326:	0e 9c       	mov	r12,r7
80006328:	f0 1f 00 05 	mcall	8000633c <nav_file_checkext+0x28>
8000632c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006330:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	5a 78       	cp.w	r8,-25
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	57 ec       	stdsp	sp[0x1f8],r12
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	4e 88       	lddpc	r8,800064dc <nav_filelist_set+0x9c>

80006340 <nav_file_isdir>:
//!
//! @return    true, it is a directory
//! @return    false, in other case
//!
bool  nav_file_isdir( void )
{
80006340:	d4 01       	pushm	lr
   return fat_entry_is_dir();
80006342:	f0 1f 00 02 	mcall	80006348 <nav_file_isdir+0x8>
}
80006346:	d8 02       	popm	pc
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	4b 10       	lddpc	r0,8000640c <nav_file_name+0xc0>

8000634c <nav_file_name>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_file_name( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case  )
{
8000634c:	d4 31       	pushm	r0-r7,lr
8000634e:	20 1d       	sub	sp,4
80006350:	18 95       	mov	r5,r12
80006352:	16 96       	mov	r6,r11
80006354:	14 97       	mov	r7,r10
80006356:	12 93       	mov	r3,r9
   _MEM_TYPE_SLOW_   uint16_t u16_lgt;   // Only used if LENGTH string mode enabled
   uint16_t  u16_ptr_save_entry;
   bool  b_readshortname = false;

   if ( !fat_check_mount_select())
80006358:	f0 1f 00 2f 	mcall	80006414 <nav_file_name+0xc8>
8000635c:	c5 80       	breq	8000640c <nav_file_name+0xc0>
      return false;

   // Check if the string size is not 0
   if( (FS_NAME_GET == b_mode)
8000635e:	58 07       	cp.w	r7,0
80006360:	c0 50       	breq	8000636a <nav_file_name+0x1e>
80006362:	58 06       	cp.w	r6,0
80006364:	c0 31       	brne	8000636a <nav_file_name+0x1e>
80006366:	30 1c       	mov	r12,1
80006368:	c5 38       	rjmp	8000640e <nav_file_name+0xc2>
   {
      return true;
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
8000636a:	4a c8       	lddpc	r8,80006418 <nav_file_name+0xcc>
8000636c:	90 14       	ld.sh	r4,r8[0x2]
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000636e:	58 04       	cp.w	r4,0
80006370:	c0 31       	brne	80006376 <nav_file_name+0x2a>
80006372:	30 10       	mov	r0,1
80006374:	c0 68       	rjmp	80006380 <nav_file_name+0x34>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80006376:	08 99       	mov	r9,r4
80006378:	20 19       	sub	r9,1
8000637a:	4a 88       	lddpc	r8,80006418 <nav_file_name+0xcc>
8000637c:	b0 19       	st.h	r8[0x2],r9
8000637e:	30 00       	mov	r0,0
80006380:	30 09       	mov	r9,0
80006382:	50 09       	stdsp	sp[0x0],r9
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
80006384:	31 01       	mov	r1,16
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80006386:	4a 52       	lddpc	r2,80006418 <nav_file_name+0xcc>
80006388:	c0 28       	rjmp	8000638c <nav_file_name+0x40>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
8000638a:	30 10       	mov	r0,1

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
8000638c:	f0 1f 00 24 	mcall	8000641c <nav_file_name+0xd0>
80006390:	c3 e0       	breq	8000640c <nav_file_name+0xc0>
         break; // error

      if ( b_readshortname )
80006392:	58 00       	cp.w	r0,0
80006394:	c0 70       	breq	800063a2 <nav_file_name+0x56>
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
80006396:	0e 9a       	mov	r10,r7
80006398:	0c 9b       	mov	r11,r6
8000639a:	0a 9c       	mov	r12,r5
8000639c:	f0 1f 00 21 	mcall	80006420 <nav_file_name+0xd4>
800063a0:	c3 78       	rjmp	8000640e <nav_file_name+0xc2>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
800063a2:	06 99       	mov	r9,r3
800063a4:	0e 9a       	mov	r10,r7
800063a6:	0c 9b       	mov	r11,r6
800063a8:	0a 9c       	mov	r12,r5
800063aa:	f0 1f 00 1f 	mcall	80006424 <nav_file_name+0xd8>
800063ae:	c1 20       	breq	800063d2 <nav_file_name+0x86>
      {
         if( g_b_string_length )
800063b0:	49 e8       	lddpc	r8,80006428 <nav_file_name+0xdc>
800063b2:	11 89       	ld.ub	r9,r8[0x0]
800063b4:	30 08       	mov	r8,0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
800063b6:	f0 09 18 00 	cp.b	r9,r8
800063ba:	eb f8 12 00 	ld.shne	r8,r5[0x0]
800063be:	fb f9 10 00 	ld.wne	r9,sp[0x0]
800063c2:	f1 d9 e1 08 	addne	r8,r8,r9
800063c6:	eb f8 1c 00 	st.hne	r5[0x0],r8
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
800063ca:	49 48       	lddpc	r8,80006418 <nav_file_name+0xcc>
800063cc:	b0 14       	st.h	r8[0x2],r4
800063ce:	30 1c       	mov	r12,1
         return true;
800063d0:	c1 f8       	rjmp	8000640e <nav_file_name+0xc2>
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
800063d2:	49 79       	lddpc	r9,8000642c <nav_file_name+0xe0>
800063d4:	13 88       	ld.ub	r8,r9[0x0]
800063d6:	e2 08 18 00 	cp.b	r8,r1
800063da:	c0 70       	breq	800063e8 <nav_file_name+0x9c>
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
800063dc:	a4 14       	st.h	r2[0x2],r4

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
800063de:	30 b9       	mov	r9,11
800063e0:	f2 08 18 00 	cp.b	r8,r9
800063e4:	c1 41       	brne	8000640c <nav_file_name+0xc0>
800063e6:	cd 2b       	rjmp	8000638a <nav_file_name+0x3e>
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
800063e8:	49 09       	lddpc	r9,80006428 <nav_file_name+0xdc>
800063ea:	13 88       	ld.ub	r8,r9[0x0]
800063ec:	30 09       	mov	r9,0
800063ee:	f2 08 18 00 	cp.b	r8,r9
800063f2:	c0 60       	breq	800063fe <nav_file_name+0xb2>
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
800063f4:	40 08       	lddsp	r8,sp[0x0]
800063f6:	2f 38       	sub	r8,-13
800063f8:	5c 88       	casts.h	r8
800063fa:	50 08       	stdsp	sp[0x0],r8
800063fc:	c0 48       	rjmp	80006404 <nav_file_name+0xb8>
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
800063fe:	2f 35       	sub	r5,-13
         u8_size_max -= FS_SIZE_LFN_ENTRY;
80006400:	20 d6       	sub	r6,13
80006402:	5c 56       	castu.b	r6
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80006404:	84 18       	ld.sh	r8,r2[0x2]
80006406:	20 18       	sub	r8,1
80006408:	a4 18       	st.h	r2[0x2],r8
8000640a:	cc 1b       	rjmp	8000638c <nav_file_name+0x40>
8000640c:	30 0c       	mov	r12,0

   }  // end of loop while(1)
   return false;
}
8000640e:	2f fd       	sub	sp,-4
80006410:	d8 32       	popm	r0-r7,pc
80006412:	00 00       	add	r0,r0
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	5a 78       	cp.w	r8,-25
80006418:	00 00       	add	r0,r0
8000641a:	16 18       	sub	r8,r11
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	57 ec       	stdsp	sp[0x1f8],r12
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	4d 38       	lddpc	r8,8000656c <nav_filelist_set+0x12c>
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	4b a4       	lddpc	r4,8000650c <nav_filelist_set+0xcc>
80006428:	00 00       	add	r0,r0
8000642a:	16 1d       	sub	sp,r11
8000642c:	00 00       	add	r0,r0
8000642e:	16 1c       	sub	r12,r11

80006430 <nav_file_getname>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool nav_file_getname( FS_STRING sz_name, uint8_t u8_size_max )
{
80006430:	d4 01       	pushm	lr
   return nav_file_name( sz_name, u8_size_max, FS_NAME_GET, false );
80006432:	30 09       	mov	r9,0
80006434:	30 1a       	mov	r10,1
80006436:	f0 1f 00 02 	mcall	8000643c <nav_file_getname+0xc>
}
8000643a:	d8 02       	popm	pc
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	63 4c       	ld.w	r12,r1[0x50]

80006440 <nav_filelist_set>:
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
80006440:	d4 31       	pushm	r0-r7,lr
80006442:	20 4d       	sub	sp,16
80006444:	50 0c       	stdsp	sp[0x0],r12
80006446:	16 92       	mov	r2,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
80006448:	f0 1f 00 51 	mcall	8000658c <nav_filelist_set+0x14c>
8000644c:	e0 80 00 9e 	breq	80006588 <nav_filelist_set+0x148>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
80006450:	4d 08       	lddpc	r8,80006590 <nav_filelist_set+0x150>
80006452:	90 18       	ld.sh	r8,r8[0x2]
80006454:	50 28       	stdsp	sp[0x8],r8
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
80006456:	4d 08       	lddpc	r8,80006594 <nav_filelist_set+0x154>
80006458:	f1 0a 00 24 	ld.sh	r10,r8[36]
8000645c:	50 1a       	stdsp	sp[0x4],r10
   b_save_entry_type       = fs_g_nav.b_mode_nav;
8000645e:	f1 38 00 2c 	ld.ub	r8,r8[44]
80006462:	50 38       	stdsp	sp[0xc],r8
80006464:	30 03       	mov	r3,0
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
80006466:	4c b7       	lddpc	r7,80006590 <nav_filelist_set+0x150>
80006468:	3f f0       	mov	r0,-1
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000646a:	4c b6       	lddpc	r6,80006594 <nav_filelist_set+0x154>
8000646c:	30 04       	mov	r4,0
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000646e:	3f e1       	mov	r1,-2
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
80006470:	4c a5       	lddpc	r5,80006598 <nav_filelist_set+0x158>
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
80006472:	58 02       	cp.w	r2,0
80006474:	c0 31       	brne	8000647a <nav_filelist_set+0x3a>
80006476:	58 03       	cp.w	r3,0
80006478:	c0 c0       	breq	80006490 <nav_filelist_set+0x50>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000647a:	8e 18       	ld.sh	r8,r7[0x2]
8000647c:	e2 08 19 00 	cp.h	r8,r1
80006480:	c0 51       	brne	8000648a <nav_filelist_set+0x4a>
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
80006482:	30 89       	mov	r9,8
80006484:	4c 58       	lddpc	r8,80006598 <nav_filelist_set+0x158>
80006486:	b0 89       	st.b	r8[0x0],r9
            break;
80006488:	c7 38       	rjmp	8000656e <nav_filelist_set+0x12e>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
8000648a:	2f f8       	sub	r8,-1
8000648c:	ae 18       	st.h	r7[0x2],r8
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000648e:	c1 d8       	rjmp	800064c8 <nav_filelist_set+0x88>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
80006490:	8e 18       	ld.sh	r8,r7[0x2]
80006492:	e0 08 19 00 	cp.h	r8,r0
80006496:	c0 51       	brne	800064a0 <nav_filelist_set+0x60>
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
80006498:	30 99       	mov	r9,9
8000649a:	4c 08       	lddpc	r8,80006598 <nav_filelist_set+0x158>
8000649c:	b0 89       	st.b	r8[0x0],r9
            break;
8000649e:	c6 88       	rjmp	8000656e <nav_filelist_set+0x12e>
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
800064a0:	58 08       	cp.w	r8,0
800064a2:	c1 11       	brne	800064c4 <nav_filelist_set+0x84>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
800064a4:	ed 38 00 2c 	ld.ub	r8,r6[44]
800064a8:	e8 08 18 00 	cp.b	r8,r4
800064ac:	c0 80       	breq	800064bc <nav_filelist_set+0x7c>
800064ae:	ed 38 00 2d 	ld.ub	r8,r6[45]
800064b2:	e8 08 18 00 	cp.b	r8,r4
800064b6:	c0 31       	brne	800064bc <nav_filelist_set+0x7c>
800064b8:	30 13       	mov	r3,1
800064ba:	c0 78       	rjmp	800064c8 <nav_filelist_set+0x88>
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
800064bc:	30 99       	mov	r9,9
800064be:	4b 78       	lddpc	r8,80006598 <nav_filelist_set+0x158>
800064c0:	b0 89       	st.b	r8[0x0],r9
               break;
800064c2:	c5 68       	rjmp	8000656e <nav_filelist_set+0x12e>
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
800064c4:	20 18       	sub	r8,1
800064c6:	ae 18       	st.h	r7[0x2],r8
         }
      }

      if( !fat_read_dir())
800064c8:	f0 1f 00 35 	mcall	8000659c <nav_filelist_set+0x15c>
800064cc:	c0 71       	brne	800064da <nav_filelist_set+0x9a>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
800064ce:	0b 89       	ld.ub	r9,r5[0x0]
800064d0:	31 a8       	mov	r8,26
800064d2:	f0 09 18 00 	cp.b	r9,r8
800064d6:	c3 20       	breq	8000653a <nav_filelist_set+0xfa>
800064d8:	c4 b8       	rjmp	8000656e <nav_filelist_set+0x12e>
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
800064da:	ed 38 00 2c 	ld.ub	r8,r6[44]
800064de:	e8 08 18 00 	cp.b	r8,r4
800064e2:	5f 1c       	srne	r12
800064e4:	f0 1f 00 2f 	mcall	800065a0 <nav_filelist_set+0x160>
800064e8:	c1 c0       	breq	80006520 <nav_filelist_set+0xe0>
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
800064ea:	58 03       	cp.w	r3,0
800064ec:	cc 31       	brne	80006472 <nav_filelist_set+0x32>
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
800064ee:	58 02       	cp.w	r2,0
800064f0:	ed f8 12 12 	ld.shne	r8,r6[0x24]
800064f4:	f7 b8 01 ff 	subne	r8,-1
800064f8:	ed f8 1c 12 	st.hne	r6[0x24],r8
           else
              fs_g_nav.u16_pos_sel_file--;
800064fc:	ed f8 02 12 	ld.sheq	r8,r6[0x24]
80006500:	f7 b8 00 01 	subeq	r8,1
80006504:	ed f8 0c 12 	st.heq	r6[0x24],r8

           if (0 == u16_nb)
80006508:	40 09       	lddsp	r9,sp[0x0]
8000650a:	58 09       	cp.w	r9,0
8000650c:	c0 51       	brne	80006516 <nav_filelist_set+0xd6>
           {
              // It is the end of move then update file information
              fat_get_entry_info();
8000650e:	f0 1f 00 26 	mcall	800065a4 <nav_filelist_set+0x164>
80006512:	30 1c       	mov	r12,1
              return true;         // NB FILE FIND
80006514:	c3 a8       	rjmp	80006588 <nav_filelist_set+0x148>
           }
           u16_nb--;
80006516:	40 08       	lddsp	r8,sp[0x0]
80006518:	20 18       	sub	r8,1
8000651a:	5c 88       	casts.h	r8
8000651c:	50 08       	stdsp	sp[0x0],r8
           continue;
8000651e:	ca ab       	rjmp	80006472 <nav_filelist_set+0x32>
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
80006520:	0b 88       	ld.ub	r8,r5[0x0]
80006522:	30 a9       	mov	r9,10
80006524:	f2 08 18 00 	cp.b	r8,r9
80006528:	5f 09       	sreq	r9
8000652a:	31 aa       	mov	r10,26
8000652c:	f4 08 18 00 	cp.b	r8,r10
80006530:	5f 08       	sreq	r8
80006532:	10 49       	or	r9,r8
80006534:	e8 09 18 00 	cp.b	r9,r4
80006538:	c9 d0       	breq	80006472 <nav_filelist_set+0x32>
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
8000653a:	58 03       	cp.w	r3,0
8000653c:	c0 50       	breq	80006546 <nav_filelist_set+0x106>
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
8000653e:	ed 64 00 2c 	st.b	r6[44],r4
80006542:	30 03       	mov	r3,0
            continue;
80006544:	c9 7b       	rjmp	80006472 <nav_filelist_set+0x32>
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
80006546:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000654a:	30 1a       	mov	r10,1
8000654c:	f4 08 18 00 	cp.b	r8,r10
80006550:	c0 60       	breq	8000655c <nav_filelist_set+0x11c>
80006552:	ed 38 00 2d 	ld.ub	r8,r6[45]
80006556:	e8 08 18 00 	cp.b	r8,r4
8000655a:	c0 50       	breq	80006564 <nav_filelist_set+0x124>
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
8000655c:	30 99       	mov	r9,9
8000655e:	48 f8       	lddpc	r8,80006598 <nav_filelist_set+0x158>
80006560:	b0 89       	st.b	r8[0x0],r9
            break;                        // end of search
80006562:	c0 68       	rjmp	8000656e <nav_filelist_set+0x12e>
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
80006564:	ae 10       	st.h	r7[0x2],r0
            fs_g_nav.b_mode_nav = FS_FILE;
80006566:	30 19       	mov	r9,1
80006568:	ed 69 00 2c 	st.b	r6[44],r9
8000656c:	c8 3b       	rjmp	80006472 <nav_filelist_set+0x32>
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
8000656e:	48 a8       	lddpc	r8,80006594 <nav_filelist_set+0x154>
80006570:	40 3a       	lddsp	r10,sp[0xc]
80006572:	58 0a       	cp.w	r10,0
80006574:	5f 19       	srne	r9
80006576:	f1 69 00 2c 	st.b	r8[44],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
8000657a:	48 69       	lddpc	r9,80006590 <nav_filelist_set+0x150>
8000657c:	40 2a       	lddsp	r10,sp[0x8]
8000657e:	b2 1a       	st.h	r9[0x2],r10
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
80006580:	40 19       	lddsp	r9,sp[0x4]
80006582:	f1 59 00 24 	st.h	r8[36],r9
80006586:	30 0c       	mov	r12,0
   return false;
}
80006588:	2f cd       	sub	sp,-16
8000658a:	d8 32       	popm	r0-r7,pc
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	5a d8       	cp.w	r8,-19
80006590:	00 00       	add	r0,r0
80006592:	16 18       	sub	r8,r11
80006594:	00 00       	add	r0,r0
80006596:	15 cc       	ld.ub	r12,r10[0x4]
80006598:	00 00       	add	r0,r0
8000659a:	16 1c       	sub	r12,r11
8000659c:	80 00       	ld.sh	r0,r0[0x0]
8000659e:	57 ec       	stdsp	sp[0x1f8],r12
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	4f 28       	lddpc	r8,80006768 <nav_filelist_first+0x4>
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	4e 40       	lddpc	r0,80006734 <nav_dir_name+0xd4>

800065a8 <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
800065a8:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
800065aa:	f0 1f 00 04 	mcall	800065b8 <nav_filelist_reset+0x10>
800065ae:	c0 40       	breq	800065b6 <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
800065b0:	f0 1f 00 03 	mcall	800065bc <nav_filelist_reset+0x14>
800065b4:	30 1c       	mov	r12,1
   return true;
}
800065b6:	d8 02       	popm	pc
800065b8:	80 00       	ld.sh	r0,r0[0x0]
800065ba:	5a d8       	cp.w	r8,-19
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	4b 28       	lddpc	r8,80006684 <nav_dir_name+0x24>

800065c0 <nav_dir_gotoparent>:
//! After, the file list changes and contains the files and directories of the new directory.
//! By default, the file selected in file list is the previous (children) directory.
//! @endverbatim
//!
bool  nav_dir_gotoparent( void )
{
800065c0:	d4 21       	pushm	r4-r7,lr
   uint32_t u32_cluster_old_dir;

   if (!fat_check_mount_noopen())
800065c2:	f0 1f 00 1f 	mcall	8000663c <nav_dir_gotoparent+0x7c>
800065c6:	c3 80       	breq	80006636 <nav_dir_gotoparent+0x76>
      return false;

   if (0 == fs_g_nav.u32_cluster_sel_dir)
800065c8:	49 e8       	lddpc	r8,80006640 <nav_dir_gotoparent+0x80>
800065ca:	70 88       	ld.w	r8,r8[0x20]
800065cc:	58 08       	cp.w	r8,0
800065ce:	c0 51       	brne	800065d8 <nav_dir_gotoparent+0x18>
   {
      fs_g_status = FS_ERR_IS_ROOT;        // There aren't parent
800065d0:	31 99       	mov	r9,25
800065d2:	49 d8       	lddpc	r8,80006644 <nav_dir_gotoparent+0x84>
800065d4:	b0 89       	st.b	r8[0x0],r9
800065d6:	d8 2a       	popm	r4-r7,pc,r12=0
      return false;
   }

   // Select and read information about directory ".."
   fs_g_nav_fast.u16_entry_pos_sel_file = 1;
800065d8:	30 19       	mov	r9,1
800065da:	49 c8       	lddpc	r8,80006648 <nav_dir_gotoparent+0x88>
800065dc:	b0 19       	st.h	r8[0x2],r9
   if ( !fat_read_dir())
800065de:	f0 1f 00 1c 	mcall	8000664c <nav_dir_gotoparent+0x8c>
800065e2:	c2 a0       	breq	80006636 <nav_dir_gotoparent+0x76>
      return false;
   fat_get_entry_info();
800065e4:	f0 1f 00 1b 	mcall	80006650 <nav_dir_gotoparent+0x90>
   // Save the children directory cluster
   u32_cluster_old_dir = fs_g_nav.u32_cluster_sel_dir;
800065e8:	49 68       	lddpc	r8,80006640 <nav_dir_gotoparent+0x80>
800065ea:	70 87       	ld.w	r7,r8[0x20]

   // Select the parent directory via information present in the current directory ".."
   fs_g_nav.u32_cluster_sel_dir = fs_g_nav_entry.u32_cluster;
800065ec:	49 a9       	lddpc	r9,80006654 <nav_dir_gotoparent+0x94>
800065ee:	72 19       	ld.w	r9,r9[0x4]
800065f0:	91 89       	st.w	r8[0x20],r9

   // Select the children directory in new directory (=parent directory)
   if( false == nav_filelist_reset())
800065f2:	f0 1f 00 1a 	mcall	80006658 <nav_dir_gotoparent+0x98>
800065f6:	c2 00       	breq	80006636 <nav_dir_gotoparent+0x76>
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
800065f8:	49 28       	lddpc	r8,80006640 <nav_dir_gotoparent+0x80>
800065fa:	f1 39 00 2d 	ld.ub	r9,r8[45]
800065fe:	30 08       	mov	r8,0
80006600:	f0 09 18 00 	cp.b	r9,r8
80006604:	c0 d0       	breq	8000661e <nav_dir_gotoparent+0x5e>
80006606:	48 f8       	lddpc	r8,80006640 <nav_dir_gotoparent+0x80>
80006608:	f1 39 00 2c 	ld.ub	r9,r8[44]
8000660c:	30 08       	mov	r8,0
8000660e:	f0 09 18 00 	cp.b	r9,r8
80006612:	c0 60       	breq	8000661e <nav_dir_gotoparent+0x5e>
80006614:	c1 28       	rjmp	80006638 <nav_dir_gotoparent+0x78>
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
80006616:	6c 18       	ld.w	r8,r6[0x4]
80006618:	0e 38       	cp.w	r8,r7
8000661a:	c0 51       	brne	80006624 <nav_dir_gotoparent+0x64>
8000661c:	c0 e8       	rjmp	80006638 <nav_dir_gotoparent+0x78>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000661e:	30 15       	mov	r5,1
80006620:	30 04       	mov	r4,0
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
80006622:	48 d6       	lddpc	r6,80006654 <nav_dir_gotoparent+0x94>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80006624:	0a 9b       	mov	r11,r5
80006626:	08 9c       	mov	r12,r4
80006628:	f0 1f 00 0d 	mcall	8000665c <nav_dir_gotoparent+0x9c>
8000662c:	cf 51       	brne	80006616 <nav_dir_gotoparent+0x56>
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
         return true;         // It is the children directory
   }
   fs_g_status = FS_ERR_FS;
8000662e:	30 89       	mov	r9,8
80006630:	48 58       	lddpc	r8,80006644 <nav_dir_gotoparent+0x84>
80006632:	b0 89       	st.b	r8[0x0],r9
   return false;
80006634:	d8 22       	popm	r4-r7,pc
80006636:	d8 2a       	popm	r4-r7,pc,r12=0
80006638:	da 2a       	popm	r4-r7,pc,r12=1
8000663a:	00 00       	add	r0,r0
8000663c:	80 00       	ld.sh	r0,r0[0x0]
8000663e:	5a d8       	cp.w	r8,-19
80006640:	00 00       	add	r0,r0
80006642:	15 cc       	ld.ub	r12,r10[0x4]
80006644:	00 00       	add	r0,r0
80006646:	16 1c       	sub	r12,r11
80006648:	00 00       	add	r0,r0
8000664a:	16 18       	sub	r8,r11
8000664c:	80 00       	ld.sh	r0,r0[0x0]
8000664e:	57 ec       	stdsp	sp[0x1f8],r12
80006650:	80 00       	ld.sh	r0,r0[0x0]
80006652:	4e 40       	lddpc	r0,800067e0 <nav_filelist_nb+0x3c>
80006654:	00 00       	add	r0,r0
80006656:	13 8c       	ld.ub	r12,r9[0x0]
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	65 a8       	ld.w	r8,r2[0x68]
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	64 40       	ld.w	r0,r2[0x10]

80006660 <nav_dir_name>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_dir_name( FS_STRING sz_path  , uint8_t u8_size_max  )
{
80006660:	d4 31       	pushm	r0-r7,lr
80006662:	20 2d       	sub	sp,8
80006664:	18 96       	mov	r6,r12
80006666:	16 95       	mov	r5,r11
   uint32_t save_u32_cluster      ;
   uint32_t save_u32_size         ;
   bool b_mode_nav_single_save;
   bool b_mode_nav_mode_save;

   if ( !fat_check_mount_noopen())
80006668:	f0 1f 00 37 	mcall	80006744 <nav_dir_name+0xe4>
8000666c:	c6 a0       	breq	80006740 <nav_dir_name+0xe0>
      return false;

   if (0 != fs_g_nav.u32_cluster_sel_dir)
8000666e:	4b 78       	lddpc	r8,80006748 <nav_dir_name+0xe8>
80006670:	70 87       	ld.w	r7,r8[0x20]
80006672:	58 07       	cp.w	r7,0
80006674:	c3 b0       	breq	800066ea <nav_dir_name+0x8a>
   {
      // Save context
      save_u16_entry_pos_sel_file= fs_g_nav_fast.u16_entry_pos_sel_file;
80006676:	4b 68       	lddpc	r8,8000674c <nav_dir_name+0xec>
80006678:	90 11       	ld.sh	r1,r8[0x2]
      save_u32_cluster_sel_dir   = fs_g_nav.u32_cluster_sel_dir        ;
      save_u8_attr               = fs_g_nav_entry.u8_attr              ;
8000667a:	4b 68       	lddpc	r8,80006750 <nav_dir_name+0xf0>
8000667c:	11 a0       	ld.ub	r0,r8[0x2]
      save_u32_cluster           = fs_g_nav_entry.u32_cluster          ;
8000667e:	70 19       	ld.w	r9,r8[0x4]
80006680:	50 19       	stdsp	sp[0x4],r9
      save_u32_size              = fs_g_nav_entry.u32_size             ;
80006682:	70 28       	ld.w	r8,r8[0x8]
80006684:	50 08       	stdsp	sp[0x0],r8
      b_mode_nav_single_save = fs_g_nav.b_mode_nav_single;
80006686:	4b 18       	lddpc	r8,80006748 <nav_dir_name+0xe8>
80006688:	f1 3a 00 2d 	ld.ub	r10,r8[45]
8000668c:	30 09       	mov	r9,0
8000668e:	f2 0a 18 00 	cp.b	r10,r9
80006692:	5f 14       	srne	r4
      b_mode_nav_mode_save   = fs_g_nav.b_mode_nav;
80006694:	f1 3a 00 2c 	ld.ub	r10,r8[44]
80006698:	f2 0a 18 00 	cp.b	r10,r9
8000669c:	5f 13       	srne	r3
      fs_g_nav.b_mode_nav_single = true;
8000669e:	30 19       	mov	r9,1
800066a0:	f1 69 00 2d 	st.b	r8[45],r9
      fs_g_nav.b_mode_nav = FS_FILE;
800066a4:	f1 69 00 2c 	st.b	r8[44],r9
      // Go to parent directory and select the children directory
      if( !nav_dir_gotoparent() )
800066a8:	f0 1f 00 2b 	mcall	80006754 <nav_dir_name+0xf4>
800066ac:	c0 71       	brne	800066ba <nav_dir_name+0x5a>
      {
         fs_g_nav.b_mode_nav_single = b_mode_nav_single_save;
800066ae:	4a 78       	lddpc	r8,80006748 <nav_dir_name+0xe8>
800066b0:	f1 64 00 2d 	st.b	r8[45],r4
         fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
800066b4:	f1 63 00 2c 	st.b	r8[44],r3
         return false;
800066b8:	c4 48       	rjmp	80006740 <nav_dir_name+0xe0>
      }
      fs_g_nav.b_mode_nav_single = b_mode_nav_single_save ;
800066ba:	4a 42       	lddpc	r2,80006748 <nav_dir_name+0xe8>
800066bc:	e5 64 00 2d 	st.b	r2[45],r4
      fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
800066c0:	e5 63 00 2c 	st.b	r2[44],r3
      // Go to directory name position
      fs_g_nav_fast.u16_entry_pos_sel_file = fs_g_nav.u16_entry_pos_sel_dir;
800066c4:	4a 24       	lddpc	r4,8000674c <nav_dir_name+0xec>
800066c6:	e5 08 00 1c 	ld.sh	r8,r2[28]
800066ca:	a8 18       	st.h	r4[0x2],r8
      status = nav_file_name( sz_path  , u8_size_max , FS_NAME_GET , false  );
800066cc:	30 09       	mov	r9,0
800066ce:	30 1a       	mov	r10,1
800066d0:	0a 9b       	mov	r11,r5
800066d2:	0c 9c       	mov	r12,r6
800066d4:	f0 1f 00 21 	mcall	80006758 <nav_dir_name+0xf8>
      // Restore previous context
      fs_g_nav_fast.u16_entry_pos_sel_file= save_u16_entry_pos_sel_file;
800066d8:	a8 11       	st.h	r4[0x2],r1
      fs_g_nav.u32_cluster_sel_dir        = save_u32_cluster_sel_dir   ;
800066da:	85 87       	st.w	r2[0x20],r7
      fs_g_nav_entry.u8_attr              = save_u8_attr               ;
800066dc:	49 d8       	lddpc	r8,80006750 <nav_dir_name+0xf0>
800066de:	b0 a0       	st.b	r8[0x2],r0
      fs_g_nav_entry.u32_cluster          = save_u32_cluster           ;
800066e0:	40 19       	lddsp	r9,sp[0x4]
800066e2:	91 19       	st.w	r8[0x4],r9
      fs_g_nav_entry.u32_size             = save_u32_size              ;
800066e4:	40 09       	lddsp	r9,sp[0x0]
800066e6:	91 29       	st.w	r8[0x8],r9
800066e8:	c2 c8       	rjmp	80006740 <nav_dir_name+0xe0>
   }
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
800066ea:	49 d8       	lddpc	r8,8000675c <nav_dir_name+0xfc>
800066ec:	11 89       	ld.ub	r9,r8[0x0]
800066ee:	30 08       	mov	r8,0
800066f0:	f0 09 18 00 	cp.b	r9,r8
800066f4:	c0 50       	breq	800066fe <nav_dir_name+0x9e>
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
800066f6:	30 38       	mov	r8,3
800066f8:	ac 08       	st.h	r6[0x0],r8
800066fa:	30 1c       	mov	r12,1
800066fc:	c2 28       	rjmp	80006740 <nav_dir_name+0xe0>
800066fe:	2f f6       	sub	r6,-1
80006700:	30 17       	mov	r7,1
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
80006702:	30 04       	mov	r4,0
80006704:	30 15       	mov	r5,1
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
80006706:	30 23       	mov	r3,2
80006708:	c0 48       	rjmp	80006710 <nav_dir_name+0xb0>
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
8000670a:	2f f6       	sub	r6,-1
8000670c:	2f f7       	sub	r7,-1
8000670e:	5c 57       	castu.b	r7
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
80006710:	0e 98       	mov	r8,r7
80006712:	20 18       	sub	r8,1
80006714:	e8 08 18 00 	cp.b	r8,r4
80006718:	c0 e0       	breq	80006734 <nav_dir_name+0xd4>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
8000671a:	ea 08 18 00 	cp.b	r8,r5
8000671e:	f9 b8 00 3a 	moveq	r8,58
80006722:	f9 b8 01 00 	movne	r8,0
80006726:	ed 68 ff ff 	st.b	r6[-1],r8
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
8000672a:	e6 07 18 00 	cp.b	r7,r3
8000672e:	fe 98 ff ee 	brls	8000670a <nav_dir_name+0xaa>
80006732:	c0 68       	rjmp	8000673e <nav_dir_name+0xde>
      {
         switch( u8_i )
         {
            case 0:
            u8_character = nav_drive_getname();    // Letter
80006734:	f0 1f 00 0b 	mcall	80006760 <nav_dir_name+0x100>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
80006738:	ed 6c ff ff 	st.b	r6[-1],r12
8000673c:	ce 7b       	rjmp	8000670a <nav_dir_name+0xaa>
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
8000673e:	30 1c       	mov	r12,1
      }
      status = true;

   }
   return status;
}
80006740:	2f ed       	sub	sp,-8
80006742:	d8 32       	popm	r0-r7,pc
80006744:	80 00       	ld.sh	r0,r0[0x0]
80006746:	5a d8       	cp.w	r8,-19
80006748:	00 00       	add	r0,r0
8000674a:	15 cc       	ld.ub	r12,r10[0x4]
8000674c:	00 00       	add	r0,r0
8000674e:	16 18       	sub	r8,r11
80006750:	00 00       	add	r0,r0
80006752:	13 8c       	ld.ub	r12,r9[0x0]
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	65 c0       	ld.w	r0,r2[0x70]
80006758:	80 00       	ld.sh	r0,r0[0x0]
8000675a:	63 4c       	ld.w	r12,r1[0x50]
8000675c:	00 00       	add	r0,r0
8000675e:	16 1d       	sub	sp,r11
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	62 ec       	ld.w	r12,r1[0x38]

80006764 <nav_filelist_first>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_first( bool b_type )
{
80006764:	d4 21       	pushm	r4-r7,lr
80006766:	18 97       	mov	r7,r12
   // Reset position
   if ( !nav_filelist_reset())
80006768:	f0 1f 00 0b 	mcall	80006794 <nav_filelist_first+0x30>
8000676c:	c0 71       	brne	8000677a <nav_filelist_first+0x16>
8000676e:	d8 22       	popm	r4-r7,pc
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( b_type == fs_g_nav.b_mode_nav )
80006770:	e9 38 00 2c 	ld.ub	r8,r4[44]
80006774:	10 37       	cp.w	r7,r8
80006776:	c0 51       	brne	80006780 <nav_filelist_first+0x1c>
80006778:	da 2a       	popm	r4-r7,pc,r12=1
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000677a:	30 16       	mov	r6,1
8000677c:	30 05       	mov	r5,0
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000677e:	48 74       	lddpc	r4,80006798 <nav_filelist_first+0x34>
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80006780:	0c 9b       	mov	r11,r6
80006782:	0a 9c       	mov	r12,r5
80006784:	f0 1f 00 06 	mcall	8000679c <nav_filelist_first+0x38>
80006788:	cf 41       	brne	80006770 <nav_filelist_first+0xc>
   {
      if( b_type == fs_g_nav.b_mode_nav )
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
8000678a:	30 99       	mov	r9,9
8000678c:	48 58       	lddpc	r8,800067a0 <nav_filelist_first+0x3c>
8000678e:	b0 89       	st.b	r8[0x0],r9
   return false;
}
80006790:	d8 22       	popm	r4-r7,pc
80006792:	00 00       	add	r0,r0
80006794:	80 00       	ld.sh	r0,r0[0x0]
80006796:	65 a8       	ld.w	r8,r2[0x68]
80006798:	00 00       	add	r0,r0
8000679a:	15 cc       	ld.ub	r12,r10[0x4]
8000679c:	80 00       	ld.sh	r0,r0[0x0]
8000679e:	64 40       	ld.w	r0,r2[0x10]
800067a0:	00 00       	add	r0,r0
800067a2:	16 1c       	sub	r12,r11

800067a4 <nav_filelist_nb>:
//!                     FS_FILE to compute the number of files <br>
//!
//! @return    number of files or directories in file list
//!
uint16_t   nav_filelist_nb( bool b_type )
{
800067a4:	d4 31       	pushm	r0-r7,lr
800067a6:	18 90       	mov	r0,r12
   uint16_t   u16_save_position;
   uint16_t   u16_save_number_dir;
   uint16_t   u16_save_number_file;

   // Save current position
   u16_save_position = fs_g_nav.u16_pos_sel_file;
800067a8:	49 88       	lddpc	r8,80006808 <nav_filelist_nb+0x64>
800067aa:	f1 01 00 24 	ld.sh	r1,r8[36]
   // Reset position
   if ( !nav_filelist_reset())
800067ae:	f0 1f 00 18 	mcall	8000680c <nav_filelist_nb+0x68>
800067b2:	c0 31       	brne	800067b8 <nav_filelist_nb+0x14>
800067b4:	30 02       	mov	r2,0
800067b6:	c2 68       	rjmp	80006802 <nav_filelist_nb+0x5e>
800067b8:	30 02       	mov	r2,0
800067ba:	04 97       	mov	r7,r2
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800067bc:	30 14       	mov	r4,1
800067be:	04 93       	mov	r3,r2
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
800067c0:	49 26       	lddpc	r6,80006808 <nav_filelist_nb+0x64>
800067c2:	30 15       	mov	r5,1
800067c4:	c0 b8       	rjmp	800067da <nav_filelist_nb+0x36>
800067c6:	ed 38 00 2c 	ld.ub	r8,r6[44]
800067ca:	ea 08 18 00 	cp.b	r8,r5
800067ce:	c0 41       	brne	800067d6 <nav_filelist_nb+0x32>
         u16_save_number_file++;    // It is a file
800067d0:	2f f2       	sub	r2,-1
800067d2:	5c 82       	casts.h	r2
800067d4:	c0 38       	rjmp	800067da <nav_filelist_nb+0x36>
      else
         u16_save_number_dir++;     // It is a directory
800067d6:	2f f7       	sub	r7,-1
800067d8:	5c 87       	casts.h	r7
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800067da:	08 9b       	mov	r11,r4
800067dc:	06 9c       	mov	r12,r3
800067de:	f0 1f 00 0d 	mcall	80006810 <nav_filelist_nb+0x6c>
800067e2:	cf 21       	brne	800067c6 <nav_filelist_nb+0x22>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
800067e4:	f0 1f 00 0a 	mcall	8000680c <nav_filelist_nb+0x68>
   if ( u16_save_position != FS_NO_SEL )
800067e8:	3f f8       	mov	r8,-1
800067ea:	f0 01 19 00 	cp.h	r1,r8
800067ee:	c0 60       	breq	800067fa <nav_filelist_nb+0x56>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
800067f0:	30 1b       	mov	r11,1
800067f2:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
800067f6:	f0 1f 00 07 	mcall	80006810 <nav_filelist_nb+0x6c>
   }
   // Return the value asked
   if( FS_FILE == b_type )
800067fa:	58 00       	cp.w	r0,0
800067fc:	c0 31       	brne	80006802 <nav_filelist_nb+0x5e>
800067fe:	0e 92       	mov	r2,r7
80006800:	5c 82       	casts.h	r2
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
80006802:	04 9c       	mov	r12,r2
80006804:	d8 32       	popm	r0-r7,pc
80006806:	00 00       	add	r0,r0
80006808:	00 00       	add	r0,r0
8000680a:	15 cc       	ld.ub	r12,r10[0x4]
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	65 a8       	ld.w	r8,r2[0x68]
80006810:	80 00       	ld.sh	r0,r0[0x0]
80006812:	64 40       	ld.w	r0,r2[0x10]

80006814 <nav_filelist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filelist_goto( uint16_t u16_newpos )
{
80006814:	eb cd 40 80 	pushm	r7,lr
80006818:	18 97       	mov	r7,r12
   uint16_t u16_current_pos;

   if( FS_NO_SEL == u16_newpos )
8000681a:	3f f8       	mov	r8,-1
8000681c:	f0 0c 19 00 	cp.h	r12,r8
80006820:	c0 51       	brne	8000682a <nav_filelist_goto+0x16>
      return nav_filelist_reset();
80006822:	f0 1f 00 1d 	mcall	80006894 <nav_filelist_goto+0x80>
80006826:	e3 cd 80 80 	ldm	sp++,r7,pc

   u16_current_pos = nav_filelist_get();
8000682a:	f0 1f 00 1c 	mcall	80006898 <nav_filelist_goto+0x84>
8000682e:	5c 8c       	casts.h	r12
   if( u16_newpos < (u16_current_pos/2) )
80006830:	f1 dc c0 2f 	bfextu	r8,r12,0x1,0xf
80006834:	f0 07 19 00 	cp.h	r7,r8
80006838:	c0 62       	brcc	80006844 <nav_filelist_goto+0x30>
   {
      // Restart at the beginning of list to accelerate the search
      if( !nav_filelist_reset() )
8000683a:	f0 1f 00 17 	mcall	80006894 <nav_filelist_goto+0x80>
8000683e:	c0 71       	brne	8000684c <nav_filelist_goto+0x38>
80006840:	e3 cd 80 80 	ldm	sp++,r7,pc
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
80006844:	3f f8       	mov	r8,-1
80006846:	f0 0c 19 00 	cp.h	r12,r8
8000684a:	c0 81       	brne	8000685a <nav_filelist_goto+0x46>
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
8000684c:	30 1b       	mov	r11,1
8000684e:	0e 9c       	mov	r12,r7
80006850:	5c 7c       	castu.h	r12
80006852:	f0 1f 00 13 	mcall	8000689c <nav_filelist_goto+0x88>
80006856:	e3 cd 80 80 	ldm	sp++,r7,pc
   }
   else
   {
      if (u16_newpos < u16_current_pos)
8000685a:	f8 07 19 00 	cp.h	r7,r12
8000685e:	c0 b2       	brcc	80006874 <nav_filelist_goto+0x60>
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
80006860:	ee 07 11 ff 	rsub	r7,r7,-1
80006864:	ee 0c 00 0c 	add	r12,r7,r12
80006868:	30 0b       	mov	r11,0
8000686a:	5c 7c       	castu.h	r12
8000686c:	f0 1f 00 0c 	mcall	8000689c <nav_filelist_goto+0x88>
80006870:	e3 cd 80 80 	ldm	sp++,r7,pc
      }
      if (u16_newpos > u16_current_pos)
80006874:	f8 07 19 00 	cp.h	r7,r12
80006878:	e0 8b 00 04 	brhi	80006880 <nav_filelist_goto+0x6c>
8000687c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      {
         return nav_filelist_set( u16_newpos -u16_current_pos - 1 , FS_FIND_NEXT );
80006880:	20 17       	sub	r7,1
80006882:	ee 0c 01 0c 	sub	r12,r7,r12
80006886:	30 1b       	mov	r11,1
80006888:	5c 7c       	castu.h	r12
8000688a:	f0 1f 00 05 	mcall	8000689c <nav_filelist_goto+0x88>
      }
   }
   return true;
}
8000688e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006892:	00 00       	add	r0,r0
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	65 a8       	ld.w	r8,r2[0x68]
80006898:	80 00       	ld.sh	r0,r0[0x0]
8000689a:	63 08       	ld.w	r8,r1[0x40]
8000689c:	80 00       	ld.sh	r0,r0[0x0]
8000689e:	64 40       	ld.w	r0,r2[0x10]

800068a0 <nav_partition_mount>:
//! then the mount routine selects the first partition supported by file system. <br>
//! After mount, the file list contains files and directories of ROOT directory
//! @endverbatim
//!
bool  nav_partition_mount( void )
{
800068a0:	d4 01       	pushm	lr
   if ( !fat_check_noopen() )
800068a2:	f0 1f 00 0a 	mcall	800068c8 <nav_partition_mount+0x28>
800068a6:	c0 f0       	breq	800068c4 <nav_partition_mount+0x24>
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
800068a8:	48 98       	lddpc	r8,800068cc <nav_partition_mount+0x2c>
800068aa:	11 89       	ld.ub	r9,r8[0x0]
800068ac:	30 08       	mov	r8,0
800068ae:	f0 09 18 00 	cp.b	r9,r8
800068b2:	c0 70       	breq	800068c0 <nav_partition_mount+0x20>
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
800068b4:	30 09       	mov	r9,0
800068b6:	48 78       	lddpc	r8,800068d0 <nav_partition_mount+0x30>
800068b8:	91 89       	st.w	r8[0x20],r9
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
800068ba:	f0 1f 00 07 	mcall	800068d4 <nav_partition_mount+0x34>
800068be:	da 0a       	popm	pc,r12=1
      return true;
   }

   return fat_mount();
800068c0:	f0 1f 00 06 	mcall	800068d8 <nav_partition_mount+0x38>
}
800068c4:	d8 02       	popm	pc
800068c6:	00 00       	add	r0,r0
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	5a 04       	cp.w	r4,-32
800068cc:	00 00       	add	r0,r0
800068ce:	16 18       	sub	r8,r11
800068d0:	00 00       	add	r0,r0
800068d2:	15 cc       	ld.ub	r12,r10[0x4]
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	4b 28       	lddpc	r8,8000699c <nav_exit+0xc>
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	5c 1c       	scr	r12

800068dc <nav_dir_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_dir_root( void )
{
800068dc:	d4 01       	pushm	lr
   return nav_partition_mount();
800068de:	f0 1f 00 02 	mcall	800068e4 <nav_dir_root+0x8>
}
800068e2:	d8 02       	popm	pc
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	68 a0       	ld.w	r0,r4[0x28]

800068e8 <nav_drive_set>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_drive_set( uint8_t u8_number )
{
800068e8:	eb cd 40 80 	pushm	r7,lr
800068ec:	18 97       	mov	r7,r12
   if ( !fat_check_noopen() )
800068ee:	f0 1f 00 0f 	mcall	80006928 <nav_drive_set+0x40>
800068f2:	c1 90       	breq	80006924 <nav_drive_set+0x3c>
      return false;

   if (u8_number >= get_nb_lun() )
800068f4:	f0 1f 00 0e 	mcall	8000692c <nav_drive_set+0x44>
800068f8:	ee 0c 18 00 	cp.b	r12,r7
800068fc:	e0 8b 00 07 	brhi	8000690a <nav_drive_set+0x22>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
80006900:	30 69       	mov	r9,6
80006902:	48 c8       	lddpc	r8,80006930 <nav_drive_set+0x48>
80006904:	b0 89       	st.b	r8[0x0],r9
80006906:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
8000690a:	48 b8       	lddpc	r8,80006934 <nav_drive_set+0x4c>
8000690c:	11 88       	ld.ub	r8,r8[0x0]
8000690e:	ee 08 18 00 	cp.b	r8,r7
80006912:	c0 31       	brne	80006918 <nav_drive_set+0x30>
80006914:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
80006918:	48 78       	lddpc	r8,80006934 <nav_drive_set+0x4c>
8000691a:	b0 87       	st.b	r8[0x0],r7
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
8000691c:	30 09       	mov	r9,0
8000691e:	48 78       	lddpc	r8,80006938 <nav_drive_set+0x50>
80006920:	b0 89       	st.b	r8[0x0],r9
80006922:	30 1c       	mov	r12,1
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
80006924:	e3 cd 80 80 	ldm	sp++,r7,pc
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	5a 04       	cp.w	r4,-32
8000692c:	80 00       	ld.sh	r0,r0[0x0]
8000692e:	6f d4       	ld.w	r4,r7[0x74]
80006930:	00 00       	add	r0,r0
80006932:	16 1c       	sub	r12,r11
80006934:	00 00       	add	r0,r0
80006936:	15 cc       	ld.ub	r12,r10[0x4]
80006938:	00 00       	add	r0,r0
8000693a:	16 18       	sub	r8,r11

8000693c <nav_drive_nb>:
//! @verbatim
//! This value may be dynamic because it depends of memory drivers (e.g. Mass Storage disk on USB host mode)
//! @endverbatim
//!
uint8_t    nav_drive_nb( void )
{
8000693c:	d4 01       	pushm	lr
   return get_nb_lun(); // Number of devices = Number of lun
8000693e:	f0 1f 00 02 	mcall	80006944 <nav_drive_nb+0x8>
}
80006942:	d8 02       	popm	pc
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	6f d4       	ld.w	r4,r7[0x74]

80006948 <nav_select>:
//!
//! @return    false if ID navigator don't exist
//! @return    true otherwise
//!
bool  nav_select( uint8_t u8_idnav )
{
80006948:	eb cd 40 80 	pushm	r7,lr
8000694c:	18 97       	mov	r7,r12
   if( FS_NB_NAVIGATOR <= u8_idnav )
8000694e:	30 18       	mov	r8,1
80006950:	f0 0c 18 00 	cp.b	r12,r8
80006954:	e0 88 00 07 	brls	80006962 <nav_select+0x1a>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
80006958:	32 79       	mov	r9,39
8000695a:	48 b8       	lddpc	r8,80006984 <nav_select+0x3c>
8000695c:	b0 89       	st.b	r8[0x0],r9
8000695e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
80006962:	48 a8       	lddpc	r8,80006988 <nav_select+0x40>
80006964:	11 8c       	ld.ub	r12,r8[0x0]
80006966:	ee 0c 18 00 	cp.b	r12,r7
8000696a:	c0 31       	brne	80006970 <nav_select+0x28>
8000696c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
80006970:	f0 1f 00 07 	mcall	8000698c <nav_select+0x44>
      fat_invert_nav( u8_idnav );               // Select new navigator
80006974:	0e 9c       	mov	r12,r7
80006976:	f0 1f 00 06 	mcall	8000698c <nav_select+0x44>
      fs_g_u8_nav_selected = u8_idnav;
8000697a:	48 48       	lddpc	r8,80006988 <nav_select+0x40>
8000697c:	b0 87       	st.b	r8[0x0],r7
8000697e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80006982:	00 00       	add	r0,r0
80006984:	00 00       	add	r0,r0
80006986:	16 1c       	sub	r12,r11
80006988:	00 00       	add	r0,r0
8000698a:	16 94       	mov	r4,r11
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	50 74       	stdsp	sp[0x1c],r4

80006990 <nav_exit>:
//! @verbatim
//! Call this at the program exit or before a USB Device session
//! @endverbatim
//!
void  nav_exit( void )
{
80006990:	d4 01       	pushm	lr
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
80006992:	30 0c       	mov	r12,0
80006994:	f0 1f 00 06 	mcall	800069ac <nav_exit+0x1c>
      file_close();
80006998:	f0 1f 00 06 	mcall	800069b0 <nav_exit+0x20>
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
8000699c:	30 1c       	mov	r12,1
8000699e:	f0 1f 00 04 	mcall	800069ac <nav_exit+0x1c>
      file_close();
800069a2:	f0 1f 00 04 	mcall	800069b0 <nav_exit+0x20>
#else
   nav_select(0);
   file_close();
#endif
   // Flush data eventually present in FAT cache
   fat_cache_flush();
800069a6:	f0 1f 00 04 	mcall	800069b4 <nav_exit+0x24>
}
800069aa:	d8 02       	popm	pc
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	69 48       	ld.w	r8,r4[0x50]
800069b0:	80 00       	ld.sh	r0,r0[0x0]
800069b2:	5f f0       	sral	r0
800069b4:	80 00       	ld.sh	r0,r0[0x0]
800069b6:	51 50       	stdsp	sp[0x54],r0

800069b8 <nav_reset>:
//! @verbatim
//! Call this at the program startup or before a new session (e.g. USB Device exit)
//! @endverbatim
//!
void  nav_reset( void )
{
800069b8:	eb cd 40 f8 	pushm	r3-r7,lr
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
800069bc:	30 07       	mov	r7,0
800069be:	49 18       	lddpc	r8,80006a00 <nav_reset+0x48>
800069c0:	b0 87       	st.b	r8[0x0],r7
   g_b_no_check_disk = false;
800069c2:	49 18       	lddpc	r8,80006a04 <nav_reset+0x4c>
800069c4:	b0 87       	st.b	r8[0x0],r7

   fat_cache_reset();
800069c6:	f0 1f 00 11 	mcall	80006a08 <nav_reset+0x50>
   fat_cache_clusterlist_reset();
800069ca:	f0 1f 00 11 	mcall	80006a0c <nav_reset+0x54>
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
800069ce:	30 0c       	mov	r12,0
800069d0:	f0 1f 00 10 	mcall	80006a10 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
800069d4:	49 03       	lddpc	r3,80006a14 <nav_reset+0x5c>
800069d6:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
800069d8:	49 05       	lddpc	r5,80006a18 <nav_reset+0x60>
800069da:	3f f4       	mov	r4,-1
800069dc:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
800069de:	49 06       	lddpc	r6,80006a1c <nav_reset+0x64>
800069e0:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
800069e2:	eb 67 00 2d 	st.b	r5[45],r7
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
800069e6:	30 1c       	mov	r12,1
800069e8:	f0 1f 00 0a 	mcall	80006a10 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
800069ec:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
800069ee:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
800069f0:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
800069f2:	eb 67 00 2d 	st.b	r5[45],r7
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
800069f6:	48 b8       	lddpc	r8,80006a20 <nav_reset+0x68>
800069f8:	b0 87       	st.b	r8[0x0],r7
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
800069fa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800069fe:	00 00       	add	r0,r0
80006a00:	00 00       	add	r0,r0
80006a02:	16 1d       	sub	sp,r11
80006a04:	00 00       	add	r0,r0
80006a06:	13 9e       	ld.ub	lr,r9[0x1]
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	4f 84       	lddpc	r4,80006be8 <reader_txt_get_line+0x18>
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	48 bc       	lddpc	r12,80006a38 <nav_filterlist_root+0x14>
80006a10:	80 00       	ld.sh	r0,r0[0x0]
80006a12:	69 48       	ld.w	r8,r4[0x50]
80006a14:	00 00       	add	r0,r0
80006a16:	16 18       	sub	r8,r11
80006a18:	00 00       	add	r0,r0
80006a1a:	15 cc       	ld.ub	r12,r10[0x4]
80006a1c:	00 00       	add	r0,r0
80006a1e:	13 8c       	ld.ub	r12,r9[0x0]
80006a20:	00 00       	add	r0,r0
80006a22:	16 94       	mov	r4,r11

80006a24 <nav_filterlist_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_root( void )
{
80006a24:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
80006a26:	3f f9       	mov	r9,-1
80006a28:	48 38       	lddpc	r8,80006a34 <nav_filterlist_root+0x10>
80006a2a:	f1 59 00 26 	st.h	r8[38],r9
   return nav_dir_root();
80006a2e:	f0 1f 00 03 	mcall	80006a38 <nav_filterlist_root+0x14>
}
80006a32:	d8 02       	popm	pc
80006a34:	00 00       	add	r0,r0
80006a36:	15 cc       	ld.ub	r12,r10[0x4]
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	68 dc       	ld.w	r12,r4[0x34]

80006a3c <nav_filterlist_previous>:
//!
//! @return    false in case of an error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_previous( void )
{
80006a3c:	eb cd 40 e0 	pushm	r5-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
80006a40:	f0 1f 00 11 	mcall	80006a84 <nav_filterlist_previous+0x48>
80006a44:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80006a48:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
80006a4a:	49 06       	lddpc	r6,80006a88 <nav_filterlist_previous+0x4c>
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80006a4c:	c1 08       	rjmp	80006a6c <nav_filterlist_previous+0x30>
   {
      if( nav_file_isdir()
80006a4e:	f0 1f 00 10 	mcall	80006a8c <nav_filterlist_previous+0x50>
80006a52:	c0 51       	brne	80006a5c <nav_filterlist_previous+0x20>
80006a54:	6c ac       	ld.w	r12,r6[0x28]
80006a56:	f0 1f 00 0f 	mcall	80006a90 <nav_filterlist_previous+0x54>
80006a5a:	c0 90       	breq	80006a6c <nav_filterlist_previous+0x30>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         fs_g_nav.u16_pos_filterlist--;
80006a5c:	48 b8       	lddpc	r8,80006a88 <nav_filterlist_previous+0x4c>
80006a5e:	f1 09 00 26 	ld.sh	r9,r8[38]
80006a62:	20 19       	sub	r9,1
80006a64:	f1 59 00 26 	st.h	r8[38],r9
80006a68:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80006a6c:	0e 9b       	mov	r11,r7
80006a6e:	0e 9c       	mov	r12,r7
80006a70:	f0 1f 00 09 	mcall	80006a94 <nav_filterlist_previous+0x58>
80006a74:	ce d1       	brne	80006a4e <nav_filterlist_previous+0x12>
      {
         fs_g_nav.u16_pos_filterlist--;
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
80006a76:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80006a7a:	f0 1f 00 08 	mcall	80006a98 <nav_filterlist_previous+0x5c>
80006a7e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80006a82:	00 00       	add	r0,r0
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	63 08       	ld.w	r8,r1[0x40]
80006a88:	00 00       	add	r0,r0
80006a8a:	15 cc       	ld.ub	r12,r10[0x4]
80006a8c:	80 00       	ld.sh	r0,r0[0x0]
80006a8e:	63 40       	ld.w	r0,r1[0x50]
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	63 14       	ld.w	r4,r1[0x44]
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	64 40       	ld.w	r0,r2[0x10]
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	68 14       	ld.w	r4,r4[0x4]

80006a9c <nav_filterlist_next>:
//!
//! @return    false in case of error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_next( void )
{
80006a9c:	d4 21       	pushm	r4-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
80006a9e:	f0 1f 00 15 	mcall	80006af0 <nav_filterlist_next+0x54>
80006aa2:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80006aa6:	30 16       	mov	r6,1
80006aa8:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
80006aaa:	49 35       	lddpc	r5,80006af4 <nav_filterlist_next+0x58>
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80006aac:	c1 88       	rjmp	80006adc <nav_filterlist_next+0x40>
   {
      if( nav_file_isdir()
80006aae:	f0 1f 00 13 	mcall	80006af8 <nav_filterlist_next+0x5c>
80006ab2:	c0 51       	brne	80006abc <nav_filterlist_next+0x20>
80006ab4:	6a ac       	ld.w	r12,r5[0x28]
80006ab6:	f0 1f 00 12 	mcall	80006afc <nav_filterlist_next+0x60>
80006aba:	c1 10       	breq	80006adc <nav_filterlist_next+0x40>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
80006abc:	3f f8       	mov	r8,-1
80006abe:	f0 04 19 00 	cp.h	r4,r8
80006ac2:	c0 61       	brne	80006ace <nav_filterlist_next+0x32>
         {
            fs_g_nav.u16_pos_filterlist = 0;
80006ac4:	30 09       	mov	r9,0
80006ac6:	48 c8       	lddpc	r8,80006af4 <nav_filterlist_next+0x58>
80006ac8:	f1 59 00 26 	st.h	r8[38],r9
80006acc:	da 2a       	popm	r4-r7,pc,r12=1
         }else{
            fs_g_nav.u16_pos_filterlist++;
80006ace:	48 a8       	lddpc	r8,80006af4 <nav_filterlist_next+0x58>
80006ad0:	f1 09 00 26 	ld.sh	r9,r8[38]
80006ad4:	2f f9       	sub	r9,-1
80006ad6:	f1 59 00 26 	st.h	r8[38],r9
80006ada:	da 2a       	popm	r4-r7,pc,r12=1
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80006adc:	0c 9b       	mov	r11,r6
80006ade:	0e 9c       	mov	r12,r7
80006ae0:	f0 1f 00 08 	mcall	80006b00 <nav_filterlist_next+0x64>
80006ae4:	ce 51       	brne	80006aae <nav_filterlist_next+0x12>
            fs_g_nav.u16_pos_filterlist++;
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
80006ae6:	08 9c       	mov	r12,r4
80006ae8:	5c 7c       	castu.h	r12
80006aea:	f0 1f 00 07 	mcall	80006b04 <nav_filterlist_next+0x68>
80006aee:	d8 2a       	popm	r4-r7,pc,r12=0
80006af0:	80 00       	ld.sh	r0,r0[0x0]
80006af2:	63 08       	ld.w	r8,r1[0x40]
80006af4:	00 00       	add	r0,r0
80006af6:	15 cc       	ld.ub	r12,r10[0x4]
80006af8:	80 00       	ld.sh	r0,r0[0x0]
80006afa:	63 40       	ld.w	r0,r1[0x50]
80006afc:	80 00       	ld.sh	r0,r0[0x0]
80006afe:	63 14       	ld.w	r4,r1[0x44]
80006b00:	80 00       	ld.sh	r0,r0[0x0]
80006b02:	64 40       	ld.w	r0,r2[0x10]
80006b04:	80 00       	ld.sh	r0,r0[0x0]
80006b06:	68 14       	ld.w	r4,r4[0x4]

80006b08 <nav_filterlist_reset>:
//!
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
80006b08:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
80006b0a:	3f f9       	mov	r9,-1
80006b0c:	48 38       	lddpc	r8,80006b18 <nav_filterlist_reset+0x10>
80006b0e:	f1 59 00 26 	st.h	r8[38],r9
   return nav_filelist_reset();
80006b12:	f0 1f 00 03 	mcall	80006b1c <nav_filterlist_reset+0x14>
}
80006b16:	d8 02       	popm	pc
80006b18:	00 00       	add	r0,r0
80006b1a:	15 cc       	ld.ub	r12,r10[0x4]
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	65 a8       	ld.w	r8,r2[0x68]

80006b20 <nav_filterlist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_goto( uint16_t u16_newpos )
{
80006b20:	eb cd 40 c0 	pushm	r6-r7,lr
80006b24:	18 97       	mov	r7,r12
   if (u16_newpos == FS_NO_SEL)
80006b26:	3f f8       	mov	r8,-1
80006b28:	f0 0c 19 00 	cp.h	r12,r8
80006b2c:	c0 51       	brne	80006b36 <nav_filterlist_goto+0x16>
     return nav_filterlist_reset();
80006b2e:	f0 1f 00 1d 	mcall	80006ba0 <nav_filterlist_goto+0x80>
80006b32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

   if( u16_newpos < (fs_g_nav.u16_pos_filterlist/2) )
80006b36:	49 c8       	lddpc	r8,80006ba4 <nav_filterlist_goto+0x84>
80006b38:	f1 18 00 26 	ld.uh	r8,r8[38]
80006b3c:	a1 98       	lsr	r8,0x1
80006b3e:	f0 0c 19 00 	cp.h	r12,r8
80006b42:	c0 42       	brcc	80006b4a <nav_filterlist_goto+0x2a>
   {
      // Restart at the beginning of list to accelerate search
      if( !nav_filterlist_reset() )
80006b44:	f0 1f 00 17 	mcall	80006ba0 <nav_filterlist_goto+0x80>
80006b48:	c2 a0       	breq	80006b9c <nav_filterlist_goto+0x7c>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
80006b4a:	49 78       	lddpc	r8,80006ba4 <nav_filterlist_goto+0x84>
80006b4c:	f1 09 00 26 	ld.sh	r9,r8[38]
80006b50:	3f f8       	mov	r8,-1
80006b52:	f0 09 19 00 	cp.h	r9,r8
80006b56:	c0 91       	brne	80006b68 <nav_filterlist_goto+0x48>
      if( !nav_filterlist_next() )
80006b58:	f0 1f 00 14 	mcall	80006ba8 <nav_filterlist_goto+0x88>
80006b5c:	c0 61       	brne	80006b68 <nav_filterlist_goto+0x48>
80006b5e:	c1 f8       	rjmp	80006b9c <nav_filterlist_goto+0x7c>
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
80006b60:	f0 1f 00 12 	mcall	80006ba8 <nav_filterlist_goto+0x88>
80006b64:	c0 31       	brne	80006b6a <nav_filterlist_goto+0x4a>
80006b66:	c0 c8       	rjmp	80006b7e <nav_filterlist_goto+0x5e>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
      if( !nav_filterlist_next() )
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
80006b68:	48 f6       	lddpc	r6,80006ba4 <nav_filterlist_goto+0x84>
80006b6a:	ed 08 00 26 	ld.sh	r8,r6[38]
80006b6e:	ee 08 19 00 	cp.h	r8,r7
80006b72:	cf 73       	brcs	80006b60 <nav_filterlist_goto+0x40>
80006b74:	c0 58       	rjmp	80006b7e <nav_filterlist_goto+0x5e>
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_previous() )
80006b76:	f0 1f 00 0e 	mcall	80006bac <nav_filterlist_goto+0x8c>
80006b7a:	c0 31       	brne	80006b80 <nav_filterlist_goto+0x60>
80006b7c:	c0 88       	rjmp	80006b8c <nav_filterlist_goto+0x6c>
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
80006b7e:	48 a6       	lddpc	r6,80006ba4 <nav_filterlist_goto+0x84>
80006b80:	ed 08 00 26 	ld.sh	r8,r6[38]
80006b84:	ee 08 19 00 	cp.h	r8,r7
80006b88:	fe 9b ff f7 	brhi	80006b76 <nav_filterlist_goto+0x56>
   {
      if( !nav_filterlist_previous() )
         break;
   }
   return (u16_newpos == fs_g_nav.u16_pos_filterlist);
80006b8c:	48 68       	lddpc	r8,80006ba4 <nav_filterlist_goto+0x84>
80006b8e:	f1 08 00 26 	ld.sh	r8,r8[38]
80006b92:	ee 08 19 00 	cp.h	r8,r7
80006b96:	5f 0c       	sreq	r12
80006b98:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b9c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	6b 08       	ld.w	r8,r5[0x40]
80006ba4:	00 00       	add	r0,r0
80006ba6:	15 cc       	ld.ub	r12,r10[0x4]
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	6a 9c       	ld.w	r12,r5[0x24]
80006bac:	80 00       	ld.sh	r0,r0[0x0]
80006bae:	6a 3c       	ld.w	r12,r5[0xc]

80006bb0 <nav_filterlist_setfilter>:
//! This function affiliates an extension filter at current navigator
//!
//! @param     sz_filterext   extension filter (ASCII format, e.g.: "txt" or "txt,d*,wk" )
//!
void  nav_filterlist_setfilter( const FS_STRING sz_filterext  )
{
80006bb0:	d4 01       	pushm	lr
   fs_g_nav.sz_filterext = sz_filterext;
80006bb2:	48 38       	lddpc	r8,80006bbc <nav_filterlist_setfilter+0xc>
80006bb4:	91 ac       	st.w	r8[0x28],r12
   nav_filterlist_reset();
80006bb6:	f0 1f 00 03 	mcall	80006bc0 <nav_filterlist_setfilter+0x10>
}
80006bba:	d8 02       	popm	pc
80006bbc:	00 00       	add	r0,r0
80006bbe:	15 cc       	ld.ub	r12,r10[0x4]
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	6b 08       	ld.w	r8,r5[0x40]

80006bc4 <reader_txt_close>:


//! Close text file
//!
void  reader_txt_close( void )
{
80006bc4:	d4 01       	pushm	lr
   file_close();
80006bc6:	f0 1f 00 02 	mcall	80006bcc <reader_txt_close+0x8>
}
80006bca:	d8 02       	popm	pc
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	5f f0       	sral	r0

80006bd0 <reader_txt_get_line>:
//! @verbatim
//! This routine remove the character '\n' '\r'
//! @endverbatim
//!
uint16_t   reader_txt_get_line( bool b_unicode, FS_STRING string , uint16_t u16_str_size )
{
80006bd0:	d4 31       	pushm	r0-r7,lr
80006bd2:	20 6d       	sub	sp,24
80006bd4:	50 2c       	stdsp	sp[0x8],r12
80006bd6:	16 95       	mov	r5,r11
80006bd8:	14 97       	mov	r7,r10
   uint8_t    size_utf8_dec=0;
   uint16_t   u16_size_line = 1;   // 1 to compute null terminator
   uint16_t   u16_unicode;
   bool  b_error = false;

   nav_checkdisk_disable();   // To optimize speed
80006bda:	f0 1f 00 6b 	mcall	80006d84 <reader_txt_get_line+0x1b4>
80006bde:	30 03       	mov	r3,0
80006be0:	30 16       	mov	r6,1
80006be2:	50 03       	stdsp	sp[0x0],r3
80006be4:	06 94       	mov	r4,r3

   while( 0 == file_eof() && !b_error )
   {
      // Get a unicode value
      switch( fs_g_nav_entry.u8_txt_format )
80006be6:	4e 90       	lddpc	r0,80006d88 <reader_txt_get_line+0x1b8>
80006be8:	30 22       	mov	r2,2
      // Check character to remove
      if( '\r' == u16_unicode )
         continue;   // Ignore character

      // Check end of line
      if((  0  == u16_unicode )
80006bea:	30 01       	mov	r1,0
80006bec:	ba f1       	st.b	sp[0x7],r1
         case UNI_TYPE_UTF8:
         // Remove UTF8 codes used
         if( 0 != size_utf8_dec )
         {
            uint8_t u8_i;
            for( u8_i=0; u8_i<(UNI_MAX_UTF8_SIZE-size_utf8_dec); u8_i++ )
80006bee:	50 33       	stdsp	sp[0xc],r3
   uint16_t   u16_unicode;
   bool  b_error = false;

   nav_checkdisk_disable();   // To optimize speed

   while( 0 == file_eof() && !b_error )
80006bf0:	ca 08       	rjmp	80006d30 <reader_txt_get_line+0x160>
   {
      // Get a unicode value
      switch( fs_g_nav_entry.u8_txt_format )
80006bf2:	01 98       	ld.ub	r8,r0[0x1]
80006bf4:	e4 08 18 00 	cp.b	r8,r2
80006bf8:	c3 d0       	breq	80006c72 <reader_txt_get_line+0xa2>
80006bfa:	30 39       	mov	r9,3
80006bfc:	f2 08 18 00 	cp.b	r8,r9
80006c00:	c0 60       	breq	80006c0c <reader_txt_get_line+0x3c>
80006c02:	30 19       	mov	r9,1
80006c04:	f2 08 18 00 	cp.b	r8,r9
80006c08:	c5 b1       	brne	80006cbe <reader_txt_get_line+0xee>
80006c0a:	c4 78       	rjmp	80006c98 <reader_txt_get_line+0xc8>
      {
         case UNI_TYPE_UTF8:
         // Remove UTF8 codes used
         if( 0 != size_utf8_dec )
80006c0c:	40 09       	lddsp	r9,sp[0x0]
80006c0e:	58 09       	cp.w	r9,0
80006c10:	c1 e0       	breq	80006c4c <reader_txt_get_line+0x7c>
         {
            uint8_t u8_i;
            for( u8_i=0; u8_i<(UNI_MAX_UTF8_SIZE-size_utf8_dec); u8_i++ )
80006c12:	12 9c       	mov	r12,r9
80006c14:	f2 0b 11 03 	rsub	r11,r9,3
80006c18:	58 0b       	cp.w	r11,0
80006c1a:	e0 8a 00 16 	brle	80006c46 <reader_txt_get_line+0x76>
80006c1e:	30 09       	mov	r9,0
80006c20:	40 38       	lddsp	r8,sp[0xc]
            {
               utf8[u8_i]=utf8[u8_i+size_utf8_dec];
80006c22:	fa ca ff e8 	sub	r10,sp,-24
80006c26:	f4 0c 00 0c 	add	r12,r10,r12
80006c2a:	fa ca ff e8 	sub	r10,sp,-24
80006c2e:	12 0a       	add	r10,r9
80006c30:	f8 09 00 09 	add	r9,r12,r9
80006c34:	f3 39 ff fc 	ld.ub	r9,r9[-4]
80006c38:	f5 69 ff fc 	st.b	r10[-4],r9
         case UNI_TYPE_UTF8:
         // Remove UTF8 codes used
         if( 0 != size_utf8_dec )
         {
            uint8_t u8_i;
            for( u8_i=0; u8_i<(UNI_MAX_UTF8_SIZE-size_utf8_dec); u8_i++ )
80006c3c:	2f f8       	sub	r8,-1
80006c3e:	5c 58       	castu.b	r8
80006c40:	10 99       	mov	r9,r8
80006c42:	16 38       	cp.w	r8,r11
80006c44:	cf 35       	brlt	80006c2a <reader_txt_get_line+0x5a>
            {
               utf8[u8_i]=utf8[u8_i+size_utf8_dec];
            }
            size_utf8_buf -= size_utf8_dec;
80006c46:	40 09       	lddsp	r9,sp[0x0]
80006c48:	12 14       	sub	r4,r9
80006c4a:	5c 54       	castu.b	r4
            size_utf8_dec =0;
         }
         // Complete UTF8 array
         size_utf8_buf += file_read_buf( &utf8[size_utf8_buf], (UNI_MAX_UTF8_SIZE-size_utf8_buf) );
80006c4c:	e8 0b 11 03 	rsub	r11,r4,3
80006c50:	5c 7b       	castu.h	r11
80006c52:	fa cc ff ec 	sub	r12,sp,-20
80006c56:	08 0c       	add	r12,r4
80006c58:	f0 1f 00 4d 	mcall	80006d8c <reader_txt_get_line+0x1bc>
80006c5c:	f8 04 00 04 	add	r4,r12,r4
80006c60:	5c 54       	castu.b	r4
         // Decode UTF8 to unicode
         size_utf8_dec = utf8_to_unicode( &utf8[0], &u16_unicode );
80006c62:	fa cb ff ee 	sub	r11,sp,-18
80006c66:	fa cc ff ec 	sub	r12,sp,-20
80006c6a:	f0 1f 00 4a 	mcall	80006d90 <reader_txt_get_line+0x1c0>
80006c6e:	50 0c       	stdsp	sp[0x0],r12
         break;
80006c70:	c3 98       	rjmp	80006ce2 <reader_txt_get_line+0x112>

         case UNI_TYPE_UTF16BE:
         MSB(u16_unicode) = file_getc();
80006c72:	f0 1f 00 49 	mcall	80006d94 <reader_txt_get_line+0x1c4>
80006c76:	fb 6c 00 12 	st.b	sp[18],r12
         LSB(u16_unicode) = file_getc();
80006c7a:	f0 1f 00 47 	mcall	80006d94 <reader_txt_get_line+0x1c4>
80006c7e:	fb 6c 00 13 	st.b	sp[19],r12
         if (LSB(u16_unicode) == (FS_EOF & 0xFF) && fs_g_status != FS_ERR_EOF)
80006c82:	3f f8       	mov	r8,-1
80006c84:	f0 0c 18 00 	cp.b	r12,r8
80006c88:	c2 d1       	brne	80006ce2 <reader_txt_get_line+0x112>
80006c8a:	4c 48       	lddpc	r8,80006d98 <reader_txt_get_line+0x1c8>
80006c8c:	11 89       	ld.ub	r9,r8[0x0]
80006c8e:	32 08       	mov	r8,32
80006c90:	f0 09 18 00 	cp.b	r9,r8
80006c94:	c2 61       	brne	80006ce0 <reader_txt_get_line+0x110>
80006c96:	c2 68       	rjmp	80006ce2 <reader_txt_get_line+0x112>
           b_error = true;
         break;

         case UNI_TYPE_UTF16LE:
         LSB(u16_unicode) = file_getc();
80006c98:	f0 1f 00 3f 	mcall	80006d94 <reader_txt_get_line+0x1c4>
80006c9c:	fb 6c 00 13 	st.b	sp[19],r12
         MSB(u16_unicode) = file_getc();
80006ca0:	f0 1f 00 3d 	mcall	80006d94 <reader_txt_get_line+0x1c4>
80006ca4:	fb 6c 00 12 	st.b	sp[18],r12
         if (MSB(u16_unicode) == (FS_EOF & 0xFF) && fs_g_status != FS_ERR_EOF)
80006ca8:	3f f8       	mov	r8,-1
80006caa:	f0 0c 18 00 	cp.b	r12,r8
80006cae:	c1 a1       	brne	80006ce2 <reader_txt_get_line+0x112>
80006cb0:	4b a8       	lddpc	r8,80006d98 <reader_txt_get_line+0x1c8>
80006cb2:	11 89       	ld.ub	r9,r8[0x0]
80006cb4:	32 08       	mov	r8,32
80006cb6:	f0 09 18 00 	cp.b	r9,r8
80006cba:	c1 31       	brne	80006ce0 <reader_txt_get_line+0x110>
80006cbc:	c1 38       	rjmp	80006ce2 <reader_txt_get_line+0x112>
           b_error = true;
         break;

         default: // ASCII or other
         u16_unicode = file_getc();
80006cbe:	f0 1f 00 36 	mcall	80006d94 <reader_txt_get_line+0x1c4>
80006cc2:	fb 5c 00 12 	st.h	sp[18],r12
         if (u16_unicode == FS_EOF && fs_g_status != FS_ERR_EOF)
80006cc6:	3f f8       	mov	r8,-1
80006cc8:	f0 0c 19 00 	cp.h	r12,r8
80006ccc:	c0 b1       	brne	80006ce2 <reader_txt_get_line+0x112>
80006cce:	4b 38       	lddpc	r8,80006d98 <reader_txt_get_line+0x1c8>
80006cd0:	11 89       	ld.ub	r9,r8[0x0]
80006cd2:	32 08       	mov	r8,32
80006cd4:	f0 09 18 00 	cp.b	r9,r8
80006cd8:	c0 50       	breq	80006ce2 <reader_txt_get_line+0x112>
80006cda:	3f f8       	mov	r8,-1
80006cdc:	30 13       	mov	r3,1
80006cde:	c1 58       	rjmp	80006d08 <reader_txt_get_line+0x138>
80006ce0:	30 13       	mov	r3,1
           b_error = true;
         break;
      }

      // Check character to remove
      if( '\r' == u16_unicode )
80006ce2:	fb 08 00 12 	ld.sh	r8,sp[18]
80006ce6:	30 d9       	mov	r9,13
80006ce8:	f2 08 19 00 	cp.h	r8,r9
80006cec:	c2 20       	breq	80006d30 <reader_txt_get_line+0x160>
         continue;   // Ignore character

      // Check end of line
      if((  0  == u16_unicode )
80006cee:	e2 08 19 00 	cp.h	r8,r1
80006cf2:	5f 0a       	sreq	r10
80006cf4:	30 a9       	mov	r9,10
80006cf6:	f2 08 19 00 	cp.h	r8,r9
80006cfa:	5f 09       	sreq	r9
80006cfc:	f5 e9 10 09 	or	r9,r10,r9
80006d00:	1b fa       	ld.ub	r10,sp[0x7]
80006d02:	f4 09 18 00 	cp.b	r9,r10
80006d06:	c1 b1       	brne	80006d3c <reader_txt_get_line+0x16c>
      || ('\n' == u16_unicode ) )
         break;      // End of line

      u16_size_line++;
80006d08:	2f f6       	sub	r6,-1
80006d0a:	5c 86       	casts.h	r6
      // Fill string
      if( 1 < u16_str_size )
80006d0c:	30 1a       	mov	r10,1
80006d0e:	f4 07 19 00 	cp.h	r7,r10
80006d12:	e0 88 00 0f 	brls	80006d30 <reader_txt_get_line+0x160>
      {
         if( b_unicode )
80006d16:	40 29       	lddsp	r9,sp[0x8]
         {
            ((FS_STR_UNICODE)string)[0] = u16_unicode;
80006d18:	58 09       	cp.w	r9,0
80006d1a:	eb f8 1c 00 	st.hne	r5[0x0],r8
80006d1e:	f9 b8 01 02 	movne	r8,2
         }else{
            string[0] = u16_unicode;
80006d22:	eb f8 0e 00 	st.beq	r5[0x0],r8
80006d26:	f9 b8 00 01 	moveq	r8,1
         }
         string += (b_unicode? 2 : 1 );
80006d2a:	10 05       	add	r5,r8
         u16_str_size--;
80006d2c:	20 17       	sub	r7,1
80006d2e:	5c 87       	casts.h	r7
   uint16_t   u16_unicode;
   bool  b_error = false;

   nav_checkdisk_disable();   // To optimize speed

   while( 0 == file_eof() && !b_error )
80006d30:	f0 1f 00 1b 	mcall	80006d9c <reader_txt_get_line+0x1cc>
80006d34:	c0 41       	brne	80006d3c <reader_txt_get_line+0x16c>
80006d36:	58 03       	cp.w	r3,0
80006d38:	fe 90 ff 5d 	breq	80006bf2 <reader_txt_get_line+0x22>
         u16_str_size--;
      }
   }
   // HERE, the line is read

   if( UNI_TYPE_UTF8 == fs_g_nav_entry.u8_txt_format )
80006d3c:	49 38       	lddpc	r8,80006d88 <reader_txt_get_line+0x1b8>
80006d3e:	11 99       	ld.ub	r9,r8[0x1]
80006d40:	30 38       	mov	r8,3
80006d42:	f0 09 18 00 	cp.b	r9,r8
80006d46:	c0 71       	brne	80006d54 <reader_txt_get_line+0x184>
   {
      // Re position cursor on next UTF8
      file_seek( (size_utf8_buf-size_utf8_dec) , FS_SEEK_CUR_RE );
80006d48:	30 2b       	mov	r11,2
80006d4a:	40 08       	lddsp	r8,sp[0x0]
80006d4c:	e8 08 01 0c 	sub	r12,r4,r8
80006d50:	f0 1f 00 14 	mcall	80006da0 <reader_txt_get_line+0x1d0>
   }

   // Handle error cases
   if (b_error)
80006d54:	58 03       	cp.w	r3,0
80006d56:	c0 50       	breq	80006d60 <reader_txt_get_line+0x190>
   {
     nav_checkdisk_enable();
80006d58:	f0 1f 00 13 	mcall	80006da4 <reader_txt_get_line+0x1d4>
80006d5c:	30 06       	mov	r6,0
     return 0;
80006d5e:	c0 f8       	rjmp	80006d7c <reader_txt_get_line+0x1ac>
   }

   // Add Null terminate
   if( 0 != u16_str_size )
80006d60:	58 07       	cp.w	r7,0
80006d62:	c0 b0       	breq	80006d78 <reader_txt_get_line+0x1a8>
   {
      if( b_unicode )
80006d64:	40 2a       	lddsp	r10,sp[0x8]
      {
         ((FS_STR_UNICODE)string)[0] = 0;
80006d66:	58 0a       	cp.w	r10,0
80006d68:	f9 b8 01 00 	movne	r8,0
80006d6c:	eb f8 1c 00 	st.hne	r5[0x0],r8
      }else{
         string[0] = 0;
80006d70:	f9 b8 00 00 	moveq	r8,0
80006d74:	eb f8 0e 00 	st.beq	r5[0x0],r8
      }
   }
   nav_checkdisk_enable();
80006d78:	f0 1f 00 0b 	mcall	80006da4 <reader_txt_get_line+0x1d4>
   return u16_size_line;
}
80006d7c:	0c 9c       	mov	r12,r6
80006d7e:	2f ad       	sub	sp,-24
80006d80:	d8 32       	popm	r0-r7,pc
80006d82:	00 00       	add	r0,r0
80006d84:	80 00       	ld.sh	r0,r0[0x0]
80006d86:	62 c8       	ld.w	r8,r1[0x30]
80006d88:	00 00       	add	r0,r0
80006d8a:	13 8c       	ld.ub	r12,r9[0x0]
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	60 98       	ld.w	r8,r0[0x24]
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	6e ac       	ld.w	r12,r7[0x28]
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	60 2c       	ld.w	r12,r0[0x8]
80006d98:	00 00       	add	r0,r0
80006d9a:	16 1c       	sub	r12,r11
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	5f 18       	srne	r8
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	5f 3c       	srlo	r12
80006da4:	80 00       	ld.sh	r0,r0[0x0]
80006da6:	62 d4       	ld.w	r4,r1[0x34]

80006da8 <reader_txt_beg>:


//! This function goes at the beginning of file and read the text header
//!
void  reader_txt_beg( void )
{
80006da8:	eb cd 40 80 	pushm	r7,lr
80006dac:	20 1d       	sub	sp,4
   // Table to store the header of text file
   uint8_t    string_header[UNI_MAX_HEADER_SIZE];

   file_seek( 0, FS_SEEK_SET );  // go to at the beginning of file
80006dae:	30 0b       	mov	r11,0
80006db0:	16 9c       	mov	r12,r11
80006db2:	f0 1f 00 0d 	mcall	80006de4 <reader_txt_beg+0x3c>

   // Read the header to detect the text format (ASCII, UNICODE LE, UNICODE BE, UTF8)
   memset( string_header, 0, UNI_MAX_HEADER_SIZE );     // By default ASCII
80006db6:	1a 97       	mov	r7,sp
80006db8:	30 08       	mov	r8,0
80006dba:	ba 08       	st.h	sp[0x0],r8
80006dbc:	ba a8       	st.b	sp[0x2],r8
   file_read_buf( string_header , UNI_MAX_HEADER_SIZE );
80006dbe:	30 3b       	mov	r11,3
80006dc0:	1a 9c       	mov	r12,sp
80006dc2:	f0 1f 00 0a 	mcall	80006de8 <reader_txt_beg+0x40>
   fs_g_nav_entry.u8_txt_format = unicode_header_scan( string_header );
80006dc6:	1a 9c       	mov	r12,sp
80006dc8:	f0 1f 00 09 	mcall	80006dec <reader_txt_beg+0x44>
80006dcc:	18 9b       	mov	r11,r12
80006dce:	48 98       	lddpc	r8,80006df0 <reader_txt_beg+0x48>
80006dd0:	b0 9c       	st.b	r8[0x1],r12
   // Set cursor after header
   file_seek( unicode_header_get( string_header, fs_g_nav_entry.u8_txt_format ), FS_SEEK_SET );
80006dd2:	1a 9c       	mov	r12,sp
80006dd4:	f0 1f 00 08 	mcall	80006df4 <reader_txt_beg+0x4c>
80006dd8:	30 0b       	mov	r11,0
80006dda:	f0 1f 00 03 	mcall	80006de4 <reader_txt_beg+0x3c>
}
80006dde:	2f fd       	sub	sp,-4
80006de0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	5f 3c       	srlo	r12
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	60 98       	ld.w	r8,r0[0x24]
80006dec:	80 00       	ld.sh	r0,r0[0x0]
80006dee:	6e 1c       	ld.w	r12,r7[0x4]
80006df0:	00 00       	add	r0,r0
80006df2:	13 8c       	ld.ub	r12,r9[0x0]
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	6e 6a       	ld.w	r10,r7[0x18]

80006df8 <reader_txt_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  reader_txt_open( bool b_readonly )
{
80006df8:	d4 01       	pushm	lr
   if( !file_open( (b_readonly)? FOPEN_MODE_R : FOPEN_MODE_R_PLUS ) )
80006dfa:	58 0c       	cp.w	r12,0
80006dfc:	f9 bc 01 09 	movne	r12,9
80006e00:	f9 bc 00 0b 	moveq	r12,11
80006e04:	f0 1f 00 04 	mcall	80006e14 <reader_txt_open+0x1c>
80006e08:	c0 40       	breq	80006e10 <reader_txt_open+0x18>
      return false; // Open error
   reader_txt_beg();
80006e0a:	f0 1f 00 04 	mcall	80006e18 <reader_txt_open+0x20>
80006e0e:	30 1c       	mov	r12,1
   return true;
}
80006e10:	d8 02       	popm	pc
80006e12:	00 00       	add	r0,r0
80006e14:	80 00       	ld.sh	r0,r0[0x0]
80006e16:	62 28       	ld.w	r8,r1[0x8]
80006e18:	80 00       	ld.sh	r0,r0[0x0]
80006e1a:	6d a8       	ld.w	r8,r6[0x68]

80006e1c <unicode_header_scan>:
//!
//! @return text format identifier
//!
uint8_t    unicode_header_scan( uint8_t* header )
{
   if( (header[0] == 0xEF)
80006e1c:	19 88       	ld.ub	r8,r12[0x0]
80006e1e:	3e f9       	mov	r9,-17
80006e20:	f2 08 18 00 	cp.b	r8,r9
80006e24:	c0 d1       	brne	80006e3e <unicode_header_scan+0x22>
   &&  (header[1] == 0xBB)
80006e26:	19 9a       	ld.ub	r10,r12[0x1]
80006e28:	3b b9       	mov	r9,-69
80006e2a:	f2 0a 18 00 	cp.b	r10,r9
80006e2e:	c0 81       	brne	80006e3e <unicode_header_scan+0x22>
   &&  (header[2] == 0xBF) )
80006e30:	19 a9       	ld.ub	r9,r12[0x2]
80006e32:	3b f8       	mov	r8,-65
80006e34:	f0 09 18 00 	cp.b	r9,r8
80006e38:	c1 81       	brne	80006e68 <unicode_header_scan+0x4c>
80006e3a:	30 3c       	mov	r12,3
80006e3c:	5e fc       	retal	r12
   {
      return UNI_TYPE_UTF8;
   }
   if( (header[0] == 0xFE)
80006e3e:	3f e9       	mov	r9,-2
80006e40:	f2 08 18 00 	cp.b	r8,r9
80006e44:	c0 81       	brne	80006e54 <unicode_header_scan+0x38>
   &&  (header[1] == 0xFF) )
80006e46:	19 99       	ld.ub	r9,r12[0x1]
80006e48:	3f f8       	mov	r8,-1
80006e4a:	f0 09 18 00 	cp.b	r9,r8
80006e4e:	c0 d1       	brne	80006e68 <unicode_header_scan+0x4c>
80006e50:	30 2c       	mov	r12,2
80006e52:	5e fc       	retal	r12
   {
      return UNI_TYPE_UTF16BE;
   }
   if( (header[0] == 0xFF)
80006e54:	3f f9       	mov	r9,-1
80006e56:	f2 08 18 00 	cp.b	r8,r9
80006e5a:	c0 71       	brne	80006e68 <unicode_header_scan+0x4c>
80006e5c:	19 99       	ld.ub	r9,r12[0x1]
80006e5e:	3f e8       	mov	r8,-2
80006e60:	f0 09 18 00 	cp.b	r9,r8
80006e64:	5f 0c       	sreq	r12
80006e66:	5e fc       	retal	r12
80006e68:	5e fd       	retal	0

80006e6a <unicode_header_get>:
//!
//! @return the size of header
//!
uint8_t    unicode_header_get( uint8_t* header, uint8_t txt_format )
{
   switch( txt_format )
80006e6a:	30 28       	mov	r8,2
80006e6c:	f0 0b 18 00 	cp.b	r11,r8
80006e70:	c1 20       	breq	80006e94 <unicode_header_get+0x2a>
80006e72:	30 38       	mov	r8,3
80006e74:	f0 0b 18 00 	cp.b	r11,r8
80006e78:	c0 60       	breq	80006e84 <unicode_header_get+0x1a>
80006e7a:	30 18       	mov	r8,1
80006e7c:	f0 0b 18 00 	cp.b	r11,r8
80006e80:	c1 00       	breq	80006ea0 <unicode_header_get+0x36>
80006e82:	5e fd       	retal	0
   {
      case UNI_TYPE_UTF8:
      header[0] = 0xEF;
80006e84:	3e f8       	mov	r8,-17
80006e86:	b8 88       	st.b	r12[0x0],r8
      header[1] = 0xBB;
80006e88:	3b b8       	mov	r8,-69
80006e8a:	b8 98       	st.b	r12[0x1],r8
      header[2] = 0xBF;
80006e8c:	3b f8       	mov	r8,-65
80006e8e:	b8 a8       	st.b	r12[0x2],r8
80006e90:	30 3c       	mov	r12,3
      return 3;
80006e92:	5e fc       	retal	r12

      case UNI_TYPE_UTF16BE:
      header[0] = 0xFE;
80006e94:	3f e8       	mov	r8,-2
80006e96:	b8 88       	st.b	r12[0x0],r8
      header[1] = 0xFF;
80006e98:	3f f8       	mov	r8,-1
80006e9a:	b8 98       	st.b	r12[0x1],r8
80006e9c:	30 2c       	mov	r12,2
      return 2;
80006e9e:	5e fc       	retal	r12

      case UNI_TYPE_UTF16LE:
      header[0] = 0xFF;
80006ea0:	3f f8       	mov	r8,-1
80006ea2:	b8 88       	st.b	r12[0x0],r8
      header[1] = 0xFE;
80006ea4:	3f e8       	mov	r8,-2
80006ea6:	b8 98       	st.b	r12[0x1],r8
80006ea8:	30 2c       	mov	r12,2
      return 2;
   }
   return 0;
}
80006eaa:	5e fc       	retal	r12

80006eac <utf8_to_unicode>:
//! @param  unicode  pointer used to store the character unicode decoded
//!
//! @return the size of UTF8 decoded
//!
uint8_t    utf8_to_unicode( uint8_t* utf8, uint16_t* unicode )
{
80006eac:	d4 01       	pushm	lr
   uint8_t c0,c1,c2;

   // Take 3 bytes
   c0 = utf8[0];
80006eae:	19 88       	ld.ub	r8,r12[0x0]
   c1 = utf8[1];
80006eb0:	19 9a       	ld.ub	r10,r12[0x1]
   c2 = utf8[2];
80006eb2:	19 ac       	ld.ub	r12,r12[0x2]

   if( 0x00 == (c0 & 0x80) )
80006eb4:	30 09       	mov	r9,0
80006eb6:	f2 08 18 00 	cp.b	r8,r9
80006eba:	c0 35       	brlt	80006ec0 <utf8_to_unicode+0x14>
   {
      *unicode = c0;
80006ebc:	b6 08       	st.h	r11[0x0],r8
80006ebe:	da 0a       	popm	pc,r12=1
      return 1;
   }
   if( 0xC0 == (c0 & 0xE0) )
80006ec0:	10 9e       	mov	lr,r8
80006ec2:	e2 1e 00 e0 	andl	lr,0xe0,COH
80006ec6:	e0 4e 00 c0 	cp.w	lr,192
80006eca:	c0 a1       	brne	80006ede <utf8_to_unicode+0x32>
   {
      *unicode = ((uint16_t)(c0 & 0x1F)<<6) | ((uint16_t)(c1 & 0x3F));
80006ecc:	f3 d8 c0 05 	bfextu	r9,r8,0x0,0x5
80006ed0:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
80006ed4:	f5 e9 10 69 	or	r9,r10,r9<<0x6
80006ed8:	b6 09       	st.h	r11[0x0],r9
80006eda:	30 2c       	mov	r12,2
      return 2;
80006edc:	d8 02       	popm	pc
   }
   if( 0xE0 == (c0 & 0xF0) )
80006ede:	10 9e       	mov	lr,r8
80006ee0:	e2 1e 00 f0 	andl	lr,0xf0,COH
80006ee4:	e0 4e 00 e0 	cp.w	lr,224
80006ee8:	c0 c1       	brne	80006f00 <utf8_to_unicode+0x54>
   {
      *unicode = ((uint16_t)(c0 & 0x0F)<<(6+6)) | ((uint16_t)(c1 & 0x3F)<<(6)) | ((uint16_t)(c2 & 0x3F));
80006eea:	f9 dc c0 06 	bfextu	r12,r12,0x0,0x6
80006eee:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
80006ef2:	f9 e8 10 c9 	or	r9,r12,r8<<0xc
80006ef6:	f3 ea 10 69 	or	r9,r9,r10<<0x6
80006efa:	b6 09       	st.h	r11[0x0],r9
80006efc:	30 3c       	mov	r12,3
      return 3;
80006efe:	d8 02       	popm	pc
   }
   // Error !
   *unicode = c0;
80006f00:	b6 08       	st.h	r11[0x0],r8
80006f02:	da 0a       	popm	pc,r12=1

80006f04 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80006f04:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80006f06:	f0 1f 00 02 	mcall	80006f0c <print+0x8>
}
80006f0a:	d8 02       	popm	pc
80006f0c:	80 00       	ld.sh	r0,r0[0x0]
80006f0e:	a2 2c       	st.h	r1[0x4],r12

80006f10 <print_ulong>:
  usart_putchar(usart, c);
}


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
80006f10:	eb cd 40 e0 	pushm	r5-r7,lr
80006f14:	20 3d       	sub	sp,12
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
80006f16:	30 08       	mov	r8,0
80006f18:	fb 68 00 0a 	st.b	sp[10],r8
80006f1c:	30 a9       	mov	r9,10
  do
  {
    tmp[--i] = '0' + n % 10;
80006f1e:	1a 95       	mov	r5,sp
80006f20:	e0 6e cc cd 	mov	lr,52429
80006f24:	ea 1e cc cc 	orh	lr,0xcccc
80006f28:	20 19       	sub	r9,1
80006f2a:	f6 0e 06 46 	mulu.d	r6,r11,lr
80006f2e:	0e 98       	mov	r8,r7
80006f30:	a3 98       	lsr	r8,0x3
80006f32:	f0 08 00 2a 	add	r10,r8,r8<<0x2
80006f36:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
80006f3a:	2d 0b       	sub	r11,-48
80006f3c:	ea 09 0b 0b 	st.b	r5[r9],r11
    n /= 10;
80006f40:	10 9b       	mov	r11,r8
  } while (n);
80006f42:	58 08       	cp.w	r8,0
80006f44:	cf 21       	brne	80006f28 <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
80006f46:	1a 9b       	mov	r11,sp
80006f48:	12 0b       	add	r11,r9
80006f4a:	f0 1f 00 03 	mcall	80006f54 <print_ulong+0x44>
}
80006f4e:	2f dd       	sub	sp,-12
80006f50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006f54:	80 00       	ld.sh	r0,r0[0x0]
80006f56:	6f 04       	ld.w	r4,r7[0x40]

80006f58 <print_dbg_ulong>:
  print_char(DBG_USART, c);
}


void print_dbg_ulong(unsigned long n)
{
80006f58:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
80006f5a:	18 9b       	mov	r11,r12
80006f5c:	fe 7c 14 00 	mov	r12,-60416
80006f60:	f0 1f 00 02 	mcall	80006f68 <print_dbg_ulong+0x10>
}
80006f64:	d8 02       	popm	pc
80006f66:	00 00       	add	r0,r0
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	6f 10       	ld.w	r0,r7[0x44]

80006f6c <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
80006f6c:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
80006f6e:	18 9b       	mov	r11,r12
80006f70:	fe 7c 14 00 	mov	r12,-60416
80006f74:	f0 1f 00 02 	mcall	80006f7c <print_dbg+0x10>
}
80006f78:	d8 02       	popm	pc
80006f7a:	00 00       	add	r0,r0
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	6f 04       	ld.w	r4,r7[0x40]

80006f80 <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
80006f80:	eb cd 40 80 	pushm	r7,lr
80006f84:	20 3d       	sub	sp,12
80006f86:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
80006f88:	50 0c       	stdsp	sp[0x0],r12
80006f8a:	30 88       	mov	r8,8
80006f8c:	ba c8       	st.b	sp[0x4],r8
80006f8e:	30 48       	mov	r8,4
80006f90:	ba d8       	st.b	sp[0x5],r8
80006f92:	30 08       	mov	r8,0
80006f94:	ba 38       	st.h	sp[0x6],r8
80006f96:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
80006f9a:	30 2b       	mov	r11,2
80006f9c:	48 6c       	lddpc	r12,80006fb4 <init_dbg_rs232_ex+0x34>
80006f9e:	f0 1f 00 07 	mcall	80006fb8 <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
80006fa2:	0e 9a       	mov	r10,r7
80006fa4:	1a 9b       	mov	r11,sp
80006fa6:	fe 7c 14 00 	mov	r12,-60416
80006faa:	f0 1f 00 05 	mcall	80006fbc <init_dbg_rs232_ex+0x3c>
}
80006fae:	2f dd       	sub	sp,-12
80006fb0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fb4:	80 00       	ld.sh	r0,r0[0x0]
80006fb6:	b7 38       	mul	r8,r11
80006fb8:	80 00       	ld.sh	r0,r0[0x0]
80006fba:	9d 88       	st.w	lr[0x20],r8
80006fbc:	80 00       	ld.sh	r0,r0[0x0]
80006fbe:	a2 7c       	st.h	r1[0xe],r12

80006fc0 <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80006fc0:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
80006fc2:	18 9b       	mov	r11,r12
80006fc4:	e0 6c e1 00 	mov	r12,57600
80006fc8:	f0 1f 00 02 	mcall	80006fd0 <init_dbg_rs232+0x10>
}
80006fcc:	d8 02       	popm	pc
80006fce:	00 00       	add	r0,r0
80006fd0:	80 00       	ld.sh	r0,r0[0x0]
80006fd2:	6f 80       	ld.w	r0,r7[0x60]

80006fd4 <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
80006fd4:	5e ff       	retal	1
80006fd6:	d7 03       	nop

80006fd8 <ctrl_access_lock>:
/*! \brief Locks accesses to LUNs.
 *
 * \return \c true if the access was successfully locked, else \c false.
 */
static bool ctrl_access_lock(void)
{
80006fd8:	eb cd 40 c0 	pushm	r6-r7,lr
  // If the semaphore could not be created, there is no backup solution.
  if (!ctrl_access_semphr) return false;
80006fdc:	48 88       	lddpc	r8,80006ffc <ctrl_access_lock+0x24>
80006fde:	70 08       	ld.w	r8,r8[0x0]
80006fe0:	58 08       	cp.w	r8,0
80006fe2:	c0 31       	brne	80006fe8 <ctrl_access_lock+0x10>
80006fe4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

  // Wait for the semaphore.
  while (!xSemaphoreTake(ctrl_access_semphr, portMAX_DELAY));
80006fe8:	48 56       	lddpc	r6,80006ffc <ctrl_access_lock+0x24>
80006fea:	3f f7       	mov	r7,-1
80006fec:	0e 9b       	mov	r11,r7
80006fee:	6c 0c       	ld.w	r12,r6[0x0]
80006ff0:	f0 1f 00 04 	mcall	80007000 <ctrl_access_lock+0x28>
80006ff4:	cf c0       	breq	80006fec <ctrl_access_lock+0x14>
80006ff6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006ffa:	00 00       	add	r0,r0
80006ffc:	00 00       	add	r0,r0
80006ffe:	05 98       	ld.ub	r8,r2[0x1]
80007000:	80 00       	ld.sh	r0,r0[0x0]
80007002:	77 40       	ld.w	r0,r11[0x50]

80007004 <ram_2_memory>:
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
80007004:	eb cd 40 e0 	pushm	r5-r7,lr
80007008:	18 97       	mov	r7,r12
8000700a:	16 95       	mov	r5,r11
8000700c:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
8000700e:	f0 1f 00 10 	mcall	8000704c <ram_2_memory+0x48>
80007012:	c0 31       	brne	80007018 <ram_2_memory+0x14>
80007014:	30 17       	mov	r7,1
80007016:	c1 88       	rjmp	80007046 <ram_2_memory+0x42>

  memory_start_write_action(1);
80007018:	30 2c       	mov	r12,2
8000701a:	f0 1f 00 0e 	mcall	80007050 <ram_2_memory+0x4c>
  status =
8000701e:	58 07       	cp.w	r7,0
80007020:	c0 30       	breq	80007026 <ram_2_memory+0x22>
80007022:	30 17       	mov	r7,1
80007024:	c0 78       	rjmp	80007032 <ram_2_memory+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
80007026:	48 c8       	lddpc	r8,80007054 <ram_2_memory+0x50>
80007028:	70 68       	ld.w	r8,r8[0x18]
8000702a:	0c 9b       	mov	r11,r6
8000702c:	0a 9c       	mov	r12,r5
8000702e:	5d 18       	icall	r8
80007030:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_ram_2_mem(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_write_action();
80007032:	30 2c       	mov	r12,2
80007034:	f0 1f 00 09 	mcall	80007058 <ram_2_memory+0x54>

  Ctrl_access_unlock();
80007038:	30 09       	mov	r9,0
8000703a:	12 9a       	mov	r10,r9
8000703c:	12 9b       	mov	r11,r9
8000703e:	48 88       	lddpc	r8,8000705c <ram_2_memory+0x58>
80007040:	70 0c       	ld.w	r12,r8[0x0]
80007042:	f0 1f 00 08 	mcall	80007060 <ram_2_memory+0x5c>

  return status;
}
80007046:	0e 9c       	mov	r12,r7
80007048:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000704c:	80 00       	ld.sh	r0,r0[0x0]
8000704e:	6f d8       	ld.w	r8,r7[0x74]
80007050:	80 00       	ld.sh	r0,r0[0x0]
80007052:	9c 6c       	ld.sh	r12,lr[0xc]
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	b7 48       	asr	r8,0x16
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	9c c8       	ld.uh	r8,lr[0x8]
8000705c:	00 00       	add	r0,r0
8000705e:	05 98       	ld.ub	r8,r2[0x1]
80007060:	80 00       	ld.sh	r0,r0[0x0]
80007062:	79 24       	ld.w	r4,r12[0x48]

80007064 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
80007064:	eb cd 40 e0 	pushm	r5-r7,lr
80007068:	18 97       	mov	r7,r12
8000706a:	16 95       	mov	r5,r11
8000706c:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
8000706e:	f0 1f 00 10 	mcall	800070ac <memory_2_ram+0x48>
80007072:	c0 31       	brne	80007078 <memory_2_ram+0x14>
80007074:	30 17       	mov	r7,1
80007076:	c1 88       	rjmp	800070a6 <memory_2_ram+0x42>

  memory_start_read_action(1);
80007078:	30 1c       	mov	r12,1
8000707a:	f0 1f 00 0e 	mcall	800070b0 <memory_2_ram+0x4c>
  status =
8000707e:	58 07       	cp.w	r7,0
80007080:	c0 30       	breq	80007086 <memory_2_ram+0x22>
80007082:	30 17       	mov	r7,1
80007084:	c0 78       	rjmp	80007092 <memory_2_ram+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
80007086:	48 c8       	lddpc	r8,800070b4 <memory_2_ram+0x50>
80007088:	70 58       	ld.w	r8,r8[0x14]
8000708a:	0c 9b       	mov	r11,r6
8000708c:	0a 9c       	mov	r12,r5
8000708e:	5d 18       	icall	r8
80007090:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_mem_2_ram(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_read_action();
80007092:	30 1c       	mov	r12,1
80007094:	f0 1f 00 09 	mcall	800070b8 <memory_2_ram+0x54>

  Ctrl_access_unlock();
80007098:	30 09       	mov	r9,0
8000709a:	12 9a       	mov	r10,r9
8000709c:	12 9b       	mov	r11,r9
8000709e:	48 88       	lddpc	r8,800070bc <memory_2_ram+0x58>
800070a0:	70 0c       	ld.w	r12,r8[0x0]
800070a2:	f0 1f 00 08 	mcall	800070c0 <memory_2_ram+0x5c>

  return status;
}
800070a6:	0e 9c       	mov	r12,r7
800070a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800070ac:	80 00       	ld.sh	r0,r0[0x0]
800070ae:	6f d8       	ld.w	r8,r7[0x74]
800070b0:	80 00       	ld.sh	r0,r0[0x0]
800070b2:	9c 6c       	ld.sh	r12,lr[0xc]
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	b7 48       	asr	r8,0x16
800070b8:	80 00       	ld.sh	r0,r0[0x0]
800070ba:	9c c8       	ld.uh	r8,lr[0x8]
800070bc:	00 00       	add	r0,r0
800070be:	05 98       	ld.ub	r8,r2[0x1]
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	79 24       	ld.w	r4,r12[0x48]

800070c4 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
800070c4:	eb cd 40 80 	pushm	r7,lr
800070c8:	18 97       	mov	r7,r12
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;
800070ca:	f0 1f 00 0c 	mcall	800070f8 <mem_wr_protect+0x34>
800070ce:	c0 31       	brne	800070d4 <mem_wr_protect+0x10>
800070d0:	30 17       	mov	r7,1
800070d2:	c1 08       	rjmp	800070f2 <mem_wr_protect+0x2e>

  wr_protect =
800070d4:	58 07       	cp.w	r7,0
800070d6:	c0 30       	breq	800070dc <mem_wr_protect+0x18>
800070d8:	30 17       	mov	r7,1
800070da:	c0 58       	rjmp	800070e4 <mem_wr_protect+0x20>
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
800070dc:	48 88       	lddpc	r8,800070fc <mem_wr_protect+0x38>
800070de:	70 3c       	ld.w	r12,r8[0xc]
800070e0:	5d 1c       	icall	r12
800070e2:	18 97       	mov	r7,r12
                                 Lun_usb_wr_protect(lun - LUN_ID_USB);
#else
                                 true;
#endif

  Ctrl_access_unlock();
800070e4:	30 09       	mov	r9,0
800070e6:	12 9a       	mov	r10,r9
800070e8:	12 9b       	mov	r11,r9
800070ea:	48 68       	lddpc	r8,80007100 <mem_wr_protect+0x3c>
800070ec:	70 0c       	ld.w	r12,r8[0x0]
800070ee:	f0 1f 00 06 	mcall	80007104 <mem_wr_protect+0x40>

  return wr_protect;
}
800070f2:	0e 9c       	mov	r12,r7
800070f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	6f d8       	ld.w	r8,r7[0x74]
800070fc:	80 00       	ld.sh	r0,r0[0x0]
800070fe:	b7 48       	asr	r8,0x16
80007100:	00 00       	add	r0,r0
80007102:	05 98       	ld.ub	r8,r2[0x1]
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	79 24       	ld.w	r4,r12[0x48]

80007108 <mem_sector_size>:
  return status;
}


U8 mem_sector_size(U8 lun)
{
80007108:	eb cd 40 80 	pushm	r7,lr
8000710c:	18 97       	mov	r7,r12
  U8 sector_size;

  if (!Ctrl_access_lock()) return 0;
8000710e:	f0 1f 00 0a 	mcall	80007134 <mem_sector_size+0x2c>
80007112:	c0 31       	brne	80007118 <mem_sector_size+0x10>
80007114:	30 07       	mov	r7,0
80007116:	c0 c8       	rjmp	8000712e <mem_sector_size+0x26>

  sector_size =
80007118:	30 08       	mov	r8,0
8000711a:	f0 07 18 00 	cp.b	r7,r8
8000711e:	5f 07       	sreq	r7
                                  Lun_usb_read_sector_size(lun - LUN_ID_USB);
#else
                                  0;
#endif

  Ctrl_access_unlock();
80007120:	30 09       	mov	r9,0
80007122:	12 9a       	mov	r10,r9
80007124:	12 9b       	mov	r11,r9
80007126:	48 58       	lddpc	r8,80007138 <mem_sector_size+0x30>
80007128:	70 0c       	ld.w	r12,r8[0x0]
8000712a:	f0 1f 00 05 	mcall	8000713c <mem_sector_size+0x34>

  return sector_size;
}
8000712e:	0e 9c       	mov	r12,r7
80007130:	e3 cd 80 80 	ldm	sp++,r7,pc
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	6f d8       	ld.w	r8,r7[0x74]
80007138:	00 00       	add	r0,r0
8000713a:	05 98       	ld.ub	r8,r2[0x1]
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	79 24       	ld.w	r4,r12[0x48]

80007140 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
80007140:	eb cd 40 80 	pushm	r7,lr
80007144:	18 97       	mov	r7,r12
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80007146:	f0 1f 00 0c 	mcall	80007174 <mem_test_unit_ready+0x34>
8000714a:	c0 31       	brne	80007150 <mem_test_unit_ready+0x10>
8000714c:	30 17       	mov	r7,1
8000714e:	c1 08       	rjmp	8000716e <mem_test_unit_ready+0x2e>

  status =
80007150:	58 07       	cp.w	r7,0
80007152:	c0 30       	breq	80007158 <mem_test_unit_ready+0x18>
80007154:	30 17       	mov	r7,1
80007156:	c0 58       	rjmp	80007160 <mem_test_unit_ready+0x20>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
80007158:	48 88       	lddpc	r8,80007178 <mem_test_unit_ready+0x38>
8000715a:	70 0c       	ld.w	r12,r8[0x0]
8000715c:	5d 1c       	icall	r12
8000715e:	18 97       	mov	r7,r12
                             Lun_usb_test_unit_ready(lun - LUN_ID_USB);
#else
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();
80007160:	30 09       	mov	r9,0
80007162:	12 9a       	mov	r10,r9
80007164:	12 9b       	mov	r11,r9
80007166:	48 68       	lddpc	r8,8000717c <mem_test_unit_ready+0x3c>
80007168:	70 0c       	ld.w	r12,r8[0x0]
8000716a:	f0 1f 00 06 	mcall	80007180 <mem_test_unit_ready+0x40>

  return status;
}
8000716e:	0e 9c       	mov	r12,r7
80007170:	e3 cd 80 80 	ldm	sp++,r7,pc
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	6f d8       	ld.w	r8,r7[0x74]
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	b7 48       	asr	r8,0x16
8000717c:	00 00       	add	r0,r0
8000717e:	05 98       	ld.ub	r8,r2[0x1]
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	79 24       	ld.w	r4,r12[0x48]

80007184 <ctrl_access_init>:


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
{
80007184:	d4 01       	pushm	lr
  // If the handle to the protecting semaphore is not valid,
  if (!ctrl_access_semphr)
80007186:	48 d8       	lddpc	r8,800071b8 <ctrl_access_init+0x34>
80007188:	70 08       	ld.w	r8,r8[0x0]
8000718a:	58 08       	cp.w	r8,0
8000718c:	c0 20       	breq	80007190 <ctrl_access_init+0xc>
8000718e:	da 0a       	popm	pc,r12=1
  {
    // try to create the semaphore.
    vSemaphoreCreateBinary(ctrl_access_semphr);
80007190:	30 3a       	mov	r10,3
80007192:	30 0b       	mov	r11,0
80007194:	30 1c       	mov	r12,1
80007196:	f0 1f 00 0a 	mcall	800071bc <ctrl_access_init+0x38>
8000719a:	48 88       	lddpc	r8,800071b8 <ctrl_access_init+0x34>
8000719c:	91 0c       	st.w	r8[0x0],r12
8000719e:	58 0c       	cp.w	r12,0
800071a0:	c0 a0       	breq	800071b4 <ctrl_access_init+0x30>
800071a2:	30 09       	mov	r9,0
800071a4:	12 9a       	mov	r10,r9
800071a6:	12 9b       	mov	r11,r9
800071a8:	f0 1f 00 06 	mcall	800071c0 <ctrl_access_init+0x3c>
//! @{


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
800071ac:	48 38       	lddpc	r8,800071b8 <ctrl_access_init+0x34>
800071ae:	70 08       	ld.w	r8,r8[0x0]
800071b0:	58 08       	cp.w	r8,0
800071b2:	5f 1c       	srne	r12
    // If the semaphore could not be created, there is no backup solution.
    if (!ctrl_access_semphr) return false;
  }

  return true;
}
800071b4:	d8 02       	popm	pc
800071b6:	00 00       	add	r0,r0
800071b8:	00 00       	add	r0,r0
800071ba:	05 98       	ld.ub	r8,r2[0x1]
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	7a b8       	ld.w	r8,sp[0x2c]
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	79 24       	ld.w	r4,r12[0x48]

800071c4 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
800071c4:	f8 c8 ff f8 	sub	r8,r12,-8
800071c8:	99 18       	st.w	r12[0x4],r8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
800071ca:	3f f9       	mov	r9,-1
800071cc:	99 29       	st.w	r12[0x8],r9

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
800071ce:	99 38       	st.w	r12[0xc],r8
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
800071d0:	99 48       	st.w	r12[0x10],r8

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
800071d2:	30 08       	mov	r8,0
800071d4:	99 08       	st.w	r12[0x0],r8

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
800071d6:	5e fc       	retal	r12

800071d8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
800071d8:	30 08       	mov	r8,0
800071da:	99 48       	st.w	r12[0x10],r8

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
800071dc:	5e fc       	retal	r12

800071de <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
800071de:	78 18       	ld.w	r8,r12[0x4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
800071e0:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
800071e2:	70 29       	ld.w	r9,r8[0x8]
800071e4:	97 29       	st.w	r11[0x8],r9

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
800071e6:	70 29       	ld.w	r9,r8[0x8]
800071e8:	93 1b       	st.w	r9[0x4],r11
    pxIndex->pxPrevious = pxNewListItem;
800071ea:	91 2b       	st.w	r8[0x8],r11

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
800071ec:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
800071ee:	78 08       	ld.w	r8,r12[0x0]
800071f0:	2f f8       	sub	r8,-1
800071f2:	99 08       	st.w	r12[0x0],r8
}
800071f4:	5e fc       	retal	r12

800071f6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
800071f6:	d4 01       	pushm	lr
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
800071f8:	76 0e       	ld.w	lr,r11[0x0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
800071fa:	5b fe       	cp.w	lr,-1
800071fc:	c0 31       	brne	80007202 <vListInsert+0xc>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
800071fe:	78 49       	ld.w	r9,r12[0x10]
80007200:	c0 98       	rjmp	80007212 <vListInsert+0x1c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
80007202:	f8 c9 ff f8 	sub	r9,r12,-8
80007206:	72 18       	ld.w	r8,r9[0x4]
80007208:	70 0a       	ld.w	r10,r8[0x0]
8000720a:	14 3e       	cp.w	lr,r10
8000720c:	c0 33       	brcs	80007212 <vListInsert+0x1c>
8000720e:	10 99       	mov	r9,r8
80007210:	cf bb       	rjmp	80007206 <vListInsert+0x10>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
80007212:	72 18       	ld.w	r8,r9[0x4]
80007214:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80007216:	91 2b       	st.w	r8[0x8],r11
    pxNewListItem->pxPrevious = pxIterator;
80007218:	97 29       	st.w	r11[0x8],r9
    pxIterator->pxNext = pxNewListItem;
8000721a:	93 1b       	st.w	r9[0x4],r11

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
8000721c:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
8000721e:	78 08       	ld.w	r8,r12[0x0]
80007220:	2f f8       	sub	r8,-1
80007222:	99 08       	st.w	r12[0x0],r8
}
80007224:	d8 02       	popm	pc

80007226 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
80007226:	78 48       	ld.w	r8,r12[0x10]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80007228:	78 19       	ld.w	r9,r12[0x4]
8000722a:	78 2a       	ld.w	r10,r12[0x8]
8000722c:	93 2a       	st.w	r9[0x8],r10
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000722e:	78 29       	ld.w	r9,r12[0x8]
80007230:	78 1a       	ld.w	r10,r12[0x4]
80007232:	93 1a       	st.w	r9[0x4],r10

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
80007234:	70 19       	ld.w	r9,r8[0x4]
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
80007236:	18 39       	cp.w	r9,r12
80007238:	f3 f9 00 02 	ld.weq	r9,r9[0x8]
8000723c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
80007240:	30 09       	mov	r9,0
80007242:	99 49       	st.w	r12[0x10],r9
    ( pxList->uxNumberOfItems )--;
80007244:	70 09       	ld.w	r9,r8[0x0]
80007246:	20 19       	sub	r9,1
80007248:	91 09       	st.w	r8[0x0],r9

    return pxList->uxNumberOfItems;
8000724a:	70 0c       	ld.w	r12,r8[0x0]
}
8000724c:	5e fc       	retal	r12

8000724e <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( StackType_t ) 0x08080808;					/* R8 */
8000724e:	e0 68 08 08 	mov	r8,2056
80007252:	ea 18 08 08 	orh	r8,0x808
80007256:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x09090909;					/* R9 */
80007258:	e0 68 09 09 	mov	r8,2313
8000725c:	ea 18 09 09 	orh	r8,0x909
80007260:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;					/* R10 */
80007262:	e0 68 0a 0a 	mov	r8,2570
80007266:	ea 18 0a 0a 	orh	r8,0xa0a
8000726a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;					/* R11 */
8000726c:	e0 68 0b 0b 	mov	r8,2827
80007270:	ea 18 0b 0b 	orh	r8,0xb0b
80007274:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pvParameters;					/* R12 */
80007276:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;					/* R14/LR */
80007278:	e0 68 be ef 	mov	r8,48879
8000727c:	ea 18 de ad 	orh	r8,0xdead
80007280:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80007282:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;				/* SR */
80007284:	fc 18 00 40 	movh	r8,0x40
80007288:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;					/* R0 */
8000728a:	e0 68 00 ff 	mov	r8,255
8000728e:	ea 18 ff 00 	orh	r8,0xff00
80007292:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x01010101;					/* R1 */
80007294:	e0 68 01 01 	mov	r8,257
80007298:	ea 18 01 01 	orh	r8,0x101
8000729c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x02020202;					/* R2 */
8000729e:	e0 68 02 02 	mov	r8,514
800072a2:	ea 18 02 02 	orh	r8,0x202
800072a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x03030303;					/* R3 */
800072a8:	e0 68 03 03 	mov	r8,771
800072ac:	ea 18 03 03 	orh	r8,0x303
800072b0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x04040404;					/* R4 */
800072b2:	e0 68 04 04 	mov	r8,1028
800072b6:	ea 18 04 04 	orh	r8,0x404
800072ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x05050505;					/* R5 */
800072bc:	e0 68 05 05 	mov	r8,1285
800072c0:	ea 18 05 05 	orh	r8,0x505
800072c4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x06060606;					/* R6 */
800072c6:	e0 68 06 06 	mov	r8,1542
800072ca:	ea 18 06 06 	orh	r8,0x606
800072ce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x07070707;					/* R7 */
800072d0:	e0 68 07 07 	mov	r8,1799
800072d4:	ea 18 07 07 	orh	r8,0x707
800072d8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800072da:	30 08       	mov	r8,0
800072dc:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800072de:	5e fc       	retal	r12

800072e0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800072e0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800072e2:	48 38       	lddpc	r8,800072ec <vPortEnterCritical+0xc>
800072e4:	70 09       	ld.w	r9,r8[0x0]
800072e6:	2f f9       	sub	r9,-1
800072e8:	91 09       	st.w	r8[0x0],r9
}
800072ea:	5e fc       	retal	r12
800072ec:	00 00       	add	r0,r0
800072ee:	00 24       	rsub	r4,r0

800072f0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
800072f0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800072f2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800072f4:	30 0a       	mov	r10,0
800072f6:	14 9b       	mov	r11,r10
800072f8:	49 2c       	lddpc	r12,80007340 <xPortStartScheduler+0x50>
800072fa:	f0 1f 00 13 	mcall	80007344 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
800072fe:	e0 68 f2 8c 	mov	r8,62092
80007302:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80007306:	30 08       	mov	r8,0
80007308:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000730c:	e0 68 06 58 	mov	r8,1624
80007310:	ea 18 00 00 	orh	r8,0x0
80007314:	70 00       	ld.w	r0,r8[0x0]
80007316:	60 0d       	ld.w	sp,r0[0x0]
80007318:	1b 00       	ld.w	r0,sp++
8000731a:	e0 68 00 24 	mov	r8,36
8000731e:	ea 18 00 00 	orh	r8,0x0
80007322:	91 00       	st.w	r8[0x0],r0
80007324:	e3 cd 00 ff 	ldm	sp++,r0-r7
80007328:	2f ed       	sub	sp,-8
8000732a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000732e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80007332:	e3 b0 00 00 	mtsr	0x0,r0
80007336:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000733a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000733e:	d8 0a       	popm	pc,r12=0
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	74 0c       	ld.w	r12,r10[0x0]
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	9e a8       	ld.uh	r8,pc[0x4]

80007348 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80007348:	20 6d       	sub	sp,24
8000734a:	eb cd 00 ff 	pushm	r0-r7
8000734e:	fa c7 ff c0 	sub	r7,sp,-64
80007352:	ee f0 ff f8 	ld.w	r0,r7[-8]
80007356:	ef 40 ff e0 	st.w	r7[-32],r0
8000735a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000735e:	ef 40 ff e4 	st.w	r7[-28],r0
80007362:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80007366:	e0 68 00 24 	mov	r8,36
8000736a:	ea 18 00 00 	orh	r8,0x0
8000736e:	70 00       	ld.w	r0,r8[0x0]
80007370:	1a d0       	st.w	--sp,r0
80007372:	f0 1f 00 1a 	mcall	800073d8 <LABEL_RET_SCALL_244+0x14>
80007376:	e0 68 06 58 	mov	r8,1624
8000737a:	ea 18 00 00 	orh	r8,0x0
8000737e:	70 00       	ld.w	r0,r8[0x0]
80007380:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80007382:	f0 1f 00 17 	mcall	800073dc <LABEL_RET_SCALL_244+0x18>
	portRESTORE_CONTEXT_SCALL();
80007386:	e0 68 06 58 	mov	r8,1624
8000738a:	ea 18 00 00 	orh	r8,0x0
8000738e:	70 00       	ld.w	r0,r8[0x0]
80007390:	60 0d       	ld.w	sp,r0[0x0]
80007392:	1b 00       	ld.w	r0,sp++
80007394:	e0 68 00 24 	mov	r8,36
80007398:	ea 18 00 00 	orh	r8,0x0
8000739c:	91 00       	st.w	r8[0x0],r0
8000739e:	fa c7 ff d8 	sub	r7,sp,-40
800073a2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800073a6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800073aa:	e0 61 00 24 	mov	r1,36
800073ae:	ea 11 00 00 	orh	r1,0x0
800073b2:	62 02       	ld.w	r2,r1[0x0]
800073b4:	58 02       	cp.w	r2,0
800073b6:	c0 70       	breq	800073c4 <LABEL_RET_SCALL_244>
800073b8:	e4 c2 00 01 	sub	r2,r2,1
800073bc:	83 02       	st.w	r1[0x0],r2
800073be:	58 02       	cp.w	r2,0
800073c0:	c0 21       	brne	800073c4 <LABEL_RET_SCALL_244>
800073c2:	b1 c0       	cbr	r0,0x10

800073c4 <LABEL_RET_SCALL_244>:
800073c4:	ef 40 ff f8 	st.w	r7[-8],r0
800073c8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800073cc:	ef 40 ff fc 	st.w	r7[-4],r0
800073d0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800073d4:	2f ad       	sub	sp,-24
800073d6:	d6 13       	rets
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	72 e0       	ld.w	r0,r9[0x38]
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	7b 28       	ld.w	r8,sp[0x48]

800073e0 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800073e0:	e1 b8 00 43 	mfsr	r8,0x10c
800073e4:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800073e8:	5e fc       	retal	r12
800073ea:	d7 03       	nop

800073ec <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800073ec:	48 78       	lddpc	r8,80007408 <vPortExitCritical+0x1c>
800073ee:	70 08       	ld.w	r8,r8[0x0]
800073f0:	58 08       	cp.w	r8,0
800073f2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800073f4:	48 58       	lddpc	r8,80007408 <vPortExitCritical+0x1c>
800073f6:	70 09       	ld.w	r9,r8[0x0]
800073f8:	20 19       	sub	r9,1
800073fa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800073fc:	70 08       	ld.w	r8,r8[0x0]
800073fe:	58 08       	cp.w	r8,0
80007400:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80007402:	d5 03       	csrf	0x10
80007404:	5e fc       	retal	r12
80007406:	00 00       	add	r0,r0
80007408:	00 00       	add	r0,r0
8000740a:	00 24       	rsub	r4,r0

8000740c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000740c:	eb cd 00 ff 	pushm	r0-r7
80007410:	e0 68 00 24 	mov	r8,36
80007414:	ea 18 00 00 	orh	r8,0x0
80007418:	70 00       	ld.w	r0,r8[0x0]
8000741a:	1a d0       	st.w	--sp,r0
8000741c:	7a 90       	ld.w	r0,sp[0x24]
8000741e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80007422:	58 10       	cp.w	r0,1
80007424:	e0 8b 00 08 	brhi	80007434 <LABEL_INT_SKIP_SAVE_CONTEXT_217>
80007428:	e0 68 06 58 	mov	r8,1624
8000742c:	ea 18 00 00 	orh	r8,0x0
80007430:	70 00       	ld.w	r0,r8[0x0]
80007432:	81 0d       	st.w	r0[0x0],sp

80007434 <LABEL_INT_SKIP_SAVE_CONTEXT_217>:
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
		clock cycles from now. */
		prvClearCcInt();
80007434:	f0 1f 00 12 	mcall	8000747c <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80007438:	f0 1f 00 12 	mcall	80007480 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x18>
		xTaskIncrementTick();
8000743c:	f0 1f 00 12 	mcall	80007484 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x1c>
	portEXIT_CRITICAL();
80007440:	f0 1f 00 12 	mcall	80007488 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80007444:	7a 90       	ld.w	r0,sp[0x24]
80007446:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000744a:	58 10       	cp.w	r0,1
8000744c:	e0 8b 00 0e 	brhi	80007468 <LABEL_INT_SKIP_RESTORE_CONTEXT_235>
80007450:	f0 1f 00 0c 	mcall	80007480 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x18>
80007454:	f0 1f 00 0e 	mcall	8000748c <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x24>
80007458:	f0 1f 00 0c 	mcall	80007488 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x20>
8000745c:	e0 68 06 58 	mov	r8,1624
80007460:	ea 18 00 00 	orh	r8,0x0
80007464:	70 00       	ld.w	r0,r8[0x0]
80007466:	60 0d       	ld.w	sp,r0[0x0]

80007468 <LABEL_INT_SKIP_RESTORE_CONTEXT_235>:
80007468:	1b 00       	ld.w	r0,sp++
8000746a:	e0 68 00 24 	mov	r8,36
8000746e:	ea 18 00 00 	orh	r8,0x0
80007472:	91 00       	st.w	r8[0x0],r0
80007474:	e3 cd 00 ff 	ldm	sp++,r0-r7
80007478:	d6 03       	rete
8000747a:	00 00       	add	r0,r0
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	73 e0       	ld.w	r0,r9[0x78]
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	72 e0       	ld.w	r0,r9[0x38]
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	7f 74       	ld.w	r4,pc[0x5c]
80007488:	80 00       	ld.sh	r0,r0[0x0]
8000748a:	73 ec       	ld.w	r12,r9[0x78]
8000748c:	80 00       	ld.sh	r0,r0[0x0]
8000748e:	7b 28       	ld.w	r8,sp[0x48]

80007490 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80007490:	d4 01       	pushm	lr
	vTaskSuspendAll();
80007492:	f0 1f 00 02 	mcall	80007498 <__malloc_lock+0x8>
}
80007496:	d8 02       	popm	pc
80007498:	80 00       	ld.sh	r0,r0[0x0]
8000749a:	7b 18       	ld.w	r8,sp[0x44]

8000749c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000749c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000749e:	f0 1f 00 02 	mcall	800074a4 <__malloc_unlock+0x8>
}
800074a2:	d8 02       	popm	pc
800074a4:	80 00       	ld.sh	r0,r0[0x0]
800074a6:	80 7c       	ld.sh	r12,r0[0xe]

800074a8 <_init_startup>:
 * vectors are not compatible with the SCALL management in the current FreeRTOS
 * port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
800074a8:	d4 01       	pushm	lr
		extern void __heap_end__;
		BaseType_t *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
800074aa:	48 b8       	lddpc	r8,800074d4 <_init_startup+0x2c>
800074ac:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
800074b0:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
800074b2:	f0 1f 00 0a 	mcall	800074d8 <_init_startup+0x30>
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		//extern volatile avr32_usart_t *volatile stdio_usart_base;
		//stdio_usart_base = configDBG_USART;
		gpio_enable_module( DBG_USART_GPIO_MAP,
800074b6:	30 2b       	mov	r11,2
800074b8:	48 9c       	lddpc	r12,800074dc <_init_startup+0x34>
800074ba:	f0 1f 00 0a 	mcall	800074e0 <_init_startup+0x38>
		sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
800074be:	e0 6a 76 00 	mov	r10,30208
800074c2:	ea 1a 03 b3 	orh	r10,0x3b3
800074c6:	48 8b       	lddpc	r11,800074e4 <_init_startup+0x3c>
800074c8:	fe 7c 18 00 	mov	r12,-59392
800074cc:	f0 1f 00 07 	mcall	800074e8 <_init_startup+0x40>
	}
	#endif
	
	// Don't-care value for GCC.
	return 1;
}
800074d0:	da 0a       	popm	pc,r12=1
800074d2:	00 00       	add	r0,r0
800074d4:	80 00       	ld.sh	r0,r0[0x0]
800074d6:	b0 00       	st.h	r8[0x0],r0
800074d8:	80 00       	ld.sh	r0,r0[0x0]
800074da:	9f 28       	st.w	pc[0x8],r8
800074dc:	80 00       	ld.sh	r0,r0[0x0]
800074de:	b7 8c       	lsr	r12,0x16
800074e0:	80 00       	ld.sh	r0,r0[0x0]
800074e2:	9d 88       	st.w	lr[0x20],r8
800074e4:	80 00       	ld.sh	r0,r0[0x0]
800074e6:	b7 80       	lsr	r0,0x16
800074e8:	80 00       	ld.sh	r0,r0[0x0]
800074ea:	a2 7c       	st.h	r1[0xe],r12

800074ec <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
800074ec:	eb cd 40 80 	pushm	r7,lr
800074f0:	18 97       	mov	r7,r12
    if( pv )
800074f2:	58 0c       	cp.w	r12,0
800074f4:	c0 80       	breq	80007504 <vPortFree+0x18>
    {
        vTaskSuspendAll();
800074f6:	f0 1f 00 05 	mcall	80007508 <vPortFree+0x1c>
        {
            free( pv );
800074fa:	0e 9c       	mov	r12,r7
800074fc:	f0 1f 00 04 	mcall	8000750c <vPortFree+0x20>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
80007500:	f0 1f 00 04 	mcall	80007510 <vPortFree+0x24>
80007504:	e3 cd 80 80 	ldm	sp++,r7,pc
80007508:	80 00       	ld.sh	r0,r0[0x0]
8000750a:	7b 18       	ld.w	r8,sp[0x44]
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	a5 dc       	cbr	r12,0x5
80007510:	80 00       	ld.sh	r0,r0[0x0]
80007512:	80 7c       	ld.sh	r12,r0[0xe]

80007514 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
80007514:	eb cd 40 80 	pushm	r7,lr
80007518:	18 97       	mov	r7,r12
    void * pvReturn;

    vTaskSuspendAll();
8000751a:	f0 1f 00 06 	mcall	80007530 <pvPortMalloc+0x1c>
    {
        pvReturn = malloc( xWantedSize );
8000751e:	0e 9c       	mov	r12,r7
80007520:	f0 1f 00 05 	mcall	80007534 <pvPortMalloc+0x20>
80007524:	18 97       	mov	r7,r12
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
80007526:	f0 1f 00 05 	mcall	80007538 <pvPortMalloc+0x24>
            }
        }
    #endif

    return pvReturn;
}
8000752a:	0e 9c       	mov	r12,r7
8000752c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007530:	80 00       	ld.sh	r0,r0[0x0]
80007532:	7b 18       	ld.w	r8,sp[0x44]
80007534:	80 00       	ld.sh	r0,r0[0x0]
80007536:	a5 ec       	*unknown*
80007538:	80 00       	ld.sh	r0,r0[0x0]
8000753a:	80 7c       	ld.sh	r12,r0[0xe]

8000753c <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
8000753c:	eb cd 40 80 	pushm	r7,lr
80007540:	18 97       	mov	r7,r12
    BaseType_t xReturn;

    taskENTER_CRITICAL();
80007542:	f0 1f 00 05 	mcall	80007554 <prvIsQueueEmpty+0x18>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
80007546:	6e e7       	ld.w	r7,r7[0x38]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
80007548:	f0 1f 00 04 	mcall	80007558 <prvIsQueueEmpty+0x1c>
8000754c:	58 07       	cp.w	r7,0

    return xReturn;
}
8000754e:	5f 0c       	sreq	r12
80007550:	e3 cd 80 80 	ldm	sp++,r7,pc
80007554:	80 00       	ld.sh	r0,r0[0x0]
80007556:	72 e0       	ld.w	r0,r9[0x38]
80007558:	80 00       	ld.sh	r0,r0[0x0]
8000755a:	73 ec       	ld.w	r12,r9[0x78]

8000755c <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
8000755c:	d4 01       	pushm	lr
8000755e:	16 98       	mov	r8,r11
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80007560:	79 09       	ld.w	r9,r12[0x40]
80007562:	58 09       	cp.w	r9,0
80007564:	c1 00       	breq	80007584 <prvCopyDataFromQueue+0x28>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
80007566:	78 3a       	ld.w	r10,r12[0xc]
80007568:	f4 09 00 09 	add	r9,r10,r9
8000756c:	99 39       	st.w	r12[0xc],r9

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
8000756e:	78 2a       	ld.w	r10,r12[0x8]
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
80007570:	14 39       	cp.w	r9,r10
80007572:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80007576:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
8000757a:	79 0a       	ld.w	r10,r12[0x40]
8000757c:	78 3b       	ld.w	r11,r12[0xc]
8000757e:	10 9c       	mov	r12,r8
80007580:	f0 1f 00 02 	mcall	80007588 <prvCopyDataFromQueue+0x2c>
80007584:	d8 02       	popm	pc
80007586:	00 00       	add	r0,r0
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	aa 30       	st.h	r5[0x6],r0

8000758c <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
8000758c:	d4 21       	pushm	r4-r7,lr
8000758e:	18 96       	mov	r6,r12

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
80007590:	f0 1f 00 25 	mcall	80007624 <prvUnlockQueue+0x98>
    {
        int8_t cTxLock = pxQueue->cTxLock;
80007594:	ed 37 00 45 	ld.ub	r7,r6[69]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80007598:	30 08       	mov	r8,0
8000759a:	f0 07 18 00 	cp.b	r7,r8
8000759e:	e0 8a 00 18 	brle	800075ce <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800075a2:	6c 98       	ld.w	r8,r6[0x24]
800075a4:	58 08       	cp.w	r8,0
800075a6:	c1 40       	breq	800075ce <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800075a8:	ec c4 ff dc 	sub	r4,r6,-36
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
800075ac:	30 05       	mov	r5,0
800075ae:	c0 48       	rjmp	800075b6 <prvUnlockQueue+0x2a>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800075b0:	6c 98       	ld.w	r8,r6[0x24]
800075b2:	58 08       	cp.w	r8,0
800075b4:	c0 d0       	breq	800075ce <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800075b6:	08 9c       	mov	r12,r4
800075b8:	f0 1f 00 1c 	mcall	80007628 <prvUnlockQueue+0x9c>
800075bc:	c0 30       	breq	800075c2 <prvUnlockQueue+0x36>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
800075be:	f0 1f 00 1c 	mcall	8000762c <prvUnlockQueue+0xa0>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
800075c2:	20 17       	sub	r7,1
800075c4:	5c 57       	castu.b	r7
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
800075c6:	ea 07 18 00 	cp.b	r7,r5
800075ca:	fe 99 ff f3 	brgt	800075b0 <prvUnlockQueue+0x24>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
800075ce:	3f f8       	mov	r8,-1
800075d0:	ed 68 00 45 	st.b	r6[69],r8
    }
    taskEXIT_CRITICAL();
800075d4:	f0 1f 00 17 	mcall	80007630 <prvUnlockQueue+0xa4>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
800075d8:	f0 1f 00 13 	mcall	80007624 <prvUnlockQueue+0x98>
    {
        int8_t cRxLock = pxQueue->cRxLock;
800075dc:	ed 37 00 44 	ld.ub	r7,r6[68]

        while( cRxLock > queueLOCKED_UNMODIFIED )
800075e0:	30 08       	mov	r8,0
800075e2:	f0 07 18 00 	cp.b	r7,r8
800075e6:	e0 8a 00 18 	brle	80007616 <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800075ea:	6c 48       	ld.w	r8,r6[0x10]
800075ec:	58 08       	cp.w	r8,0
800075ee:	c1 40       	breq	80007616 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800075f0:	ec c4 ff f0 	sub	r4,r6,-16
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
800075f4:	30 05       	mov	r5,0
800075f6:	c0 48       	rjmp	800075fe <prvUnlockQueue+0x72>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800075f8:	6c 48       	ld.w	r8,r6[0x10]
800075fa:	58 08       	cp.w	r8,0
800075fc:	c0 d0       	breq	80007616 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800075fe:	08 9c       	mov	r12,r4
80007600:	f0 1f 00 0a 	mcall	80007628 <prvUnlockQueue+0x9c>
80007604:	c0 30       	breq	8000760a <prvUnlockQueue+0x7e>
                {
                    vTaskMissedYield();
80007606:	f0 1f 00 0a 	mcall	8000762c <prvUnlockQueue+0xa0>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
8000760a:	20 17       	sub	r7,1
8000760c:	5c 57       	castu.b	r7
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
8000760e:	ea 07 18 00 	cp.b	r7,r5
80007612:	fe 99 ff f3 	brgt	800075f8 <prvUnlockQueue+0x6c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
80007616:	3f f8       	mov	r8,-1
80007618:	ed 68 00 44 	st.b	r6[68],r8
    }
    taskEXIT_CRITICAL();
8000761c:	f0 1f 00 05 	mcall	80007630 <prvUnlockQueue+0xa4>
}
80007620:	d8 22       	popm	r4-r7,pc
80007622:	00 00       	add	r0,r0
80007624:	80 00       	ld.sh	r0,r0[0x0]
80007626:	72 e0       	ld.w	r0,r9[0x38]
80007628:	80 00       	ld.sh	r0,r0[0x0]
8000762a:	7e e8       	ld.w	r8,pc[0x38]
8000762c:	80 00       	ld.sh	r0,r0[0x0]
8000762e:	7b b4       	ld.w	r4,sp[0x6c]
80007630:	80 00       	ld.sh	r0,r0[0x0]
80007632:	73 ec       	ld.w	r12,r9[0x78]

80007634 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
80007634:	d4 31       	pushm	r0-r7,lr
80007636:	20 5d       	sub	sp,20
80007638:	18 97       	mov	r7,r12
8000763a:	50 1b       	stdsp	sp[0x4],r11
8000763c:	50 2a       	stdsp	sp[0x8],r10
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000763e:	f8 c8 ff dc 	sub	r8,r12,-36
80007642:	50 08       	stdsp	sp[0x0],r8
80007644:	30 04       	mov	r4,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007646:	fa c3 ff f4 	sub	r3,sp,-12
8000764a:	30 10       	mov	r0,1

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
8000764c:	3f f5       	mov	r5,-1
8000764e:	30 01       	mov	r1,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007650:	fa c2 ff f8 	sub	r2,sp,-8
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80007654:	f0 1f 00 30 	mcall	80007714 <xQueueReceive+0xe0>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80007658:	6e e6       	ld.w	r6,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
8000765a:	58 06       	cp.w	r6,0
8000765c:	c1 40       	breq	80007684 <xQueueReceive+0x50>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
8000765e:	40 1b       	lddsp	r11,sp[0x4]
80007660:	0e 9c       	mov	r12,r7
80007662:	f0 1f 00 2e 	mcall	80007718 <xQueueReceive+0xe4>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
80007666:	20 16       	sub	r6,1
80007668:	8f e6       	st.w	r7[0x38],r6

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000766a:	6e 48       	ld.w	r8,r7[0x10]
8000766c:	58 08       	cp.w	r8,0
8000766e:	c0 70       	breq	8000767c <xQueueReceive+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007670:	ee cc ff f0 	sub	r12,r7,-16
80007674:	f0 1f 00 2a 	mcall	8000771c <xQueueReceive+0xe8>
80007678:	c0 20       	breq	8000767c <xQueueReceive+0x48>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
8000767a:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
8000767c:	f0 1f 00 29 	mcall	80007720 <xQueueReceive+0xec>
80007680:	30 1c       	mov	r12,1
                return pdPASS;
80007682:	c4 78       	rjmp	80007710 <xQueueReceive+0xdc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007684:	40 28       	lddsp	r8,sp[0x8]
80007686:	58 08       	cp.w	r8,0
80007688:	c0 51       	brne	80007692 <xQueueReceive+0x5e>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
8000768a:	f0 1f 00 26 	mcall	80007720 <xQueueReceive+0xec>
8000768e:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80007690:	c4 08       	rjmp	80007710 <xQueueReceive+0xdc>
                }
                else if( xEntryTimeSet == pdFALSE )
80007692:	58 04       	cp.w	r4,0
80007694:	c0 51       	brne	8000769e <xQueueReceive+0x6a>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007696:	06 9c       	mov	r12,r3
80007698:	f0 1f 00 23 	mcall	80007724 <xQueueReceive+0xf0>
8000769c:	00 94       	mov	r4,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
8000769e:	f0 1f 00 21 	mcall	80007720 <xQueueReceive+0xec>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
800076a2:	f0 1f 00 22 	mcall	80007728 <xQueueReceive+0xf4>
        prvLockQueue( pxQueue );
800076a6:	f0 1f 00 1c 	mcall	80007714 <xQueueReceive+0xe0>
800076aa:	ef 38 00 44 	ld.ub	r8,r7[68]
800076ae:	ea 08 18 00 	cp.b	r8,r5
800076b2:	ef f1 0e 44 	st.beq	r7[0x44],r1
800076b6:	ef 38 00 45 	ld.ub	r8,r7[69]
800076ba:	ea 08 18 00 	cp.b	r8,r5
800076be:	ef f1 0e 45 	st.beq	r7[0x45],r1
800076c2:	f0 1f 00 18 	mcall	80007720 <xQueueReceive+0xec>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800076c6:	04 9b       	mov	r11,r2
800076c8:	06 9c       	mov	r12,r3
800076ca:	f0 1f 00 19 	mcall	8000772c <xQueueReceive+0xf8>
800076ce:	c1 71       	brne	800076fc <xQueueReceive+0xc8>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800076d0:	0e 9c       	mov	r12,r7
800076d2:	f0 1f 00 18 	mcall	80007730 <xQueueReceive+0xfc>
800076d6:	c0 d0       	breq	800076f0 <xQueueReceive+0xbc>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800076d8:	40 2b       	lddsp	r11,sp[0x8]
800076da:	40 0c       	lddsp	r12,sp[0x0]
800076dc:	f0 1f 00 16 	mcall	80007734 <xQueueReceive+0x100>
                prvUnlockQueue( pxQueue );
800076e0:	0e 9c       	mov	r12,r7
800076e2:	f0 1f 00 16 	mcall	80007738 <xQueueReceive+0x104>

                if( xTaskResumeAll() == pdFALSE )
800076e6:	f0 1f 00 16 	mcall	8000773c <xQueueReceive+0x108>
800076ea:	cb 51       	brne	80007654 <xQueueReceive+0x20>
                {
                    portYIELD_WITHIN_API();
800076ec:	d7 33       	scall
800076ee:	cb 3b       	rjmp	80007654 <xQueueReceive+0x20>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
800076f0:	0e 9c       	mov	r12,r7
800076f2:	f0 1f 00 12 	mcall	80007738 <xQueueReceive+0x104>
                ( void ) xTaskResumeAll();
800076f6:	f0 1f 00 12 	mcall	8000773c <xQueueReceive+0x108>
800076fa:	ca db       	rjmp	80007654 <xQueueReceive+0x20>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
800076fc:	0e 9c       	mov	r12,r7
800076fe:	f0 1f 00 0f 	mcall	80007738 <xQueueReceive+0x104>
            ( void ) xTaskResumeAll();
80007702:	f0 1f 00 0f 	mcall	8000773c <xQueueReceive+0x108>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80007706:	0e 9c       	mov	r12,r7
80007708:	f0 1f 00 0a 	mcall	80007730 <xQueueReceive+0xfc>
8000770c:	ca 40       	breq	80007654 <xQueueReceive+0x20>
8000770e:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
80007710:	2f bd       	sub	sp,-20
80007712:	d8 32       	popm	r0-r7,pc
80007714:	80 00       	ld.sh	r0,r0[0x0]
80007716:	72 e0       	ld.w	r0,r9[0x38]
80007718:	80 00       	ld.sh	r0,r0[0x0]
8000771a:	75 5c       	ld.w	r12,r10[0x54]
8000771c:	80 00       	ld.sh	r0,r0[0x0]
8000771e:	7e e8       	ld.w	r8,pc[0x38]
80007720:	80 00       	ld.sh	r0,r0[0x0]
80007722:	73 ec       	ld.w	r12,r9[0x78]
80007724:	80 00       	ld.sh	r0,r0[0x0]
80007726:	7b 9c       	ld.w	r12,sp[0x64]
80007728:	80 00       	ld.sh	r0,r0[0x0]
8000772a:	7b 18       	ld.w	r8,sp[0x44]
8000772c:	80 00       	ld.sh	r0,r0[0x0]
8000772e:	7c 08       	ld.w	r8,lr[0x0]
80007730:	80 00       	ld.sh	r0,r0[0x0]
80007732:	75 3c       	ld.w	r12,r10[0x4c]
80007734:	80 00       	ld.sh	r0,r0[0x0]
80007736:	84 88       	ld.uh	r8,r2[0x0]
80007738:	80 00       	ld.sh	r0,r0[0x0]
8000773a:	75 8c       	ld.w	r12,r10[0x60]
8000773c:	80 00       	ld.sh	r0,r0[0x0]
8000773e:	80 7c       	ld.sh	r12,r0[0xe]

80007740 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
80007740:	d4 31       	pushm	r0-r7,lr
80007742:	20 4d       	sub	sp,16
80007744:	18 97       	mov	r7,r12
80007746:	50 1b       	stdsp	sp[0x4],r11
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007748:	f8 c1 ff dc 	sub	r1,r12,-36
8000774c:	30 08       	mov	r8,0
8000774e:	50 08       	stdsp	sp[0x0],r8
80007750:	10 95       	mov	r5,r8
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007752:	fa c4 ff f8 	sub	r4,sp,-8
80007756:	30 10       	mov	r0,1

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
80007758:	3f f6       	mov	r6,-1
8000775a:	30 02       	mov	r2,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000775c:	fa c3 ff fc 	sub	r3,sp,-4
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80007760:	f0 1f 00 42 	mcall	80007868 <xQueueSemaphoreTake+0x128>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
80007764:	6e e8       	ld.w	r8,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
80007766:	58 08       	cp.w	r8,0
80007768:	c1 60       	breq	80007794 <xQueueSemaphoreTake+0x54>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
8000776a:	20 18       	sub	r8,1
8000776c:	8f e8       	st.w	r7[0x38],r8

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000776e:	6e 08       	ld.w	r8,r7[0x0]
80007770:	58 08       	cp.w	r8,0
80007772:	c0 41       	brne	8000777a <xQueueSemaphoreTake+0x3a>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
80007774:	f0 1f 00 3e 	mcall	8000786c <xQueueSemaphoreTake+0x12c>
80007778:	8f 2c       	st.w	r7[0x8],r12
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000777a:	6e 48       	ld.w	r8,r7[0x10]
8000777c:	58 08       	cp.w	r8,0
8000777e:	c0 70       	breq	8000778c <xQueueSemaphoreTake+0x4c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007780:	ee cc ff f0 	sub	r12,r7,-16
80007784:	f0 1f 00 3b 	mcall	80007870 <xQueueSemaphoreTake+0x130>
80007788:	c0 20       	breq	8000778c <xQueueSemaphoreTake+0x4c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
8000778a:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
8000778c:	f0 1f 00 3a 	mcall	80007874 <xQueueSemaphoreTake+0x134>
80007790:	30 1c       	mov	r12,1
                return pdPASS;
80007792:	c6 88       	rjmp	80007862 <xQueueSemaphoreTake+0x122>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007794:	40 18       	lddsp	r8,sp[0x4]
80007796:	58 08       	cp.w	r8,0
80007798:	c0 51       	brne	800077a2 <xQueueSemaphoreTake+0x62>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
8000779a:	f0 1f 00 37 	mcall	80007874 <xQueueSemaphoreTake+0x134>
8000779e:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
800077a0:	c6 18       	rjmp	80007862 <xQueueSemaphoreTake+0x122>
                }
                else if( xEntryTimeSet == pdFALSE )
800077a2:	58 05       	cp.w	r5,0
800077a4:	c0 51       	brne	800077ae <xQueueSemaphoreTake+0x6e>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800077a6:	08 9c       	mov	r12,r4
800077a8:	f0 1f 00 34 	mcall	80007878 <xQueueSemaphoreTake+0x138>
800077ac:	00 95       	mov	r5,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
800077ae:	f0 1f 00 32 	mcall	80007874 <xQueueSemaphoreTake+0x134>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
800077b2:	f0 1f 00 33 	mcall	8000787c <xQueueSemaphoreTake+0x13c>
        prvLockQueue( pxQueue );
800077b6:	f0 1f 00 2d 	mcall	80007868 <xQueueSemaphoreTake+0x128>
800077ba:	ef 38 00 44 	ld.ub	r8,r7[68]
800077be:	ec 08 18 00 	cp.b	r8,r6
800077c2:	ef f2 0e 44 	st.beq	r7[0x44],r2
800077c6:	ef 38 00 45 	ld.ub	r8,r7[69]
800077ca:	ec 08 18 00 	cp.b	r8,r6
800077ce:	ef f2 0e 45 	st.beq	r7[0x45],r2
800077d2:	f0 1f 00 29 	mcall	80007874 <xQueueSemaphoreTake+0x134>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800077d6:	06 9b       	mov	r11,r3
800077d8:	08 9c       	mov	r12,r4
800077da:	f0 1f 00 2a 	mcall	80007880 <xQueueSemaphoreTake+0x140>
800077de:	c2 21       	brne	80007822 <xQueueSemaphoreTake+0xe2>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800077e0:	0e 9c       	mov	r12,r7
800077e2:	f0 1f 00 29 	mcall	80007884 <xQueueSemaphoreTake+0x144>
800077e6:	c1 80       	breq	80007816 <xQueueSemaphoreTake+0xd6>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800077e8:	6e 08       	ld.w	r8,r7[0x0]
800077ea:	58 08       	cp.w	r8,0
800077ec:	c0 91       	brne	800077fe <xQueueSemaphoreTake+0xbe>
                        {
                            taskENTER_CRITICAL();
800077ee:	f0 1f 00 1f 	mcall	80007868 <xQueueSemaphoreTake+0x128>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
800077f2:	6e 2c       	ld.w	r12,r7[0x8]
800077f4:	f0 1f 00 25 	mcall	80007888 <xQueueSemaphoreTake+0x148>
800077f8:	50 0c       	stdsp	sp[0x0],r12
                            }
                            taskEXIT_CRITICAL();
800077fa:	f0 1f 00 1f 	mcall	80007874 <xQueueSemaphoreTake+0x134>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800077fe:	40 1b       	lddsp	r11,sp[0x4]
80007800:	02 9c       	mov	r12,r1
80007802:	f0 1f 00 23 	mcall	8000788c <xQueueSemaphoreTake+0x14c>
                prvUnlockQueue( pxQueue );
80007806:	0e 9c       	mov	r12,r7
80007808:	f0 1f 00 22 	mcall	80007890 <xQueueSemaphoreTake+0x150>

                if( xTaskResumeAll() == pdFALSE )
8000780c:	f0 1f 00 22 	mcall	80007894 <xQueueSemaphoreTake+0x154>
80007810:	ca 81       	brne	80007760 <xQueueSemaphoreTake+0x20>
                {
                    portYIELD_WITHIN_API();
80007812:	d7 33       	scall
80007814:	ca 6b       	rjmp	80007760 <xQueueSemaphoreTake+0x20>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
80007816:	0e 9c       	mov	r12,r7
80007818:	f0 1f 00 1e 	mcall	80007890 <xQueueSemaphoreTake+0x150>
                ( void ) xTaskResumeAll();
8000781c:	f0 1f 00 1e 	mcall	80007894 <xQueueSemaphoreTake+0x154>
80007820:	ca 0b       	rjmp	80007760 <xQueueSemaphoreTake+0x20>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
80007822:	0e 9c       	mov	r12,r7
80007824:	f0 1f 00 1b 	mcall	80007890 <xQueueSemaphoreTake+0x150>
            ( void ) xTaskResumeAll();
80007828:	f0 1f 00 1b 	mcall	80007894 <xQueueSemaphoreTake+0x154>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
8000782c:	0e 9c       	mov	r12,r7
8000782e:	f0 1f 00 16 	mcall	80007884 <xQueueSemaphoreTake+0x144>
80007832:	c9 70       	breq	80007760 <xQueueSemaphoreTake+0x20>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
80007834:	40 08       	lddsp	r8,sp[0x0]
80007836:	58 08       	cp.w	r8,0
80007838:	c0 31       	brne	8000783e <xQueueSemaphoreTake+0xfe>
8000783a:	30 0c       	mov	r12,0
8000783c:	c1 38       	rjmp	80007862 <xQueueSemaphoreTake+0x122>
                        {
                            taskENTER_CRITICAL();
8000783e:	f0 1f 00 0b 	mcall	80007868 <xQueueSemaphoreTake+0x128>
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
80007842:	6e 98       	ld.w	r8,r7[0x24]
80007844:	58 08       	cp.w	r8,0
80007846:	f9 bb 00 00 	moveq	r11,0
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
8000784a:	ef f8 10 0c 	ld.wne	r8,r7[0x30]
8000784e:	f1 fb 10 00 	ld.wne	r11,r8[0x0]
80007852:	fb bb 01 08 	rsubne	r11,8
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
80007856:	6e 2c       	ld.w	r12,r7[0x8]
80007858:	f0 1f 00 10 	mcall	80007898 <xQueueSemaphoreTake+0x158>
                            }
                            taskEXIT_CRITICAL();
8000785c:	f0 1f 00 06 	mcall	80007874 <xQueueSemaphoreTake+0x134>
80007860:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
80007862:	2f cd       	sub	sp,-16
80007864:	d8 32       	popm	r0-r7,pc
80007866:	00 00       	add	r0,r0
80007868:	80 00       	ld.sh	r0,r0[0x0]
8000786a:	72 e0       	ld.w	r0,r9[0x38]
8000786c:	80 00       	ld.sh	r0,r0[0x0]
8000786e:	7b e8       	ld.w	r8,sp[0x78]
80007870:	80 00       	ld.sh	r0,r0[0x0]
80007872:	7e e8       	ld.w	r8,pc[0x38]
80007874:	80 00       	ld.sh	r0,r0[0x0]
80007876:	73 ec       	ld.w	r12,r9[0x78]
80007878:	80 00       	ld.sh	r0,r0[0x0]
8000787a:	7b 9c       	ld.w	r12,sp[0x64]
8000787c:	80 00       	ld.sh	r0,r0[0x0]
8000787e:	7b 18       	ld.w	r8,sp[0x44]
80007880:	80 00       	ld.sh	r0,r0[0x0]
80007882:	7c 08       	ld.w	r8,lr[0x0]
80007884:	80 00       	ld.sh	r0,r0[0x0]
80007886:	75 3c       	ld.w	r12,r10[0x4c]
80007888:	80 00       	ld.sh	r0,r0[0x0]
8000788a:	7e 44       	ld.w	r4,pc[0x10]
8000788c:	80 00       	ld.sh	r0,r0[0x0]
8000788e:	84 88       	ld.uh	r8,r2[0x0]
80007890:	80 00       	ld.sh	r0,r0[0x0]
80007892:	75 8c       	ld.w	r12,r10[0x60]
80007894:	80 00       	ld.sh	r0,r0[0x0]
80007896:	80 7c       	ld.sh	r12,r0[0xe]
80007898:	80 00       	ld.sh	r0,r0[0x0]
8000789a:	7d 60       	ld.w	r0,lr[0x58]

8000789c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
8000789c:	eb cd 40 e0 	pushm	r5-r7,lr
800078a0:	18 97       	mov	r7,r12
800078a2:	14 96       	mov	r6,r10
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
800078a4:	78 e5       	ld.w	r5,r12[0x38]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
800078a6:	79 0a       	ld.w	r10,r12[0x40]
800078a8:	58 0a       	cp.w	r10,0
800078aa:	c0 a1       	brne	800078be <prvCopyDataToQueue+0x22>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800078ac:	78 08       	ld.w	r8,r12[0x0]
800078ae:	58 08       	cp.w	r8,0
800078b0:	c3 11       	brne	80007912 <prvCopyDataToQueue+0x76>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
800078b2:	78 2c       	ld.w	r12,r12[0x8]
800078b4:	f0 1f 00 1a 	mcall	8000791c <prvCopyDataToQueue+0x80>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
800078b8:	30 08       	mov	r8,0
800078ba:	8f 28       	st.w	r7[0x8],r8
800078bc:	c2 c8       	rjmp	80007914 <prvCopyDataToQueue+0x78>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
800078be:	58 06       	cp.w	r6,0
800078c0:	c1 01       	brne	800078e0 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
800078c2:	78 1c       	ld.w	r12,r12[0x4]
800078c4:	f0 1f 00 17 	mcall	80007920 <prvCopyDataToQueue+0x84>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
800078c8:	6e 19       	ld.w	r9,r7[0x4]
800078ca:	6f 08       	ld.w	r8,r7[0x40]
800078cc:	f2 08 00 08 	add	r8,r9,r8
800078d0:	8f 18       	st.w	r7[0x4],r8

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
800078d2:	6e 29       	ld.w	r9,r7[0x8]
800078d4:	12 38       	cp.w	r8,r9
800078d6:	c1 e3       	brcs	80007912 <prvCopyDataToQueue+0x76>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
800078d8:	6e 08       	ld.w	r8,r7[0x0]
800078da:	8f 18       	st.w	r7[0x4],r8
800078dc:	30 0c       	mov	r12,0
800078de:	c1 b8       	rjmp	80007914 <prvCopyDataToQueue+0x78>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
800078e0:	78 3c       	ld.w	r12,r12[0xc]
800078e2:	f0 1f 00 10 	mcall	80007920 <prvCopyDataToQueue+0x84>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
800078e6:	6f 08       	ld.w	r8,r7[0x40]
800078e8:	6e 39       	ld.w	r9,r7[0xc]
800078ea:	f2 08 01 08 	sub	r8,r9,r8
800078ee:	8f 38       	st.w	r7[0xc],r8

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
800078f0:	6e 09       	ld.w	r9,r7[0x0]
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
800078f2:	12 38       	cp.w	r8,r9
800078f4:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800078f8:	ef f9 30 02 	ld.wcs	r9,r7[0x8]
800078fc:	f3 d8 e3 19 	subcs	r9,r9,r8
80007900:	ef f9 3a 03 	st.wcs	r7[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
80007904:	58 26       	cp.w	r6,2
80007906:	c0 61       	brne	80007912 <prvCopyDataToQueue+0x76>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80007908:	58 05       	cp.w	r5,0
8000790a:	c0 40       	breq	80007912 <prvCopyDataToQueue+0x76>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
8000790c:	20 15       	sub	r5,1
8000790e:	30 0c       	mov	r12,0
80007910:	c0 28       	rjmp	80007914 <prvCopyDataToQueue+0x78>
80007912:	30 0c       	mov	r12,0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
80007914:	2f f5       	sub	r5,-1
80007916:	8f e5       	st.w	r7[0x38],r5

    return xReturn;
}
80007918:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000791c:	80 00       	ld.sh	r0,r0[0x0]
8000791e:	7d dc       	ld.w	r12,lr[0x74]
80007920:	80 00       	ld.sh	r0,r0[0x0]
80007922:	aa 30       	st.h	r5[0x6],r0

80007924 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
80007924:	d4 31       	pushm	r0-r7,lr
80007926:	20 5d       	sub	sp,20
80007928:	18 97       	mov	r7,r12
8000792a:	50 1b       	stdsp	sp[0x4],r11
8000792c:	50 2a       	stdsp	sp[0x8],r10
8000792e:	12 91       	mov	r1,r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007930:	f8 c8 ff f0 	sub	r8,r12,-16
80007934:	50 08       	stdsp	sp[0x0],r8
80007936:	30 03       	mov	r3,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007938:	fa c2 ff f4 	sub	r2,sp,-12

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
8000793c:	3f f5       	mov	r5,-1

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000793e:	fa c0 ff f8 	sub	r0,sp,-8
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80007942:	f0 1f 00 36 	mcall	80007a18 <xQueueGenericSend+0xf4>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80007946:	6e e9       	ld.w	r9,r7[0x38]
80007948:	6e f8       	ld.w	r8,r7[0x3c]
8000794a:	10 39       	cp.w	r9,r8
8000794c:	c0 33       	brcs	80007952 <xQueueGenericSend+0x2e>
8000794e:	58 21       	cp.w	r1,2
80007950:	c1 71       	brne	8000797e <xQueueGenericSend+0x5a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007952:	02 9a       	mov	r10,r1
80007954:	40 1b       	lddsp	r11,sp[0x4]
80007956:	0e 9c       	mov	r12,r7
80007958:	f0 1f 00 31 	mcall	80007a1c <xQueueGenericSend+0xf8>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000795c:	6e 98       	ld.w	r8,r7[0x24]
8000795e:	58 08       	cp.w	r8,0
80007960:	c0 80       	breq	80007970 <xQueueGenericSend+0x4c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007962:	ee cc ff dc 	sub	r12,r7,-36
80007966:	f0 1f 00 2f 	mcall	80007a20 <xQueueGenericSend+0xfc>
8000796a:	c0 60       	breq	80007976 <xQueueGenericSend+0x52>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
8000796c:	d7 33       	scall
8000796e:	c0 48       	rjmp	80007976 <xQueueGenericSend+0x52>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
80007970:	58 0c       	cp.w	r12,0
80007972:	c0 20       	breq	80007976 <xQueueGenericSend+0x52>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
80007974:	d7 33       	scall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
80007976:	f0 1f 00 2c 	mcall	80007a24 <xQueueGenericSend+0x100>
8000797a:	30 1c       	mov	r12,1
                return pdPASS;
8000797c:	c4 b8       	rjmp	80007a12 <xQueueGenericSend+0xee>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
8000797e:	40 28       	lddsp	r8,sp[0x8]
80007980:	58 08       	cp.w	r8,0
80007982:	c0 51       	brne	8000798c <xQueueGenericSend+0x68>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
80007984:	f0 1f 00 28 	mcall	80007a24 <xQueueGenericSend+0x100>
80007988:	30 0c       	mov	r12,0

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
8000798a:	c4 48       	rjmp	80007a12 <xQueueGenericSend+0xee>
                }
                else if( xEntryTimeSet == pdFALSE )
8000798c:	58 03       	cp.w	r3,0
8000798e:	c0 51       	brne	80007998 <xQueueGenericSend+0x74>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007990:	04 9c       	mov	r12,r2
80007992:	f0 1f 00 26 	mcall	80007a28 <xQueueGenericSend+0x104>
80007996:	30 13       	mov	r3,1
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80007998:	f0 1f 00 23 	mcall	80007a24 <xQueueGenericSend+0x100>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
8000799c:	f0 1f 00 24 	mcall	80007a2c <xQueueGenericSend+0x108>
        prvLockQueue( pxQueue );
800079a0:	f0 1f 00 1e 	mcall	80007a18 <xQueueGenericSend+0xf4>
800079a4:	ef 38 00 44 	ld.ub	r8,r7[68]
800079a8:	ea 08 18 00 	cp.b	r8,r5
800079ac:	f9 b8 00 00 	moveq	r8,0
800079b0:	ef f8 0e 44 	st.beq	r7[0x44],r8
800079b4:	ef 38 00 45 	ld.ub	r8,r7[69]
800079b8:	ea 08 18 00 	cp.b	r8,r5
800079bc:	f9 b8 00 00 	moveq	r8,0
800079c0:	ef f8 0e 45 	st.beq	r7[0x45],r8
800079c4:	f0 1f 00 18 	mcall	80007a24 <xQueueGenericSend+0x100>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800079c8:	00 9b       	mov	r11,r0
800079ca:	04 9c       	mov	r12,r2
800079cc:	f0 1f 00 19 	mcall	80007a30 <xQueueGenericSend+0x10c>
800079d0:	c1 b1       	brne	80007a06 <xQueueGenericSend+0xe2>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
800079d2:	f0 1f 00 12 	mcall	80007a18 <xQueueGenericSend+0xf4>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
800079d6:	6e e4       	ld.w	r4,r7[0x38]
800079d8:	6e f6       	ld.w	r6,r7[0x3c]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
800079da:	f0 1f 00 13 	mcall	80007a24 <xQueueGenericSend+0x100>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
800079de:	0c 34       	cp.w	r4,r6
800079e0:	c0 d1       	brne	800079fa <xQueueGenericSend+0xd6>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800079e2:	40 2b       	lddsp	r11,sp[0x8]
800079e4:	40 0c       	lddsp	r12,sp[0x0]
800079e6:	f0 1f 00 14 	mcall	80007a34 <xQueueGenericSend+0x110>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
800079ea:	0e 9c       	mov	r12,r7
800079ec:	f0 1f 00 13 	mcall	80007a38 <xQueueGenericSend+0x114>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
800079f0:	f0 1f 00 13 	mcall	80007a3c <xQueueGenericSend+0x118>
800079f4:	ca 71       	brne	80007942 <xQueueGenericSend+0x1e>
                {
                    portYIELD_WITHIN_API();
800079f6:	d7 33       	scall
800079f8:	ca 5b       	rjmp	80007942 <xQueueGenericSend+0x1e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
800079fa:	0e 9c       	mov	r12,r7
800079fc:	f0 1f 00 0f 	mcall	80007a38 <xQueueGenericSend+0x114>
                ( void ) xTaskResumeAll();
80007a00:	f0 1f 00 0f 	mcall	80007a3c <xQueueGenericSend+0x118>
80007a04:	c9 fb       	rjmp	80007942 <xQueueGenericSend+0x1e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
80007a06:	0e 9c       	mov	r12,r7
80007a08:	f0 1f 00 0c 	mcall	80007a38 <xQueueGenericSend+0x114>
            ( void ) xTaskResumeAll();
80007a0c:	f0 1f 00 0c 	mcall	80007a3c <xQueueGenericSend+0x118>
80007a10:	30 0c       	mov	r12,0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
80007a12:	2f bd       	sub	sp,-20
80007a14:	d8 32       	popm	r0-r7,pc
80007a16:	00 00       	add	r0,r0
80007a18:	80 00       	ld.sh	r0,r0[0x0]
80007a1a:	72 e0       	ld.w	r0,r9[0x38]
80007a1c:	80 00       	ld.sh	r0,r0[0x0]
80007a1e:	78 9c       	ld.w	r12,r12[0x24]
80007a20:	80 00       	ld.sh	r0,r0[0x0]
80007a22:	7e e8       	ld.w	r8,pc[0x38]
80007a24:	80 00       	ld.sh	r0,r0[0x0]
80007a26:	73 ec       	ld.w	r12,r9[0x78]
80007a28:	80 00       	ld.sh	r0,r0[0x0]
80007a2a:	7b 9c       	ld.w	r12,sp[0x64]
80007a2c:	80 00       	ld.sh	r0,r0[0x0]
80007a2e:	7b 18       	ld.w	r8,sp[0x44]
80007a30:	80 00       	ld.sh	r0,r0[0x0]
80007a32:	7c 08       	ld.w	r8,lr[0x0]
80007a34:	80 00       	ld.sh	r0,r0[0x0]
80007a36:	84 88       	ld.uh	r8,r2[0x0]
80007a38:	80 00       	ld.sh	r0,r0[0x0]
80007a3a:	75 8c       	ld.w	r12,r10[0x60]
80007a3c:	80 00       	ld.sh	r0,r0[0x0]
80007a3e:	80 7c       	ld.sh	r12,r0[0xe]

80007a40 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
80007a40:	eb cd 40 c0 	pushm	r6-r7,lr
80007a44:	18 97       	mov	r7,r12
80007a46:	16 96       	mov	r6,r11
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
80007a48:	f0 1f 00 18 	mcall	80007aa8 <xQueueGenericReset+0x68>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
80007a4c:	6f 09       	ld.w	r9,r7[0x40]
80007a4e:	6e fa       	ld.w	r10,r7[0x3c]
80007a50:	f2 0a 02 4b 	mul	r11,r9,r10
80007a54:	6e 08       	ld.w	r8,r7[0x0]
80007a56:	f0 0b 00 0b 	add	r11,r8,r11
80007a5a:	8f 2b       	st.w	r7[0x8],r11
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80007a5c:	30 0b       	mov	r11,0
80007a5e:	8f eb       	st.w	r7[0x38],r11
        pxQueue->pcWriteTo = pxQueue->pcHead;
80007a60:	8f 18       	st.w	r7[0x4],r8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
80007a62:	20 1a       	sub	r10,1
80007a64:	f4 09 02 49 	mul	r9,r10,r9
80007a68:	12 08       	add	r8,r9
80007a6a:	8f 38       	st.w	r7[0xc],r8
        pxQueue->cRxLock = queueUNLOCKED;
80007a6c:	3f f8       	mov	r8,-1
80007a6e:	ef 68 00 44 	st.b	r7[68],r8
        pxQueue->cTxLock = queueUNLOCKED;
80007a72:	ef 68 00 45 	st.b	r7[69],r8

        if( xNewQueue == pdFALSE )
80007a76:	58 06       	cp.w	r6,0
80007a78:	c0 b1       	brne	80007a8e <xQueueGenericReset+0x4e>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007a7a:	6e 48       	ld.w	r8,r7[0x10]
80007a7c:	58 08       	cp.w	r8,0
80007a7e:	c1 00       	breq	80007a9e <xQueueGenericReset+0x5e>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007a80:	ee cc ff f0 	sub	r12,r7,-16
80007a84:	f0 1f 00 0a 	mcall	80007aac <xQueueGenericReset+0x6c>
80007a88:	c0 b0       	breq	80007a9e <xQueueGenericReset+0x5e>
                {
                    queueYIELD_IF_USING_PREEMPTION();
80007a8a:	d7 33       	scall
80007a8c:	c0 98       	rjmp	80007a9e <xQueueGenericReset+0x5e>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80007a8e:	ee cc ff f0 	sub	r12,r7,-16
80007a92:	f0 1f 00 08 	mcall	80007ab0 <xQueueGenericReset+0x70>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
80007a96:	ee cc ff dc 	sub	r12,r7,-36
80007a9a:	f0 1f 00 06 	mcall	80007ab0 <xQueueGenericReset+0x70>
        }
    }
    taskEXIT_CRITICAL();
80007a9e:	f0 1f 00 06 	mcall	80007ab4 <xQueueGenericReset+0x74>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
80007aa2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007aa6:	00 00       	add	r0,r0
80007aa8:	80 00       	ld.sh	r0,r0[0x0]
80007aaa:	72 e0       	ld.w	r0,r9[0x38]
80007aac:	80 00       	ld.sh	r0,r0[0x0]
80007aae:	7e e8       	ld.w	r8,pc[0x38]
80007ab0:	80 00       	ld.sh	r0,r0[0x0]
80007ab2:	71 c4       	ld.w	r4,r8[0x70]
80007ab4:	80 00       	ld.sh	r0,r0[0x0]
80007ab6:	73 ec       	ld.w	r12,r9[0x78]

80007ab8 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
80007ab8:	eb cd 40 e0 	pushm	r5-r7,lr
80007abc:	18 95       	mov	r5,r12
80007abe:	16 96       	mov	r6,r11
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
80007ac0:	f6 0c 02 4c 	mul	r12,r11,r12
80007ac4:	2b 8c       	sub	r12,-72
80007ac6:	f0 1f 00 0b 	mcall	80007af0 <xQueueGenericCreate+0x38>
80007aca:	18 97       	mov	r7,r12

        if( pxNewQueue != NULL )
80007acc:	c0 f0       	breq	80007aea <xQueueGenericCreate+0x32>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
80007ace:	58 06       	cp.w	r6,0
80007ad0:	c0 31       	brne	80007ad6 <xQueueGenericCreate+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
80007ad2:	8f 0c       	st.w	r7[0x0],r12
80007ad4:	c0 48       	rjmp	80007adc <xQueueGenericCreate+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
80007ad6:	f8 c8 ff b8 	sub	r8,r12,-72
80007ada:	99 08       	st.w	r12[0x0],r8
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
80007adc:	8f f5       	st.w	r7[0x3c],r5
    pxNewQueue->uxItemSize = uxItemSize;
80007ade:	ef 46 00 40 	st.w	r7[64],r6
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
80007ae2:	30 1b       	mov	r11,1
80007ae4:	0e 9c       	mov	r12,r7
80007ae6:	f0 1f 00 04 	mcall	80007af4 <xQueueGenericCreate+0x3c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
80007aea:	0e 9c       	mov	r12,r7
80007aec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007af0:	80 00       	ld.sh	r0,r0[0x0]
80007af2:	75 14       	ld.w	r4,r10[0x44]
80007af4:	80 00       	ld.sh	r0,r0[0x0]
80007af6:	7a 40       	ld.w	r0,sp[0x10]

80007af8 <prvTaskIsTaskSuspended>:

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80007af8:	78 59       	ld.w	r9,r12[0x14]
80007afa:	48 68       	lddpc	r8,80007b10 <prvTaskIsTaskSuspended+0x18>
80007afc:	10 39       	cp.w	r9,r8
80007afe:	c0 81       	brne	80007b0e <prvTaskIsTaskSuspended+0x16>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
80007b00:	78 a8       	ld.w	r8,r12[0x28]
80007b02:	48 59       	lddpc	r9,80007b14 <prvTaskIsTaskSuspended+0x1c>
80007b04:	12 38       	cp.w	r8,r9
80007b06:	c0 40       	breq	80007b0e <prvTaskIsTaskSuspended+0x16>
80007b08:	58 08       	cp.w	r8,0
80007b0a:	5f 0c       	sreq	r12
80007b0c:	5e fc       	retal	r12
80007b0e:	5e fd       	retal	0
80007b10:	00 00       	add	r0,r0
80007b12:	06 c0       	st.b	r3++,r0
80007b14:	00 00       	add	r0,r0
80007b16:	06 5c       	eor	r12,r3

80007b18 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
80007b18:	48 38       	lddpc	r8,80007b24 <vTaskSuspendAll+0xc>
80007b1a:	70 09       	ld.w	r9,r8[0x0]
80007b1c:	2f f9       	sub	r9,-1
80007b1e:	91 09       	st.w	r8[0x0],r9

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
80007b20:	5e fc       	retal	r12
80007b22:	00 00       	add	r0,r0
80007b24:	00 00       	add	r0,r0
80007b26:	06 88       	andn	r8,r3

80007b28 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
80007b28:	49 88       	lddpc	r8,80007b88 <vTaskSwitchContext+0x60>
80007b2a:	70 08       	ld.w	r8,r8[0x0]
80007b2c:	58 08       	cp.w	r8,0
80007b2e:	c0 50       	breq	80007b38 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
80007b30:	30 19       	mov	r9,1
80007b32:	49 78       	lddpc	r8,80007b8c <vTaskSwitchContext+0x64>
80007b34:	91 09       	st.w	r8[0x0],r9
80007b36:	5e fc       	retal	r12
    }
    else
    {
        xYieldPending = pdFALSE;
80007b38:	30 09       	mov	r9,0
80007b3a:	49 58       	lddpc	r8,80007b8c <vTaskSwitchContext+0x64>
80007b3c:	91 09       	st.w	r8[0x0],r9
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007b3e:	49 58       	lddpc	r8,80007b90 <vTaskSwitchContext+0x68>
80007b40:	70 09       	ld.w	r9,r8[0x0]
80007b42:	f2 09 00 28 	add	r8,r9,r9<<0x2
80007b46:	a3 68       	lsl	r8,0x2
80007b48:	49 3b       	lddpc	r11,80007b94 <vTaskSwitchContext+0x6c>
80007b4a:	10 0b       	add	r11,r8
80007b4c:	76 0a       	ld.w	r10,r11[0x0]
80007b4e:	58 0a       	cp.w	r10,0
80007b50:	c0 b1       	brne	80007b66 <vTaskSwitchContext+0x3e>
80007b52:	21 48       	sub	r8,20
80007b54:	49 0a       	lddpc	r10,80007b94 <vTaskSwitchContext+0x6c>
80007b56:	f4 08 00 08 	add	r8,r10,r8
80007b5a:	20 19       	sub	r9,1
80007b5c:	10 9b       	mov	r11,r8
80007b5e:	70 0a       	ld.w	r10,r8[0x0]
80007b60:	21 48       	sub	r8,20
80007b62:	58 0a       	cp.w	r10,0
80007b64:	cf b0       	breq	80007b5a <vTaskSwitchContext+0x32>
80007b66:	76 18       	ld.w	r8,r11[0x4]
80007b68:	70 18       	ld.w	r8,r8[0x4]
80007b6a:	97 18       	st.w	r11[0x4],r8
80007b6c:	f6 ca ff f8 	sub	r10,r11,-8
80007b70:	14 38       	cp.w	r8,r10
80007b72:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
80007b76:	f7 f8 0a 01 	st.weq	r11[0x4],r8
80007b7a:	76 18       	ld.w	r8,r11[0x4]
80007b7c:	70 3a       	ld.w	r10,r8[0xc]
80007b7e:	48 78       	lddpc	r8,80007b98 <vTaskSwitchContext+0x70>
80007b80:	91 0a       	st.w	r8[0x0],r10
80007b82:	48 48       	lddpc	r8,80007b90 <vTaskSwitchContext+0x68>
80007b84:	91 09       	st.w	r8[0x0],r9
80007b86:	5e fc       	retal	r12
80007b88:	00 00       	add	r0,r0
80007b8a:	06 88       	andn	r8,r3
80007b8c:	00 00       	add	r0,r0
80007b8e:	06 d8       	st.w	--r3,r8
80007b90:	00 00       	add	r0,r0
80007b92:	06 d4       	st.w	--r3,r4
80007b94:	00 00       	add	r0,r0
80007b96:	05 b4       	ld.ub	r4,r2[0x3]
80007b98:	00 00       	add	r0,r0
80007b9a:	06 58       	eor	r8,r3

80007b9c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
80007b9c:	48 48       	lddpc	r8,80007bac <vTaskInternalSetTimeOutState+0x10>
80007b9e:	70 08       	ld.w	r8,r8[0x0]
80007ba0:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
80007ba2:	48 48       	lddpc	r8,80007bb0 <vTaskInternalSetTimeOutState+0x14>
80007ba4:	70 08       	ld.w	r8,r8[0x0]
80007ba6:	99 18       	st.w	r12[0x4],r8
}
80007ba8:	5e fc       	retal	r12
80007baa:	00 00       	add	r0,r0
80007bac:	00 00       	add	r0,r0
80007bae:	05 a8       	ld.ub	r8,r2[0x2]
80007bb0:	00 00       	add	r0,r0
80007bb2:	06 84       	andn	r4,r3

80007bb4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
80007bb4:	30 19       	mov	r9,1
80007bb6:	48 28       	lddpc	r8,80007bbc <vTaskMissedYield+0x8>
80007bb8:	91 09       	st.w	r8[0x0],r9
}
80007bba:	5e fc       	retal	r12
80007bbc:	00 00       	add	r0,r0
80007bbe:	06 d8       	st.w	--r3,r8

80007bc0 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007bc0:	48 88       	lddpc	r8,80007be0 <prvResetNextTaskUnblockTime+0x20>
80007bc2:	70 08       	ld.w	r8,r8[0x0]
80007bc4:	70 08       	ld.w	r8,r8[0x0]
80007bc6:	58 08       	cp.w	r8,0
80007bc8:	c0 51       	brne	80007bd2 <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
80007bca:	3f f9       	mov	r9,-1
80007bcc:	48 68       	lddpc	r8,80007be4 <prvResetNextTaskUnblockTime+0x24>
80007bce:	91 09       	st.w	r8[0x0],r9
80007bd0:	5e fc       	retal	r12
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
80007bd2:	48 48       	lddpc	r8,80007be0 <prvResetNextTaskUnblockTime+0x20>
80007bd4:	70 08       	ld.w	r8,r8[0x0]
80007bd6:	70 38       	ld.w	r8,r8[0xc]
80007bd8:	70 09       	ld.w	r9,r8[0x0]
80007bda:	48 38       	lddpc	r8,80007be4 <prvResetNextTaskUnblockTime+0x24>
80007bdc:	91 09       	st.w	r8[0x0],r9
80007bde:	5e fc       	retal	r12
80007be0:	00 00       	add	r0,r0
80007be2:	05 a0       	ld.ub	r0,r2[0x2]
80007be4:	00 00       	add	r0,r0
80007be6:	05 9c       	ld.ub	r12,r2[0x1]

80007be8 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
80007be8:	48 78       	lddpc	r8,80007c04 <pvTaskIncrementMutexHeldCount+0x1c>
80007bea:	70 08       	ld.w	r8,r8[0x0]
80007bec:	58 08       	cp.w	r8,0
80007bee:	c0 70       	breq	80007bfc <pvTaskIncrementMutexHeldCount+0x14>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
80007bf0:	48 58       	lddpc	r8,80007c04 <pvTaskIncrementMutexHeldCount+0x1c>
80007bf2:	70 08       	ld.w	r8,r8[0x0]
80007bf4:	71 29       	ld.w	r9,r8[0x48]
80007bf6:	2f f9       	sub	r9,-1
80007bf8:	f1 49 00 48 	st.w	r8[72],r9
        }

        return pxCurrentTCB;
80007bfc:	48 28       	lddpc	r8,80007c04 <pvTaskIncrementMutexHeldCount+0x1c>
80007bfe:	70 0c       	ld.w	r12,r8[0x0]
    }
80007c00:	5e fc       	retal	r12
80007c02:	00 00       	add	r0,r0
80007c04:	00 00       	add	r0,r0
80007c06:	06 58       	eor	r8,r3

80007c08 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
80007c08:	eb cd 40 c0 	pushm	r6-r7,lr
80007c0c:	18 97       	mov	r7,r12
80007c0e:	16 96       	mov	r6,r11
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
80007c10:	f0 1f 00 14 	mcall	80007c60 <xTaskCheckForTimeOut+0x58>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
80007c14:	49 48       	lddpc	r8,80007c64 <xTaskCheckForTimeOut+0x5c>
80007c16:	70 0a       	ld.w	r10,r8[0x0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
80007c18:	6e 19       	ld.w	r9,r7[0x4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
80007c1a:	6c 08       	ld.w	r8,r6[0x0]
80007c1c:	5b f8       	cp.w	r8,-1
80007c1e:	c0 31       	brne	80007c24 <xTaskCheckForTimeOut+0x1c>
80007c20:	30 07       	mov	r7,0
80007c22:	c1 a8       	rjmp	80007c56 <xTaskCheckForTimeOut+0x4e>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80007c24:	49 1b       	lddpc	r11,80007c68 <xTaskCheckForTimeOut+0x60>
80007c26:	76 0b       	ld.w	r11,r11[0x0]
80007c28:	6e 0c       	ld.w	r12,r7[0x0]
80007c2a:	16 3c       	cp.w	r12,r11
80007c2c:	c0 70       	breq	80007c3a <xTaskCheckForTimeOut+0x32>
80007c2e:	12 3a       	cp.w	r10,r9
80007c30:	c0 53       	brcs	80007c3a <xTaskCheckForTimeOut+0x32>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
80007c32:	30 08       	mov	r8,0
80007c34:	8d 08       	st.w	r6[0x0],r8
80007c36:	30 17       	mov	r7,1
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80007c38:	c0 f8       	rjmp	80007c56 <xTaskCheckForTimeOut+0x4e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
80007c3a:	f4 09 01 09 	sub	r9,r10,r9
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
80007c3e:	10 39       	cp.w	r9,r8
80007c40:	c0 82       	brcc	80007c50 <xTaskCheckForTimeOut+0x48>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
80007c42:	12 18       	sub	r8,r9
80007c44:	8d 08       	st.w	r6[0x0],r8
            vTaskInternalSetTimeOutState( pxTimeOut );
80007c46:	0e 9c       	mov	r12,r7
80007c48:	f0 1f 00 09 	mcall	80007c6c <xTaskCheckForTimeOut+0x64>
80007c4c:	30 07       	mov	r7,0
80007c4e:	c0 48       	rjmp	80007c56 <xTaskCheckForTimeOut+0x4e>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
80007c50:	30 08       	mov	r8,0
80007c52:	8d 08       	st.w	r6[0x0],r8
80007c54:	30 17       	mov	r7,1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
80007c56:	f0 1f 00 07 	mcall	80007c70 <xTaskCheckForTimeOut+0x68>

    return xReturn;
}
80007c5a:	0e 9c       	mov	r12,r7
80007c5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007c60:	80 00       	ld.sh	r0,r0[0x0]
80007c62:	72 e0       	ld.w	r0,r9[0x38]
80007c64:	00 00       	add	r0,r0
80007c66:	06 84       	andn	r4,r3
80007c68:	00 00       	add	r0,r0
80007c6a:	05 a8       	ld.ub	r8,r2[0x2]
80007c6c:	80 00       	ld.sh	r0,r0[0x0]
80007c6e:	7b 9c       	ld.w	r12,sp[0x64]
80007c70:	80 00       	ld.sh	r0,r0[0x0]
80007c72:	73 ec       	ld.w	r12,r9[0x78]

80007c74 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
80007c74:	eb cd 40 f8 	pushm	r3-r7,lr
80007c78:	18 97       	mov	r7,r12
80007c7a:	16 95       	mov	r5,r11
80007c7c:	14 93       	mov	r3,r10
80007c7e:	12 96       	mov	r6,r9
80007c80:	10 94       	mov	r4,r8

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
80007c82:	f0 1f 00 31 	mcall	80007d44 <xTaskGenericNotify+0xd0>
        {
            if( pulPreviousNotificationValue != NULL )
80007c86:	58 04       	cp.w	r4,0
80007c88:	c0 60       	breq	80007c94 <xTaskGenericNotify+0x20>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
80007c8a:	ea c8 ff ed 	sub	r8,r5,-19
80007c8e:	ee 08 03 28 	ld.w	r8,r7[r8<<0x2]
80007c92:	89 08       	st.w	r4[0x0],r8
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
80007c94:	ee 05 00 08 	add	r8,r7,r5
80007c98:	f1 39 00 50 	ld.ub	r9,r8[80]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
80007c9c:	30 2a       	mov	r10,2
80007c9e:	f1 6a 00 50 	st.b	r8[80],r10

            switch( eAction )
80007ca2:	58 26       	cp.w	r6,2
80007ca4:	c1 20       	breq	80007cc8 <xTaskGenericNotify+0x54>
80007ca6:	e0 8b 00 05 	brhi	80007cb0 <xTaskGenericNotify+0x3c>
80007caa:	58 16       	cp.w	r6,1
80007cac:	c2 21       	brne	80007cf0 <xTaskGenericNotify+0x7c>
80007cae:	c0 68       	rjmp	80007cba <xTaskGenericNotify+0x46>
80007cb0:	58 36       	cp.w	r6,3
80007cb2:	c1 20       	breq	80007cd6 <xTaskGenericNotify+0x62>
80007cb4:	58 46       	cp.w	r6,4
80007cb6:	c1 d1       	brne	80007cf0 <xTaskGenericNotify+0x7c>
80007cb8:	c1 38       	rjmp	80007cde <xTaskGenericNotify+0x6a>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
80007cba:	2e d5       	sub	r5,-19
80007cbc:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
80007cc0:	10 43       	or	r3,r8
80007cc2:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
80007cc6:	c1 58       	rjmp	80007cf0 <xTaskGenericNotify+0x7c>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
80007cc8:	2e d5       	sub	r5,-19
80007cca:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
80007cce:	2f f8       	sub	r8,-1
80007cd0:	ee 05 09 28 	st.w	r7[r5<<0x2],r8
                    break;
80007cd4:	c0 e8       	rjmp	80007cf0 <xTaskGenericNotify+0x7c>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
80007cd6:	2e d5       	sub	r5,-19
80007cd8:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
80007cdc:	c0 a8       	rjmp	80007cf0 <xTaskGenericNotify+0x7c>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80007cde:	30 28       	mov	r8,2
80007ce0:	f0 09 18 00 	cp.b	r9,r8
80007ce4:	c0 31       	brne	80007cea <xTaskGenericNotify+0x76>
80007ce6:	30 07       	mov	r7,0
80007ce8:	c2 88       	rjmp	80007d38 <xTaskGenericNotify+0xc4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
80007cea:	2e d5       	sub	r5,-19
80007cec:	ee 05 09 23 	st.w	r7[r5<<0x2],r3

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80007cf0:	30 18       	mov	r8,1
80007cf2:	f0 09 18 00 	cp.b	r9,r8
80007cf6:	c2 01       	brne	80007d36 <xTaskGenericNotify+0xc2>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007cf8:	ee c6 ff fc 	sub	r6,r7,-4
80007cfc:	0c 9c       	mov	r12,r6
80007cfe:	f0 1f 00 13 	mcall	80007d48 <xTaskGenericNotify+0xd4>
                prvAddTaskToReadyList( pxTCB );
80007d02:	6e bc       	ld.w	r12,r7[0x2c]
80007d04:	49 28       	lddpc	r8,80007d4c <xTaskGenericNotify+0xd8>
80007d06:	70 08       	ld.w	r8,r8[0x0]
80007d08:	10 3c       	cp.w	r12,r8
80007d0a:	e0 88 00 04 	brls	80007d12 <xTaskGenericNotify+0x9e>
80007d0e:	49 08       	lddpc	r8,80007d4c <xTaskGenericNotify+0xd8>
80007d10:	91 0c       	st.w	r8[0x0],r12
80007d12:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007d16:	0c 9b       	mov	r11,r6
80007d18:	48 e8       	lddpc	r8,80007d50 <xTaskGenericNotify+0xdc>
80007d1a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007d1e:	f0 1f 00 0e 	mcall	80007d54 <xTaskGenericNotify+0xe0>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80007d22:	48 e8       	lddpc	r8,80007d58 <xTaskGenericNotify+0xe4>
80007d24:	70 08       	ld.w	r8,r8[0x0]
80007d26:	6e b9       	ld.w	r9,r7[0x2c]
80007d28:	70 b8       	ld.w	r8,r8[0x2c]
80007d2a:	10 39       	cp.w	r9,r8
80007d2c:	e0 88 00 05 	brls	80007d36 <xTaskGenericNotify+0xc2>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
80007d30:	d7 33       	scall
80007d32:	30 17       	mov	r7,1
80007d34:	c0 28       	rjmp	80007d38 <xTaskGenericNotify+0xc4>
80007d36:	30 17       	mov	r7,1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80007d38:	f0 1f 00 09 	mcall	80007d5c <xTaskGenericNotify+0xe8>

        return xReturn;
    }
80007d3c:	0e 9c       	mov	r12,r7
80007d3e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007d42:	00 00       	add	r0,r0
80007d44:	80 00       	ld.sh	r0,r0[0x0]
80007d46:	72 e0       	ld.w	r0,r9[0x38]
80007d48:	80 00       	ld.sh	r0,r0[0x0]
80007d4a:	72 26       	ld.w	r6,r9[0x8]
80007d4c:	00 00       	add	r0,r0
80007d4e:	06 d4       	st.w	--r3,r4
80007d50:	00 00       	add	r0,r0
80007d52:	05 b4       	ld.ub	r4,r2[0x3]
80007d54:	80 00       	ld.sh	r0,r0[0x0]
80007d56:	71 de       	ld.w	lr,r8[0x74]
80007d58:	00 00       	add	r0,r0
80007d5a:	06 58       	eor	r8,r3
80007d5c:	80 00       	ld.sh	r0,r0[0x0]
80007d5e:	73 ec       	ld.w	r12,r9[0x78]

80007d60 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
80007d60:	eb cd 40 c0 	pushm	r6-r7,lr
80007d64:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
80007d66:	58 0c       	cp.w	r12,0
80007d68:	c2 f0       	breq	80007dc6 <vTaskPriorityDisinheritAfterTimeout+0x66>
80007d6a:	79 18       	ld.w	r8,r12[0x44]
80007d6c:	10 3b       	cp.w	r11,r8
80007d6e:	f0 0b 17 30 	movlo	r11,r8
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
80007d72:	78 b9       	ld.w	r9,r12[0x2c]
80007d74:	16 39       	cp.w	r9,r11
80007d76:	c2 80       	breq	80007dc6 <vTaskPriorityDisinheritAfterTimeout+0x66>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
80007d78:	79 28       	ld.w	r8,r12[0x48]
80007d7a:	58 18       	cp.w	r8,1
80007d7c:	c2 51       	brne	80007dc6 <vTaskPriorityDisinheritAfterTimeout+0x66>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
80007d7e:	99 bb       	st.w	r12[0x2c],r11

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007d80:	78 68       	ld.w	r8,r12[0x18]
80007d82:	58 08       	cp.w	r8,0
80007d84:	c0 45       	brlt	80007d8c <vTaskPriorityDisinheritAfterTimeout+0x2c>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007d86:	f6 0b 11 08 	rsub	r11,r11,8
80007d8a:	99 6b       	st.w	r12[0x18],r11
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80007d8c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007d90:	48 f8       	lddpc	r8,80007dcc <vTaskPriorityDisinheritAfterTimeout+0x6c>
80007d92:	f0 09 00 29 	add	r9,r8,r9<<0x2
80007d96:	6e 58       	ld.w	r8,r7[0x14]
80007d98:	12 38       	cp.w	r8,r9
80007d9a:	c1 61       	brne	80007dc6 <vTaskPriorityDisinheritAfterTimeout+0x66>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007d9c:	ee c6 ff fc 	sub	r6,r7,-4
80007da0:	0c 9c       	mov	r12,r6
80007da2:	f0 1f 00 0c 	mcall	80007dd0 <vTaskPriorityDisinheritAfterTimeout+0x70>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
80007da6:	6e bc       	ld.w	r12,r7[0x2c]
80007da8:	48 b8       	lddpc	r8,80007dd4 <vTaskPriorityDisinheritAfterTimeout+0x74>
80007daa:	70 08       	ld.w	r8,r8[0x0]
80007dac:	10 3c       	cp.w	r12,r8
80007dae:	e0 88 00 04 	brls	80007db6 <vTaskPriorityDisinheritAfterTimeout+0x56>
80007db2:	48 98       	lddpc	r8,80007dd4 <vTaskPriorityDisinheritAfterTimeout+0x74>
80007db4:	91 0c       	st.w	r8[0x0],r12
80007db6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007dba:	0c 9b       	mov	r11,r6
80007dbc:	48 48       	lddpc	r8,80007dcc <vTaskPriorityDisinheritAfterTimeout+0x6c>
80007dbe:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007dc2:	f0 1f 00 06 	mcall	80007dd8 <vTaskPriorityDisinheritAfterTimeout+0x78>
80007dc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007dca:	00 00       	add	r0,r0
80007dcc:	00 00       	add	r0,r0
80007dce:	05 b4       	ld.ub	r4,r2[0x3]
80007dd0:	80 00       	ld.sh	r0,r0[0x0]
80007dd2:	72 26       	ld.w	r6,r9[0x8]
80007dd4:	00 00       	add	r0,r0
80007dd6:	06 d4       	st.w	--r3,r4
80007dd8:	80 00       	ld.sh	r0,r0[0x0]
80007dda:	71 de       	ld.w	lr,r8[0x74]

80007ddc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
80007ddc:	eb cd 40 c0 	pushm	r6-r7,lr
80007de0:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
80007de2:	58 0c       	cp.w	r12,0
80007de4:	c2 60       	breq	80007e30 <xTaskPriorityDisinherit+0x54>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
80007de6:	79 28       	ld.w	r8,r12[0x48]
80007de8:	20 18       	sub	r8,1
80007dea:	f9 48 00 48 	st.w	r12[72],r8

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80007dee:	78 ba       	ld.w	r10,r12[0x2c]
80007df0:	79 19       	ld.w	r9,r12[0x44]
80007df2:	12 3a       	cp.w	r10,r9
80007df4:	c1 e0       	breq	80007e30 <xTaskPriorityDisinherit+0x54>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
80007df6:	58 08       	cp.w	r8,0
80007df8:	c1 c1       	brne	80007e30 <xTaskPriorityDisinherit+0x54>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007dfa:	f8 c6 ff fc 	sub	r6,r12,-4
80007dfe:	0c 9c       	mov	r12,r6
80007e00:	f0 1f 00 0d 	mcall	80007e34 <xTaskPriorityDisinherit+0x58>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
80007e04:	6f 1c       	ld.w	r12,r7[0x44]
80007e06:	8f bc       	st.w	r7[0x2c],r12

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007e08:	f8 08 11 08 	rsub	r8,r12,8
80007e0c:	8f 68       	st.w	r7[0x18],r8
                    prvAddTaskToReadyList( pxTCB );
80007e0e:	48 b8       	lddpc	r8,80007e38 <xTaskPriorityDisinherit+0x5c>
80007e10:	70 08       	ld.w	r8,r8[0x0]
80007e12:	10 3c       	cp.w	r12,r8
80007e14:	e0 88 00 04 	brls	80007e1c <xTaskPriorityDisinherit+0x40>
80007e18:	48 88       	lddpc	r8,80007e38 <xTaskPriorityDisinherit+0x5c>
80007e1a:	91 0c       	st.w	r8[0x0],r12
80007e1c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007e20:	0c 9b       	mov	r11,r6
80007e22:	48 78       	lddpc	r8,80007e3c <xTaskPriorityDisinherit+0x60>
80007e24:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007e28:	f0 1f 00 06 	mcall	80007e40 <xTaskPriorityDisinherit+0x64>
80007e2c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007e30:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80007e34:	80 00       	ld.sh	r0,r0[0x0]
80007e36:	72 26       	ld.w	r6,r9[0x8]
80007e38:	00 00       	add	r0,r0
80007e3a:	06 d4       	st.w	--r3,r4
80007e3c:	00 00       	add	r0,r0
80007e3e:	05 b4       	ld.ub	r4,r2[0x3]
80007e40:	80 00       	ld.sh	r0,r0[0x0]
80007e42:	71 de       	ld.w	lr,r8[0x74]

80007e44 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
80007e44:	eb cd 40 c0 	pushm	r6-r7,lr
80007e48:	18 97       	mov	r7,r12
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
80007e4a:	58 0c       	cp.w	r12,0
80007e4c:	c0 31       	brne	80007e52 <xTaskPriorityInherit+0xe>
80007e4e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
80007e52:	4a 18       	lddpc	r8,80007ed4 <xTaskPriorityInherit+0x90>
80007e54:	70 08       	ld.w	r8,r8[0x0]
80007e56:	78 b9       	ld.w	r9,r12[0x2c]
80007e58:	70 b8       	ld.w	r8,r8[0x2c]
80007e5a:	10 39       	cp.w	r9,r8
80007e5c:	c3 32       	brcc	80007ec2 <xTaskPriorityInherit+0x7e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007e5e:	78 68       	ld.w	r8,r12[0x18]
80007e60:	58 08       	cp.w	r8,0
80007e62:	c0 75       	brlt	80007e70 <xTaskPriorityInherit+0x2c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007e64:	49 c8       	lddpc	r8,80007ed4 <xTaskPriorityInherit+0x90>
80007e66:	70 08       	ld.w	r8,r8[0x0]
80007e68:	70 b8       	ld.w	r8,r8[0x2c]
80007e6a:	f0 08 11 08 	rsub	r8,r8,8
80007e6e:	99 68       	st.w	r12[0x18],r8
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
80007e70:	6e b8       	ld.w	r8,r7[0x2c]
80007e72:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007e76:	49 99       	lddpc	r9,80007ed8 <xTaskPriorityInherit+0x94>
80007e78:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007e7c:	6e 59       	ld.w	r9,r7[0x14]
80007e7e:	10 39       	cp.w	r9,r8
80007e80:	c1 b1       	brne	80007eb6 <xTaskPriorityInherit+0x72>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007e82:	ee c6 ff fc 	sub	r6,r7,-4
80007e86:	0c 9c       	mov	r12,r6
80007e88:	f0 1f 00 15 	mcall	80007edc <xTaskPriorityInherit+0x98>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
80007e8c:	49 28       	lddpc	r8,80007ed4 <xTaskPriorityInherit+0x90>
80007e8e:	70 08       	ld.w	r8,r8[0x0]
80007e90:	70 bc       	ld.w	r12,r8[0x2c]
80007e92:	8f bc       	st.w	r7[0x2c],r12
                    prvAddTaskToReadyList( pxMutexHolderTCB );
80007e94:	49 38       	lddpc	r8,80007ee0 <xTaskPriorityInherit+0x9c>
80007e96:	70 08       	ld.w	r8,r8[0x0]
80007e98:	10 3c       	cp.w	r12,r8
80007e9a:	e0 88 00 04 	brls	80007ea2 <xTaskPriorityInherit+0x5e>
80007e9e:	49 18       	lddpc	r8,80007ee0 <xTaskPriorityInherit+0x9c>
80007ea0:	91 0c       	st.w	r8[0x0],r12
80007ea2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007ea6:	0c 9b       	mov	r11,r6
80007ea8:	48 c8       	lddpc	r8,80007ed8 <xTaskPriorityInherit+0x94>
80007eaa:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007eae:	f0 1f 00 0e 	mcall	80007ee4 <xTaskPriorityInherit+0xa0>
80007eb2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
80007eb6:	48 88       	lddpc	r8,80007ed4 <xTaskPriorityInherit+0x90>
80007eb8:	70 08       	ld.w	r8,r8[0x0]
80007eba:	70 b8       	ld.w	r8,r8[0x2c]
80007ebc:	8f b8       	st.w	r7[0x2c],r8
80007ebe:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
80007ec2:	48 58       	lddpc	r8,80007ed4 <xTaskPriorityInherit+0x90>
80007ec4:	70 08       	ld.w	r8,r8[0x0]
80007ec6:	79 19       	ld.w	r9,r12[0x44]
80007ec8:	70 b8       	ld.w	r8,r8[0x2c]
80007eca:	10 39       	cp.w	r9,r8
80007ecc:	5f 3c       	srlo	r12
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
80007ece:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007ed2:	00 00       	add	r0,r0
80007ed4:	00 00       	add	r0,r0
80007ed6:	06 58       	eor	r8,r3
80007ed8:	00 00       	add	r0,r0
80007eda:	05 b4       	ld.ub	r4,r2[0x3]
80007edc:	80 00       	ld.sh	r0,r0[0x0]
80007ede:	72 26       	ld.w	r6,r9[0x8]
80007ee0:	00 00       	add	r0,r0
80007ee2:	06 d4       	st.w	--r3,r4
80007ee4:	80 00       	ld.sh	r0,r0[0x0]
80007ee6:	71 de       	ld.w	lr,r8[0x74]

80007ee8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
80007ee8:	eb cd 40 c0 	pushm	r6-r7,lr
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007eec:	78 38       	ld.w	r8,r12[0xc]
80007eee:	70 37       	ld.w	r7,r8[0xc]
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007ef0:	ee c6 ff e8 	sub	r6,r7,-24
80007ef4:	0c 9c       	mov	r12,r6
80007ef6:	f0 1f 00 18 	mcall	80007f54 <xTaskRemoveFromEventList+0x6c>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007efa:	49 88       	lddpc	r8,80007f58 <xTaskRemoveFromEventList+0x70>
80007efc:	70 08       	ld.w	r8,r8[0x0]
80007efe:	58 08       	cp.w	r8,0
80007f00:	c1 71       	brne	80007f2e <xTaskRemoveFromEventList+0x46>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80007f02:	ee c6 ff fc 	sub	r6,r7,-4
80007f06:	0c 9c       	mov	r12,r6
80007f08:	f0 1f 00 13 	mcall	80007f54 <xTaskRemoveFromEventList+0x6c>
        prvAddTaskToReadyList( pxUnblockedTCB );
80007f0c:	6e bc       	ld.w	r12,r7[0x2c]
80007f0e:	49 48       	lddpc	r8,80007f5c <xTaskRemoveFromEventList+0x74>
80007f10:	70 08       	ld.w	r8,r8[0x0]
80007f12:	10 3c       	cp.w	r12,r8
80007f14:	e0 88 00 04 	brls	80007f1c <xTaskRemoveFromEventList+0x34>
80007f18:	49 18       	lddpc	r8,80007f5c <xTaskRemoveFromEventList+0x74>
80007f1a:	91 0c       	st.w	r8[0x0],r12
80007f1c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007f20:	0c 9b       	mov	r11,r6
80007f22:	49 08       	lddpc	r8,80007f60 <xTaskRemoveFromEventList+0x78>
80007f24:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007f28:	f0 1f 00 0f 	mcall	80007f64 <xTaskRemoveFromEventList+0x7c>
80007f2c:	c0 58       	rjmp	80007f36 <xTaskRemoveFromEventList+0x4e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80007f2e:	0c 9b       	mov	r11,r6
80007f30:	48 ec       	lddpc	r12,80007f68 <xTaskRemoveFromEventList+0x80>
80007f32:	f0 1f 00 0d 	mcall	80007f64 <xTaskRemoveFromEventList+0x7c>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80007f36:	48 e8       	lddpc	r8,80007f6c <xTaskRemoveFromEventList+0x84>
80007f38:	70 08       	ld.w	r8,r8[0x0]
80007f3a:	6e b9       	ld.w	r9,r7[0x2c]
80007f3c:	70 b8       	ld.w	r8,r8[0x2c]
80007f3e:	10 39       	cp.w	r9,r8
80007f40:	e0 8b 00 04 	brhi	80007f48 <xTaskRemoveFromEventList+0x60>
80007f44:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
80007f48:	30 1c       	mov	r12,1
80007f4a:	48 a8       	lddpc	r8,80007f70 <xTaskRemoveFromEventList+0x88>
80007f4c:	91 0c       	st.w	r8[0x0],r12
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
80007f4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007f52:	00 00       	add	r0,r0
80007f54:	80 00       	ld.sh	r0,r0[0x0]
80007f56:	72 26       	ld.w	r6,r9[0x8]
80007f58:	00 00       	add	r0,r0
80007f5a:	06 88       	andn	r8,r3
80007f5c:	00 00       	add	r0,r0
80007f5e:	06 d4       	st.w	--r3,r4
80007f60:	00 00       	add	r0,r0
80007f62:	05 b4       	ld.ub	r4,r2[0x3]
80007f64:	80 00       	ld.sh	r0,r0[0x0]
80007f66:	71 de       	ld.w	lr,r8[0x74]
80007f68:	00 00       	add	r0,r0
80007f6a:	06 5c       	eor	r12,r3
80007f6c:	00 00       	add	r0,r0
80007f6e:	06 58       	eor	r8,r3
80007f70:	00 00       	add	r0,r0
80007f72:	06 d8       	st.w	--r3,r8

80007f74 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
80007f74:	d4 31       	pushm	r0-r7,lr
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007f76:	4b 48       	lddpc	r8,80008044 <xTaskIncrementTick+0xd0>
80007f78:	70 08       	ld.w	r8,r8[0x0]
80007f7a:	58 08       	cp.w	r8,0
80007f7c:	c5 d1       	brne	80008036 <xTaskIncrementTick+0xc2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
80007f7e:	4b 38       	lddpc	r8,80008048 <xTaskIncrementTick+0xd4>
80007f80:	70 02       	ld.w	r2,r8[0x0]
80007f82:	2f f2       	sub	r2,-1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
80007f84:	91 02       	st.w	r8[0x0],r2

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
80007f86:	c0 d1       	brne	80007fa0 <xTaskIncrementTick+0x2c>
        {
            taskSWITCH_DELAYED_LISTS();
80007f88:	4b 19       	lddpc	r9,8000804c <xTaskIncrementTick+0xd8>
80007f8a:	72 0a       	ld.w	r10,r9[0x0]
80007f8c:	4b 18       	lddpc	r8,80008050 <xTaskIncrementTick+0xdc>
80007f8e:	70 0b       	ld.w	r11,r8[0x0]
80007f90:	93 0b       	st.w	r9[0x0],r11
80007f92:	91 0a       	st.w	r8[0x0],r10
80007f94:	4b 08       	lddpc	r8,80008054 <xTaskIncrementTick+0xe0>
80007f96:	70 09       	ld.w	r9,r8[0x0]
80007f98:	2f f9       	sub	r9,-1
80007f9a:	91 09       	st.w	r8[0x0],r9
80007f9c:	f0 1f 00 2f 	mcall	80008058 <xTaskIncrementTick+0xe4>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
80007fa0:	4a f8       	lddpc	r8,8000805c <xTaskIncrementTick+0xe8>
80007fa2:	70 08       	ld.w	r8,r8[0x0]
80007fa4:	10 32       	cp.w	r2,r8
80007fa6:	c3 63       	brcs	80008012 <xTaskIncrementTick+0x9e>
80007fa8:	30 06       	mov	r6,0
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007faa:	4a 94       	lddpc	r4,8000804c <xTaskIncrementTick+0xd8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007fac:	4a d3       	lddpc	r3,80008060 <xTaskIncrementTick+0xec>
80007fae:	4a e1       	lddpc	r1,80008064 <xTaskIncrementTick+0xf0>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007fb0:	4a e0       	lddpc	r0,80008068 <xTaskIncrementTick+0xf4>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007fb2:	68 08       	ld.w	r8,r4[0x0]
80007fb4:	70 08       	ld.w	r8,r8[0x0]
80007fb6:	58 08       	cp.w	r8,0
80007fb8:	c0 51       	brne	80007fc2 <xTaskIncrementTick+0x4e>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007fba:	3f f9       	mov	r9,-1
80007fbc:	4a 88       	lddpc	r8,8000805c <xTaskIncrementTick+0xe8>
80007fbe:	91 09       	st.w	r8[0x0],r9
                    break;
80007fc0:	c2 a8       	rjmp	80008014 <xTaskIncrementTick+0xa0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007fc2:	68 08       	ld.w	r8,r4[0x0]
80007fc4:	70 38       	ld.w	r8,r8[0xc]
80007fc6:	70 37       	ld.w	r7,r8[0xc]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80007fc8:	6e 18       	ld.w	r8,r7[0x4]

                    if( xConstTickCount < xItemValue )
80007fca:	10 32       	cp.w	r2,r8
80007fcc:	c0 42       	brcc	80007fd4 <xTaskIncrementTick+0x60>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
80007fce:	4a 49       	lddpc	r9,8000805c <xTaskIncrementTick+0xe8>
80007fd0:	93 08       	st.w	r9[0x0],r8
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
80007fd2:	c2 18       	rjmp	80008014 <xTaskIncrementTick+0xa0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007fd4:	ee c5 ff fc 	sub	r5,r7,-4
80007fd8:	0a 9c       	mov	r12,r5
80007fda:	f0 1f 00 25 	mcall	8000806c <xTaskIncrementTick+0xf8>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80007fde:	6e a8       	ld.w	r8,r7[0x28]
80007fe0:	58 08       	cp.w	r8,0
80007fe2:	c0 50       	breq	80007fec <xTaskIncrementTick+0x78>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007fe4:	ee cc ff e8 	sub	r12,r7,-24
80007fe8:	f0 1f 00 21 	mcall	8000806c <xTaskIncrementTick+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007fec:	6e bc       	ld.w	r12,r7[0x2c]
80007fee:	66 08       	ld.w	r8,r3[0x0]
80007ff0:	10 3c       	cp.w	r12,r8
80007ff2:	e7 fc ba 00 	st.whi	r3[0x0],r12
80007ff6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007ffa:	0a 9b       	mov	r11,r5
80007ffc:	e2 0c 00 2c 	add	r12,r1,r12<<0x2
80008000:	f0 1f 00 1c 	mcall	80008070 <xTaskIncrementTick+0xfc>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80008004:	60 08       	ld.w	r8,r0[0x0]
80008006:	6e b9       	ld.w	r9,r7[0x2c]
80008008:	70 b8       	ld.w	r8,r8[0x2c]
8000800a:	10 39       	cp.w	r9,r8
8000800c:	f9 b6 02 01 	movhs	r6,1
80008010:	cd 1b       	rjmp	80007fb2 <xTaskIncrementTick+0x3e>
80008012:	30 06       	mov	r6,0
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
80008014:	49 58       	lddpc	r8,80008068 <xTaskIncrementTick+0xf4>
80008016:	70 08       	ld.w	r8,r8[0x0]
80008018:	70 b8       	ld.w	r8,r8[0x2c]
8000801a:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000801e:	49 29       	lddpc	r9,80008064 <xTaskIncrementTick+0xf0>
80008020:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80008024:	58 28       	cp.w	r8,2
80008026:	f9 b6 02 01 	movhs	r6,1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
8000802a:	49 38       	lddpc	r8,80008074 <xTaskIncrementTick+0x100>
8000802c:	70 08       	ld.w	r8,r8[0x0]
8000802e:	58 08       	cp.w	r8,0
80008030:	f9 b6 01 01 	movne	r6,1
80008034:	c0 68       	rjmp	80008040 <xTaskIncrementTick+0xcc>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
80008036:	49 18       	lddpc	r8,80008078 <xTaskIncrementTick+0x104>
80008038:	70 09       	ld.w	r9,r8[0x0]
8000803a:	2f f9       	sub	r9,-1
8000803c:	91 09       	st.w	r8[0x0],r9
8000803e:	30 06       	mov	r6,0
            }
        #endif
    }

    return xSwitchRequired;
}
80008040:	0c 9c       	mov	r12,r6
80008042:	d8 32       	popm	r0-r7,pc
80008044:	00 00       	add	r0,r0
80008046:	06 88       	andn	r8,r3
80008048:	00 00       	add	r0,r0
8000804a:	06 84       	andn	r4,r3
8000804c:	00 00       	add	r0,r0
8000804e:	05 a0       	ld.ub	r0,r2[0x2]
80008050:	00 00       	add	r0,r0
80008052:	05 ac       	ld.ub	r12,r2[0x2]
80008054:	00 00       	add	r0,r0
80008056:	05 a8       	ld.ub	r8,r2[0x2]
80008058:	80 00       	ld.sh	r0,r0[0x0]
8000805a:	7b c0       	ld.w	r0,sp[0x70]
8000805c:	00 00       	add	r0,r0
8000805e:	05 9c       	ld.ub	r12,r2[0x1]
80008060:	00 00       	add	r0,r0
80008062:	06 d4       	st.w	--r3,r4
80008064:	00 00       	add	r0,r0
80008066:	05 b4       	ld.ub	r4,r2[0x3]
80008068:	00 00       	add	r0,r0
8000806a:	06 58       	eor	r8,r3
8000806c:	80 00       	ld.sh	r0,r0[0x0]
8000806e:	72 26       	ld.w	r6,r9[0x8]
80008070:	80 00       	ld.sh	r0,r0[0x0]
80008072:	71 de       	ld.w	lr,r8[0x74]
80008074:	00 00       	add	r0,r0
80008076:	06 d8       	st.w	--r3,r8
80008078:	00 00       	add	r0,r0
8000807a:	05 b0       	ld.ub	r0,r2[0x3]

8000807c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
8000807c:	d4 31       	pushm	r0-r7,lr
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
8000807e:	f0 1f 00 2b 	mcall	80008128 <xTaskResumeAll+0xac>
    {
        --uxSchedulerSuspended;
80008082:	4a b8       	lddpc	r8,8000812c <xTaskResumeAll+0xb0>
80008084:	70 09       	ld.w	r9,r8[0x0]
80008086:	20 19       	sub	r9,1
80008088:	91 09       	st.w	r8[0x0],r9

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
8000808a:	70 08       	ld.w	r8,r8[0x0]
8000808c:	58 08       	cp.w	r8,0
8000808e:	c4 71       	brne	8000811c <xTaskResumeAll+0xa0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80008090:	4a 88       	lddpc	r8,80008130 <xTaskResumeAll+0xb4>
80008092:	70 08       	ld.w	r8,r8[0x0]
80008094:	58 08       	cp.w	r8,0
80008096:	c4 30       	breq	8000811c <xTaskResumeAll+0xa0>
80008098:	30 07       	mov	r7,0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
8000809a:	4a 76       	lddpc	r6,80008134 <xTaskResumeAll+0xb8>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
8000809c:	4a 74       	lddpc	r4,80008138 <xTaskResumeAll+0xbc>
8000809e:	4a 83       	lddpc	r3,8000813c <xTaskResumeAll+0xc0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800080a0:	4a 82       	lddpc	r2,80008140 <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
800080a2:	4a 91       	lddpc	r1,80008144 <xTaskResumeAll+0xc8>
800080a4:	30 10       	mov	r0,1
800080a6:	c1 e8       	rjmp	800080e2 <xTaskResumeAll+0x66>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800080a8:	6c 38       	ld.w	r8,r6[0xc]
800080aa:	70 37       	ld.w	r7,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
800080ac:	ee cc ff e8 	sub	r12,r7,-24
800080b0:	f0 1f 00 26 	mcall	80008148 <xTaskResumeAll+0xcc>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
800080b4:	ee c5 ff fc 	sub	r5,r7,-4
800080b8:	0a 9c       	mov	r12,r5
800080ba:	f0 1f 00 24 	mcall	80008148 <xTaskResumeAll+0xcc>
                    prvAddTaskToReadyList( pxTCB );
800080be:	6e bc       	ld.w	r12,r7[0x2c]
800080c0:	68 08       	ld.w	r8,r4[0x0]
800080c2:	10 3c       	cp.w	r12,r8
800080c4:	e9 fc ba 00 	st.whi	r4[0x0],r12
800080c8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800080cc:	0a 9b       	mov	r11,r5
800080ce:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800080d2:	f0 1f 00 1f 	mcall	8000814c <xTaskResumeAll+0xd0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800080d6:	64 08       	ld.w	r8,r2[0x0]
800080d8:	6e b9       	ld.w	r9,r7[0x2c]
800080da:	70 b8       	ld.w	r8,r8[0x2c]
                    {
                        xYieldPending = pdTRUE;
800080dc:	10 39       	cp.w	r9,r8
800080de:	e3 f0 2a 00 	st.wcc	r1[0x0],r0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
800080e2:	6c 08       	ld.w	r8,r6[0x0]
800080e4:	58 08       	cp.w	r8,0
800080e6:	ce 11       	brne	800080a8 <xTaskResumeAll+0x2c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
800080e8:	58 07       	cp.w	r7,0
800080ea:	c0 30       	breq	800080f0 <xTaskResumeAll+0x74>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
800080ec:	f0 1f 00 19 	mcall	80008150 <xTaskResumeAll+0xd4>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
800080f0:	49 98       	lddpc	r8,80008154 <xTaskResumeAll+0xd8>
800080f2:	70 07       	ld.w	r7,r8[0x0]

                    if( xPendedCounts > ( TickType_t ) 0U )
800080f4:	58 07       	cp.w	r7,0
800080f6:	c0 c0       	breq	8000810e <xTaskResumeAll+0x92>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
800080f8:	49 36       	lddpc	r6,80008144 <xTaskResumeAll+0xc8>
800080fa:	30 15       	mov	r5,1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
800080fc:	f0 1f 00 17 	mcall	80008158 <xTaskResumeAll+0xdc>
                            {
                                xYieldPending = pdTRUE;
80008100:	ed f5 1a 00 	st.wne	r6[0x0],r5
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
80008104:	20 17       	sub	r7,1
                        } while( xPendedCounts > ( TickType_t ) 0U );
80008106:	cf b1       	brne	800080fc <xTaskResumeAll+0x80>

                        xPendedTicks = 0;
80008108:	30 09       	mov	r9,0
8000810a:	49 38       	lddpc	r8,80008154 <xTaskResumeAll+0xd8>
8000810c:	91 09       	st.w	r8[0x0],r9
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
8000810e:	48 e8       	lddpc	r8,80008144 <xTaskResumeAll+0xc8>
80008110:	70 08       	ld.w	r8,r8[0x0]
80008112:	58 08       	cp.w	r8,0
80008114:	c0 40       	breq	8000811c <xTaskResumeAll+0xa0>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
80008116:	d7 33       	scall
80008118:	30 17       	mov	r7,1
8000811a:	c0 28       	rjmp	8000811e <xTaskResumeAll+0xa2>
8000811c:	30 07       	mov	r7,0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
8000811e:	f0 1f 00 10 	mcall	8000815c <xTaskResumeAll+0xe0>

    return xAlreadyYielded;
}
80008122:	0e 9c       	mov	r12,r7
80008124:	d8 32       	popm	r0-r7,pc
80008126:	00 00       	add	r0,r0
80008128:	80 00       	ld.sh	r0,r0[0x0]
8000812a:	72 e0       	ld.w	r0,r9[0x38]
8000812c:	00 00       	add	r0,r0
8000812e:	06 88       	andn	r8,r3
80008130:	00 00       	add	r0,r0
80008132:	06 a4       	st.w	r3++,r4
80008134:	00 00       	add	r0,r0
80008136:	06 5c       	eor	r12,r3
80008138:	00 00       	add	r0,r0
8000813a:	06 d4       	st.w	--r3,r4
8000813c:	00 00       	add	r0,r0
8000813e:	05 b4       	ld.ub	r4,r2[0x3]
80008140:	00 00       	add	r0,r0
80008142:	06 58       	eor	r8,r3
80008144:	00 00       	add	r0,r0
80008146:	06 d8       	st.w	--r3,r8
80008148:	80 00       	ld.sh	r0,r0[0x0]
8000814a:	72 26       	ld.w	r6,r9[0x8]
8000814c:	80 00       	ld.sh	r0,r0[0x0]
8000814e:	71 de       	ld.w	lr,r8[0x74]
80008150:	80 00       	ld.sh	r0,r0[0x0]
80008152:	7b c0       	ld.w	r0,sp[0x70]
80008154:	00 00       	add	r0,r0
80008156:	05 b0       	ld.ub	r0,r2[0x3]
80008158:	80 00       	ld.sh	r0,r0[0x0]
8000815a:	7f 74       	ld.w	r4,pc[0x5c]
8000815c:	80 00       	ld.sh	r0,r0[0x0]
8000815e:	73 ec       	ld.w	r12,r9[0x78]

80008160 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
80008160:	eb cd 40 e0 	pushm	r5-r7,lr
80008164:	18 97       	mov	r7,r12
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80008166:	f0 1f 00 1a 	mcall	800081cc <xTaskResumeFromISR+0x6c>
8000816a:	c0 31       	brne	80008170 <xTaskResumeFromISR+0x10>
8000816c:	30 06       	mov	r6,0
8000816e:	c2 c8       	rjmp	800081c6 <xTaskResumeFromISR+0x66>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80008170:	49 88       	lddpc	r8,800081d0 <xTaskResumeFromISR+0x70>
80008172:	70 08       	ld.w	r8,r8[0x0]
80008174:	58 08       	cp.w	r8,0
80008176:	c2 21       	brne	800081ba <xTaskResumeFromISR+0x5a>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80008178:	49 78       	lddpc	r8,800081d4 <xTaskResumeFromISR+0x74>
8000817a:	70 08       	ld.w	r8,r8[0x0]
8000817c:	6e b9       	ld.w	r9,r7[0x2c]
8000817e:	70 b8       	ld.w	r8,r8[0x2c]
80008180:	10 39       	cp.w	r9,r8
80008182:	c0 32       	brcc	80008188 <xTaskResumeFromISR+0x28>
80008184:	30 06       	mov	r6,0
80008186:	c0 48       	rjmp	8000818e <xTaskResumeFromISR+0x2e>
                        xYieldRequired = pdTRUE;

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
80008188:	30 16       	mov	r6,1
8000818a:	49 48       	lddpc	r8,800081d8 <xTaskResumeFromISR+0x78>
8000818c:	91 06       	st.w	r8[0x0],r6
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8000818e:	ee c5 ff fc 	sub	r5,r7,-4
80008192:	0a 9c       	mov	r12,r5
80008194:	f0 1f 00 12 	mcall	800081dc <xTaskResumeFromISR+0x7c>
                    prvAddTaskToReadyList( pxTCB );
80008198:	6e bc       	ld.w	r12,r7[0x2c]
8000819a:	49 28       	lddpc	r8,800081e0 <xTaskResumeFromISR+0x80>
8000819c:	70 08       	ld.w	r8,r8[0x0]
8000819e:	10 3c       	cp.w	r12,r8
800081a0:	e0 88 00 04 	brls	800081a8 <xTaskResumeFromISR+0x48>
800081a4:	48 f8       	lddpc	r8,800081e0 <xTaskResumeFromISR+0x80>
800081a6:	91 0c       	st.w	r8[0x0],r12
800081a8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800081ac:	0a 9b       	mov	r11,r5
800081ae:	48 e8       	lddpc	r8,800081e4 <xTaskResumeFromISR+0x84>
800081b0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800081b4:	f0 1f 00 0d 	mcall	800081e8 <xTaskResumeFromISR+0x88>
800081b8:	c0 78       	rjmp	800081c6 <xTaskResumeFromISR+0x66>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
800081ba:	ee cb ff e8 	sub	r11,r7,-24
800081be:	48 cc       	lddpc	r12,800081ec <xTaskResumeFromISR+0x8c>
800081c0:	f0 1f 00 0a 	mcall	800081e8 <xTaskResumeFromISR+0x88>
800081c4:	30 06       	mov	r6,0
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
800081c6:	0c 9c       	mov	r12,r6
800081c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800081cc:	80 00       	ld.sh	r0,r0[0x0]
800081ce:	7a f8       	ld.w	r8,sp[0x3c]
800081d0:	00 00       	add	r0,r0
800081d2:	06 88       	andn	r8,r3
800081d4:	00 00       	add	r0,r0
800081d6:	06 58       	eor	r8,r3
800081d8:	00 00       	add	r0,r0
800081da:	06 d8       	st.w	--r3,r8
800081dc:	80 00       	ld.sh	r0,r0[0x0]
800081de:	72 26       	ld.w	r6,r9[0x8]
800081e0:	00 00       	add	r0,r0
800081e2:	06 d4       	st.w	--r3,r4
800081e4:	00 00       	add	r0,r0
800081e6:	05 b4       	ld.ub	r4,r2[0x3]
800081e8:	80 00       	ld.sh	r0,r0[0x0]
800081ea:	71 de       	ld.w	lr,r8[0x74]
800081ec:	00 00       	add	r0,r0
800081ee:	06 5c       	eor	r12,r3

800081f0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
800081f0:	eb cd 40 c0 	pushm	r6-r7,lr
800081f4:	18 97       	mov	r7,r12
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
800081f6:	49 78       	lddpc	r8,80008250 <vTaskResume+0x60>
800081f8:	70 08       	ld.w	r8,r8[0x0]
800081fa:	10 3c       	cp.w	r12,r8
800081fc:	c2 70       	breq	8000824a <vTaskResume+0x5a>
800081fe:	58 0c       	cp.w	r12,0
80008200:	c2 50       	breq	8000824a <vTaskResume+0x5a>
        {
            taskENTER_CRITICAL();
80008202:	f0 1f 00 15 	mcall	80008254 <vTaskResume+0x64>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80008206:	0e 9c       	mov	r12,r7
80008208:	f0 1f 00 14 	mcall	80008258 <vTaskResume+0x68>
8000820c:	c1 d0       	breq	80008246 <vTaskResume+0x56>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8000820e:	ee c6 ff fc 	sub	r6,r7,-4
80008212:	0c 9c       	mov	r12,r6
80008214:	f0 1f 00 12 	mcall	8000825c <vTaskResume+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80008218:	6e bc       	ld.w	r12,r7[0x2c]
8000821a:	49 28       	lddpc	r8,80008260 <vTaskResume+0x70>
8000821c:	70 08       	ld.w	r8,r8[0x0]
8000821e:	10 3c       	cp.w	r12,r8
80008220:	e0 88 00 04 	brls	80008228 <vTaskResume+0x38>
80008224:	48 f8       	lddpc	r8,80008260 <vTaskResume+0x70>
80008226:	91 0c       	st.w	r8[0x0],r12
80008228:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000822c:	0c 9b       	mov	r11,r6
8000822e:	48 e8       	lddpc	r8,80008264 <vTaskResume+0x74>
80008230:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80008234:	f0 1f 00 0d 	mcall	80008268 <vTaskResume+0x78>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80008238:	48 68       	lddpc	r8,80008250 <vTaskResume+0x60>
8000823a:	70 08       	ld.w	r8,r8[0x0]
8000823c:	6e b9       	ld.w	r9,r7[0x2c]
8000823e:	70 b8       	ld.w	r8,r8[0x2c]
80008240:	10 39       	cp.w	r9,r8
80008242:	c0 23       	brcs	80008246 <vTaskResume+0x56>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
80008244:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
80008246:	f0 1f 00 0a 	mcall	8000826c <vTaskResume+0x7c>
8000824a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000824e:	00 00       	add	r0,r0
80008250:	00 00       	add	r0,r0
80008252:	06 58       	eor	r8,r3
80008254:	80 00       	ld.sh	r0,r0[0x0]
80008256:	72 e0       	ld.w	r0,r9[0x38]
80008258:	80 00       	ld.sh	r0,r0[0x0]
8000825a:	7a f8       	ld.w	r8,sp[0x3c]
8000825c:	80 00       	ld.sh	r0,r0[0x0]
8000825e:	72 26       	ld.w	r6,r9[0x8]
80008260:	00 00       	add	r0,r0
80008262:	06 d4       	st.w	--r3,r4
80008264:	00 00       	add	r0,r0
80008266:	05 b4       	ld.ub	r4,r2[0x3]
80008268:	80 00       	ld.sh	r0,r0[0x0]
8000826a:	71 de       	ld.w	lr,r8[0x74]
8000826c:	80 00       	ld.sh	r0,r0[0x0]
8000826e:	73 ec       	ld.w	r12,r9[0x78]

80008270 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
80008270:	eb cd 40 c0 	pushm	r6-r7,lr
80008274:	18 97       	mov	r7,r12
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
80008276:	f0 1f 00 23 	mcall	80008300 <vTaskSuspend+0x90>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
8000827a:	58 07       	cp.w	r7,0
8000827c:	c0 31       	brne	80008282 <vTaskSuspend+0x12>
8000827e:	4a 28       	lddpc	r8,80008304 <vTaskSuspend+0x94>
80008280:	70 07       	ld.w	r7,r8[0x0]

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80008282:	ee c6 ff fc 	sub	r6,r7,-4
80008286:	0c 9c       	mov	r12,r6
80008288:	f0 1f 00 20 	mcall	80008308 <vTaskSuspend+0x98>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
8000828c:	6e a8       	ld.w	r8,r7[0x28]
8000828e:	58 08       	cp.w	r8,0
80008290:	c0 50       	breq	8000829a <vTaskSuspend+0x2a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80008292:	ee cc ff e8 	sub	r12,r7,-24
80008296:	f0 1f 00 1d 	mcall	80008308 <vTaskSuspend+0x98>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
8000829a:	0c 9b       	mov	r11,r6
8000829c:	49 cc       	lddpc	r12,8000830c <vTaskSuspend+0x9c>
8000829e:	f0 1f 00 1d 	mcall	80008310 <vTaskSuspend+0xa0>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
800082a2:	ef 39 00 50 	ld.ub	r9,r7[80]
800082a6:	30 18       	mov	r8,1
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
800082a8:	f0 09 18 00 	cp.b	r9,r8
800082ac:	f9 b8 00 00 	moveq	r8,0
800082b0:	ef f8 0e 50 	st.beq	r7[0x50],r8
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
800082b4:	f0 1f 00 18 	mcall	80008314 <vTaskSuspend+0xa4>

        if( xSchedulerRunning != pdFALSE )
800082b8:	49 88       	lddpc	r8,80008318 <vTaskSuspend+0xa8>
800082ba:	70 08       	ld.w	r8,r8[0x0]
800082bc:	58 08       	cp.w	r8,0
800082be:	c0 70       	breq	800082cc <vTaskSuspend+0x5c>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
800082c0:	f0 1f 00 10 	mcall	80008300 <vTaskSuspend+0x90>
            {
                prvResetNextTaskUnblockTime();
800082c4:	f0 1f 00 16 	mcall	8000831c <vTaskSuspend+0xac>
            }
            taskEXIT_CRITICAL();
800082c8:	f0 1f 00 13 	mcall	80008314 <vTaskSuspend+0xa4>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
800082cc:	48 e8       	lddpc	r8,80008304 <vTaskSuspend+0x94>
800082ce:	70 08       	ld.w	r8,r8[0x0]
800082d0:	10 37       	cp.w	r7,r8
800082d2:	c1 51       	brne	800082fc <vTaskSuspend+0x8c>
        {
            if( xSchedulerRunning != pdFALSE )
800082d4:	49 18       	lddpc	r8,80008318 <vTaskSuspend+0xa8>
800082d6:	70 08       	ld.w	r8,r8[0x0]
800082d8:	58 08       	cp.w	r8,0
800082da:	c0 40       	breq	800082e2 <vTaskSuspend+0x72>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
800082dc:	d7 33       	scall
800082de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
800082e2:	48 b8       	lddpc	r8,8000830c <vTaskSuspend+0x9c>
800082e4:	70 09       	ld.w	r9,r8[0x0]
800082e6:	48 f8       	lddpc	r8,80008320 <vTaskSuspend+0xb0>
800082e8:	70 08       	ld.w	r8,r8[0x0]
800082ea:	10 39       	cp.w	r9,r8
800082ec:	c0 61       	brne	800082f8 <vTaskSuspend+0x88>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
800082ee:	30 09       	mov	r9,0
800082f0:	48 58       	lddpc	r8,80008304 <vTaskSuspend+0x94>
800082f2:	91 09       	st.w	r8[0x0],r9
800082f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                }
                else
                {
                    vTaskSwitchContext();
800082f8:	f0 1f 00 0b 	mcall	80008324 <vTaskSuspend+0xb4>
800082fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008300:	80 00       	ld.sh	r0,r0[0x0]
80008302:	72 e0       	ld.w	r0,r9[0x38]
80008304:	00 00       	add	r0,r0
80008306:	06 58       	eor	r8,r3
80008308:	80 00       	ld.sh	r0,r0[0x0]
8000830a:	72 26       	ld.w	r6,r9[0x8]
8000830c:	00 00       	add	r0,r0
8000830e:	06 c0       	st.b	r3++,r0
80008310:	80 00       	ld.sh	r0,r0[0x0]
80008312:	71 de       	ld.w	lr,r8[0x74]
80008314:	80 00       	ld.sh	r0,r0[0x0]
80008316:	73 ec       	ld.w	r12,r9[0x78]
80008318:	00 00       	add	r0,r0
8000831a:	05 a4       	ld.ub	r4,r2[0x2]
8000831c:	80 00       	ld.sh	r0,r0[0x0]
8000831e:	7b c0       	ld.w	r0,sp[0x70]
80008320:	00 00       	add	r0,r0
80008322:	06 a4       	st.w	r3++,r4
80008324:	80 00       	ld.sh	r0,r0[0x0]
80008326:	7b 28       	ld.w	r8,sp[0x48]

80008328 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
80008328:	eb cd 40 e0 	pushm	r5-r7,lr
8000832c:	18 97       	mov	r7,r12
8000832e:	16 95       	mov	r5,r11
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
80008330:	49 b8       	lddpc	r8,8000839c <prvAddCurrentTaskToDelayedList+0x74>
80008332:	70 06       	ld.w	r6,r8[0x0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80008334:	49 b8       	lddpc	r8,800083a0 <prvAddCurrentTaskToDelayedList+0x78>
80008336:	70 0c       	ld.w	r12,r8[0x0]
80008338:	2f cc       	sub	r12,-4
8000833a:	f0 1f 00 1b 	mcall	800083a4 <prvAddCurrentTaskToDelayedList+0x7c>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
8000833e:	5b f7       	cp.w	r7,-1
80008340:	5f 09       	sreq	r9
80008342:	58 05       	cp.w	r5,0
80008344:	5f 18       	srne	r8
80008346:	f3 e8 00 08 	and	r8,r9,r8
8000834a:	c0 90       	breq	8000835c <prvAddCurrentTaskToDelayedList+0x34>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
8000834c:	49 58       	lddpc	r8,800083a0 <prvAddCurrentTaskToDelayedList+0x78>
8000834e:	70 0b       	ld.w	r11,r8[0x0]
80008350:	2f cb       	sub	r11,-4
80008352:	49 6c       	lddpc	r12,800083a8 <prvAddCurrentTaskToDelayedList+0x80>
80008354:	f0 1f 00 16 	mcall	800083ac <prvAddCurrentTaskToDelayedList+0x84>
80008358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
8000835c:	0c 07       	add	r7,r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
8000835e:	49 18       	lddpc	r8,800083a0 <prvAddCurrentTaskToDelayedList+0x78>
80008360:	70 08       	ld.w	r8,r8[0x0]
80008362:	91 17       	st.w	r8[0x4],r7

                if( xTimeToWake < xConstTickCount )
80008364:	0e 36       	cp.w	r6,r7
80008366:	e0 88 00 0b 	brls	8000837c <prvAddCurrentTaskToDelayedList+0x54>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8000836a:	48 e8       	lddpc	r8,800083a0 <prvAddCurrentTaskToDelayedList+0x78>
8000836c:	70 0b       	ld.w	r11,r8[0x0]
8000836e:	49 18       	lddpc	r8,800083b0 <prvAddCurrentTaskToDelayedList+0x88>
80008370:	70 0c       	ld.w	r12,r8[0x0]
80008372:	2f cb       	sub	r11,-4
80008374:	f0 1f 00 10 	mcall	800083b4 <prvAddCurrentTaskToDelayedList+0x8c>
80008378:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8000837c:	48 98       	lddpc	r8,800083a0 <prvAddCurrentTaskToDelayedList+0x78>
8000837e:	70 0b       	ld.w	r11,r8[0x0]
80008380:	48 e8       	lddpc	r8,800083b8 <prvAddCurrentTaskToDelayedList+0x90>
80008382:	70 0c       	ld.w	r12,r8[0x0]
80008384:	2f cb       	sub	r11,-4
80008386:	f0 1f 00 0c 	mcall	800083b4 <prvAddCurrentTaskToDelayedList+0x8c>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
8000838a:	48 d8       	lddpc	r8,800083bc <prvAddCurrentTaskToDelayedList+0x94>
8000838c:	70 08       	ld.w	r8,r8[0x0]
8000838e:	10 37       	cp.w	r7,r8
80008390:	c0 32       	brcc	80008396 <prvAddCurrentTaskToDelayedList+0x6e>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
80008392:	48 b8       	lddpc	r8,800083bc <prvAddCurrentTaskToDelayedList+0x94>
80008394:	91 07       	st.w	r8[0x0],r7
80008396:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000839a:	00 00       	add	r0,r0
8000839c:	00 00       	add	r0,r0
8000839e:	06 84       	andn	r4,r3
800083a0:	00 00       	add	r0,r0
800083a2:	06 58       	eor	r8,r3
800083a4:	80 00       	ld.sh	r0,r0[0x0]
800083a6:	72 26       	ld.w	r6,r9[0x8]
800083a8:	00 00       	add	r0,r0
800083aa:	06 c0       	st.b	r3++,r0
800083ac:	80 00       	ld.sh	r0,r0[0x0]
800083ae:	71 de       	ld.w	lr,r8[0x74]
800083b0:	00 00       	add	r0,r0
800083b2:	05 ac       	ld.ub	r12,r2[0x2]
800083b4:	80 00       	ld.sh	r0,r0[0x0]
800083b6:	71 f6       	ld.w	r6,r8[0x7c]
800083b8:	00 00       	add	r0,r0
800083ba:	05 a0       	ld.ub	r0,r2[0x2]
800083bc:	00 00       	add	r0,r0
800083be:	05 9c       	ld.ub	r12,r2[0x1]

800083c0 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
800083c0:	eb cd 40 e0 	pushm	r5-r7,lr
800083c4:	18 97       	mov	r7,r12
800083c6:	16 95       	mov	r5,r11
800083c8:	14 96       	mov	r6,r10
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
800083ca:	f0 1f 00 20 	mcall	80008448 <ulTaskGenericNotifyTake+0x88>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
800083ce:	4a 08       	lddpc	r8,8000844c <ulTaskGenericNotifyTake+0x8c>
800083d0:	70 08       	ld.w	r8,r8[0x0]
800083d2:	ee c9 ff ed 	sub	r9,r7,-19
800083d6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800083da:	58 08       	cp.w	r8,0
800083dc:	c0 e1       	brne	800083f8 <ulTaskGenericNotifyTake+0x38>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
800083de:	49 c8       	lddpc	r8,8000844c <ulTaskGenericNotifyTake+0x8c>
800083e0:	70 08       	ld.w	r8,r8[0x0]
800083e2:	0e 08       	add	r8,r7
800083e4:	30 19       	mov	r9,1
800083e6:	f1 69 00 50 	st.b	r8[80],r9

                if( xTicksToWait > ( TickType_t ) 0 )
800083ea:	58 06       	cp.w	r6,0
800083ec:	c0 60       	breq	800083f8 <ulTaskGenericNotifyTake+0x38>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
800083ee:	30 1b       	mov	r11,1
800083f0:	0c 9c       	mov	r12,r6
800083f2:	f0 1f 00 18 	mcall	80008450 <ulTaskGenericNotifyTake+0x90>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
800083f6:	d7 33       	scall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
800083f8:	f0 1f 00 17 	mcall	80008454 <ulTaskGenericNotifyTake+0x94>

        taskENTER_CRITICAL();
800083fc:	f0 1f 00 13 	mcall	80008448 <ulTaskGenericNotifyTake+0x88>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
80008400:	49 38       	lddpc	r8,8000844c <ulTaskGenericNotifyTake+0x8c>
80008402:	70 08       	ld.w	r8,r8[0x0]
80008404:	ee c9 ff ed 	sub	r9,r7,-19
80008408:	f0 09 03 26 	ld.w	r6,r8[r9<<0x2]

            if( ulReturn != 0UL )
8000840c:	58 06       	cp.w	r6,0
8000840e:	c1 10       	breq	80008430 <ulTaskGenericNotifyTake+0x70>
            {
                if( xClearCountOnExit != pdFALSE )
80008410:	58 05       	cp.w	r5,0
80008412:	c0 70       	breq	80008420 <ulTaskGenericNotifyTake+0x60>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
80008414:	48 e8       	lddpc	r8,8000844c <ulTaskGenericNotifyTake+0x8c>
80008416:	70 08       	ld.w	r8,r8[0x0]
80008418:	30 0a       	mov	r10,0
8000841a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
8000841e:	c0 98       	rjmp	80008430 <ulTaskGenericNotifyTake+0x70>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
80008420:	48 b8       	lddpc	r8,8000844c <ulTaskGenericNotifyTake+0x8c>
80008422:	70 08       	ld.w	r8,r8[0x0]
80008424:	ec ca 00 01 	sub	r10,r6,1
80008428:	ee c9 ff ed 	sub	r9,r7,-19
8000842c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
80008430:	48 78       	lddpc	r8,8000844c <ulTaskGenericNotifyTake+0x8c>
80008432:	70 08       	ld.w	r8,r8[0x0]
80008434:	f0 07 00 07 	add	r7,r8,r7
80008438:	30 08       	mov	r8,0
8000843a:	ef 68 00 50 	st.b	r7[80],r8
        }
        taskEXIT_CRITICAL();
8000843e:	f0 1f 00 06 	mcall	80008454 <ulTaskGenericNotifyTake+0x94>

        return ulReturn;
    }
80008442:	0c 9c       	mov	r12,r6
80008444:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008448:	80 00       	ld.sh	r0,r0[0x0]
8000844a:	72 e0       	ld.w	r0,r9[0x38]
8000844c:	00 00       	add	r0,r0
8000844e:	06 58       	eor	r8,r3
80008450:	80 00       	ld.sh	r0,r0[0x0]
80008452:	83 28       	st.w	r1[0x8],r8
80008454:	80 00       	ld.sh	r0,r0[0x0]
80008456:	73 ec       	ld.w	r12,r9[0x78]

80008458 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
80008458:	eb cd 40 80 	pushm	r7,lr
8000845c:	18 97       	mov	r7,r12
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
8000845e:	58 0c       	cp.w	r12,0
80008460:	c0 a0       	breq	80008474 <vTaskDelay+0x1c>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
80008462:	f0 1f 00 07 	mcall	8000847c <vTaskDelay+0x24>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
80008466:	30 0b       	mov	r11,0
80008468:	0e 9c       	mov	r12,r7
8000846a:	f0 1f 00 06 	mcall	80008480 <vTaskDelay+0x28>
            }
            xAlreadyYielded = xTaskResumeAll();
8000846e:	f0 1f 00 06 	mcall	80008484 <vTaskDelay+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
80008472:	c0 21       	brne	80008476 <vTaskDelay+0x1e>
        {
            portYIELD_WITHIN_API();
80008474:	d7 33       	scall
80008476:	e3 cd 80 80 	ldm	sp++,r7,pc
8000847a:	00 00       	add	r0,r0
8000847c:	80 00       	ld.sh	r0,r0[0x0]
8000847e:	7b 18       	ld.w	r8,sp[0x44]
80008480:	80 00       	ld.sh	r0,r0[0x0]
80008482:	83 28       	st.w	r1[0x8],r8
80008484:	80 00       	ld.sh	r0,r0[0x0]
80008486:	80 7c       	ld.sh	r12,r0[0xe]

80008488 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
80008488:	eb cd 40 80 	pushm	r7,lr
8000848c:	16 97       	mov	r7,r11

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
8000848e:	48 68       	lddpc	r8,800084a4 <vTaskPlaceOnEventList+0x1c>
80008490:	70 0b       	ld.w	r11,r8[0x0]
80008492:	2e 8b       	sub	r11,-24
80008494:	f0 1f 00 05 	mcall	800084a8 <vTaskPlaceOnEventList+0x20>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80008498:	30 1b       	mov	r11,1
8000849a:	0e 9c       	mov	r12,r7
8000849c:	f0 1f 00 04 	mcall	800084ac <vTaskPlaceOnEventList+0x24>
}
800084a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800084a4:	00 00       	add	r0,r0
800084a6:	06 58       	eor	r8,r3
800084a8:	80 00       	ld.sh	r0,r0[0x0]
800084aa:	71 f6       	ld.w	r6,r8[0x7c]
800084ac:	80 00       	ld.sh	r0,r0[0x0]
800084ae:	83 28       	st.w	r1[0x8],r8

800084b0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
800084b0:	eb cd 40 80 	pushm	r7,lr
800084b4:	18 97       	mov	r7,r12

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
800084b6:	78 cc       	ld.w	r12,r12[0x30]
800084b8:	f0 1f 00 04 	mcall	800084c8 <prvDeleteTCB+0x18>
                vPortFree( pxTCB );
800084bc:	0e 9c       	mov	r12,r7
800084be:	f0 1f 00 03 	mcall	800084c8 <prvDeleteTCB+0x18>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
800084c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800084c6:	00 00       	add	r0,r0
800084c8:	80 00       	ld.sh	r0,r0[0x0]
800084ca:	74 ec       	ld.w	r12,r10[0x38]

800084cc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800084cc:	eb cd 40 f8 	pushm	r3-r7,lr
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
800084d0:	49 17       	lddpc	r7,80008514 <prvIdleTask+0x48>
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800084d2:	49 25       	lddpc	r5,80008518 <prvIdleTask+0x4c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
800084d4:	49 24       	lddpc	r4,8000851c <prvIdleTask+0x50>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
800084d6:	49 33       	lddpc	r3,80008520 <prvIdleTask+0x54>
800084d8:	c1 48       	rjmp	80008500 <prvIdleTask+0x34>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
800084da:	f0 1f 00 13 	mcall	80008524 <prvIdleTask+0x58>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800084de:	6a 38       	ld.w	r8,r5[0xc]
800084e0:	70 36       	ld.w	r6,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
800084e2:	ec cc ff fc 	sub	r12,r6,-4
800084e6:	f0 1f 00 11 	mcall	80008528 <prvIdleTask+0x5c>
                    --uxCurrentNumberOfTasks;
800084ea:	68 08       	ld.w	r8,r4[0x0]
800084ec:	20 18       	sub	r8,1
800084ee:	89 08       	st.w	r4[0x0],r8
                    --uxDeletedTasksWaitingCleanUp;
800084f0:	6e 08       	ld.w	r8,r7[0x0]
800084f2:	20 18       	sub	r8,1
800084f4:	8f 08       	st.w	r7[0x0],r8
                }
                taskEXIT_CRITICAL();
800084f6:	f0 1f 00 0e 	mcall	8000852c <prvIdleTask+0x60>

                prvDeleteTCB( pxTCB );
800084fa:	0c 9c       	mov	r12,r6
800084fc:	f0 1f 00 0d 	mcall	80008530 <prvIdleTask+0x64>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80008500:	6e 08       	ld.w	r8,r7[0x0]
80008502:	58 08       	cp.w	r8,0
80008504:	ce b1       	brne	800084da <prvIdleTask+0xe>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80008506:	66 08       	ld.w	r8,r3[0x0]
80008508:	58 18       	cp.w	r8,1
8000850a:	fe 98 ff fb 	brls	80008500 <prvIdleTask+0x34>
                {
                    taskYIELD();
8000850e:	d7 33       	scall
80008510:	cf 8b       	rjmp	80008500 <prvIdleTask+0x34>
80008512:	00 00       	add	r0,r0
80008514:	00 00       	add	r0,r0
80008516:	06 54       	eor	r4,r3
80008518:	00 00       	add	r0,r0
8000851a:	06 a8       	st.w	r3++,r8
8000851c:	00 00       	add	r0,r0
8000851e:	06 a4       	st.w	r3++,r4
80008520:	00 00       	add	r0,r0
80008522:	05 b4       	ld.ub	r4,r2[0x3]
80008524:	80 00       	ld.sh	r0,r0[0x0]
80008526:	72 e0       	ld.w	r0,r9[0x38]
80008528:	80 00       	ld.sh	r0,r0[0x0]
8000852a:	72 26       	ld.w	r6,r9[0x8]
8000852c:	80 00       	ld.sh	r0,r0[0x0]
8000852e:	73 ec       	ld.w	r12,r9[0x78]
80008530:	80 00       	ld.sh	r0,r0[0x0]
80008532:	84 b0       	ld.uh	r0,r2[0x6]

80008534 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
80008534:	eb cd 40 c0 	pushm	r6-r7,lr
80008538:	18 97       	mov	r7,r12
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
8000853a:	f0 1f 00 1d 	mcall	800085ac <vTaskDelete+0x78>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
8000853e:	58 07       	cp.w	r7,0
80008540:	c0 31       	brne	80008546 <vTaskDelete+0x12>
80008542:	49 c8       	lddpc	r8,800085b0 <vTaskDelete+0x7c>
80008544:	70 07       	ld.w	r7,r8[0x0]

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80008546:	ee c6 ff fc 	sub	r6,r7,-4
8000854a:	0c 9c       	mov	r12,r6
8000854c:	f0 1f 00 1a 	mcall	800085b4 <vTaskDelete+0x80>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80008550:	6e a8       	ld.w	r8,r7[0x28]
80008552:	58 08       	cp.w	r8,0
80008554:	c0 50       	breq	8000855e <vTaskDelete+0x2a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80008556:	ee cc ff e8 	sub	r12,r7,-24
8000855a:	f0 1f 00 17 	mcall	800085b4 <vTaskDelete+0x80>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
8000855e:	49 78       	lddpc	r8,800085b8 <vTaskDelete+0x84>
80008560:	70 09       	ld.w	r9,r8[0x0]
80008562:	2f f9       	sub	r9,-1
80008564:	91 09       	st.w	r8[0x0],r9

            if( pxTCB == pxCurrentTCB )
80008566:	49 38       	lddpc	r8,800085b0 <vTaskDelete+0x7c>
80008568:	70 08       	ld.w	r8,r8[0x0]
8000856a:	10 37       	cp.w	r7,r8
8000856c:	c0 a1       	brne	80008580 <vTaskDelete+0x4c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
8000856e:	0c 9b       	mov	r11,r6
80008570:	49 3c       	lddpc	r12,800085bc <vTaskDelete+0x88>
80008572:	f0 1f 00 14 	mcall	800085c0 <vTaskDelete+0x8c>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
80008576:	49 48       	lddpc	r8,800085c4 <vTaskDelete+0x90>
80008578:	70 09       	ld.w	r9,r8[0x0]
8000857a:	2f f9       	sub	r9,-1
8000857c:	91 09       	st.w	r8[0x0],r9
8000857e:	c0 a8       	rjmp	80008592 <vTaskDelete+0x5e>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
80008580:	49 28       	lddpc	r8,800085c8 <vTaskDelete+0x94>
80008582:	70 09       	ld.w	r9,r8[0x0]
80008584:	20 19       	sub	r9,1
80008586:	91 09       	st.w	r8[0x0],r9
                traceTASK_DELETE( pxTCB );
                prvDeleteTCB( pxTCB );
80008588:	0e 9c       	mov	r12,r7
8000858a:	f0 1f 00 11 	mcall	800085cc <vTaskDelete+0x98>

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
8000858e:	f0 1f 00 11 	mcall	800085d0 <vTaskDelete+0x9c>
            }
        }
        taskEXIT_CRITICAL();
80008592:	f0 1f 00 11 	mcall	800085d4 <vTaskDelete+0xa0>

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
80008596:	49 18       	lddpc	r8,800085d8 <vTaskDelete+0xa4>
80008598:	70 08       	ld.w	r8,r8[0x0]
8000859a:	58 08       	cp.w	r8,0
8000859c:	c0 60       	breq	800085a8 <vTaskDelete+0x74>
        {
            if( pxTCB == pxCurrentTCB )
8000859e:	48 58       	lddpc	r8,800085b0 <vTaskDelete+0x7c>
800085a0:	70 08       	ld.w	r8,r8[0x0]
800085a2:	10 37       	cp.w	r7,r8
800085a4:	c0 21       	brne	800085a8 <vTaskDelete+0x74>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
800085a6:	d7 33       	scall
800085a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800085ac:	80 00       	ld.sh	r0,r0[0x0]
800085ae:	72 e0       	ld.w	r0,r9[0x38]
800085b0:	00 00       	add	r0,r0
800085b2:	06 58       	eor	r8,r3
800085b4:	80 00       	ld.sh	r0,r0[0x0]
800085b6:	72 26       	ld.w	r6,r9[0x8]
800085b8:	00 00       	add	r0,r0
800085ba:	06 a0       	st.w	r3++,r0
800085bc:	00 00       	add	r0,r0
800085be:	06 a8       	st.w	r3++,r8
800085c0:	80 00       	ld.sh	r0,r0[0x0]
800085c2:	71 de       	ld.w	lr,r8[0x74]
800085c4:	00 00       	add	r0,r0
800085c6:	06 54       	eor	r4,r3
800085c8:	00 00       	add	r0,r0
800085ca:	06 a4       	st.w	r3++,r4
800085cc:	80 00       	ld.sh	r0,r0[0x0]
800085ce:	84 b0       	ld.uh	r0,r2[0x6]
800085d0:	80 00       	ld.sh	r0,r0[0x0]
800085d2:	7b c0       	ld.w	r0,sp[0x70]
800085d4:	80 00       	ld.sh	r0,r0[0x0]
800085d6:	73 ec       	ld.w	r12,r9[0x78]
800085d8:	00 00       	add	r0,r0
800085da:	05 a4       	ld.ub	r4,r2[0x2]

800085dc <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
800085dc:	d4 31       	pushm	r0-r7,lr
800085de:	20 1d       	sub	sp,4
800085e0:	50 0c       	stdsp	sp[0x0],r12
800085e2:	16 97       	mov	r7,r11
800085e4:	12 90       	mov	r0,r9
800085e6:	10 94       	mov	r4,r8
800085e8:	40 a2       	lddsp	r2,sp[0x28]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
800085ea:	e7 da c0 10 	bfextu	r3,r10,0x0,0x10
800085ee:	e6 0c 15 02 	lsl	r12,r3,0x2
800085f2:	f0 1f 00 61 	mcall	80008774 <xTaskCreate+0x198>
800085f6:	18 96       	mov	r6,r12

                if( pxStack != NULL )
800085f8:	c0 31       	brne	800085fe <xTaskCreate+0x22>
800085fa:	3f fc       	mov	r12,-1
800085fc:	cb a8       	rjmp	80008770 <xTaskCreate+0x194>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
800085fe:	35 4c       	mov	r12,84
80008600:	f0 1f 00 5d 	mcall	80008774 <xTaskCreate+0x198>
80008604:	18 95       	mov	r5,r12

                    if( pxNewTCB != NULL )
80008606:	c0 50       	breq	80008610 <xTaskCreate+0x34>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
80008608:	99 c6       	st.w	r12[0x30],r6
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
8000860a:	58 07       	cp.w	r7,0
8000860c:	c0 71       	brne	8000861a <xTaskCreate+0x3e>
8000860e:	c2 28       	rjmp	80008652 <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
80008610:	0c 9c       	mov	r12,r6
80008612:	f0 1f 00 5a 	mcall	80008778 <xTaskCreate+0x19c>
80008616:	3f fc       	mov	r12,-1
80008618:	ca c8       	rjmp	80008770 <xTaskCreate+0x194>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
8000861a:	0f 88       	ld.ub	r8,r7[0x0]
8000861c:	f9 68 00 34 	st.b	r12[52],r8

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80008620:	0f 89       	ld.ub	r9,r7[0x0]
80008622:	30 08       	mov	r8,0
80008624:	f0 09 18 00 	cp.b	r9,r8
80008628:	c1 10       	breq	8000864a <xTaskCreate+0x6e>
8000862a:	2f f7       	sub	r7,-1
8000862c:	f8 c8 ff cb 	sub	r8,r12,-53
80008630:	30 19       	mov	r9,1
80008632:	30 0b       	mov	r11,0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80008634:	0f 8a       	ld.ub	r10,r7[0x0]
80008636:	b0 8a       	st.b	r8[0x0],r10

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80008638:	0f 8a       	ld.ub	r10,r7[0x0]
8000863a:	f6 0a 18 00 	cp.b	r10,r11
8000863e:	c0 60       	breq	8000864a <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80008640:	2f f9       	sub	r9,-1
80008642:	2f f7       	sub	r7,-1
80008644:	2f f8       	sub	r8,-1
80008646:	59 09       	cp.w	r9,16
80008648:	cf 61       	brne	80008634 <xTaskCreate+0x58>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
8000864a:	30 08       	mov	r8,0
8000864c:	eb 68 00 43 	st.b	r5[67],r8
80008650:	c0 48       	rjmp	80008658 <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
80008652:	30 08       	mov	r8,0
80008654:	f9 68 00 34 	st.b	r12[52],r8
80008658:	58 74       	cp.w	r4,7
8000865a:	f9 b4 0b 07 	movhi	r4,7
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
8000865e:	8b b4       	st.w	r5[0x2c],r4
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
80008660:	eb 44 00 44 	st.w	r5[68],r4
            pxNewTCB->uxMutexesHeld = 0;
80008664:	30 07       	mov	r7,0
80008666:	eb 47 00 48 	st.w	r5[72],r7
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
8000866a:	ea c1 ff fc 	sub	r1,r5,-4
8000866e:	02 9c       	mov	r12,r1
80008670:	f0 1f 00 43 	mcall	8000877c <xTaskCreate+0x1a0>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80008674:	ea cc ff e8 	sub	r12,r5,-24
80008678:	f0 1f 00 41 	mcall	8000877c <xTaskCreate+0x1a0>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
8000867c:	8b 45       	st.w	r5[0x10],r5

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000867e:	e8 04 11 08 	rsub	r4,r4,8
80008682:	8b 64       	st.w	r5[0x18],r4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80008684:	8b 95       	st.w	r5[0x24],r5
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
80008686:	ea c8 ff b4 	sub	r8,r5,-76
8000868a:	91 07       	st.w	r8[0x0],r7
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
8000868c:	ea c8 ff b0 	sub	r8,r5,-80
80008690:	b0 87       	st.b	r8[0x0],r7
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
80008692:	20 13       	sub	r3,1
80008694:	ec 03 00 26 	add	r6,r6,r3<<0x2
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80008698:	00 9a       	mov	r10,r0
8000869a:	40 0b       	lddsp	r11,sp[0x0]
8000869c:	0c 9c       	mov	r12,r6
8000869e:	e0 1c ff fc 	andl	r12,0xfffc
800086a2:	f0 1f 00 38 	mcall	80008780 <xTaskCreate+0x1a4>
800086a6:	8b 0c       	st.w	r5[0x0],r12

    if( pxCreatedTask != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
800086a8:	58 02       	cp.w	r2,0
800086aa:	e5 f5 1a 00 	st.wne	r2[0x0],r5

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
800086ae:	f0 1f 00 36 	mcall	80008784 <xTaskCreate+0x1a8>
    {
        uxCurrentNumberOfTasks++;
800086b2:	4b 68       	lddpc	r8,80008788 <xTaskCreate+0x1ac>
800086b4:	70 09       	ld.w	r9,r8[0x0]
800086b6:	2f f9       	sub	r9,-1
800086b8:	91 09       	st.w	r8[0x0],r9

        if( pxCurrentTCB == NULL )
800086ba:	4b 58       	lddpc	r8,8000878c <xTaskCreate+0x1b0>
800086bc:	70 08       	ld.w	r8,r8[0x0]
800086be:	58 08       	cp.w	r8,0
800086c0:	c2 61       	brne	8000870c <xTaskCreate+0x130>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
800086c2:	4b 38       	lddpc	r8,8000878c <xTaskCreate+0x1b0>
800086c4:	91 05       	st.w	r8[0x0],r5

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
800086c6:	4b 18       	lddpc	r8,80008788 <xTaskCreate+0x1ac>
800086c8:	70 08       	ld.w	r8,r8[0x0]
800086ca:	58 18       	cp.w	r8,1
800086cc:	c2 d1       	brne	80008726 <xTaskCreate+0x14a>
800086ce:	4b 17       	lddpc	r7,80008790 <xTaskCreate+0x1b4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
800086d0:	ee c6 ff 60 	sub	r6,r7,-160
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
800086d4:	0e 9c       	mov	r12,r7
800086d6:	f0 1f 00 30 	mcall	80008794 <xTaskCreate+0x1b8>
800086da:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
800086dc:	0c 37       	cp.w	r7,r6
800086de:	cf b1       	brne	800086d4 <xTaskCreate+0xf8>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
800086e0:	4a e7       	lddpc	r7,80008798 <xTaskCreate+0x1bc>
800086e2:	0e 9c       	mov	r12,r7
800086e4:	f0 1f 00 2c 	mcall	80008794 <xTaskCreate+0x1b8>
    vListInitialise( &xDelayedTaskList2 );
800086e8:	4a d6       	lddpc	r6,8000879c <xTaskCreate+0x1c0>
800086ea:	0c 9c       	mov	r12,r6
800086ec:	f0 1f 00 2a 	mcall	80008794 <xTaskCreate+0x1b8>
    vListInitialise( &xPendingReadyList );
800086f0:	4a cc       	lddpc	r12,800087a0 <xTaskCreate+0x1c4>
800086f2:	f0 1f 00 29 	mcall	80008794 <xTaskCreate+0x1b8>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
800086f6:	4a cc       	lddpc	r12,800087a4 <xTaskCreate+0x1c8>
800086f8:	f0 1f 00 27 	mcall	80008794 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
800086fc:	4a bc       	lddpc	r12,800087a8 <xTaskCreate+0x1cc>
800086fe:	f0 1f 00 26 	mcall	80008794 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
80008702:	4a b8       	lddpc	r8,800087ac <xTaskCreate+0x1d0>
80008704:	91 07       	st.w	r8[0x0],r7
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
80008706:	4a b8       	lddpc	r8,800087b0 <xTaskCreate+0x1d4>
80008708:	91 06       	st.w	r8[0x0],r6
8000870a:	c0 e8       	rjmp	80008726 <xTaskCreate+0x14a>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
8000870c:	4a a8       	lddpc	r8,800087b4 <xTaskCreate+0x1d8>
8000870e:	70 08       	ld.w	r8,r8[0x0]
80008710:	58 08       	cp.w	r8,0
80008712:	c0 a1       	brne	80008726 <xTaskCreate+0x14a>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80008714:	49 e8       	lddpc	r8,8000878c <xTaskCreate+0x1b0>
80008716:	70 08       	ld.w	r8,r8[0x0]
80008718:	70 b9       	ld.w	r9,r8[0x2c]
8000871a:	6a b8       	ld.w	r8,r5[0x2c]
8000871c:	10 39       	cp.w	r9,r8
8000871e:	e0 8b 00 04 	brhi	80008726 <xTaskCreate+0x14a>
                {
                    pxCurrentTCB = pxNewTCB;
80008722:	49 b8       	lddpc	r8,8000878c <xTaskCreate+0x1b0>
80008724:	91 05       	st.w	r8[0x0],r5
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
80008726:	4a 58       	lddpc	r8,800087b8 <xTaskCreate+0x1dc>
80008728:	70 09       	ld.w	r9,r8[0x0]
8000872a:	2f f9       	sub	r9,-1
8000872c:	91 09       	st.w	r8[0x0],r9
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
8000872e:	6a b8       	ld.w	r8,r5[0x2c]
80008730:	4a 39       	lddpc	r9,800087bc <xTaskCreate+0x1e0>
80008732:	72 09       	ld.w	r9,r9[0x0]
80008734:	12 38       	cp.w	r8,r9
80008736:	e0 88 00 04 	brls	8000873e <xTaskCreate+0x162>
8000873a:	4a 19       	lddpc	r9,800087bc <xTaskCreate+0x1e0>
8000873c:	93 08       	st.w	r9[0x0],r8
8000873e:	6a bc       	ld.w	r12,r5[0x2c]
80008740:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80008744:	02 9b       	mov	r11,r1
80008746:	49 38       	lddpc	r8,80008790 <xTaskCreate+0x1b4>
80008748:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000874c:	f0 1f 00 1d 	mcall	800087c0 <xTaskCreate+0x1e4>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
80008750:	f0 1f 00 1d 	mcall	800087c4 <xTaskCreate+0x1e8>

    if( xSchedulerRunning != pdFALSE )
80008754:	49 88       	lddpc	r8,800087b4 <xTaskCreate+0x1d8>
80008756:	70 08       	ld.w	r8,r8[0x0]
80008758:	58 08       	cp.w	r8,0
8000875a:	c0 a0       	breq	8000876e <xTaskCreate+0x192>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
8000875c:	48 c8       	lddpc	r8,8000878c <xTaskCreate+0x1b0>
8000875e:	70 08       	ld.w	r8,r8[0x0]
80008760:	70 b9       	ld.w	r9,r8[0x2c]
80008762:	6a b8       	ld.w	r8,r5[0x2c]
80008764:	10 39       	cp.w	r9,r8
80008766:	c0 42       	brcc	8000876e <xTaskCreate+0x192>
        {
            taskYIELD_IF_USING_PREEMPTION();
80008768:	d7 33       	scall
8000876a:	30 1c       	mov	r12,1
8000876c:	c0 28       	rjmp	80008770 <xTaskCreate+0x194>
8000876e:	30 1c       	mov	r12,1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
80008770:	2f fd       	sub	sp,-4
80008772:	d8 32       	popm	r0-r7,pc
80008774:	80 00       	ld.sh	r0,r0[0x0]
80008776:	75 14       	ld.w	r4,r10[0x44]
80008778:	80 00       	ld.sh	r0,r0[0x0]
8000877a:	74 ec       	ld.w	r12,r10[0x38]
8000877c:	80 00       	ld.sh	r0,r0[0x0]
8000877e:	71 d8       	ld.w	r8,r8[0x74]
80008780:	80 00       	ld.sh	r0,r0[0x0]
80008782:	72 4e       	ld.w	lr,r9[0x10]
80008784:	80 00       	ld.sh	r0,r0[0x0]
80008786:	72 e0       	ld.w	r0,r9[0x38]
80008788:	00 00       	add	r0,r0
8000878a:	06 a4       	st.w	r3++,r4
8000878c:	00 00       	add	r0,r0
8000878e:	06 58       	eor	r8,r3
80008790:	00 00       	add	r0,r0
80008792:	05 b4       	ld.ub	r4,r2[0x3]
80008794:	80 00       	ld.sh	r0,r0[0x0]
80008796:	71 c4       	ld.w	r4,r8[0x70]
80008798:	00 00       	add	r0,r0
8000879a:	06 70       	tst	r0,r3
8000879c:	00 00       	add	r0,r0
8000879e:	06 8c       	andn	r12,r3
800087a0:	00 00       	add	r0,r0
800087a2:	06 5c       	eor	r12,r3
800087a4:	00 00       	add	r0,r0
800087a6:	06 a8       	st.w	r3++,r8
800087a8:	00 00       	add	r0,r0
800087aa:	06 c0       	st.b	r3++,r0
800087ac:	00 00       	add	r0,r0
800087ae:	05 a0       	ld.ub	r0,r2[0x2]
800087b0:	00 00       	add	r0,r0
800087b2:	05 ac       	ld.ub	r12,r2[0x2]
800087b4:	00 00       	add	r0,r0
800087b6:	05 a4       	ld.ub	r4,r2[0x2]
800087b8:	00 00       	add	r0,r0
800087ba:	06 a0       	st.w	r3++,r0
800087bc:	00 00       	add	r0,r0
800087be:	06 d4       	st.w	--r3,r4
800087c0:	80 00       	ld.sh	r0,r0[0x0]
800087c2:	71 de       	ld.w	lr,r8[0x74]
800087c4:	80 00       	ld.sh	r0,r0[0x0]
800087c6:	73 ec       	ld.w	r12,r9[0x78]

800087c8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
800087c8:	d4 01       	pushm	lr
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
800087ca:	48 f8       	lddpc	r8,80008804 <vTaskStartScheduler+0x3c>
800087cc:	1a d8       	st.w	--sp,r8
800087ce:	30 08       	mov	r8,0
800087d0:	10 99       	mov	r9,r8
800087d2:	e0 6a 01 00 	mov	r10,256
800087d6:	48 db       	lddpc	r11,80008808 <vTaskStartScheduler+0x40>
800087d8:	48 dc       	lddpc	r12,8000880c <vTaskStartScheduler+0x44>
800087da:	f0 1f 00 0e 	mcall	80008810 <vTaskStartScheduler+0x48>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
800087de:	2f fd       	sub	sp,-4
800087e0:	58 1c       	cp.w	r12,1
800087e2:	c0 d1       	brne	800087fc <vTaskStartScheduler+0x34>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
800087e4:	d3 03       	ssrf	0x10
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
800087e6:	3f f9       	mov	r9,-1
800087e8:	48 b8       	lddpc	r8,80008814 <vTaskStartScheduler+0x4c>
800087ea:	91 09       	st.w	r8[0x0],r9
        xSchedulerRunning = pdTRUE;
800087ec:	30 19       	mov	r9,1
800087ee:	48 b8       	lddpc	r8,80008818 <vTaskStartScheduler+0x50>
800087f0:	91 09       	st.w	r8[0x0],r9
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
800087f2:	30 09       	mov	r9,0
800087f4:	48 a8       	lddpc	r8,8000881c <vTaskStartScheduler+0x54>
800087f6:	91 09       	st.w	r8[0x0],r9

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
800087f8:	f0 1f 00 0a 	mcall	80008820 <vTaskStartScheduler+0x58>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
800087fc:	48 a8       	lddpc	r8,80008824 <vTaskStartScheduler+0x5c>
800087fe:	70 08       	ld.w	r8,r8[0x0]
}
80008800:	d8 02       	popm	pc
80008802:	00 00       	add	r0,r0
80008804:	00 00       	add	r0,r0
80008806:	06 bc       	st.h	r3++,r12
80008808:	80 00       	ld.sh	r0,r0[0x0]
8000880a:	b7 9c       	lsr	r12,0x17
8000880c:	80 00       	ld.sh	r0,r0[0x0]
8000880e:	84 cc       	ld.uh	r12,r2[0x8]
80008810:	80 00       	ld.sh	r0,r0[0x0]
80008812:	85 dc       	st.w	r2[0x34],r12
80008814:	00 00       	add	r0,r0
80008816:	05 9c       	ld.ub	r12,r2[0x1]
80008818:	00 00       	add	r0,r0
8000881a:	05 a4       	ld.ub	r4,r2[0x2]
8000881c:	00 00       	add	r0,r0
8000881e:	06 84       	andn	r4,r3
80008820:	80 00       	ld.sh	r0,r0[0x0]
80008822:	72 f0       	ld.w	r0,r9[0x3c]
80008824:	00 00       	add	r0,r0
80008826:	00 28       	rsub	r8,r0

80008828 <check_sd_card>:
	pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
	
}

void check_sd_card(void)
{
80008828:	d4 01       	pushm	lr
	// NECESSARY: Initialize USART first.
	print_dbg("\r\nInit SD/MMC Driver");
8000882a:	49 0c       	lddpc	r12,80008868 <check_sd_card+0x40>
8000882c:	f0 1f 00 10 	mcall	8000886c <check_sd_card+0x44>
	print_dbg("\r\nInsert SD/MMC...");
80008830:	49 0c       	lddpc	r12,80008870 <check_sd_card+0x48>
80008832:	f0 1f 00 0f 	mcall	8000886c <check_sd_card+0x44>
		
	while (!sd_mmc_spi_mem_check());
80008836:	f0 1f 00 10 	mcall	80008874 <check_sd_card+0x4c>
8000883a:	cf e0       	breq	80008836 <check_sd_card+0xe>
	print_dbg("\r\nCard detected!");
8000883c:	48 fc       	lddpc	r12,80008878 <check_sd_card+0x50>
8000883e:	f0 1f 00 0c 	mcall	8000886c <check_sd_card+0x44>
		
	// Read Card capacity
	sd_mmc_spi_get_capacity();
80008842:	f0 1f 00 0f 	mcall	8000887c <check_sd_card+0x54>
	print_dbg("Capacity = ");
80008846:	48 fc       	lddpc	r12,80008880 <check_sd_card+0x58>
80008848:	f0 1f 00 09 	mcall	8000886c <check_sd_card+0x44>
	print_dbg_ulong(capacity >> 20);
8000884c:	48 e8       	lddpc	r8,80008884 <check_sd_card+0x5c>
8000884e:	f0 e8 00 00 	ld.d	r8,r8[0]
80008852:	f0 0c 16 14 	lsr	r12,r8,0x14
80008856:	f9 e9 10 cc 	or	r12,r12,r9<<0xc
8000885a:	f0 1f 00 0c 	mcall	80008888 <check_sd_card+0x60>
	print_dbg(" MBytes\r\n");
8000885e:	48 cc       	lddpc	r12,8000888c <check_sd_card+0x64>
80008860:	f0 1f 00 03 	mcall	8000886c <check_sd_card+0x44>
}
80008864:	d8 02       	popm	pc
80008866:	00 00       	add	r0,r0
80008868:	80 01       	ld.sh	r1,r0[0x0]
8000886a:	50 f4       	stdsp	sp[0x3c],r4
8000886c:	80 00       	ld.sh	r0,r0[0x0]
8000886e:	6f 6c       	ld.w	r12,r7[0x58]
80008870:	80 01       	ld.sh	r1,r0[0x0]
80008872:	51 0c       	stdsp	sp[0x40],r12
80008874:	80 00       	ld.sh	r0,r0[0x0]
80008876:	39 14       	mov	r4,-111
80008878:	80 01       	ld.sh	r1,r0[0x0]
8000887a:	51 20       	stdsp	sp[0x48],r0
8000887c:	80 00       	ld.sh	r0,r0[0x0]
8000887e:	2e 00       	sub	r0,-32
80008880:	80 01       	ld.sh	r1,r0[0x0]
80008882:	51 34       	stdsp	sp[0x4c],r4
80008884:	00 00       	add	r0,r0
80008886:	13 5c       	ld.sh	r12,--r9
80008888:	80 00       	ld.sh	r0,r0[0x0]
8000888a:	6f 58       	ld.w	r8,r7[0x54]
8000888c:	80 01       	ld.sh	r1,r0[0x0]
8000888e:	51 40       	stdsp	sp[0x50],r0

80008890 <sd_mmc_resources_init>:

#include "conf_spi_sd.h"

// SPI
void sd_mmc_resources_init(void)
{
80008890:	eb cd 40 80 	pushm	r7,lr
80008894:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80008896:	49 98       	lddpc	r8,800088f8 <sd_mmc_resources_init+0x68>
80008898:	1a 97       	mov	r7,sp
8000889a:	f0 ea 00 00 	ld.d	r10,r8[0]
8000889e:	fa eb 00 00 	st.d	sp[0],r10
800088a2:	f0 e8 00 08 	ld.d	r8,r8[8]
800088a6:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
800088aa:	30 4b       	mov	r11,4
800088ac:	49 4c       	lddpc	r12,800088fc <sd_mmc_resources_init+0x6c>
800088ae:	f0 1f 00 15 	mcall	80008900 <sd_mmc_resources_init+0x70>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
800088b2:	1a 9b       	mov	r11,sp
800088b4:	fe 7c 24 00 	mov	r12,-56320
800088b8:	f0 1f 00 13 	mcall	80008904 <sd_mmc_resources_init+0x74>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
800088bc:	30 09       	mov	r9,0
800088be:	12 9a       	mov	r10,r9
800088c0:	12 9b       	mov	r11,r9
800088c2:	fe 7c 24 00 	mov	r12,-56320
800088c6:	f0 1f 00 11 	mcall	80008908 <sd_mmc_resources_init+0x78>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
800088ca:	fe 7c 24 00 	mov	r12,-56320
800088ce:	f0 1f 00 10 	mcall	8000890c <sd_mmc_resources_init+0x7c>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, PBA_HZ);
800088d2:	20 4d       	sub	sp,16
800088d4:	ee e8 00 00 	ld.d	r8,r7[0]
800088d8:	fa e9 00 00 	st.d	sp[0],r8
800088dc:	ee e8 00 08 	ld.d	r8,r7[8]
800088e0:	fa e9 00 08 	st.d	sp[8],r8
800088e4:	e0 6c 76 00 	mov	r12,30208
800088e8:	ea 1c 03 b3 	orh	r12,0x3b3
800088ec:	f0 1f 00 09 	mcall	80008910 <sd_mmc_resources_init+0x80>
800088f0:	2f cd       	sub	sp,-16
	
}
800088f2:	2f cd       	sub	sp,-16
800088f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800088f8:	80 01       	ld.sh	r1,r0[0x0]
800088fa:	50 c4       	stdsp	sp[0x30],r4
800088fc:	80 01       	ld.sh	r1,r0[0x0]
800088fe:	50 d4       	stdsp	sp[0x34],r4
80008900:	80 00       	ld.sh	r0,r0[0x0]
80008902:	9d 88       	st.w	lr[0x20],r8
80008904:	80 00       	ld.sh	r0,r0[0x0]
80008906:	42 a2       	lddsp	r2,sp[0xa8]
80008908:	80 00       	ld.sh	r0,r0[0x0]
8000890a:	42 da       	lddsp	r10,sp[0xb4]
8000890c:	80 00       	ld.sh	r0,r0[0x0]
8000890e:	43 06       	lddsp	r6,sp[0xc0]
80008910:	80 00       	ld.sh	r0,r0[0x0]
80008912:	39 3c       	mov	r12,-109

80008914 <master_callback>:

	else if( arg == AUDIO_ADC_RELOAD_CB )
	{
		adc_reload_callback();;
	}
}
80008914:	5e fc       	retal	r12
80008916:	d7 03       	nop

80008918 <RT_ISR_gpio_qt_71_not_naked>:
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
{
80008918:	d4 01       	pushm	lr
	// ENTER, LEFT, RIGHT
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER))
8000891a:	33 ac       	mov	r12,58
8000891c:	f0 1f 00 17 	mcall	80008978 <RT_ISR_gpio_qt_71_not_naked+0x60>
80008920:	c0 b0       	breq	80008936 <RT_ISR_gpio_qt_71_not_naked+0x1e>
	{
		INTC_QT_FLAG._enter = true;
80008922:	49 78       	lddpc	r8,8000897c <RT_ISR_gpio_qt_71_not_naked+0x64>
80008924:	11 89       	ld.ub	r9,r8[0x0]
80008926:	30 1a       	mov	r10,1
80008928:	f3 da d0 e1 	bfins	r9,r10,0x7,0x1
8000892c:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER);
8000892e:	33 ac       	mov	r12,58
80008930:	f0 1f 00 14 	mcall	80008980 <RT_ISR_gpio_qt_71_not_naked+0x68>
80008934:	c1 c8       	rjmp	8000896c <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT))
80008936:	33 9c       	mov	r12,57
80008938:	f0 1f 00 10 	mcall	80008978 <RT_ISR_gpio_qt_71_not_naked+0x60>
8000893c:	c0 b0       	breq	80008952 <RT_ISR_gpio_qt_71_not_naked+0x3a>
	{
		INTC_QT_FLAG._left = true;
8000893e:	49 08       	lddpc	r8,8000897c <RT_ISR_gpio_qt_71_not_naked+0x64>
80008940:	11 89       	ld.ub	r9,r8[0x0]
80008942:	30 1a       	mov	r10,1
80008944:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
80008948:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT);
8000894a:	33 9c       	mov	r12,57
8000894c:	f0 1f 00 0d 	mcall	80008980 <RT_ISR_gpio_qt_71_not_naked+0x68>
80008950:	c0 e8       	rjmp	8000896c <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT))
80008952:	33 8c       	mov	r12,56
80008954:	f0 1f 00 09 	mcall	80008978 <RT_ISR_gpio_qt_71_not_naked+0x60>
80008958:	c0 a0       	breq	8000896c <RT_ISR_gpio_qt_71_not_naked+0x54>
	{
		INTC_QT_FLAG._right = true;
8000895a:	48 98       	lddpc	r8,8000897c <RT_ISR_gpio_qt_71_not_naked+0x64>
8000895c:	11 89       	ld.ub	r9,r8[0x0]
8000895e:	30 1a       	mov	r10,1
80008960:	f3 da d0 a1 	bfins	r9,r10,0x5,0x1
80008964:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT);
80008966:	33 8c       	mov	r12,56
80008968:	f0 1f 00 06 	mcall	80008980 <RT_ISR_gpio_qt_71_not_naked+0x68>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
8000896c:	48 68       	lddpc	r8,80008984 <RT_ISR_gpio_qt_71_not_naked+0x6c>
8000896e:	70 0c       	ld.w	r12,r8[0x0]
80008970:	f0 1f 00 06 	mcall	80008988 <RT_ISR_gpio_qt_71_not_naked+0x70>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80008974:	5f 1c       	srne	r12
80008976:	d8 02       	popm	pc
80008978:	80 00       	ld.sh	r0,r0[0x0]
8000897a:	9e 76       	ld.sh	r6,pc[0xe]
8000897c:	00 00       	add	r0,r0
8000897e:	16 9c       	mov	r12,r11
80008980:	80 00       	ld.sh	r0,r0[0x0]
80008982:	9e 8e       	ld.uh	lr,pc[0x0]
80008984:	00 00       	add	r0,r0
80008986:	06 e4       	st.h	--r3,r4
80008988:	80 00       	ld.sh	r0,r0[0x0]
8000898a:	81 60       	st.w	r0[0x18],r0

8000898c <RT_ISR_gpio_qt_71>:

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
8000898c:	eb cd 00 ff 	pushm	r0-r7
80008990:	e0 68 00 24 	mov	r8,36
80008994:	ea 18 00 00 	orh	r8,0x0
80008998:	70 00       	ld.w	r0,r8[0x0]
8000899a:	1a d0       	st.w	--sp,r0
8000899c:	7a 90       	ld.w	r0,sp[0x24]
8000899e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800089a2:	58 10       	cp.w	r0,1
800089a4:	e0 8b 00 08 	brhi	800089b4 <LABEL_ISR_SKIP_SAVE_CONTEXT_1050>
800089a8:	e0 68 06 58 	mov	r8,1624
800089ac:	ea 18 00 00 	orh	r8,0x0
800089b0:	70 00       	ld.w	r0,r8[0x0]
800089b2:	81 0d       	st.w	r0[0x0],sp

800089b4 <LABEL_ISR_SKIP_SAVE_CONTEXT_1050>:
800089b4:	f0 1f 00 10 	mcall	800089f4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1050+0x14>
800089b8:	7a 90       	ld.w	r0,sp[0x24]
800089ba:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800089be:	58 10       	cp.w	r0,1
800089c0:	e0 8b 00 10 	brhi	800089e0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1050>
800089c4:	58 1c       	cp.w	r12,1
800089c6:	c0 71       	brne	800089d4 <LABEL_ISR_RESTORE_CONTEXT_1050>
800089c8:	f0 1f 00 0c 	mcall	800089f8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1050+0x18>
800089cc:	f0 1f 00 0c 	mcall	800089fc <LABEL_ISR_SKIP_RESTORE_CONTEXT_1050+0x1c>
800089d0:	f0 1f 00 0c 	mcall	80008a00 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1050+0x20>

800089d4 <LABEL_ISR_RESTORE_CONTEXT_1050>:
800089d4:	e0 68 06 58 	mov	r8,1624
800089d8:	ea 18 00 00 	orh	r8,0x0
800089dc:	70 00       	ld.w	r0,r8[0x0]
800089de:	60 0d       	ld.w	sp,r0[0x0]

800089e0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1050>:
800089e0:	1b 00       	ld.w	r0,sp++
800089e2:	e0 68 00 24 	mov	r8,36
800089e6:	ea 18 00 00 	orh	r8,0x0
800089ea:	91 00       	st.w	r8[0x0],r0
800089ec:	e3 cd 00 ff 	ldm	sp++,r0-r7
800089f0:	d6 03       	rete
800089f2:	00 00       	add	r0,r0
800089f4:	80 00       	ld.sh	r0,r0[0x0]
800089f6:	89 18       	st.w	r4[0x4],r8
800089f8:	80 00       	ld.sh	r0,r0[0x0]
800089fa:	72 e0       	ld.w	r0,r9[0x38]
800089fc:	80 00       	ld.sh	r0,r0[0x0]
800089fe:	7b 28       	ld.w	r8,sp[0x48]
80008a00:	80 00       	ld.sh	r0,r0[0x0]
80008a02:	73 ec       	ld.w	r12,r9[0x78]

80008a04 <RT_ISR_gpio_qt_70_not_naked>:
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
{
80008a04:	d4 01       	pushm	lr
	// UP, DOWN
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP))
80008a06:	33 6c       	mov	r12,54
80008a08:	f0 1f 00 10 	mcall	80008a48 <RT_ISR_gpio_qt_70_not_naked+0x44>
80008a0c:	c0 b0       	breq	80008a22 <RT_ISR_gpio_qt_70_not_naked+0x1e>
	{
		INTC_QT_FLAG._up = true;
80008a0e:	49 08       	lddpc	r8,80008a4c <RT_ISR_gpio_qt_70_not_naked+0x48>
80008a10:	11 89       	ld.ub	r9,r8[0x0]
80008a12:	30 1a       	mov	r10,1
80008a14:	f3 da d0 81 	bfins	r9,r10,0x4,0x1
80008a18:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP);
80008a1a:	33 6c       	mov	r12,54
80008a1c:	f0 1f 00 0d 	mcall	80008a50 <RT_ISR_gpio_qt_70_not_naked+0x4c>
80008a20:	c0 e8       	rjmp	80008a3c <RT_ISR_gpio_qt_70_not_naked+0x38>

	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN))
80008a22:	33 7c       	mov	r12,55
80008a24:	f0 1f 00 09 	mcall	80008a48 <RT_ISR_gpio_qt_70_not_naked+0x44>
80008a28:	c0 a0       	breq	80008a3c <RT_ISR_gpio_qt_70_not_naked+0x38>
	{
		INTC_QT_FLAG._down = true;
80008a2a:	48 98       	lddpc	r8,80008a4c <RT_ISR_gpio_qt_70_not_naked+0x48>
80008a2c:	11 89       	ld.ub	r9,r8[0x0]
80008a2e:	30 1a       	mov	r10,1
80008a30:	f3 da d0 61 	bfins	r9,r10,0x3,0x1
80008a34:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN);
80008a36:	33 7c       	mov	r12,55
80008a38:	f0 1f 00 06 	mcall	80008a50 <RT_ISR_gpio_qt_70_not_naked+0x4c>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
80008a3c:	48 68       	lddpc	r8,80008a54 <RT_ISR_gpio_qt_70_not_naked+0x50>
80008a3e:	70 0c       	ld.w	r12,r8[0x0]
80008a40:	f0 1f 00 06 	mcall	80008a58 <RT_ISR_gpio_qt_70_not_naked+0x54>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80008a44:	5f 1c       	srne	r12
80008a46:	d8 02       	popm	pc
80008a48:	80 00       	ld.sh	r0,r0[0x0]
80008a4a:	9e 76       	ld.sh	r6,pc[0xe]
80008a4c:	00 00       	add	r0,r0
80008a4e:	16 9c       	mov	r12,r11
80008a50:	80 00       	ld.sh	r0,r0[0x0]
80008a52:	9e 8e       	ld.uh	lr,pc[0x0]
80008a54:	00 00       	add	r0,r0
80008a56:	06 e4       	st.h	--r3,r4
80008a58:	80 00       	ld.sh	r0,r0[0x0]
80008a5a:	81 60       	st.w	r0[0x18],r0

80008a5c <RT_ISR_gpio_qt_70>:
		vTaskSuspend(NULL);
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
80008a5c:	eb cd 00 ff 	pushm	r0-r7
80008a60:	e0 68 00 24 	mov	r8,36
80008a64:	ea 18 00 00 	orh	r8,0x0
80008a68:	70 00       	ld.w	r0,r8[0x0]
80008a6a:	1a d0       	st.w	--sp,r0
80008a6c:	7a 90       	ld.w	r0,sp[0x24]
80008a6e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a72:	58 10       	cp.w	r0,1
80008a74:	e0 8b 00 08 	brhi	80008a84 <LABEL_ISR_SKIP_SAVE_CONTEXT_1029>
80008a78:	e0 68 06 58 	mov	r8,1624
80008a7c:	ea 18 00 00 	orh	r8,0x0
80008a80:	70 00       	ld.w	r0,r8[0x0]
80008a82:	81 0d       	st.w	r0[0x0],sp

80008a84 <LABEL_ISR_SKIP_SAVE_CONTEXT_1029>:
80008a84:	f0 1f 00 10 	mcall	80008ac4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1029+0x14>
80008a88:	7a 90       	ld.w	r0,sp[0x24]
80008a8a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a8e:	58 10       	cp.w	r0,1
80008a90:	e0 8b 00 10 	brhi	80008ab0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1029>
80008a94:	58 1c       	cp.w	r12,1
80008a96:	c0 71       	brne	80008aa4 <LABEL_ISR_RESTORE_CONTEXT_1029>
80008a98:	f0 1f 00 0c 	mcall	80008ac8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1029+0x18>
80008a9c:	f0 1f 00 0c 	mcall	80008acc <LABEL_ISR_SKIP_RESTORE_CONTEXT_1029+0x1c>
80008aa0:	f0 1f 00 0c 	mcall	80008ad0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1029+0x20>

80008aa4 <LABEL_ISR_RESTORE_CONTEXT_1029>:
80008aa4:	e0 68 06 58 	mov	r8,1624
80008aa8:	ea 18 00 00 	orh	r8,0x0
80008aac:	70 00       	ld.w	r0,r8[0x0]
80008aae:	60 0d       	ld.w	sp,r0[0x0]

80008ab0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_1029>:
80008ab0:	1b 00       	ld.w	r0,sp++
80008ab2:	e0 68 00 24 	mov	r8,36
80008ab6:	ea 18 00 00 	orh	r8,0x0
80008aba:	91 00       	st.w	r8[0x0],r0
80008abc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008ac0:	d6 03       	rete
80008ac2:	00 00       	add	r0,r0
80008ac4:	80 00       	ld.sh	r0,r0[0x0]
80008ac6:	8a 04       	ld.sh	r4,r5[0x0]
80008ac8:	80 00       	ld.sh	r0,r0[0x0]
80008aca:	72 e0       	ld.w	r0,r9[0x38]
80008acc:	80 00       	ld.sh	r0,r0[0x0]
80008ace:	7b 28       	ld.w	r8,sp[0x48]
80008ad0:	80 00       	ld.sh	r0,r0[0x0]
80008ad2:	73 ec       	ld.w	r12,r9[0x78]

80008ad4 <main>:
/*-----------------------------------------------------------*/
/*							 MAIN							 */
/*-----------------------------------------------------------*/

int main (void)
{
80008ad4:	eb cd 40 c0 	pushm	r6-r7,lr
80008ad8:	21 0d       	sub	sp,64

/***************   MAIN   ***************/
static void init_sys_clocks(void)
{
  // Switch to OSC0 to speed up the booting
  pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80008ada:	30 3a       	mov	r10,3
80008adc:	e0 6b 1b 00 	mov	r11,6912
80008ae0:	ea 1b 00 b7 	orh	r11,0xb7
80008ae4:	fe 7c 0c 00 	mov	r12,-62464
80008ae8:	f0 1f 00 b8 	mcall	80008dc8 <main+0x2f4>

  // Start oscillator1
  pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
80008aec:	e0 6b 44 00 	mov	r11,17408
80008af0:	ea 1b 00 ac 	orh	r11,0xac
80008af4:	fe 7c 0c 00 	mov	r12,-62464
80008af8:	f0 1f 00 b5 	mcall	80008dcc <main+0x2f8>
  pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
80008afc:	30 3b       	mov	r11,3
80008afe:	fe 7c 0c 00 	mov	r12,-62464
80008b02:	f0 1f 00 b4 	mcall	80008dd0 <main+0x2fc>

  // Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
  // We use OSC1 since we need a correct master clock for the SSC module to generate
  //
  pm_pll_setup(&AVR32_PM, 0,  // pll.
80008b06:	31 06       	mov	r6,16
80008b08:	1a d6       	st.w	--sp,r6
80008b0a:	30 18       	mov	r8,1
80008b0c:	10 99       	mov	r9,r8
80008b0e:	30 aa       	mov	r10,10
80008b10:	30 0b       	mov	r11,0
80008b12:	fe 7c 0c 00 	mov	r12,-62464
80008b16:	f0 1f 00 b0 	mcall	80008dd4 <main+0x300>
    1,   // osc.
    16); // lockcount.

  // Set PLL operating range and divider (fpll = fvco/2)
  // -> PLL0 output = 62.0928 MHz
  pm_pll_set_option(&AVR32_PM, 0, // pll.
80008b1a:	30 08       	mov	r8,0
80008b1c:	30 19       	mov	r9,1
80008b1e:	12 9a       	mov	r10,r9
80008b20:	10 9b       	mov	r11,r8
80008b22:	fe 7c 0c 00 	mov	r12,-62464
80008b26:	f0 1f 00 ad 	mcall	80008dd8 <main+0x304>
    1,  // pll_freq.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL0 and wait for the lock
  pm_pll_enable(&AVR32_PM, 0);
80008b2a:	30 0b       	mov	r11,0
80008b2c:	fe 7c 0c 00 	mov	r12,-62464
80008b30:	f0 1f 00 ab 	mcall	80008ddc <main+0x308>
  pm_wait_for_pll0_locked(&AVR32_PM);
80008b34:	fe 7c 0c 00 	mov	r12,-62464
80008b38:	f0 1f 00 aa 	mcall	80008de0 <main+0x30c>
  // Set all peripheral clocks torun at master clock rate
  pm_cksel(&AVR32_PM,
80008b3c:	30 07       	mov	r7,0
80008b3e:	1a d7       	st.w	--sp,r7
80008b40:	1a d7       	st.w	--sp,r7
80008b42:	0e 98       	mov	r8,r7
80008b44:	0e 99       	mov	r9,r7
80008b46:	0e 9a       	mov	r10,r7
80008b48:	0e 9b       	mov	r11,r7
80008b4a:	fe 7c 0c 00 	mov	r12,-62464
80008b4e:	f0 1f 00 a6 	mcall	80008de4 <main+0x310>
    0,   // pbbsel.
    0,   // hsbdiv.
    0);  // hsbsel.

  // Set one waitstate for the flash
  flashc_set_wait_state(1);
80008b52:	30 1c       	mov	r12,1
80008b54:	f0 1f 00 a5 	mcall	80008de8 <main+0x314>

  // Switch to PLL0 as the master clock
  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
80008b58:	30 2b       	mov	r11,2
80008b5a:	fe 7c 0c 00 	mov	r12,-62464
80008b5e:	f0 1f 00 a4 	mcall	80008dec <main+0x318>

  // Use 12MHz from OSC0 and generate 96 MHz
  pm_pll_setup(&AVR32_PM, 1,  // pll.
80008b62:	1a d6       	st.w	--sp,r6
80008b64:	0e 98       	mov	r8,r7
80008b66:	30 19       	mov	r9,1
80008b68:	30 7a       	mov	r10,7
80008b6a:	12 9b       	mov	r11,r9
80008b6c:	fe 7c 0c 00 	mov	r12,-62464
80008b70:	f0 1f 00 99 	mcall	80008dd4 <main+0x300>
    7,   // mul.
    1,   // div.
    0,   // osc.
    16); // lockcount.

  pm_pll_set_option(&AVR32_PM, 1, // pll.
80008b74:	0e 98       	mov	r8,r7
80008b76:	30 19       	mov	r9,1
80008b78:	12 9a       	mov	r10,r9
80008b7a:	12 9b       	mov	r11,r9
80008b7c:	fe 7c 0c 00 	mov	r12,-62464
80008b80:	f0 1f 00 96 	mcall	80008dd8 <main+0x304>
    1,  // pll_freq: choose the range 80-180MHz.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL1 and wait forl lock
  pm_pll_enable(&AVR32_PM, 1);
80008b84:	30 1b       	mov	r11,1
80008b86:	fe 7c 0c 00 	mov	r12,-62464
80008b8a:	f0 1f 00 95 	mcall	80008ddc <main+0x308>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(&AVR32_PM);
80008b8e:	fe 7c 0c 00 	mov	r12,-62464
80008b92:	f0 1f 00 98 	mcall	80008df0 <main+0x31c>
{
	/* Insert system clock initialization code here (sysclk_init()). */
	init_sys_clocks();

	/* Initialize RS232 debug text output. */
	init_dbg_rs232(PBA_HZ); /**/
80008b96:	e0 6c 76 00 	mov	r12,30208
80008b9a:	ea 1c 03 b3 	orh	r12,0x3b3
80008b9e:	f0 1f 00 96 	mcall	80008df4 <main+0x320>
}

static void init_tft_bl(void)
{
	avr32_pwm_channel_t pwm_channel6;
	pwm_channel6.cdty = 0;
80008ba2:	50 57       	stdsp	sp[0x14],r7
	pwm_channel6.cprd = 100;
80008ba4:	36 48       	mov	r8,100
80008ba6:	50 68       	stdsp	sp[0x18],r8

	et024006_Init(PBA_HZ, PBA_HZ);
80008ba8:	e0 6b 76 00 	mov	r11,30208
80008bac:	ea 1b 03 b3 	orh	r11,0x3b3
80008bb0:	16 9c       	mov	r12,r11
80008bb2:	f0 1f 00 92 	mcall	80008df8 <main+0x324>

	pwm_opt_t opt;
	opt.diva = 0;
80008bb6:	51 17       	stdsp	sp[0x44],r7
	opt.divb = 0;
80008bb8:	51 07       	stdsp	sp[0x40],r7
	opt.prea = 0;
80008bba:	51 37       	stdsp	sp[0x4c],r7
	opt.preb = 0;
80008bbc:	51 27       	stdsp	sp[0x48],r7

	pwm_init(&opt);
80008bbe:	fa cc ff c0 	sub	r12,sp,-64
80008bc2:	f0 1f 00 8f 	mcall	80008dfc <main+0x328>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
80008bc6:	40 48       	lddsp	r8,sp[0x10]
80008bc8:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
80008bcc:	a9 b8       	sbr	r8,0x9
80008bce:	30 19       	mov	r9,1
80008bd0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
80008bd4:	50 48       	stdsp	sp[0x10],r8

	pwm_channel_init(6, &pwm_channel6);
80008bd6:	fa 06 00 0b 	add	r11,sp,r6
80008bda:	30 6c       	mov	r12,6
80008bdc:	f0 1f 00 89 	mcall	80008e00 <main+0x32c>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
80008be0:	34 0c       	mov	r12,64
80008be2:	f0 1f 00 89 	mcall	80008e04 <main+0x330>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
80008be6:	0e 98       	mov	r8,r7
80008be8:	e0 69 00 f0 	mov	r9,240
80008bec:	e0 6a 01 40 	mov	r10,320
80008bf0:	0e 9b       	mov	r11,r7
80008bf2:	0e 9c       	mov	r12,r7
80008bf4:	f0 1f 00 85 	mcall	80008e08 <main+0x334>
80008bf8:	0c 0d       	add	sp,r6
	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80008bfa:	30 67       	mov	r7,6
80008bfc:	c1 e8       	rjmp	80008c38 <main+0x164>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
80008bfe:	2f f8       	sub	r8,-1
80008c00:	50 18       	stdsp	sp[0x4],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
80008c02:	50 48       	stdsp	sp[0x10],r8
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80008c04:	1a 9b       	mov	r11,sp
80008c06:	0e 9c       	mov	r12,r7
80008c08:	f0 1f 00 81 	mcall	80008e0c <main+0x338>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80008c0c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80008c10:	e0 79 d4 c0 	mov	r9,120000
80008c14:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80008c18:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80008c1c:	14 38       	cp.w	r8,r10
80008c1e:	e0 88 00 08 	brls	80008c2e <main+0x15a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80008c22:	12 38       	cp.w	r8,r9
80008c24:	fe 98 ff fa 	brls	80008c18 <main+0x144>
80008c28:	12 3a       	cp.w	r10,r9
80008c2a:	c0 73       	brcs	80008c38 <main+0x164>
80008c2c:	cf 6b       	rjmp	80008c18 <main+0x144>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80008c2e:	12 38       	cp.w	r8,r9
80008c30:	e0 8b 00 04 	brhi	80008c38 <main+0x164>
80008c34:	12 3a       	cp.w	r10,r9
80008c36:	cf 12       	brcc	80008c18 <main+0x144>
	pwm_channel_init(6, &pwm_channel6);
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
80008c38:	40 18       	lddsp	r8,sp[0x4]
80008c3a:	40 29       	lddsp	r9,sp[0x8]
80008c3c:	12 38       	cp.w	r8,r9
80008c3e:	ce 03       	brcs	80008bfe <main+0x12a>
	/* TWI */
	const gpio_map_t TPA6130_TWI_GPIO_MAP =
	{
		{TPA6130_TWI_SCL_PIN, TPA6130_TWI_SCL_FUNCTION},
		{TPA6130_TWI_SDA_PIN, TPA6130_TWI_SDA_FUNCTION}
	};
80008c40:	4f 48       	lddpc	r8,80008e10 <main+0x33c>
80008c42:	fa cc ff e0 	sub	r12,sp,-32
80008c46:	f0 ea 00 00 	ld.d	r10,r8[0]
80008c4a:	f8 eb 00 00 	st.d	r12[0],r10
80008c4e:	f0 e8 00 08 	ld.d	r8,r8[8]
80008c52:	f8 e9 00 08 	st.d	r12[8],r8
	const twi_options_t TPA6130_TWI_OPTIONS =
	{
		.pba_hz = PBA_HZ,
		.speed  = TPA6130_TWI_MASTER_SPEED,
		.chip   = TPA6130_TWI_ADDRESS
	};
80008c56:	4f 08       	lddpc	r8,80008e14 <main+0x340>
80008c58:	fa c7 ff d0 	sub	r7,sp,-48
80008c5c:	f0 ea 00 00 	ld.d	r10,r8[0]
80008c60:	ee eb 00 00 	st.d	r7[0],r10
80008c64:	70 28       	ld.w	r8,r8[0x8]
80008c66:	8f 28       	st.w	r7[0x8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(TPA6130_TWI_GPIO_MAP,
80008c68:	30 2b       	mov	r11,2
80008c6a:	f0 1f 00 6c 	mcall	80008e18 <main+0x344>
	sizeof(TPA6130_TWI_GPIO_MAP) / sizeof(TPA6130_TWI_GPIO_MAP[0]));

	// Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
80008c6e:	0e 9b       	mov	r11,r7
80008c70:	fe 7c 2c 00 	mov	r12,-54272
80008c74:	f0 1f 00 6a 	mcall	80008e1c <main+0x348>

	/* TWA */
	tpa6130_init();
80008c78:	f0 1f 00 6a 	mcall	80008e20 <main+0x34c>

	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,
80008c7c:	e0 68 76 00 	mov	r8,30208
80008c80:	ea 18 03 b3 	orh	r8,0x3b3
80008c84:	1a d8       	st.w	--sp,r8
80008c86:	30 38       	mov	r8,3
80008c88:	1a d8       	st.w	--sp,r8
80008c8a:	4e 78       	lddpc	r8,80008e24 <main+0x350>
80008c8c:	30 09       	mov	r9,0
80008c8e:	31 0a       	mov	r10,16
80008c90:	30 2b       	mov	r11,2
80008c92:	e0 6c 2b 11 	mov	r12,11025
80008c96:	f0 1f 00 65 	mcall	80008e28 <main+0x354>
						master_callback,
						AUDIO_DAC_OUT_OF_SAMPLE_CB
						| AUDIO_DAC_RELOAD_CB,
						PBA_HZ); /**/

	tpa6130_set_volume(0x00); // 2F
80008c9a:	30 0c       	mov	r12,0
80008c9c:	f0 1f 00 64 	mcall	80008e2c <main+0x358>
	tpa6130_get_volume();
80008ca0:	f0 1f 00 64 	mcall	80008e30 <main+0x35c>

	init_tft_bl();

	init_twi_tpa();

	sd_mmc_resources_init();
80008ca4:	f0 1f 00 64 	mcall	80008e34 <main+0x360>
	check_sd_card();
80008ca8:	f0 1f 00 64 	mcall	80008e38 <main+0x364>
}

static void init_qt_interrupt(void)
{
	/* INTC */
	Disable_global_interrupt();
80008cac:	d3 03       	ssrf	0x10
	//INTC_init_interrupts();
	// QT
	INTC_register_interrupt(&RT_ISR_gpio_qt_70, 70, AVR32_INTC_INT0);
80008cae:	30 0a       	mov	r10,0
80008cb0:	34 6b       	mov	r11,70
80008cb2:	4e 3c       	lddpc	r12,80008e3c <main+0x368>
80008cb4:	f0 1f 00 63 	mcall	80008e40 <main+0x36c>
	INTC_register_interrupt(&RT_ISR_gpio_qt_71, 71, AVR32_INTC_INT0);
80008cb8:	30 0a       	mov	r10,0
80008cba:	34 7b       	mov	r11,71
80008cbc:	4e 2c       	lddpc	r12,80008e44 <main+0x370>
80008cbe:	f0 1f 00 61 	mcall	80008e40 <main+0x36c>
	Enable_global_interrupt();
80008cc2:	d5 03       	csrf	0x10

	/* GPIO */
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_UP,    GPIO_RISING_EDGE);
80008cc4:	30 1b       	mov	r11,1
80008cc6:	33 6c       	mov	r12,54
80008cc8:	f0 1f 00 60 	mcall	80008e48 <main+0x374>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_DOWN,  GPIO_RISING_EDGE);
80008ccc:	30 1b       	mov	r11,1
80008cce:	33 7c       	mov	r12,55
80008cd0:	f0 1f 00 5e 	mcall	80008e48 <main+0x374>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_LEFT,  GPIO_RISING_EDGE);
80008cd4:	30 1b       	mov	r11,1
80008cd6:	33 9c       	mov	r12,57
80008cd8:	f0 1f 00 5c 	mcall	80008e48 <main+0x374>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_RIGHT, GPIO_RISING_EDGE);
80008cdc:	30 1b       	mov	r11,1
80008cde:	33 8c       	mov	r12,56
80008ce0:	f0 1f 00 5a 	mcall	80008e48 <main+0x374>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_ENTER, GPIO_RISING_EDGE);
80008ce4:	30 1b       	mov	r11,1
80008ce6:	33 ac       	mov	r12,58
80008ce8:	f0 1f 00 58 	mcall	80008e48 <main+0x374>

	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
80008cec:	30 09       	mov	r9,0
80008cee:	4d 88       	lddpc	r8,80008e4c <main+0x378>
80008cf0:	b0 89       	st.b	r8[0x0],r9
{
	/*Inicialiazamos los archivos de la SD manejada por SPI, para lograr que funcionara tuvo que habilitarla mediante el
	conf_access.h y conf_explorer.h, debido a que por default viene habilitada la memoria incluida en la EVK*/
	
#ifdef FREERTOS_USED
	if (ctrl_access_init())
80008cf2:	f0 1f 00 58 	mcall	80008e50 <main+0x37c>
80008cf6:	2f ed       	sub	sp,-8
80008cf8:	58 0c       	cp.w	r12,0
80008cfa:	c0 40       	breq	80008d02 <main+0x22e>
	{
		print_dbg("Access to SD granted.\r\n");
80008cfc:	4d 6c       	lddpc	r12,80008e54 <main+0x380>
80008cfe:	f0 1f 00 57 	mcall	80008e58 <main+0x384>
	}
#endif

	first_ls = true;
80008d02:	30 19       	mov	r9,1
80008d04:	4d 68       	lddpc	r8,80008e5c <main+0x388>
80008d06:	b0 89       	st.b	r8[0x0],r9
	if (nav_drive_get() >= nav_drive_nb() || first_ls)
80008d08:	f0 1f 00 56 	mcall	80008e60 <main+0x38c>
80008d0c:	18 97       	mov	r7,r12
80008d0e:	f0 1f 00 56 	mcall	80008e64 <main+0x390>
80008d12:	f8 07 18 00 	cp.b	r7,r12
80008d16:	c0 72       	brcc	80008d24 <main+0x250>
80008d18:	4d 18       	lddpc	r8,80008e5c <main+0x388>
80008d1a:	11 89       	ld.ub	r9,r8[0x0]
80008d1c:	30 08       	mov	r8,0
80008d1e:	f0 09 18 00 	cp.b	r9,r8
80008d22:	c0 e0       	breq	80008d3e <main+0x26a>
	{
		first_ls = false;
80008d24:	30 09       	mov	r9,0
80008d26:	4c e8       	lddpc	r8,80008e5c <main+0x388>
80008d28:	b0 89       	st.b	r8[0x0],r9
		// Reset navigators .
		nav_reset();
80008d2a:	f0 1f 00 50 	mcall	80008e68 <main+0x394>
		// Use the last drive available as default.
		nav_drive_set(nav_drive_nb() - 1); // Or sd.drive_number
80008d2e:	f0 1f 00 4e 	mcall	80008e64 <main+0x390>
80008d32:	20 1c       	sub	r12,1
80008d34:	5c 5c       	castu.b	r12
80008d36:	f0 1f 00 4e 	mcall	80008e6c <main+0x398>
		//nav_drive_set(nav_drive_nb() - 1);
		// Mount it.
		nav_partition_mount();
80008d3a:	f0 1f 00 4e 	mcall	80008e70 <main+0x39c>
	}
	nav_dir_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH);
80008d3e:	31 eb       	mov	r11,30
80008d40:	4c dc       	lddpc	r12,80008e74 <main+0x3a0>
80008d42:	f0 1f 00 4e 	mcall	80008e78 <main+0x3a4>
	// Try to sort items by folders
	if (!nav_filelist_first(FS_DIR))
80008d46:	30 0c       	mov	r12,0
80008d48:	f0 1f 00 4d 	mcall	80008e7c <main+0x3a8>
80008d4c:	c0 41       	brne	80008d54 <main+0x280>
	{
		// Sort items by files
		nav_filelist_first(FS_FILE);
80008d4e:	30 1c       	mov	r12,1
80008d50:	f0 1f 00 4b 	mcall	80008e7c <main+0x3a8>
	}
	nav_filelist_reset();
80008d54:	f0 1f 00 4b 	mcall	80008e80 <main+0x3ac>
	// Get data
	sd.lun				 = get_nb_lun();				// Read actual LUN
80008d58:	f0 1f 00 4b 	mcall	80008e84 <main+0x3b0>
80008d5c:	4c b7       	lddpc	r7,80008e88 <main+0x3b4>
80008d5e:	ae 8c       	st.b	r7[0x0],r12
	sd.drive_name		 = nav_drive_getname();			// Read drive assigned letter
80008d60:	f0 1f 00 4b 	mcall	80008e8c <main+0x3b8>
80008d64:	ae 9c       	st.b	r7[0x1],r12
	sd.devices_available = nav_drive_nb();				// Read available devices. Equal to LUN
80008d66:	f0 1f 00 40 	mcall	80008e64 <main+0x390>
80008d6a:	ae ac       	st.b	r7[0x2],r12
	sd.drive_number		 = nav_drive_get();				// Returns nav_drive_nb()-1
80008d6c:	f0 1f 00 3d 	mcall	80008e60 <main+0x38c>
80008d70:	ae bc       	st.b	r7[0x3],r12
	sd.number_of_files	 = nav_filelist_nb(FS_FILE);	// Get the number of available files
80008d72:	30 1c       	mov	r12,1
80008d74:	f0 1f 00 47 	mcall	80008e90 <main+0x3bc>
80008d78:	5c 5c       	castu.b	r12
80008d7a:	ae cc       	st.b	r7[0x4],r12
	print_dbg_ulong(sd.number_of_files);
80008d7c:	f0 1f 00 46 	mcall	80008e94 <main+0x3c0>
}

static void init_sdram(void)
{
	// Initialize the external SDRAM chip.
	sdramc_init(PBA_HZ);
80008d80:	e0 6c 76 00 	mov	r12,30208
80008d84:	ea 1c 03 b3 	orh	r12,0x3b3
80008d88:	f0 1f 00 44 	mcall	80008e98 <main+0x3c4>
	print_dbg("\r\nSDRAM initialized\r\n");
80008d8c:	4c 4c       	lddpc	r12,80008e9c <main+0x3c8>
80008d8e:	f0 1f 00 33 	mcall	80008e58 <main+0x384>

	init_fs();
	
	init_sdram();

	print_dbg(MSG_WELCOME);
80008d92:	4c 4c       	lddpc	r12,80008ea0 <main+0x3cc>
80008d94:	f0 1f 00 31 	mcall	80008e58 <main+0x384>
	/* Insert application code here, after the board has been initialized. */

	//xTaskCreate(qtButtonTask,  "tQT",        256,  (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
	//xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
	//xTaskCreate(etTask,		   "tET",		 512,  (void *) 0, mainLED_TASK_PRIORITY, &etHandle);
	xTaskCreate(fsTask,		   "tFS",		 1024,  (void *) 0, mainLED_TASK_PRIORITY, &fsHandle);
80008d98:	4c 38       	lddpc	r8,80008ea4 <main+0x3d0>
80008d9a:	1a d8       	st.w	--sp,r8
80008d9c:	30 18       	mov	r8,1
80008d9e:	30 09       	mov	r9,0
80008da0:	e0 6a 04 00 	mov	r10,1024
80008da4:	4c 1b       	lddpc	r11,80008ea8 <main+0x3d4>
80008da6:	4c 2c       	lddpc	r12,80008eac <main+0x3d8>
80008da8:	f0 1f 00 42 	mcall	80008eb0 <main+0x3dc>
	xTaskCreate(sdramTask,     "tSDRAM",	 256,  (void *) 0, mainLED_TASK_PRIORITY + 1, &sdramHandle);
80008dac:	4c 28       	lddpc	r8,80008eb4 <main+0x3e0>
80008dae:	1a d8       	st.w	--sp,r8
80008db0:	30 28       	mov	r8,2
80008db2:	30 09       	mov	r9,0
80008db4:	e0 6a 01 00 	mov	r10,256
80008db8:	4c 0b       	lddpc	r11,80008eb8 <main+0x3e4>
80008dba:	4c 1c       	lddpc	r12,80008ebc <main+0x3e8>
80008dbc:	f0 1f 00 3d 	mcall	80008eb0 <main+0x3dc>
	
	vTaskStartScheduler();
80008dc0:	f0 1f 00 40 	mcall	80008ec0 <main+0x3ec>
80008dc4:	2f ed       	sub	sp,-8
80008dc6:	c0 08       	rjmp	80008dc6 <main+0x2f2>
80008dc8:	80 00       	ld.sh	r0,r0[0x0]
80008dca:	a1 64       	lsl	r4,0x0
80008dcc:	80 00       	ld.sh	r0,r0[0x0]
80008dce:	a0 40       	st.h	r0[0x8],r0
80008dd0:	80 00       	ld.sh	r0,r0[0x0]
80008dd2:	a0 98       	st.b	r0[0x1],r8
80008dd4:	80 00       	ld.sh	r0,r0[0x0]
80008dd6:	a0 fa       	st.b	r0[0x7],r10
80008dd8:	80 00       	ld.sh	r0,r0[0x0]
80008dda:	a1 1c       	ld.d	r12,--r0
80008ddc:	80 00       	ld.sh	r0,r0[0x0]
80008dde:	a1 36       	mul	r6,r0
80008de0:	80 00       	ld.sh	r0,r0[0x0]
80008de2:	a1 44       	asr	r4,0x0
80008de4:	80 00       	ld.sh	r0,r0[0x0]
80008de6:	a0 b4       	st.b	r0[0x3],r4
80008de8:	80 00       	ld.sh	r0,r0[0x0]
80008dea:	9d 28       	st.w	lr[0x8],r8
80008dec:	80 00       	ld.sh	r0,r0[0x0]
80008dee:	a1 58       	asr	r8,0x1
80008df0:	80 00       	ld.sh	r0,r0[0x0]
80008df2:	a1 4e       	asr	lr,0x0
80008df4:	80 00       	ld.sh	r0,r0[0x0]
80008df6:	6f c0       	ld.w	r0,r7[0x70]
80008df8:	80 00       	ld.sh	r0,r0[0x0]
80008dfa:	29 5c       	sub	r12,-107
80008dfc:	80 00       	ld.sh	r0,r0[0x0]
80008dfe:	42 3c       	lddsp	r12,sp[0x8c]
80008e00:	80 00       	ld.sh	r0,r0[0x0]
80008e02:	41 cc       	lddsp	r12,sp[0x70]
80008e04:	80 00       	ld.sh	r0,r0[0x0]
80008e06:	42 02       	lddsp	r2,sp[0x80]
80008e08:	80 00       	ld.sh	r0,r0[0x0]
80008e0a:	27 68       	sub	r8,118
80008e0c:	80 00       	ld.sh	r0,r0[0x0]
80008e0e:	42 14       	lddsp	r4,sp[0x84]
80008e10:	80 01       	ld.sh	r1,r0[0x0]
80008e12:	51 4c       	stdsp	sp[0x50],r12
80008e14:	80 01       	ld.sh	r1,r0[0x0]
80008e16:	51 5c       	stdsp	sp[0x54],r12
80008e18:	80 00       	ld.sh	r0,r0[0x0]
80008e1a:	9d 88       	st.w	lr[0x20],r8
80008e1c:	80 00       	ld.sh	r0,r0[0x0]
80008e1e:	47 5c       	lddsp	r12,sp[0x1d4]
80008e20:	80 00       	ld.sh	r0,r0[0x0]
80008e22:	23 00       	sub	r0,48
80008e24:	80 00       	ld.sh	r0,r0[0x0]
80008e26:	89 14       	st.w	r4[0x4],r4
80008e28:	80 00       	ld.sh	r0,r0[0x0]
80008e2a:	23 e8       	sub	r8,62
80008e2c:	80 00       	ld.sh	r0,r0[0x0]
80008e2e:	21 8c       	sub	r12,24
80008e30:	80 00       	ld.sh	r0,r0[0x0]
80008e32:	22 68       	sub	r8,38
80008e34:	80 00       	ld.sh	r0,r0[0x0]
80008e36:	88 90       	ld.uh	r0,r4[0x2]
80008e38:	80 00       	ld.sh	r0,r0[0x0]
80008e3a:	88 28       	ld.sh	r8,r4[0x4]
80008e3c:	80 00       	ld.sh	r0,r0[0x0]
80008e3e:	8a 5c       	ld.sh	r12,r5[0xa]
80008e40:	80 00       	ld.sh	r0,r0[0x0]
80008e42:	9e a8       	ld.uh	r8,pc[0x4]
80008e44:	80 00       	ld.sh	r0,r0[0x0]
80008e46:	89 8c       	st.w	r4[0x20],r12
80008e48:	80 00       	ld.sh	r0,r0[0x0]
80008e4a:	9e 30       	ld.sh	r0,pc[0x6]
80008e4c:	00 00       	add	r0,r0
80008e4e:	16 9c       	mov	r12,r11
80008e50:	80 00       	ld.sh	r0,r0[0x0]
80008e52:	71 84       	ld.w	r4,r8[0x60]
80008e54:	80 01       	ld.sh	r1,r0[0x0]
80008e56:	51 68       	stdsp	sp[0x58],r8
80008e58:	80 00       	ld.sh	r0,r0[0x0]
80008e5a:	6f 6c       	ld.w	r12,r7[0x58]
80008e5c:	00 00       	add	r0,r0
80008e5e:	06 e9       	st.h	--r3,r9
80008e60:	80 00       	ld.sh	r0,r0[0x0]
80008e62:	62 e0       	ld.w	r0,r1[0x38]
80008e64:	80 00       	ld.sh	r0,r0[0x0]
80008e66:	69 3c       	ld.w	r12,r4[0x4c]
80008e68:	80 00       	ld.sh	r0,r0[0x0]
80008e6a:	69 b8       	ld.w	r8,r4[0x6c]
80008e6c:	80 00       	ld.sh	r0,r0[0x0]
80008e6e:	68 e8       	ld.w	r8,r4[0x38]
80008e70:	80 00       	ld.sh	r0,r0[0x0]
80008e72:	68 a0       	ld.w	r0,r4[0x28]
80008e74:	00 00       	add	r0,r0
80008e76:	0a f4       	st.b	--r5,r4
80008e78:	80 00       	ld.sh	r0,r0[0x0]
80008e7a:	66 60       	ld.w	r0,r3[0x18]
80008e7c:	80 00       	ld.sh	r0,r0[0x0]
80008e7e:	67 64       	ld.w	r4,r3[0x58]
80008e80:	80 00       	ld.sh	r0,r0[0x0]
80008e82:	65 a8       	ld.w	r8,r2[0x68]
80008e84:	80 00       	ld.sh	r0,r0[0x0]
80008e86:	6f d4       	ld.w	r4,r7[0x74]
80008e88:	00 00       	add	r0,r0
80008e8a:	0f 20       	ld.uh	r0,r7++
80008e8c:	80 00       	ld.sh	r0,r0[0x0]
80008e8e:	62 ec       	ld.w	r12,r1[0x38]
80008e90:	80 00       	ld.sh	r0,r0[0x0]
80008e92:	67 a4       	ld.w	r4,r3[0x68]
80008e94:	80 00       	ld.sh	r0,r0[0x0]
80008e96:	6f 58       	ld.w	r8,r7[0x54]
80008e98:	80 00       	ld.sh	r0,r0[0x0]
80008e9a:	3d f8       	mov	r8,-33
80008e9c:	80 01       	ld.sh	r1,r0[0x0]
80008e9e:	51 80       	stdsp	sp[0x60],r0
80008ea0:	80 01       	ld.sh	r1,r0[0x0]
80008ea2:	51 98       	stdsp	sp[0x64],r8
80008ea4:	00 00       	add	r0,r0
80008ea6:	0b 18       	ld.sh	r8,r5++
80008ea8:	80 01       	ld.sh	r1,r0[0x0]
80008eaa:	51 d4       	stdsp	sp[0x74],r4
80008eac:	80 00       	ld.sh	r0,r0[0x0]
80008eae:	99 28       	st.w	r12[0x8],r8
80008eb0:	80 00       	ld.sh	r0,r0[0x0]
80008eb2:	85 dc       	st.w	r2[0x34],r12
80008eb4:	00 00       	add	r0,r0
80008eb6:	0a ec       	st.h	--r5,r12
80008eb8:	80 01       	ld.sh	r1,r0[0x0]
80008eba:	51 d8       	stdsp	sp[0x74],r8
80008ebc:	80 00       	ld.sh	r0,r0[0x0]
80008ebe:	98 78       	ld.sh	r8,r12[0xe]
80008ec0:	80 00       	ld.sh	r0,r0[0x0]
80008ec2:	87 c8       	st.w	r3[0x30],r8

80008ec4 <etTask>:
	}
}

// ethHandle
portTASK_FUNCTION( etTask, p )
{
80008ec4:	d4 31       	pushm	r0-r7,lr
80008ec6:	20 3d       	sub	sp,12
	{
		switch(state)
		{
			default:
			case MAIN:
				notif_chaneg_page = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
80008ec8:	30 07       	mov	r7,0
				if (notif_chaneg_page > 0)
				{
					change_page = true;
80008eca:	fe f4 04 b6 	ld.w	r4,pc[1206]
80008ece:	30 16       	mov	r6,1
	static bool change_dected = false;
	static menu_keys_t keys;
	
	if (mainLrQueue != 0)
	{
		if (xQueueReceive( mainLrQueue, &keys.lr, (TickType_t) 2 ))
80008ed0:	fe f5 04 b4 	ld.w	r5,pc[1204]
		}
	}
	
	if (mainUdQueue != 0)
	{
		if (xQueueReceive( mainUdQueue, &keys.ud, (TickType_t) 2 ))
80008ed4:	ea ce ff ff 	sub	lr,r5,-1
80008ed8:	50 1e       	stdsp	sp[0x4],lr
			
			et024006_PutPixmap(takeonme, 70, 0, 0, 190, 20, 70, 70);
			et024006_PrintString(song_info[index_page + 2].duration, (const unsigned char*) &FONT8x8, 190, 100, WHITE, -1);
			
			et024006_PutPixmap(fercaspian, 70, 0, 0, 190, 140, 70, 70);
			et024006_PrintString(song_info[0].duration, (const unsigned char*) &FONT8x8, 190, 220, WHITE, -1);
80008eda:	fe f8 04 ae 	ld.w	r8,pc[1198]
80008ede:	2b 08       	sub	r8,-80
80008ee0:	50 28       	stdsp	sp[0x8],r8
	{
		switch(state)
		{
			default:
			case MAIN:
				notif_chaneg_page = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
80008ee2:	30 1a       	mov	r10,1
80008ee4:	14 9b       	mov	r11,r10
80008ee6:	0e 9c       	mov	r12,r7
80008ee8:	f0 1f 01 29 	mcall	8000938c <etTask+0x4c8>
80008eec:	fe fe 04 a4 	ld.w	lr,pc[1188]
80008ef0:	9d 0c       	st.w	lr[0x0],r12
				if (notif_chaneg_page > 0)
80008ef2:	58 0c       	cp.w	r12,0
80008ef4:	e0 8a 00 03 	brle	80008efa <etTask+0x36>
				{
					change_page = true;
80008ef8:	a8 86       	st.b	r4[0x0],r6
				}
				menu_gui(false, change_page);
80008efa:	09 83       	ld.ub	r3,r4[0x0]
{
	static bool first_time	  = true;
	static bool change_dected = false;
	static menu_keys_t keys;
	
	if (mainLrQueue != 0)
80008efc:	fe f8 04 98 	ld.w	r8,pc[1176]
80008f00:	70 0c       	ld.w	r12,r8[0x0]
80008f02:	58 0c       	cp.w	r12,0
80008f04:	c0 90       	breq	80008f16 <etTask+0x52>
	{
		if (xQueueReceive( mainLrQueue, &keys.lr, (TickType_t) 2 ))
80008f06:	30 2a       	mov	r10,2
80008f08:	0a 9b       	mov	r11,r5
80008f0a:	f0 1f 01 24 	mcall	80009398 <etTask+0x4d4>
80008f0e:	c0 40       	breq	80008f16 <etTask+0x52>
		{
			change_dected = true;
80008f10:	fe f8 04 8c 	ld.w	r8,pc[1164]
80008f14:	b0 86       	st.b	r8[0x0],r6
		}
	}
	
	if (mainUdQueue != 0)
80008f16:	fe f8 04 8a 	ld.w	r8,pc[1162]
80008f1a:	70 0c       	ld.w	r12,r8[0x0]
80008f1c:	58 0c       	cp.w	r12,0
80008f1e:	c0 90       	breq	80008f30 <etTask+0x6c>
	{
		if (xQueueReceive( mainUdQueue, &keys.ud, (TickType_t) 2 ))
80008f20:	30 2a       	mov	r10,2
80008f22:	40 1b       	lddsp	r11,sp[0x4]
80008f24:	f0 1f 01 1d 	mcall	80009398 <etTask+0x4d4>
80008f28:	c0 40       	breq	80008f30 <etTask+0x6c>
		{
			change_dected = true;
80008f2a:	fe f8 04 72 	ld.w	r8,pc[1138]
80008f2e:	b0 86       	st.b	r8[0x0],r6
		}
	}
	
	if (first_time || init || change_page)
80008f30:	fe f8 04 74 	ld.w	r8,pc[1140]
80008f34:	11 89       	ld.ub	r9,r8[0x0]
80008f36:	30 08       	mov	r8,0
80008f38:	f0 09 18 00 	cp.b	r9,r8
80008f3c:	c0 41       	brne	80008f44 <etTask+0x80>
80008f3e:	58 03       	cp.w	r3,0
80008f40:	e0 80 01 32 	breq	800091a4 <etTask+0x2e0>
	{
		et024006_DrawFilledRect(0, 0, 320, 240, BLACK);
80008f44:	0e 98       	mov	r8,r7
80008f46:	e0 69 00 f0 	mov	r9,240
80008f4a:	e0 6a 01 40 	mov	r10,320
80008f4e:	0e 9b       	mov	r11,r7
80008f50:	0e 9c       	mov	r12,r7
80008f52:	f0 1f 01 16 	mcall	800093a8 <etTask+0x4e4>
		et024006_DrawVertLine(160,0,120,WHITE);
80008f56:	e0 69 ff ff 	mov	r9,65535
80008f5a:	37 8a       	mov	r10,120
80008f5c:	0e 9b       	mov	r11,r7
80008f5e:	e0 6c 00 a0 	mov	r12,160
80008f62:	f0 1f 01 13 	mcall	800093ac <etTask+0x4e8>
		et024006_DrawVertLine(160,120,120,WHITE);
80008f66:	e0 69 ff ff 	mov	r9,65535
80008f6a:	37 8a       	mov	r10,120
80008f6c:	14 9b       	mov	r11,r10
80008f6e:	e0 6c 00 a0 	mov	r12,160
80008f72:	f0 1f 01 0f 	mcall	800093ac <etTask+0x4e8>
	
		et024006_DrawHorizLine(0,120,160,WHITE);
80008f76:	e0 69 ff ff 	mov	r9,65535
80008f7a:	e0 6a 00 a0 	mov	r10,160
80008f7e:	37 8b       	mov	r11,120
80008f80:	0e 9c       	mov	r12,r7
80008f82:	f0 1f 01 0c 	mcall	800093b0 <etTask+0x4ec>
		et024006_DrawHorizLine(160,120,160,WHITE);
80008f86:	e0 69 ff ff 	mov	r9,65535
80008f8a:	e0 6a 00 a0 	mov	r10,160
80008f8e:	37 8b       	mov	r11,120
80008f90:	14 9c       	mov	r12,r10
80008f92:	f0 1f 01 08 	mcall	800093b0 <etTask+0x4ec>
	
		/* Place four images */
		// FIXME: Read images via SD card, and make this loopable
		uint8_t index_page = et_data.actual_page * 4;
80008f96:	fe f8 04 1e 	ld.w	r8,pc[1054]
80008f9a:	11 98       	ld.ub	r8,r8[0x1]
80008f9c:	f0 02 15 02 	lsl	r2,r8,0x2
80008fa0:	5c 52       	castu.b	r2
		if (et_data.actual_page == 0)
80008fa2:	58 08       	cp.w	r8,0
80008fa4:	c7 f1       	brne	800090a2 <etTask+0x1de>
		{
			et024006_PutPixmap(letdown, 70, 0, 0, 30, 140, 70, 70);
80008fa6:	34 63       	mov	r3,70
80008fa8:	1a d3       	st.w	--sp,r3
80008faa:	1a d3       	st.w	--sp,r3
80008fac:	e0 68 00 8c 	mov	r8,140
80008fb0:	1a d8       	st.w	--sp,r8
80008fb2:	31 e8       	mov	r8,30
80008fb4:	0e 99       	mov	r9,r7
80008fb6:	0e 9a       	mov	r10,r7
80008fb8:	06 9b       	mov	r11,r3
80008fba:	fe fc 03 fe 	ld.w	r12,pc[1022]
80008fbe:	f0 1f 01 00 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page].duration, (const unsigned char *) &FONT8x8, 30, 220, WHITE, -1);
80008fc2:	fe f0 03 fe 	ld.w	r0,pc[1022]
80008fc6:	e4 0e 10 64 	mul	lr,r2,100
80008fca:	50 3e       	stdsp	sp[0xc],lr
80008fcc:	1c 9c       	mov	r12,lr
80008fce:	2b 0c       	sub	r12,-80
80008fd0:	3f f1       	mov	r1,-1
80008fd2:	1a d1       	st.w	--sp,r1
80008fd4:	e0 68 ff ff 	mov	r8,65535
80008fd8:	e0 69 00 dc 	mov	r9,220
80008fdc:	31 ea       	mov	r10,30
80008fde:	00 9b       	mov	r11,r0
80008fe0:	fe fe 03 a8 	ld.w	lr,pc[936]
80008fe4:	fc 0c 00 0c 	add	r12,lr,r12
80008fe8:	f0 1f 00 f7 	mcall	800093c4 <etTask+0x500>
			
			et024006_PutPixmap(wearethechampions, 70, 0, 0, 30, 20, 70, 70);
80008fec:	1a d3       	st.w	--sp,r3
80008fee:	1a d3       	st.w	--sp,r3
80008ff0:	31 48       	mov	r8,20
80008ff2:	1a d8       	st.w	--sp,r8
80008ff4:	31 e8       	mov	r8,30
80008ff6:	0e 99       	mov	r9,r7
80008ff8:	0e 9a       	mov	r10,r7
80008ffa:	06 9b       	mov	r11,r3
80008ffc:	fe fc 03 cc 	ld.w	r12,pc[972]
80009000:	f0 1f 00 ef 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page + 1].duration, (const unsigned char*) &FONT8x8, 30, 100, WHITE, -1);
80009004:	e4 0c 10 64 	mul	r12,r2,100
80009008:	f8 cc ff 4c 	sub	r12,r12,-180
8000900c:	1a d1       	st.w	--sp,r1
8000900e:	e0 68 ff ff 	mov	r8,65535
80009012:	36 49       	mov	r9,100
80009014:	31 ea       	mov	r10,30
80009016:	00 9b       	mov	r11,r0
80009018:	fe fe 03 70 	ld.w	lr,pc[880]
8000901c:	fc 0c 00 0c 	add	r12,lr,r12
80009020:	f0 1f 00 e9 	mcall	800093c4 <etTask+0x500>
			
			et024006_PutPixmap(fercaspian, 70, 0, 0, 190, 20, 70, 70);
80009024:	2f 8d       	sub	sp,-32
80009026:	1a d3       	st.w	--sp,r3
80009028:	1a d3       	st.w	--sp,r3
8000902a:	31 48       	mov	r8,20
8000902c:	1a d8       	st.w	--sp,r8
8000902e:	e0 68 00 be 	mov	r8,190
80009032:	0e 99       	mov	r9,r7
80009034:	0e 9a       	mov	r10,r7
80009036:	06 9b       	mov	r11,r3
80009038:	fe fc 03 94 	ld.w	r12,pc[916]
8000903c:	f0 1f 00 e0 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page + 2].duration, (const unsigned char*) &FONT8x8, 190, 100, WHITE, -1);
80009040:	40 3e       	lddsp	lr,sp[0xc]
80009042:	fc cc fe e8 	sub	r12,lr,-280
80009046:	1a d1       	st.w	--sp,r1
80009048:	e0 68 ff ff 	mov	r8,65535
8000904c:	36 49       	mov	r9,100
8000904e:	e0 6a 00 be 	mov	r10,190
80009052:	00 9b       	mov	r11,r0
80009054:	fe fe 03 34 	ld.w	lr,pc[820]
80009058:	fc 0c 00 0c 	add	r12,lr,r12
8000905c:	f0 1f 00 da 	mcall	800093c4 <etTask+0x500>
			
			et024006_PutPixmap(takeonme, 70, 0, 0, 190, 140, 70, 70);
80009060:	1a d3       	st.w	--sp,r3
80009062:	1a d3       	st.w	--sp,r3
80009064:	e0 68 00 8c 	mov	r8,140
80009068:	1a d8       	st.w	--sp,r8
8000906a:	e0 68 00 be 	mov	r8,190
8000906e:	0e 99       	mov	r9,r7
80009070:	0e 9a       	mov	r10,r7
80009072:	06 9b       	mov	r11,r3
80009074:	fe fc 03 5c 	ld.w	r12,pc[860]
80009078:	f0 1f 00 d1 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page + 3].duration, (const unsigned char*) &FONT8x8, 190, 220, WHITE, -1);
8000907c:	40 7e       	lddsp	lr,sp[0x1c]
8000907e:	fc cc fe 84 	sub	r12,lr,-380
80009082:	1a d1       	st.w	--sp,r1
80009084:	e0 68 ff ff 	mov	r8,65535
80009088:	e0 69 00 dc 	mov	r9,220
8000908c:	e0 6a 00 be 	mov	r10,190
80009090:	00 9b       	mov	r11,r0
80009092:	fe fe 02 f6 	ld.w	lr,pc[758]
80009096:	fc 0c 00 0c 	add	r12,lr,r12
8000909a:	f0 1f 00 cb 	mcall	800093c4 <etTask+0x500>
8000909e:	2f 8d       	sub	sp,-32
800090a0:	c7 b8       	rjmp	80009196 <etTask+0x2d2>
		}
		
		else if (et_data.actual_page == 1)
800090a2:	ec 08 18 00 	cp.b	r8,r6
800090a6:	c7 81       	brne	80009196 <etTask+0x2d2>
		{
			et024006_PutPixmap(wearethechampions, 70, 0, 0, 30, 140, 70, 70);
800090a8:	34 63       	mov	r3,70
800090aa:	1a d3       	st.w	--sp,r3
800090ac:	1a d3       	st.w	--sp,r3
800090ae:	e0 68 00 8c 	mov	r8,140
800090b2:	1a d8       	st.w	--sp,r8
800090b4:	31 e8       	mov	r8,30
800090b6:	0e 99       	mov	r9,r7
800090b8:	0e 9a       	mov	r10,r7
800090ba:	06 9b       	mov	r11,r3
800090bc:	fe fc 03 0c 	ld.w	r12,pc[780]
800090c0:	f0 1f 00 bf 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page].duration, (const unsigned char *) &FONT8x8, 30, 220, WHITE, -1);
800090c4:	fe f0 02 fc 	ld.w	r0,pc[764]
800090c8:	e4 0e 10 64 	mul	lr,r2,100
800090cc:	50 3e       	stdsp	sp[0xc],lr
800090ce:	1c 9c       	mov	r12,lr
800090d0:	2b 0c       	sub	r12,-80
800090d2:	3f f1       	mov	r1,-1
800090d4:	1a d1       	st.w	--sp,r1
800090d6:	e0 68 ff ff 	mov	r8,65535
800090da:	e0 69 00 dc 	mov	r9,220
800090de:	31 ea       	mov	r10,30
800090e0:	00 9b       	mov	r11,r0
800090e2:	fe fe 02 a6 	ld.w	lr,pc[678]
800090e6:	fc 0c 00 0c 	add	r12,lr,r12
800090ea:	f0 1f 00 b7 	mcall	800093c4 <etTask+0x500>
			
			et024006_PutPixmap(letdown, 70, 0, 0, 30, 20, 70, 70);
800090ee:	1a d3       	st.w	--sp,r3
800090f0:	1a d3       	st.w	--sp,r3
800090f2:	31 48       	mov	r8,20
800090f4:	1a d8       	st.w	--sp,r8
800090f6:	31 e8       	mov	r8,30
800090f8:	0e 99       	mov	r9,r7
800090fa:	0e 9a       	mov	r10,r7
800090fc:	06 9b       	mov	r11,r3
800090fe:	fe fc 02 ba 	ld.w	r12,pc[698]
80009102:	f0 1f 00 af 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page + 1].duration, (const unsigned char*) &FONT8x8, 30, 100, WHITE, -1);
80009106:	e4 0c 10 64 	mul	r12,r2,100
8000910a:	f8 cc ff 4c 	sub	r12,r12,-180
8000910e:	1a d1       	st.w	--sp,r1
80009110:	e0 68 ff ff 	mov	r8,65535
80009114:	36 49       	mov	r9,100
80009116:	31 ea       	mov	r10,30
80009118:	00 9b       	mov	r11,r0
8000911a:	fe fe 02 6e 	ld.w	lr,pc[622]
8000911e:	fc 0c 00 0c 	add	r12,lr,r12
80009122:	f0 1f 00 a9 	mcall	800093c4 <etTask+0x500>
			
			et024006_PutPixmap(takeonme, 70, 0, 0, 190, 20, 70, 70);
80009126:	2f 8d       	sub	sp,-32
80009128:	1a d3       	st.w	--sp,r3
8000912a:	1a d3       	st.w	--sp,r3
8000912c:	31 48       	mov	r8,20
8000912e:	1a d8       	st.w	--sp,r8
80009130:	e0 68 00 be 	mov	r8,190
80009134:	0e 99       	mov	r9,r7
80009136:	0e 9a       	mov	r10,r7
80009138:	06 9b       	mov	r11,r3
8000913a:	fe fc 02 96 	ld.w	r12,pc[662]
8000913e:	f0 1f 00 a0 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[index_page + 2].duration, (const unsigned char*) &FONT8x8, 190, 100, WHITE, -1);
80009142:	40 3e       	lddsp	lr,sp[0xc]
80009144:	fc cc fe e8 	sub	r12,lr,-280
80009148:	1a d1       	st.w	--sp,r1
8000914a:	e0 68 ff ff 	mov	r8,65535
8000914e:	36 49       	mov	r9,100
80009150:	e0 6a 00 be 	mov	r10,190
80009154:	00 9b       	mov	r11,r0
80009156:	fe fe 02 32 	ld.w	lr,pc[562]
8000915a:	fc 0c 00 0c 	add	r12,lr,r12
8000915e:	f0 1f 00 9a 	mcall	800093c4 <etTask+0x500>
			
			et024006_PutPixmap(fercaspian, 70, 0, 0, 190, 140, 70, 70);
80009162:	1a d3       	st.w	--sp,r3
80009164:	1a d3       	st.w	--sp,r3
80009166:	e0 68 00 8c 	mov	r8,140
8000916a:	1a d8       	st.w	--sp,r8
8000916c:	e0 68 00 be 	mov	r8,190
80009170:	0e 99       	mov	r9,r7
80009172:	0e 9a       	mov	r10,r7
80009174:	06 9b       	mov	r11,r3
80009176:	fe fc 02 56 	ld.w	r12,pc[598]
8000917a:	f0 1f 00 91 	mcall	800093bc <etTask+0x4f8>
			et024006_PrintString(song_info[0].duration, (const unsigned char*) &FONT8x8, 190, 220, WHITE, -1);
8000917e:	1a d1       	st.w	--sp,r1
80009180:	e0 68 ff ff 	mov	r8,65535
80009184:	e0 69 00 dc 	mov	r9,220
80009188:	e0 6a 00 be 	mov	r10,190
8000918c:	00 9b       	mov	r11,r0
8000918e:	40 ac       	lddsp	r12,sp[0x28]
80009190:	f0 1f 00 8d 	mcall	800093c4 <etTask+0x500>
80009194:	2f 8d       	sub	sp,-32
			
		}
		
		
	}
	if (first_time || change_dected || init)
80009196:	fe f8 02 0e 	ld.w	r8,pc[526]
8000919a:	11 89       	ld.ub	r9,r8[0x0]
8000919c:	30 08       	mov	r8,0
8000919e:	f0 09 18 00 	cp.b	r9,r8
800091a2:	c0 81       	brne	800091b2 <etTask+0x2ee>
800091a4:	4f e8       	lddpc	r8,8000939c <etTask+0x4d8>
800091a6:	11 89       	ld.ub	r9,r8[0x0]
800091a8:	30 08       	mov	r8,0
800091aa:	f0 09 18 00 	cp.b	r9,r8
800091ae:	e0 80 00 e2 	breq	80009372 <etTask+0x4ae>
	{
		first_time = false;
800091b2:	30 09       	mov	r9,0
800091b4:	4f c8       	lddpc	r8,800093a4 <etTask+0x4e0>
800091b6:	b0 89       	st.b	r8[0x0],r9
		if (keys.ud == 0 && keys.lr == 0){
800091b8:	0b 98       	ld.ub	r8,r5[0x1]
800091ba:	58 08       	cp.w	r8,0
800091bc:	c3 61       	brne	80009228 <etTask+0x364>
800091be:	0b 89       	ld.ub	r9,r5[0x0]
800091c0:	f0 09 18 00 	cp.b	r9,r8
800091c4:	c6 b1       	brne	8000929a <etTask+0x3d6>
			et024006_DrawVertLine(160,0,120,WHITE);
800091c6:	e0 69 ff ff 	mov	r9,65535
800091ca:	37 8a       	mov	r10,120
800091cc:	0e 9b       	mov	r11,r7
800091ce:	e0 6c 00 a0 	mov	r12,160
800091d2:	f0 1f 00 77 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawVertLine(160,120,120,WHITE);
800091d6:	e0 69 ff ff 	mov	r9,65535
800091da:	37 8a       	mov	r10,120
800091dc:	14 9b       	mov	r11,r10
800091de:	e0 6c 00 a0 	mov	r12,160
800091e2:	f0 1f 00 73 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(0,120,160,WHITE);
800091e6:	e0 69 ff ff 	mov	r9,65535
800091ea:	e0 6a 00 a0 	mov	r10,160
800091ee:	37 8b       	mov	r11,120
800091f0:	0e 9c       	mov	r12,r7
800091f2:	f0 1f 00 70 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawHorizLine(160,120,160,WHITE);
800091f6:	e0 69 ff ff 	mov	r9,65535
800091fa:	e0 6a 00 a0 	mov	r10,160
800091fe:	37 8b       	mov	r11,120
80009200:	14 9c       	mov	r12,r10
80009202:	f0 1f 00 6c 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawVertLine(160,0,120,GREEN);
80009206:	e0 69 07 e0 	mov	r9,2016
8000920a:	37 8a       	mov	r10,120
8000920c:	0e 9b       	mov	r11,r7
8000920e:	e0 6c 00 a0 	mov	r12,160
80009212:	f0 1f 00 67 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(0,120,160,GREEN);
80009216:	e0 69 07 e0 	mov	r9,2016
8000921a:	e0 6a 00 a0 	mov	r10,160
8000921e:	37 8b       	mov	r11,120
80009220:	0e 9c       	mov	r12,r7
80009222:	f0 1f 00 64 	mcall	800093b0 <etTask+0x4ec>
80009226:	ca 68       	rjmp	80009372 <etTask+0x4ae>
			//et024006_PrintString("News of the World", (const unsigned char*) &FONT8x8, 30, 60, WHITE, -1);
			//et024006_PrintString("1977", (const unsigned char*) &FONT8x8, 30, 80, WHITE, -1);
			//et024006_PrintString("dur: 3:04", (const unsigned char*) &FONT8x8, 30, 100, BLACK, -1);
			//}
		}
		else if (keys.ud == 1 && keys.lr == 0){
80009228:	ec 08 18 00 	cp.b	r8,r6
8000922c:	c6 c1       	brne	80009304 <etTask+0x440>
8000922e:	0b 89       	ld.ub	r9,r5[0x0]
80009230:	30 08       	mov	r8,0
80009232:	f0 09 18 00 	cp.b	r9,r8
80009236:	c6 a1       	brne	8000930a <etTask+0x446>
			et024006_DrawVertLine(160,0,120,WHITE);
80009238:	e0 69 ff ff 	mov	r9,65535
8000923c:	37 8a       	mov	r10,120
8000923e:	0e 9b       	mov	r11,r7
80009240:	e0 6c 00 a0 	mov	r12,160
80009244:	f0 1f 00 5a 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawVertLine(160,120,120,WHITE);
80009248:	e0 69 ff ff 	mov	r9,65535
8000924c:	37 8a       	mov	r10,120
8000924e:	14 9b       	mov	r11,r10
80009250:	e0 6c 00 a0 	mov	r12,160
80009254:	f0 1f 00 56 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(0,120,160,WHITE);
80009258:	e0 69 ff ff 	mov	r9,65535
8000925c:	e0 6a 00 a0 	mov	r10,160
80009260:	37 8b       	mov	r11,120
80009262:	0e 9c       	mov	r12,r7
80009264:	f0 1f 00 53 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawHorizLine(160,120,160,WHITE);
80009268:	e0 69 ff ff 	mov	r9,65535
8000926c:	e0 6a 00 a0 	mov	r10,160
80009270:	37 8b       	mov	r11,120
80009272:	14 9c       	mov	r12,r10
80009274:	f0 1f 00 4f 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawVertLine(160,120,120,GREEN);
80009278:	e0 69 07 e0 	mov	r9,2016
8000927c:	37 8a       	mov	r10,120
8000927e:	14 9b       	mov	r11,r10
80009280:	e0 6c 00 a0 	mov	r12,160
80009284:	f0 1f 00 4a 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(0,120,160,GREEN);
80009288:	e0 69 07 e0 	mov	r9,2016
8000928c:	e0 6a 00 a0 	mov	r10,160
80009290:	37 8b       	mov	r11,120
80009292:	0e 9c       	mov	r12,r7
80009294:	f0 1f 00 47 	mcall	800093b0 <etTask+0x4ec>
80009298:	c6 d8       	rjmp	80009372 <etTask+0x4ae>
			//et024006_PrintString("Ok Computer", (const unsigned char*) &FONT8x8, 30, 180, WHITE, -1);
			//et024006_PrintString("1997", (const unsigned char*) &FONT8x8, 30, 200, WHITE, -1);
			//et024006_PrintString("dur: 4:59", (const unsigned char*) &FONT8x8, 30, 220, BLACK, -1);
			//}
		}
		else if (keys.ud == 0 && keys.lr == 1){
8000929a:	0b 88       	ld.ub	r8,r5[0x0]
8000929c:	ec 08 18 00 	cp.b	r8,r6
800092a0:	c6 91       	brne	80009372 <etTask+0x4ae>
			et024006_DrawVertLine(160,0,120,WHITE);
800092a2:	e0 69 ff ff 	mov	r9,65535
800092a6:	37 8a       	mov	r10,120
800092a8:	0e 9b       	mov	r11,r7
800092aa:	e0 6c 00 a0 	mov	r12,160
800092ae:	f0 1f 00 40 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawVertLine(160,120,120,WHITE);
800092b2:	e0 69 ff ff 	mov	r9,65535
800092b6:	37 8a       	mov	r10,120
800092b8:	14 9b       	mov	r11,r10
800092ba:	e0 6c 00 a0 	mov	r12,160
800092be:	f0 1f 00 3c 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(0,120,160,WHITE);
800092c2:	e0 69 ff ff 	mov	r9,65535
800092c6:	e0 6a 00 a0 	mov	r10,160
800092ca:	37 8b       	mov	r11,120
800092cc:	0e 9c       	mov	r12,r7
800092ce:	f0 1f 00 39 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawHorizLine(160,120,160,WHITE);
800092d2:	e0 69 ff ff 	mov	r9,65535
800092d6:	e0 6a 00 a0 	mov	r10,160
800092da:	37 8b       	mov	r11,120
800092dc:	14 9c       	mov	r12,r10
800092de:	f0 1f 00 35 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawVertLine(160,0,120,GREEN);
800092e2:	e0 69 07 e0 	mov	r9,2016
800092e6:	37 8a       	mov	r10,120
800092e8:	0e 9b       	mov	r11,r7
800092ea:	e0 6c 00 a0 	mov	r12,160
800092ee:	f0 1f 00 30 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(160,120,160,GREEN);
800092f2:	e0 69 07 e0 	mov	r9,2016
800092f6:	e0 6a 00 a0 	mov	r10,160
800092fa:	37 8b       	mov	r11,120
800092fc:	14 9c       	mov	r12,r10
800092fe:	f0 1f 00 2d 	mcall	800093b0 <etTask+0x4ec>
80009302:	c3 88       	rjmp	80009372 <etTask+0x4ae>
			//et024006_PrintString("between days", (const unsigned char*) &FONT8x8, 190, 60, WHITE, -1);
			//et024006_PrintString("2018", (const unsigned char*) &FONT8x8, 190, 80, WHITE, -1);
			//et024006_PrintString("dur: 4:36", (const unsigned char*) &FONT8x8, 190, 100, BLACK, -1);
			//}
		}
		else if (keys.ud == 1 && keys.lr == 1){
80009304:	ec 08 18 00 	cp.b	r8,r6
80009308:	c3 51       	brne	80009372 <etTask+0x4ae>
8000930a:	0b 88       	ld.ub	r8,r5[0x0]
8000930c:	ec 08 18 00 	cp.b	r8,r6
80009310:	c3 11       	brne	80009372 <etTask+0x4ae>
			et024006_DrawVertLine(160,0,120,WHITE);
80009312:	e0 69 ff ff 	mov	r9,65535
80009316:	37 8a       	mov	r10,120
80009318:	0e 9b       	mov	r11,r7
8000931a:	e0 6c 00 a0 	mov	r12,160
8000931e:	f0 1f 00 24 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawVertLine(160,120,120,WHITE);
80009322:	e0 69 ff ff 	mov	r9,65535
80009326:	37 8a       	mov	r10,120
80009328:	14 9b       	mov	r11,r10
8000932a:	e0 6c 00 a0 	mov	r12,160
8000932e:	f0 1f 00 20 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(0,120,160,WHITE);
80009332:	e0 69 ff ff 	mov	r9,65535
80009336:	e0 6a 00 a0 	mov	r10,160
8000933a:	37 8b       	mov	r11,120
8000933c:	0e 9c       	mov	r12,r7
8000933e:	f0 1f 00 1d 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawHorizLine(160,120,160,WHITE);
80009342:	e0 69 ff ff 	mov	r9,65535
80009346:	e0 6a 00 a0 	mov	r10,160
8000934a:	37 8b       	mov	r11,120
8000934c:	14 9c       	mov	r12,r10
8000934e:	f0 1f 00 19 	mcall	800093b0 <etTask+0x4ec>
			et024006_DrawVertLine(160,120,120,GREEN);
80009352:	e0 69 07 e0 	mov	r9,2016
80009356:	37 8a       	mov	r10,120
80009358:	14 9b       	mov	r11,r10
8000935a:	e0 6c 00 a0 	mov	r12,160
8000935e:	f0 1f 00 14 	mcall	800093ac <etTask+0x4e8>
			et024006_DrawHorizLine(160,120,160,GREEN);
80009362:	e0 69 07 e0 	mov	r9,2016
80009366:	e0 6a 00 a0 	mov	r10,160
8000936a:	37 8b       	mov	r11,120
8000936c:	14 9c       	mov	r12,r10
8000936e:	f0 1f 00 11 	mcall	800093b0 <etTask+0x4ec>
				if (notif_chaneg_page > 0)
				{
					change_page = true;
				}
				menu_gui(false, change_page);
				change_page = false;
80009372:	30 08       	mov	r8,0
80009374:	a8 88       	st.b	r4[0x0],r8
			case LYRICS:
				break;
			case EQ:
				break;
		}
		vTaskSuspend(NULL);
80009376:	0e 9c       	mov	r12,r7
80009378:	f0 1f 00 17 	mcall	800093d4 <etTask+0x510>
	}
8000937c:	fe 9f fd b3 	bral	80008ee2 <etTask+0x1e>
80009380:	00 00       	add	r0,r0
80009382:	06 dc       	st.w	--r3,r12
80009384:	00 00       	add	r0,r0
80009386:	06 f0       	st.b	--r3,r0
80009388:	00 00       	add	r0,r0
8000938a:	06 fc       	st.b	--r3,r12
8000938c:	80 00       	ld.sh	r0,r0[0x0]
8000938e:	83 c0       	st.w	r1[0x30],r0
80009390:	00 00       	add	r0,r0
80009392:	0b 1c       	ld.sh	r12,r5++
80009394:	00 00       	add	r0,r0
80009396:	16 b4       	st.h	r11++,r4
80009398:	80 00       	ld.sh	r0,r0[0x0]
8000939a:	76 34       	ld.w	r4,r11[0xc]
8000939c:	00 00       	add	r0,r0
8000939e:	06 f4       	st.b	--r3,r4
800093a0:	00 00       	add	r0,r0
800093a2:	16 a8       	st.w	r11++,r8
800093a4:	00 00       	add	r0,r0
800093a6:	00 2c       	rsub	r12,r0
800093a8:	80 00       	ld.sh	r0,r0[0x0]
800093aa:	27 68       	sub	r8,118
800093ac:	80 00       	ld.sh	r0,r0[0x0]
800093ae:	27 a8       	sub	r8,122
800093b0:	80 00       	ld.sh	r0,r0[0x0]
800093b2:	27 c4       	sub	r4,124
800093b4:	00 00       	add	r0,r0
800093b6:	0a e4       	st.h	--r5,r4
800093b8:	80 00       	ld.sh	r0,r0[0x0]
800093ba:	dd ea       	popm	r4-r11,pc,r12=-1
800093bc:	80 00       	ld.sh	r0,r0[0x0]
800093be:	28 44       	sub	r4,-124
800093c0:	80 00       	ld.sh	r0,r0[0x0]
800093c2:	b2 50       	st.h	r9[0xa],r0
800093c4:	80 00       	ld.sh	r0,r0[0x0]
800093c6:	24 ec       	sub	r12,78
800093c8:	80 01       	ld.sh	r1,r0[0x0]
800093ca:	2a 7a       	sub	r10,-89
800093cc:	80 00       	ld.sh	r0,r0[0x0]
800093ce:	b7 a2       	sbr	r2,0x16
800093d0:	80 01       	ld.sh	r1,r0[0x0]
800093d2:	04 32       	cp.w	r2,r2
800093d4:	80 00       	ld.sh	r0,r0[0x0]
800093d6:	82 70       	ld.sh	r0,r1[0xe]

800093d8 <playAudioTask>:
	}
}

// audioHandle
portTASK_FUNCTION( playAudioTask, p )
{
800093d8:	d4 31       	pushm	r0-r7,lr
	volatile unsigned long *sdram = SDRAM;
	print_dbg("Running audio...\r\n");
800093da:	4d 0c       	lddpc	r12,80009518 <playAudioTask+0x140>
800093dc:	f0 1f 00 50 	mcall	8000951c <playAudioTask+0x144>
	static uint32_t count = 0;
	uint32_t i = sd.audio_data[selected_song].init_ptr;
800093e0:	4d 08       	lddpc	r8,80009520 <playAudioTask+0x148>
800093e2:	11 88       	ld.ub	r8,r8[0x0]
800093e4:	f0 08 00 18 	add	r8,r8,r8<<0x1
800093e8:	4c f9       	lddpc	r9,80009524 <playAudioTask+0x14c>
800093ea:	f2 08 00 28 	add	r8,r9,r8<<0x2
800093ee:	f0 f7 00 98 	ld.w	r7,r8[152]
	static bool playAudio = false;
	static bool notify	  = false;
	static uint16_t samplesRx;
	static sdram_udata_t data;
	
	tpa6130_set_volume(0x45); // 2F
800093f2:	34 5c       	mov	r12,69
800093f4:	f0 1f 00 4d 	mcall	80009528 <playAudioTask+0x150>

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
800093f8:	30 05       	mov	r5,0
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				memset(&data, 0, sizeof(data));
800093fa:	4c d4       	lddpc	r4,8000952c <playAudioTask+0x154>
				data.word = sdram[i];
800093fc:	fc 12 d0 00 	movh	r2,0xd000
80009400:	08 93       	mov	r3,r4

	}
}

// audioHandle
portTASK_FUNCTION( playAudioTask, p )
80009402:	e8 c6 ff fc 	sub	r6,r4,-4
	
	tpa6130_set_volume(0x45); // 2F

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
80009406:	30 1a       	mov	r10,1
80009408:	14 9b       	mov	r11,r10
8000940a:	0a 9c       	mov	r12,r5
8000940c:	f0 1f 00 49 	mcall	80009530 <playAudioTask+0x158>
80009410:	4c 98       	lddpc	r8,80009534 <playAudioTask+0x15c>
80009412:	91 0c       	st.w	r8[0x0],r12

		if (notificationValue > 0)
80009414:	58 0c       	cp.w	r12,0
80009416:	e0 8a 00 07 	brle	80009424 <playAudioTask+0x4c>
		{
			//playAudio = !playAudio;
			notify = !notify;
8000941a:	4c 88       	lddpc	r8,80009538 <playAudioTask+0x160>
8000941c:	11 89       	ld.ub	r9,r8[0x0]
8000941e:	ec 19 00 01 	eorl	r9,0x1
80009422:	b0 89       	st.b	r8[0x0],r9
			//print_dbg("Notification received.");

		}

		if ((pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE) && (notify == true))
80009424:	0a 9c       	mov	r12,r5
80009426:	f0 1f 00 46 	mcall	8000953c <playAudioTask+0x164>
8000942a:	e2 1c 00 02 	andl	r12,0x2,COH
8000942e:	c1 b0       	breq	80009464 <playAudioTask+0x8c>
80009430:	4c 28       	lddpc	r8,80009538 <playAudioTask+0x160>
80009432:	11 89       	ld.ub	r9,r8[0x0]
80009434:	30 08       	mov	r8,0
80009436:	f0 09 18 00 	cp.b	r9,r8
8000943a:	c1 50       	breq	80009464 <playAudioTask+0x8c>
		{
			playAudio = true;
8000943c:	30 19       	mov	r9,1
8000943e:	4c 18       	lddpc	r8,80009540 <playAudioTask+0x168>
80009440:	b0 89       	st.b	r8[0x0],r9
			//print_dbg("Running audio...\r\n");

			if (forwardQueue != 0)
80009442:	4c 18       	lddpc	r8,80009544 <playAudioTask+0x16c>
80009444:	70 0c       	ld.w	r12,r8[0x0]
80009446:	58 0c       	cp.w	r12,0
80009448:	c1 70       	breq	80009476 <playAudioTask+0x9e>
			{
				if (xQueueReceive( forwardQueue, &samplesRx, (TickType_t) 2 ))
8000944a:	30 2a       	mov	r10,2
8000944c:	4b fb       	lddpc	r11,80009548 <playAudioTask+0x170>
8000944e:	f0 1f 00 40 	mcall	8000954c <playAudioTask+0x174>
80009452:	c0 90       	breq	80009464 <playAudioTask+0x8c>
				{
					i = ( (i + samplesRx) <= sizeof(letdownsong) ) ? (i + samplesRx) : i;
80009454:	4b d8       	lddpc	r8,80009548 <playAudioTask+0x170>
80009456:	90 8b       	ld.uh	r11,r8[0x0]
80009458:	ee 0b 00 0b 	add	r11,r7,r11
8000945c:	e0 4b 6f 78 	cp.w	r11,28536
80009460:	e0 88 00 03 	brls	80009466 <playAudioTask+0x8e>
80009464:	0e 9b       	mov	r11,r7
					//i = (i > samplesRx) ? (i - samplesRx) : i;
				//}
			//}
		}

		if (playAudio)
80009466:	4b 78       	lddpc	r8,80009540 <playAudioTask+0x168>
80009468:	11 89       	ld.ub	r9,r8[0x0]
8000946a:	30 08       	mov	r8,0
8000946c:	f0 09 18 00 	cp.b	r9,r8
80009470:	c0 41       	brne	80009478 <playAudioTask+0xa0>
80009472:	16 97       	mov	r7,r11
80009474:	cc 9b       	rjmp	80009406 <playAudioTask+0x2e>
80009476:	0e 9b       	mov	r11,r7
		{
			playAudio = false;
80009478:	30 09       	mov	r9,0
8000947a:	4b 28       	lddpc	r8,80009540 <playAudioTask+0x168>
8000947c:	b0 89       	st.b	r8[0x0],r9
			count = 0;
8000947e:	4b 58       	lddpc	r8,80009550 <playAudioTask+0x178>
80009480:	91 05       	st.w	r8[0x0],r5
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				memset(&data, 0, sizeof(data));
				data.word = sdram[i];
80009482:	10 9c       	mov	r12,r8
80009484:	4b 40       	lddpc	r0,80009554 <playAudioTask+0x17c>
					samples[count++] = ((uint8_t)data.byte[j]+0x80) << 8;
					samples[count++] = ((uint8_t)data.byte[j]+0x80) << 8;
				}
				i++;
				//if (i >= sizeof(letdownsong)) i = 0;
				if (i >= (sd.audio_data[selected_song].end_ptr))
80009486:	4a 71       	lddpc	r1,80009520 <playAudioTask+0x148>
80009488:	4a 7e       	lddpc	lr,80009524 <playAudioTask+0x14c>
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				memset(&data, 0, sizeof(data));
8000948a:	89 05       	st.w	r4[0x0],r5
				data.word = sdram[i];
8000948c:	e4 0b 03 28 	ld.w	r8,r2[r11<<0x2]
80009490:	89 08       	st.w	r4[0x0],r8
80009492:	78 07       	ld.w	r7,r12[0x0]
80009494:	06 99       	mov	r9,r3
80009496:	e0 07 00 18 	add	r8,r0,r7<<0x1
				for (uint8_t j = 0; j < 4; j++)
				{	
					samples[count++] = ((uint8_t)data.byte[j]+0x80) << 8;
8000949a:	13 3a       	ld.ub	r10,r9++
8000949c:	28 0a       	sub	r10,-128
8000949e:	a9 6a       	lsl	r10,0x8
800094a0:	b0 0a       	st.h	r8[0x0],r10
					samples[count++] = ((uint8_t)data.byte[j]+0x80) << 8;
800094a2:	b0 1a       	st.h	r8[0x2],r10
800094a4:	2f c8       	sub	r8,-4
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				memset(&data, 0, sizeof(data));
				data.word = sdram[i];
				for (uint8_t j = 0; j < 4; j++)
800094a6:	0c 39       	cp.w	r9,r6
800094a8:	cf 91       	brne	8000949a <playAudioTask+0xc2>
800094aa:	2f 87       	sub	r7,-8
800094ac:	99 07       	st.w	r12[0x0],r7
				{	
					samples[count++] = ((uint8_t)data.byte[j]+0x80) << 8;
					samples[count++] = ((uint8_t)data.byte[j]+0x80) << 8;
				}
				i++;
800094ae:	2f fb       	sub	r11,-1
				//if (i >= sizeof(letdownsong)) i = 0;
				if (i >= (sd.audio_data[selected_song].end_ptr))
800094b0:	03 88       	ld.ub	r8,r1[0x0]
800094b2:	10 9a       	mov	r10,r8
800094b4:	f0 08 00 19 	add	r9,r8,r8<<0x1
800094b8:	fc 09 00 29 	add	r9,lr,r9<<0x2
800094bc:	f2 f9 00 9c 	ld.w	r9,r9[156]
800094c0:	12 3b       	cp.w	r11,r9
800094c2:	c1 43       	brcs	800094ea <playAudioTask+0x112>
				{
					if (selected_song + 1 < sd.number_of_audio_files)
800094c4:	2f fa       	sub	r10,-1
800094c6:	1d d9       	ld.ub	r9,lr[0x5]
800094c8:	12 3a       	cp.w	r10,r9
800094ca:	c0 b4       	brge	800094e0 <playAudioTask+0x108>
					{
						selected_song++;
800094cc:	2f f8       	sub	r8,-1
800094ce:	5c 58       	castu.b	r8
800094d0:	a2 88       	st.b	r1[0x0],r8
						i = sd.audio_data[selected_song].init_ptr;
800094d2:	f0 08 00 18 	add	r8,r8,r8<<0x1
800094d6:	fc 08 00 28 	add	r8,lr,r8<<0x2
800094da:	f0 fb 00 98 	ld.w	r11,r8[152]
800094de:	c0 68       	rjmp	800094ea <playAudioTask+0x112>
					}
					else
					{
						notify = !notify;
800094e0:	49 69       	lddpc	r9,80009538 <playAudioTask+0x160>
800094e2:	13 88       	ld.ub	r8,r9[0x0]
800094e4:	ec 18 00 01 	eorl	r8,0x1
800094e8:	b2 88       	st.b	r9[0x0],r8
		if (playAudio)
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
800094ea:	e0 47 01 ff 	cp.w	r7,511
800094ee:	fe 98 ff ce 	brls	8000948a <playAudioTask+0xb2>
800094f2:	16 97       	mov	r7,r11
					}
					
				}
			}

			gpio_set_gpio_pin(LED0_GPIO);
800094f4:	33 bc       	mov	r12,59
800094f6:	f0 1f 00 19 	mcall	80009558 <playAudioTask+0x180>
			gpio_clr_gpio_pin(LED1_GPIO);
800094fa:	33 cc       	mov	r12,60
800094fc:	f0 1f 00 18 	mcall	8000955c <playAudioTask+0x184>

			// Play buffer
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
80009500:	e0 6b 01 00 	mov	r11,256
80009504:	49 4c       	lddpc	r12,80009554 <playAudioTask+0x17c>
80009506:	f0 1f 00 17 	mcall	80009560 <playAudioTask+0x188>

			gpio_clr_gpio_pin(LED0_GPIO);
8000950a:	33 bc       	mov	r12,59
8000950c:	f0 1f 00 14 	mcall	8000955c <playAudioTask+0x184>
			gpio_set_gpio_pin(LED1_GPIO);
80009510:	33 cc       	mov	r12,60
80009512:	f0 1f 00 12 	mcall	80009558 <playAudioTask+0x180>
80009516:	c7 8b       	rjmp	80009406 <playAudioTask+0x2e>
80009518:	80 01       	ld.sh	r1,r0[0x0]
8000951a:	51 e0       	stdsp	sp[0x78],r0
8000951c:	80 00       	ld.sh	r0,r0[0x0]
8000951e:	6f 6c       	ld.w	r12,r7[0x58]
80009520:	00 00       	add	r0,r0
80009522:	10 2c       	rsub	r12,r8
80009524:	00 00       	add	r0,r0
80009526:	0f 20       	ld.uh	r0,r7++
80009528:	80 00       	ld.sh	r0,r0[0x0]
8000952a:	21 8c       	sub	r12,24
8000952c:	00 00       	add	r0,r0
8000952e:	10 30       	cp.w	r0,r8
80009530:	80 00       	ld.sh	r0,r0[0x0]
80009532:	83 c0       	st.w	r1[0x30],r0
80009534:	00 00       	add	r0,r0
80009536:	0a e8       	st.h	--r5,r8
80009538:	00 00       	add	r0,r0
8000953a:	06 f5       	st.b	--r3,r5
8000953c:	80 00       	ld.sh	r0,r0[0x0]
8000953e:	40 d4       	lddsp	r4,sp[0x34]
80009540:	00 00       	add	r0,r0
80009542:	06 f3       	st.b	--r3,r3
80009544:	00 00       	add	r0,r0
80009546:	16 b8       	st.h	r11++,r8
80009548:	00 00       	add	r0,r0
8000954a:	06 de       	st.w	--r3,lr
8000954c:	80 00       	ld.sh	r0,r0[0x0]
8000954e:	76 34       	ld.w	r4,r11[0xc]
80009550:	00 00       	add	r0,r0
80009552:	06 e0       	st.h	--r3,r0
80009554:	00 00       	add	r0,r0
80009556:	0b 20       	ld.uh	r0,r5++
80009558:	80 00       	ld.sh	r0,r0[0x0]
8000955a:	9d f8       	st.w	lr[0x3c],r8
8000955c:	80 00       	ld.sh	r0,r0[0x0]
8000955e:	9e 14       	ld.sh	r4,pc[0x2]
80009560:	80 00       	ld.sh	r0,r0[0x0]
80009562:	21 bc       	sub	r12,27

80009564 <qtButtonTask>:
	
}

// qtHandle
portTASK_FUNCTION( qtButtonTask, p )
{
80009564:	d4 31       	pushm	r0-r7,lr
	gpio_set_gpio_pin(LED0_GPIO);
80009566:	33 bc       	mov	r12,59
80009568:	f0 1f 00 b2 	mcall	80009830 <qtButtonTask+0x2cc>
	gpio_set_gpio_pin(LED1_GPIO);
8000956c:	33 cc       	mov	r12,60
8000956e:	f0 1f 00 b1 	mcall	80009830 <qtButtonTask+0x2cc>
	gpio_set_gpio_pin(LED2_GPIO);
80009572:	30 5c       	mov	r12,5
80009574:	f0 1f 00 af 	mcall	80009830 <qtButtonTask+0x2cc>
	gpio_set_gpio_pin(LED3_GPIO);
80009578:	30 6c       	mov	r12,6
8000957a:	f0 1f 00 ae 	mcall	80009830 <qtButtonTask+0x2cc>

	static uint16_t samplesToMove;
	static uint8_t lrValue = 0;
	static uint8_t udValue = 0;
	forwardQueue = xQueueCreate( 1 , sizeof(uint16_t));
8000957e:	30 0a       	mov	r10,0
80009580:	30 2b       	mov	r11,2
80009582:	30 1c       	mov	r12,1
80009584:	f0 1f 00 ac 	mcall	80009834 <qtButtonTask+0x2d0>
80009588:	fe f8 02 b0 	ld.w	r8,pc[688]
8000958c:	91 0c       	st.w	r8[0x0],r12
	reverseQueue = xQueueCreate( 1 , sizeof(uint16_t));
8000958e:	30 0a       	mov	r10,0
80009590:	30 2b       	mov	r11,2
80009592:	30 1c       	mov	r12,1
80009594:	f0 1f 00 a8 	mcall	80009834 <qtButtonTask+0x2d0>
80009598:	fe f8 02 a4 	ld.w	r8,pc[676]
8000959c:	91 0c       	st.w	r8[0x0],r12
	repUdQueue = xQueueCreate( 1 , sizeof(uint8_t));
8000959e:	30 0a       	mov	r10,0
800095a0:	30 1b       	mov	r11,1
800095a2:	16 9c       	mov	r12,r11
800095a4:	f0 1f 00 a4 	mcall	80009834 <qtButtonTask+0x2d0>
800095a8:	fe f8 02 98 	ld.w	r8,pc[664]
800095ac:	91 0c       	st.w	r8[0x0],r12
	repLrQueue = xQueueCreate( 1 , sizeof(uint8_t));
800095ae:	30 0a       	mov	r10,0
800095b0:	30 1b       	mov	r11,1
800095b2:	16 9c       	mov	r12,r11
800095b4:	f0 1f 00 a0 	mcall	80009834 <qtButtonTask+0x2d0>
800095b8:	fe f8 02 8c 	ld.w	r8,pc[652]
800095bc:	91 0c       	st.w	r8[0x0],r12
	mainUdQueue = xQueueCreate( 1 , sizeof(uint8_t));
800095be:	30 0a       	mov	r10,0
800095c0:	30 1b       	mov	r11,1
800095c2:	16 9c       	mov	r12,r11
800095c4:	f0 1f 00 9c 	mcall	80009834 <qtButtonTask+0x2d0>
800095c8:	fe f8 02 80 	ld.w	r8,pc[640]
800095cc:	91 0c       	st.w	r8[0x0],r12
	mainLrQueue = xQueueCreate( 1 , sizeof(uint8_t));
800095ce:	30 0a       	mov	r10,0
800095d0:	30 1b       	mov	r11,1
800095d2:	16 9c       	mov	r12,r11
800095d4:	f0 1f 00 98 	mcall	80009834 <qtButtonTask+0x2d0>
800095d8:	fe f8 02 74 	ld.w	r8,pc[628]
800095dc:	91 0c       	st.w	r8[0x0],r12

	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
800095de:	30 05       	mov	r5,0
		
		switch(state)
		{
			default:
			case MAIN:
				if (INTC_QT_FLAG._left) {
800095e0:	fe f7 02 70 	ld.w	r7,pc[624]
800095e4:	30 06       	mov	r6,0
					INTC_QT_FLAG._left = false;
					lrValue = (lrValue > 0) ? lrValue - 1 : lrValue;
800095e6:	fe f4 02 6e 	ld.w	r4,pc[622]
					xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
800095ea:	10 92       	mov	r2,r8
					vTaskResume(etHandle);
800095ec:	fe f3 02 6c 	ld.w	r3,pc[620]
					xQueueSend( mainUdQueue, &udValue, (TickType_t) 0);
					vTaskResume(etHandle);
				}
				else if (INTC_QT_FLAG._enter) {
					INTC_QT_FLAG._enter = false;
					xTaskNotifyGive(audioHandle);
800095f0:	30 20       	mov	r0,2
					vTaskResume(etHandle);
				}
				else if (INTC_QT_FLAG._down) {
					INTC_QT_FLAG._down = false;
					//udValue = (udValue + 1 <= 2) ? udValue + 1 : udValue;
					if (udValue == 1)
800095f2:	fe f1 02 6a 	ld.w	r1,pc[618]
	mainUdQueue = xQueueCreate( 1 , sizeof(uint8_t));
	mainLrQueue = xQueueCreate( 1 , sizeof(uint8_t));

	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
800095f6:	0a 9c       	mov	r12,r5
800095f8:	f0 1f 00 9a 	mcall	80009860 <qtButtonTask+0x2fc>
		
		switch(state)
		{
			default:
			case MAIN:
				if (INTC_QT_FLAG._left) {
800095fc:	0f 88       	ld.ub	r8,r7[0x0]
800095fe:	10 99       	mov	r9,r8
80009600:	e2 19 00 40 	andl	r9,0x40,COH
80009604:	ec 09 18 00 	cp.b	r9,r6
80009608:	c1 40       	breq	80009630 <qtButtonTask+0xcc>
					INTC_QT_FLAG._left = false;
8000960a:	0f 88       	ld.ub	r8,r7[0x0]
8000960c:	f1 d5 d0 c1 	bfins	r8,r5,0x6,0x1
80009610:	ae 88       	st.b	r7[0x0],r8
					lrValue = (lrValue > 0) ? lrValue - 1 : lrValue;
80009612:	09 88       	ld.ub	r8,r4[0x0]
80009614:	58 08       	cp.w	r8,0
80009616:	c0 20       	breq	8000961a <qtButtonTask+0xb6>
80009618:	20 18       	sub	r8,1
8000961a:	a8 88       	st.b	r4[0x0],r8
					xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
8000961c:	0a 99       	mov	r9,r5
8000961e:	0a 9a       	mov	r10,r5
80009620:	08 9b       	mov	r11,r4
80009622:	64 0c       	ld.w	r12,r2[0x0]
80009624:	f0 1f 00 90 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
80009628:	66 0c       	ld.w	r12,r3[0x0]
8000962a:	f0 1f 00 90 	mcall	80009868 <qtButtonTask+0x304>
8000962e:	c8 88       	rjmp	8000973e <qtButtonTask+0x1da>
				}
				else if (INTC_QT_FLAG._right) {
80009630:	10 99       	mov	r9,r8
80009632:	e2 19 00 20 	andl	r9,0x20,COH
80009636:	ec 09 18 00 	cp.b	r9,r6
8000963a:	c1 70       	breq	80009668 <qtButtonTask+0x104>
					INTC_QT_FLAG._right = false;
8000963c:	0f 88       	ld.ub	r8,r7[0x0]
8000963e:	f1 d5 d0 a1 	bfins	r8,r5,0x5,0x1
80009642:	ae 88       	st.b	r7[0x0],r8
					lrValue = (lrValue + 1 < 2) ? lrValue + 1 : lrValue;
80009644:	09 88       	ld.ub	r8,r4[0x0]
80009646:	f0 c9 ff ff 	sub	r9,r8,-1
8000964a:	58 19       	cp.w	r9,1
8000964c:	e0 89 00 03 	brgt	80009652 <qtButtonTask+0xee>
80009650:	2f f8       	sub	r8,-1
80009652:	a8 88       	st.b	r4[0x0],r8
					xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
80009654:	0a 99       	mov	r9,r5
80009656:	0a 9a       	mov	r10,r5
80009658:	08 9b       	mov	r11,r4
8000965a:	64 0c       	ld.w	r12,r2[0x0]
8000965c:	f0 1f 00 82 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
80009660:	66 0c       	ld.w	r12,r3[0x0]
80009662:	f0 1f 00 82 	mcall	80009868 <qtButtonTask+0x304>
80009666:	c6 c8       	rjmp	8000973e <qtButtonTask+0x1da>
				}
				else if (INTC_QT_FLAG._up) {
80009668:	10 99       	mov	r9,r8
8000966a:	e2 19 00 10 	andl	r9,0x10,COH
8000966e:	ec 09 18 00 	cp.b	r9,r6
80009672:	c2 60       	breq	800096be <qtButtonTask+0x15a>
					INTC_QT_FLAG._up = false;
80009674:	0f 88       	ld.ub	r8,r7[0x0]
80009676:	f1 d5 d0 81 	bfins	r8,r5,0x4,0x1
8000967a:	ae 88       	st.b	r7[0x0],r8
					//udValue = (udValue > 0) ? udValue - 1 : udValue;
					if (udValue == 0)
8000967c:	03 88       	ld.ub	r8,r1[0x0]
8000967e:	58 08       	cp.w	r8,0
80009680:	c1 21       	brne	800096a4 <qtButtonTask+0x140>
					{
						if (et_data.actual_page > 0)
80009682:	4f b8       	lddpc	r8,8000986c <qtButtonTask+0x308>
80009684:	11 98       	ld.ub	r8,r8[0x1]
80009686:	58 08       	cp.w	r8,0
80009688:	c1 00       	breq	800096a8 <qtButtonTask+0x144>
						{
							et_data.actual_page--;
8000968a:	20 18       	sub	r8,1
8000968c:	4f 89       	lddpc	r9,8000986c <qtButtonTask+0x308>
8000968e:	b2 98       	st.b	r9[0x1],r8
							xTaskNotifyGive( etHandle );
80009690:	0a 98       	mov	r8,r5
80009692:	00 99       	mov	r9,r0
80009694:	0a 9a       	mov	r10,r5
80009696:	0a 9b       	mov	r11,r5
80009698:	66 0c       	ld.w	r12,r3[0x0]
8000969a:	f0 1f 00 76 	mcall	80009870 <qtButtonTask+0x30c>
							udValue = 1;
8000969e:	30 18       	mov	r8,1
800096a0:	a2 88       	st.b	r1[0x0],r8
800096a2:	c0 38       	rjmp	800096a8 <qtButtonTask+0x144>
						}
					}
					else
					{
						udValue--;
800096a4:	20 18       	sub	r8,1
800096a6:	a2 88       	st.b	r1[0x0],r8
					}
					xQueueSend( mainUdQueue, &udValue, (TickType_t) 0);
800096a8:	0a 99       	mov	r9,r5
800096aa:	0a 9a       	mov	r10,r5
800096ac:	02 9b       	mov	r11,r1
800096ae:	4e 78       	lddpc	r8,80009848 <qtButtonTask+0x2e4>
800096b0:	70 0c       	ld.w	r12,r8[0x0]
800096b2:	f0 1f 00 6d 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
800096b6:	66 0c       	ld.w	r12,r3[0x0]
800096b8:	f0 1f 00 6c 	mcall	80009868 <qtButtonTask+0x304>
800096bc:	c4 18       	rjmp	8000973e <qtButtonTask+0x1da>
				}
				else if (INTC_QT_FLAG._down) {
800096be:	10 99       	mov	r9,r8
800096c0:	e2 19 00 08 	andl	r9,0x8,COH
800096c4:	ec 09 18 00 	cp.b	r9,r6
800096c8:	c2 90       	breq	8000971a <qtButtonTask+0x1b6>
					INTC_QT_FLAG._down = false;
800096ca:	0f 88       	ld.ub	r8,r7[0x0]
800096cc:	f1 d5 d0 61 	bfins	r8,r5,0x3,0x1
800096d0:	ae 88       	st.b	r7[0x0],r8
					//udValue = (udValue + 1 <= 2) ? udValue + 1 : udValue;
					if (udValue == 1)
800096d2:	03 88       	ld.ub	r8,r1[0x0]
800096d4:	30 19       	mov	r9,1
800096d6:	f2 08 18 00 	cp.b	r8,r9
800096da:	c1 31       	brne	80009700 <qtButtonTask+0x19c>
					{
						if (et_data.actual_page < et_data.pages_available - 1)
800096dc:	4e 48       	lddpc	r8,8000986c <qtButtonTask+0x308>
800096de:	11 99       	ld.ub	r9,r8[0x1]
800096e0:	11 88       	ld.ub	r8,r8[0x0]
800096e2:	20 18       	sub	r8,1
800096e4:	10 39       	cp.w	r9,r8
800096e6:	c0 f4       	brge	80009704 <qtButtonTask+0x1a0>
						{
							et_data.actual_page++;
800096e8:	2f f9       	sub	r9,-1
800096ea:	4e 18       	lddpc	r8,8000986c <qtButtonTask+0x308>
800096ec:	b0 99       	st.b	r8[0x1],r9
							xTaskNotifyGive( etHandle );
800096ee:	0a 98       	mov	r8,r5
800096f0:	00 99       	mov	r9,r0
800096f2:	0a 9a       	mov	r10,r5
800096f4:	0a 9b       	mov	r11,r5
800096f6:	66 0c       	ld.w	r12,r3[0x0]
800096f8:	f0 1f 00 5e 	mcall	80009870 <qtButtonTask+0x30c>
							udValue = 0;
800096fc:	a2 86       	st.b	r1[0x0],r6
800096fe:	c0 38       	rjmp	80009704 <qtButtonTask+0x1a0>
						}
					}
					else
					{
						udValue++;
80009700:	2f f8       	sub	r8,-1
80009702:	a2 88       	st.b	r1[0x0],r8
					}
					xQueueSend( mainUdQueue, &udValue, (TickType_t) 0);
80009704:	0a 99       	mov	r9,r5
80009706:	0a 9a       	mov	r10,r5
80009708:	02 9b       	mov	r11,r1
8000970a:	4d 08       	lddpc	r8,80009848 <qtButtonTask+0x2e4>
8000970c:	70 0c       	ld.w	r12,r8[0x0]
8000970e:	f0 1f 00 56 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
80009712:	66 0c       	ld.w	r12,r3[0x0]
80009714:	f0 1f 00 55 	mcall	80009868 <qtButtonTask+0x304>
80009718:	c1 38       	rjmp	8000973e <qtButtonTask+0x1da>
				}
				else if (INTC_QT_FLAG._enter) {
8000971a:	10 99       	mov	r9,r8
8000971c:	e0 19 ff 80 	andl	r9,0xff80
80009720:	ec 09 18 00 	cp.b	r9,r6
80009724:	c4 30       	breq	800097aa <qtButtonTask+0x246>
					INTC_QT_FLAG._enter = false;
80009726:	0f 88       	ld.ub	r8,r7[0x0]
80009728:	f1 d5 d0 e1 	bfins	r8,r5,0x7,0x1
8000972c:	ae 88       	st.b	r7[0x0],r8
					xTaskNotifyGive(audioHandle);
8000972e:	0a 98       	mov	r8,r5
80009730:	00 99       	mov	r9,r0
80009732:	0a 9a       	mov	r10,r5
80009734:	0a 9b       	mov	r11,r5
80009736:	4d 0e       	lddpc	lr,80009874 <qtButtonTask+0x310>
80009738:	7c 0c       	ld.w	r12,lr[0x0]
8000973a:	f0 1f 00 4e 	mcall	80009870 <qtButtonTask+0x30c>
				}
				
			case REPRODUCIR:
				if (INTC_QT_FLAG._left) {
8000973e:	0f 88       	ld.ub	r8,r7[0x0]
80009740:	10 99       	mov	r9,r8
80009742:	e2 19 00 40 	andl	r9,0x40,COH
80009746:	ec 09 18 00 	cp.b	r9,r6
8000974a:	c1 40       	breq	80009772 <qtButtonTask+0x20e>
					INTC_QT_FLAG._left = false;
8000974c:	0f 88       	ld.ub	r8,r7[0x0]
8000974e:	f1 d5 d0 c1 	bfins	r8,r5,0x6,0x1
80009752:	ae 88       	st.b	r7[0x0],r8
					lrValue = (lrValue > 0) ? lrValue - 1 : lrValue;
80009754:	09 88       	ld.ub	r8,r4[0x0]
80009756:	58 08       	cp.w	r8,0
80009758:	c0 20       	breq	8000975c <qtButtonTask+0x1f8>
8000975a:	20 18       	sub	r8,1
8000975c:	a8 88       	st.b	r4[0x0],r8
					xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
8000975e:	0a 99       	mov	r9,r5
80009760:	0a 9a       	mov	r10,r5
80009762:	08 9b       	mov	r11,r4
80009764:	64 0c       	ld.w	r12,r2[0x0]
80009766:	f0 1f 00 40 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
8000976a:	66 0c       	ld.w	r12,r3[0x0]
8000976c:	f0 1f 00 3f 	mcall	80009868 <qtButtonTask+0x304>
80009770:	c4 3b       	rjmp	800095f6 <qtButtonTask+0x92>
				}
				else if (INTC_QT_FLAG._right) {
80009772:	10 99       	mov	r9,r8
80009774:	e2 19 00 20 	andl	r9,0x20,COH
80009778:	ec 09 18 00 	cp.b	r9,r6
8000977c:	c1 70       	breq	800097aa <qtButtonTask+0x246>
					INTC_QT_FLAG._right = false;
8000977e:	0f 88       	ld.ub	r8,r7[0x0]
80009780:	f1 d5 d0 a1 	bfins	r8,r5,0x5,0x1
80009784:	ae 88       	st.b	r7[0x0],r8
					lrValue = (lrValue + 1 < 2) ? lrValue + 1 : lrValue;
80009786:	09 88       	ld.ub	r8,r4[0x0]
80009788:	f0 c9 ff ff 	sub	r9,r8,-1
8000978c:	58 19       	cp.w	r9,1
8000978e:	e0 89 00 03 	brgt	80009794 <qtButtonTask+0x230>
80009792:	2f f8       	sub	r8,-1
80009794:	a8 88       	st.b	r4[0x0],r8
					xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
80009796:	0a 99       	mov	r9,r5
80009798:	0a 9a       	mov	r10,r5
8000979a:	08 9b       	mov	r11,r4
8000979c:	64 0c       	ld.w	r12,r2[0x0]
8000979e:	f0 1f 00 32 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
800097a2:	66 0c       	ld.w	r12,r3[0x0]
800097a4:	f0 1f 00 31 	mcall	80009868 <qtButtonTask+0x304>
800097a8:	c2 7b       	rjmp	800095f6 <qtButtonTask+0x92>
				}
				else if (INTC_QT_FLAG._up) {
800097aa:	10 99       	mov	r9,r8
800097ac:	e2 19 00 10 	andl	r9,0x10,COH
800097b0:	ec 09 18 00 	cp.b	r9,r6
800097b4:	c1 50       	breq	800097de <qtButtonTask+0x27a>
					INTC_QT_FLAG._up = false;
800097b6:	0f 88       	ld.ub	r8,r7[0x0]
800097b8:	f1 d5 d0 81 	bfins	r8,r5,0x4,0x1
800097bc:	ae 88       	st.b	r7[0x0],r8
					udValue = (udValue > 0) ? udValue - 1 : udValue;
800097be:	03 88       	ld.ub	r8,r1[0x0]
800097c0:	58 08       	cp.w	r8,0
800097c2:	c0 20       	breq	800097c6 <qtButtonTask+0x262>
800097c4:	20 18       	sub	r8,1
800097c6:	a2 88       	st.b	r1[0x0],r8
					xQueueSend( repUdQueue, &udValue, (TickType_t) 0);
800097c8:	0a 99       	mov	r9,r5
800097ca:	0a 9a       	mov	r10,r5
800097cc:	02 9b       	mov	r11,r1
800097ce:	49 d8       	lddpc	r8,80009840 <qtButtonTask+0x2dc>
800097d0:	70 0c       	ld.w	r12,r8[0x0]
800097d2:	f0 1f 00 25 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
800097d6:	66 0c       	ld.w	r12,r3[0x0]
800097d8:	f0 1f 00 24 	mcall	80009868 <qtButtonTask+0x304>
800097dc:	c0 db       	rjmp	800095f6 <qtButtonTask+0x92>
				}
				else if (INTC_QT_FLAG._down) {
800097de:	10 99       	mov	r9,r8
800097e0:	e2 19 00 08 	andl	r9,0x8,COH
800097e4:	ec 09 18 00 	cp.b	r9,r6
800097e8:	c1 80       	breq	80009818 <qtButtonTask+0x2b4>
					INTC_QT_FLAG._down = false;
800097ea:	0f 88       	ld.ub	r8,r7[0x0]
800097ec:	f1 d5 d0 61 	bfins	r8,r5,0x3,0x1
800097f0:	ae 88       	st.b	r7[0x0],r8
					udValue = (udValue + 1 <= 2) ? udValue + 1 : udValue;
800097f2:	03 88       	ld.ub	r8,r1[0x0]
800097f4:	f0 c9 ff ff 	sub	r9,r8,-1
800097f8:	58 29       	cp.w	r9,2
800097fa:	e0 89 00 03 	brgt	80009800 <qtButtonTask+0x29c>
800097fe:	2f f8       	sub	r8,-1
80009800:	a2 88       	st.b	r1[0x0],r8
					xQueueSend( repUdQueue, &udValue, (TickType_t) 0);
80009802:	0a 99       	mov	r9,r5
80009804:	0a 9a       	mov	r10,r5
80009806:	02 9b       	mov	r11,r1
80009808:	48 e8       	lddpc	r8,80009840 <qtButtonTask+0x2dc>
8000980a:	70 0c       	ld.w	r12,r8[0x0]
8000980c:	f0 1f 00 16 	mcall	80009864 <qtButtonTask+0x300>
					vTaskResume(etHandle);
80009810:	66 0c       	ld.w	r12,r3[0x0]
80009812:	f0 1f 00 16 	mcall	80009868 <qtButtonTask+0x304>
80009816:	cf 0a       	rjmp	800095f6 <qtButtonTask+0x92>
				}
				else if (INTC_QT_FLAG._enter) {
80009818:	e0 18 ff 80 	andl	r8,0xff80
8000981c:	ec 08 18 00 	cp.b	r8,r6
80009820:	fe 90 fe eb 	breq	800095f6 <qtButtonTask+0x92>
					INTC_QT_FLAG._enter = false;
80009824:	0f 88       	ld.ub	r8,r7[0x0]
80009826:	f1 d5 d0 e1 	bfins	r8,r5,0x7,0x1
8000982a:	ae 88       	st.b	r7[0x0],r8
8000982c:	ce 5a       	rjmp	800095f6 <qtButtonTask+0x92>
8000982e:	00 00       	add	r0,r0
80009830:	80 00       	ld.sh	r0,r0[0x0]
80009832:	9d f8       	st.w	lr[0x3c],r8
80009834:	80 00       	ld.sh	r0,r0[0x0]
80009836:	7a b8       	ld.w	r8,sp[0x2c]
80009838:	00 00       	add	r0,r0
8000983a:	16 b8       	st.h	r11++,r8
8000983c:	00 00       	add	r0,r0
8000983e:	16 98       	mov	r8,r11
80009840:	00 00       	add	r0,r0
80009842:	16 b0       	st.h	r11++,r0
80009844:	00 00       	add	r0,r0
80009846:	16 a0       	st.w	r11++,r0
80009848:	00 00       	add	r0,r0
8000984a:	16 a8       	st.w	r11++,r8
8000984c:	00 00       	add	r0,r0
8000984e:	16 b4       	st.h	r11++,r4
80009850:	00 00       	add	r0,r0
80009852:	16 9c       	mov	r12,r11
80009854:	00 00       	add	r0,r0
80009856:	06 f2       	st.b	--r3,r2
80009858:	00 00       	add	r0,r0
8000985a:	06 f8       	st.b	--r3,r8
8000985c:	00 00       	add	r0,r0
8000985e:	06 e8       	st.h	--r3,r8
80009860:	80 00       	ld.sh	r0,r0[0x0]
80009862:	82 70       	ld.sh	r0,r1[0xe]
80009864:	80 00       	ld.sh	r0,r0[0x0]
80009866:	79 24       	ld.w	r4,r12[0x48]
80009868:	80 00       	ld.sh	r0,r0[0x0]
8000986a:	81 f0       	st.w	r0[0x3c],r0
8000986c:	00 00       	add	r0,r0
8000986e:	0a e4       	st.h	--r5,r4
80009870:	80 00       	ld.sh	r0,r0[0x0]
80009872:	7c 74       	ld.w	r4,lr[0x1c]
80009874:	00 00       	add	r0,r0
80009876:	0a f0       	st.b	--r5,r0

80009878 <sdramTask>:
	
}

// sdramHandle
portTASK_FUNCTION( sdramTask, p )
{
80009878:	eb cd 40 fe 	pushm	r1-r7,lr
8000987c:	20 1d       	sub	sp,4
	volatile unsigned long *sdram = SDRAM;
	UBaseType_t sample = 0;
8000987e:	30 06       	mov	r6,0
80009880:	fa c7 ff fc 	sub	r7,sp,-4
80009884:	0e d6       	st.w	--r7,r6
	
	// Calculate SDRAM size in words (32 bits).
	sdram_size = SDRAM_SIZE >> 2;
80009886:	49 e5       	lddpc	r5,800098fc <sdramTask+0x84>
80009888:	fc 18 00 80 	movh	r8,0x80
8000988c:	8b 08       	st.w	r5[0x0],r8
	print_dbg("\x0CSDRAM size in bytes: ");
8000988e:	49 dc       	lddpc	r12,80009900 <sdramTask+0x88>
80009890:	f0 1f 00 1d 	mcall	80009904 <sdramTask+0x8c>
	print_dbg_ulong(sdram_size*4);
80009894:	6a 0c       	ld.w	r12,r5[0x0]
80009896:	a3 6c       	lsl	r12,0x2
80009898:	f0 1f 00 1c 	mcall	80009908 <sdramTask+0x90>
	print_dbg("\r\n");
8000989c:	49 cc       	lddpc	r12,8000990c <sdramTask+0x94>
8000989e:	f0 1f 00 1a 	mcall	80009904 <sdramTask+0x8c>

	//print_dbg("Suspending task");
	xTaskNotifyGive(fsHandle);
800098a2:	0c 98       	mov	r8,r6
800098a4:	30 29       	mov	r9,2
800098a6:	0c 9a       	mov	r10,r6
800098a8:	0c 9b       	mov	r11,r6
800098aa:	49 ac       	lddpc	r12,80009910 <sdramTask+0x98>
800098ac:	78 0c       	ld.w	r12,r12[0x0]
800098ae:	f0 1f 00 1a 	mcall	80009914 <sdramTask+0x9c>
	vTaskSuspend(NULL);
800098b2:	0c 9c       	mov	r12,r6
800098b4:	f0 1f 00 19 	mcall	80009918 <sdramTask+0xa0>
	
	while(1)
	{
		if (sdramQueue != 0)
800098b8:	49 95       	lddpc	r5,8000991c <sdramTask+0xa4>
		{
			if (xQueueReceive( sdramQueue, &sample, (TickType_t) 2 ))
800098ba:	30 26       	mov	r6,2
			{
				sdram[sdram_ptr++] = sample;
800098bc:	49 94       	lddpc	r4,80009920 <sdramTask+0xa8>
800098be:	fc 12 d0 00 	movh	r2,0xd000
				xTaskNotifyGive(fsHandle);
800098c2:	49 41       	lddpc	r1,80009910 <sdramTask+0x98>
800098c4:	30 03       	mov	r3,0
	xTaskNotifyGive(fsHandle);
	vTaskSuspend(NULL);
	
	while(1)
	{
		if (sdramQueue != 0)
800098c6:	6a 0c       	ld.w	r12,r5[0x0]
800098c8:	58 0c       	cp.w	r12,0
800098ca:	c1 70       	breq	800098f8 <sdramTask+0x80>
		{
			if (xQueueReceive( sdramQueue, &sample, (TickType_t) 2 ))
800098cc:	0c 9a       	mov	r10,r6
800098ce:	1a 9b       	mov	r11,sp
800098d0:	f0 1f 00 15 	mcall	80009924 <sdramTask+0xac>
800098d4:	cf 90       	breq	800098c6 <sdramTask+0x4e>
			{
				sdram[sdram_ptr++] = sample;
800098d6:	68 08       	ld.w	r8,r4[0x0]
800098d8:	40 0a       	lddsp	r10,sp[0x0]
800098da:	e4 08 09 2a 	st.w	r2[r8<<0x2],r10
800098de:	2f f8       	sub	r8,-1
800098e0:	89 08       	st.w	r4[0x0],r8
				xTaskNotifyGive(fsHandle);
800098e2:	06 98       	mov	r8,r3
800098e4:	0c 99       	mov	r9,r6
800098e6:	06 9a       	mov	r10,r3
800098e8:	06 9b       	mov	r11,r3
800098ea:	62 0c       	ld.w	r12,r1[0x0]
800098ec:	f0 1f 00 0a 	mcall	80009914 <sdramTask+0x9c>
				vTaskSuspend(NULL);
800098f0:	06 9c       	mov	r12,r3
800098f2:	f0 1f 00 0a 	mcall	80009918 <sdramTask+0xa0>
800098f6:	ce 8b       	rjmp	800098c6 <sdramTask+0x4e>
800098f8:	c0 08       	rjmp	800098f8 <sdramTask+0x80>
800098fa:	00 00       	add	r0,r0
800098fc:	00 00       	add	r0,r0
800098fe:	06 ec       	st.h	--r3,r12
80009900:	80 01       	ld.sh	r1,r0[0x0]
80009902:	51 f4       	stdsp	sp[0x7c],r4
80009904:	80 00       	ld.sh	r0,r0[0x0]
80009906:	6f 6c       	ld.w	r12,r7[0x58]
80009908:	80 00       	ld.sh	r0,r0[0x0]
8000990a:	6f 58       	ld.w	r8,r7[0x54]
8000990c:	80 01       	ld.sh	r1,r0[0x0]
8000990e:	51 f0       	stdsp	sp[0x7c],r0
80009910:	00 00       	add	r0,r0
80009912:	0b 18       	ld.sh	r8,r5++
80009914:	80 00       	ld.sh	r0,r0[0x0]
80009916:	7c 74       	ld.w	r4,lr[0x1c]
80009918:	80 00       	ld.sh	r0,r0[0x0]
8000991a:	82 70       	ld.sh	r0,r1[0xe]
8000991c:	00 00       	add	r0,r0
8000991e:	16 a4       	st.w	r11++,r4
80009920:	00 00       	add	r0,r0
80009922:	0b 14       	ld.sh	r4,r5++
80009924:	80 00       	ld.sh	r0,r0[0x0]
80009926:	76 34       	ld.w	r4,r11[0xc]

80009928 <fsTask>:

}

// fsHandle
portTASK_FUNCTION( fsTask, p )
{
80009928:	d4 31       	pushm	r0-r7,lr
8000992a:	20 7d       	sub	sp,28
	sdramQueue = xQueueCreate( 1 , sizeof(unsigned long));
8000992c:	30 0a       	mov	r10,0
8000992e:	30 4b       	mov	r11,4
80009930:	30 1c       	mov	r12,1
80009932:	f0 1f 00 a6 	mcall	80009bc8 <fsTask+0x2a0>
80009936:	fe f8 02 96 	ld.w	r8,pc[662]
8000993a:	91 0c       	st.w	r8[0x0],r12
	
	/****		Get all files data	 ****/
	nav_filelist_reset();
8000993c:	f0 1f 00 a5 	mcall	80009bd0 <fsTask+0x2a8>
	nav_filelist_goto( 0 ); // System volume information
80009940:	30 0c       	mov	r12,0
80009942:	f0 1f 00 a5 	mcall	80009bd4 <fsTask+0x2ac>
	uint8_t files = 0;
	print_dbg("Files: \r\n");
80009946:	fe fc 02 92 	ld.w	r12,pc[658]
8000994a:	f0 1f 00 a5 	mcall	80009bdc <fsTask+0x2b4>
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
8000994e:	fe f8 02 92 	ld.w	r8,pc[658]
80009952:	11 c9       	ld.ub	r9,r8[0x4]
80009954:	30 08       	mov	r8,0
80009956:	f0 09 18 00 	cp.b	r9,r8
8000995a:	c2 80       	breq	800099aa <fsTask+0x82>
8000995c:	fe f6 02 84 	ld.w	r6,pc[644]
80009960:	2f 86       	sub	r6,-8
80009962:	30 07       	mov	r7,0
	{
		nav_filelist_set(sd.drive_number, FS_FIND_NEXT);
80009964:	fe f5 02 7c 	ld.w	r5,pc[636]
80009968:	30 13       	mov	r3,1
		nav_file_getname(sd.name_of_files[i], 30);
8000996a:	31 e2       	mov	r2,30
		print_dbg(sd.name_of_files[i]);
		print_dbg("\r\n");
8000996c:	fe f1 02 78 	ld.w	r1,pc[632]
		files++;
		vTaskDelay(pdMS_TO_TICKS(100));
80009970:	36 40       	mov	r0,100
	uint8_t files = 0;
	print_dbg("Files: \r\n");
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
	{
		nav_filelist_set(sd.drive_number, FS_FIND_NEXT);
80009972:	06 9b       	mov	r11,r3
80009974:	0b bc       	ld.ub	r12,r5[0x3]
80009976:	f0 1f 00 9d 	mcall	80009be8 <fsTask+0x2c0>
		nav_file_getname(sd.name_of_files[i], 30);
8000997a:	04 9b       	mov	r11,r2
8000997c:	6c 0c       	ld.w	r12,r6[0x0]
8000997e:	f0 1f 00 9c 	mcall	80009bec <fsTask+0x2c4>
		print_dbg(sd.name_of_files[i]);
80009982:	0d 0c       	ld.w	r12,r6++
80009984:	f0 1f 00 96 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg("\r\n");
80009988:	02 9c       	mov	r12,r1
8000998a:	f0 1f 00 95 	mcall	80009bdc <fsTask+0x2b4>
8000998e:	0e 94       	mov	r4,r7
80009990:	2f f4       	sub	r4,-1
80009992:	5c 54       	castu.b	r4
		files++;
		vTaskDelay(pdMS_TO_TICKS(100));
80009994:	00 9c       	mov	r12,r0
80009996:	f0 1f 00 97 	mcall	80009bf0 <fsTask+0x2c8>
	nav_filelist_reset();
	nav_filelist_goto( 0 ); // System volume information
	uint8_t files = 0;
	print_dbg("Files: \r\n");
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
8000999a:	2f f7       	sub	r7,-1
8000999c:	0b c8       	ld.ub	r8,r5[0x4]
8000999e:	0e 38       	cp.w	r8,r7
800099a0:	fe 9b ff e9 	brhi	80009972 <fsTask+0x4a>
		print_dbg(sd.name_of_files[i]);
		print_dbg("\r\n");
		files++;
		vTaskDelay(pdMS_TO_TICKS(100));
	}
	if (files == sd.number_of_files)
800099a4:	f0 04 18 00 	cp.b	r4,r8
800099a8:	c0 51       	brne	800099b2 <fsTask+0x8a>
	{
		print_dbg("Number of files coincide.\r\n");
800099aa:	fe fc 02 4a 	ld.w	r12,pc[586]
800099ae:	f0 1f 00 8c 	mcall	80009bdc <fsTask+0x2b4>
	}
	
	/***	Retrieve Info data	****/
	char info[20];
	FS_STRING name;
	nav_filelist_reset();
800099b2:	f0 1f 00 88 	mcall	80009bd0 <fsTask+0x2a8>
	nav_filterlist_setfilter("txt");
800099b6:	fe fc 02 42 	ld.w	r12,pc[578]
800099ba:	f0 1f 00 91 	mcall	80009bfc <fsTask+0x2d4>
	nav_filterlist_root();
800099be:	f0 1f 00 91 	mcall	80009c00 <fsTask+0x2d8>
	nav_filterlist_goto( 0 ); // System volume information
800099c2:	30 0c       	mov	r12,0
800099c4:	f0 1f 00 90 	mcall	80009c04 <fsTask+0x2dc>
	for (size_t i = 0; i < (sd.number_of_files / 2); i++)
800099c8:	fe f8 02 18 	ld.w	r8,pc[536]
800099cc:	11 c9       	ld.ub	r9,r8[0x4]
800099ce:	30 18       	mov	r8,1
800099d0:	f0 09 18 00 	cp.b	r9,r8
800099d4:	e0 88 00 76 	brls	80009ac0 <fsTask+0x198>
800099d8:	30 02       	mov	r2,0
		print_dbg("\r\n");
		
		//file_open(FOPEN_MODE_R);
		reader_txt_open( true );
		
		reader_txt_get_line(false, info, 20);
800099da:	fa c7 ff f8 	sub	r7,sp,-8
800099de:	31 45       	mov	r5,20
800099e0:	04 94       	mov	r4,r2
		strcpy(song_info[i].name, info);
800099e2:	fe f3 02 26 	ld.w	r3,pc[550]
	nav_filterlist_setfilter("txt");
	nav_filterlist_root();
	nav_filterlist_goto( 0 ); // System volume information
	for (size_t i = 0; i < (sd.number_of_files / 2); i++)
	{
		nav_filterlist_next();
800099e6:	f0 1f 00 8a 	mcall	80009c0c <fsTask+0x2e4>
		nav_file_getname(name, 30);
800099ea:	31 eb       	mov	r11,30
800099ec:	30 06       	mov	r6,0
800099ee:	0c 9c       	mov	r12,r6
800099f0:	f0 1f 00 7f 	mcall	80009bec <fsTask+0x2c4>
		print_dbg(name);
800099f4:	0c 9c       	mov	r12,r6
800099f6:	f0 1f 00 7a 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg("\r\n");
800099fa:	4f bc       	lddpc	r12,80009be4 <fsTask+0x2bc>
800099fc:	f0 1f 00 78 	mcall	80009bdc <fsTask+0x2b4>
		
		//file_open(FOPEN_MODE_R);
		reader_txt_open( true );
80009a00:	30 1c       	mov	r12,1
80009a02:	f0 1f 00 84 	mcall	80009c10 <fsTask+0x2e8>
		
		reader_txt_get_line(false, info, 20);
80009a06:	0a 9a       	mov	r10,r5
80009a08:	0e 9b       	mov	r11,r7
80009a0a:	08 9c       	mov	r12,r4
80009a0c:	f0 1f 00 82 	mcall	80009c14 <fsTask+0x2ec>
		strcpy(song_info[i].name, info);
80009a10:	e4 06 10 64 	mul	r6,r2,100
80009a14:	e6 06 00 01 	add	r1,r3,r6
80009a18:	0e 9b       	mov	r11,r7
80009a1a:	02 9c       	mov	r12,r1
80009a1c:	f0 1f 00 7f 	mcall	80009c18 <fsTask+0x2f0>
		reader_txt_get_line(false, info, 20);
80009a20:	0a 9a       	mov	r10,r5
80009a22:	0e 9b       	mov	r11,r7
80009a24:	08 9c       	mov	r12,r4
80009a26:	f0 1f 00 7c 	mcall	80009c14 <fsTask+0x2ec>
		strcpy(song_info[i].artist, info);
80009a2a:	ec c0 ff ec 	sub	r0,r6,-20
80009a2e:	e6 00 00 00 	add	r0,r3,r0
80009a32:	0e 9b       	mov	r11,r7
80009a34:	00 9c       	mov	r12,r0
80009a36:	f0 1f 00 79 	mcall	80009c18 <fsTask+0x2f0>
		reader_txt_get_line(false, info, 20);
80009a3a:	0a 9a       	mov	r10,r5
80009a3c:	0e 9b       	mov	r11,r7
80009a3e:	08 9c       	mov	r12,r4
80009a40:	f0 1f 00 75 	mcall	80009c14 <fsTask+0x2ec>
		strcpy(song_info[i].album, info);
80009a44:	ec c8 ff d8 	sub	r8,r6,-40
80009a48:	e6 08 00 08 	add	r8,r3,r8
80009a4c:	50 18       	stdsp	sp[0x4],r8
80009a4e:	0e 9b       	mov	r11,r7
80009a50:	10 9c       	mov	r12,r8
80009a52:	f0 1f 00 72 	mcall	80009c18 <fsTask+0x2f0>
		reader_txt_get_line(false, info, 20);
80009a56:	0a 9a       	mov	r10,r5
80009a58:	0e 9b       	mov	r11,r7
80009a5a:	08 9c       	mov	r12,r4
80009a5c:	f0 1f 00 6e 	mcall	80009c14 <fsTask+0x2ec>
		strcpy(song_info[i].year, info);
80009a60:	ec c8 ff c4 	sub	r8,r6,-60
80009a64:	e6 08 00 08 	add	r8,r3,r8
80009a68:	50 08       	stdsp	sp[0x0],r8
80009a6a:	0e 9b       	mov	r11,r7
80009a6c:	10 9c       	mov	r12,r8
80009a6e:	f0 1f 00 6b 	mcall	80009c18 <fsTask+0x2f0>
		reader_txt_get_line(false, info, 20);
80009a72:	0a 9a       	mov	r10,r5
80009a74:	0e 9b       	mov	r11,r7
80009a76:	08 9c       	mov	r12,r4
80009a78:	f0 1f 00 67 	mcall	80009c14 <fsTask+0x2ec>
		strcpy(song_info[i].duration, info);
80009a7c:	2b 06       	sub	r6,-80
80009a7e:	e6 06 00 06 	add	r6,r3,r6
80009a82:	0e 9b       	mov	r11,r7
80009a84:	0c 9c       	mov	r12,r6
80009a86:	f0 1f 00 65 	mcall	80009c18 <fsTask+0x2f0>

		// Close the file.
		reader_txt_close();
80009a8a:	f0 1f 00 65 	mcall	80009c1c <fsTask+0x2f4>
		
		print_dbg(song_info[i].name);
80009a8e:	02 9c       	mov	r12,r1
80009a90:	f0 1f 00 53 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg(song_info[i].artist);
80009a94:	00 9c       	mov	r12,r0
80009a96:	f0 1f 00 52 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg(song_info[i].album);
80009a9a:	40 1c       	lddsp	r12,sp[0x4]
80009a9c:	f0 1f 00 50 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg(song_info[i].year);
80009aa0:	40 0c       	lddsp	r12,sp[0x0]
80009aa2:	f0 1f 00 4f 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg(song_info[i].duration);
80009aa6:	0c 9c       	mov	r12,r6
80009aa8:	f0 1f 00 4d 	mcall	80009bdc <fsTask+0x2b4>
		
		print_dbg("\r\n");
80009aac:	4c ec       	lddpc	r12,80009be4 <fsTask+0x2bc>
80009aae:	f0 1f 00 4c 	mcall	80009bdc <fsTask+0x2b4>
	FS_STRING name;
	nav_filelist_reset();
	nav_filterlist_setfilter("txt");
	nav_filterlist_root();
	nav_filterlist_goto( 0 ); // System volume information
	for (size_t i = 0; i < (sd.number_of_files / 2); i++)
80009ab2:	2f f2       	sub	r2,-1
80009ab4:	4c b9       	lddpc	r9,80009be0 <fsTask+0x2b8>
80009ab6:	13 c8       	ld.ub	r8,r9[0x4]
80009ab8:	a1 98       	lsr	r8,0x1
80009aba:	04 38       	cp.w	r8,r2
80009abc:	fe 9b ff 95 	brhi	800099e6 <fsTask+0xbe>
	}
	
	/***	Retrieve Audio Info		****/

	/* Filter List ".h" */
	nav_filelist_reset();
80009ac0:	f0 1f 00 44 	mcall	80009bd0 <fsTask+0x2a8>
	nav_filterlist_setfilter("h");
80009ac4:	4d 7c       	lddpc	r12,80009c20 <fsTask+0x2f8>
80009ac6:	f0 1f 00 4e 	mcall	80009bfc <fsTask+0x2d4>
	nav_filterlist_root();
80009aca:	f0 1f 00 4e 	mcall	80009c00 <fsTask+0x2d8>
	nav_filterlist_goto( 0 ); // System volume information
80009ace:	30 0c       	mov	r12,0
80009ad0:	f0 1f 00 4d 	mcall	80009c04 <fsTask+0x2dc>
	//sd.number_of_audio_files = nav_filterlist_nb(FS_FILE, "h");
	sd.number_of_audio_files = (sd.number_of_files / 2);
80009ad4:	4c 37       	lddpc	r7,80009be0 <fsTask+0x2b8>
80009ad6:	0f cc       	ld.ub	r12,r7[0x4]
80009ad8:	a1 9c       	lsr	r12,0x1
80009ada:	ae dc       	st.b	r7[0x5],r12
	print_dbg_ulong(sd.number_of_audio_files);
80009adc:	f0 1f 00 52 	mcall	80009c24 <fsTask+0x2fc>
	et_data.pages_available = sd.number_of_audio_files / 4;
80009ae0:	0f d8       	ld.ub	r8,r7[0x5]
80009ae2:	a3 88       	lsr	r8,0x2
80009ae4:	4d 19       	lddpc	r9,80009c28 <fsTask+0x300>
80009ae6:	b2 88       	st.b	r9[0x0],r8
	if (sd.number_of_files % 4 != 0)
80009ae8:	0f c9       	ld.ub	r9,r7[0x4]
80009aea:	f3 d9 c0 02 	bfextu	r9,r9,0x0,0x2
80009aee:	c0 40       	breq	80009af6 <fsTask+0x1ce>
	{
		et_data.pages_available++;
80009af0:	2f f8       	sub	r8,-1
80009af2:	4c e9       	lddpc	r9,80009c28 <fsTask+0x300>
80009af4:	b2 88       	st.b	r9[0x0],r8
	}
	//print_dbg_ulong(et_data.pages_available);
	
	/* Filter List ".h" */
	files = 0;
	nav_filelist_reset();
80009af6:	f0 1f 00 37 	mcall	80009bd0 <fsTask+0x2a8>
	nav_filterlist_setfilter("h");
80009afa:	4c ac       	lddpc	r12,80009c20 <fsTask+0x2f8>
80009afc:	f0 1f 00 40 	mcall	80009bfc <fsTask+0x2d4>
	nav_filterlist_root();
80009b00:	f0 1f 00 40 	mcall	80009c00 <fsTask+0x2d8>
	nav_filterlist_goto( 0 ); // System volume information
80009b04:	30 0c       	mov	r12,0
80009b06:	f0 1f 00 40 	mcall	80009c04 <fsTask+0x2dc>
	print_dbg("Audio Files: \r\n");
80009b0a:	4c 9c       	lddpc	r12,80009c2c <fsTask+0x304>
80009b0c:	f0 1f 00 34 	mcall	80009bdc <fsTask+0x2b4>
	for(size_t i = 0; i < sd.number_of_audio_files; i++)
80009b10:	4b 48       	lddpc	r8,80009be0 <fsTask+0x2b8>
80009b12:	11 d9       	ld.ub	r9,r8[0x5]
80009b14:	30 08       	mov	r8,0
80009b16:	f0 09 18 00 	cp.b	r9,r8
80009b1a:	c2 20       	breq	80009b5e <fsTask+0x236>
80009b1c:	4b 16       	lddpc	r6,80009be0 <fsTask+0x2b8>
80009b1e:	29 46       	sub	r6,-108
80009b20:	30 07       	mov	r7,0
	{
		nav_filterlist_next();
		nav_file_getname(sd.name_of_audio_files[i], 30);
80009b22:	31 e4       	mov	r4,30
		print_dbg(sd.name_of_audio_files[i]);
		print_dbg("\r\n");
80009b24:	4b 03       	lddpc	r3,80009be4 <fsTask+0x2bc>
		files++;
		vTaskDelay(pdMS_TO_TICKS(100));
80009b26:	36 42       	mov	r2,100
	nav_filelist_reset();
	nav_filterlist_setfilter("h");
	nav_filterlist_root();
	nav_filterlist_goto( 0 ); // System volume information
	print_dbg("Audio Files: \r\n");
	for(size_t i = 0; i < sd.number_of_audio_files; i++)
80009b28:	4a e1       	lddpc	r1,80009be0 <fsTask+0x2b8>
	{
		nav_filterlist_next();
80009b2a:	f0 1f 00 39 	mcall	80009c0c <fsTask+0x2e4>
		nav_file_getname(sd.name_of_audio_files[i], 30);
80009b2e:	08 9b       	mov	r11,r4
80009b30:	6c 0c       	ld.w	r12,r6[0x0]
80009b32:	f0 1f 00 2f 	mcall	80009bec <fsTask+0x2c4>
		print_dbg(sd.name_of_audio_files[i]);
80009b36:	0d 0c       	ld.w	r12,r6++
80009b38:	f0 1f 00 29 	mcall	80009bdc <fsTask+0x2b4>
		print_dbg("\r\n");
80009b3c:	06 9c       	mov	r12,r3
80009b3e:	f0 1f 00 28 	mcall	80009bdc <fsTask+0x2b4>
80009b42:	0e 95       	mov	r5,r7
80009b44:	2f f5       	sub	r5,-1
80009b46:	5c 55       	castu.b	r5
		files++;
		vTaskDelay(pdMS_TO_TICKS(100));
80009b48:	04 9c       	mov	r12,r2
80009b4a:	f0 1f 00 2a 	mcall	80009bf0 <fsTask+0x2c8>
	nav_filelist_reset();
	nav_filterlist_setfilter("h");
	nav_filterlist_root();
	nav_filterlist_goto( 0 ); // System volume information
	print_dbg("Audio Files: \r\n");
	for(size_t i = 0; i < sd.number_of_audio_files; i++)
80009b4e:	2f f7       	sub	r7,-1
80009b50:	03 d8       	ld.ub	r8,r1[0x5]
80009b52:	0e 38       	cp.w	r8,r7
80009b54:	fe 9b ff eb 	brhi	80009b2a <fsTask+0x202>
		print_dbg(sd.name_of_audio_files[i]);
		print_dbg("\r\n");
		files++;
		vTaskDelay(pdMS_TO_TICKS(100));
	}
	if (files == sd.number_of_audio_files)
80009b58:	f0 05 18 00 	cp.b	r5,r8
80009b5c:	c0 51       	brne	80009b66 <fsTask+0x23e>
	{
		print_dbg("Number of files coincide.\r\n");
80009b5e:	4a 6c       	lddpc	r12,80009bf4 <fsTask+0x2cc>
80009b60:	f0 1f 00 1f 	mcall	80009bdc <fsTask+0x2b4>
80009b64:	c0 48       	rjmp	80009b6c <fsTask+0x244>
	}
	else
	{
		print_dbg("Number of files does not coincide.\r\n");
80009b66:	4b 3c       	lddpc	r12,80009c30 <fsTask+0x308>
80009b68:	f0 1f 00 1d 	mcall	80009bdc <fsTask+0x2b4>
		
		nav_checkdisk_enable();
	}
#endif

	print_dbg("DONE");
80009b6c:	4b 2c       	lddpc	r12,80009c34 <fsTask+0x30c>
80009b6e:	f0 1f 00 1c 	mcall	80009bdc <fsTask+0x2b4>
	nav_exit();	// FS Closed
80009b72:	f0 1f 00 32 	mcall	80009c38 <fsTask+0x310>
	

	xTaskCreate(qtButtonTask,  "tQT",        256,  (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
80009b76:	4b 28       	lddpc	r8,80009c3c <fsTask+0x314>
80009b78:	1a d8       	st.w	--sp,r8
80009b7a:	30 28       	mov	r8,2
80009b7c:	30 09       	mov	r9,0
80009b7e:	e0 6a 01 00 	mov	r10,256
80009b82:	4b 0b       	lddpc	r11,80009c40 <fsTask+0x318>
80009b84:	4b 0c       	lddpc	r12,80009c44 <fsTask+0x31c>
80009b86:	f0 1f 00 31 	mcall	80009c48 <fsTask+0x320>
	xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
80009b8a:	4b 18       	lddpc	r8,80009c4c <fsTask+0x324>
80009b8c:	1a d8       	st.w	--sp,r8
80009b8e:	30 18       	mov	r8,1
80009b90:	30 09       	mov	r9,0
80009b92:	e0 6a 08 00 	mov	r10,2048
80009b96:	4a fb       	lddpc	r11,80009c50 <fsTask+0x328>
80009b98:	4a fc       	lddpc	r12,80009c54 <fsTask+0x32c>
80009b9a:	f0 1f 00 2c 	mcall	80009c48 <fsTask+0x320>
	xTaskCreate(etTask,		   "tET",		 512,  (void *) 0, mainLED_TASK_PRIORITY, &etHandle);
80009b9e:	4a f8       	lddpc	r8,80009c58 <fsTask+0x330>
80009ba0:	1a d8       	st.w	--sp,r8
80009ba2:	30 18       	mov	r8,1
80009ba4:	30 09       	mov	r9,0
80009ba6:	e0 6a 02 00 	mov	r10,512
80009baa:	4a db       	lddpc	r11,80009c5c <fsTask+0x334>
80009bac:	4a dc       	lddpc	r12,80009c60 <fsTask+0x338>
80009bae:	f0 1f 00 27 	mcall	80009c48 <fsTask+0x320>
	
	vTaskDelete(sdramHandle);
80009bb2:	4a d8       	lddpc	r8,80009c64 <fsTask+0x33c>
80009bb4:	70 0c       	ld.w	r12,r8[0x0]
80009bb6:	f0 1f 00 2d 	mcall	80009c68 <fsTask+0x340>
	vTaskDelete(NULL);
80009bba:	30 0c       	mov	r12,0
80009bbc:	f0 1f 00 2b 	mcall	80009c68 <fsTask+0x340>
80009bc0:	2f dd       	sub	sp,-12
	
}
80009bc2:	2f 9d       	sub	sp,-28
80009bc4:	d8 32       	popm	r0-r7,pc
80009bc6:	00 00       	add	r0,r0
80009bc8:	80 00       	ld.sh	r0,r0[0x0]
80009bca:	7a b8       	ld.w	r8,sp[0x2c]
80009bcc:	00 00       	add	r0,r0
80009bce:	16 a4       	st.w	r11++,r4
80009bd0:	80 00       	ld.sh	r0,r0[0x0]
80009bd2:	65 a8       	ld.w	r8,r2[0x68]
80009bd4:	80 00       	ld.sh	r0,r0[0x0]
80009bd6:	68 14       	ld.w	r4,r4[0x4]
80009bd8:	80 01       	ld.sh	r1,r0[0x0]
80009bda:	52 0c       	stdsp	sp[0x80],r12
80009bdc:	80 00       	ld.sh	r0,r0[0x0]
80009bde:	6f 6c       	ld.w	r12,r7[0x58]
80009be0:	00 00       	add	r0,r0
80009be2:	0f 20       	ld.uh	r0,r7++
80009be4:	80 01       	ld.sh	r1,r0[0x0]
80009be6:	51 f0       	stdsp	sp[0x7c],r0
80009be8:	80 00       	ld.sh	r0,r0[0x0]
80009bea:	64 40       	ld.w	r0,r2[0x10]
80009bec:	80 00       	ld.sh	r0,r0[0x0]
80009bee:	64 30       	ld.w	r0,r2[0xc]
80009bf0:	80 00       	ld.sh	r0,r0[0x0]
80009bf2:	84 58       	ld.sh	r8,r2[0xa]
80009bf4:	80 01       	ld.sh	r1,r0[0x0]
80009bf6:	52 18       	stdsp	sp[0x84],r8
80009bf8:	80 01       	ld.sh	r1,r0[0x0]
80009bfa:	52 34       	stdsp	sp[0x8c],r4
80009bfc:	80 00       	ld.sh	r0,r0[0x0]
80009bfe:	6b b0       	ld.w	r0,r5[0x6c]
80009c00:	80 00       	ld.sh	r0,r0[0x0]
80009c02:	6a 24       	ld.w	r4,r5[0x8]
80009c04:	80 00       	ld.sh	r0,r0[0x0]
80009c06:	6b 20       	ld.w	r0,r5[0x48]
80009c08:	00 00       	add	r0,r0
80009c0a:	06 fc       	st.b	--r3,r12
80009c0c:	80 00       	ld.sh	r0,r0[0x0]
80009c0e:	6a 9c       	ld.w	r12,r5[0x24]
80009c10:	80 00       	ld.sh	r0,r0[0x0]
80009c12:	6d f8       	ld.w	r8,r6[0x7c]
80009c14:	80 00       	ld.sh	r0,r0[0x0]
80009c16:	6b d0       	ld.w	r0,r5[0x74]
80009c18:	80 00       	ld.sh	r0,r0[0x0]
80009c1a:	ab a8       	sbr	r8,0xa
80009c1c:	80 00       	ld.sh	r0,r0[0x0]
80009c1e:	6b c4       	ld.w	r4,r5[0x70]
80009c20:	80 01       	ld.sh	r1,r0[0x0]
80009c22:	52 38       	stdsp	sp[0x8c],r8
80009c24:	80 00       	ld.sh	r0,r0[0x0]
80009c26:	6f 58       	ld.w	r8,r7[0x54]
80009c28:	00 00       	add	r0,r0
80009c2a:	0a e4       	st.h	--r5,r4
80009c2c:	80 01       	ld.sh	r1,r0[0x0]
80009c2e:	52 3c       	stdsp	sp[0x8c],r12
80009c30:	80 01       	ld.sh	r1,r0[0x0]
80009c32:	52 4c       	stdsp	sp[0x90],r12
80009c34:	80 01       	ld.sh	r1,r0[0x0]
80009c36:	52 74       	stdsp	sp[0x9c],r4
80009c38:	80 00       	ld.sh	r0,r0[0x0]
80009c3a:	69 90       	ld.w	r0,r4[0x64]
80009c3c:	00 00       	add	r0,r0
80009c3e:	06 e4       	st.h	--r3,r4
80009c40:	80 01       	ld.sh	r1,r0[0x0]
80009c42:	52 7c       	stdsp	sp[0x9c],r12
80009c44:	80 00       	ld.sh	r0,r0[0x0]
80009c46:	95 64       	st.w	r10[0x18],r4
80009c48:	80 00       	ld.sh	r0,r0[0x0]
80009c4a:	85 dc       	st.w	r2[0x34],r12
80009c4c:	00 00       	add	r0,r0
80009c4e:	0a f0       	st.b	--r5,r0
80009c50:	80 01       	ld.sh	r1,r0[0x0]
80009c52:	52 80       	stdsp	sp[0xa0],r0
80009c54:	80 00       	ld.sh	r0,r0[0x0]
80009c56:	93 d8       	st.w	r9[0x34],r8
80009c58:	00 00       	add	r0,r0
80009c5a:	06 f8       	st.b	--r3,r8
80009c5c:	80 01       	ld.sh	r1,r0[0x0]
80009c5e:	52 8c       	stdsp	sp[0xa0],r12
80009c60:	80 00       	ld.sh	r0,r0[0x0]
80009c62:	8e c4       	ld.uh	r4,r7[0x8]
80009c64:	00 00       	add	r0,r0
80009c66:	0a ec       	st.h	--r5,r12
80009c68:	80 00       	ld.sh	r0,r0[0x0]
80009c6a:	85 34       	st.w	r2[0xc],r4

80009c6c <LED_On>:
  }
}


void LED_On(uint32_t leds)
{
80009c6c:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80009c6e:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);
80009c72:	49 48       	lddpc	r8,80009cc0 <LED_On+0x54>
80009c74:	70 09       	ld.w	r9,r8[0x0]
80009c76:	f9 e9 10 09 	or	r9,r12,r9
80009c7a:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80009c7c:	58 0c       	cp.w	r12,0
80009c7e:	c1 f0       	breq	80009cbc <LED_On+0x50>
80009c80:	49 18       	lddpc	r8,80009cc4 <LED_On+0x58>
80009c82:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it on.
    led_shift = 1 + ctz(leds);
80009c84:	32 1e       	mov	lr,33
80009c86:	58 0c       	cp.w	r12,0
80009c88:	c0 31       	brne	80009c8e <LED_On+0x22>
80009c8a:	1c 9a       	mov	r10,lr
80009c8c:	c0 68       	rjmp	80009c98 <LED_On+0x2c>
80009c8e:	18 9a       	mov	r10,r12
80009c90:	5c 9a       	brev	r10
80009c92:	f4 0a 12 00 	clz	r10,r10
80009c96:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80009c98:	f4 09 15 04 	lsl	r9,r10,0x4
80009c9c:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80009c9e:	70 09       	ld.w	r9,r8[0x0]
80009ca0:	a9 69       	lsl	r9,0x8
80009ca2:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrc  = led_descriptor->GPIO.PIN_MASK;
80009ca6:	70 1b       	ld.w	r11,r8[0x4]
80009ca8:	f3 4b 00 58 	st.w	r9[88],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80009cac:	70 1b       	ld.w	r11,r8[0x4]
80009cae:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80009cb2:	70 1b       	ld.w	r11,r8[0x4]
80009cb4:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80009cb6:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80009cba:	ce 61       	brne	80009c86 <LED_On+0x1a>
80009cbc:	d8 02       	popm	pc
80009cbe:	00 00       	add	r0,r0
80009cc0:	00 00       	add	r0,r0
80009cc2:	00 30       	cp.w	r0,r0
80009cc4:	80 01       	ld.sh	r1,r0[0x0]
80009cc6:	52 90       	stdsp	sp[0xa4],r0

80009cc8 <LED_Off>:
  return Tst_bits(LED_State, leds);
}


void LED_Off(uint32_t leds)
{
80009cc8:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80009cca:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);
80009cce:	49 58       	lddpc	r8,80009d20 <LED_Off+0x58>
80009cd0:	70 09       	ld.w	r9,r8[0x0]
80009cd2:	f8 0a 11 ff 	rsub	r10,r12,-1
80009cd6:	f5 e9 00 09 	and	r9,r10,r9
80009cda:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80009cdc:	58 0c       	cp.w	r12,0
80009cde:	c1 f0       	breq	80009d1c <LED_Off+0x54>
80009ce0:	49 18       	lddpc	r8,80009d24 <LED_Off+0x5c>
80009ce2:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it off.
    led_shift = 1 + ctz(leds);
80009ce4:	32 1e       	mov	lr,33
80009ce6:	58 0c       	cp.w	r12,0
80009ce8:	c0 31       	brne	80009cee <LED_Off+0x26>
80009cea:	1c 9a       	mov	r10,lr
80009cec:	c0 68       	rjmp	80009cf8 <LED_Off+0x30>
80009cee:	18 9a       	mov	r10,r12
80009cf0:	5c 9a       	brev	r10
80009cf2:	f4 0a 12 00 	clz	r10,r10
80009cf6:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80009cf8:	f4 09 15 04 	lsl	r9,r10,0x4
80009cfc:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80009cfe:	70 09       	ld.w	r9,r8[0x0]
80009d00:	a9 69       	lsl	r9,0x8
80009d02:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
80009d06:	70 1b       	ld.w	r11,r8[0x4]
80009d08:	f3 4b 00 54 	st.w	r9[84],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80009d0c:	70 1b       	ld.w	r11,r8[0x4]
80009d0e:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80009d12:	70 1b       	ld.w	r11,r8[0x4]
80009d14:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80009d16:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80009d1a:	ce 61       	brne	80009ce6 <LED_Off+0x1e>
80009d1c:	d8 02       	popm	pc
80009d1e:	00 00       	add	r0,r0
80009d20:	00 00       	add	r0,r0
80009d22:	00 30       	cp.w	r0,r0
80009d24:	80 01       	ld.sh	r1,r0[0x0]
80009d26:	52 90       	stdsp	sp[0xa4],r0

80009d28 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80009d28:	fe 68 14 00 	mov	r8,-125952
80009d2c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80009d2e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80009d32:	91 09       	st.w	r8[0x0],r9
}
80009d34:	5e fc       	retal	r12

80009d36 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009d36:	f8 08 16 05 	lsr	r8,r12,0x5
80009d3a:	a9 68       	lsl	r8,0x8
80009d3c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80009d40:	58 1b       	cp.w	r11,1
80009d42:	c0 d0       	breq	80009d5c <gpio_enable_module_pin+0x26>
80009d44:	c0 63       	brcs	80009d50 <gpio_enable_module_pin+0x1a>
80009d46:	58 2b       	cp.w	r11,2
80009d48:	c1 00       	breq	80009d68 <gpio_enable_module_pin+0x32>
80009d4a:	58 3b       	cp.w	r11,3
80009d4c:	c1 40       	breq	80009d74 <gpio_enable_module_pin+0x3e>
80009d4e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009d50:	30 19       	mov	r9,1
80009d52:	f2 0c 09 49 	lsl	r9,r9,r12
80009d56:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009d58:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009d5a:	c1 28       	rjmp	80009d7e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009d5c:	30 19       	mov	r9,1
80009d5e:	f2 0c 09 49 	lsl	r9,r9,r12
80009d62:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009d64:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009d66:	c0 c8       	rjmp	80009d7e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009d68:	30 19       	mov	r9,1
80009d6a:	f2 0c 09 49 	lsl	r9,r9,r12
80009d6e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009d70:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009d72:	c0 68       	rjmp	80009d7e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009d74:	30 19       	mov	r9,1
80009d76:	f2 0c 09 49 	lsl	r9,r9,r12
80009d7a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009d7c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80009d7e:	30 19       	mov	r9,1
80009d80:	f2 0c 09 4c 	lsl	r12,r9,r12
80009d84:	91 2c       	st.w	r8[0x8],r12
80009d86:	5e fd       	retal	0

80009d88 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80009d88:	d4 21       	pushm	r4-r7,lr
80009d8a:	18 97       	mov	r7,r12
80009d8c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009d8e:	58 0b       	cp.w	r11,0
80009d90:	c0 31       	brne	80009d96 <gpio_enable_module+0xe>
80009d92:	30 05       	mov	r5,0
80009d94:	c0 d8       	rjmp	80009dae <gpio_enable_module+0x26>
80009d96:	30 06       	mov	r6,0
80009d98:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80009d9a:	6e 1b       	ld.w	r11,r7[0x4]
80009d9c:	6e 0c       	ld.w	r12,r7[0x0]
80009d9e:	f0 1f 00 06 	mcall	80009db4 <gpio_enable_module+0x2c>
80009da2:	18 45       	or	r5,r12
		gpiomap++;
80009da4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009da6:	2f f6       	sub	r6,-1
80009da8:	0c 34       	cp.w	r4,r6
80009daa:	fe 9b ff f8 	brhi	80009d9a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80009dae:	0a 9c       	mov	r12,r5
80009db0:	d8 22       	popm	r4-r7,pc
80009db2:	00 00       	add	r0,r0
80009db4:	80 00       	ld.sh	r0,r0[0x0]
80009db6:	9d 36       	st.w	lr[0xc],r6

80009db8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009db8:	f8 08 16 05 	lsr	r8,r12,0x5
80009dbc:	a9 68       	lsl	r8,0x8
80009dbe:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80009dc2:	30 19       	mov	r9,1
80009dc4:	f2 0c 09 4c 	lsl	r12,r9,r12
80009dc8:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80009dcc:	91 1c       	st.w	r8[0x4],r12
}
80009dce:	5e fc       	retal	r12

80009dd0 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
80009dd0:	eb cd 40 e0 	pushm	r5-r7,lr
80009dd4:	18 97       	mov	r7,r12
80009dd6:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
80009dd8:	58 0b       	cp.w	r11,0
80009dda:	c0 a0       	breq	80009dee <gpio_enable_gpio+0x1e>
80009ddc:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
80009dde:	6e 0c       	ld.w	r12,r7[0x0]
80009de0:	f0 1f 00 05 	mcall	80009df4 <gpio_enable_gpio+0x24>
		gpiomap++;
80009de4:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
80009de6:	2f f5       	sub	r5,-1
80009de8:	0a 36       	cp.w	r6,r5
80009dea:	fe 9b ff fa 	brhi	80009dde <gpio_enable_gpio+0xe>
80009dee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009df2:	00 00       	add	r0,r0
80009df4:	80 00       	ld.sh	r0,r0[0x0]
80009df6:	9d b8       	st.w	lr[0x2c],r8

80009df8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009df8:	f8 08 16 05 	lsr	r8,r12,0x5
80009dfc:	a9 68       	lsl	r8,0x8
80009dfe:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80009e02:	30 19       	mov	r9,1
80009e04:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e08:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80009e0c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009e10:	91 1c       	st.w	r8[0x4],r12
}
80009e12:	5e fc       	retal	r12

80009e14 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009e14:	f8 08 16 05 	lsr	r8,r12,0x5
80009e18:	a9 68       	lsl	r8,0x8
80009e1a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80009e1e:	30 19       	mov	r9,1
80009e20:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e24:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80009e28:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009e2c:	91 1c       	st.w	r8[0x4],r12
}
80009e2e:	5e fc       	retal	r12

80009e30 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009e30:	f8 08 16 05 	lsr	r8,r12,0x5
80009e34:	a9 68       	lsl	r8,0x8
80009e36:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80009e3a:	30 19       	mov	r9,1
80009e3c:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e40:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80009e44:	12 3b       	cp.w	r11,r9
80009e46:	c0 a0       	breq	80009e5a <gpio_enable_pin_interrupt+0x2a>
80009e48:	c0 43       	brcs	80009e50 <gpio_enable_pin_interrupt+0x20>
80009e4a:	58 2b       	cp.w	r11,2
80009e4c:	c1 11       	brne	80009e6e <gpio_enable_pin_interrupt+0x3e>
80009e4e:	c0 b8       	rjmp	80009e64 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80009e50:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80009e54:	f1 4c 00 b8 	st.w	r8[184],r12
80009e58:	c0 c8       	rjmp	80009e70 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80009e5a:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80009e5e:	f1 4c 00 b8 	st.w	r8[184],r12
80009e62:	c0 78       	rjmp	80009e70 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80009e64:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
80009e68:	f1 4c 00 b4 	st.w	r8[180],r12
80009e6c:	c0 28       	rjmp	80009e70 <gpio_enable_pin_interrupt+0x40>
80009e6e:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80009e70:	f1 4c 00 94 	st.w	r8[148],r12
80009e74:	5e fd       	retal	0

80009e76 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009e76:	f8 08 16 05 	lsr	r8,r12,0x5
80009e7a:	a9 68       	lsl	r8,0x8
80009e7c:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80009e80:	f0 f8 00 d0 	ld.w	r8,r8[208]
80009e84:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80009e88:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80009e8c:	5e fc       	retal	r12

80009e8e <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009e8e:	f8 08 16 05 	lsr	r8,r12,0x5
80009e92:	a9 68       	lsl	r8,0x8
80009e94:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80009e98:	30 19       	mov	r9,1
80009e9a:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e9e:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
80009ea2:	5e fc       	retal	r12

80009ea4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80009ea4:	c0 08       	rjmp	80009ea4 <_unhandled_interrupt>
80009ea6:	d7 03       	nop

80009ea8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80009ea8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80009eac:	49 99       	lddpc	r9,80009f10 <INTC_register_interrupt+0x68>
80009eae:	f2 08 00 39 	add	r9,r9,r8<<0x3
80009eb2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80009eb6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80009eb8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80009ebc:	58 0a       	cp.w	r10,0
80009ebe:	c0 91       	brne	80009ed0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80009ec0:	49 59       	lddpc	r9,80009f14 <INTC_register_interrupt+0x6c>
80009ec2:	49 6a       	lddpc	r10,80009f18 <INTC_register_interrupt+0x70>
80009ec4:	12 1a       	sub	r10,r9
80009ec6:	fe 79 08 00 	mov	r9,-63488
80009eca:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80009ece:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80009ed0:	58 1a       	cp.w	r10,1
80009ed2:	c0 a1       	brne	80009ee6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80009ed4:	49 09       	lddpc	r9,80009f14 <INTC_register_interrupt+0x6c>
80009ed6:	49 2a       	lddpc	r10,80009f1c <INTC_register_interrupt+0x74>
80009ed8:	12 1a       	sub	r10,r9
80009eda:	bf aa       	sbr	r10,0x1e
80009edc:	fe 79 08 00 	mov	r9,-63488
80009ee0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80009ee4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80009ee6:	58 2a       	cp.w	r10,2
80009ee8:	c0 a1       	brne	80009efc <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80009eea:	48 b9       	lddpc	r9,80009f14 <INTC_register_interrupt+0x6c>
80009eec:	48 da       	lddpc	r10,80009f20 <INTC_register_interrupt+0x78>
80009eee:	12 1a       	sub	r10,r9
80009ef0:	bf ba       	sbr	r10,0x1f
80009ef2:	fe 79 08 00 	mov	r9,-63488
80009ef6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80009efa:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80009efc:	48 69       	lddpc	r9,80009f14 <INTC_register_interrupt+0x6c>
80009efe:	48 aa       	lddpc	r10,80009f24 <INTC_register_interrupt+0x7c>
80009f00:	12 1a       	sub	r10,r9
80009f02:	ea 1a c0 00 	orh	r10,0xc000
80009f06:	fe 79 08 00 	mov	r9,-63488
80009f0a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80009f0e:	5e fc       	retal	r12
80009f10:	80 01       	ld.sh	r1,r0[0x0]
80009f12:	52 d0       	stdsp	sp[0xb4],r0
80009f14:	80 00       	ld.sh	r0,r0[0x0]
80009f16:	b0 00       	st.h	r8[0x0],r0
80009f18:	80 00       	ld.sh	r0,r0[0x0]
80009f1a:	b1 04       	ld.d	r4,r8
80009f1c:	80 00       	ld.sh	r0,r0[0x0]
80009f1e:	b1 12       	ld.d	r2,--r8
80009f20:	80 00       	ld.sh	r0,r0[0x0]
80009f22:	b1 20       	st.d	r8++,r0
80009f24:	80 00       	ld.sh	r0,r0[0x0]
80009f26:	b1 2e       	st.d	r8++,lr

80009f28 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80009f28:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80009f2a:	49 18       	lddpc	r8,80009f6c <INTC_init_interrupts+0x44>
80009f2c:	e3 b8 00 01 	mtsr	0x4,r8
80009f30:	49 0e       	lddpc	lr,80009f70 <INTC_init_interrupts+0x48>
80009f32:	30 07       	mov	r7,0
80009f34:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80009f36:	49 0c       	lddpc	r12,80009f74 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80009f38:	49 05       	lddpc	r5,80009f78 <INTC_init_interrupts+0x50>
80009f3a:	10 15       	sub	r5,r8
80009f3c:	fe 76 08 00 	mov	r6,-63488
80009f40:	c1 08       	rjmp	80009f60 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80009f42:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80009f44:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80009f46:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80009f48:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80009f4c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80009f4e:	10 3a       	cp.w	r10,r8
80009f50:	fe 9b ff fc 	brhi	80009f48 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80009f54:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80009f58:	2f f7       	sub	r7,-1
80009f5a:	2f 8e       	sub	lr,-8
80009f5c:	59 47       	cp.w	r7,20
80009f5e:	c0 50       	breq	80009f68 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80009f60:	7c 08       	ld.w	r8,lr[0x0]
80009f62:	58 08       	cp.w	r8,0
80009f64:	ce f1       	brne	80009f42 <INTC_init_interrupts+0x1a>
80009f66:	cf 7b       	rjmp	80009f54 <INTC_init_interrupts+0x2c>
80009f68:	d8 22       	popm	r4-r7,pc
80009f6a:	00 00       	add	r0,r0
80009f6c:	80 00       	ld.sh	r0,r0[0x0]
80009f6e:	b0 00       	st.h	r8[0x0],r0
80009f70:	80 01       	ld.sh	r1,r0[0x0]
80009f72:	52 d0       	stdsp	sp[0xb4],r0
80009f74:	80 00       	ld.sh	r0,r0[0x0]
80009f76:	9e a4       	ld.uh	r4,pc[0x4]
80009f78:	80 00       	ld.sh	r0,r0[0x0]
80009f7a:	b1 04       	ld.d	r4,r8

80009f7c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80009f7c:	fe 78 08 00 	mov	r8,-63488
80009f80:	e0 69 00 83 	mov	r9,131
80009f84:	f2 0c 01 0c 	sub	r12,r9,r12
80009f88:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80009f8c:	f2 ca ff c0 	sub	r10,r9,-64
80009f90:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80009f94:	58 08       	cp.w	r8,0
80009f96:	c0 21       	brne	80009f9a <_get_interrupt_handler+0x1e>
80009f98:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
80009f9a:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80009f9e:	48 5a       	lddpc	r10,80009fb0 <_get_interrupt_handler+0x34>
80009fa0:	f4 09 00 39 	add	r9,r10,r9<<0x3
80009fa4:	f0 08 11 1f 	rsub	r8,r8,31
80009fa8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80009faa:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80009fae:	5e fc       	retal	r12
80009fb0:	80 01       	ld.sh	r1,r0[0x0]
80009fb2:	52 d0       	stdsp	sp[0xb4],r0

80009fb4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80009fb4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80009fb6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80009fba:	99 a8       	st.w	r12[0x28],r8
}
80009fbc:	5e fc       	retal	r12
80009fbe:	d7 03       	nop

80009fc0 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80009fc0:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80009fc2:	ec 5b bb 9f 	cp.w	r11,899999
80009fc6:	e0 8b 00 04 	brhi	80009fce <pm_enable_osc0_crystal+0xe>
80009fca:	30 4b       	mov	r11,4
80009fcc:	c1 38       	rjmp	80009ff2 <pm_enable_osc0_crystal+0x32>
80009fce:	e0 68 c6 bf 	mov	r8,50879
80009fd2:	ea 18 00 2d 	orh	r8,0x2d
80009fd6:	10 3b       	cp.w	r11,r8
80009fd8:	e0 8b 00 04 	brhi	80009fe0 <pm_enable_osc0_crystal+0x20>
80009fdc:	30 5b       	mov	r11,5
80009fde:	c0 a8       	rjmp	80009ff2 <pm_enable_osc0_crystal+0x32>
80009fe0:	e0 68 12 00 	mov	r8,4608
80009fe4:	ea 18 00 7a 	orh	r8,0x7a
80009fe8:	10 3b       	cp.w	r11,r8
80009fea:	f9 bb 03 06 	movlo	r11,6
80009fee:	f9 bb 02 07 	movhs	r11,7
80009ff2:	f0 1f 00 02 	mcall	80009ff8 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80009ff6:	d8 02       	popm	pc
80009ff8:	80 00       	ld.sh	r0,r0[0x0]
80009ffa:	9f b4       	st.w	pc[0x2c],r4

80009ffc <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80009ffc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80009ffe:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000a002:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000a004:	78 08       	ld.w	r8,r12[0x0]
8000a006:	a3 a8       	sbr	r8,0x2
8000a008:	99 08       	st.w	r12[0x0],r8
}
8000a00a:	5e fc       	retal	r12

8000a00c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000a00c:	79 58       	ld.w	r8,r12[0x54]
8000a00e:	e2 18 00 80 	andl	r8,0x80,COH
8000a012:	cf d0       	breq	8000a00c <pm_wait_for_clk0_ready>
}
8000a014:	5e fc       	retal	r12
8000a016:	d7 03       	nop

8000a018 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000a018:	eb cd 40 80 	pushm	r7,lr
8000a01c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000a01e:	f0 1f 00 04 	mcall	8000a02c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000a022:	0e 9c       	mov	r12,r7
8000a024:	f0 1f 00 03 	mcall	8000a030 <pm_enable_clk0+0x18>
}
8000a028:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a02c:	80 00       	ld.sh	r0,r0[0x0]
8000a02e:	9f fc       	st.w	pc[0x3c],r12
8000a030:	80 00       	ld.sh	r0,r0[0x0]
8000a032:	a0 0c       	st.h	r0[0x0],r12

8000a034 <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
8000a034:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
8000a036:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
8000a03a:	99 b8       	st.w	r12[0x2c],r8
}
8000a03c:	5e fc       	retal	r12
8000a03e:	d7 03       	nop

8000a040 <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
8000a040:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
8000a042:	ec 5b bb 9f 	cp.w	r11,899999
8000a046:	e0 8b 00 04 	brhi	8000a04e <pm_enable_osc1_crystal+0xe>
8000a04a:	30 4b       	mov	r11,4
8000a04c:	c1 38       	rjmp	8000a072 <pm_enable_osc1_crystal+0x32>
8000a04e:	e0 68 c6 bf 	mov	r8,50879
8000a052:	ea 18 00 2d 	orh	r8,0x2d
8000a056:	10 3b       	cp.w	r11,r8
8000a058:	e0 8b 00 04 	brhi	8000a060 <pm_enable_osc1_crystal+0x20>
8000a05c:	30 5b       	mov	r11,5
8000a05e:	c0 a8       	rjmp	8000a072 <pm_enable_osc1_crystal+0x32>
8000a060:	e0 68 12 00 	mov	r8,4608
8000a064:	ea 18 00 7a 	orh	r8,0x7a
8000a068:	10 3b       	cp.w	r11,r8
8000a06a:	f9 bb 03 06 	movlo	r11,6
8000a06e:	f9 bb 02 07 	movhs	r11,7
8000a072:	f0 1f 00 02 	mcall	8000a078 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
8000a076:	d8 02       	popm	pc
8000a078:	80 00       	ld.sh	r0,r0[0x0]
8000a07a:	a0 34       	st.h	r0[0x6],r4

8000a07c <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
8000a07c:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
8000a07e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
8000a082:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
8000a084:	78 08       	ld.w	r8,r12[0x0]
8000a086:	a3 b8       	sbr	r8,0x3
8000a088:	99 08       	st.w	r12[0x0],r8
}
8000a08a:	5e fc       	retal	r12

8000a08c <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
8000a08c:	79 58       	ld.w	r8,r12[0x54]
8000a08e:	e2 18 01 00 	andl	r8,0x100,COH
8000a092:	cf d0       	breq	8000a08c <pm_wait_for_clk1_ready>
}
8000a094:	5e fc       	retal	r12
8000a096:	d7 03       	nop

8000a098 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
8000a098:	eb cd 40 80 	pushm	r7,lr
8000a09c:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
8000a09e:	f0 1f 00 04 	mcall	8000a0ac <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
8000a0a2:	0e 9c       	mov	r12,r7
8000a0a4:	f0 1f 00 03 	mcall	8000a0b0 <pm_enable_clk1+0x18>
}
8000a0a8:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a0ac:	80 00       	ld.sh	r0,r0[0x0]
8000a0ae:	a0 7c       	st.h	r0[0xe],r12
8000a0b0:	80 00       	ld.sh	r0,r0[0x0]
8000a0b2:	a0 8c       	st.b	r0[0x0],r12

8000a0b4 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000a0b4:	eb cd 40 d0 	pushm	r4,r6-r7,lr
8000a0b8:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
8000a0bc:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000a0be:	09 f7       	ld.ub	r7,r4[0x7]
8000a0c0:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000a0c4:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000a0c8:	09 b4       	ld.ub	r4,r4[0x3]
8000a0ca:	08 96       	mov	r6,r4
8000a0cc:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000a0d0:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000a0d4:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
8000a0d8:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
8000a0dc:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000a0e0:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000a0e4:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
8000a0e8:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
8000a0ec:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000a0ee:	79 58       	ld.w	r8,r12[0x54]
8000a0f0:	e2 18 00 20 	andl	r8,0x20,COH
8000a0f4:	cf d0       	breq	8000a0ee <pm_cksel+0x3a>
}
8000a0f6:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000a0fa <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000a0fa:	eb cd 40 80 	pushm	r7,lr
8000a0fe:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000a100:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000a102:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000a106:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000a10a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000a10e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000a112:	2f 8b       	sub	r11,-8
8000a114:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000a118:	e3 cd 80 80 	ldm	sp++,r7,pc

8000a11c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000a11c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000a11e:	2f 8b       	sub	r11,-8
8000a120:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000a124:	f5 e9 10 19 	or	r9,r10,r9<<0x1
8000a128:	f3 e8 10 28 	or	r8,r9,r8<<0x2
8000a12c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000a130:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000a134:	d8 02       	popm	pc

8000a136 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000a136:	2f 8b       	sub	r11,-8
8000a138:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
8000a13c:	a1 a8       	sbr	r8,0x0
8000a13e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000a142:	5e fc       	retal	r12

8000a144 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000a144:	79 58       	ld.w	r8,r12[0x54]
8000a146:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a14a:	cf d0       	breq	8000a144 <pm_wait_for_pll0_locked>
}
8000a14c:	5e fc       	retal	r12

8000a14e <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
8000a14e:	79 58       	ld.w	r8,r12[0x54]
8000a150:	e2 18 00 02 	andl	r8,0x2,COH
8000a154:	cf d0       	breq	8000a14e <pm_wait_for_pll1_locked>
}
8000a156:	5e fc       	retal	r12

8000a158 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000a158:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000a15a:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000a15e:	99 08       	st.w	r12[0x0],r8
}
8000a160:	5e fc       	retal	r12
8000a162:	d7 03       	nop

8000a164 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
8000a164:	eb cd 40 c0 	pushm	r6-r7,lr
8000a168:	18 97       	mov	r7,r12
8000a16a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000a16c:	f0 1f 00 06 	mcall	8000a184 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000a170:	0c 9b       	mov	r11,r6
8000a172:	0e 9c       	mov	r12,r7
8000a174:	f0 1f 00 05 	mcall	8000a188 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
8000a178:	30 1b       	mov	r11,1
8000a17a:	0e 9c       	mov	r12,r7
8000a17c:	f0 1f 00 04 	mcall	8000a18c <pm_switch_to_osc0+0x28>
}
8000a180:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a184:	80 00       	ld.sh	r0,r0[0x0]
8000a186:	9f c0       	st.w	pc[0x30],r0
8000a188:	80 00       	ld.sh	r0,r0[0x0]
8000a18a:	a0 18       	st.h	r0[0x2],r8
8000a18c:	80 00       	ld.sh	r0,r0[0x0]
8000a18e:	a1 58       	asr	r8,0x1

8000a190 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000a190:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000a192:	f6 08 15 04 	lsl	r8,r11,0x4
8000a196:	14 38       	cp.w	r8,r10
8000a198:	f9 b8 08 10 	movls	r8,16
8000a19c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000a1a0:	f0 0b 02 4b 	mul	r11,r8,r11
8000a1a4:	f6 09 16 01 	lsr	r9,r11,0x1
8000a1a8:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000a1ac:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000a1b0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000a1b4:	f2 cb 00 01 	sub	r11,r9,1
8000a1b8:	e0 4b ff fe 	cp.w	r11,65534
8000a1bc:	e0 88 00 03 	brls	8000a1c2 <usart_set_async_baudrate+0x32>
8000a1c0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000a1c2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000a1c4:	e8 6e 00 00 	mov	lr,524288
8000a1c8:	59 08       	cp.w	r8,16
8000a1ca:	fc 08 17 10 	movne	r8,lr
8000a1ce:	f9 b8 00 00 	moveq	r8,0
8000a1d2:	e4 1b ff f7 	andh	r11,0xfff7
8000a1d6:	e0 1b fe cf 	andl	r11,0xfecf
8000a1da:	16 48       	or	r8,r11
8000a1dc:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000a1de:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000a1e2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000a1e6:	99 89       	st.w	r12[0x20],r9
8000a1e8:	d8 0a       	popm	pc,r12=0

8000a1ea <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000a1ea:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000a1ec:	e2 18 00 02 	andl	r8,0x2,COH
8000a1f0:	c0 31       	brne	8000a1f6 <usart_write_char+0xc>
8000a1f2:	30 2c       	mov	r12,2
8000a1f4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000a1f6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000a1fa:	99 7b       	st.w	r12[0x1c],r11
8000a1fc:	5e fd       	retal	0
8000a1fe:	d7 03       	nop

8000a200 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000a200:	eb cd 40 e0 	pushm	r5-r7,lr
8000a204:	18 96       	mov	r6,r12
8000a206:	16 95       	mov	r5,r11
8000a208:	e0 67 27 0f 	mov	r7,9999
8000a20c:	c0 68       	rjmp	8000a218 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000a20e:	58 07       	cp.w	r7,0
8000a210:	c0 31       	brne	8000a216 <usart_putchar+0x16>
8000a212:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000a216:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000a218:	0a 9b       	mov	r11,r5
8000a21a:	0c 9c       	mov	r12,r6
8000a21c:	f0 1f 00 03 	mcall	8000a228 <usart_putchar+0x28>
8000a220:	cf 71       	brne	8000a20e <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000a222:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000a226:	00 00       	add	r0,r0
8000a228:	80 00       	ld.sh	r0,r0[0x0]
8000a22a:	a1 ea       	*unknown*

8000a22c <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000a22c:	eb cd 40 c0 	pushm	r6-r7,lr
8000a230:	18 96       	mov	r6,r12
8000a232:	16 97       	mov	r7,r11
  while (*string != '\0')
8000a234:	17 8b       	ld.ub	r11,r11[0x0]
8000a236:	58 0b       	cp.w	r11,0
8000a238:	c0 80       	breq	8000a248 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000a23a:	2f f7       	sub	r7,-1
8000a23c:	0c 9c       	mov	r12,r6
8000a23e:	f0 1f 00 04 	mcall	8000a24c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000a242:	0f 8b       	ld.ub	r11,r7[0x0]
8000a244:	58 0b       	cp.w	r11,0
8000a246:	cf a1       	brne	8000a23a <usart_write_line+0xe>
8000a248:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a24c:	80 00       	ld.sh	r0,r0[0x0]
8000a24e:	a2 00       	st.h	r1[0x0],r0

8000a250 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000a250:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000a254:	e6 18 00 01 	andh	r8,0x1,COH
8000a258:	c0 71       	brne	8000a266 <usart_reset+0x16>
8000a25a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000a25c:	3f f8       	mov	r8,-1
8000a25e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000a260:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000a262:	d5 03       	csrf	0x10
8000a264:	c0 48       	rjmp	8000a26c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000a266:	3f f8       	mov	r8,-1
8000a268:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000a26a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000a26c:	30 08       	mov	r8,0
8000a26e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000a270:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000a272:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000a274:	ea 68 61 0c 	mov	r8,680204
8000a278:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000a27a:	5e fc       	retal	r12

8000a27c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000a27c:	eb cd 40 e0 	pushm	r5-r7,lr
8000a280:	18 96       	mov	r6,r12
8000a282:	16 97       	mov	r7,r11
8000a284:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000a286:	f0 1f 00 2f 	mcall	8000a340 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000a28a:	58 07       	cp.w	r7,0
8000a28c:	c5 80       	breq	8000a33c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000a28e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000a290:	30 49       	mov	r9,4
8000a292:	f2 08 18 00 	cp.b	r8,r9
8000a296:	e0 88 00 53 	brls	8000a33c <usart_init_rs232+0xc0>
8000a29a:	30 99       	mov	r9,9
8000a29c:	f2 08 18 00 	cp.b	r8,r9
8000a2a0:	e0 8b 00 4e 	brhi	8000a33c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000a2a4:	0f d9       	ld.ub	r9,r7[0x5]
8000a2a6:	30 78       	mov	r8,7
8000a2a8:	f0 09 18 00 	cp.b	r9,r8
8000a2ac:	e0 8b 00 48 	brhi	8000a33c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
8000a2b0:	8e 39       	ld.sh	r9,r7[0x6]
8000a2b2:	e0 68 01 01 	mov	r8,257
8000a2b6:	f0 09 19 00 	cp.h	r9,r8
8000a2ba:	e0 8b 00 41 	brhi	8000a33c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000a2be:	ef 39 00 08 	ld.ub	r9,r7[8]
8000a2c2:	30 38       	mov	r8,3
8000a2c4:	f0 09 18 00 	cp.b	r9,r8
8000a2c8:	e0 8b 00 3a 	brhi	8000a33c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000a2cc:	0a 9a       	mov	r10,r5
8000a2ce:	6e 0b       	ld.w	r11,r7[0x0]
8000a2d0:	0c 9c       	mov	r12,r6
8000a2d2:	f0 1f 00 1d 	mcall	8000a344 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000a2d6:	58 1c       	cp.w	r12,1
8000a2d8:	c3 20       	breq	8000a33c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000a2da:	0f c8       	ld.ub	r8,r7[0x4]
8000a2dc:	30 99       	mov	r9,9
8000a2de:	f2 08 18 00 	cp.b	r8,r9
8000a2e2:	c0 51       	brne	8000a2ec <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000a2e4:	6c 18       	ld.w	r8,r6[0x4]
8000a2e6:	b1 b8       	sbr	r8,0x11
8000a2e8:	8d 18       	st.w	r6[0x4],r8
8000a2ea:	c0 68       	rjmp	8000a2f6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
8000a2ec:	6c 19       	ld.w	r9,r6[0x4]
8000a2ee:	20 58       	sub	r8,5
8000a2f0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000a2f4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000a2f6:	6c 19       	ld.w	r9,r6[0x4]
8000a2f8:	ef 3a 00 08 	ld.ub	r10,r7[8]
8000a2fc:	0f d8       	ld.ub	r8,r7[0x5]
8000a2fe:	a9 78       	lsl	r8,0x9
8000a300:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000a304:	12 48       	or	r8,r9
8000a306:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
8000a308:	8e 38       	ld.sh	r8,r7[0x6]
8000a30a:	30 29       	mov	r9,2
8000a30c:	f2 08 19 00 	cp.h	r8,r9
8000a310:	e0 88 00 09 	brls	8000a322 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000a314:	6c 18       	ld.w	r8,r6[0x4]
8000a316:	ad b8       	sbr	r8,0xd
8000a318:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000a31a:	8e b8       	ld.uh	r8,r7[0x6]
8000a31c:	20 28       	sub	r8,2
8000a31e:	8d a8       	st.w	r6[0x28],r8
8000a320:	c0 68       	rjmp	8000a32c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000a322:	6c 19       	ld.w	r9,r6[0x4]
8000a324:	5c 78       	castu.h	r8
8000a326:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000a32a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000a32c:	6c 18       	ld.w	r8,r6[0x4]
8000a32e:	e0 18 ff f0 	andl	r8,0xfff0
8000a332:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000a334:	35 08       	mov	r8,80
8000a336:	8d 08       	st.w	r6[0x0],r8
8000a338:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000a33c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000a340:	80 00       	ld.sh	r0,r0[0x0]
8000a342:	a2 50       	st.h	r1[0xa],r0
8000a344:	80 00       	ld.sh	r0,r0[0x0]
8000a346:	a1 90       	lsr	r0,0x1

8000a348 <__avr32_udiv64>:
8000a348:	d4 31       	pushm	r0-r7,lr
8000a34a:	1a 97       	mov	r7,sp
8000a34c:	20 3d       	sub	sp,12
8000a34e:	10 9c       	mov	r12,r8
8000a350:	12 9e       	mov	lr,r9
8000a352:	14 93       	mov	r3,r10
8000a354:	58 09       	cp.w	r9,0
8000a356:	e0 81 00 bd 	brne	8000a4d0 <__avr32_udiv64+0x188>
8000a35a:	16 38       	cp.w	r8,r11
8000a35c:	e0 88 00 40 	brls	8000a3dc <__avr32_udiv64+0x94>
8000a360:	f0 08 12 00 	clz	r8,r8
8000a364:	c0 d0       	breq	8000a37e <__avr32_udiv64+0x36>
8000a366:	f6 08 09 4b 	lsl	r11,r11,r8
8000a36a:	f0 09 11 20 	rsub	r9,r8,32
8000a36e:	f8 08 09 4c 	lsl	r12,r12,r8
8000a372:	f4 09 0a 49 	lsr	r9,r10,r9
8000a376:	f4 08 09 43 	lsl	r3,r10,r8
8000a37a:	f3 eb 10 0b 	or	r11,r9,r11
8000a37e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a382:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a386:	f6 0e 0d 00 	divu	r0,r11,lr
8000a38a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000a38e:	00 99       	mov	r9,r0
8000a390:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000a394:	e0 0a 02 48 	mul	r8,r0,r10
8000a398:	10 3b       	cp.w	r11,r8
8000a39a:	c0 a2       	brcc	8000a3ae <__avr32_udiv64+0x66>
8000a39c:	20 19       	sub	r9,1
8000a39e:	18 0b       	add	r11,r12
8000a3a0:	18 3b       	cp.w	r11,r12
8000a3a2:	c0 63       	brcs	8000a3ae <__avr32_udiv64+0x66>
8000a3a4:	10 3b       	cp.w	r11,r8
8000a3a6:	f7 b9 03 01 	sublo	r9,1
8000a3aa:	f7 dc e3 0b 	addcs	r11,r11,r12
8000a3ae:	f6 08 01 01 	sub	r1,r11,r8
8000a3b2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000a3b6:	e2 0e 0d 00 	divu	r0,r1,lr
8000a3ba:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000a3be:	00 98       	mov	r8,r0
8000a3c0:	e0 0a 02 4a 	mul	r10,r0,r10
8000a3c4:	14 33       	cp.w	r3,r10
8000a3c6:	c0 82       	brcc	8000a3d6 <__avr32_udiv64+0x8e>
8000a3c8:	20 18       	sub	r8,1
8000a3ca:	18 03       	add	r3,r12
8000a3cc:	18 33       	cp.w	r3,r12
8000a3ce:	c0 43       	brcs	8000a3d6 <__avr32_udiv64+0x8e>
8000a3d0:	14 33       	cp.w	r3,r10
8000a3d2:	f7 b8 03 01 	sublo	r8,1
8000a3d6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000a3da:	cd f8       	rjmp	8000a598 <__avr32_udiv64+0x250>
8000a3dc:	58 08       	cp.w	r8,0
8000a3de:	c0 51       	brne	8000a3e8 <__avr32_udiv64+0xa0>
8000a3e0:	30 19       	mov	r9,1
8000a3e2:	f2 08 0d 08 	divu	r8,r9,r8
8000a3e6:	10 9c       	mov	r12,r8
8000a3e8:	f8 06 12 00 	clz	r6,r12
8000a3ec:	c0 41       	brne	8000a3f4 <__avr32_udiv64+0xac>
8000a3ee:	18 1b       	sub	r11,r12
8000a3f0:	30 19       	mov	r9,1
8000a3f2:	c4 08       	rjmp	8000a472 <__avr32_udiv64+0x12a>
8000a3f4:	ec 01 11 20 	rsub	r1,r6,32
8000a3f8:	f4 01 0a 49 	lsr	r9,r10,r1
8000a3fc:	f8 06 09 4c 	lsl	r12,r12,r6
8000a400:	f6 06 09 48 	lsl	r8,r11,r6
8000a404:	f6 01 0a 41 	lsr	r1,r11,r1
8000a408:	f3 e8 10 08 	or	r8,r9,r8
8000a40c:	f8 03 16 10 	lsr	r3,r12,0x10
8000a410:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000a414:	e2 03 0d 00 	divu	r0,r1,r3
8000a418:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a41c:	00 9e       	mov	lr,r0
8000a41e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000a422:	e0 05 02 49 	mul	r9,r0,r5
8000a426:	12 3b       	cp.w	r11,r9
8000a428:	c0 a2       	brcc	8000a43c <__avr32_udiv64+0xf4>
8000a42a:	20 1e       	sub	lr,1
8000a42c:	18 0b       	add	r11,r12
8000a42e:	18 3b       	cp.w	r11,r12
8000a430:	c0 63       	brcs	8000a43c <__avr32_udiv64+0xf4>
8000a432:	12 3b       	cp.w	r11,r9
8000a434:	f7 be 03 01 	sublo	lr,1
8000a438:	f7 dc e3 0b 	addcs	r11,r11,r12
8000a43c:	12 1b       	sub	r11,r9
8000a43e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000a442:	f6 03 0d 02 	divu	r2,r11,r3
8000a446:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000a44a:	04 99       	mov	r9,r2
8000a44c:	e4 05 02 4b 	mul	r11,r2,r5
8000a450:	16 38       	cp.w	r8,r11
8000a452:	c0 a2       	brcc	8000a466 <__avr32_udiv64+0x11e>
8000a454:	20 19       	sub	r9,1
8000a456:	18 08       	add	r8,r12
8000a458:	18 38       	cp.w	r8,r12
8000a45a:	c0 63       	brcs	8000a466 <__avr32_udiv64+0x11e>
8000a45c:	16 38       	cp.w	r8,r11
8000a45e:	f7 b9 03 01 	sublo	r9,1
8000a462:	f1 dc e3 08 	addcs	r8,r8,r12
8000a466:	f4 06 09 43 	lsl	r3,r10,r6
8000a46a:	f0 0b 01 0b 	sub	r11,r8,r11
8000a46e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000a472:	f8 06 16 10 	lsr	r6,r12,0x10
8000a476:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000a47a:	f6 06 0d 00 	divu	r0,r11,r6
8000a47e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000a482:	00 9a       	mov	r10,r0
8000a484:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000a488:	e0 0e 02 48 	mul	r8,r0,lr
8000a48c:	10 3b       	cp.w	r11,r8
8000a48e:	c0 a2       	brcc	8000a4a2 <__avr32_udiv64+0x15a>
8000a490:	20 1a       	sub	r10,1
8000a492:	18 0b       	add	r11,r12
8000a494:	18 3b       	cp.w	r11,r12
8000a496:	c0 63       	brcs	8000a4a2 <__avr32_udiv64+0x15a>
8000a498:	10 3b       	cp.w	r11,r8
8000a49a:	f7 ba 03 01 	sublo	r10,1
8000a49e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000a4a2:	f6 08 01 01 	sub	r1,r11,r8
8000a4a6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000a4aa:	e2 06 0d 00 	divu	r0,r1,r6
8000a4ae:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000a4b2:	00 98       	mov	r8,r0
8000a4b4:	e0 0e 02 4b 	mul	r11,r0,lr
8000a4b8:	16 33       	cp.w	r3,r11
8000a4ba:	c0 82       	brcc	8000a4ca <__avr32_udiv64+0x182>
8000a4bc:	20 18       	sub	r8,1
8000a4be:	18 03       	add	r3,r12
8000a4c0:	18 33       	cp.w	r3,r12
8000a4c2:	c0 43       	brcs	8000a4ca <__avr32_udiv64+0x182>
8000a4c4:	16 33       	cp.w	r3,r11
8000a4c6:	f7 b8 03 01 	sublo	r8,1
8000a4ca:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000a4ce:	c6 98       	rjmp	8000a5a0 <__avr32_udiv64+0x258>
8000a4d0:	16 39       	cp.w	r9,r11
8000a4d2:	e0 8b 00 65 	brhi	8000a59c <__avr32_udiv64+0x254>
8000a4d6:	f2 09 12 00 	clz	r9,r9
8000a4da:	c0 b1       	brne	8000a4f0 <__avr32_udiv64+0x1a8>
8000a4dc:	10 3a       	cp.w	r10,r8
8000a4de:	5f 2a       	srhs	r10
8000a4e0:	1c 3b       	cp.w	r11,lr
8000a4e2:	5f b8       	srhi	r8
8000a4e4:	10 4a       	or	r10,r8
8000a4e6:	f2 0a 18 00 	cp.b	r10,r9
8000a4ea:	c5 90       	breq	8000a59c <__avr32_udiv64+0x254>
8000a4ec:	30 18       	mov	r8,1
8000a4ee:	c5 98       	rjmp	8000a5a0 <__avr32_udiv64+0x258>
8000a4f0:	f0 09 09 46 	lsl	r6,r8,r9
8000a4f4:	f2 03 11 20 	rsub	r3,r9,32
8000a4f8:	fc 09 09 4e 	lsl	lr,lr,r9
8000a4fc:	f0 03 0a 48 	lsr	r8,r8,r3
8000a500:	f6 09 09 4c 	lsl	r12,r11,r9
8000a504:	f4 03 0a 42 	lsr	r2,r10,r3
8000a508:	ef 46 ff f4 	st.w	r7[-12],r6
8000a50c:	f6 03 0a 43 	lsr	r3,r11,r3
8000a510:	18 42       	or	r2,r12
8000a512:	f1 ee 10 0c 	or	r12,r8,lr
8000a516:	f8 01 16 10 	lsr	r1,r12,0x10
8000a51a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000a51e:	e6 01 0d 04 	divu	r4,r3,r1
8000a522:	e4 03 16 10 	lsr	r3,r2,0x10
8000a526:	08 9e       	mov	lr,r4
8000a528:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000a52c:	e8 06 02 48 	mul	r8,r4,r6
8000a530:	10 33       	cp.w	r3,r8
8000a532:	c0 a2       	brcc	8000a546 <__avr32_udiv64+0x1fe>
8000a534:	20 1e       	sub	lr,1
8000a536:	18 03       	add	r3,r12
8000a538:	18 33       	cp.w	r3,r12
8000a53a:	c0 63       	brcs	8000a546 <__avr32_udiv64+0x1fe>
8000a53c:	10 33       	cp.w	r3,r8
8000a53e:	f7 be 03 01 	sublo	lr,1
8000a542:	e7 dc e3 03 	addcs	r3,r3,r12
8000a546:	10 13       	sub	r3,r8
8000a548:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000a54c:	e6 01 0d 00 	divu	r0,r3,r1
8000a550:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000a554:	00 98       	mov	r8,r0
8000a556:	e0 06 02 46 	mul	r6,r0,r6
8000a55a:	0c 3b       	cp.w	r11,r6
8000a55c:	c0 a2       	brcc	8000a570 <__avr32_udiv64+0x228>
8000a55e:	20 18       	sub	r8,1
8000a560:	18 0b       	add	r11,r12
8000a562:	18 3b       	cp.w	r11,r12
8000a564:	c0 63       	brcs	8000a570 <__avr32_udiv64+0x228>
8000a566:	0c 3b       	cp.w	r11,r6
8000a568:	f7 dc e3 0b 	addcs	r11,r11,r12
8000a56c:	f7 b8 03 01 	sublo	r8,1
8000a570:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000a574:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000a578:	0c 1b       	sub	r11,r6
8000a57a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000a57e:	06 95       	mov	r5,r3
8000a580:	16 35       	cp.w	r5,r11
8000a582:	e0 8b 00 0a 	brhi	8000a596 <__avr32_udiv64+0x24e>
8000a586:	5f 0b       	sreq	r11
8000a588:	f4 09 09 49 	lsl	r9,r10,r9
8000a58c:	12 32       	cp.w	r2,r9
8000a58e:	5f b9       	srhi	r9
8000a590:	f7 e9 00 09 	and	r9,r11,r9
8000a594:	c0 60       	breq	8000a5a0 <__avr32_udiv64+0x258>
8000a596:	20 18       	sub	r8,1
8000a598:	30 09       	mov	r9,0
8000a59a:	c0 38       	rjmp	8000a5a0 <__avr32_udiv64+0x258>
8000a59c:	30 09       	mov	r9,0
8000a59e:	12 98       	mov	r8,r9
8000a5a0:	10 9a       	mov	r10,r8
8000a5a2:	12 93       	mov	r3,r9
8000a5a4:	10 92       	mov	r2,r8
8000a5a6:	12 9b       	mov	r11,r9
8000a5a8:	2f dd       	sub	sp,-12
8000a5aa:	d8 32       	popm	r0-r7,pc

8000a5ac <atexit>:
8000a5ac:	d4 01       	pushm	lr
8000a5ae:	30 09       	mov	r9,0
8000a5b0:	18 9b       	mov	r11,r12
8000a5b2:	12 9a       	mov	r10,r9
8000a5b4:	12 9c       	mov	r12,r9
8000a5b6:	e0 a0 03 29 	rcall	8000ac08 <__register_exitproc>
8000a5ba:	d8 02       	popm	pc

8000a5bc <exit>:
8000a5bc:	d4 21       	pushm	r4-r7,lr
8000a5be:	30 0b       	mov	r11,0
8000a5c0:	18 97       	mov	r7,r12
8000a5c2:	e0 a0 03 77 	rcall	8000acb0 <__call_exitprocs>
8000a5c6:	48 58       	lddpc	r8,8000a5d8 <exit+0x1c>
8000a5c8:	70 0c       	ld.w	r12,r8[0x0]
8000a5ca:	78 a8       	ld.w	r8,r12[0x28]
8000a5cc:	58 08       	cp.w	r8,0
8000a5ce:	c0 20       	breq	8000a5d2 <exit+0x16>
8000a5d0:	5d 18       	icall	r8
8000a5d2:	0e 9c       	mov	r12,r7
8000a5d4:	e0 a0 02 f8 	rcall	8000abc4 <_exit>
8000a5d8:	80 01       	ld.sh	r1,r0[0x0]
8000a5da:	53 74       	stdsp	sp[0xdc],r4

8000a5dc <free>:
8000a5dc:	d4 01       	pushm	lr
8000a5de:	e0 68 01 24 	mov	r8,292
8000a5e2:	18 9b       	mov	r11,r12
8000a5e4:	70 0c       	ld.w	r12,r8[0x0]
8000a5e6:	e0 a0 04 1b 	rcall	8000ae1c <_free_r>
8000a5ea:	d8 02       	popm	pc

8000a5ec <malloc>:
8000a5ec:	d4 01       	pushm	lr
8000a5ee:	e0 68 01 24 	mov	r8,292
8000a5f2:	18 9b       	mov	r11,r12
8000a5f4:	70 0c       	ld.w	r12,r8[0x0]
8000a5f6:	c0 3c       	rcall	8000a5fc <_malloc_r>
8000a5f8:	d8 02       	popm	pc
8000a5fa:	d7 03       	nop

8000a5fc <_malloc_r>:
8000a5fc:	d4 31       	pushm	r0-r7,lr
8000a5fe:	f6 c8 ff f5 	sub	r8,r11,-11
8000a602:	18 95       	mov	r5,r12
8000a604:	10 97       	mov	r7,r8
8000a606:	e0 17 ff f8 	andl	r7,0xfff8
8000a60a:	59 68       	cp.w	r8,22
8000a60c:	f9 b7 08 10 	movls	r7,16
8000a610:	16 37       	cp.w	r7,r11
8000a612:	5f 38       	srlo	r8
8000a614:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a618:	c0 50       	breq	8000a622 <_malloc_r+0x26>
8000a61a:	30 c8       	mov	r8,12
8000a61c:	99 38       	st.w	r12[0xc],r8
8000a61e:	e0 8f 01 f8 	bral	8000aa0e <_malloc_r+0x412>
8000a622:	fe b0 e7 37 	rcall	80007490 <__malloc_lock>
8000a626:	e0 47 01 f7 	cp.w	r7,503
8000a62a:	e0 8b 00 1d 	brhi	8000a664 <_malloc_r+0x68>
8000a62e:	ee 03 16 03 	lsr	r3,r7,0x3
8000a632:	e0 68 01 28 	mov	r8,296
8000a636:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a63a:	70 36       	ld.w	r6,r8[0xc]
8000a63c:	10 36       	cp.w	r6,r8
8000a63e:	c0 61       	brne	8000a64a <_malloc_r+0x4e>
8000a640:	ec c8 ff f8 	sub	r8,r6,-8
8000a644:	70 36       	ld.w	r6,r8[0xc]
8000a646:	10 36       	cp.w	r6,r8
8000a648:	c0 c0       	breq	8000a660 <_malloc_r+0x64>
8000a64a:	6c 18       	ld.w	r8,r6[0x4]
8000a64c:	e0 18 ff fc 	andl	r8,0xfffc
8000a650:	6c 3a       	ld.w	r10,r6[0xc]
8000a652:	ec 08 00 09 	add	r9,r6,r8
8000a656:	0a 9c       	mov	r12,r5
8000a658:	6c 28       	ld.w	r8,r6[0x8]
8000a65a:	95 28       	st.w	r10[0x8],r8
8000a65c:	91 3a       	st.w	r8[0xc],r10
8000a65e:	c4 78       	rjmp	8000a6ec <_malloc_r+0xf0>
8000a660:	2f e3       	sub	r3,-2
8000a662:	c4 d8       	rjmp	8000a6fc <_malloc_r+0x100>
8000a664:	ee 03 16 09 	lsr	r3,r7,0x9
8000a668:	c0 41       	brne	8000a670 <_malloc_r+0x74>
8000a66a:	ee 03 16 03 	lsr	r3,r7,0x3
8000a66e:	c2 68       	rjmp	8000a6ba <_malloc_r+0xbe>
8000a670:	58 43       	cp.w	r3,4
8000a672:	e0 8b 00 06 	brhi	8000a67e <_malloc_r+0x82>
8000a676:	ee 03 16 06 	lsr	r3,r7,0x6
8000a67a:	2c 83       	sub	r3,-56
8000a67c:	c1 f8       	rjmp	8000a6ba <_malloc_r+0xbe>
8000a67e:	59 43       	cp.w	r3,20
8000a680:	e0 8b 00 04 	brhi	8000a688 <_malloc_r+0x8c>
8000a684:	2a 53       	sub	r3,-91
8000a686:	c1 a8       	rjmp	8000a6ba <_malloc_r+0xbe>
8000a688:	e0 43 00 54 	cp.w	r3,84
8000a68c:	e0 8b 00 06 	brhi	8000a698 <_malloc_r+0x9c>
8000a690:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a694:	29 23       	sub	r3,-110
8000a696:	c1 28       	rjmp	8000a6ba <_malloc_r+0xbe>
8000a698:	e0 43 01 54 	cp.w	r3,340
8000a69c:	e0 8b 00 06 	brhi	8000a6a8 <_malloc_r+0xac>
8000a6a0:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a6a4:	28 93       	sub	r3,-119
8000a6a6:	c0 a8       	rjmp	8000a6ba <_malloc_r+0xbe>
8000a6a8:	e0 43 05 54 	cp.w	r3,1364
8000a6ac:	e0 88 00 04 	brls	8000a6b4 <_malloc_r+0xb8>
8000a6b0:	37 e3       	mov	r3,126
8000a6b2:	c0 48       	rjmp	8000a6ba <_malloc_r+0xbe>
8000a6b4:	ee 03 16 12 	lsr	r3,r7,0x12
8000a6b8:	28 43       	sub	r3,-124
8000a6ba:	e0 6a 01 28 	mov	r10,296
8000a6be:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a6c2:	74 36       	ld.w	r6,r10[0xc]
8000a6c4:	c1 98       	rjmp	8000a6f6 <_malloc_r+0xfa>
8000a6c6:	6c 19       	ld.w	r9,r6[0x4]
8000a6c8:	e0 19 ff fc 	andl	r9,0xfffc
8000a6cc:	f2 07 01 0b 	sub	r11,r9,r7
8000a6d0:	58 fb       	cp.w	r11,15
8000a6d2:	e0 8a 00 04 	brle	8000a6da <_malloc_r+0xde>
8000a6d6:	20 13       	sub	r3,1
8000a6d8:	c1 18       	rjmp	8000a6fa <_malloc_r+0xfe>
8000a6da:	6c 38       	ld.w	r8,r6[0xc]
8000a6dc:	58 0b       	cp.w	r11,0
8000a6de:	c0 b5       	brlt	8000a6f4 <_malloc_r+0xf8>
8000a6e0:	6c 2a       	ld.w	r10,r6[0x8]
8000a6e2:	ec 09 00 09 	add	r9,r6,r9
8000a6e6:	0a 9c       	mov	r12,r5
8000a6e8:	91 2a       	st.w	r8[0x8],r10
8000a6ea:	95 38       	st.w	r10[0xc],r8
8000a6ec:	72 18       	ld.w	r8,r9[0x4]
8000a6ee:	a1 a8       	sbr	r8,0x0
8000a6f0:	93 18       	st.w	r9[0x4],r8
8000a6f2:	cb c8       	rjmp	8000a86a <_malloc_r+0x26e>
8000a6f4:	10 96       	mov	r6,r8
8000a6f6:	14 36       	cp.w	r6,r10
8000a6f8:	ce 71       	brne	8000a6c6 <_malloc_r+0xca>
8000a6fa:	2f f3       	sub	r3,-1
8000a6fc:	e0 6a 01 28 	mov	r10,296
8000a700:	f4 cc ff f8 	sub	r12,r10,-8
8000a704:	78 26       	ld.w	r6,r12[0x8]
8000a706:	18 36       	cp.w	r6,r12
8000a708:	c6 c0       	breq	8000a7e0 <_malloc_r+0x1e4>
8000a70a:	6c 19       	ld.w	r9,r6[0x4]
8000a70c:	e0 19 ff fc 	andl	r9,0xfffc
8000a710:	f2 07 01 08 	sub	r8,r9,r7
8000a714:	58 f8       	cp.w	r8,15
8000a716:	e0 89 00 8f 	brgt	8000a834 <_malloc_r+0x238>
8000a71a:	99 3c       	st.w	r12[0xc],r12
8000a71c:	99 2c       	st.w	r12[0x8],r12
8000a71e:	58 08       	cp.w	r8,0
8000a720:	c0 55       	brlt	8000a72a <_malloc_r+0x12e>
8000a722:	ec 09 00 09 	add	r9,r6,r9
8000a726:	0a 9c       	mov	r12,r5
8000a728:	ce 2b       	rjmp	8000a6ec <_malloc_r+0xf0>
8000a72a:	e0 49 01 ff 	cp.w	r9,511
8000a72e:	e0 8b 00 13 	brhi	8000a754 <_malloc_r+0x158>
8000a732:	a3 99       	lsr	r9,0x3
8000a734:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a738:	70 2b       	ld.w	r11,r8[0x8]
8000a73a:	8d 38       	st.w	r6[0xc],r8
8000a73c:	8d 2b       	st.w	r6[0x8],r11
8000a73e:	97 36       	st.w	r11[0xc],r6
8000a740:	91 26       	st.w	r8[0x8],r6
8000a742:	a3 49       	asr	r9,0x2
8000a744:	74 18       	ld.w	r8,r10[0x4]
8000a746:	30 1b       	mov	r11,1
8000a748:	f6 09 09 49 	lsl	r9,r11,r9
8000a74c:	f1 e9 10 09 	or	r9,r8,r9
8000a750:	95 19       	st.w	r10[0x4],r9
8000a752:	c4 78       	rjmp	8000a7e0 <_malloc_r+0x1e4>
8000a754:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a758:	58 4a       	cp.w	r10,4
8000a75a:	e0 8b 00 07 	brhi	8000a768 <_malloc_r+0x16c>
8000a75e:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a762:	2c 8a       	sub	r10,-56
8000a764:	c2 08       	rjmp	8000a7a4 <_malloc_r+0x1a8>
8000a766:	d7 03       	nop
8000a768:	59 4a       	cp.w	r10,20
8000a76a:	e0 8b 00 04 	brhi	8000a772 <_malloc_r+0x176>
8000a76e:	2a 5a       	sub	r10,-91
8000a770:	c1 a8       	rjmp	8000a7a4 <_malloc_r+0x1a8>
8000a772:	e0 4a 00 54 	cp.w	r10,84
8000a776:	e0 8b 00 06 	brhi	8000a782 <_malloc_r+0x186>
8000a77a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a77e:	29 2a       	sub	r10,-110
8000a780:	c1 28       	rjmp	8000a7a4 <_malloc_r+0x1a8>
8000a782:	e0 4a 01 54 	cp.w	r10,340
8000a786:	e0 8b 00 06 	brhi	8000a792 <_malloc_r+0x196>
8000a78a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a78e:	28 9a       	sub	r10,-119
8000a790:	c0 a8       	rjmp	8000a7a4 <_malloc_r+0x1a8>
8000a792:	e0 4a 05 54 	cp.w	r10,1364
8000a796:	e0 88 00 04 	brls	8000a79e <_malloc_r+0x1a2>
8000a79a:	37 ea       	mov	r10,126
8000a79c:	c0 48       	rjmp	8000a7a4 <_malloc_r+0x1a8>
8000a79e:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a7a2:	28 4a       	sub	r10,-124
8000a7a4:	e0 6b 01 28 	mov	r11,296
8000a7a8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a7ac:	68 28       	ld.w	r8,r4[0x8]
8000a7ae:	08 38       	cp.w	r8,r4
8000a7b0:	c0 e1       	brne	8000a7cc <_malloc_r+0x1d0>
8000a7b2:	76 19       	ld.w	r9,r11[0x4]
8000a7b4:	a3 4a       	asr	r10,0x2
8000a7b6:	30 1e       	mov	lr,1
8000a7b8:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a7bc:	f3 ea 10 0a 	or	r10,r9,r10
8000a7c0:	10 99       	mov	r9,r8
8000a7c2:	97 1a       	st.w	r11[0x4],r10
8000a7c4:	c0 a8       	rjmp	8000a7d8 <_malloc_r+0x1dc>
8000a7c6:	70 28       	ld.w	r8,r8[0x8]
8000a7c8:	08 38       	cp.w	r8,r4
8000a7ca:	c0 60       	breq	8000a7d6 <_malloc_r+0x1da>
8000a7cc:	70 1a       	ld.w	r10,r8[0x4]
8000a7ce:	e0 1a ff fc 	andl	r10,0xfffc
8000a7d2:	14 39       	cp.w	r9,r10
8000a7d4:	cf 93       	brcs	8000a7c6 <_malloc_r+0x1ca>
8000a7d6:	70 39       	ld.w	r9,r8[0xc]
8000a7d8:	8d 39       	st.w	r6[0xc],r9
8000a7da:	8d 28       	st.w	r6[0x8],r8
8000a7dc:	91 36       	st.w	r8[0xc],r6
8000a7de:	93 26       	st.w	r9[0x8],r6
8000a7e0:	e6 08 14 02 	asr	r8,r3,0x2
8000a7e4:	30 1b       	mov	r11,1
8000a7e6:	e0 64 01 28 	mov	r4,296
8000a7ea:	f6 08 09 4b 	lsl	r11,r11,r8
8000a7ee:	68 18       	ld.w	r8,r4[0x4]
8000a7f0:	10 3b       	cp.w	r11,r8
8000a7f2:	e0 8b 00 6b 	brhi	8000a8c8 <_malloc_r+0x2cc>
8000a7f6:	f7 e8 00 09 	and	r9,r11,r8
8000a7fa:	c0 b1       	brne	8000a810 <_malloc_r+0x214>
8000a7fc:	e0 13 ff fc 	andl	r3,0xfffc
8000a800:	a1 7b       	lsl	r11,0x1
8000a802:	2f c3       	sub	r3,-4
8000a804:	c0 38       	rjmp	8000a80a <_malloc_r+0x20e>
8000a806:	2f c3       	sub	r3,-4
8000a808:	a1 7b       	lsl	r11,0x1
8000a80a:	f7 e8 00 09 	and	r9,r11,r8
8000a80e:	cf c0       	breq	8000a806 <_malloc_r+0x20a>
8000a810:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a814:	06 92       	mov	r2,r3
8000a816:	1c 91       	mov	r1,lr
8000a818:	62 36       	ld.w	r6,r1[0xc]
8000a81a:	c2 e8       	rjmp	8000a876 <_malloc_r+0x27a>
8000a81c:	6c 1a       	ld.w	r10,r6[0x4]
8000a81e:	e0 1a ff fc 	andl	r10,0xfffc
8000a822:	f4 07 01 08 	sub	r8,r10,r7
8000a826:	58 f8       	cp.w	r8,15
8000a828:	e0 8a 00 15 	brle	8000a852 <_malloc_r+0x256>
8000a82c:	6c 3a       	ld.w	r10,r6[0xc]
8000a82e:	6c 29       	ld.w	r9,r6[0x8]
8000a830:	95 29       	st.w	r10[0x8],r9
8000a832:	93 3a       	st.w	r9[0xc],r10
8000a834:	0e 99       	mov	r9,r7
8000a836:	ec 07 00 07 	add	r7,r6,r7
8000a83a:	a1 a9       	sbr	r9,0x0
8000a83c:	99 37       	st.w	r12[0xc],r7
8000a83e:	99 27       	st.w	r12[0x8],r7
8000a840:	8d 19       	st.w	r6[0x4],r9
8000a842:	ee 08 09 08 	st.w	r7[r8],r8
8000a846:	8f 2c       	st.w	r7[0x8],r12
8000a848:	8f 3c       	st.w	r7[0xc],r12
8000a84a:	a1 a8       	sbr	r8,0x0
8000a84c:	0a 9c       	mov	r12,r5
8000a84e:	8f 18       	st.w	r7[0x4],r8
8000a850:	c0 d8       	rjmp	8000a86a <_malloc_r+0x26e>
8000a852:	6c 39       	ld.w	r9,r6[0xc]
8000a854:	58 08       	cp.w	r8,0
8000a856:	c0 f5       	brlt	8000a874 <_malloc_r+0x278>
8000a858:	ec 0a 00 0a 	add	r10,r6,r10
8000a85c:	74 18       	ld.w	r8,r10[0x4]
8000a85e:	a1 a8       	sbr	r8,0x0
8000a860:	0a 9c       	mov	r12,r5
8000a862:	95 18       	st.w	r10[0x4],r8
8000a864:	6c 28       	ld.w	r8,r6[0x8]
8000a866:	93 28       	st.w	r9[0x8],r8
8000a868:	91 39       	st.w	r8[0xc],r9
8000a86a:	fe b0 e6 19 	rcall	8000749c <__malloc_unlock>
8000a86e:	ec cc ff f8 	sub	r12,r6,-8
8000a872:	d8 32       	popm	r0-r7,pc
8000a874:	12 96       	mov	r6,r9
8000a876:	02 36       	cp.w	r6,r1
8000a878:	cd 21       	brne	8000a81c <_malloc_r+0x220>
8000a87a:	2f f2       	sub	r2,-1
8000a87c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a880:	c0 30       	breq	8000a886 <_malloc_r+0x28a>
8000a882:	2f 81       	sub	r1,-8
8000a884:	cc ab       	rjmp	8000a818 <_malloc_r+0x21c>
8000a886:	1c 98       	mov	r8,lr
8000a888:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a88c:	c0 81       	brne	8000a89c <_malloc_r+0x2a0>
8000a88e:	68 19       	ld.w	r9,r4[0x4]
8000a890:	f6 08 11 ff 	rsub	r8,r11,-1
8000a894:	f3 e8 00 08 	and	r8,r9,r8
8000a898:	89 18       	st.w	r4[0x4],r8
8000a89a:	c0 78       	rjmp	8000a8a8 <_malloc_r+0x2ac>
8000a89c:	f0 c9 00 08 	sub	r9,r8,8
8000a8a0:	20 13       	sub	r3,1
8000a8a2:	70 08       	ld.w	r8,r8[0x0]
8000a8a4:	12 38       	cp.w	r8,r9
8000a8a6:	cf 10       	breq	8000a888 <_malloc_r+0x28c>
8000a8a8:	a1 7b       	lsl	r11,0x1
8000a8aa:	68 18       	ld.w	r8,r4[0x4]
8000a8ac:	10 3b       	cp.w	r11,r8
8000a8ae:	e0 8b 00 0d 	brhi	8000a8c8 <_malloc_r+0x2cc>
8000a8b2:	58 0b       	cp.w	r11,0
8000a8b4:	c0 a0       	breq	8000a8c8 <_malloc_r+0x2cc>
8000a8b6:	04 93       	mov	r3,r2
8000a8b8:	c0 38       	rjmp	8000a8be <_malloc_r+0x2c2>
8000a8ba:	2f c3       	sub	r3,-4
8000a8bc:	a1 7b       	lsl	r11,0x1
8000a8be:	f7 e8 00 09 	and	r9,r11,r8
8000a8c2:	ca 71       	brne	8000a810 <_malloc_r+0x214>
8000a8c4:	cf bb       	rjmp	8000a8ba <_malloc_r+0x2be>
8000a8c6:	d7 03       	nop
8000a8c8:	68 23       	ld.w	r3,r4[0x8]
8000a8ca:	66 12       	ld.w	r2,r3[0x4]
8000a8cc:	e0 12 ff fc 	andl	r2,0xfffc
8000a8d0:	0e 32       	cp.w	r2,r7
8000a8d2:	5f 39       	srlo	r9
8000a8d4:	e4 07 01 08 	sub	r8,r2,r7
8000a8d8:	58 f8       	cp.w	r8,15
8000a8da:	5f aa       	srle	r10
8000a8dc:	f5 e9 10 09 	or	r9,r10,r9
8000a8e0:	e0 80 00 98 	breq	8000aa10 <_malloc_r+0x414>
8000a8e4:	e0 68 11 28 	mov	r8,4392
8000a8e8:	70 01       	ld.w	r1,r8[0x0]
8000a8ea:	e0 68 05 34 	mov	r8,1332
8000a8ee:	2f 01       	sub	r1,-16
8000a8f0:	70 08       	ld.w	r8,r8[0x0]
8000a8f2:	0e 01       	add	r1,r7
8000a8f4:	5b f8       	cp.w	r8,-1
8000a8f6:	c0 40       	breq	8000a8fe <_malloc_r+0x302>
8000a8f8:	28 11       	sub	r1,-127
8000a8fa:	e0 11 ff 80 	andl	r1,0xff80
8000a8fe:	02 9b       	mov	r11,r1
8000a900:	0a 9c       	mov	r12,r5
8000a902:	c4 3d       	rcall	8000ab88 <_sbrk_r>
8000a904:	18 96       	mov	r6,r12
8000a906:	5b fc       	cp.w	r12,-1
8000a908:	c7 40       	breq	8000a9f0 <_malloc_r+0x3f4>
8000a90a:	e6 02 00 08 	add	r8,r3,r2
8000a90e:	10 3c       	cp.w	r12,r8
8000a910:	c0 32       	brcc	8000a916 <_malloc_r+0x31a>
8000a912:	08 33       	cp.w	r3,r4
8000a914:	c6 e1       	brne	8000a9f0 <_malloc_r+0x3f4>
8000a916:	e0 6a 11 2c 	mov	r10,4396
8000a91a:	74 09       	ld.w	r9,r10[0x0]
8000a91c:	e2 09 00 09 	add	r9,r1,r9
8000a920:	95 09       	st.w	r10[0x0],r9
8000a922:	10 36       	cp.w	r6,r8
8000a924:	c0 a1       	brne	8000a938 <_malloc_r+0x33c>
8000a926:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a92a:	c0 71       	brne	8000a938 <_malloc_r+0x33c>
8000a92c:	e2 02 00 02 	add	r2,r1,r2
8000a930:	68 28       	ld.w	r8,r4[0x8]
8000a932:	a1 a2       	sbr	r2,0x0
8000a934:	91 12       	st.w	r8[0x4],r2
8000a936:	c4 e8       	rjmp	8000a9d2 <_malloc_r+0x3d6>
8000a938:	e0 6a 05 34 	mov	r10,1332
8000a93c:	74 0b       	ld.w	r11,r10[0x0]
8000a93e:	5b fb       	cp.w	r11,-1
8000a940:	c0 31       	brne	8000a946 <_malloc_r+0x34a>
8000a942:	95 06       	st.w	r10[0x0],r6
8000a944:	c0 78       	rjmp	8000a952 <_malloc_r+0x356>
8000a946:	ec 09 00 09 	add	r9,r6,r9
8000a94a:	e0 6a 11 2c 	mov	r10,4396
8000a94e:	10 19       	sub	r9,r8
8000a950:	95 09       	st.w	r10[0x0],r9
8000a952:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a956:	f0 09 11 08 	rsub	r9,r8,8
8000a95a:	58 08       	cp.w	r8,0
8000a95c:	f2 08 17 10 	movne	r8,r9
8000a960:	ed d8 e1 06 	addne	r6,r6,r8
8000a964:	28 08       	sub	r8,-128
8000a966:	ec 01 00 01 	add	r1,r6,r1
8000a96a:	0a 9c       	mov	r12,r5
8000a96c:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a970:	f0 01 01 01 	sub	r1,r8,r1
8000a974:	02 9b       	mov	r11,r1
8000a976:	c0 9d       	rcall	8000ab88 <_sbrk_r>
8000a978:	e0 68 11 2c 	mov	r8,4396
8000a97c:	5b fc       	cp.w	r12,-1
8000a97e:	ec 0c 17 00 	moveq	r12,r6
8000a982:	f9 b1 00 00 	moveq	r1,0
8000a986:	70 09       	ld.w	r9,r8[0x0]
8000a988:	0c 1c       	sub	r12,r6
8000a98a:	89 26       	st.w	r4[0x8],r6
8000a98c:	02 0c       	add	r12,r1
8000a98e:	12 01       	add	r1,r9
8000a990:	a1 ac       	sbr	r12,0x0
8000a992:	91 01       	st.w	r8[0x0],r1
8000a994:	8d 1c       	st.w	r6[0x4],r12
8000a996:	08 33       	cp.w	r3,r4
8000a998:	c1 d0       	breq	8000a9d2 <_malloc_r+0x3d6>
8000a99a:	58 f2       	cp.w	r2,15
8000a99c:	e0 8b 00 05 	brhi	8000a9a6 <_malloc_r+0x3aa>
8000a9a0:	30 18       	mov	r8,1
8000a9a2:	8d 18       	st.w	r6[0x4],r8
8000a9a4:	c2 68       	rjmp	8000a9f0 <_malloc_r+0x3f4>
8000a9a6:	30 59       	mov	r9,5
8000a9a8:	20 c2       	sub	r2,12
8000a9aa:	e0 12 ff f8 	andl	r2,0xfff8
8000a9ae:	e6 02 00 08 	add	r8,r3,r2
8000a9b2:	91 29       	st.w	r8[0x8],r9
8000a9b4:	91 19       	st.w	r8[0x4],r9
8000a9b6:	66 18       	ld.w	r8,r3[0x4]
8000a9b8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a9bc:	e5 e8 10 08 	or	r8,r2,r8
8000a9c0:	87 18       	st.w	r3[0x4],r8
8000a9c2:	58 f2       	cp.w	r2,15
8000a9c4:	e0 88 00 07 	brls	8000a9d2 <_malloc_r+0x3d6>
8000a9c8:	e6 cb ff f8 	sub	r11,r3,-8
8000a9cc:	0a 9c       	mov	r12,r5
8000a9ce:	e0 a0 02 27 	rcall	8000ae1c <_free_r>
8000a9d2:	e0 69 11 24 	mov	r9,4388
8000a9d6:	72 0a       	ld.w	r10,r9[0x0]
8000a9d8:	e0 68 11 2c 	mov	r8,4396
8000a9dc:	70 08       	ld.w	r8,r8[0x0]
8000a9de:	14 38       	cp.w	r8,r10
8000a9e0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a9e4:	e0 69 11 20 	mov	r9,4384
8000a9e8:	72 0a       	ld.w	r10,r9[0x0]
8000a9ea:	14 38       	cp.w	r8,r10
8000a9ec:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a9f0:	68 28       	ld.w	r8,r4[0x8]
8000a9f2:	70 18       	ld.w	r8,r8[0x4]
8000a9f4:	e0 18 ff fc 	andl	r8,0xfffc
8000a9f8:	0e 38       	cp.w	r8,r7
8000a9fa:	5f 39       	srlo	r9
8000a9fc:	0e 18       	sub	r8,r7
8000a9fe:	58 f8       	cp.w	r8,15
8000aa00:	5f aa       	srle	r10
8000aa02:	f5 e9 10 09 	or	r9,r10,r9
8000aa06:	c0 50       	breq	8000aa10 <_malloc_r+0x414>
8000aa08:	0a 9c       	mov	r12,r5
8000aa0a:	fe b0 e5 49 	rcall	8000749c <__malloc_unlock>
8000aa0e:	d8 3a       	popm	r0-r7,pc,r12=0
8000aa10:	68 26       	ld.w	r6,r4[0x8]
8000aa12:	a1 a8       	sbr	r8,0x0
8000aa14:	0e 99       	mov	r9,r7
8000aa16:	a1 a9       	sbr	r9,0x0
8000aa18:	8d 19       	st.w	r6[0x4],r9
8000aa1a:	ec 07 00 07 	add	r7,r6,r7
8000aa1e:	0a 9c       	mov	r12,r5
8000aa20:	89 27       	st.w	r4[0x8],r7
8000aa22:	8f 18       	st.w	r7[0x4],r8
8000aa24:	fe b0 e5 3c 	rcall	8000749c <__malloc_unlock>
8000aa28:	ec cc ff f8 	sub	r12,r6,-8
8000aa2c:	d8 32       	popm	r0-r7,pc
8000aa2e:	d7 03       	nop

8000aa30 <memcpy>:
8000aa30:	58 8a       	cp.w	r10,8
8000aa32:	c2 f5       	brlt	8000aa90 <memcpy+0x60>
8000aa34:	f9 eb 10 09 	or	r9,r12,r11
8000aa38:	e2 19 00 03 	andl	r9,0x3,COH
8000aa3c:	e0 81 00 97 	brne	8000ab6a <memcpy+0x13a>
8000aa40:	e0 4a 00 20 	cp.w	r10,32
8000aa44:	c3 b4       	brge	8000aaba <memcpy+0x8a>
8000aa46:	f4 08 14 02 	asr	r8,r10,0x2
8000aa4a:	f0 09 11 08 	rsub	r9,r8,8
8000aa4e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000aa52:	76 69       	ld.w	r9,r11[0x18]
8000aa54:	99 69       	st.w	r12[0x18],r9
8000aa56:	76 59       	ld.w	r9,r11[0x14]
8000aa58:	99 59       	st.w	r12[0x14],r9
8000aa5a:	76 49       	ld.w	r9,r11[0x10]
8000aa5c:	99 49       	st.w	r12[0x10],r9
8000aa5e:	76 39       	ld.w	r9,r11[0xc]
8000aa60:	99 39       	st.w	r12[0xc],r9
8000aa62:	76 29       	ld.w	r9,r11[0x8]
8000aa64:	99 29       	st.w	r12[0x8],r9
8000aa66:	76 19       	ld.w	r9,r11[0x4]
8000aa68:	99 19       	st.w	r12[0x4],r9
8000aa6a:	76 09       	ld.w	r9,r11[0x0]
8000aa6c:	99 09       	st.w	r12[0x0],r9
8000aa6e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000aa72:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000aa76:	e0 1a 00 03 	andl	r10,0x3
8000aa7a:	f4 0a 11 04 	rsub	r10,r10,4
8000aa7e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000aa82:	17 a9       	ld.ub	r9,r11[0x2]
8000aa84:	b0 a9       	st.b	r8[0x2],r9
8000aa86:	17 99       	ld.ub	r9,r11[0x1]
8000aa88:	b0 99       	st.b	r8[0x1],r9
8000aa8a:	17 89       	ld.ub	r9,r11[0x0]
8000aa8c:	b0 89       	st.b	r8[0x0],r9
8000aa8e:	5e fc       	retal	r12
8000aa90:	f4 0a 11 09 	rsub	r10,r10,9
8000aa94:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000aa98:	17 f9       	ld.ub	r9,r11[0x7]
8000aa9a:	b8 f9       	st.b	r12[0x7],r9
8000aa9c:	17 e9       	ld.ub	r9,r11[0x6]
8000aa9e:	b8 e9       	st.b	r12[0x6],r9
8000aaa0:	17 d9       	ld.ub	r9,r11[0x5]
8000aaa2:	b8 d9       	st.b	r12[0x5],r9
8000aaa4:	17 c9       	ld.ub	r9,r11[0x4]
8000aaa6:	b8 c9       	st.b	r12[0x4],r9
8000aaa8:	17 b9       	ld.ub	r9,r11[0x3]
8000aaaa:	b8 b9       	st.b	r12[0x3],r9
8000aaac:	17 a9       	ld.ub	r9,r11[0x2]
8000aaae:	b8 a9       	st.b	r12[0x2],r9
8000aab0:	17 99       	ld.ub	r9,r11[0x1]
8000aab2:	b8 99       	st.b	r12[0x1],r9
8000aab4:	17 89       	ld.ub	r9,r11[0x0]
8000aab6:	b8 89       	st.b	r12[0x0],r9
8000aab8:	5e fc       	retal	r12
8000aaba:	eb cd 40 c0 	pushm	r6-r7,lr
8000aabe:	18 99       	mov	r9,r12
8000aac0:	22 0a       	sub	r10,32
8000aac2:	b7 07       	ld.d	r6,r11++
8000aac4:	b3 26       	st.d	r9++,r6
8000aac6:	b7 07       	ld.d	r6,r11++
8000aac8:	b3 26       	st.d	r9++,r6
8000aaca:	b7 07       	ld.d	r6,r11++
8000aacc:	b3 26       	st.d	r9++,r6
8000aace:	b7 07       	ld.d	r6,r11++
8000aad0:	b3 26       	st.d	r9++,r6
8000aad2:	22 0a       	sub	r10,32
8000aad4:	cf 74       	brge	8000aac2 <memcpy+0x92>
8000aad6:	2f 0a       	sub	r10,-16
8000aad8:	c0 65       	brlt	8000aae4 <memcpy+0xb4>
8000aada:	b7 07       	ld.d	r6,r11++
8000aadc:	b3 26       	st.d	r9++,r6
8000aade:	b7 07       	ld.d	r6,r11++
8000aae0:	b3 26       	st.d	r9++,r6
8000aae2:	21 0a       	sub	r10,16
8000aae4:	5c 3a       	neg	r10
8000aae6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000aaea:	d7 03       	nop
8000aaec:	d7 03       	nop
8000aaee:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000aaf2:	f3 66 00 0e 	st.b	r9[14],r6
8000aaf6:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000aafa:	f3 66 00 0d 	st.b	r9[13],r6
8000aafe:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000ab02:	f3 66 00 0c 	st.b	r9[12],r6
8000ab06:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000ab0a:	f3 66 00 0b 	st.b	r9[11],r6
8000ab0e:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000ab12:	f3 66 00 0a 	st.b	r9[10],r6
8000ab16:	f7 36 00 09 	ld.ub	r6,r11[9]
8000ab1a:	f3 66 00 09 	st.b	r9[9],r6
8000ab1e:	f7 36 00 08 	ld.ub	r6,r11[8]
8000ab22:	f3 66 00 08 	st.b	r9[8],r6
8000ab26:	f7 36 00 07 	ld.ub	r6,r11[7]
8000ab2a:	f3 66 00 07 	st.b	r9[7],r6
8000ab2e:	f7 36 00 06 	ld.ub	r6,r11[6]
8000ab32:	f3 66 00 06 	st.b	r9[6],r6
8000ab36:	f7 36 00 05 	ld.ub	r6,r11[5]
8000ab3a:	f3 66 00 05 	st.b	r9[5],r6
8000ab3e:	f7 36 00 04 	ld.ub	r6,r11[4]
8000ab42:	f3 66 00 04 	st.b	r9[4],r6
8000ab46:	f7 36 00 03 	ld.ub	r6,r11[3]
8000ab4a:	f3 66 00 03 	st.b	r9[3],r6
8000ab4e:	f7 36 00 02 	ld.ub	r6,r11[2]
8000ab52:	f3 66 00 02 	st.b	r9[2],r6
8000ab56:	f7 36 00 01 	ld.ub	r6,r11[1]
8000ab5a:	f3 66 00 01 	st.b	r9[1],r6
8000ab5e:	f7 36 00 00 	ld.ub	r6,r11[0]
8000ab62:	f3 66 00 00 	st.b	r9[0],r6
8000ab66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000ab6a:	20 1a       	sub	r10,1
8000ab6c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000ab70:	f8 0a 0b 09 	st.b	r12[r10],r9
8000ab74:	cf b1       	brne	8000ab6a <memcpy+0x13a>
8000ab76:	5e fc       	retal	r12

8000ab78 <memset>:
8000ab78:	18 98       	mov	r8,r12
8000ab7a:	c0 38       	rjmp	8000ab80 <memset+0x8>
8000ab7c:	10 cb       	st.b	r8++,r11
8000ab7e:	20 1a       	sub	r10,1
8000ab80:	58 0a       	cp.w	r10,0
8000ab82:	cf d1       	brne	8000ab7c <memset+0x4>
8000ab84:	5e fc       	retal	r12
8000ab86:	d7 03       	nop

8000ab88 <_sbrk_r>:
8000ab88:	d4 21       	pushm	r4-r7,lr
8000ab8a:	30 08       	mov	r8,0
8000ab8c:	18 97       	mov	r7,r12
8000ab8e:	e0 66 16 bc 	mov	r6,5820
8000ab92:	16 9c       	mov	r12,r11
8000ab94:	8d 08       	st.w	r6[0x0],r8
8000ab96:	c1 dc       	rcall	8000abd0 <_sbrk>
8000ab98:	5b fc       	cp.w	r12,-1
8000ab9a:	c0 51       	brne	8000aba4 <_sbrk_r+0x1c>
8000ab9c:	6c 08       	ld.w	r8,r6[0x0]
8000ab9e:	58 08       	cp.w	r8,0
8000aba0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aba4:	d8 22       	popm	r4-r7,pc
8000aba6:	d7 03       	nop

8000aba8 <strcpy>:
8000aba8:	30 08       	mov	r8,0
8000abaa:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000abae:	f8 08 0b 09 	st.b	r12[r8],r9
8000abb2:	2f f8       	sub	r8,-1
8000abb4:	58 09       	cp.w	r9,0
8000abb6:	cf a1       	brne	8000abaa <strcpy+0x2>
8000abb8:	5e fc       	retal	r12

8000abba <_init_argv>:
8000abba:	30 e8       	mov	r8,14
8000abbc:	d6 73       	breakpoint
8000abbe:	3f fc       	mov	r12,-1
8000abc0:	35 8b       	mov	r11,88
8000abc2:	5e fc       	retal	r12

8000abc4 <_exit>:
8000abc4:	30 d8       	mov	r8,13
8000abc6:	d6 73       	breakpoint
8000abc8:	3f fc       	mov	r12,-1
8000abca:	35 8b       	mov	r11,88
8000abcc:	c0 08       	rjmp	8000abcc <_exit+0x8>
8000abce:	d7 03       	nop

8000abd0 <_sbrk>:
8000abd0:	d4 01       	pushm	lr
8000abd2:	e0 68 11 54 	mov	r8,4436
8000abd6:	70 09       	ld.w	r9,r8[0x0]
8000abd8:	58 09       	cp.w	r9,0
8000abda:	c0 41       	brne	8000abe2 <_sbrk+0x12>
8000abdc:	e0 69 16 c0 	mov	r9,5824
8000abe0:	91 09       	st.w	r8[0x0],r9
8000abe2:	e0 69 11 54 	mov	r9,4436
8000abe6:	e0 6a f0 00 	mov	r10,61440
8000abea:	72 08       	ld.w	r8,r9[0x0]
8000abec:	f0 0c 00 0c 	add	r12,r8,r12
8000abf0:	14 3c       	cp.w	r12,r10
8000abf2:	e0 8b 00 04 	brhi	8000abfa <_sbrk+0x2a>
8000abf6:	93 0c       	st.w	r9[0x0],r12
8000abf8:	c0 58       	rjmp	8000ac02 <_sbrk+0x32>
8000abfa:	cc 3c       	rcall	8000ad80 <__errno>
8000abfc:	30 c8       	mov	r8,12
8000abfe:	99 08       	st.w	r12[0x0],r8
8000ac00:	3f f8       	mov	r8,-1
8000ac02:	10 9c       	mov	r12,r8
8000ac04:	d8 02       	popm	pc
8000ac06:	d7 03       	nop

8000ac08 <__register_exitproc>:
8000ac08:	d4 31       	pushm	r0-r7,lr
8000ac0a:	4a 98       	lddpc	r8,8000acac <__register_exitproc+0xa4>
8000ac0c:	70 03       	ld.w	r3,r8[0x0]
8000ac0e:	67 24       	ld.w	r4,r3[0x48]
8000ac10:	e6 c8 ff b4 	sub	r8,r3,-76
8000ac14:	58 04       	cp.w	r4,0
8000ac16:	f0 04 17 00 	moveq	r4,r8
8000ac1a:	e7 f4 0a 12 	st.weq	r3[0x48],r4
8000ac1e:	18 97       	mov	r7,r12
8000ac20:	16 96       	mov	r6,r11
8000ac22:	14 95       	mov	r5,r10
8000ac24:	12 92       	mov	r2,r9
8000ac26:	68 18       	ld.w	r8,r4[0x4]
8000ac28:	59 f8       	cp.w	r8,31
8000ac2a:	e0 8a 00 0e 	brle	8000ac46 <__register_exitproc+0x3e>
8000ac2e:	e0 6c 00 8c 	mov	r12,140
8000ac32:	fe b0 fc dd 	rcall	8000a5ec <malloc>
8000ac36:	18 94       	mov	r4,r12
8000ac38:	c3 80       	breq	8000aca8 <__register_exitproc+0xa0>
8000ac3a:	67 28       	ld.w	r8,r3[0x48]
8000ac3c:	99 08       	st.w	r12[0x0],r8
8000ac3e:	e7 4c 00 48 	st.w	r3[72],r12
8000ac42:	30 08       	mov	r8,0
8000ac44:	99 18       	st.w	r12[0x4],r8
8000ac46:	58 07       	cp.w	r7,0
8000ac48:	c2 70       	breq	8000ac96 <__register_exitproc+0x8e>
8000ac4a:	e8 fc 00 88 	ld.w	r12,r4[136]
8000ac4e:	58 0c       	cp.w	r12,0
8000ac50:	c0 d1       	brne	8000ac6a <__register_exitproc+0x62>
8000ac52:	e0 6c 01 08 	mov	r12,264
8000ac56:	fe b0 fc cb 	rcall	8000a5ec <malloc>
8000ac5a:	c2 70       	breq	8000aca8 <__register_exitproc+0xa0>
8000ac5c:	30 08       	mov	r8,0
8000ac5e:	e9 4c 00 88 	st.w	r4[136],r12
8000ac62:	f9 48 01 04 	st.w	r12[260],r8
8000ac66:	f9 48 01 00 	st.w	r12[256],r8
8000ac6a:	68 18       	ld.w	r8,r4[0x4]
8000ac6c:	f0 c9 ff e0 	sub	r9,r8,-32
8000ac70:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000ac74:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
8000ac78:	30 1a       	mov	r10,1
8000ac7a:	f8 f9 01 00 	ld.w	r9,r12[256]
8000ac7e:	f4 08 09 48 	lsl	r8,r10,r8
8000ac82:	10 49       	or	r9,r8
8000ac84:	f9 49 01 00 	st.w	r12[256],r9
8000ac88:	58 27       	cp.w	r7,2
8000ac8a:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
8000ac8e:	f3 d8 e0 38 	oreq	r8,r9,r8
8000ac92:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000ac96:	68 18       	ld.w	r8,r4[0x4]
8000ac98:	30 0c       	mov	r12,0
8000ac9a:	f0 c9 ff ff 	sub	r9,r8,-1
8000ac9e:	2f e8       	sub	r8,-2
8000aca0:	89 19       	st.w	r4[0x4],r9
8000aca2:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000aca6:	d8 32       	popm	r0-r7,pc
8000aca8:	dc 3a       	popm	r0-r7,pc,r12=-1
8000acaa:	d7 03       	nop
8000acac:	80 01       	ld.sh	r1,r0[0x0]
8000acae:	53 74       	stdsp	sp[0xdc],r4

8000acb0 <__call_exitprocs>:
8000acb0:	d4 31       	pushm	r0-r7,lr
8000acb2:	20 3d       	sub	sp,12
8000acb4:	4b 28       	lddpc	r8,8000ad7c <__call_exitprocs+0xcc>
8000acb6:	50 2c       	stdsp	sp[0x8],r12
8000acb8:	70 08       	ld.w	r8,r8[0x0]
8000acba:	16 91       	mov	r1,r11
8000acbc:	50 08       	stdsp	sp[0x0],r8
8000acbe:	2b 88       	sub	r8,-72
8000acc0:	50 18       	stdsp	sp[0x4],r8
8000acc2:	40 0a       	lddsp	r10,sp[0x0]
8000acc4:	40 14       	lddsp	r4,sp[0x4]
8000acc6:	75 27       	ld.w	r7,r10[0x48]
8000acc8:	c5 58       	rjmp	8000ad72 <__call_exitprocs+0xc2>
8000acca:	6e 15       	ld.w	r5,r7[0x4]
8000accc:	ee f6 00 88 	ld.w	r6,r7[136]
8000acd0:	ea c2 ff ff 	sub	r2,r5,-1
8000acd4:	20 15       	sub	r5,1
8000acd6:	ee 02 00 22 	add	r2,r7,r2<<0x2
8000acda:	ec 05 00 23 	add	r3,r6,r5<<0x2
8000acde:	c3 58       	rjmp	8000ad48 <__call_exitprocs+0x98>
8000ace0:	58 01       	cp.w	r1,0
8000ace2:	c0 70       	breq	8000acf0 <__call_exitprocs+0x40>
8000ace4:	58 06       	cp.w	r6,0
8000ace6:	c2 e0       	breq	8000ad42 <__call_exitprocs+0x92>
8000ace8:	e6 f8 00 80 	ld.w	r8,r3[128]
8000acec:	02 38       	cp.w	r8,r1
8000acee:	c2 a1       	brne	8000ad42 <__call_exitprocs+0x92>
8000acf0:	6e 19       	ld.w	r9,r7[0x4]
8000acf2:	64 08       	ld.w	r8,r2[0x0]
8000acf4:	20 19       	sub	r9,1
8000acf6:	12 35       	cp.w	r5,r9
8000acf8:	ef f5 0a 01 	st.weq	r7[0x4],r5
8000acfc:	f9 b9 01 00 	movne	r9,0
8000ad00:	e5 f9 1a 00 	st.wne	r2[0x0],r9
8000ad04:	58 08       	cp.w	r8,0
8000ad06:	c1 e0       	breq	8000ad42 <__call_exitprocs+0x92>
8000ad08:	6e 10       	ld.w	r0,r7[0x4]
8000ad0a:	58 06       	cp.w	r6,0
8000ad0c:	c0 90       	breq	8000ad1e <__call_exitprocs+0x6e>
8000ad0e:	30 1a       	mov	r10,1
8000ad10:	f4 05 09 49 	lsl	r9,r10,r5
8000ad14:	ec fa 01 00 	ld.w	r10,r6[256]
8000ad18:	f3 ea 00 0a 	and	r10,r9,r10
8000ad1c:	c0 31       	brne	8000ad22 <__call_exitprocs+0x72>
8000ad1e:	5d 18       	icall	r8
8000ad20:	c0 b8       	rjmp	8000ad36 <__call_exitprocs+0x86>
8000ad22:	ec fa 01 04 	ld.w	r10,r6[260]
8000ad26:	66 0b       	ld.w	r11,r3[0x0]
8000ad28:	14 69       	and	r9,r10
8000ad2a:	c0 41       	brne	8000ad32 <__call_exitprocs+0x82>
8000ad2c:	40 2c       	lddsp	r12,sp[0x8]
8000ad2e:	5d 18       	icall	r8
8000ad30:	c0 38       	rjmp	8000ad36 <__call_exitprocs+0x86>
8000ad32:	16 9c       	mov	r12,r11
8000ad34:	5d 18       	icall	r8
8000ad36:	6e 18       	ld.w	r8,r7[0x4]
8000ad38:	10 30       	cp.w	r0,r8
8000ad3a:	cc 41       	brne	8000acc2 <__call_exitprocs+0x12>
8000ad3c:	68 08       	ld.w	r8,r4[0x0]
8000ad3e:	0e 38       	cp.w	r8,r7
8000ad40:	cc 11       	brne	8000acc2 <__call_exitprocs+0x12>
8000ad42:	20 15       	sub	r5,1
8000ad44:	20 43       	sub	r3,4
8000ad46:	20 42       	sub	r2,4
8000ad48:	58 05       	cp.w	r5,0
8000ad4a:	cc b4       	brge	8000ace0 <__call_exitprocs+0x30>
8000ad4c:	6e 18       	ld.w	r8,r7[0x4]
8000ad4e:	58 08       	cp.w	r8,0
8000ad50:	c0 f1       	brne	8000ad6e <__call_exitprocs+0xbe>
8000ad52:	6e 08       	ld.w	r8,r7[0x0]
8000ad54:	58 08       	cp.w	r8,0
8000ad56:	c0 c0       	breq	8000ad6e <__call_exitprocs+0xbe>
8000ad58:	89 08       	st.w	r4[0x0],r8
8000ad5a:	58 06       	cp.w	r6,0
8000ad5c:	c0 40       	breq	8000ad64 <__call_exitprocs+0xb4>
8000ad5e:	0c 9c       	mov	r12,r6
8000ad60:	fe b0 fc 3e 	rcall	8000a5dc <free>
8000ad64:	0e 9c       	mov	r12,r7
8000ad66:	fe b0 fc 3b 	rcall	8000a5dc <free>
8000ad6a:	68 07       	ld.w	r7,r4[0x0]
8000ad6c:	c0 38       	rjmp	8000ad72 <__call_exitprocs+0xc2>
8000ad6e:	0e 94       	mov	r4,r7
8000ad70:	6e 07       	ld.w	r7,r7[0x0]
8000ad72:	58 07       	cp.w	r7,0
8000ad74:	ca b1       	brne	8000acca <__call_exitprocs+0x1a>
8000ad76:	2f dd       	sub	sp,-12
8000ad78:	d8 32       	popm	r0-r7,pc
8000ad7a:	d7 03       	nop
8000ad7c:	80 01       	ld.sh	r1,r0[0x0]
8000ad7e:	53 74       	stdsp	sp[0xdc],r4

8000ad80 <__errno>:
8000ad80:	e0 68 01 24 	mov	r8,292
8000ad84:	70 0c       	ld.w	r12,r8[0x0]
8000ad86:	2f 4c       	sub	r12,-12
8000ad88:	5e fc       	retal	r12
8000ad8a:	d7 03       	nop

8000ad8c <_malloc_trim_r>:
8000ad8c:	d4 21       	pushm	r4-r7,lr
8000ad8e:	16 95       	mov	r5,r11
8000ad90:	18 97       	mov	r7,r12
8000ad92:	fe b0 e3 7f 	rcall	80007490 <__malloc_lock>
8000ad96:	e0 64 01 28 	mov	r4,296
8000ad9a:	68 28       	ld.w	r8,r4[0x8]
8000ad9c:	70 16       	ld.w	r6,r8[0x4]
8000ad9e:	e0 16 ff fc 	andl	r6,0xfffc
8000ada2:	ec c8 ff 91 	sub	r8,r6,-111
8000ada6:	f0 05 01 05 	sub	r5,r8,r5
8000adaa:	e0 15 ff 80 	andl	r5,0xff80
8000adae:	ea c5 00 80 	sub	r5,r5,128
8000adb2:	e0 45 00 7f 	cp.w	r5,127
8000adb6:	e0 8a 00 22 	brle	8000adfa <_malloc_trim_r+0x6e>
8000adba:	30 0b       	mov	r11,0
8000adbc:	0e 9c       	mov	r12,r7
8000adbe:	ce 5e       	rcall	8000ab88 <_sbrk_r>
8000adc0:	68 28       	ld.w	r8,r4[0x8]
8000adc2:	0c 08       	add	r8,r6
8000adc4:	10 3c       	cp.w	r12,r8
8000adc6:	c1 a1       	brne	8000adfa <_malloc_trim_r+0x6e>
8000adc8:	ea 0b 11 00 	rsub	r11,r5,0
8000adcc:	0e 9c       	mov	r12,r7
8000adce:	cd de       	rcall	8000ab88 <_sbrk_r>
8000add0:	5b fc       	cp.w	r12,-1
8000add2:	c1 81       	brne	8000ae02 <_malloc_trim_r+0x76>
8000add4:	30 0b       	mov	r11,0
8000add6:	0e 9c       	mov	r12,r7
8000add8:	cd 8e       	rcall	8000ab88 <_sbrk_r>
8000adda:	68 28       	ld.w	r8,r4[0x8]
8000addc:	f8 08 01 09 	sub	r9,r12,r8
8000ade0:	58 f9       	cp.w	r9,15
8000ade2:	e0 8a 00 0c 	brle	8000adfa <_malloc_trim_r+0x6e>
8000ade6:	a1 a9       	sbr	r9,0x0
8000ade8:	91 19       	st.w	r8[0x4],r9
8000adea:	e0 68 05 34 	mov	r8,1332
8000adee:	70 09       	ld.w	r9,r8[0x0]
8000adf0:	e0 68 11 2c 	mov	r8,4396
8000adf4:	f8 09 01 09 	sub	r9,r12,r9
8000adf8:	91 09       	st.w	r8[0x0],r9
8000adfa:	0e 9c       	mov	r12,r7
8000adfc:	fe b0 e3 50 	rcall	8000749c <__malloc_unlock>
8000ae00:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae02:	68 28       	ld.w	r8,r4[0x8]
8000ae04:	0a 16       	sub	r6,r5
8000ae06:	a1 a6       	sbr	r6,0x0
8000ae08:	91 16       	st.w	r8[0x4],r6
8000ae0a:	e0 68 11 2c 	mov	r8,4396
8000ae0e:	70 09       	ld.w	r9,r8[0x0]
8000ae10:	0a 19       	sub	r9,r5
8000ae12:	0e 9c       	mov	r12,r7
8000ae14:	91 09       	st.w	r8[0x0],r9
8000ae16:	fe b0 e3 43 	rcall	8000749c <__malloc_unlock>
8000ae1a:	da 2a       	popm	r4-r7,pc,r12=1

8000ae1c <_free_r>:
8000ae1c:	d4 21       	pushm	r4-r7,lr
8000ae1e:	16 96       	mov	r6,r11
8000ae20:	18 97       	mov	r7,r12
8000ae22:	58 0b       	cp.w	r11,0
8000ae24:	e0 80 00 c0 	breq	8000afa4 <_free_r+0x188>
8000ae28:	fe b0 e3 34 	rcall	80007490 <__malloc_lock>
8000ae2c:	20 86       	sub	r6,8
8000ae2e:	e0 6a 01 28 	mov	r10,296
8000ae32:	6c 18       	ld.w	r8,r6[0x4]
8000ae34:	74 2e       	ld.w	lr,r10[0x8]
8000ae36:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ae3a:	a1 c8       	cbr	r8,0x0
8000ae3c:	ec 08 00 09 	add	r9,r6,r8
8000ae40:	72 1b       	ld.w	r11,r9[0x4]
8000ae42:	e0 1b ff fc 	andl	r11,0xfffc
8000ae46:	1c 39       	cp.w	r9,lr
8000ae48:	c1 e1       	brne	8000ae84 <_free_r+0x68>
8000ae4a:	f6 08 00 08 	add	r8,r11,r8
8000ae4e:	58 0c       	cp.w	r12,0
8000ae50:	c0 81       	brne	8000ae60 <_free_r+0x44>
8000ae52:	6c 09       	ld.w	r9,r6[0x0]
8000ae54:	12 16       	sub	r6,r9
8000ae56:	12 08       	add	r8,r9
8000ae58:	6c 3b       	ld.w	r11,r6[0xc]
8000ae5a:	6c 29       	ld.w	r9,r6[0x8]
8000ae5c:	97 29       	st.w	r11[0x8],r9
8000ae5e:	93 3b       	st.w	r9[0xc],r11
8000ae60:	10 99       	mov	r9,r8
8000ae62:	95 26       	st.w	r10[0x8],r6
8000ae64:	a1 a9       	sbr	r9,0x0
8000ae66:	8d 19       	st.w	r6[0x4],r9
8000ae68:	e0 69 05 30 	mov	r9,1328
8000ae6c:	72 09       	ld.w	r9,r9[0x0]
8000ae6e:	12 38       	cp.w	r8,r9
8000ae70:	c0 63       	brcs	8000ae7c <_free_r+0x60>
8000ae72:	e0 68 11 28 	mov	r8,4392
8000ae76:	0e 9c       	mov	r12,r7
8000ae78:	70 0b       	ld.w	r11,r8[0x0]
8000ae7a:	c8 9f       	rcall	8000ad8c <_malloc_trim_r>
8000ae7c:	0e 9c       	mov	r12,r7
8000ae7e:	fe b0 e3 0f 	rcall	8000749c <__malloc_unlock>
8000ae82:	d8 22       	popm	r4-r7,pc
8000ae84:	93 1b       	st.w	r9[0x4],r11
8000ae86:	58 0c       	cp.w	r12,0
8000ae88:	c0 30       	breq	8000ae8e <_free_r+0x72>
8000ae8a:	30 0c       	mov	r12,0
8000ae8c:	c1 08       	rjmp	8000aeac <_free_r+0x90>
8000ae8e:	6c 0e       	ld.w	lr,r6[0x0]
8000ae90:	f4 c5 ff f8 	sub	r5,r10,-8
8000ae94:	1c 16       	sub	r6,lr
8000ae96:	1c 08       	add	r8,lr
8000ae98:	6c 2e       	ld.w	lr,r6[0x8]
8000ae9a:	0a 3e       	cp.w	lr,r5
8000ae9c:	f9 bc 00 01 	moveq	r12,1
8000aea0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aea4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000aea8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000aeac:	f2 0b 00 0e 	add	lr,r9,r11
8000aeb0:	7c 1e       	ld.w	lr,lr[0x4]
8000aeb2:	ed be 00 00 	bld	lr,0x0
8000aeb6:	c1 40       	breq	8000aede <_free_r+0xc2>
8000aeb8:	16 08       	add	r8,r11
8000aeba:	58 0c       	cp.w	r12,0
8000aebc:	c0 d1       	brne	8000aed6 <_free_r+0xba>
8000aebe:	e0 6e 01 28 	mov	lr,296
8000aec2:	72 2b       	ld.w	r11,r9[0x8]
8000aec4:	2f 8e       	sub	lr,-8
8000aec6:	1c 3b       	cp.w	r11,lr
8000aec8:	c0 71       	brne	8000aed6 <_free_r+0xba>
8000aeca:	97 36       	st.w	r11[0xc],r6
8000aecc:	97 26       	st.w	r11[0x8],r6
8000aece:	8d 2b       	st.w	r6[0x8],r11
8000aed0:	8d 3b       	st.w	r6[0xc],r11
8000aed2:	30 1c       	mov	r12,1
8000aed4:	c0 58       	rjmp	8000aede <_free_r+0xc2>
8000aed6:	72 2b       	ld.w	r11,r9[0x8]
8000aed8:	72 39       	ld.w	r9,r9[0xc]
8000aeda:	93 2b       	st.w	r9[0x8],r11
8000aedc:	97 39       	st.w	r11[0xc],r9
8000aede:	10 99       	mov	r9,r8
8000aee0:	ec 08 09 08 	st.w	r6[r8],r8
8000aee4:	a1 a9       	sbr	r9,0x0
8000aee6:	8d 19       	st.w	r6[0x4],r9
8000aee8:	58 0c       	cp.w	r12,0
8000aeea:	c5 a1       	brne	8000af9e <_free_r+0x182>
8000aeec:	e0 48 01 ff 	cp.w	r8,511
8000aef0:	e0 8b 00 13 	brhi	8000af16 <_free_r+0xfa>
8000aef4:	a3 98       	lsr	r8,0x3
8000aef6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000aefa:	72 2b       	ld.w	r11,r9[0x8]
8000aefc:	8d 39       	st.w	r6[0xc],r9
8000aefe:	8d 2b       	st.w	r6[0x8],r11
8000af00:	97 36       	st.w	r11[0xc],r6
8000af02:	93 26       	st.w	r9[0x8],r6
8000af04:	a3 48       	asr	r8,0x2
8000af06:	74 19       	ld.w	r9,r10[0x4]
8000af08:	30 1b       	mov	r11,1
8000af0a:	f6 08 09 48 	lsl	r8,r11,r8
8000af0e:	f3 e8 10 08 	or	r8,r9,r8
8000af12:	95 18       	st.w	r10[0x4],r8
8000af14:	c4 58       	rjmp	8000af9e <_free_r+0x182>
8000af16:	f0 0b 16 09 	lsr	r11,r8,0x9
8000af1a:	58 4b       	cp.w	r11,4
8000af1c:	e0 8b 00 06 	brhi	8000af28 <_free_r+0x10c>
8000af20:	f0 0b 16 06 	lsr	r11,r8,0x6
8000af24:	2c 8b       	sub	r11,-56
8000af26:	c2 08       	rjmp	8000af66 <_free_r+0x14a>
8000af28:	59 4b       	cp.w	r11,20
8000af2a:	e0 8b 00 04 	brhi	8000af32 <_free_r+0x116>
8000af2e:	2a 5b       	sub	r11,-91
8000af30:	c1 b8       	rjmp	8000af66 <_free_r+0x14a>
8000af32:	e0 4b 00 54 	cp.w	r11,84
8000af36:	e0 8b 00 06 	brhi	8000af42 <_free_r+0x126>
8000af3a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000af3e:	29 2b       	sub	r11,-110
8000af40:	c1 38       	rjmp	8000af66 <_free_r+0x14a>
8000af42:	e0 4b 01 54 	cp.w	r11,340
8000af46:	e0 8b 00 06 	brhi	8000af52 <_free_r+0x136>
8000af4a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000af4e:	28 9b       	sub	r11,-119
8000af50:	c0 b8       	rjmp	8000af66 <_free_r+0x14a>
8000af52:	e0 4b 05 54 	cp.w	r11,1364
8000af56:	e0 88 00 05 	brls	8000af60 <_free_r+0x144>
8000af5a:	37 eb       	mov	r11,126
8000af5c:	c0 58       	rjmp	8000af66 <_free_r+0x14a>
8000af5e:	d7 03       	nop
8000af60:	f0 0b 16 12 	lsr	r11,r8,0x12
8000af64:	28 4b       	sub	r11,-124
8000af66:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000af6a:	78 29       	ld.w	r9,r12[0x8]
8000af6c:	18 39       	cp.w	r9,r12
8000af6e:	c0 e1       	brne	8000af8a <_free_r+0x16e>
8000af70:	74 18       	ld.w	r8,r10[0x4]
8000af72:	a3 4b       	asr	r11,0x2
8000af74:	30 1c       	mov	r12,1
8000af76:	f8 0b 09 4b 	lsl	r11,r12,r11
8000af7a:	f1 eb 10 0b 	or	r11,r8,r11
8000af7e:	12 98       	mov	r8,r9
8000af80:	95 1b       	st.w	r10[0x4],r11
8000af82:	c0 a8       	rjmp	8000af96 <_free_r+0x17a>
8000af84:	72 29       	ld.w	r9,r9[0x8]
8000af86:	18 39       	cp.w	r9,r12
8000af88:	c0 60       	breq	8000af94 <_free_r+0x178>
8000af8a:	72 1a       	ld.w	r10,r9[0x4]
8000af8c:	e0 1a ff fc 	andl	r10,0xfffc
8000af90:	14 38       	cp.w	r8,r10
8000af92:	cf 93       	brcs	8000af84 <_free_r+0x168>
8000af94:	72 38       	ld.w	r8,r9[0xc]
8000af96:	8d 38       	st.w	r6[0xc],r8
8000af98:	8d 29       	st.w	r6[0x8],r9
8000af9a:	93 36       	st.w	r9[0xc],r6
8000af9c:	91 26       	st.w	r8[0x8],r6
8000af9e:	0e 9c       	mov	r12,r7
8000afa0:	fe b0 e2 7e 	rcall	8000749c <__malloc_unlock>
8000afa4:	d8 22       	popm	r4-r7,pc
8000afa6:	d7 03       	nop

8000afa8 <__do_global_ctors_aux>:
8000afa8:	d4 21       	pushm	r4-r7,lr
8000afaa:	30 c7       	mov	r7,12
8000afac:	c0 28       	rjmp	8000afb0 <__do_global_ctors_aux+0x8>
8000afae:	5d 18       	icall	r8
8000afb0:	20 47       	sub	r7,4
8000afb2:	6e 08       	ld.w	r8,r7[0x0]
8000afb4:	5b f8       	cp.w	r8,-1
8000afb6:	cf c1       	brne	8000afae <__do_global_ctors_aux+0x6>
8000afb8:	d8 22       	popm	r4-r7,pc
8000afba:	d7 03       	nop

Disassembly of section .exception:

8000b000 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000b000:	c0 08       	rjmp	8000b000 <_evba>
	...

8000b004 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000b004:	c0 08       	rjmp	8000b004 <_handle_TLB_Multiple_Hit>
	...

8000b008 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000b008:	c0 08       	rjmp	8000b008 <_handle_Bus_Error_Data_Fetch>
	...

8000b00c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000b00c:	c0 08       	rjmp	8000b00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000b010 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000b010:	c0 08       	rjmp	8000b010 <_handle_NMI>
	...

8000b014 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000b014:	c0 08       	rjmp	8000b014 <_handle_Instruction_Address>
	...

8000b018 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000b018:	c0 08       	rjmp	8000b018 <_handle_ITLB_Protection>
	...

8000b01c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000b01c:	c0 08       	rjmp	8000b01c <_handle_Breakpoint>
	...

8000b020 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000b020:	c0 08       	rjmp	8000b020 <_handle_Illegal_Opcode>
	...

8000b024 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000b024:	c0 08       	rjmp	8000b024 <_handle_Unimplemented_Instruction>
	...

8000b028 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000b028:	c0 08       	rjmp	8000b028 <_handle_Privilege_Violation>
	...

8000b02c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000b02c:	c0 08       	rjmp	8000b02c <_handle_Floating_Point>
	...

8000b030 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000b030:	c0 08       	rjmp	8000b030 <_handle_Coprocessor_Absent>
	...

8000b034 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000b034:	c0 08       	rjmp	8000b034 <_handle_Data_Address_Read>
	...

8000b038 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000b038:	c0 08       	rjmp	8000b038 <_handle_Data_Address_Write>
	...

8000b03c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000b03c:	c0 08       	rjmp	8000b03c <_handle_DTLB_Protection_Read>
	...

8000b040 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000b040:	c0 08       	rjmp	8000b040 <_handle_DTLB_Protection_Write>
	...

8000b044 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000b044:	c0 08       	rjmp	8000b044 <_handle_DTLB_Modified>
	...

8000b050 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000b050:	c0 08       	rjmp	8000b050 <_handle_ITLB_Miss>
	...

8000b060 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000b060:	c0 08       	rjmp	8000b060 <_handle_DTLB_Miss_Read>
	...

8000b070 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000b070:	c0 08       	rjmp	8000b070 <_handle_DTLB_Miss_Write>
	...

8000b100 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000b100:	fe cf 3d b8 	sub	pc,pc,15800

8000b104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000b104:	30 0c       	mov	r12,0
8000b106:	fe b0 f7 3b 	rcall	80009f7c <_get_interrupt_handler>
8000b10a:	58 0c       	cp.w	r12,0
8000b10c:	f8 0f 17 10 	movne	pc,r12
8000b110:	d6 03       	rete

8000b112 <_int1>:
8000b112:	30 1c       	mov	r12,1
8000b114:	fe b0 f7 34 	rcall	80009f7c <_get_interrupt_handler>
8000b118:	58 0c       	cp.w	r12,0
8000b11a:	f8 0f 17 10 	movne	pc,r12
8000b11e:	d6 03       	rete

8000b120 <_int2>:
8000b120:	30 2c       	mov	r12,2
8000b122:	fe b0 f7 2d 	rcall	80009f7c <_get_interrupt_handler>
8000b126:	58 0c       	cp.w	r12,0
8000b128:	f8 0f 17 10 	movne	pc,r12
8000b12c:	d6 03       	rete

8000b12e <_int3>:
8000b12e:	30 3c       	mov	r12,3
8000b130:	fe b0 f7 26 	rcall	80009f7c <_get_interrupt_handler>
8000b134:	58 0c       	cp.w	r12,0
8000b136:	f8 0f 17 10 	movne	pc,r12
8000b13a:	d6 03       	rete
8000b13c:	d7 03       	nop
8000b13e:	d7 03       	nop
8000b140:	d7 03       	nop
8000b142:	d7 03       	nop
8000b144:	d7 03       	nop
8000b146:	d7 03       	nop
8000b148:	d7 03       	nop
8000b14a:	d7 03       	nop
8000b14c:	d7 03       	nop
8000b14e:	d7 03       	nop
8000b150:	d7 03       	nop
8000b152:	d7 03       	nop
8000b154:	d7 03       	nop
8000b156:	d7 03       	nop
8000b158:	d7 03       	nop
8000b15a:	d7 03       	nop
8000b15c:	d7 03       	nop
8000b15e:	d7 03       	nop
8000b160:	d7 03       	nop
8000b162:	d7 03       	nop
8000b164:	d7 03       	nop
8000b166:	d7 03       	nop
8000b168:	d7 03       	nop
8000b16a:	d7 03       	nop
8000b16c:	d7 03       	nop
8000b16e:	d7 03       	nop
8000b170:	d7 03       	nop
8000b172:	d7 03       	nop
8000b174:	d7 03       	nop
8000b176:	d7 03       	nop
8000b178:	d7 03       	nop
8000b17a:	d7 03       	nop
8000b17c:	d7 03       	nop
8000b17e:	d7 03       	nop
8000b180:	d7 03       	nop
8000b182:	d7 03       	nop
8000b184:	d7 03       	nop
8000b186:	d7 03       	nop
8000b188:	d7 03       	nop
8000b18a:	d7 03       	nop
8000b18c:	d7 03       	nop
8000b18e:	d7 03       	nop
8000b190:	d7 03       	nop
8000b192:	d7 03       	nop
8000b194:	d7 03       	nop
8000b196:	d7 03       	nop
8000b198:	d7 03       	nop
8000b19a:	d7 03       	nop
8000b19c:	d7 03       	nop
8000b19e:	d7 03       	nop
8000b1a0:	d7 03       	nop
8000b1a2:	d7 03       	nop
8000b1a4:	d7 03       	nop
8000b1a6:	d7 03       	nop
8000b1a8:	d7 03       	nop
8000b1aa:	d7 03       	nop
8000b1ac:	d7 03       	nop
8000b1ae:	d7 03       	nop
8000b1b0:	d7 03       	nop
8000b1b2:	d7 03       	nop
8000b1b4:	d7 03       	nop
8000b1b6:	d7 03       	nop
8000b1b8:	d7 03       	nop
8000b1ba:	d7 03       	nop
8000b1bc:	d7 03       	nop
8000b1be:	d7 03       	nop
8000b1c0:	d7 03       	nop
8000b1c2:	d7 03       	nop
8000b1c4:	d7 03       	nop
8000b1c6:	d7 03       	nop
8000b1c8:	d7 03       	nop
8000b1ca:	d7 03       	nop
8000b1cc:	d7 03       	nop
8000b1ce:	d7 03       	nop
8000b1d0:	d7 03       	nop
8000b1d2:	d7 03       	nop
8000b1d4:	d7 03       	nop
8000b1d6:	d7 03       	nop
8000b1d8:	d7 03       	nop
8000b1da:	d7 03       	nop
8000b1dc:	d7 03       	nop
8000b1de:	d7 03       	nop
8000b1e0:	d7 03       	nop
8000b1e2:	d7 03       	nop
8000b1e4:	d7 03       	nop
8000b1e6:	d7 03       	nop
8000b1e8:	d7 03       	nop
8000b1ea:	d7 03       	nop
8000b1ec:	d7 03       	nop
8000b1ee:	d7 03       	nop
8000b1f0:	d7 03       	nop
8000b1f2:	d7 03       	nop
8000b1f4:	d7 03       	nop
8000b1f6:	d7 03       	nop
8000b1f8:	d7 03       	nop
8000b1fa:	d7 03       	nop
8000b1fc:	d7 03       	nop
8000b1fe:	d7 03       	nop

Disassembly of section .fini:

8000b200 <_fini>:
8000b200:	eb cd 40 40 	pushm	r6,lr
8000b204:	48 26       	lddpc	r6,8000b20c <_fini+0xc>
8000b206:	1e 26       	rsub	r6,pc
8000b208:	c0 48       	rjmp	8000b210 <_fini+0x10>
8000b20a:	d7 03       	nop
8000b20c:	80 00       	ld.sh	r0,r0[0x0]
8000b20e:	b1 ea       	*unknown*
8000b210:	fe b0 b7 3e 	rcall	8000208c <__do_global_dtors_aux>
8000b214:	e3 cd 80 40 	ldm	sp++,r6,pc
