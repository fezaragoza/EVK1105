
FreeRTOS_EVK1105Project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00007e00  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000a000  8000a000  0000a400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000a200  8000a200  0000a600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000988  8000a218  8000a218  0000a618  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8000aba0  0000b008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8000aba8  0000b010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8000abb0  0000b018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000abb4  0000b01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000518  0000001c  8000abb4  0000b01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00000abc  0000054c  0000054c  00000000  2**2
                  ALLOC
 14 .heap         0000dff8  00001008  00001008  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000b534  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00001a80  00000000  00000000  0000b568  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 0000464e  00000000  00000000  0000cfe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   0002774a  00000000  00000000  00011636  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00005ef8  00000000  00000000  00038d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   000161ad  00000000  00000000  0003ec78  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00004c50  00000000  00000000  00054e28  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00008d7d  00000000  00000000  00059a78  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000e557  00000000  00000000  000627f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 01d7051f  00000000  00000000  00070d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001d48  00000000  00000000  01de126b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 3e fb 	rcall	80009e14 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 38 	mov	r10,1336
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 10 08 	mov	r10,4104
8000204c:	e0 6c 05 38 	mov	r12,1336
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 26 6b 	rcall	80006d30 <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 39 d2 	rcall	80009404 <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 3c e2 	rcall	80009a2e <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 31 1d 	rcall	800082b4 <main>
8000207e:	e0 a0 39 cb 	rcall	80009414 <exit>
80002082:	d7 03       	nop
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ab a0       	sbr	r0,0xa
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	a2 00       	st.h	r1[0x0],r0

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 4c 	mov	r8,1356
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 50 	mov	r7,1360
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 4c 	mov	r8,1356
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <tpa6130_abdac_tx_pdca_int_handler>:
  .output_impedance    = TPA6130_OUTPUT_IMPEDANCE_DEFAULT,
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
800020e0:	d4 01       	pushm	lr
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
800020e2:	30 0c       	mov	r12,0
800020e4:	f0 1f 00 13 	mcall	80002130 <tpa6130_abdac_tx_pdca_int_handler+0x50>
800020e8:	e2 1c 00 02 	andl	r12,0x2,COH
800020ec:	c0 d0       	breq	80002106 <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
800020ee:	30 0c       	mov	r12,0
800020f0:	f0 1f 00 11 	mcall	80002134 <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
800020f4:	49 18       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
800020f6:	70 28       	ld.w	r8,r8[0x8]
800020f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800020fc:	c0 50       	breq	80002106 <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
800020fe:	48 f8       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002100:	70 18       	ld.w	r8,r8[0x4]
80002102:	30 1c       	mov	r12,1
80002104:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
80002106:	30 0c       	mov	r12,0
80002108:	f0 1f 00 0a 	mcall	80002130 <tpa6130_abdac_tx_pdca_int_handler+0x50>
8000210c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002110:	c0 d0       	breq	8000212a <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002112:	30 0c       	mov	r12,0
80002114:	f0 1f 00 0a 	mcall	8000213c <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002118:	48 88       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
8000211a:	70 28       	ld.w	r8,r8[0x8]
8000211c:	e2 18 00 02 	andl	r8,0x2,COH
80002120:	c0 50       	breq	8000212a <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
80002122:	48 68       	lddpc	r8,80002138 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002124:	70 18       	ld.w	r8,r8[0x4]
80002126:	30 2c       	mov	r12,2
80002128:	5d 18       	icall	r8
  }
}
8000212a:	d4 02       	popm	lr
8000212c:	d6 03       	rete
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	3f 10       	mov	r0,-15
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	3f 48       	mov	r8,-12
80002138:	00 00       	add	r0,r0
8000213a:	05 54       	ld.sh	r4,--r2
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	3f 20       	mov	r0,-14

80002140 <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80002140:	d4 21       	pushm	r4-r7,lr
80002142:	20 5d       	sub	sp,20
80002144:	18 94       	mov	r4,r12
80002146:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80002148:	f7 ec 10 88 	or	r8,r11,r12<<0x8
8000214c:	fb 58 00 12 	st.h	sp[18],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80002150:	30 08       	mov	r8,0
80002152:	30 09       	mov	r9,0
80002154:	fa e9 00 00 	st.d	sp[0],r8
80002158:	36 08       	mov	r8,96
8000215a:	ba 88       	st.b	sp[0x0],r8
8000215c:	fa c8 ff ee 	sub	r8,sp,-18
80002160:	50 28       	stdsp	sp[0x8],r8
80002162:	30 28       	mov	r8,2
80002164:	50 38       	stdsp	sp[0xc],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
80002166:	1a 96       	mov	r6,sp
80002168:	fe 77 2c 00 	mov	r7,-54272
8000216c:	1a 9b       	mov	r11,sp
8000216e:	0e 9c       	mov	r12,r7
80002170:	f0 1f 00 05 	mcall	80002184 <tpa6130_write_data+0x44>
  }
  while( twi_status != TWI_SUCCESS );
80002174:	cf c1       	brne	8000216c <tpa6130_write_data+0x2c>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
80002176:	48 58       	lddpc	r8,80002188 <tpa6130_write_data+0x48>
80002178:	f0 04 00 04 	add	r4,r8,r4
8000217c:	e9 65 ff ff 	st.b	r4[-1],r5
}
80002180:	2f bd       	sub	sp,-20
80002182:	d8 22       	popm	r4-r7,pc
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	43 d0       	lddsp	r0,sp[0xf4]
80002188:	00 00       	add	r0,r0
8000218a:	00 1c       	sub	r12,r0

8000218c <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
8000218c:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
8000218e:	33 f8       	mov	r8,63
80002190:	f0 0c 18 00 	cp.b	r12,r8
80002194:	e0 8a 00 04 	brle	8000219c <tpa6130_set_volume+0x10>
80002198:	33 fb       	mov	r11,63
8000219a:	c0 b8       	rjmp	800021b0 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
8000219c:	30 08       	mov	r8,0
8000219e:	f0 0c 18 00 	cp.b	r12,r8
800021a2:	e0 89 00 05 	brgt	800021ac <tpa6130_set_volume+0x20>
800021a6:	e0 6b 00 c0 	mov	r11,192
800021aa:	c0 38       	rjmp	800021b0 <tpa6130_set_volume+0x24>
800021ac:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
800021b0:	30 2c       	mov	r12,2
800021b2:	f0 1f 00 02 	mcall	800021b8 <tpa6130_set_volume+0x2c>
}
800021b6:	d8 02       	popm	pc
800021b8:	80 00       	ld.sh	r0,r0[0x0]
800021ba:	21 40       	sub	r0,20

800021bc <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
800021bc:	d4 01       	pushm	lr
800021be:	20 5d       	sub	sp,20
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
800021c0:	58 0b       	cp.w	r11,0
800021c2:	c0 90       	breq	800021d4 <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
800021c4:	48 f8       	lddpc	r8,80002200 <tpa6130_read_data+0x44>
800021c6:	f0 0c 00 0c 	add	r12,r8,r12
800021ca:	f9 38 ff ff 	ld.ub	r8,r12[-1]
800021ce:	fb 68 00 13 	st.b	sp[19],r8
800021d2:	c1 38       	rjmp	800021f8 <tpa6130_read_data+0x3c>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr[0] = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
800021d4:	30 08       	mov	r8,0
800021d6:	30 09       	mov	r9,0
800021d8:	fa e9 00 00 	st.d	sp[0],r8
800021dc:	36 08       	mov	r8,96
800021de:	ba 88       	st.b	sp[0x0],r8
800021e0:	ba 9c       	st.b	sp[0x1],r12
800021e2:	30 18       	mov	r8,1
800021e4:	50 18       	stdsp	sp[0x4],r8
800021e6:	fa c9 ff ed 	sub	r9,sp,-19
800021ea:	50 29       	stdsp	sp[0x8],r9
800021ec:	50 38       	stdsp	sp[0xc],r8
    twi_master_read(TPA6130_TWI, &twi_package);
800021ee:	1a 9b       	mov	r11,sp
800021f0:	fe 7c 2c 00 	mov	r12,-54272
800021f4:	f0 1f 00 04 	mcall	80002204 <tpa6130_read_data+0x48>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
800021f8:	fb 3c 00 13 	ld.ub	r12,sp[19]
800021fc:	2f bd       	sub	sp,-20
800021fe:	d8 02       	popm	pc
80002200:	00 00       	add	r0,r0
80002202:	00 1c       	sub	r12,r0
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	44 a8       	lddsp	r8,sp[0x128]

80002208 <tpa6130_get_volume>:
/*! \brief Gets the current volume settings.
 *  \returns Current volume settings. Value is between 0 (-59dB) and
 *  63 (4dB).
 */
int8_t tpa6130_get_volume(void)
{
80002208:	d4 01       	pushm	lr
  return tpa6130_read_data(TPA6130_VOLUME_AND_MUTE, TWI_READ_SR);
8000220a:	30 1b       	mov	r11,1
8000220c:	30 2c       	mov	r12,2
8000220e:	f0 1f 00 03 	mcall	80002218 <tpa6130_get_volume+0x10>
}
80002212:	5c 5c       	castu.b	r12
80002214:	d8 02       	popm	pc
80002216:	00 00       	add	r0,r0
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	21 bc       	sub	r12,27

8000221c <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
8000221c:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
8000221e:	30 0b       	mov	r11,0
80002220:	30 1c       	mov	r12,1
80002222:	f0 1f 00 05 	mcall	80002234 <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
80002226:	18 9b       	mov	r11,r12
80002228:	e2 1b 00 fe 	andl	r11,0xfe,COH
8000222c:	30 1c       	mov	r12,1
8000222e:	f0 1f 00 03 	mcall	80002238 <tpa6130_powerup+0x1c>
}
80002232:	d8 02       	popm	pc
80002234:	80 00       	ld.sh	r0,r0[0x0]
80002236:	21 bc       	sub	r12,27
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	21 40       	sub	r0,20

8000223c <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
8000223c:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
8000223e:	30 0b       	mov	r11,0
80002240:	30 1c       	mov	r12,1
80002242:	f0 1f 00 05 	mcall	80002254 <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
80002246:	18 9b       	mov	r11,r12
80002248:	a1 ab       	sbr	r11,0x0
8000224a:	5c 5b       	castu.b	r11
8000224c:	30 1c       	mov	r12,1
8000224e:	f0 1f 00 03 	mcall	80002258 <tpa6130_shutdown+0x1c>
}
80002252:	d8 02       	popm	pc
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	21 bc       	sub	r12,27
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	21 40       	sub	r0,20

8000225c <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
8000225c:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
8000225e:	f0 1f 00 0b 	mcall	80002288 <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
80002262:	fe 7c 40 00 	mov	r12,-49152
80002266:	f0 1f 00 0a 	mcall	8000228c <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
8000226a:	30 0c       	mov	r12,0
8000226c:	f0 1f 00 09 	mcall	80002290 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
80002270:	30 4b       	mov	r11,4
80002272:	48 9c       	lddpc	r12,80002294 <tpa6130_dac_stop+0x38>
80002274:	f0 1f 00 09 	mcall	80002298 <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
80002278:	48 98       	lddpc	r8,8000229c <tpa6130_dac_stop+0x40>
8000227a:	30 09       	mov	r9,0
8000227c:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
8000227e:	30 09       	mov	r9,0
80002280:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
80002282:	91 29       	st.w	r8[0x8],r9
}
80002284:	d8 02       	popm	pc
80002286:	00 00       	add	r0,r0
80002288:	80 00       	ld.sh	r0,r0[0x0]
8000228a:	22 3c       	sub	r12,35
8000228c:	80 00       	ld.sh	r0,r0[0x0]
8000228e:	39 6c       	mov	r12,-106
80002290:	80 00       	ld.sh	r0,r0[0x0]
80002292:	3e f0       	mov	r0,-17
80002294:	80 00       	ld.sh	r0,r0[0x0]
80002296:	a2 30       	st.h	r1[0x6],r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	8c 28       	ld.sh	r8,r6[0x4]
8000229c:	00 00       	add	r0,r0
8000229e:	05 54       	ld.sh	r4,--r2

800022a0 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
800022a0:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
800022a2:	36 0b       	mov	r11,96
800022a4:	fe 7c 2c 00 	mov	r12,-54272
800022a8:	f0 1f 00 0e 	mcall	800022e0 <tpa6130_init+0x40>
800022ac:	c0 40       	breq	800022b4 <tpa6130_init+0x14>
800022ae:	e0 6c 00 fd 	mov	r12,253
800022b2:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
800022b4:	30 0b       	mov	r11,0
800022b6:	30 4c       	mov	r12,4
800022b8:	f0 1f 00 0b 	mcall	800022e4 <tpa6130_init+0x44>
800022bc:	30 28       	mov	r8,2
800022be:	f0 0c 18 00 	cp.b	r12,r8
800022c2:	c0 40       	breq	800022ca <tpa6130_init+0x2a>
800022c4:	e0 6c 00 f8 	mov	r12,248
800022c8:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
800022ca:	48 88       	lddpc	r8,800022e8 <tpa6130_init+0x48>
800022cc:	11 9b       	ld.ub	r11,r8[0x1]
800022ce:	30 2c       	mov	r12,2
800022d0:	f0 1f 00 07 	mcall	800022ec <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
800022d4:	e0 6b 00 c0 	mov	r11,192
800022d8:	30 1c       	mov	r12,1
800022da:	f0 1f 00 05 	mcall	800022ec <tpa6130_init+0x4c>
800022de:	d8 0a       	popm	pc,r12=0
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	44 80       	lddsp	r0,sp[0x120]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	21 bc       	sub	r12,27
800022e8:	00 00       	add	r0,r0
800022ea:	00 1c       	sub	r12,r0
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	21 40       	sub	r0,20

800022f0 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
800022f0:	eb cd 40 c0 	pushm	r6-r7,lr
800022f4:	20 6d       	sub	sp,24
800022f6:	18 97       	mov	r7,r12
800022f8:	12 96       	mov	r6,r9
800022fa:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
800022fc:	49 a9       	lddpc	r9,80002364 <tpa6130_dac_setup+0x74>
800022fe:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80002300:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
80002302:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
80002304:	f0 1f 00 19 	mcall	80002368 <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
80002308:	0e 9c       	mov	r12,r7
8000230a:	f0 1f 00 19 	mcall	8000236c <tpa6130_dac_setup+0x7c>
8000230e:	c0 a1       	brne	80002322 <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
80002310:	0e 9a       	mov	r10,r7
80002312:	e0 6b 44 00 	mov	r11,17408
80002316:	ea 1b 00 ac 	orh	r11,0xac
8000231a:	fe 7c 40 00 	mov	r12,-49152
8000231e:	f0 1f 00 15 	mcall	80002370 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
80002322:	58 06       	cp.w	r6,0
80002324:	c0 50       	breq	8000232e <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
80002326:	fe 7c 40 00 	mov	r12,-49152
8000232a:	f0 1f 00 13 	mcall	80002374 <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
8000232e:	fe 7c 40 00 	mov	r12,-49152
80002332:	f0 1f 00 12 	mcall	80002378 <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
80002336:	49 28       	lddpc	r8,8000237c <tpa6130_dac_setup+0x8c>
80002338:	1a 9b       	mov	r11,sp
8000233a:	f0 e6 00 00 	ld.d	r6,r8[0]
8000233e:	fa e7 00 00 	st.d	sp[0],r6
80002342:	f0 e6 00 08 	ld.d	r6,r8[8]
80002346:	fa e7 00 08 	st.d	sp[8],r6
8000234a:	f0 e8 00 10 	ld.d	r8,r8[16]
8000234e:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
80002352:	30 0c       	mov	r12,0
80002354:	f0 1f 00 0b 	mcall	80002380 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
80002358:	30 0c       	mov	r12,0
8000235a:	f0 1f 00 0b 	mcall	80002384 <tpa6130_dac_setup+0x94>

}
8000235e:	2f ad       	sub	sp,-24
80002360:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002364:	00 00       	add	r0,r0
80002366:	05 54       	ld.sh	r4,--r2
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	22 a0       	sub	r0,42
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	3a 18       	mov	r8,-95
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	39 9a       	mov	r10,-103
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	39 82       	mov	r2,-104
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	39 58       	mov	r8,-107
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	a2 18       	st.h	r1[0x2],r8
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	3f 70       	mov	r0,-9
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	3f 00       	mov	r0,-16

80002388 <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002388:	eb cd 40 fe 	pushm	r1-r7,lr
8000238c:	fa c4 ff e0 	sub	r4,sp,-32
80002390:	18 92       	mov	r2,r12
80002392:	16 93       	mov	r3,r11
80002394:	14 95       	mov	r5,r10
80002396:	12 97       	mov	r7,r9
80002398:	10 96       	mov	r6,r8
8000239a:	68 01       	ld.w	r1,r4[0x0]
8000239c:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
8000239e:	f0 1f 00 0d 	mcall	800023d0 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
800023a2:	30 4b       	mov	r11,4
800023a4:	48 cc       	lddpc	r12,800023d4 <tpa6130_dac_start+0x4c>
800023a6:	f0 1f 00 0d 	mcall	800023d8 <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
800023aa:	1a d4       	st.w	--sp,r4
800023ac:	1a d1       	st.w	--sp,r1
800023ae:	0c 98       	mov	r8,r6
800023b0:	0e 99       	mov	r9,r7
800023b2:	0a 9a       	mov	r10,r5
800023b4:	06 9b       	mov	r11,r3
800023b6:	04 9c       	mov	r12,r2
800023b8:	f0 1f 00 09 	mcall	800023dc <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
800023bc:	30 1a       	mov	r10,1
800023be:	36 0b       	mov	r11,96
800023c0:	48 8c       	lddpc	r12,800023e0 <tpa6130_dac_start+0x58>
800023c2:	f0 1f 00 09 	mcall	800023e4 <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
800023c6:	f0 1f 00 09 	mcall	800023e8 <tpa6130_dac_start+0x60>
800023ca:	2f ed       	sub	sp,-8

}
800023cc:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	22 5c       	sub	r12,37
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	a2 30       	st.h	r1[0x6],r0
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	8b e0       	st.w	r5[0x38],r0
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	22 f0       	sub	r0,47
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	20 e0       	sub	r0,14
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	8d 00       	st.w	r6[0x0],r0
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	22 1c       	sub	r12,33

800023ec <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
800023ec:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023f0:	fc 1e c0 00 	movh	lr,0xc000
800023f4:	30 28       	mov	r8,2
800023f6:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023f8:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
800023fc:	fc 18 c0 20 	movh	r8,0xc020
80002400:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002402:	30 37       	mov	r7,3
80002404:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002406:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002408:	30 4c       	mov	r12,4
8000240a:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000240c:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80002410:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002412:	30 5c       	mov	r12,5
80002414:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002416:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002418:	30 6a       	mov	r10,6
8000241a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000241c:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80002420:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002422:	30 7a       	mov	r10,7
80002424:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002426:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002428:	30 8a       	mov	r10,8
8000242a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000242c:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80002430:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002432:	30 9a       	mov	r10,9
80002434:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002436:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80002438:	e3 cd 80 80 	ldm	sp++,r7,pc

8000243c <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000243c:	fc 19 c0 00 	movh	r9,0xc000
80002440:	30 28       	mov	r8,2
80002442:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002444:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80002448:	fc 18 c0 20 	movh	r8,0xc020
8000244c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000244e:	30 3a       	mov	r10,3
80002450:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002452:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002454:	30 6a       	mov	r10,6
80002456:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002458:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
8000245c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000245e:	30 7a       	mov	r10,7
80002460:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002462:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80002464:	5e fc       	retal	r12
80002466:	d7 03       	nop

80002468 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80002468:	eb cd 40 80 	pushm	r7,lr
8000246c:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
8000246e:	5c 7b       	castu.h	r11
80002470:	5c 7c       	castu.h	r12
80002472:	f0 1f 00 06 	mcall	80002488 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002476:	32 29       	mov	r9,34
80002478:	fc 18 c0 00 	movh	r8,0xc000
8000247c:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000247e:	fc 18 c0 20 	movh	r8,0xc020
80002482:	b0 07       	st.h	r8[0x0],r7
#endif

}
80002484:	e3 cd 80 80 	ldm	sp++,r7,pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	24 3c       	sub	r12,67

8000248c <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
8000248c:	d4 31       	pushm	r0-r7,lr
8000248e:	20 dd       	sub	sp,52
80002490:	18 97       	mov	r7,r12
80002492:	50 6b       	stdsp	sp[0x18],r11
80002494:	50 8a       	stdsp	sp[0x20],r10
80002496:	50 29       	stdsp	sp[0x8],r9
80002498:	10 94       	mov	r4,r8
8000249a:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
8000249c:	19 89       	ld.ub	r9,r12[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	e0 80 01 0c 	breq	800026bc <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800024a8:	16 98       	mov	r8,r11
800024aa:	11 3a       	ld.ub	r10,r8++
800024ac:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
800024ae:	11 89       	ld.ub	r9,r8[0x0]
800024b0:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
800024b2:	11 98       	ld.ub	r8,r8[0x1]
800024b4:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
800024b6:	5b f3       	cp.w	r3,-1
800024b8:	e0 81 00 8d 	brne	800025d2 <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800024bc:	e0 69 00 ef 	mov	r9,239
800024c0:	e0 6a 01 3f 	mov	r10,319
800024c4:	30 0b       	mov	r11,0
800024c6:	16 9c       	mov	r12,r11
800024c8:	f0 1f 00 7e 	mcall	800026c0 <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800024cc:	40 58       	lddsp	r8,sp[0x14]
800024ce:	50 c8       	stdsp	sp[0x30],r8
800024d0:	f0 08 00 18 	add	r8,r8,r8<<0x1
800024d4:	a5 78       	lsl	r8,0x5
800024d6:	40 69       	lddsp	r9,sp[0x18]
800024d8:	10 09       	add	r9,r8
800024da:	50 b9       	stdsp	sp[0x2c],r9
800024dc:	ee c8 ff ff 	sub	r8,r7,-1
800024e0:	50 98       	stdsp	sp[0x24],r8
800024e2:	40 8a       	lddsp	r10,sp[0x20]
800024e4:	5c 8a       	casts.h	r10
800024e6:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
800024e8:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800024ea:	08 90       	mov	r0,r4
800024ec:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
800024ee:	40 99       	lddsp	r9,sp[0x24]
800024f0:	f3 38 ff ff 	ld.ub	r8,r9[-1]
800024f4:	30 aa       	mov	r10,10
800024f6:	f4 08 18 00 	cp.b	r8,r10
800024fa:	c0 b1       	brne	80002510 <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
800024fc:	40 28       	lddsp	r8,sp[0x8]
800024fe:	40 39       	lddsp	r9,sp[0xc]
80002500:	12 08       	add	r8,r9
80002502:	5c 88       	casts.h	r8
80002504:	50 28       	stdsp	sp[0x8],r8
80002506:	40 98       	lddsp	r8,sp[0x24]
80002508:	40 8a       	lddsp	r10,sp[0x20]
8000250a:	5c 8a       	casts.h	r10
8000250c:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000250e:	c5 a8       	rjmp	800025c2 <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
80002510:	30 99       	mov	r9,9
80002512:	f2 08 18 00 	cp.b	r8,r9
80002516:	c0 81       	brne	80002526 <et024006_PrintString+0x9a>
        x += xfont;
80002518:	40 a8       	lddsp	r8,sp[0x28]
8000251a:	40 49       	lddsp	r9,sp[0x10]
8000251c:	12 08       	add	r8,r9
8000251e:	5c 88       	casts.h	r8
80002520:	50 a8       	stdsp	sp[0x28],r8
80002522:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80002524:	c4 f8       	rjmp	800025c2 <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80002526:	f0 ca 00 20 	sub	r10,r8,32
8000252a:	35 f9       	mov	r9,95
8000252c:	f2 0a 18 00 	cp.b	r10,r9
80002530:	e0 88 00 04 	brls	80002538 <et024006_PrintString+0xac>
80002534:	40 b5       	lddsp	r5,sp[0x2c]
80002536:	c0 a8       	rjmp	8000254a <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80002538:	22 08       	sub	r8,32
8000253a:	40 ca       	lddsp	r10,sp[0x30]
8000253c:	f0 0a 02 45 	mul	r5,r8,r10
80002540:	40 59       	lddsp	r9,sp[0x14]
80002542:	12 05       	add	r5,r9
80002544:	40 68       	lddsp	r8,sp[0x18]
80002546:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000254a:	40 22       	lddsp	r2,sp[0x8]
8000254c:	5c 72       	castu.h	r2
8000254e:	40 3a       	lddsp	r10,sp[0xc]
80002550:	e4 0a 00 0a 	add	r10,r2,r10
80002554:	50 1a       	stdsp	sp[0x4],r10
80002556:	04 3a       	cp.w	r10,r2
80002558:	e0 8a 00 2f 	brle	800025b6 <et024006_PrintString+0x12a>
8000255c:	40 21       	lddsp	r1,sp[0x8]
8000255e:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80002560:	40 a9       	lddsp	r9,sp[0x28]
80002562:	5c 79       	castu.h	r9
80002564:	50 09       	stdsp	sp[0x0],r9
80002566:	12 94       	mov	r4,r9
80002568:	40 48       	lddsp	r8,sp[0x10]
8000256a:	10 04       	add	r4,r8
8000256c:	40 aa       	lddsp	r10,sp[0x28]
8000256e:	5c 8a       	casts.h	r10
80002570:	50 7a       	stdsp	sp[0x1c],r10
80002572:	c1 b8       	rjmp	800025a8 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80002574:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002576:	0b 88       	ld.ub	r8,r5[0x0]
80002578:	ed e8 00 08 	and	r8,r6,r8
8000257c:	e6 08 18 00 	cp.b	r8,r3
80002580:	c0 50       	breq	8000258a <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
80002582:	00 9a       	mov	r10,r0
80002584:	04 9b       	mov	r11,r2
80002586:	f0 1f 00 50 	mcall	800026c4 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
8000258a:	2f f7       	sub	r7,-1
8000258c:	5c 87       	casts.h	r7
8000258e:	0e 9c       	mov	r12,r7
80002590:	5c 7c       	castu.h	r12
80002592:	08 3c       	cp.w	r12,r4
80002594:	cf 05       	brlt	80002574 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80002596:	2f f1       	sub	r1,-1
80002598:	5c 81       	casts.h	r1
8000259a:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
8000259e:	40 19       	lddsp	r9,sp[0x4]
800025a0:	04 39       	cp.w	r9,r2
800025a2:	e0 8a 00 0a 	brle	800025b6 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800025a6:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800025a8:	40 0c       	lddsp	r12,sp[0x0]
800025aa:	08 3c       	cp.w	r12,r4
800025ac:	cf 54       	brge	80002596 <et024006_PrintString+0x10a>
800025ae:	40 77       	lddsp	r7,sp[0x1c]
800025b0:	e0 66 00 80 	mov	r6,128
800025b4:	ce 1b       	rjmp	80002576 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800025b6:	40 a8       	lddsp	r8,sp[0x28]
800025b8:	40 4a       	lddsp	r10,sp[0x10]
800025ba:	14 08       	add	r8,r10
800025bc:	5c 88       	casts.h	r8
800025be:	50 a8       	stdsp	sp[0x28],r8
800025c0:	40 98       	lddsp	r8,sp[0x24]
800025c2:	40 99       	lddsp	r9,sp[0x24]
800025c4:	2f f9       	sub	r9,-1
800025c6:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800025c8:	11 88       	ld.ub	r8,r8[0x0]
800025ca:	e6 08 18 00 	cp.b	r8,r3
800025ce:	c9 01       	brne	800024ee <et024006_PrintString+0x62>
800025d0:	c7 68       	rjmp	800026bc <et024006_PrintString+0x230>
800025d2:	f8 c8 ff ff 	sub	r8,r12,-1
800025d6:	50 08       	stdsp	sp[0x0],r8
800025d8:	40 8c       	lddsp	r12,sp[0x20]
800025da:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800025dc:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800025de:	5c 83       	casts.h	r3
800025e0:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
800025e4:	40 0a       	lddsp	r10,sp[0x0]
800025e6:	f5 31 ff ff 	ld.ub	r1,r10[-1]
800025ea:	30 a8       	mov	r8,10
800025ec:	f0 01 18 00 	cp.b	r1,r8
800025f0:	c0 b1       	brne	80002606 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
800025f2:	40 28       	lddsp	r8,sp[0x8]
800025f4:	40 39       	lddsp	r9,sp[0xc]
800025f6:	12 08       	add	r8,r9
800025f8:	5c 88       	casts.h	r8
800025fa:	50 28       	stdsp	sp[0x8],r8
800025fc:	14 98       	mov	r8,r10
800025fe:	40 8a       	lddsp	r10,sp[0x20]
80002600:	5c 8a       	casts.h	r10
80002602:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80002604:	c5 28       	rjmp	800026a8 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80002606:	30 98       	mov	r8,9
80002608:	f0 01 18 00 	cp.b	r1,r8
8000260c:	c0 71       	brne	8000261a <et024006_PrintString+0x18e>
        x += xfont;
8000260e:	40 49       	lddsp	r9,sp[0x10]
80002610:	12 0c       	add	r12,r9
80002612:	5c 8c       	casts.h	r12
80002614:	50 1c       	stdsp	sp[0x4],r12
80002616:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
80002618:	c4 88       	rjmp	800026a8 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000261a:	40 32       	lddsp	r2,sp[0xc]
8000261c:	40 47       	lddsp	r7,sp[0x10]
8000261e:	f8 07 00 08 	add	r8,r12,r7
80002622:	5c 88       	casts.h	r8
80002624:	50 18       	stdsp	sp[0x4],r8
80002626:	04 99       	mov	r9,r2
80002628:	20 19       	sub	r9,1
8000262a:	40 28       	lddsp	r8,sp[0x8]
8000262c:	10 09       	add	r9,r8
8000262e:	40 1a       	lddsp	r10,sp[0x4]
80002630:	20 1a       	sub	r10,1
80002632:	5c 79       	castu.h	r9
80002634:	5c 7a       	castu.h	r10
80002636:	10 9b       	mov	r11,r8
80002638:	5c 7b       	castu.h	r11
8000263a:	5c 7c       	castu.h	r12
8000263c:	f0 1f 00 21 	mcall	800026c0 <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002640:	32 29       	mov	r9,34
80002642:	fc 18 c0 00 	movh	r8,0xc000
80002646:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80002648:	40 3a       	lddsp	r10,sp[0xc]
8000264a:	58 0a       	cp.w	r10,0
8000264c:	c2 d0       	breq	800026a6 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
8000264e:	e2 ce 00 20 	sub	lr,r1,32
80002652:	40 59       	lddsp	r9,sp[0x14]
80002654:	f2 0e 02 4e 	mul	lr,r9,lr
80002658:	12 0e       	add	lr,r9
8000265a:	40 68       	lddsp	r8,sp[0x18]
8000265c:	f0 0e 00 0e 	add	lr,r8,lr
80002660:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80002662:	e0 60 00 80 	mov	r0,128
80002666:	18 91       	mov	r1,r12
80002668:	c1 98       	rjmp	8000269a <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
8000266a:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000266c:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
80002670:	ec 0a 18 00 	cp.b	r10,r6
80002674:	e8 0a 17 10 	movne	r10,r4
80002678:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000267c:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80002680:	2f f8       	sub	r8,-1
80002682:	5c 88       	casts.h	r8
80002684:	f0 07 19 00 	cp.h	r7,r8
80002688:	fe 9b ff f1 	brhi	8000266a <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
8000268c:	2f fc       	sub	r12,-1
8000268e:	5c 8c       	casts.h	r12
80002690:	f8 02 19 00 	cp.h	r2,r12
80002694:	e0 88 00 09 	brls	800026a6 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
80002698:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
8000269a:	58 07       	cp.w	r7,0
8000269c:	cf 80       	breq	8000268c <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
8000269e:	1d 8b       	ld.ub	r11,lr[0x0]
800026a0:	00 99       	mov	r9,r0
800026a2:	02 98       	mov	r8,r1
800026a4:	ce 4b       	rjmp	8000266c <et024006_PrintString+0x1e0>
800026a6:	40 08       	lddsp	r8,sp[0x0]
800026a8:	40 09       	lddsp	r9,sp[0x0]
800026aa:	2f f9       	sub	r9,-1
800026ac:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800026ae:	11 88       	ld.ub	r8,r8[0x0]
800026b0:	ec 08 18 00 	cp.b	r8,r6
800026b4:	c0 40       	breq	800026bc <et024006_PrintString+0x230>
800026b6:	40 1c       	lddsp	r12,sp[0x4]
800026b8:	5c 8c       	casts.h	r12
800026ba:	c9 5b       	rjmp	800025e4 <et024006_PrintString+0x158>
  }
}
800026bc:	2f 3d       	sub	sp,-52
800026be:	d8 32       	popm	r0-r7,pc
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	23 ec       	sub	r12,62
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	24 68       	sub	r8,70

800026c8 <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026c8:	32 29       	mov	r9,34
800026ca:	fc 18 c0 00 	movh	r8,0xc000
800026ce:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800026d0:	58 7b       	cp.w	r11,7
800026d2:	e0 88 00 13 	brls	800026f8 <et024006_DuplicatePixel+0x30>
800026d6:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
800026d8:	fc 18 c0 20 	movh	r8,0xc020
800026dc:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026de:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026e0:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026e2:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026e4:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026e6:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026e8:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800026ea:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
800026ec:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800026ee:	58 79       	cp.w	r9,7
800026f0:	fe 9b ff f6 	brhi	800026dc <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
800026f4:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
800026f8:	58 0b       	cp.w	r11,0
800026fa:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
800026fc:	fc 18 c0 20 	movh	r8,0xc020
80002700:	b0 0c       	st.h	r8[0x0],r12
    --count;
80002702:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002704:	cf e1       	brne	80002700 <et024006_DuplicatePixel+0x38>
80002706:	5e fc       	retal	r12

80002708 <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80002708:	eb cd 40 e0 	pushm	r5-r7,lr
8000270c:	14 97       	mov	r7,r10
8000270e:	12 96       	mov	r6,r9
80002710:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80002712:	f6 c9 00 01 	sub	r9,r11,1
80002716:	0c 09       	add	r9,r6
80002718:	f8 ca 00 01 	sub	r10,r12,1
8000271c:	0e 0a       	add	r10,r7
8000271e:	5c 79       	castu.h	r9
80002720:	5c 7a       	castu.h	r10
80002722:	5c 7b       	castu.h	r11
80002724:	5c 7c       	castu.h	r12
80002726:	f0 1f 00 07 	mcall	80002740 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000272a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000272e:	5c 77       	castu.h	r7
80002730:	af 3b       	mul	r11,r7
80002732:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80002736:	f0 1f 00 04 	mcall	80002744 <et024006_DrawFilledRect+0x3c>
}
8000273a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000273e:	00 00       	add	r0,r0
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	23 ec       	sub	r12,62
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	26 c8       	sub	r8,108

80002748 <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002748:	fc 19 c0 00 	movh	r9,0xc000
8000274c:	34 6a       	mov	r10,70
8000274e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002750:	fc 18 c0 20 	movh	r8,0xc020
80002754:	e0 6b 00 94 	mov	r11,148
80002758:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000275a:	34 7b       	mov	r11,71
8000275c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000275e:	34 1b       	mov	r11,65
80002760:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002762:	34 8b       	mov	r11,72
80002764:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002766:	30 0b       	mov	r11,0
80002768:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000276a:	34 9b       	mov	r11,73
8000276c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000276e:	33 3b       	mov	r11,51
80002770:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002772:	34 ab       	mov	r11,74
80002774:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002776:	32 5b       	mov	r11,37
80002778:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000277a:	34 bb       	mov	r11,75
8000277c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000277e:	34 5b       	mov	r11,69
80002780:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002782:	34 cb       	mov	r11,76
80002784:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002786:	34 4b       	mov	r11,68
80002788:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000278a:	34 db       	mov	r11,77
8000278c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000278e:	37 7b       	mov	r11,119
80002790:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002792:	34 eb       	mov	r11,78
80002794:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002796:	31 2b       	mov	r11,18
80002798:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000279a:	34 fb       	mov	r11,79
8000279c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000279e:	e0 6b 00 cc 	mov	r11,204
800027a2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027a4:	35 0b       	mov	r11,80
800027a6:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027a8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027aa:	35 1a       	mov	r10,81
800027ac:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027ae:	e0 69 00 82 	mov	r9,130
800027b2:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
800027b4:	5e fc       	retal	r12
800027b6:	d7 03       	nop

800027b8 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
800027b8:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
800027bc:	fe f7 04 80 	ld.w	r7,pc[1152]
800027c0:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
800027c2:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
800027c4:	16 9c       	mov	r12,r11
800027c6:	f0 1f 01 1f 	mcall	80002c40 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
800027ca:	35 5c       	mov	r12,85
800027cc:	f0 1f 01 1e 	mcall	80002c44 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
800027d0:	30 2b       	mov	r11,2
800027d2:	33 2c       	mov	r12,50
800027d4:	f0 1f 01 1d 	mcall	80002c48 <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800027d8:	35 2c       	mov	r12,82
800027da:	f0 1f 01 1d 	mcall	80002c4c <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
800027de:	35 2c       	mov	r12,82
800027e0:	f0 1f 01 1c 	mcall	80002c50 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800027e4:	6e 07       	ld.w	r7,r7[0x0]
800027e6:	33 28       	mov	r8,50
800027e8:	ee 08 06 46 	mulu.d	r6,r7,r8
800027ec:	ee 78 42 40 	mov	r8,1000000
800027f0:	30 09       	mov	r9,0
800027f2:	ee 7a 42 3f 	mov	r10,999999
800027f6:	30 0b       	mov	r11,0
800027f8:	ec 0a 00 0a 	add	r10,r6,r10
800027fc:	ee 0b 00 4b 	adc	r11,r7,r11
80002800:	f0 1f 01 15 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002804:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002808:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000280c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002810:	14 38       	cp.w	r8,r10
80002812:	e0 88 00 09 	brls	80002824 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002816:	12 38       	cp.w	r8,r9
80002818:	fe 98 ff fa 	brls	8000280c <et024006_Init+0x54>
8000281c:	12 3a       	cp.w	r10,r9
8000281e:	e0 83 00 a2 	brlo	80002962 <et024006_Init+0x1aa>
80002822:	cf 5b       	rjmp	8000280c <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002824:	12 38       	cp.w	r8,r9
80002826:	e0 8b 00 9e 	brhi	80002962 <et024006_Init+0x1aa>
8000282a:	12 3a       	cp.w	r10,r9
8000282c:	e0 83 00 9b 	brlo	80002962 <et024006_Init+0x1aa>
80002830:	ce eb       	rjmp	8000280c <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002832:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002836:	14 38       	cp.w	r8,r10
80002838:	e0 88 00 09 	brls	8000284a <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000283c:	12 38       	cp.w	r8,r9
8000283e:	fe 98 ff fa 	brls	80002832 <et024006_Init+0x7a>
80002842:	12 3a       	cp.w	r10,r9
80002844:	e0 83 00 a9 	brlo	80002996 <et024006_Init+0x1de>
80002848:	cf 5b       	rjmp	80002832 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000284a:	12 38       	cp.w	r8,r9
8000284c:	e0 8b 00 a5 	brhi	80002996 <et024006_Init+0x1de>
80002850:	12 3a       	cp.w	r10,r9
80002852:	e0 83 00 a2 	brlo	80002996 <et024006_Init+0x1de>
80002856:	ce eb       	rjmp	80002832 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002858:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285c:	14 38       	cp.w	r8,r10
8000285e:	e0 88 00 09 	brls	80002870 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002862:	12 38       	cp.w	r8,r9
80002864:	fe 98 ff fa 	brls	80002858 <et024006_Init+0xa0>
80002868:	12 3a       	cp.w	r10,r9
8000286a:	e0 83 01 1e 	brlo	80002aa6 <et024006_Init+0x2ee>
8000286e:	cf 5b       	rjmp	80002858 <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002870:	12 38       	cp.w	r8,r9
80002872:	e0 8b 01 1a 	brhi	80002aa6 <et024006_Init+0x2ee>
80002876:	12 3a       	cp.w	r10,r9
80002878:	e0 83 01 17 	brlo	80002aa6 <et024006_Init+0x2ee>
8000287c:	ce eb       	rjmp	80002858 <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000287e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002882:	14 38       	cp.w	r8,r10
80002884:	e0 88 00 09 	brls	80002896 <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002888:	12 38       	cp.w	r8,r9
8000288a:	fe 98 ff fa 	brls	8000287e <et024006_Init+0xc6>
8000288e:	12 3a       	cp.w	r10,r9
80002890:	e0 83 01 29 	brlo	80002ae2 <et024006_Init+0x32a>
80002894:	cf 5b       	rjmp	8000287e <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002896:	12 38       	cp.w	r8,r9
80002898:	e0 8b 01 25 	brhi	80002ae2 <et024006_Init+0x32a>
8000289c:	12 3a       	cp.w	r10,r9
8000289e:	e0 83 01 22 	brlo	80002ae2 <et024006_Init+0x32a>
800028a2:	ce eb       	rjmp	8000287e <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800028a4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800028a8:	14 38       	cp.w	r8,r10
800028aa:	e0 88 00 09 	brls	800028bc <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800028ae:	12 38       	cp.w	r8,r9
800028b0:	fe 98 ff fa 	brls	800028a4 <et024006_Init+0xec>
800028b4:	12 3a       	cp.w	r10,r9
800028b6:	e0 83 01 35 	brlo	80002b20 <et024006_Init+0x368>
800028ba:	cf 5b       	rjmp	800028a4 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028bc:	12 38       	cp.w	r8,r9
800028be:	e0 8b 01 31 	brhi	80002b20 <et024006_Init+0x368>
800028c2:	12 3a       	cp.w	r10,r9
800028c4:	e0 83 01 2e 	brlo	80002b20 <et024006_Init+0x368>
800028c8:	ce eb       	rjmp	800028a4 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800028ca:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800028ce:	14 38       	cp.w	r8,r10
800028d0:	e0 88 00 09 	brls	800028e2 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800028d4:	12 38       	cp.w	r8,r9
800028d6:	fe 98 ff fa 	brls	800028ca <et024006_Init+0x112>
800028da:	12 3a       	cp.w	r10,r9
800028dc:	e0 83 01 40 	brlo	80002b5c <et024006_Init+0x3a4>
800028e0:	cf 5b       	rjmp	800028ca <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028e2:	12 38       	cp.w	r8,r9
800028e4:	e0 8b 01 3c 	brhi	80002b5c <et024006_Init+0x3a4>
800028e8:	12 3a       	cp.w	r10,r9
800028ea:	e0 83 01 39 	brlo	80002b5c <et024006_Init+0x3a4>
800028ee:	ce eb       	rjmp	800028ca <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800028f0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800028f4:	14 38       	cp.w	r8,r10
800028f6:	e0 88 00 09 	brls	80002908 <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800028fa:	12 38       	cp.w	r8,r9
800028fc:	fe 98 ff fa 	brls	800028f0 <et024006_Init+0x138>
80002900:	12 3a       	cp.w	r10,r9
80002902:	e0 83 01 4b 	brlo	80002b98 <et024006_Init+0x3e0>
80002906:	cf 5b       	rjmp	800028f0 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002908:	12 38       	cp.w	r8,r9
8000290a:	e0 8b 01 47 	brhi	80002b98 <et024006_Init+0x3e0>
8000290e:	12 3a       	cp.w	r10,r9
80002910:	e0 83 01 44 	brlo	80002b98 <et024006_Init+0x3e0>
80002914:	ce eb       	rjmp	800028f0 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002916:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000291a:	14 38       	cp.w	r8,r10
8000291c:	e0 88 00 09 	brls	8000292e <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002920:	12 38       	cp.w	r8,r9
80002922:	fe 98 ff fa 	brls	80002916 <et024006_Init+0x15e>
80002926:	12 3a       	cp.w	r10,r9
80002928:	e0 83 01 56 	brlo	80002bd4 <et024006_Init+0x41c>
8000292c:	cf 5b       	rjmp	80002916 <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000292e:	12 38       	cp.w	r8,r9
80002930:	e0 8b 01 52 	brhi	80002bd4 <et024006_Init+0x41c>
80002934:	12 3a       	cp.w	r10,r9
80002936:	e0 83 01 4f 	brlo	80002bd4 <et024006_Init+0x41c>
8000293a:	ce eb       	rjmp	80002916 <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000293c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002940:	14 38       	cp.w	r8,r10
80002942:	e0 88 00 09 	brls	80002954 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002946:	12 38       	cp.w	r8,r9
80002948:	fe 98 ff fa 	brls	8000293c <et024006_Init+0x184>
8000294c:	12 3a       	cp.w	r10,r9
8000294e:	e0 83 01 64 	brlo	80002c16 <et024006_Init+0x45e>
80002952:	cf 5b       	rjmp	8000293c <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002954:	12 38       	cp.w	r8,r9
80002956:	e0 8b 01 60 	brhi	80002c16 <et024006_Init+0x45e>
8000295a:	12 3a       	cp.w	r10,r9
8000295c:	e0 83 01 5d 	brlo	80002c16 <et024006_Init+0x45e>
80002960:	ce eb       	rjmp	8000293c <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80002962:	35 2c       	mov	r12,82
80002964:	f0 1f 00 ba 	mcall	80002c4c <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002968:	fe f8 02 d4 	ld.w	r8,pc[724]
8000296c:	70 07       	ld.w	r7,r8[0x0]
8000296e:	30 58       	mov	r8,5
80002970:	ee 08 06 46 	mulu.d	r6,r7,r8
80002974:	e0 68 03 e8 	mov	r8,1000
80002978:	30 09       	mov	r9,0
8000297a:	e0 6a 03 e7 	mov	r10,999
8000297e:	30 0b       	mov	r11,0
80002980:	ec 0a 00 0a 	add	r10,r6,r10
80002984:	ee 0b 00 4b 	adc	r11,r7,r11
80002988:	f0 1f 00 b3 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000298c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002990:	f0 0a 00 0a 	add	r10,r8,r10
80002994:	c4 fb       	rjmp	80002832 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
80002996:	f0 1f 00 b1 	mcall	80002c58 <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000299a:	fc 19 c0 00 	movh	r9,0xc000
8000299e:	30 1a       	mov	r10,1
800029a0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029a2:	fc 18 c0 20 	movh	r8,0xc020
800029a6:	30 6b       	mov	r11,6
800029a8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029aa:	33 ab       	mov	r11,58
800029ac:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029ae:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029b0:	33 bb       	mov	r11,59
800029b2:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029b4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029b6:	33 ca       	mov	r10,60
800029b8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029ba:	e0 6a 00 f0 	mov	r10,240
800029be:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029c0:	33 db       	mov	r11,61
800029c2:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029c4:	30 07       	mov	r7,0
800029c6:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029c8:	33 eb       	mov	r11,62
800029ca:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029cc:	33 8b       	mov	r11,56
800029ce:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029d0:	34 0c       	mov	r12,64
800029d2:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029d4:	30 fe       	mov	lr,15
800029d6:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029d8:	34 1e       	mov	lr,65
800029da:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029dc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029de:	32 7a       	mov	r10,39
800029e0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029e2:	30 2a       	mov	r10,2
800029e4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029e6:	32 8e       	mov	lr,40
800029e8:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029ea:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029ec:	32 9e       	mov	lr,41
800029ee:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029f0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029f2:	32 ae       	mov	lr,42
800029f4:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029f6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029f8:	32 ce       	mov	lr,44
800029fa:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029fc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029fe:	32 de       	mov	lr,45
80002a00:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a02:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a04:	31 9a       	mov	r10,25
80002a06:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a08:	34 9a       	mov	r10,73
80002a0a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a0c:	e0 6a 00 93 	mov	r10,147
80002a10:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a12:	30 8a       	mov	r10,8
80002a14:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a16:	31 6a       	mov	r10,22
80002a18:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a1a:	36 8a       	mov	r10,104
80002a1c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a1e:	32 3a       	mov	r10,35
80002a20:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a22:	e0 6a 00 95 	mov	r10,149
80002a26:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a28:	32 4e       	mov	lr,36
80002a2a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a2c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a2e:	32 5a       	mov	r10,37
80002a30:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a32:	e0 6a 00 ff 	mov	r10,255
80002a36:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a38:	e0 6a 00 90 	mov	r10,144
80002a3c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a3e:	37 fa       	mov	r10,127
80002a40:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a42:	33 5a       	mov	r10,53
80002a44:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a46:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a48:	33 6a       	mov	r10,54
80002a4a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a4c:	37 8a       	mov	r10,120
80002a4e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a50:	31 da       	mov	r10,29
80002a52:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a54:	30 7a       	mov	r10,7
80002a56:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a58:	31 ea       	mov	r10,30
80002a5a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a5c:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a5e:	31 fa       	mov	r10,31
80002a60:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a62:	30 4a       	mov	r10,4
80002a64:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a66:	32 0a       	mov	r10,32
80002a68:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a6a:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a6c:	34 4a       	mov	r10,68
80002a6e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a70:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a72:	34 5a       	mov	r10,69
80002a74:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a76:	31 29       	mov	r9,18
80002a78:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a7a:	4f 18       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002a7c:	70 07       	ld.w	r7,r8[0x0]
80002a7e:	30 a8       	mov	r8,10
80002a80:	ee 08 06 46 	mulu.d	r6,r7,r8
80002a84:	e0 68 03 e8 	mov	r8,1000
80002a88:	30 09       	mov	r9,0
80002a8a:	e0 6a 03 e7 	mov	r10,999
80002a8e:	30 0b       	mov	r11,0
80002a90:	ec 0a 00 0a 	add	r10,r6,r10
80002a94:	ee 0b 00 4b 	adc	r11,r7,r11
80002a98:	f0 1f 00 6f 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002a9c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002aa0:	f0 0a 00 0a 	add	r10,r8,r10
80002aa4:	cd aa       	rjmp	80002858 <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002aa6:	31 c9       	mov	r9,28
80002aa8:	fc 18 c0 00 	movh	r8,0xc000
80002aac:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002aae:	30 49       	mov	r9,4
80002ab0:	fc 18 c0 20 	movh	r8,0xc020
80002ab4:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002ab6:	4e 28       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002ab8:	70 07       	ld.w	r7,r8[0x0]
80002aba:	31 48       	mov	r8,20
80002abc:	ee 08 06 46 	mulu.d	r6,r7,r8
80002ac0:	e0 68 03 e8 	mov	r8,1000
80002ac4:	30 09       	mov	r9,0
80002ac6:	e0 6a 03 e7 	mov	r10,999
80002aca:	30 0b       	mov	r11,0
80002acc:	ec 0a 00 0a 	add	r10,r6,r10
80002ad0:	ee 0b 00 4b 	adc	r11,r7,r11
80002ad4:	f0 1f 00 60 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ad8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002adc:	f0 0a 00 0a 	add	r10,r8,r10
80002ae0:	cc fa       	rjmp	8000287e <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002ae2:	34 39       	mov	r9,67
80002ae4:	fc 18 c0 00 	movh	r8,0xc000
80002ae8:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002aea:	e0 69 00 80 	mov	r9,128
80002aee:	fc 18 c0 20 	movh	r8,0xc020
80002af2:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002af4:	4d 28       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002af6:	70 07       	ld.w	r7,r8[0x0]
80002af8:	30 58       	mov	r8,5
80002afa:	ee 08 06 46 	mulu.d	r6,r7,r8
80002afe:	e0 68 03 e8 	mov	r8,1000
80002b02:	30 09       	mov	r9,0
80002b04:	e0 6a 03 e7 	mov	r10,999
80002b08:	30 0b       	mov	r11,0
80002b0a:	ec 0a 00 0a 	add	r10,r6,r10
80002b0e:	ee 0b 00 4b 	adc	r11,r7,r11
80002b12:	f0 1f 00 51 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002b16:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002b1a:	f0 0a 00 0a 	add	r10,r8,r10
80002b1e:	cc 3a       	rjmp	800028a4 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b20:	31 b9       	mov	r9,27
80002b22:	fc 18 c0 00 	movh	r8,0xc000
80002b26:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b28:	30 89       	mov	r9,8
80002b2a:	fc 18 c0 20 	movh	r8,0xc020
80002b2e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002b30:	4c 38       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002b32:	70 07       	ld.w	r7,r8[0x0]
80002b34:	32 88       	mov	r8,40
80002b36:	ee 08 06 46 	mulu.d	r6,r7,r8
80002b3a:	e0 68 03 e8 	mov	r8,1000
80002b3e:	30 09       	mov	r9,0
80002b40:	e0 6a 03 e7 	mov	r10,999
80002b44:	30 0b       	mov	r11,0
80002b46:	ec 0a 00 0a 	add	r10,r6,r10
80002b4a:	ee 0b 00 4b 	adc	r11,r7,r11
80002b4e:	f0 1f 00 42 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002b52:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002b56:	f0 0a 00 0a 	add	r10,r8,r10
80002b5a:	cb 8a       	rjmp	800028ca <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b5c:	31 b9       	mov	r9,27
80002b5e:	fc 18 c0 00 	movh	r8,0xc000
80002b62:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002b64:	31 09       	mov	r9,16
80002b66:	fc 18 c0 20 	movh	r8,0xc020
80002b6a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002b6c:	4b 48       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002b6e:	70 07       	ld.w	r7,r8[0x0]
80002b70:	32 88       	mov	r8,40
80002b72:	ee 08 06 46 	mulu.d	r6,r7,r8
80002b76:	e0 68 03 e8 	mov	r8,1000
80002b7a:	30 09       	mov	r9,0
80002b7c:	e0 6a 03 e7 	mov	r10,999
80002b80:	30 0b       	mov	r11,0
80002b82:	ec 0a 00 0a 	add	r10,r6,r10
80002b86:	ee 0b 00 4b 	adc	r11,r7,r11
80002b8a:	f0 1f 00 33 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002b8e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002b92:	f0 0a 00 0a 	add	r10,r8,r10
80002b96:	ca da       	rjmp	800028f0 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002b98:	32 69       	mov	r9,38
80002b9a:	fc 18 c0 00 	movh	r8,0xc000
80002b9e:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002ba0:	30 49       	mov	r9,4
80002ba2:	fc 18 c0 20 	movh	r8,0xc020
80002ba6:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002ba8:	4a 58       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002baa:	70 07       	ld.w	r7,r8[0x0]
80002bac:	32 88       	mov	r8,40
80002bae:	ee 08 06 46 	mulu.d	r6,r7,r8
80002bb2:	e0 68 03 e8 	mov	r8,1000
80002bb6:	30 09       	mov	r9,0
80002bb8:	e0 6a 03 e7 	mov	r10,999
80002bbc:	30 0b       	mov	r11,0
80002bbe:	ec 0a 00 0a 	add	r10,r6,r10
80002bc2:	ee 0b 00 4b 	adc	r11,r7,r11
80002bc6:	f0 1f 00 24 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002bca:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002bce:	f0 0a 00 0a 	add	r10,r8,r10
80002bd2:	ca 2a       	rjmp	80002916 <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002bd4:	fc 19 c0 00 	movh	r9,0xc000
80002bd8:	32 6a       	mov	r10,38
80002bda:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002bdc:	fc 18 c0 20 	movh	r8,0xc020
80002be0:	32 4b       	mov	r11,36
80002be2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002be4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002be6:	32 c9       	mov	r9,44
80002be8:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002bea:	49 58       	lddpc	r8,80002c3c <et024006_Init+0x484>
80002bec:	70 07       	ld.w	r7,r8[0x0]
80002bee:	32 88       	mov	r8,40
80002bf0:	ee 08 06 46 	mulu.d	r6,r7,r8
80002bf4:	e0 68 03 e8 	mov	r8,1000
80002bf8:	30 09       	mov	r9,0
80002bfa:	e0 6a 03 e7 	mov	r10,999
80002bfe:	30 0b       	mov	r11,0
80002c00:	ec 0a 00 0a 	add	r10,r6,r10
80002c04:	ee 0b 00 4b 	adc	r11,r7,r11
80002c08:	f0 1f 00 13 	mcall	80002c54 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002c0c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002c10:	f0 0a 00 0a 	add	r10,r8,r10
80002c14:	c9 4a       	rjmp	8000293c <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c16:	fc 19 c0 00 	movh	r9,0xc000
80002c1a:	32 68       	mov	r8,38
80002c1c:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c1e:	fc 18 c0 20 	movh	r8,0xc020
80002c22:	33 ca       	mov	r10,60
80002c24:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c26:	37 0a       	mov	r10,112
80002c28:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
80002c2a:	90 0b       	ld.sh	r11,r8[0x0]
80002c2c:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002c2e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002c30:	16 99       	mov	r9,r11
80002c32:	a3 b9       	sbr	r9,0x3
80002c34:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80002c36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c3a:	00 00       	add	r0,r0
80002c3c:	00 00       	add	r0,r0
80002c3e:	05 60       	ld.uh	r0,--r2
80002c40:	80 00       	ld.sh	r0,r0[0x0]
80002c42:	3d c0       	mov	r0,-36
80002c44:	80 00       	ld.sh	r0,r0[0x0]
80002c46:	8c 10       	ld.sh	r0,r6[0x2]
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	8b 8e       	st.w	r5[0x20],lr
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	8c 50       	ld.sh	r0,r6[0xa]
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	8c 6c       	ld.sh	r12,r6[0xc]
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	91 a0       	st.w	r8[0x28],r0
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	27 48       	sub	r8,116

80002c5c <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80002c5c:	d4 01       	pushm	lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80002c5e:	4c 18       	lddpc	r8,80002d60 <sd_mmc_spi_get_capacity+0x104>
80002c60:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
80002c62:	4c 18       	lddpc	r8,80002d64 <sd_mmc_spi_get_capacity+0x108>
80002c64:	11 8a       	ld.ub	r10,r8[0x0]
80002c66:	30 38       	mov	r8,3
80002c68:	f0 0a 18 00 	cp.b	r10,r8
80002c6c:	c2 71       	brne	80002cba <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80002c6e:	4b d8       	lddpc	r8,80002d60 <sd_mmc_spi_get_capacity+0x104>
80002c70:	f1 3a 00 08 	ld.ub	r10,r8[8]
80002c74:	f1 39 00 09 	ld.ub	r9,r8[9]
80002c78:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80002c7c:	11 fa       	ld.ub	r10,r8[0x7]
80002c7e:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
80002c82:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
80002c86:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
80002c88:	f4 0b 16 0d 	lsr	r11,r10,0xd
80002c8c:	16 99       	mov	r9,r11
80002c8e:	f4 08 15 13 	lsl	r8,r10,0x13
80002c92:	4b 6a       	lddpc	r10,80002d68 <sd_mmc_spi_get_capacity+0x10c>
80002c94:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
80002c98:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002c9c:	4b 48       	lddpc	r8,80002d6c <sd_mmc_spi_get_capacity+0x110>
80002c9e:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002ca0:	f4 ea 00 00 	ld.d	r10,r10[0]
80002ca4:	90 09       	ld.sh	r9,r8[0x0]
80002ca6:	f4 08 16 09 	lsr	r8,r10,0x9
80002caa:	f1 eb 11 78 	or	r8,r8,r11<<0x17
80002cae:	20 18       	sub	r8,1
80002cb0:	b7 79       	lsl	r9,0x17
80002cb2:	12 08       	add	r8,r9
80002cb4:	4a f9       	lddpc	r9,80002d70 <sd_mmc_spi_get_capacity+0x114>
80002cb6:	93 08       	st.w	r9[0x0],r8
80002cb8:	c4 28       	rjmp	80002d3c <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002cba:	4a a8       	lddpc	r8,80002d60 <sd_mmc_spi_get_capacity+0x104>
80002cbc:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002cc0:	f1 39 00 08 	ld.ub	r9,r8[8]
80002cc4:	a7 89       	lsr	r9,0x6
80002cc6:	11 fe       	ld.ub	lr,r8[0x7]
80002cc8:	f2 0e 00 29 	add	r9,r9,lr<<0x2
80002ccc:	11 ee       	ld.ub	lr,r8[0x6]
80002cce:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80002cd2:	ab 6e       	lsl	lr,0xa
80002cd4:	1c 09       	add	r9,lr
80002cd6:	2f f9       	sub	r9,-1
80002cd8:	f1 38 00 09 	ld.ub	r8,r8[9]
80002cdc:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002ce0:	f8 0e 16 07 	lsr	lr,r12,0x7
80002ce4:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002ce8:	2f e8       	sub	r8,-2
80002cea:	f2 08 09 49 	lsl	r9,r9,r8
80002cee:	20 19       	sub	r9,1
80002cf0:	4a 08       	lddpc	r8,80002d70 <sd_mmc_spi_get_capacity+0x114>
80002cf2:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80002cf4:	70 0e       	ld.w	lr,r8[0x0]
80002cf6:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
80002cfa:	2f fe       	sub	lr,-1
80002cfc:	fc 0b 09 48 	lsl	r8,lr,r11
80002d00:	30 09       	mov	r9,0
80002d02:	49 ae       	lddpc	lr,80002d68 <sd_mmc_spi_get_capacity+0x10c>
80002d04:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
80002d08:	49 98       	lddpc	r8,80002d6c <sd_mmc_spi_get_capacity+0x110>
80002d0a:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80002d0c:	30 98       	mov	r8,9
80002d0e:	f0 0b 18 00 	cp.b	r11,r8
80002d12:	e0 88 00 08 	brls	80002d22 <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002d16:	49 78       	lddpc	r8,80002d70 <sd_mmc_spi_get_capacity+0x114>
80002d18:	70 09       	ld.w	r9,r8[0x0]
80002d1a:	20 9b       	sub	r11,9
80002d1c:	f2 0b 09 4b 	lsl	r11,r9,r11
80002d20:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
80002d22:	58 0a       	cp.w	r10,0
80002d24:	c0 c1       	brne	80002d3c <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80002d26:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
80002d2a:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80002d2e:	48 d9       	lddpc	r9,80002d60 <sd_mmc_spi_get_capacity+0x104>
80002d30:	f3 39 00 0b 	ld.ub	r9,r9[11]
80002d34:	a3 7c       	lsl	r12,0x3
80002d36:	f9 e9 12 59 	or	r9,r12,r9>>0x5
80002d3a:	c0 c8       	rjmp	80002d52 <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80002d3c:	48 9a       	lddpc	r10,80002d60 <sd_mmc_spi_get_capacity+0x104>
80002d3e:	f5 39 00 0a 	ld.ub	r9,r10[10]
80002d42:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
80002d46:	f5 38 00 0b 	ld.ub	r8,r10[11]
80002d4a:	a7 98       	lsr	r8,0x7
80002d4c:	f0 09 00 18 	add	r8,r8,r9<<0x1
80002d50:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80002d52:	2f f9       	sub	r9,-1
80002d54:	2f f8       	sub	r8,-1
80002d56:	b1 39       	mul	r9,r8
80002d58:	48 78       	lddpc	r8,80002d74 <sd_mmc_spi_get_capacity+0x118>
80002d5a:	b0 09       	st.h	r8[0x0],r9
}
80002d5c:	d8 02       	popm	pc
80002d5e:	00 00       	add	r0,r0
80002d60:	00 00       	add	r0,r0
80002d62:	0a 8c       	andn	r12,r5
80002d64:	00 00       	add	r0,r0
80002d66:	0a 8a       	andn	r10,r5
80002d68:	00 00       	add	r0,r0
80002d6a:	0a 78       	tst	r8,r5
80002d6c:	00 00       	add	r0,r0
80002d6e:	0a 80       	andn	r0,r5
80002d70:	00 00       	add	r0,r0
80002d72:	0a 84       	andn	r4,r5
80002d74:	00 00       	add	r0,r0
80002d76:	0a 82       	andn	r2,r5

80002d78 <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002d78:	5e fc       	retal	r12
80002d7a:	d7 03       	nop

80002d7c <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
80002d7c:	d4 01       	pushm	lr
80002d7e:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002d80:	18 9b       	mov	r11,r12
80002d82:	fe 7c 24 00 	mov	r12,-56320
80002d86:	f0 1f 00 09 	mcall	80002da8 <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002d8a:	fa cb ff fe 	sub	r11,sp,-2
80002d8e:	fe 7c 24 00 	mov	r12,-56320
80002d92:	f0 1f 00 07 	mcall	80002dac <sd_mmc_spi_send_and_read+0x30>
80002d96:	58 1c       	cp.w	r12,1
80002d98:	c0 41       	brne	80002da0 <sd_mmc_spi_send_and_read+0x24>
80002d9a:	e0 6c 00 ff 	mov	r12,255
80002d9e:	c0 28       	rjmp	80002da2 <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
80002da0:	1b bc       	ld.ub	r12,sp[0x3]
}
80002da2:	2f fd       	sub	sp,-4
80002da4:	d8 02       	popm	pc
80002da6:	00 00       	add	r0,r0
80002da8:	80 00       	ld.sh	r0,r0[0x0]
80002daa:	41 10       	lddsp	r0,sp[0x44]
80002dac:	80 00       	ld.sh	r0,r0[0x0]
80002dae:	41 2c       	lddsp	r12,sp[0x48]

80002db0 <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
80002db0:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002db2:	30 1b       	mov	r11,1
80002db4:	fe 7c 24 00 	mov	r12,-56320
80002db8:	f0 1f 00 10 	mcall	80002df8 <sd_mmc_spi_wait_not_busy+0x48>
80002dbc:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002dbe:	e0 65 00 ff 	mov	r5,255
80002dc2:	48 f4       	lddpc	r4,80002dfc <sd_mmc_spi_wait_not_busy+0x4c>
80002dc4:	3f f6       	mov	r6,-1
80002dc6:	c0 b8       	rjmp	80002ddc <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80002dc8:	2f f7       	sub	r7,-1
    if (retry == 200000)
80002dca:	e2 57 0d 40 	cp.w	r7,200000
80002dce:	c0 71       	brne	80002ddc <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002dd0:	30 1b       	mov	r11,1
80002dd2:	fe 7c 24 00 	mov	r12,-56320
80002dd6:	f0 1f 00 0b 	mcall	80002e00 <sd_mmc_spi_wait_not_busy+0x50>
80002dda:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002ddc:	0a 9c       	mov	r12,r5
80002dde:	f0 1f 00 0a 	mcall	80002e04 <sd_mmc_spi_wait_not_busy+0x54>
80002de2:	a8 8c       	st.b	r4[0x0],r12
80002de4:	ec 0c 18 00 	cp.b	r12,r6
80002de8:	cf 01       	brne	80002dc8 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002dea:	30 1b       	mov	r11,1
80002dec:	fe 7c 24 00 	mov	r12,-56320
80002df0:	f0 1f 00 04 	mcall	80002e00 <sd_mmc_spi_wait_not_busy+0x50>
80002df4:	da 2a       	popm	r4-r7,pc,r12=1
80002df6:	00 00       	add	r0,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	42 78       	lddsp	r8,sp[0x9c]
80002dfc:	00 00       	add	r0,r0
80002dfe:	0a 9c       	mov	r12,r5
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	42 38       	lddsp	r8,sp[0x8c]
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2d 7c       	sub	r12,-41

80002e08 <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
80002e08:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9; // gl_ptr_mem = pos * 512
80002e0a:	48 58       	lddpc	r8,80002e1c <sd_mmc_spi_write_open+0x14>
80002e0c:	f8 09 16 17 	lsr	r9,r12,0x17
80002e10:	91 09       	st.w	r8[0x0],r9
80002e12:	a9 7c       	lsl	r12,0x9
80002e14:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002e16:	f0 1f 00 03 	mcall	80002e20 <sd_mmc_spi_write_open+0x18>
}
80002e1a:	d8 02       	popm	pc
80002e1c:	00 00       	add	r0,r0
80002e1e:	05 68       	ld.uh	r8,--r2
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	2d b0       	sub	r0,-37

80002e24 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
80002e24:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
80002e26:	f0 1f 00 02 	mcall	80002e2c <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
80002e2a:	d8 02       	popm	pc
80002e2c:	80 00       	ld.sh	r0,r0[0x0]
80002e2e:	2d b0       	sub	r0,-37

80002e30 <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
80002e30:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9;        // gl_ptr_mem = pos * 512
80002e32:	48 58       	lddpc	r8,80002e44 <sd_mmc_spi_read_open+0x14>
80002e34:	f8 09 16 17 	lsr	r9,r12,0x17
80002e38:	91 09       	st.w	r8[0x0],r9
80002e3a:	a9 7c       	lsl	r12,0x9
80002e3c:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002e3e:	f0 1f 00 03 	mcall	80002e48 <sd_mmc_spi_read_open+0x18>
}
80002e42:	d8 02       	popm	pc
80002e44:	00 00       	add	r0,r0
80002e46:	05 68       	ld.uh	r8,--r2
80002e48:	80 00       	ld.sh	r0,r0[0x0]
80002e4a:	2d b0       	sub	r0,-37

80002e4c <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80002e4c:	eb cd 40 f8 	pushm	r3-r7,lr
80002e50:	18 96       	mov	r6,r12
80002e52:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002e54:	e0 6b 00 ff 	mov	r11,255
80002e58:	fe 7c 24 00 	mov	r12,-56320
80002e5c:	f0 1f 00 2b 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80002e60:	0c 9b       	mov	r11,r6
80002e62:	a7 ab       	sbr	r11,0x6
80002e64:	5c 5b       	castu.b	r11
80002e66:	fe 7c 24 00 	mov	r12,-56320
80002e6a:	f0 1f 00 28 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80002e6e:	ee 0b 16 18 	lsr	r11,r7,0x18
80002e72:	fe 7c 24 00 	mov	r12,-56320
80002e76:	f0 1f 00 25 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
80002e7a:	ee 0b 16 10 	lsr	r11,r7,0x10
80002e7e:	fe 7c 24 00 	mov	r12,-56320
80002e82:	f0 1f 00 22 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
80002e86:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002e8a:	fe 7c 24 00 	mov	r12,-56320
80002e8e:	f0 1f 00 1f 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
80002e92:	0e 9b       	mov	r11,r7
80002e94:	5c 7b       	castu.h	r11
80002e96:	fe 7c 24 00 	mov	r12,-56320
80002e9a:	f0 1f 00 1c 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
  switch(command)
80002e9e:	30 08       	mov	r8,0
80002ea0:	f0 06 18 00 	cp.b	r6,r8
80002ea4:	c0 60       	breq	80002eb0 <sd_mmc_spi_command+0x64>
80002ea6:	30 88       	mov	r8,8
80002ea8:	f0 06 18 00 	cp.b	r6,r8
80002eac:	c1 01       	brne	80002ecc <sd_mmc_spi_command+0x80>
80002eae:	c0 88       	rjmp	80002ebe <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80002eb0:	e0 6b 00 95 	mov	r11,149
80002eb4:	fe 7c 24 00 	mov	r12,-56320
80002eb8:	f0 1f 00 14 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
         break;
80002ebc:	c0 e8       	rjmp	80002ed8 <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80002ebe:	e0 6b 00 87 	mov	r11,135
80002ec2:	fe 7c 24 00 	mov	r12,-56320
80002ec6:	f0 1f 00 11 	mcall	80002f08 <sd_mmc_spi_command+0xbc>
         break;
80002eca:	c0 78       	rjmp	80002ed8 <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002ecc:	e0 6b 00 ff 	mov	r11,255
80002ed0:	fe 7c 24 00 	mov	r12,-56320
80002ed4:	f0 1f 00 0d 	mcall	80002f08 <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002ed8:	3f f9       	mov	r9,-1
80002eda:	48 d8       	lddpc	r8,80002f0c <sd_mmc_spi_command+0xc0>
80002edc:	b0 89       	st.b	r8[0x0],r9
80002ede:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002ee0:	e0 64 00 ff 	mov	r4,255
80002ee4:	10 93       	mov	r3,r8
80002ee6:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80002ee8:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002eea:	c0 68       	rjmp	80002ef6 <sd_mmc_spi_command+0xaa>
  {
    retry++;
80002eec:	2f f7       	sub	r7,-1
80002eee:	5c 57       	castu.b	r7
    if(retry > 10) break;
80002ef0:	ea 07 18 00 	cp.b	r7,r5
80002ef4:	c0 80       	breq	80002f04 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002ef6:	08 9c       	mov	r12,r4
80002ef8:	f0 1f 00 06 	mcall	80002f10 <sd_mmc_spi_command+0xc4>
80002efc:	a6 8c       	st.b	r3[0x0],r12
80002efe:	ec 0c 18 00 	cp.b	r12,r6
80002f02:	cf 50       	breq	80002eec <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80002f04:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	41 10       	lddsp	r0,sp[0x44]
80002f0c:	00 00       	add	r0,r0
80002f0e:	0a 9c       	mov	r12,r5
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	2d 7c       	sub	r12,-41

80002f14 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
80002f14:	eb cd 40 c0 	pushm	r6-r7,lr
80002f18:	18 97       	mov	r7,r12
80002f1a:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002f1c:	30 1b       	mov	r11,1
80002f1e:	fe 7c 24 00 	mov	r12,-56320
80002f22:	f0 1f 00 09 	mcall	80002f44 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
80002f26:	0c 9b       	mov	r11,r6
80002f28:	0e 9c       	mov	r12,r7
80002f2a:	f0 1f 00 08 	mcall	80002f48 <sd_mmc_spi_send_command+0x34>
80002f2e:	48 87       	lddpc	r7,80002f4c <sd_mmc_spi_send_command+0x38>
80002f30:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002f32:	30 1b       	mov	r11,1
80002f34:	fe 7c 24 00 	mov	r12,-56320
80002f38:	f0 1f 00 06 	mcall	80002f50 <sd_mmc_spi_send_command+0x3c>
  return r1;
}
80002f3c:	0f 8c       	ld.ub	r12,r7[0x0]
80002f3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f42:	00 00       	add	r0,r0
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	42 78       	lddsp	r8,sp[0x9c]
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	2e 4c       	sub	r12,-28
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a 9c       	mov	r12,r5
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	42 38       	lddsp	r8,sp[0x8c]

80002f54 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80002f54:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80002f58:	49 a8       	lddpc	r8,80002fc0 <sd_mmc_spi_check_presence+0x6c>
80002f5a:	11 89       	ld.ub	r9,r8[0x0]
80002f5c:	30 08       	mov	r8,0
80002f5e:	f0 09 18 00 	cp.b	r9,r8
80002f62:	c1 f1       	brne	80002fa0 <sd_mmc_spi_check_presence+0x4c>
80002f64:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002f66:	0e 94       	mov	r4,r7
80002f68:	49 73       	lddpc	r3,80002fc4 <sd_mmc_spi_check_presence+0x70>
80002f6a:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002f6c:	e0 62 00 ff 	mov	r2,255
80002f70:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80002f74:	30 b5       	mov	r5,11
80002f76:	c0 c8       	rjmp	80002f8e <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002f78:	04 9b       	mov	r11,r2
80002f7a:	02 9c       	mov	r12,r1
80002f7c:	f0 1f 00 13 	mcall	80002fc8 <sd_mmc_spi_check_presence+0x74>
      retry++;
80002f80:	2f f7       	sub	r7,-1
80002f82:	5c 87       	casts.h	r7
      if (retry > 10)
80002f84:	ea 07 19 00 	cp.h	r7,r5
80002f88:	c0 31       	brne	80002f8e <sd_mmc_spi_check_presence+0x3a>
80002f8a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002f8e:	08 9b       	mov	r11,r4
80002f90:	08 9c       	mov	r12,r4
80002f92:	f0 1f 00 0f 	mcall	80002fcc <sd_mmc_spi_check_presence+0x78>
80002f96:	a6 8c       	st.b	r3[0x0],r12
80002f98:	ec 0c 18 00 	cp.b	r12,r6
80002f9c:	ce e1       	brne	80002f78 <sd_mmc_spi_check_presence+0x24>
80002f9e:	c0 e8       	rjmp	80002fba <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80002fa0:	30 0b       	mov	r11,0
80002fa2:	33 bc       	mov	r12,59
80002fa4:	f0 1f 00 0a 	mcall	80002fcc <sd_mmc_spi_check_presence+0x78>
80002fa8:	48 78       	lddpc	r8,80002fc4 <sd_mmc_spi_check_presence+0x70>
80002faa:	b0 8c       	st.b	r8[0x0],r12
80002fac:	58 0c       	cp.w	r12,0
80002fae:	c0 60       	breq	80002fba <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
80002fb0:	30 09       	mov	r9,0
80002fb2:	48 48       	lddpc	r8,80002fc0 <sd_mmc_spi_check_presence+0x6c>
80002fb4:	b0 89       	st.b	r8[0x0],r9
80002fb6:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
80002fba:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
80002fbe:	00 00       	add	r0,r0
80002fc0:	00 00       	add	r0,r0
80002fc2:	05 84       	ld.ub	r4,r2[0x0]
80002fc4:	00 00       	add	r0,r0
80002fc6:	0a 9c       	mov	r12,r5
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	41 10       	lddsp	r0,sp[0x44]
80002fcc:	80 00       	ld.sh	r0,r0[0x0]
80002fce:	2f 14       	sub	r4,-15

80002fd0 <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
80002fd0:	eb cd 40 e0 	pushm	r5-r7,lr
80002fd4:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002fd6:	f0 1f 00 4e 	mcall	8000310c <sd_mmc_spi_write_sector_from_ram+0x13c>
80002fda:	e0 80 00 96 	breq	80003106 <sd_mmc_spi_write_sector_from_ram+0x136>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002fde:	30 1b       	mov	r11,1
80002fe0:	fe 7c 24 00 	mov	r12,-56320
80002fe4:	f0 1f 00 4b 	mcall	80003110 <sd_mmc_spi_write_sector_from_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002fe8:	4c b8       	lddpc	r8,80003114 <sd_mmc_spi_write_sector_from_ram+0x144>
80002fea:	11 89       	ld.ub	r9,r8[0x0]
80002fec:	30 38       	mov	r8,3
80002fee:	f0 09 18 00 	cp.b	r9,r8
80002ff2:	c0 d1       	brne	8000300c <sd_mmc_spi_write_sector_from_ram+0x3c>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80002ff4:	4c 98       	lddpc	r8,80003118 <sd_mmc_spi_write_sector_from_ram+0x148>
80002ff6:	70 0b       	ld.w	r11,r8[0x0]
80002ff8:	70 18       	ld.w	r8,r8[0x4]
80002ffa:	a9 98       	lsr	r8,0x9
80002ffc:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
80003000:	31 8c       	mov	r12,24
80003002:	f0 1f 00 47 	mcall	8000311c <sd_mmc_spi_write_sector_from_ram+0x14c>
80003006:	4c 78       	lddpc	r8,80003120 <sd_mmc_spi_write_sector_from_ram+0x150>
80003008:	b0 8c       	st.b	r8[0x0],r12
8000300a:	c0 88       	rjmp	8000301a <sd_mmc_spi_write_sector_from_ram+0x4a>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
8000300c:	4c 38       	lddpc	r8,80003118 <sd_mmc_spi_write_sector_from_ram+0x148>
8000300e:	70 1b       	ld.w	r11,r8[0x4]
80003010:	31 8c       	mov	r12,24
80003012:	f0 1f 00 43 	mcall	8000311c <sd_mmc_spi_write_sector_from_ram+0x14c>
80003016:	4c 38       	lddpc	r8,80003120 <sd_mmc_spi_write_sector_from_ram+0x150>
80003018:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
8000301a:	4c 28       	lddpc	r8,80003120 <sd_mmc_spi_write_sector_from_ram+0x150>
8000301c:	11 89       	ld.ub	r9,r8[0x0]
8000301e:	30 08       	mov	r8,0
80003020:	f0 09 18 00 	cp.b	r9,r8
80003024:	c0 80       	breq	80003034 <sd_mmc_spi_write_sector_from_ram+0x64>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80003026:	30 1b       	mov	r11,1
80003028:	fe 7c 24 00 	mov	r12,-56320
8000302c:	f0 1f 00 3e 	mcall	80003124 <sd_mmc_spi_write_sector_from_ram+0x154>
80003030:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80003034:	e0 6b 00 ff 	mov	r11,255
80003038:	fe 7c 24 00 	mov	r12,-56320
8000303c:	f0 1f 00 3b 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
80003040:	e0 6b 00 fe 	mov	r11,254
80003044:	fe 7c 24 00 	mov	r12,-56320
80003048:	f0 1f 00 38 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
8000304c:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
80003050:	fe 75 24 00 	mov	r5,-56320
80003054:	0f 3b       	ld.ub	r11,r7++
80003056:	0a 9c       	mov	r12,r5
80003058:	f0 1f 00 34 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
8000305c:	0c 37       	cp.w	r7,r6
8000305e:	cf b1       	brne	80003054 <sd_mmc_spi_write_sector_from_ram+0x84>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
80003060:	e0 6b 00 ff 	mov	r11,255
80003064:	fe 7c 24 00 	mov	r12,-56320
80003068:	f0 1f 00 30 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
8000306c:	e0 6b 00 ff 	mov	r11,255
80003070:	fe 7c 24 00 	mov	r12,-56320
80003074:	f0 1f 00 2d 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003078:	e0 6c 00 ff 	mov	r12,255
8000307c:	f0 1f 00 2c 	mcall	8000312c <sd_mmc_spi_write_sector_from_ram+0x15c>
80003080:	4a 88       	lddpc	r8,80003120 <sd_mmc_spi_write_sector_from_ram+0x150>
80003082:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80003084:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003088:	58 5c       	cp.w	r12,5
8000308a:	c1 40       	breq	800030b2 <sd_mmc_spi_write_sector_from_ram+0xe2>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000308c:	e0 6b 00 ff 	mov	r11,255
80003090:	fe 7c 24 00 	mov	r12,-56320
80003094:	f0 1f 00 25 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_write(SD_MMC_SPI,0xFF);
80003098:	e0 6b 00 ff 	mov	r11,255
8000309c:	fe 7c 24 00 	mov	r12,-56320
800030a0:	f0 1f 00 22 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800030a4:	30 1b       	mov	r11,1
800030a6:	fe 7c 24 00 	mov	r12,-56320
800030aa:	f0 1f 00 1f 	mcall	80003124 <sd_mmc_spi_write_sector_from_ram+0x154>
800030ae:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
800030b2:	e0 6b 00 ff 	mov	r11,255
800030b6:	fe 7c 24 00 	mov	r12,-56320
800030ba:	f0 1f 00 1c 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
800030be:	e0 6b 00 ff 	mov	r11,255
800030c2:	fe 7c 24 00 	mov	r12,-56320
800030c6:	f0 1f 00 19 	mcall	80003128 <sd_mmc_spi_write_sector_from_ram+0x158>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800030ca:	30 1b       	mov	r11,1
800030cc:	fe 7c 24 00 	mov	r12,-56320
800030d0:	f0 1f 00 15 	mcall	80003124 <sd_mmc_spi_write_sector_from_ram+0x154>
  gl_ptr_mem += 512;        // Update the memory pointer.
800030d4:	49 18       	lddpc	r8,80003118 <sd_mmc_spi_write_sector_from_ram+0x148>
800030d6:	f0 e6 00 00 	ld.d	r6,r8[0]
800030da:	e0 6a 02 00 	mov	r10,512
800030de:	30 0b       	mov	r11,0
800030e0:	ec 0a 00 0a 	add	r10,r6,r10
800030e4:	ee 0b 00 4b 	adc	r11,r7,r11
800030e8:	f0 eb 00 00 	st.d	r8[0],r10
800030ec:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
800030ee:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800030f0:	c0 68       	rjmp	800030fc <sd_mmc_spi_write_sector_from_ram+0x12c>
  {
    i++;
800030f2:	2f f7       	sub	r7,-1
800030f4:	5c 87       	casts.h	r7
    if (i == 10)
800030f6:	ec 07 19 00 	cp.h	r7,r6
800030fa:	c0 60       	breq	80003106 <sd_mmc_spi_write_sector_from_ram+0x136>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800030fc:	f0 1f 00 04 	mcall	8000310c <sd_mmc_spi_write_sector_from_ram+0x13c>
80003100:	cf 90       	breq	800030f2 <sd_mmc_spi_write_sector_from_ram+0x122>
80003102:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003106:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000310a:	00 00       	add	r0,r0
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	2d b0       	sub	r0,-37
80003110:	80 00       	ld.sh	r0,r0[0x0]
80003112:	42 78       	lddsp	r8,sp[0x9c]
80003114:	00 00       	add	r0,r0
80003116:	0a 8a       	andn	r10,r5
80003118:	00 00       	add	r0,r0
8000311a:	05 68       	ld.uh	r8,--r2
8000311c:	80 00       	ld.sh	r0,r0[0x0]
8000311e:	2e 4c       	sub	r12,-28
80003120:	00 00       	add	r0,r0
80003122:	0a 9c       	mov	r12,r5
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	42 38       	lddsp	r8,sp[0x8c]
80003128:	80 00       	ld.sh	r0,r0[0x0]
8000312a:	41 10       	lddsp	r0,sp[0x44]
8000312c:	80 00       	ld.sh	r0,r0[0x0]
8000312e:	2d 7c       	sub	r12,-41

80003130 <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
80003130:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003134:	f0 1f 00 1c 	mcall	800031a4 <sd_mmc_spi_check_hc+0x74>
80003138:	c0 31       	brne	8000313e <sd_mmc_spi_check_hc+0xe>
8000313a:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000313e:	30 1b       	mov	r11,1
80003140:	fe 7c 24 00 	mov	r12,-56320
80003144:	f0 1f 00 19 	mcall	800031a8 <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
80003148:	30 0b       	mov	r11,0
8000314a:	33 ac       	mov	r12,58
8000314c:	f0 1f 00 18 	mcall	800031ac <sd_mmc_spi_check_hc+0x7c>
80003150:	49 88       	lddpc	r8,800031b0 <sd_mmc_spi_check_hc+0x80>
80003152:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
80003154:	58 0c       	cp.w	r12,0
80003156:	c0 80       	breq	80003166 <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003158:	30 1b       	mov	r11,1
8000315a:	fe 7c 24 00 	mov	r12,-56320
8000315e:	f0 1f 00 16 	mcall	800031b4 <sd_mmc_spi_check_hc+0x84>
80003162:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80003166:	e0 6c 00 ff 	mov	r12,255
8000316a:	f0 1f 00 14 	mcall	800031b8 <sd_mmc_spi_check_hc+0x88>
8000316e:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003170:	e0 6c 00 ff 	mov	r12,255
80003174:	f0 1f 00 11 	mcall	800031b8 <sd_mmc_spi_check_hc+0x88>
80003178:	48 e7       	lddpc	r7,800031b0 <sd_mmc_spi_check_hc+0x80>
8000317a:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000317c:	e0 6c 00 ff 	mov	r12,255
80003180:	f0 1f 00 0e 	mcall	800031b8 <sd_mmc_spi_check_hc+0x88>
80003184:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003186:	e0 6c 00 ff 	mov	r12,255
8000318a:	f0 1f 00 0c 	mcall	800031b8 <sd_mmc_spi_check_hc+0x88>
8000318e:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003190:	30 1b       	mov	r11,1
80003192:	fe 7c 24 00 	mov	r12,-56320
80003196:	f0 1f 00 08 	mcall	800031b4 <sd_mmc_spi_check_hc+0x84>
8000319a:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
8000319e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800031a2:	00 00       	add	r0,r0
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	2d b0       	sub	r0,-37
800031a8:	80 00       	ld.sh	r0,r0[0x0]
800031aa:	42 78       	lddsp	r8,sp[0x9c]
800031ac:	80 00       	ld.sh	r0,r0[0x0]
800031ae:	2e 4c       	sub	r12,-28
800031b0:	00 00       	add	r0,r0
800031b2:	0a 9c       	mov	r12,r5
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	42 38       	lddsp	r8,sp[0x8c]
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	2d 7c       	sub	r12,-41

800031bc <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
800031bc:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800031c0:	f0 1f 00 27 	mcall	8000325c <sd_mmc_spi_get_if+0xa0>
800031c4:	c0 31       	brne	800031ca <sd_mmc_spi_get_if+0xe>
800031c6:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800031ca:	30 1b       	mov	r11,1
800031cc:	fe 7c 24 00 	mov	r12,-56320
800031d0:	f0 1f 00 24 	mcall	80003260 <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
800031d4:	e0 6b 01 aa 	mov	r11,426
800031d8:	30 8c       	mov	r12,8
800031da:	f0 1f 00 23 	mcall	80003264 <sd_mmc_spi_get_if+0xa8>
800031de:	4a 38       	lddpc	r8,80003268 <sd_mmc_spi_get_if+0xac>
800031e0:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
800031e2:	e2 1c 00 04 	andl	r12,0x4,COH
800031e6:	c0 80       	breq	800031f6 <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800031e8:	30 1b       	mov	r11,1
800031ea:	fe 7c 24 00 	mov	r12,-56320
800031ee:	f0 1f 00 20 	mcall	8000326c <sd_mmc_spi_get_if+0xb0>
800031f2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800031f6:	e0 6c 00 ff 	mov	r12,255
800031fa:	f0 1f 00 1e 	mcall	80003270 <sd_mmc_spi_get_if+0xb4>
800031fe:	49 b7       	lddpc	r7,80003268 <sd_mmc_spi_get_if+0xac>
80003200:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003202:	e0 6c 00 ff 	mov	r12,255
80003206:	f0 1f 00 1b 	mcall	80003270 <sd_mmc_spi_get_if+0xb4>
8000320a:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000320c:	e0 6c 00 ff 	mov	r12,255
80003210:	f0 1f 00 18 	mcall	80003270 <sd_mmc_spi_get_if+0xb4>
80003214:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
80003216:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000321a:	c0 81       	brne	8000322a <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000321c:	30 1b       	mov	r11,1
8000321e:	fe 7c 24 00 	mov	r12,-56320
80003222:	f0 1f 00 13 	mcall	8000326c <sd_mmc_spi_get_if+0xb0>
80003226:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000322a:	e0 6c 00 ff 	mov	r12,255
8000322e:	f0 1f 00 11 	mcall	80003270 <sd_mmc_spi_get_if+0xb4>
80003232:	48 e8       	lddpc	r8,80003268 <sd_mmc_spi_get_if+0xac>
80003234:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
80003236:	3a a8       	mov	r8,-86
80003238:	f0 0c 18 00 	cp.b	r12,r8
8000323c:	c0 80       	breq	8000324c <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000323e:	30 1b       	mov	r11,1
80003240:	fe 7c 24 00 	mov	r12,-56320
80003244:	f0 1f 00 0a 	mcall	8000326c <sd_mmc_spi_get_if+0xb0>
80003248:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000324c:	30 1b       	mov	r11,1
8000324e:	fe 7c 24 00 	mov	r12,-56320
80003252:	f0 1f 00 07 	mcall	8000326c <sd_mmc_spi_get_if+0xb0>
80003256:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000325a:	00 00       	add	r0,r0
8000325c:	80 00       	ld.sh	r0,r0[0x0]
8000325e:	2d b0       	sub	r0,-37
80003260:	80 00       	ld.sh	r0,r0[0x0]
80003262:	42 78       	lddsp	r8,sp[0x9c]
80003264:	80 00       	ld.sh	r0,r0[0x0]
80003266:	2e 4c       	sub	r12,-28
80003268:	00 00       	add	r0,r0
8000326a:	0a 9c       	mov	r12,r5
8000326c:	80 00       	ld.sh	r0,r0[0x0]
8000326e:	42 38       	lddsp	r8,sp[0x8c]
80003270:	80 00       	ld.sh	r0,r0[0x0]
80003272:	2d 7c       	sub	r12,-41

80003274 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80003274:	eb cd 40 f8 	pushm	r3-r7,lr
80003278:	20 1d       	sub	sp,4
8000327a:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000327c:	f0 1f 00 4d 	mcall	800033b0 <sd_mmc_spi_read_sector_to_ram+0x13c>
80003280:	e0 80 00 94 	breq	800033a8 <sd_mmc_spi_read_sector_to_ram+0x134>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003284:	30 1b       	mov	r11,1
80003286:	fe 7c 24 00 	mov	r12,-56320
8000328a:	f0 1f 00 4b 	mcall	800033b4 <sd_mmc_spi_read_sector_to_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000328e:	4c b8       	lddpc	r8,800033b8 <sd_mmc_spi_read_sector_to_ram+0x144>
80003290:	11 89       	ld.ub	r9,r8[0x0]
80003292:	30 38       	mov	r8,3
80003294:	f0 09 18 00 	cp.b	r9,r8
80003298:	c0 d1       	brne	800032b2 <sd_mmc_spi_read_sector_to_ram+0x3e>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
8000329a:	4c 98       	lddpc	r8,800033bc <sd_mmc_spi_read_sector_to_ram+0x148>
8000329c:	70 0b       	ld.w	r11,r8[0x0]
8000329e:	70 18       	ld.w	r8,r8[0x4]
800032a0:	a9 98       	lsr	r8,0x9
800032a2:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
800032a6:	31 1c       	mov	r12,17
800032a8:	f0 1f 00 46 	mcall	800033c0 <sd_mmc_spi_read_sector_to_ram+0x14c>
800032ac:	4c 68       	lddpc	r8,800033c4 <sd_mmc_spi_read_sector_to_ram+0x150>
800032ae:	b0 8c       	st.b	r8[0x0],r12
800032b0:	c0 88       	rjmp	800032c0 <sd_mmc_spi_read_sector_to_ram+0x4c>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
800032b2:	4c 38       	lddpc	r8,800033bc <sd_mmc_spi_read_sector_to_ram+0x148>
800032b4:	70 1b       	ld.w	r11,r8[0x4]
800032b6:	31 1c       	mov	r12,17
800032b8:	f0 1f 00 42 	mcall	800033c0 <sd_mmc_spi_read_sector_to_ram+0x14c>
800032bc:	4c 28       	lddpc	r8,800033c4 <sd_mmc_spi_read_sector_to_ram+0x150>
800032be:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
800032c0:	4c 18       	lddpc	r8,800033c4 <sd_mmc_spi_read_sector_to_ram+0x150>
800032c2:	11 89       	ld.ub	r9,r8[0x0]
800032c4:	30 08       	mov	r8,0
800032c6:	f0 09 18 00 	cp.b	r9,r8
800032ca:	c1 20       	breq	800032ee <sd_mmc_spi_read_sector_to_ram+0x7a>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800032cc:	30 1b       	mov	r11,1
800032ce:	fe 7c 24 00 	mov	r12,-56320
800032d2:	f0 1f 00 3e 	mcall	800033c8 <sd_mmc_spi_read_sector_to_ram+0x154>
800032d6:	30 0c       	mov	r12,0
    return false;
800032d8:	c6 88       	rjmp	800033a8 <sd_mmc_spi_read_sector_to_ram+0x134>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
800032da:	20 17       	sub	r7,1
800032dc:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
800032de:	c0 e1       	brne	800032fa <sd_mmc_spi_read_sector_to_ram+0x86>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
800032e0:	30 1b       	mov	r11,1
800032e2:	fe 7c 24 00 	mov	r12,-56320
800032e6:	f0 1f 00 39 	mcall	800033c8 <sd_mmc_spi_read_sector_to_ram+0x154>
800032ea:	30 0c       	mov	r12,0
       return false;
800032ec:	c5 e8       	rjmp	800033a8 <sd_mmc_spi_read_sector_to_ram+0x134>
800032ee:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800032f2:	e0 65 00 ff 	mov	r5,255
800032f6:	4b 44       	lddpc	r4,800033c4 <sd_mmc_spi_read_sector_to_ram+0x150>
800032f8:	3f f6       	mov	r6,-1
800032fa:	0a 9c       	mov	r12,r5
800032fc:	f0 1f 00 34 	mcall	800033cc <sd_mmc_spi_read_sector_to_ram+0x158>
80003300:	a8 8c       	st.b	r4[0x0],r12
80003302:	ec 0c 18 00 	cp.b	r12,r6
80003306:	ce a0       	breq	800032da <sd_mmc_spi_read_sector_to_ram+0x66>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80003308:	3f e8       	mov	r8,-2
8000330a:	f0 0c 18 00 	cp.b	r12,r8
8000330e:	c0 e0       	breq	8000332a <sd_mmc_spi_read_sector_to_ram+0xb6>
  {
    spi_write(SD_MMC_SPI,0xFF);
80003310:	e0 6b 00 ff 	mov	r11,255
80003314:	fe 7c 24 00 	mov	r12,-56320
80003318:	f0 1f 00 2e 	mcall	800033d0 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000331c:	30 1b       	mov	r11,1
8000331e:	fe 7c 24 00 	mov	r12,-56320
80003322:	f0 1f 00 2a 	mcall	800033c8 <sd_mmc_spi_read_sector_to_ram+0x154>
80003326:	30 0c       	mov	r12,0
    return false;
80003328:	c4 08       	rjmp	800033a8 <sd_mmc_spi_read_sector_to_ram+0x134>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
8000332a:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
8000332c:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
80003330:	e0 64 00 ff 	mov	r4,255
80003334:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
80003338:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
8000333c:	08 9b       	mov	r11,r4
8000333e:	0c 9c       	mov	r12,r6
80003340:	f0 1f 00 24 	mcall	800033d0 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_read(SD_MMC_SPI,&data_read);
80003344:	06 9b       	mov	r11,r3
80003346:	0c 9c       	mov	r12,r6
80003348:	f0 1f 00 23 	mcall	800033d4 <sd_mmc_spi_read_sector_to_ram+0x160>
    *_ram++=data_read;
8000334c:	9a 18       	ld.sh	r8,sp[0x2]
8000334e:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80003350:	0a 37       	cp.w	r7,r5
80003352:	cf 51       	brne	8000333c <sd_mmc_spi_read_sector_to_ram+0xc8>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
80003354:	49 a8       	lddpc	r8,800033bc <sd_mmc_spi_read_sector_to_ram+0x148>
80003356:	f0 e6 00 00 	ld.d	r6,r8[0]
8000335a:	e0 6a 02 00 	mov	r10,512
8000335e:	30 0b       	mov	r11,0
80003360:	ec 0a 00 0a 	add	r10,r6,r10
80003364:	ee 0b 00 4b 	adc	r11,r7,r11
80003368:	f0 eb 00 00 	st.d	r8[0],r10

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
8000336c:	e0 6b 00 ff 	mov	r11,255
80003370:	fe 7c 24 00 	mov	r12,-56320
80003374:	f0 1f 00 17 	mcall	800033d0 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80003378:	e0 6b 00 ff 	mov	r11,255
8000337c:	fe 7c 24 00 	mov	r12,-56320
80003380:	f0 1f 00 14 	mcall	800033d0 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80003384:	e0 6b 00 ff 	mov	r11,255
80003388:	fe 7c 24 00 	mov	r12,-56320
8000338c:	f0 1f 00 11 	mcall	800033d0 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80003390:	e0 6b 00 ff 	mov	r11,255
80003394:	fe 7c 24 00 	mov	r12,-56320
80003398:	f0 1f 00 0e 	mcall	800033d0 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000339c:	30 1b       	mov	r11,1
8000339e:	fe 7c 24 00 	mov	r12,-56320
800033a2:	f0 1f 00 0a 	mcall	800033c8 <sd_mmc_spi_read_sector_to_ram+0x154>
800033a6:	30 1c       	mov	r12,1

  return true;   // Read done.
}
800033a8:	2f fd       	sub	sp,-4
800033aa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800033ae:	00 00       	add	r0,r0
800033b0:	80 00       	ld.sh	r0,r0[0x0]
800033b2:	2d b0       	sub	r0,-37
800033b4:	80 00       	ld.sh	r0,r0[0x0]
800033b6:	42 78       	lddsp	r8,sp[0x9c]
800033b8:	00 00       	add	r0,r0
800033ba:	0a 8a       	andn	r10,r5
800033bc:	00 00       	add	r0,r0
800033be:	05 68       	ld.uh	r8,--r2
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	2e 4c       	sub	r12,-28
800033c4:	00 00       	add	r0,r0
800033c6:	0a 9c       	mov	r12,r5
800033c8:	80 00       	ld.sh	r0,r0[0x0]
800033ca:	42 38       	lddsp	r8,sp[0x8c]
800033cc:	80 00       	ld.sh	r0,r0[0x0]
800033ce:	2d 7c       	sub	r12,-41
800033d0:	80 00       	ld.sh	r0,r0[0x0]
800033d2:	41 10       	lddsp	r0,sp[0x44]
800033d4:	80 00       	ld.sh	r0,r0[0x0]
800033d6:	41 2c       	lddsp	r12,sp[0x48]

800033d8 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
800033d8:	eb cd 40 fc 	pushm	r2-r7,lr
800033dc:	20 1d       	sub	sp,4
800033de:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800033e0:	f0 1f 00 32 	mcall	800034a8 <sd_mmc_spi_get_csd+0xd0>
800033e4:	c5 f0       	breq	800034a2 <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800033e6:	30 1b       	mov	r11,1
800033e8:	fe 7c 24 00 	mov	r12,-56320
800033ec:	f0 1f 00 30 	mcall	800034ac <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
800033f0:	30 0b       	mov	r11,0
800033f2:	30 9c       	mov	r12,9
800033f4:	f0 1f 00 2f 	mcall	800034b0 <sd_mmc_spi_get_csd+0xd8>
800033f8:	4a f8       	lddpc	r8,800034b4 <sd_mmc_spi_get_csd+0xdc>
800033fa:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
800033fc:	58 0c       	cp.w	r12,0
800033fe:	c0 81       	brne	8000340e <sd_mmc_spi_get_csd+0x36>
80003400:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003402:	e0 64 00 ff 	mov	r4,255
80003406:	10 93       	mov	r3,r8
80003408:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
8000340a:	30 95       	mov	r5,9
8000340c:	c1 78       	rjmp	8000343a <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000340e:	30 1b       	mov	r11,1
80003410:	fe 7c 24 00 	mov	r12,-56320
80003414:	f0 1f 00 29 	mcall	800034b8 <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
80003418:	30 09       	mov	r9,0
8000341a:	4a 98       	lddpc	r8,800034bc <sd_mmc_spi_get_csd+0xe4>
8000341c:	b0 89       	st.b	r8[0x0],r9
8000341e:	30 0c       	mov	r12,0
    return false;
80003420:	c4 18       	rjmp	800034a2 <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
80003422:	ea 07 18 00 	cp.b	r7,r5
80003426:	c0 81       	brne	80003436 <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003428:	30 1b       	mov	r11,1
8000342a:	fe 7c 24 00 	mov	r12,-56320
8000342e:	f0 1f 00 23 	mcall	800034b8 <sd_mmc_spi_get_csd+0xe0>
80003432:	30 0c       	mov	r12,0
      return false;
80003434:	c3 78       	rjmp	800034a2 <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
80003436:	2f f7       	sub	r7,-1
80003438:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000343a:	08 9c       	mov	r12,r4
8000343c:	f0 1f 00 21 	mcall	800034c0 <sd_mmc_spi_get_csd+0xe8>
80003440:	a6 8c       	st.b	r3[0x0],r12
80003442:	ec 0c 18 00 	cp.b	r12,r6
80003446:	ce e1       	brne	80003422 <sd_mmc_spi_get_csd+0x4a>
80003448:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000344a:	e0 65 00 ff 	mov	r5,255
8000344e:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
80003452:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003456:	0a 9b       	mov	r11,r5
80003458:	0c 9c       	mov	r12,r6
8000345a:	f0 1f 00 1b 	mcall	800034c4 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
8000345e:	08 9b       	mov	r11,r4
80003460:	0c 9c       	mov	r12,r6
80003462:	f0 1f 00 1a 	mcall	800034c8 <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
80003466:	9a 18       	ld.sh	r8,sp[0x2]
80003468:	e4 07 0b 08 	st.b	r2[r7],r8
8000346c:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
8000346e:	59 07       	cp.w	r7,16
80003470:	cf 31       	brne	80003456 <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80003472:	e0 6b 00 ff 	mov	r11,255
80003476:	fe 7c 24 00 	mov	r12,-56320
8000347a:	f0 1f 00 13 	mcall	800034c4 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
8000347e:	e0 6b 00 ff 	mov	r11,255
80003482:	fe 7c 24 00 	mov	r12,-56320
80003486:	f0 1f 00 10 	mcall	800034c4 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
8000348a:	e0 6b 00 ff 	mov	r11,255
8000348e:	fe 7c 24 00 	mov	r12,-56320
80003492:	f0 1f 00 0d 	mcall	800034c4 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003496:	30 1b       	mov	r11,1
80003498:	fe 7c 24 00 	mov	r12,-56320
8000349c:	f0 1f 00 07 	mcall	800034b8 <sd_mmc_spi_get_csd+0xe0>
800034a0:	30 1c       	mov	r12,1
  return true;
}
800034a2:	2f fd       	sub	sp,-4
800034a4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	2d b0       	sub	r0,-37
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	42 78       	lddsp	r8,sp[0x9c]
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	2e 4c       	sub	r12,-28
800034b4:	00 00       	add	r0,r0
800034b6:	0a 9c       	mov	r12,r5
800034b8:	80 00       	ld.sh	r0,r0[0x0]
800034ba:	42 38       	lddsp	r8,sp[0x8c]
800034bc:	00 00       	add	r0,r0
800034be:	05 84       	ld.ub	r4,r2[0x0]
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	2d 7c       	sub	r12,-41
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	41 10       	lddsp	r0,sp[0x44]
800034c8:	80 00       	ld.sh	r0,r0[0x0]
800034ca:	41 2c       	lddsp	r12,sp[0x48]

800034cc <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
800034cc:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
800034ce:	fe fb 02 66 	ld.w	r11,pc[614]
800034d2:	e6 68 1a 80 	mov	r8,400000
800034d6:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800034d8:	fe f8 02 60 	ld.w	r8,pc[608]
800034dc:	70 0a       	ld.w	r10,r8[0x0]
800034de:	fe 7c 24 00 	mov	r12,-56320
800034e2:	f0 1f 00 97 	mcall	8000373c <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800034e6:	30 1b       	mov	r11,1
800034e8:	fe 7c 24 00 	mov	r12,-56320
800034ec:	f0 1f 00 95 	mcall	80003740 <sd_mmc_spi_internal_init+0x274>
800034f0:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
800034f2:	e0 66 00 ff 	mov	r6,255
800034f6:	fe 75 24 00 	mov	r5,-56320
800034fa:	0c 9b       	mov	r11,r6
800034fc:	0a 9c       	mov	r12,r5
800034fe:	f0 1f 00 92 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
80003502:	2f f7       	sub	r7,-1
80003504:	58 a7       	cp.w	r7,10
80003506:	cf a1       	brne	800034fa <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003508:	30 1b       	mov	r11,1
8000350a:	fe 7c 24 00 	mov	r12,-56320
8000350e:	f0 1f 00 8f 	mcall	80003748 <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
80003512:	30 08       	mov	r8,0
80003514:	fe f9 02 38 	ld.w	r9,pc[568]
80003518:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
8000351a:	fe f9 02 36 	ld.w	r9,pc[566]
8000351e:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003520:	30 0b       	mov	r11,0
80003522:	16 9c       	mov	r12,r11
80003524:	f0 1f 00 8c 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
80003528:	fe f8 02 30 	ld.w	r8,pc[560]
8000352c:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000352e:	e0 6b 00 ff 	mov	r11,255
80003532:	fe 7c 24 00 	mov	r12,-56320
80003536:	f0 1f 00 84 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
8000353a:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000353c:	fe f6 02 1c 	ld.w	r6,pc[540]
80003540:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003542:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003544:	e0 62 00 ff 	mov	r2,255
80003548:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
8000354c:	36 54       	mov	r4,101
8000354e:	c1 08       	rjmp	8000356e <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003550:	06 9b       	mov	r11,r3
80003552:	06 9c       	mov	r12,r3
80003554:	f0 1f 00 80 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
80003558:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000355a:	04 9b       	mov	r11,r2
8000355c:	02 9c       	mov	r12,r1
8000355e:	f0 1f 00 7a 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
80003562:	2f f7       	sub	r7,-1
80003564:	5c 87       	casts.h	r7
    if(retry > 100)
80003566:	e8 07 19 00 	cp.h	r7,r4
8000356a:	e0 80 00 e4 	breq	80003732 <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000356e:	0d 88       	ld.ub	r8,r6[0x0]
80003570:	ea 08 18 00 	cp.b	r8,r5
80003574:	ce e1       	brne	80003550 <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
80003576:	f0 1f 00 7a 	mcall	8000375c <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
8000357a:	5b fc       	cp.w	r12,-1
8000357c:	e0 80 00 db 	breq	80003732 <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
80003580:	58 1c       	cp.w	r12,1
80003582:	c0 51       	brne	8000358c <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
80003584:	30 29       	mov	r9,2
80003586:	4f 38       	lddpc	r8,80003750 <sd_mmc_spi_internal_init+0x284>
80003588:	b0 89       	st.b	r8[0x0],r9
8000358a:	c4 c8       	rjmp	80003622 <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000358c:	30 0b       	mov	r11,0
8000358e:	33 7c       	mov	r12,55
80003590:	f0 1f 00 71 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
80003594:	4f 17       	lddpc	r7,80003758 <sd_mmc_spi_internal_init+0x28c>
80003596:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80003598:	e0 6b 00 ff 	mov	r11,255
8000359c:	fe 7c 24 00 	mov	r12,-56320
800035a0:	f0 1f 00 69 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800035a4:	30 0b       	mov	r11,0
800035a6:	32 9c       	mov	r12,41
800035a8:	f0 1f 00 6b 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
800035ac:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800035ae:	e0 6b 00 ff 	mov	r11,255
800035b2:	fe 7c 24 00 	mov	r12,-56320
800035b6:	f0 1f 00 64 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
800035ba:	0f 88       	ld.ub	r8,r7[0x0]
800035bc:	e2 18 00 fe 	andl	r8,0xfe,COH
800035c0:	c0 51       	brne	800035ca <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
800035c2:	30 19       	mov	r9,1
800035c4:	4e 38       	lddpc	r8,80003750 <sd_mmc_spi_internal_init+0x284>
800035c6:	b0 89       	st.b	r8[0x0],r9
800035c8:	c2 d8       	rjmp	80003622 <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
800035ca:	30 09       	mov	r9,0
800035cc:	4e 18       	lddpc	r8,80003750 <sd_mmc_spi_internal_init+0x284>
800035ce:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800035d0:	30 0b       	mov	r11,0
800035d2:	16 9c       	mov	r12,r11
800035d4:	f0 1f 00 60 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
800035d8:	4e 08       	lddpc	r8,80003758 <sd_mmc_spi_internal_init+0x28c>
800035da:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800035dc:	e0 6b 00 ff 	mov	r11,255
800035e0:	fe 7c 24 00 	mov	r12,-56320
800035e4:	f0 1f 00 58 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
800035e8:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
800035ea:	4d c6       	lddpc	r6,80003758 <sd_mmc_spi_internal_init+0x28c>
800035ec:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800035ee:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800035f0:	e0 62 00 ff 	mov	r2,255
800035f4:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
800035f8:	36 54       	mov	r4,101
800035fa:	c1 08       	rjmp	8000361a <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800035fc:	06 9b       	mov	r11,r3
800035fe:	06 9c       	mov	r12,r3
80003600:	f0 1f 00 55 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
80003604:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003606:	04 9b       	mov	r11,r2
80003608:	02 9c       	mov	r12,r1
8000360a:	f0 1f 00 4f 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
8000360e:	2f f7       	sub	r7,-1
80003610:	5c 87       	casts.h	r7
        if(retry > 100)
80003612:	e8 07 19 00 	cp.h	r7,r4
80003616:	e0 80 00 8e 	breq	80003732 <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000361a:	0d 88       	ld.ub	r8,r6[0x0]
8000361c:	ea 08 18 00 	cp.b	r8,r5
80003620:	ce e1       	brne	800035fc <sd_mmc_spi_internal_init+0x130>
80003622:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003624:	4c b4       	lddpc	r4,80003750 <sd_mmc_spi_internal_init+0x284>
80003626:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80003628:	0e 93       	mov	r3,r7
8000362a:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000362c:	4c b6       	lddpc	r6,80003758 <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000362e:	e0 62 00 ff 	mov	r2,255
80003632:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003636:	09 88       	ld.ub	r8,r4[0x0]
80003638:	ea 08 18 00 	cp.b	r8,r5
8000363c:	c1 10       	breq	8000365e <sd_mmc_spi_internal_init+0x192>
8000363e:	c0 63       	brcs	8000364a <sd_mmc_spi_internal_init+0x17e>
80003640:	30 29       	mov	r9,2
80003642:	f2 08 18 00 	cp.b	r8,r9
80003646:	c2 81       	brne	80003696 <sd_mmc_spi_internal_init+0x1ca>
80003648:	c1 98       	rjmp	8000367a <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
8000364a:	06 9b       	mov	r11,r3
8000364c:	30 1c       	mov	r12,1
8000364e:	f0 1f 00 42 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
80003652:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003654:	04 9b       	mov	r11,r2
80003656:	02 9c       	mov	r12,r1
80003658:	f0 1f 00 3b 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
      break;
8000365c:	c1 d8       	rjmp	80003696 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000365e:	06 9b       	mov	r11,r3
80003660:	00 9c       	mov	r12,r0
80003662:	f0 1f 00 3d 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80003666:	06 9b       	mov	r11,r3
80003668:	32 9c       	mov	r12,41
8000366a:	f0 1f 00 3b 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
8000366e:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003670:	04 9b       	mov	r11,r2
80003672:	02 9c       	mov	r12,r1
80003674:	f0 1f 00 34 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
      break;
80003678:	c0 f8       	rjmp	80003696 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000367a:	06 9b       	mov	r11,r3
8000367c:	00 9c       	mov	r12,r0
8000367e:	f0 1f 00 36 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
80003682:	fc 1b 40 00 	movh	r11,0x4000
80003686:	32 9c       	mov	r12,41
80003688:	f0 1f 00 33 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
8000368c:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000368e:	04 9b       	mov	r11,r2
80003690:	02 9c       	mov	r12,r1
80003692:	f0 1f 00 2d 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
80003696:	2f f7       	sub	r7,-1
80003698:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
8000369a:	fe 78 c3 50 	mov	r8,-15536
8000369e:	f0 07 19 00 	cp.h	r7,r8
800036a2:	c4 80       	breq	80003732 <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
800036a4:	0d 89       	ld.ub	r9,r6[0x0]
800036a6:	30 08       	mov	r8,0
800036a8:	f0 09 18 00 	cp.b	r9,r8
800036ac:	cc 51       	brne	80003636 <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
800036ae:	4a 98       	lddpc	r8,80003750 <sd_mmc_spi_internal_init+0x284>
800036b0:	11 89       	ld.ub	r9,r8[0x0]
800036b2:	30 28       	mov	r8,2
800036b4:	f0 09 18 00 	cp.b	r9,r8
800036b8:	c0 a1       	brne	800036cc <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
800036ba:	f0 1f 00 2a 	mcall	80003760 <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
800036be:	5b fc       	cp.w	r12,-1
800036c0:	c3 90       	breq	80003732 <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
800036c2:	58 1c       	cp.w	r12,1
800036c4:	c0 41       	brne	800036cc <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
800036c6:	30 39       	mov	r9,3
800036c8:	4a 28       	lddpc	r8,80003750 <sd_mmc_spi_internal_init+0x284>
800036ca:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
800036cc:	30 0b       	mov	r11,0
800036ce:	33 bc       	mov	r12,59
800036d0:	f0 1f 00 21 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
800036d4:	4a 17       	lddpc	r7,80003758 <sd_mmc_spi_internal_init+0x28c>
800036d6:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800036d8:	e0 6b 00 ff 	mov	r11,255
800036dc:	fe 7c 24 00 	mov	r12,-56320
800036e0:	f0 1f 00 19 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
800036e4:	e0 6b 02 00 	mov	r11,512
800036e8:	31 0c       	mov	r12,16
800036ea:	f0 1f 00 1b 	mcall	80003754 <sd_mmc_spi_internal_init+0x288>
800036ee:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800036f0:	e0 6b 00 ff 	mov	r11,255
800036f4:	fe 7c 24 00 	mov	r12,-56320
800036f8:	f0 1f 00 13 	mcall	80003744 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
800036fc:	0f 89       	ld.ub	r9,r7[0x0]
800036fe:	30 08       	mov	r8,0
80003700:	f0 09 18 00 	cp.b	r9,r8
80003704:	c1 71       	brne	80003732 <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80003706:	49 8c       	lddpc	r12,80003764 <sd_mmc_spi_internal_init+0x298>
80003708:	f0 1f 00 18 	mcall	80003768 <sd_mmc_spi_internal_init+0x29c>
8000370c:	c1 30       	breq	80003732 <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
8000370e:	f0 1f 00 18 	mcall	8000376c <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80003712:	30 19       	mov	r9,1
80003714:	48 e8       	lddpc	r8,8000374c <sd_mmc_spi_internal_init+0x280>
80003716:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80003718:	48 7b       	lddpc	r11,80003734 <sd_mmc_spi_internal_init+0x268>
8000371a:	e0 68 1b 00 	mov	r8,6912
8000371e:	ea 18 00 b7 	orh	r8,0xb7
80003722:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80003724:	48 58       	lddpc	r8,80003738 <sd_mmc_spi_internal_init+0x26c>
80003726:	70 0a       	ld.w	r10,r8[0x0]
80003728:	fe 7c 24 00 	mov	r12,-56320
8000372c:	f0 1f 00 04 	mcall	8000373c <sd_mmc_spi_internal_init+0x270>
80003730:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
80003732:	d8 3a       	popm	r0-r7,pc,r12=0
80003734:	00 00       	add	r0,r0
80003736:	05 70       	ld.ub	r0,--r2
80003738:	00 00       	add	r0,r0
8000373a:	05 80       	ld.ub	r0,r2[0x0]
8000373c:	80 00       	ld.sh	r0,r0[0x0]
8000373e:	41 4c       	lddsp	r12,sp[0x50]
80003740:	80 00       	ld.sh	r0,r0[0x0]
80003742:	42 78       	lddsp	r8,sp[0x9c]
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	41 10       	lddsp	r0,sp[0x44]
80003748:	80 00       	ld.sh	r0,r0[0x0]
8000374a:	42 38       	lddsp	r8,sp[0x8c]
8000374c:	00 00       	add	r0,r0
8000374e:	05 84       	ld.ub	r4,r2[0x0]
80003750:	00 00       	add	r0,r0
80003752:	0a 8a       	andn	r10,r5
80003754:	80 00       	ld.sh	r0,r0[0x0]
80003756:	2f 14       	sub	r4,-15
80003758:	00 00       	add	r0,r0
8000375a:	0a 9c       	mov	r12,r5
8000375c:	80 00       	ld.sh	r0,r0[0x0]
8000375e:	31 bc       	mov	r12,27
80003760:	80 00       	ld.sh	r0,r0[0x0]
80003762:	31 30       	mov	r0,19
80003764:	00 00       	add	r0,r0
80003766:	0a 8c       	andn	r12,r5
80003768:	80 00       	ld.sh	r0,r0[0x0]
8000376a:	33 d8       	mov	r8,61
8000376c:	80 00       	ld.sh	r0,r0[0x0]
8000376e:	2c 5c       	sub	r12,-59

80003770 <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80003770:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
80003772:	f0 1f 00 07 	mcall	8000378c <sd_mmc_spi_mem_check+0x1c>
80003776:	c0 a0       	breq	8000378a <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
80003778:	48 68       	lddpc	r8,80003790 <sd_mmc_spi_mem_check+0x20>
8000377a:	11 89       	ld.ub	r9,r8[0x0]
8000377c:	30 08       	mov	r8,0
8000377e:	f0 09 18 00 	cp.b	r9,r8
80003782:	c0 20       	breq	80003786 <sd_mmc_spi_mem_check+0x16>
80003784:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
80003786:	f0 1f 00 04 	mcall	80003794 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
8000378a:	d8 02       	popm	pc
8000378c:	80 00       	ld.sh	r0,r0[0x0]
8000378e:	2f 54       	sub	r4,-11
80003790:	00 00       	add	r0,r0
80003792:	05 84       	ld.ub	r4,r2[0x0]
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	34 cc       	mov	r12,76

80003798 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
80003798:	eb cd 40 10 	pushm	r4,lr
8000379c:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
800037a0:	48 88       	lddpc	r8,800037c0 <sd_mmc_spi_init+0x28>
800037a2:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
800037a4:	48 88       	lddpc	r8,800037c4 <sd_mmc_spi_init+0x2c>
800037a6:	e8 ea 00 00 	ld.d	r10,r4[0]
800037aa:	f0 eb 00 00 	st.d	r8[0],r10
800037ae:	e8 ea 00 08 	ld.d	r10,r4[8]
800037b2:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
800037b6:	f0 1f 00 05 	mcall	800037c8 <sd_mmc_spi_init+0x30>
}
800037ba:	e3 cd 80 10 	ldm	sp++,r4,pc
800037be:	00 00       	add	r0,r0
800037c0:	00 00       	add	r0,r0
800037c2:	05 80       	ld.ub	r0,r2[0x0]
800037c4:	00 00       	add	r0,r0
800037c6:	05 70       	ld.ub	r0,--r2
800037c8:	80 00       	ld.sh	r0,r0[0x0]
800037ca:	34 cc       	mov	r12,76

800037cc <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
800037cc:	5e fd       	retal	0

800037ce <sd_mmc_spi_removal>:
//!/
bool  sd_mmc_spi_removal(void)
{
  return false;
//  return ((sd_mmc_spi_check_presence()) ? false : true);
}
800037ce:	5e fd       	retal	0

800037d0 <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
800037d0:	d4 01       	pushm	lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
800037d2:	49 88       	lddpc	r8,80003830 <sd_mmc_spi_test_unit_ready+0x60>
800037d4:	11 88       	ld.ub	r8,r8[0x0]
800037d6:	30 19       	mov	r9,1
800037d8:	f2 08 18 00 	cp.b	r8,r9
800037dc:	c1 40       	breq	80003804 <sd_mmc_spi_test_unit_ready+0x34>
800037de:	c0 63       	brcs	800037ea <sd_mmc_spi_test_unit_ready+0x1a>
800037e0:	30 29       	mov	r9,2
800037e2:	f2 08 18 00 	cp.b	r8,r9
800037e6:	c2 01       	brne	80003826 <sd_mmc_spi_test_unit_ready+0x56>
800037e8:	c1 a8       	rjmp	8000381c <sd_mmc_spi_test_unit_ready+0x4c>
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
800037ea:	30 09       	mov	r9,0
800037ec:	49 28       	lddpc	r8,80003834 <sd_mmc_spi_test_unit_ready+0x64>
800037ee:	b0 89       	st.b	r8[0x0],r9
      if (sd_mmc_spi_mem_check())
800037f0:	f0 1f 00 12 	mcall	80003838 <sd_mmc_spi_test_unit_ready+0x68>
800037f4:	c0 31       	brne	800037fa <sd_mmc_spi_test_unit_ready+0x2a>
800037f6:	30 2c       	mov	r12,2
800037f8:	d8 02       	popm	pc
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
800037fa:	30 19       	mov	r9,1
800037fc:	48 d8       	lddpc	r8,80003830 <sd_mmc_spi_test_unit_ready+0x60>
800037fe:	b0 89       	st.b	r8[0x0],r9
80003800:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
80003802:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
80003804:	f0 1f 00 0d 	mcall	80003838 <sd_mmc_spi_test_unit_ready+0x68>
80003808:	c0 20       	breq	8000380c <sd_mmc_spi_test_unit_ready+0x3c>
8000380a:	d8 0a       	popm	pc,r12=0
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
8000380c:	30 29       	mov	r9,2
8000380e:	48 98       	lddpc	r8,80003830 <sd_mmc_spi_test_unit_ready+0x60>
80003810:	b0 89       	st.b	r8[0x0],r9
        sd_mmc_spi_init_done = false;
80003812:	30 09       	mov	r9,0
80003814:	48 88       	lddpc	r8,80003834 <sd_mmc_spi_test_unit_ready+0x64>
80003816:	b0 89       	st.b	r8[0x0],r9
80003818:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
8000381a:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
8000381c:	30 09       	mov	r9,0
8000381e:	48 58       	lddpc	r8,80003830 <sd_mmc_spi_test_unit_ready+0x60>
80003820:	b0 89       	st.b	r8[0x0],r9
80003822:	30 2c       	mov	r12,2
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
80003824:	d8 02       	popm	pc

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80003826:	30 09       	mov	r9,0
80003828:	48 28       	lddpc	r8,80003830 <sd_mmc_spi_test_unit_ready+0x60>
8000382a:	b0 89       	st.b	r8[0x0],r9
8000382c:	30 3c       	mov	r12,3
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
8000382e:	d8 02       	popm	pc
80003830:	00 00       	add	r0,r0
80003832:	00 20       	rsub	r0,r0
80003834:	00 00       	add	r0,r0
80003836:	05 84       	ld.ub	r4,r2[0x0]
80003838:	80 00       	ld.sh	r0,r0[0x0]
8000383a:	37 70       	mov	r0,119

8000383c <sd_mmc_spi_mem_init>:

//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
8000383c:	d4 01       	pushm	lr
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
8000383e:	f0 1f 00 02 	mcall	80003844 <sd_mmc_spi_mem_init+0x8>
}
80003842:	d8 02       	popm	pc
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	34 cc       	mov	r12,76

80003848 <sd_mmc_spi_ram_2_mem>:
//! @return                Ctrl_status
//!   It is ready      ->    CTRL_GOOD
//!   An error occurs  ->    CTRL_FAIL
//!
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
80003848:	eb cd 40 c0 	pushm	r6-r7,lr
8000384c:	18 96       	mov	r6,r12
8000384e:	16 97       	mov	r7,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
80003850:	f0 1f 00 12 	mcall	80003898 <sd_mmc_spi_ram_2_mem+0x50>

   if (!sd_mmc_spi_init_done)
80003854:	49 28       	lddpc	r8,8000389c <sd_mmc_spi_ram_2_mem+0x54>
80003856:	11 89       	ld.ub	r9,r8[0x0]
80003858:	30 08       	mov	r8,0
8000385a:	f0 09 18 00 	cp.b	r9,r8
8000385e:	c0 c1       	brne	80003876 <sd_mmc_spi_ram_2_mem+0x2e>
   {
      sd_mmc_spi_mem_init();
80003860:	f0 1f 00 10 	mcall	800038a0 <sd_mmc_spi_ram_2_mem+0x58>
   }

   if (sd_mmc_spi_init_done)
80003864:	48 e8       	lddpc	r8,8000389c <sd_mmc_spi_ram_2_mem+0x54>
80003866:	11 89       	ld.ub	r9,r8[0x0]
80003868:	30 08       	mov	r8,0
8000386a:	f0 09 18 00 	cp.b	r9,r8
8000386e:	c0 41       	brne	80003876 <sd_mmc_spi_ram_2_mem+0x2e>
80003870:	30 2c       	mov	r12,2
80003872:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   {
     sd_mmc_spi_write_open(addr);
80003876:	0c 9c       	mov	r12,r6
80003878:	f0 1f 00 0b 	mcall	800038a4 <sd_mmc_spi_ram_2_mem+0x5c>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
8000387c:	0e 9c       	mov	r12,r7
8000387e:	f0 1f 00 0b 	mcall	800038a8 <sd_mmc_spi_ram_2_mem+0x60>
80003882:	c0 61       	brne	8000388e <sd_mmc_spi_ram_2_mem+0x46>
     {
       sd_mmc_spi_write_close();
80003884:	f0 1f 00 0a 	mcall	800038ac <sd_mmc_spi_ram_2_mem+0x64>
80003888:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
8000388a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     }
     sd_mmc_spi_write_close();
8000388e:	f0 1f 00 08 	mcall	800038ac <sd_mmc_spi_ram_2_mem+0x64>
80003892:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003896:	00 00       	add	r0,r0
80003898:	80 00       	ld.sh	r0,r0[0x0]
8000389a:	2f 54       	sub	r4,-11
8000389c:	00 00       	add	r0,r0
8000389e:	05 84       	ld.ub	r4,r2[0x0]
800038a0:	80 00       	ld.sh	r0,r0[0x0]
800038a2:	38 3c       	mov	r12,-125
800038a4:	80 00       	ld.sh	r0,r0[0x0]
800038a6:	2e 08       	sub	r8,-32
800038a8:	80 00       	ld.sh	r0,r0[0x0]
800038aa:	2f d0       	sub	r0,-3
800038ac:	80 00       	ld.sh	r0,r0[0x0]
800038ae:	2d 78       	sub	r8,-41

800038b0 <sd_mmc_spi_mem_2_ram>:
//------------ Standard functions for read/write 1 sector to 1 sector ram buffer -----------------

#if ACCESS_MEM_TO_RAM == true

Ctrl_status sd_mmc_spi_mem_2_ram(uint32_t addr, void *ram)
{
800038b0:	eb cd 40 c0 	pushm	r6-r7,lr
800038b4:	18 97       	mov	r7,r12
800038b6:	16 96       	mov	r6,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
800038b8:	f0 1f 00 12 	mcall	80003900 <sd_mmc_spi_mem_2_ram+0x50>

   if (!sd_mmc_spi_init_done)
800038bc:	49 28       	lddpc	r8,80003904 <sd_mmc_spi_mem_2_ram+0x54>
800038be:	11 89       	ld.ub	r9,r8[0x0]
800038c0:	30 08       	mov	r8,0
800038c2:	f0 09 18 00 	cp.b	r9,r8
800038c6:	c0 c1       	brne	800038de <sd_mmc_spi_mem_2_ram+0x2e>
   {
      sd_mmc_spi_mem_init();
800038c8:	f0 1f 00 10 	mcall	80003908 <sd_mmc_spi_mem_2_ram+0x58>
   }

   if (!sd_mmc_spi_init_done)
800038cc:	48 e8       	lddpc	r8,80003904 <sd_mmc_spi_mem_2_ram+0x54>
800038ce:	11 89       	ld.ub	r9,r8[0x0]
800038d0:	30 08       	mov	r8,0
800038d2:	f0 09 18 00 	cp.b	r9,r8
800038d6:	c0 41       	brne	800038de <sd_mmc_spi_mem_2_ram+0x2e>
800038d8:	30 2c       	mov	r12,2
800038da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
800038de:	0e 9c       	mov	r12,r7
800038e0:	f0 1f 00 0b 	mcall	8000390c <sd_mmc_spi_mem_2_ram+0x5c>
800038e4:	c0 c0       	breq	800038fc <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
800038e6:	0c 9c       	mov	r12,r6
800038e8:	f0 1f 00 0a 	mcall	80003910 <sd_mmc_spi_mem_2_ram+0x60>
800038ec:	c0 80       	breq	800038fc <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
800038ee:	f0 1f 00 0a 	mcall	80003914 <sd_mmc_spi_mem_2_ram+0x64>
800038f2:	ec 1c 00 01 	eorl	r12,0x1
800038f6:	5c 5c       	castu.b	r12
800038f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800038fc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	2f 54       	sub	r4,-11
80003904:	00 00       	add	r0,r0
80003906:	05 84       	ld.ub	r4,r2[0x0]
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	38 3c       	mov	r12,-125
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	2e 30       	sub	r0,-29
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	32 74       	mov	r4,39
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	2e 24       	sub	r4,-30

80003918 <sd_mmc_spi_read_capacity>:
}



Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector)
{
80003918:	eb cd 40 80 	pushm	r7,lr
8000391c:	18 97       	mov	r7,r12
//   sd_mmc_spi_check_presence();   // omitted because creates interferences with "sd_mmc_spi_test_unit_ready()" function
   Sd_mmc_spi_access_signal_on();

   if (!sd_mmc_spi_init_done)
8000391e:	48 c8       	lddpc	r8,8000394c <sd_mmc_spi_read_capacity+0x34>
80003920:	11 89       	ld.ub	r9,r8[0x0]
80003922:	30 08       	mov	r8,0
80003924:	f0 09 18 00 	cp.b	r9,r8
80003928:	c0 c1       	brne	80003940 <sd_mmc_spi_read_capacity+0x28>
   {
      sd_mmc_spi_mem_init();
8000392a:	f0 1f 00 0a 	mcall	80003950 <sd_mmc_spi_read_capacity+0x38>
   }

   if (sd_mmc_spi_init_done)
8000392e:	48 88       	lddpc	r8,8000394c <sd_mmc_spi_read_capacity+0x34>
80003930:	11 89       	ld.ub	r9,r8[0x0]
80003932:	30 08       	mov	r8,0
80003934:	f0 09 18 00 	cp.b	r9,r8
80003938:	c0 41       	brne	80003940 <sd_mmc_spi_read_capacity+0x28>
8000393a:	30 2c       	mov	r12,2
8000393c:	e3 cd 80 80 	ldm	sp++,r7,pc
   {
     *nb_sector = sd_mmc_spi_last_block_address+1;
80003940:	48 58       	lddpc	r8,80003954 <sd_mmc_spi_read_capacity+0x3c>
80003942:	70 08       	ld.w	r8,r8[0x0]
80003944:	2f f8       	sub	r8,-1
80003946:	8f 08       	st.w	r7[0x0],r8
80003948:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000394c:	00 00       	add	r0,r0
8000394e:	05 84       	ld.ub	r4,r2[0x0]
80003950:	80 00       	ld.sh	r0,r0[0x0]
80003952:	38 3c       	mov	r12,-125
80003954:	00 00       	add	r0,r0
80003956:	0a 84       	andn	r4,r5

80003958 <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80003958:	fe 78 0c 00 	mov	r8,-62464
8000395c:	71 d9       	ld.w	r9,r8[0x74]
8000395e:	a3 a9       	sbr	r9,0x2
80003960:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80003964:	78 28       	ld.w	r8,r12[0x8]
80003966:	bf b8       	sbr	r8,0x1f
80003968:	99 28       	st.w	r12[0x8],r8
}
8000396a:	5e fc       	retal	r12

8000396c <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
8000396c:	78 28       	ld.w	r8,r12[0x8]
8000396e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80003972:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
80003974:	fe 78 0c 00 	mov	r8,-62464
80003978:	71 d9       	ld.w	r9,r8[0x74]
8000397a:	a3 c9       	cbr	r9,0x2
8000397c:	f1 49 00 74 	st.w	r8[116],r9
}
80003980:	5e fc       	retal	r12

80003982 <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
80003982:	78 28       	ld.w	r8,r12[0x8]
80003984:	e6 18 40 00 	andh	r8,0x4000,COH
80003988:	c0 50       	breq	80003992 <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
8000398a:	78 28       	ld.w	r8,r12[0x8]
8000398c:	bf c8       	cbr	r8,0x1e
8000398e:	99 28       	st.w	r12[0x8],r8
80003990:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
80003992:	78 28       	ld.w	r8,r12[0x8]
80003994:	bf a8       	sbr	r8,0x1e
80003996:	99 28       	st.w	r12[0x8],r8
80003998:	5e fc       	retal	r12

8000399a <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
8000399a:	fe 78 0c 00 	mov	r8,-62464
8000399e:	71 d9       	ld.w	r9,r8[0x74]
800039a0:	30 0c       	mov	r12,0
800039a2:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800039a6:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
800039aa:	71 d9       	ld.w	r9,r8[0x74]
800039ac:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800039b0:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
800039b4:	a9 6a       	lsl	r10,0x8
800039b6:	16 3a       	cp.w	r10,r11
800039b8:	e0 88 00 09 	brls	800039ca <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
800039bc:	71 d9       	ld.w	r9,r8[0x74]
800039be:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800039c2:	f1 49 00 74 	st.w	r8[116],r9
800039c6:	31 6c       	mov	r12,22
    return EINVAL;
800039c8:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
800039ca:	f6 0a 0d 08 	divu	r8,r11,r10
800039ce:	5c 88       	casts.h	r8

  if (div > 1) {
800039d0:	30 19       	mov	r9,1
800039d2:	f2 08 19 00 	cp.h	r8,r9
800039d6:	e0 88 00 14 	brls	800039fe <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
800039da:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
800039de:	20 1c       	sub	r12,1
800039e0:	5c 5c       	castu.b	r12
800039e2:	fe 79 0c 00 	mov	r9,-62464
800039e6:	73 da       	ld.w	r10,r9[0x74]
800039e8:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
800039ec:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
800039f0:	73 da       	ld.w	r10,r9[0x74]
800039f2:	30 1c       	mov	r12,1
800039f4:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
800039f8:	f3 4a 00 74 	st.w	r9[116],r10
800039fc:	c0 98       	rjmp	80003a0e <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
800039fe:	fe 79 0c 00 	mov	r9,-62464
80003a02:	73 da       	ld.w	r10,r9[0x74]
80003a04:	30 0c       	mov	r12,0
80003a06:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003a0a:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
80003a0e:	5c 78       	castu.h	r8
80003a10:	a9 68       	lsl	r8,0x8
80003a12:	f6 08 0d 0a 	divu	r10,r11,r8
80003a16:	5e fa       	retal	r10

80003a18 <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80003a18:	e0 4c 56 22 	cp.w	r12,22050
80003a1c:	e0 80 00 8d 	breq	80003b36 <abdac_set_dac_sample_rate+0x11e>
80003a20:	e0 8b 00 12 	brhi	80003a44 <abdac_set_dac_sample_rate+0x2c>
80003a24:	e0 4c 2b 11 	cp.w	r12,11025
80003a28:	c3 b0       	breq	80003a9e <abdac_set_dac_sample_rate+0x86>
80003a2a:	e0 8b 00 06 	brhi	80003a36 <abdac_set_dac_sample_rate+0x1e>
80003a2e:	e0 4c 1f 40 	cp.w	r12,8000
80003a32:	c1 b1       	brne	80003a68 <abdac_set_dac_sample_rate+0x50>
80003a34:	c1 b8       	rjmp	80003a6a <abdac_set_dac_sample_rate+0x52>
80003a36:	e0 4c 2e e0 	cp.w	r12,12000
80003a3a:	c4 b0       	breq	80003ad0 <abdac_set_dac_sample_rate+0xb8>
80003a3c:	e0 4c 3e 80 	cp.w	r12,16000
80003a40:	c1 41       	brne	80003a68 <abdac_set_dac_sample_rate+0x50>
80003a42:	c6 18       	rjmp	80003b04 <abdac_set_dac_sample_rate+0xec>
80003a44:	e0 4c 7d 00 	cp.w	r12,32000
80003a48:	e0 80 00 aa 	breq	80003b9c <abdac_set_dac_sample_rate+0x184>
80003a4c:	e0 8b 00 06 	brhi	80003a58 <abdac_set_dac_sample_rate+0x40>
80003a50:	e0 4c 5d c0 	cp.w	r12,24000
80003a54:	c0 a1       	brne	80003a68 <abdac_set_dac_sample_rate+0x50>
80003a56:	c8 98       	rjmp	80003b68 <abdac_set_dac_sample_rate+0x150>
80003a58:	e0 4c ac 44 	cp.w	r12,44100
80003a5c:	e0 80 00 b9 	breq	80003bce <abdac_set_dac_sample_rate+0x1b6>
80003a60:	e0 4c bb 80 	cp.w	r12,48000
80003a64:	e0 80 00 ce 	breq	80003c00 <abdac_set_dac_sample_rate+0x1e8>
80003a68:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80003a6a:	fe 78 0c 00 	mov	r8,-62464
80003a6e:	71 d9       	ld.w	r9,r8[0x74]
80003a70:	30 ea       	mov	r10,14
80003a72:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003a76:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003a7a:	71 d9       	ld.w	r9,r8[0x74]
80003a7c:	30 1c       	mov	r12,1
80003a7e:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003a82:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003a86:	71 d9       	ld.w	r9,r8[0x74]
80003a88:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003a8c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003a90:	71 d9       	ld.w	r9,r8[0x74]
80003a92:	30 0a       	mov	r10,0
80003a94:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003a98:	f1 49 00 74 	st.w	r8[116],r9
      break;
80003a9c:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003a9e:	fe 78 0c 00 	mov	r8,-62464
80003aa2:	71 d9       	ld.w	r9,r8[0x74]
80003aa4:	30 1c       	mov	r12,1
80003aa6:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003aaa:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003aae:	71 d9       	ld.w	r9,r8[0x74]
80003ab0:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003ab4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003ab8:	71 d9       	ld.w	r9,r8[0x74]
80003aba:	30 0a       	mov	r10,0
80003abc:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003ac0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003ac4:	71 d9       	ld.w	r9,r8[0x74]
80003ac6:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003aca:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003ace:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
80003ad0:	fe 78 0c 00 	mov	r8,-62464
80003ad4:	71 d9       	ld.w	r9,r8[0x74]
80003ad6:	30 9a       	mov	r10,9
80003ad8:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003adc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003ae0:	71 d9       	ld.w	r9,r8[0x74]
80003ae2:	30 1c       	mov	r12,1
80003ae4:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003ae8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003aec:	71 d9       	ld.w	r9,r8[0x74]
80003aee:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003af2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003af6:	71 d9       	ld.w	r9,r8[0x74]
80003af8:	30 0a       	mov	r10,0
80003afa:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003afe:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003b02:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80003b04:	fe 78 0c 00 	mov	r8,-62464
80003b08:	71 d9       	ld.w	r9,r8[0x74]
80003b0a:	30 5a       	mov	r10,5
80003b0c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003b10:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003b14:	71 d9       	ld.w	r9,r8[0x74]
80003b16:	30 1c       	mov	r12,1
80003b18:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003b1c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003b20:	71 d9       	ld.w	r9,r8[0x74]
80003b22:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003b26:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003b2a:	71 d9       	ld.w	r9,r8[0x74]
80003b2c:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003b30:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003b34:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80003b36:	fe 78 0c 00 	mov	r8,-62464
80003b3a:	71 d9       	ld.w	r9,r8[0x74]
80003b3c:	30 0a       	mov	r10,0
80003b3e:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003b42:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80003b46:	71 d9       	ld.w	r9,r8[0x74]
80003b48:	30 1c       	mov	r12,1
80003b4a:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003b4e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003b52:	71 d9       	ld.w	r9,r8[0x74]
80003b54:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003b58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003b5c:	71 d9       	ld.w	r9,r8[0x74]
80003b5e:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003b62:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003b66:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80003b68:	fe 78 0c 00 	mov	r8,-62464
80003b6c:	71 d9       	ld.w	r9,r8[0x74]
80003b6e:	30 4a       	mov	r10,4
80003b70:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003b74:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003b78:	71 d9       	ld.w	r9,r8[0x74]
80003b7a:	30 1c       	mov	r12,1
80003b7c:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003b80:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003b84:	71 d9       	ld.w	r9,r8[0x74]
80003b86:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003b8a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003b8e:	71 d9       	ld.w	r9,r8[0x74]
80003b90:	30 0a       	mov	r10,0
80003b92:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003b96:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003b9a:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
80003b9c:	fe 78 0c 00 	mov	r8,-62464
80003ba0:	71 d9       	ld.w	r9,r8[0x74]
80003ba2:	30 2a       	mov	r10,2
80003ba4:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003ba8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003bac:	71 d9       	ld.w	r9,r8[0x74]
80003bae:	30 1c       	mov	r12,1
80003bb0:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003bb4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003bb8:	71 d9       	ld.w	r9,r8[0x74]
80003bba:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003bbe:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003bc2:	71 d9       	ld.w	r9,r8[0x74]
80003bc4:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003bc8:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003bcc:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
80003bce:	fe 78 0c 00 	mov	r8,-62464
80003bd2:	71 da       	ld.w	r10,r8[0x74]
80003bd4:	30 09       	mov	r9,0
80003bd6:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
80003bda:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
80003bde:	71 da       	ld.w	r10,r8[0x74]
80003be0:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80003be4:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003be8:	71 da       	ld.w	r10,r8[0x74]
80003bea:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
80003bee:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003bf2:	71 d9       	ld.w	r9,r8[0x74]
80003bf4:	30 1c       	mov	r12,1
80003bf6:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003bfa:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003bfe:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003c00:	fe 78 0c 00 	mov	r8,-62464
80003c04:	71 d9       	ld.w	r9,r8[0x74]
80003c06:	30 1c       	mov	r12,1
80003c08:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003c0c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003c10:	71 d9       	ld.w	r9,r8[0x74]
80003c12:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003c16:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003c1a:	71 d9       	ld.w	r9,r8[0x74]
80003c1c:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003c20:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003c24:	71 d9       	ld.w	r9,r8[0x74]
80003c26:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003c2a:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
80003c2e:	5e fc       	retal	r12

80003c30 <sdramc_ck_delay>:
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
80003c30:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
80003c34:	f0 0c 00 0c 	add	r12,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80003c38:	18 38       	cp.w	r8,r12
80003c3a:	e0 88 00 06 	brls	80003c46 <sdramc_ck_delay+0x16>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80003c3e:	e1 b8 00 42 	mfsr	r8,0x108
80003c42:	10 3c       	cp.w	r12,r8
80003c44:	cf d3       	brcs	80003c3e <sdramc_ck_delay+0xe>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
80003c46:	e1 b8 00 42 	mfsr	r8,0x108
80003c4a:	10 3c       	cp.w	r12,r8
80003c4c:	fe 9b ff fd 	brhi	80003c46 <sdramc_ck_delay+0x16>
}
80003c50:	5e fc       	retal	r12
80003c52:	d7 03       	nop

80003c54 <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
80003c54:	d4 31       	pushm	r0-r7,lr
80003c56:	20 2d       	sub	sp,8
80003c58:	18 91       	mov	r1,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003c5a:	ee 7b 42 3f 	mov	r11,999999
80003c5e:	f8 0b 00 09 	add	r9,r12,r11
80003c62:	e0 60 de 83 	mov	r0,56963
80003c66:	ea 10 43 1b 	orh	r0,0x431b
80003c6a:	f2 00 06 48 	mulu.d	r8,r9,r0
80003c6e:	f2 06 16 12 	lsr	r6,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
80003c72:	32 7b       	mov	r11,39
80003c74:	4d 0c       	lddpc	r12,80003db4 <sdramc_init+0x160>
80003c76:	f0 1f 00 51 	mcall	80003db8 <sdramc_init+0x164>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80003c7a:	fe 68 10 00 	mov	r8,-126976
80003c7e:	f0 f9 01 24 	ld.w	r9,r8[292]
80003c82:	a1 b9       	sbr	r9,0x1
80003c84:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80003c88:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80003c8c:	ec 09 15 04 	lsl	r9,r6,0x4
80003c90:	0c 19       	sub	r9,r6
80003c92:	f2 c3 fc 19 	sub	r3,r9,-999
80003c96:	e0 65 4d d3 	mov	r5,19923
80003c9a:	ea 15 10 62 	orh	r5,0x1062
80003c9e:	e6 05 06 42 	mulu.d	r2,r3,r5
80003ca2:	a7 83       	lsr	r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80003ca4:	ec 02 15 05 	lsl	r2,r6,0x5
80003ca8:	0c 02       	add	r2,r6
80003caa:	a1 72       	lsl	r2,0x1
80003cac:	e4 06 00 0b 	add	r11,r2,r6
80003cb0:	f6 cb fc 19 	sub	r11,r11,-999
80003cb4:	f6 05 06 4a 	mulu.d	r10,r11,r5
80003cb8:	a7 8b       	lsr	r11,0x6
80003cba:	bd 6b       	lsl	r11,0x1c
80003cbc:	16 9c       	mov	r12,r11
80003cbe:	e8 1c 00 d9 	orl	r12,0xd9
80003cc2:	ec 08 15 03 	lsl	r8,r6,0x3
80003cc6:	f0 06 01 0a 	sub	r10,r8,r6
80003cca:	a1 7a       	lsl	r10,0x1
80003ccc:	f4 c7 fc 19 	sub	r7,r10,-999
80003cd0:	ee 05 06 4a 	mulu.d	r10,r7,r5
80003cd4:	fa eb 00 00 	st.d	sp[0],r10
80003cd8:	40 0a       	lddsp	r10,sp[0x0]
80003cda:	a3 6a       	lsl	r10,0x2
80003cdc:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003ce0:	14 4c       	or	r12,r10
80003ce2:	a3 69       	lsl	r9,0x2
80003ce4:	f2 c9 fc 19 	sub	r9,r9,-999
80003ce8:	f2 05 06 4a 	mulu.d	r10,r9,r5
80003cec:	fa eb 00 00 	st.d	sp[0],r10
80003cf0:	40 09       	lddsp	r9,sp[0x0]
80003cf2:	a7 69       	lsl	r9,0x6
80003cf4:	e2 19 f0 00 	andl	r9,0xf000,COH
80003cf8:	f9 e9 10 0a 	or	r10,r12,r9
80003cfc:	e6 09 15 10 	lsl	r9,r3,0x10
80003d00:	e6 19 00 0f 	andh	r9,0xf,COH
80003d04:	12 4a       	or	r10,r9
80003d06:	e6 09 15 14 	lsl	r9,r3,0x14
80003d0a:	e6 19 00 f0 	andh	r9,0xf0,COH
80003d0e:	12 4a       	or	r10,r9
80003d10:	f0 06 00 09 	add	r9,r8,r6
80003d14:	ec 09 00 29 	add	r9,r6,r9<<0x2
80003d18:	f2 c9 fc 19 	sub	r9,r9,-999
80003d1c:	f2 05 06 48 	mulu.d	r8,r9,r5
80003d20:	b3 69       	lsl	r9,0x12
80003d22:	e6 19 0f 00 	andh	r9,0xf00,COH
80003d26:	f5 e9 10 08 	or	r8,r10,r9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
80003d2a:	fe 67 20 00 	mov	r7,-122880
80003d2e:	8f 28       	st.w	r7[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
80003d30:	6e 28       	ld.w	r8,r7[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
80003d32:	30 18       	mov	r8,1
80003d34:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003d36:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003d38:	fc 14 d0 00 	movh	r4,0xd000
80003d3c:	88 08       	ld.sh	r8,r4[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
80003d3e:	ec 0c 10 64 	mul	r12,r6,100
80003d42:	f0 1f 00 1f 	mcall	80003dbc <sdramc_init+0x168>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
80003d46:	30 28       	mov	r8,2
80003d48:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003d4a:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003d4c:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
80003d4e:	06 9c       	mov	r12,r3
80003d50:	f0 1f 00 1b 	mcall	80003dbc <sdramc_init+0x168>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
80003d54:	30 48       	mov	r8,4
80003d56:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003d58:	6e 08       	ld.w	r8,r7[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80003d5a:	e4 c3 fc 19 	sub	r3,r2,-999
80003d5e:	e6 05 06 42 	mulu.d	r2,r3,r5
80003d62:	a7 83       	lsr	r3,0x6
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80003d64:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80003d66:	06 9c       	mov	r12,r3
80003d68:	f0 1f 00 15 	mcall	80003dbc <sdramc_init+0x168>
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80003d6c:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80003d6e:	06 9c       	mov	r12,r3
80003d70:	f0 1f 00 13 	mcall	80003dbc <sdramc_init+0x168>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
80003d74:	30 38       	mov	r8,3
80003d76:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003d78:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003d7a:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
80003d7c:	ec 09 15 01 	lsl	r9,r6,0x1
80003d80:	f2 c9 fc 19 	sub	r9,r9,-999
80003d84:	f2 05 06 48 	mulu.d	r8,r9,r5
80003d88:	f2 0c 16 06 	lsr	r12,r9,0x6
80003d8c:	f0 1f 00 0c 	mcall	80003dbc <sdramc_init+0x168>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
80003d90:	30 08       	mov	r8,0
80003d92:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003d94:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003d96:	88 08       	ld.sh	r8,r4[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
80003d98:	e2 00 06 40 	mulu.d	r0,r1,r0
80003d9c:	b3 81       	lsr	r1,0x12
80003d9e:	e0 68 1e 84 	mov	r8,7812
80003da2:	b1 31       	mul	r1,r8
80003da4:	e2 05 06 44 	mulu.d	r4,r1,r5
80003da8:	a7 85       	lsr	r5,0x6
80003daa:	8f 15       	st.w	r7[0x4],r5
  AVR32_SDRAMC.tr;
80003dac:	6e 18       	ld.w	r8,r7[0x4]
}
80003dae:	2f ed       	sub	sp,-8
80003db0:	d8 32       	popm	r0-r7,pc
80003db2:	00 00       	add	r0,r0
80003db4:	80 00       	ld.sh	r0,r0[0x0]
80003db6:	a5 58       	asr	r8,0x5
80003db8:	80 00       	ld.sh	r0,r0[0x0]
80003dba:	8b e0       	st.w	r5[0x38],r0
80003dbc:	80 00       	ld.sh	r0,r0[0x0]
80003dbe:	3c 30       	mov	r0,-61

80003dc0 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80003dc0:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003dc4:	ee 78 42 3f 	mov	r8,999999
80003dc8:	f8 08 00 09 	add	r9,r12,r8
80003dcc:	e0 68 de 83 	mov	r8,56963
80003dd0:	ea 18 43 1b 	orh	r8,0x431b
80003dd4:	f2 08 06 48 	mulu.d	r8,r9,r8
80003dd8:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80003ddc:	f0 08 00 25 	add	r5,r8,r8<<0x2
80003de0:	a3 65       	lsl	r5,0x2
80003de2:	ea c5 fc 19 	sub	r5,r5,-999
80003de6:	e0 69 4d d3 	mov	r9,19923
80003dea:	ea 19 10 62 	orh	r9,0x1062
80003dee:	ea 09 06 44 	mulu.d	r4,r5,r9
80003df2:	a7 85       	lsr	r5,0x6
80003df4:	f0 0a 15 04 	lsl	r10,r8,0x4
80003df8:	f4 08 01 07 	sub	r7,r10,r8
80003dfc:	a1 77       	lsl	r7,0x1
80003dfe:	ee c7 fc 19 	sub	r7,r7,-999
80003e02:	ee 09 06 46 	mulu.d	r6,r7,r9
80003e06:	0e 94       	mov	r4,r7
80003e08:	a7 84       	lsr	r4,0x6
80003e0a:	f4 08 01 07 	sub	r7,r10,r8
80003e0e:	a3 67       	lsl	r7,0x2
80003e10:	ee c7 fc 19 	sub	r7,r7,-999
80003e14:	ee 09 06 46 	mulu.d	r6,r7,r9
80003e18:	a7 87       	lsr	r7,0x6
80003e1a:	f0 03 10 5a 	mul	r3,r8,90
80003e1e:	e6 c3 fc 19 	sub	r3,r3,-999
80003e22:	e6 09 06 42 	mulu.d	r2,r3,r9
80003e26:	e6 0c 16 06 	lsr	r12,r3,0x6
80003e2a:	e0 63 00 d2 	mov	r3,210
80003e2e:	f0 03 02 43 	mul	r3,r8,r3
80003e32:	e6 c3 fc 19 	sub	r3,r3,-999
80003e36:	e6 09 06 42 	mulu.d	r2,r3,r9
80003e3a:	e6 06 16 06 	lsr	r6,r3,0x6
80003e3e:	f4 08 01 0b 	sub	r11,r10,r8
80003e42:	a5 6b       	lsl	r11,0x4
80003e44:	f6 cb fc 19 	sub	r11,r11,-999
80003e48:	f6 09 06 4a 	mulu.d	r10,r11,r9
80003e4c:	f6 0e 16 06 	lsr	lr,r11,0x6
80003e50:	f0 03 10 64 	mul	r3,r8,100
80003e54:	e6 c3 fc 19 	sub	r3,r3,-999
80003e58:	e6 09 06 42 	mulu.d	r2,r3,r9
80003e5c:	a7 83       	lsr	r3,0x6
80003e5e:	e0 6a 01 0e 	mov	r10,270
80003e62:	b5 38       	mul	r8,r10
80003e64:	f0 c8 fc 19 	sub	r8,r8,-999
80003e68:	f0 09 06 48 	mulu.d	r8,r8,r9
80003e6c:	a7 89       	lsr	r9,0x6
80003e6e:	ec 04 00 0a 	add	r10,r6,r4
80003e72:	1c 3a       	cp.w	r10,lr
80003e74:	f4 0e 17 20 	movhs	lr,r10
80003e78:	ee 05 00 0b 	add	r11,r7,r5
80003e7c:	18 3b       	cp.w	r11,r12
80003e7e:	f6 0c 17 20 	movhs	r12,r11
80003e82:	06 3b       	cp.w	r11,r3
80003e84:	e6 0b 17 30 	movlo	r11,r3
80003e88:	12 3a       	cp.w	r10,r9
80003e8a:	f4 09 17 20 	movhs	r9,r10
80003e8e:	eb e4 11 05 	or	r5,r5,r4<<0x10
80003e92:	fe 6a 1c 00 	mov	r10,-123904
80003e96:	95 05       	st.w	r10[0x0],r5
80003e98:	ef e6 11 07 	or	r7,r7,r6<<0x10
80003e9c:	ef ec 10 87 	or	r7,r7,r12<<0x8
80003ea0:	ef ee 11 87 	or	r7,r7,lr<<0x18
80003ea4:	95 17       	st.w	r10[0x4],r7
80003ea6:	1c 39       	cp.w	r9,lr
80003ea8:	f2 0e 17 20 	movhs	lr,r9
80003eac:	18 3b       	cp.w	r11,r12
80003eae:	f8 0b 17 30 	movlo	r11,r12
80003eb2:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
80003eb6:	95 2b       	st.w	r10[0x8],r11
80003eb8:	e0 68 10 03 	mov	r8,4099
80003ebc:	95 38       	st.w	r10[0xc],r8
80003ebe:	30 19       	mov	r9,1
80003ec0:	48 48       	lddpc	r8,80003ed0 <smc_init+0x110>
80003ec2:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80003ec4:	31 4b       	mov	r11,20
80003ec6:	48 4c       	lddpc	r12,80003ed4 <smc_init+0x114>
80003ec8:	f0 1f 00 04 	mcall	80003ed8 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80003ecc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003ed0:	00 00       	add	r0,r0
80003ed2:	05 88       	ld.ub	r8,r2[0x0]
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	a6 90       	st.b	r3[0x1],r0
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	8b e0       	st.w	r5[0x38],r0

80003edc <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80003edc:	30 e8       	mov	r8,14
80003ede:	f0 0c 18 00 	cp.b	r12,r8
80003ee2:	e0 88 00 03 	brls	80003ee8 <pdca_get_handler+0xc>
80003ee6:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80003ee8:	a7 6c       	lsl	r12,0x6
80003eea:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80003eee:	5e fc       	retal	r12

80003ef0 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80003ef0:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003ef2:	f0 1f 00 03 	mcall	80003efc <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80003ef6:	30 28       	mov	r8,2
80003ef8:	99 58       	st.w	r12[0x14],r8
}
80003efa:	d8 02       	popm	pc
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	3e dc       	mov	r12,-19

80003f00 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
80003f00:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003f02:	f0 1f 00 03 	mcall	80003f0c <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
80003f06:	30 18       	mov	r8,1
80003f08:	99 58       	st.w	r12[0x14],r8
}
80003f0a:	d8 02       	popm	pc
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	3e dc       	mov	r12,-19

80003f10 <pdca_get_transfer_status>:

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
}

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
80003f10:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003f12:	f0 1f 00 03 	mcall	80003f1c <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
80003f16:	78 bc       	ld.w	r12,r12[0x2c]
}
80003f18:	d8 02       	popm	pc
80003f1a:	00 00       	add	r0,r0
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	3e dc       	mov	r12,-19

80003f20 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80003f20:	d4 01       	pushm	lr
80003f22:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003f24:	f0 1f 00 08 	mcall	80003f44 <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003f28:	e1 b8 00 00 	mfsr	r8,0x0
80003f2c:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80003f2e:	d3 03       	ssrf	0x10

	return flags;
80003f30:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
80003f32:	30 19       	mov	r9,1
80003f34:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
80003f36:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003f38:	e6 18 00 01 	andh	r8,0x1,COH
80003f3c:	c0 21       	brne	80003f40 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
80003f3e:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80003f40:	2f fd       	sub	sp,-4
80003f42:	d8 02       	popm	pc
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	3e dc       	mov	r12,-19

80003f48 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
80003f48:	d4 01       	pushm	lr
80003f4a:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003f4c:	f0 1f 00 08 	mcall	80003f6c <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003f50:	e1 b8 00 00 	mfsr	r8,0x0
80003f54:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80003f56:	d3 03       	ssrf	0x10

	return flags;
80003f58:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
80003f5a:	30 29       	mov	r9,2
80003f5c:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
80003f5e:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003f60:	e6 18 00 01 	andh	r8,0x1,COH
80003f64:	c0 21       	brne	80003f68 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
80003f66:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80003f68:	2f fd       	sub	sp,-4
80003f6a:	d8 02       	popm	pc
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	3e dc       	mov	r12,-19

80003f70 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80003f70:	eb cd 40 e0 	pushm	r5-r7,lr
80003f74:	20 1d       	sub	sp,4
80003f76:	18 95       	mov	r5,r12
80003f78:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003f7a:	f0 1f 00 13 	mcall	80003fc4 <pdca_init_channel+0x54>
80003f7e:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80003f80:	0a 9c       	mov	r12,r5
80003f82:	f0 1f 00 12 	mcall	80003fc8 <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
80003f86:	0a 9c       	mov	r12,r5
80003f88:	f0 1f 00 11 	mcall	80003fcc <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003f8c:	e1 b8 00 00 	mfsr	r8,0x0
80003f90:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80003f92:	d3 03       	ssrf	0x10

	return flags;
80003f94:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
80003f96:	6c 09       	ld.w	r9,r6[0x0]
80003f98:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
80003f9a:	6c 19       	ld.w	r9,r6[0x4]
80003f9c:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
80003f9e:	6c 49       	ld.w	r9,r6[0x10]
80003fa0:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
80003fa2:	6c 29       	ld.w	r9,r6[0x8]
80003fa4:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
80003fa6:	6c 39       	ld.w	r9,r6[0xc]
80003fa8:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
80003faa:	6c 59       	ld.w	r9,r6[0x14]
80003fac:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80003fae:	e0 69 01 00 	mov	r9,256
80003fb2:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
80003fb4:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003fb6:	e6 18 00 01 	andh	r8,0x1,COH
80003fba:	c0 21       	brne	80003fbe <pdca_init_channel+0x4e>
      cpu_irq_enable();
80003fbc:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80003fbe:	2f fd       	sub	sp,-4
80003fc0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	3e dc       	mov	r12,-19
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	3f 48       	mov	r8,-12
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3f 20       	mov	r0,-14

80003fd0 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80003fd0:	58 0b       	cp.w	r11,0
80003fd2:	c1 90       	breq	80004004 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003fd4:	58 6c       	cp.w	r12,6
80003fd6:	e0 8b 00 17 	brhi	80004004 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80003fda:	76 0a       	ld.w	r10,r11[0x0]
80003fdc:	fe 78 30 00 	mov	r8,-53248
80003fe0:	f8 c9 ff f0 	sub	r9,r12,-16
80003fe4:	a5 79       	lsl	r9,0x5
80003fe6:	f0 09 00 09 	add	r9,r8,r9
80003fea:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003fec:	76 19       	ld.w	r9,r11[0x4]
80003fee:	a5 7c       	lsl	r12,0x5
80003ff0:	f0 0c 00 0c 	add	r12,r8,r12
80003ff4:	f8 c8 fd fc 	sub	r8,r12,-516
80003ff8:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80003ffa:	76 28       	ld.w	r8,r11[0x8]
80003ffc:	f8 cc fd f8 	sub	r12,r12,-520
80004000:	99 08       	st.w	r12[0x0],r8
80004002:	5e fd       	retal	0

  return PWM_SUCCESS;
80004004:	5e ff       	retal	1

80004006 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80004006:	18 98       	mov	r8,r12
80004008:	e0 18 ff 80 	andl	r8,0xff80
8000400c:	c0 20       	breq	80004010 <pwm_start_channels+0xa>
8000400e:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
80004010:	fe 78 30 00 	mov	r8,-53248
80004014:	91 1c       	st.w	r8[0x4],r12
80004016:	5e fd       	retal	0

80004018 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80004018:	58 6c       	cp.w	r12,6
8000401a:	e0 88 00 03 	brls	80004020 <pwm_async_update_channel+0x8>
8000401e:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
80004020:	76 0a       	ld.w	r10,r11[0x0]
80004022:	fe 78 30 00 	mov	r8,-53248
80004026:	f8 c9 ff f0 	sub	r9,r12,-16
8000402a:	a5 79       	lsl	r9,0x5
8000402c:	f0 09 00 09 	add	r9,r8,r9
80004030:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
80004032:	76 49       	ld.w	r9,r11[0x10]
80004034:	a5 7c       	lsl	r12,0x5
80004036:	18 08       	add	r8,r12
80004038:	f0 c8 fd f0 	sub	r8,r8,-528
8000403c:	91 09       	st.w	r8[0x0],r9
8000403e:	5e fd       	retal	0

80004040 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004040:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80004044:	58 0c       	cp.w	r12,0
80004046:	c0 21       	brne	8000404a <pwm_init+0xa>
80004048:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000404a:	e6 18 00 01 	andh	r8,0x1,COH
8000404e:	c0 91       	brne	80004060 <pwm_init+0x20>
80004050:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80004052:	fe 78 30 00 	mov	r8,-53248
80004056:	37 f9       	mov	r9,127
80004058:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
8000405a:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000405c:	d5 03       	csrf	0x10
8000405e:	c0 68       	rjmp	8000406a <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80004060:	fe 78 30 00 	mov	r8,-53248
80004064:	37 f9       	mov	r9,127
80004066:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80004068:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
8000406a:	78 08       	ld.w	r8,r12[0x0]
8000406c:	78 39       	ld.w	r9,r12[0xc]
8000406e:	a9 69       	lsl	r9,0x8
80004070:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80004074:	78 18       	ld.w	r8,r12[0x4]
80004076:	10 49       	or	r9,r8
80004078:	78 28       	ld.w	r8,r12[0x8]
8000407a:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000407e:	fe 78 30 00 	mov	r8,-53248
80004082:	91 09       	st.w	r8[0x0],r9
80004084:	5e fd       	retal	0

80004086 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80004086:	f8 c8 00 01 	sub	r8,r12,1
8000408a:	f0 0b 00 0b 	add	r11,r8,r11
8000408e:	f6 0c 0d 0a 	divu	r10,r11,r12
80004092:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80004094:	f4 c8 00 01 	sub	r8,r10,1
80004098:	e0 48 00 fe 	cp.w	r8,254
8000409c:	e0 88 00 03 	brls	800040a2 <getBaudDiv+0x1c>
800040a0:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800040a2:	5c 8c       	casts.h	r12
}
800040a4:	5e fc       	retal	r12

800040a6 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800040a6:	f7 39 00 0d 	ld.ub	r9,r11[13]
800040aa:	30 18       	mov	r8,1
800040ac:	f0 09 18 00 	cp.b	r9,r8
800040b0:	e0 88 00 04 	brls	800040b8 <spi_initMaster+0x12>
800040b4:	30 2c       	mov	r12,2
800040b6:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800040b8:	e0 68 00 80 	mov	r8,128
800040bc:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800040be:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800040c0:	30 19       	mov	r9,1
800040c2:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800040c6:	f7 39 00 0d 	ld.ub	r9,r11[13]
800040ca:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800040ce:	30 09       	mov	r9,0
800040d0:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800040d4:	30 fa       	mov	r10,15
800040d6:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800040da:	99 18       	st.w	r12[0x4],r8
800040dc:	5e f9       	retal	r9

800040de <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800040de:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800040e0:	30 18       	mov	r8,1
800040e2:	f0 0b 18 00 	cp.b	r11,r8
800040e6:	5f be       	srhi	lr
800040e8:	f0 0a 18 00 	cp.b	r10,r8
800040ec:	5f b8       	srhi	r8
800040ee:	fd e8 10 08 	or	r8,lr,r8
800040f2:	c0 30       	breq	800040f8 <spi_selectionMode+0x1a>
800040f4:	30 2c       	mov	r12,2
800040f6:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800040f8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800040fa:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800040fe:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80004102:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80004106:	99 18       	st.w	r12[0x4],r8
80004108:	d8 0a       	popm	pc,r12=0

8000410a <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000410a:	30 18       	mov	r8,1
8000410c:	99 08       	st.w	r12[0x0],r8
}
8000410e:	5e fc       	retal	r12

80004110 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80004110:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004114:	c0 58       	rjmp	8000411e <spi_write+0xe>
		if (!timeout--) {
80004116:	58 08       	cp.w	r8,0
80004118:	c0 21       	brne	8000411c <spi_write+0xc>
8000411a:	5e ff       	retal	1
8000411c:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000411e:	78 49       	ld.w	r9,r12[0x10]
80004120:	e2 19 00 02 	andl	r9,0x2,COH
80004124:	cf 90       	breq	80004116 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80004126:	5c 7b       	castu.h	r11
80004128:	99 3b       	st.w	r12[0xc],r11
8000412a:	5e fd       	retal	0

8000412c <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000412c:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004130:	c0 58       	rjmp	8000413a <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80004132:	58 08       	cp.w	r8,0
80004134:	c0 21       	brne	80004138 <spi_read+0xc>
80004136:	5e ff       	retal	1
80004138:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000413a:	78 49       	ld.w	r9,r12[0x10]
8000413c:	e2 19 02 01 	andl	r9,0x201,COH
80004140:	e0 49 02 01 	cp.w	r9,513
80004144:	cf 71       	brne	80004132 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80004146:	78 28       	ld.w	r8,r12[0x8]
80004148:	b6 08       	st.h	r11[0x0],r8
8000414a:	5e fd       	retal	0

8000414c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000414c:	eb cd 40 f8 	pushm	r3-r7,lr
80004150:	18 95       	mov	r5,r12
80004152:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004154:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004158:	30 38       	mov	r8,3
8000415a:	f0 06 18 00 	cp.b	r6,r8
8000415e:	e0 8b 00 5f 	brhi	8000421c <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
80004162:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004166:	30 18       	mov	r8,1
80004168:	f0 04 18 00 	cp.b	r4,r8
8000416c:	e0 8b 00 58 	brhi	8000421c <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80004170:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004174:	30 78       	mov	r8,7
80004176:	f0 03 18 00 	cp.b	r3,r8
8000417a:	e0 88 00 51 	brls	8000421c <spi_setupChipReg+0xd0>
8000417e:	31 08       	mov	r8,16
80004180:	f0 03 18 00 	cp.b	r3,r8
80004184:	e0 8b 00 4c 	brhi	8000421c <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80004188:	14 9b       	mov	r11,r10
8000418a:	6e 1c       	ld.w	r12,r7[0x4]
8000418c:	f0 1f 00 27 	mcall	80004228 <spi_setupChipReg+0xdc>

	if (baudDiv < 0) {
80004190:	c4 65       	brlt	8000421c <spi_setupChipReg+0xd0>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80004192:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80004194:	ec 09 16 01 	lsr	r9,r6,0x1
80004198:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000419c:	ec 16 00 01 	eorl	r6,0x1
800041a0:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800041a4:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800041a8:	20 83       	sub	r3,8
800041aa:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800041ae:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800041b2:	ef 39 00 09 	ld.ub	r9,r7[9]
800041b6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800041ba:	ef 39 00 0a 	ld.ub	r9,r7[10]
800041be:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800041c2:	0f 89       	ld.ub	r9,r7[0x0]
800041c4:	30 1a       	mov	r10,1
800041c6:	f4 09 18 00 	cp.b	r9,r10
800041ca:	c0 d0       	breq	800041e4 <spi_setupChipReg+0x98>
800041cc:	c0 a3       	brcs	800041e0 <spi_setupChipReg+0x94>
800041ce:	30 2a       	mov	r10,2
800041d0:	f4 09 18 00 	cp.b	r9,r10
800041d4:	c0 a0       	breq	800041e8 <spi_setupChipReg+0x9c>
800041d6:	30 3a       	mov	r10,3
800041d8:	f4 09 18 00 	cp.b	r9,r10
800041dc:	c2 01       	brne	8000421c <spi_setupChipReg+0xd0>
800041de:	c0 78       	rjmp	800041ec <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800041e0:	8b c8       	st.w	r5[0x30],r8
		break;
800041e2:	c0 68       	rjmp	800041ee <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800041e4:	8b d8       	st.w	r5[0x34],r8
		break;
800041e6:	c0 48       	rjmp	800041ee <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800041e8:	8b e8       	st.w	r5[0x38],r8
		break;
800041ea:	c0 28       	rjmp	800041ee <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800041ec:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800041ee:	49 08       	lddpc	r8,8000422c <spi_setupChipReg+0xe0>
800041f0:	70 08       	ld.w	r8,r8[0x0]
800041f2:	58 08       	cp.w	r8,0
800041f4:	c1 71       	brne	80004222 <spi_setupChipReg+0xd6>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800041f6:	30 3a       	mov	r10,3
800041f8:	30 0b       	mov	r11,0
800041fa:	30 1c       	mov	r12,1
800041fc:	f0 1f 00 0d 	mcall	80004230 <spi_setupChipReg+0xe4>
80004200:	48 b8       	lddpc	r8,8000422c <spi_setupChipReg+0xe0>
80004202:	91 0c       	st.w	r8[0x0],r12
80004204:	58 0c       	cp.w	r12,0
80004206:	c0 a0       	breq	8000421a <spi_setupChipReg+0xce>
80004208:	30 09       	mov	r9,0
8000420a:	12 9a       	mov	r10,r9
8000420c:	12 9b       	mov	r11,r9
8000420e:	f0 1f 00 0a 	mcall	80004234 <spi_setupChipReg+0xe8>
		if (!xSPIMutex) {
80004212:	48 78       	lddpc	r8,8000422c <spi_setupChipReg+0xe0>
80004214:	70 08       	ld.w	r8,r8[0x0]
80004216:	58 08       	cp.w	r8,0
80004218:	c0 51       	brne	80004222 <spi_setupChipReg+0xd6>
8000421a:	c0 08       	rjmp	8000421a <spi_setupChipReg+0xce>
8000421c:	30 2c       	mov	r12,2
8000421e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004222:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004226:	00 00       	add	r0,r0
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	40 86       	lddsp	r6,sp[0x20]
8000422c:	00 00       	add	r0,r0
8000422e:	0a a0       	st.w	r5++,r0
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	73 40       	ld.w	r0,r9[0x50]
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	71 ac       	ld.w	r12,r8[0x68]

80004238 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004238:	d4 01       	pushm	lr
8000423a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000423e:	c0 58       	rjmp	80004248 <spi_unselectChip+0x10>
		if (!timeout--) {
80004240:	58 08       	cp.w	r8,0
80004242:	c0 21       	brne	80004246 <spi_unselectChip+0xe>
80004244:	da 0a       	popm	pc,r12=1
80004246:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004248:	78 49       	ld.w	r9,r12[0x10]
8000424a:	e2 19 02 00 	andl	r9,0x200,COH
8000424e:	cf 90       	breq	80004240 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004250:	78 18       	ld.w	r8,r12[0x4]
80004252:	ea 18 00 0f 	orh	r8,0xf
80004256:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80004258:	fc 18 01 00 	movh	r8,0x100
8000425c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000425e:	30 09       	mov	r9,0
80004260:	12 9a       	mov	r10,r9
80004262:	12 9b       	mov	r11,r9
80004264:	48 38       	lddpc	r8,80004270 <spi_unselectChip+0x38>
80004266:	70 0c       	ld.w	r12,r8[0x0]
80004268:	f0 1f 00 03 	mcall	80004274 <spi_unselectChip+0x3c>
8000426c:	d8 0a       	popm	pc,r12=0
8000426e:	00 00       	add	r0,r0
80004270:	00 00       	add	r0,r0
80004272:	0a a0       	st.w	r5++,r0
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	71 ac       	ld.w	r12,r8[0x68]

80004278 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004278:	d4 21       	pushm	r4-r7,lr
8000427a:	18 95       	mov	r5,r12
8000427c:	16 94       	mov	r4,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
8000427e:	49 86       	lddpc	r6,800042dc <spi_selectChip+0x64>
80004280:	31 47       	mov	r7,20
80004282:	0e 9b       	mov	r11,r7
80004284:	6c 0c       	ld.w	r12,r6[0x0]
80004286:	f0 1f 00 17 	mcall	800042e0 <spi_selectChip+0x68>
8000428a:	cf c0       	breq	80004282 <spi_selectChip+0xa>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000428c:	6a 18       	ld.w	r8,r5[0x4]
8000428e:	ea 18 00 0f 	orh	r8,0xf
80004292:	8b 18       	st.w	r5[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004294:	6a 18       	ld.w	r8,r5[0x4]
80004296:	e2 18 00 04 	andl	r8,0x4,COH
8000429a:	c1 00       	breq	800042ba <spi_selectChip+0x42>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000429c:	30 e8       	mov	r8,14
8000429e:	f0 04 18 00 	cp.b	r4,r8
800042a2:	e0 8b 00 1a 	brhi	800042d6 <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800042a6:	6a 19       	ld.w	r9,r5[0x4]
800042a8:	e8 08 15 10 	lsl	r8,r4,0x10
800042ac:	ea 18 ff f0 	orh	r8,0xfff0
800042b0:	e8 18 ff ff 	orl	r8,0xffff
800042b4:	12 68       	and	r8,r9
800042b6:	8b 18       	st.w	r5[0x4],r8
800042b8:	d8 2a       	popm	r4-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800042ba:	30 38       	mov	r8,3
800042bc:	f0 04 18 00 	cp.b	r4,r8
800042c0:	e0 8b 00 0b 	brhi	800042d6 <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800042c4:	6a 19       	ld.w	r9,r5[0x4]
800042c6:	2f 04       	sub	r4,-16
800042c8:	30 18       	mov	r8,1
800042ca:	f0 04 09 48 	lsl	r8,r8,r4
800042ce:	5c d8       	com	r8
800042d0:	12 68       	and	r8,r9
800042d2:	8b 18       	st.w	r5[0x4],r8
800042d4:	d8 2a       	popm	r4-r7,pc,r12=0
800042d6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800042d8:	d8 22       	popm	r4-r7,pc
800042da:	00 00       	add	r0,r0
800042dc:	00 00       	add	r0,r0
800042de:	0a a0       	st.w	r5++,r0
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	6f c8       	ld.w	r8,r7[0x70]

800042e4 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
800042e4:	4a 78       	lddpc	r8,80004380 <twi_master_interrupt_handler+0x9c>
800042e6:	70 08       	ld.w	r8,r8[0x0]
800042e8:	70 89       	ld.w	r9,r8[0x20]
800042ea:	4a 7a       	lddpc	r10,80004384 <twi_master_interrupt_handler+0xa0>
800042ec:	74 0a       	ld.w	r10,r10[0x0]
800042ee:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800042f2:	12 9a       	mov	r10,r9
800042f4:	e2 1a 01 00 	andl	r10,0x100,COH
800042f8:	c3 91       	brne	8000436a <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800042fa:	12 9a       	mov	r10,r9
800042fc:	e2 1a 00 02 	andl	r10,0x2,COH
80004300:	c1 70       	breq	8000432e <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004302:	4a 29       	lddpc	r9,80004388 <twi_master_interrupt_handler+0xa4>
80004304:	72 0a       	ld.w	r10,r9[0x0]
80004306:	70 cb       	ld.w	r11,r8[0x30]
80004308:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
8000430a:	72 0a       	ld.w	r10,r9[0x0]
8000430c:	2f fa       	sub	r10,-1
8000430e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004310:	49 f9       	lddpc	r9,8000438c <twi_master_interrupt_handler+0xa8>
80004312:	72 0a       	ld.w	r10,r9[0x0]
80004314:	20 1a       	sub	r10,1
80004316:	93 0a       	st.w	r9[0x0],r10
80004318:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
8000431a:	58 19       	cp.w	r9,1
8000431c:	f9 b9 00 02 	moveq	r9,2
80004320:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004324:	49 a9       	lddpc	r9,8000438c <twi_master_interrupt_handler+0xa8>
80004326:	72 09       	ld.w	r9,r9[0x0]
80004328:	58 09       	cp.w	r9,0
8000432a:	c2 30       	breq	80004370 <twi_master_interrupt_handler+0x8c>
8000432c:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
8000432e:	12 9a       	mov	r10,r9
80004330:	e2 1a 00 04 	andl	r10,0x4,COH
80004334:	c1 70       	breq	80004362 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004336:	49 79       	lddpc	r9,80004390 <twi_master_interrupt_handler+0xac>
80004338:	72 0a       	ld.w	r10,r9[0x0]
8000433a:	20 1a       	sub	r10,1
8000433c:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
8000433e:	72 09       	ld.w	r9,r9[0x0]
80004340:	58 09       	cp.w	r9,0
80004342:	e0 89 00 0a 	brgt	80004356 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004346:	49 09       	lddpc	r9,80004384 <twi_master_interrupt_handler+0xa0>
80004348:	30 1a       	mov	r10,1
8000434a:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
8000434c:	3f fa       	mov	r10,-1
8000434e:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004350:	72 09       	ld.w	r9,r9[0x0]
80004352:	91 99       	st.w	r8[0x24],r9
80004354:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004356:	49 0a       	lddpc	r10,80004394 <twi_master_interrupt_handler+0xb0>
80004358:	74 09       	ld.w	r9,r10[0x0]
8000435a:	13 3b       	ld.ub	r11,r9++
8000435c:	91 db       	st.w	r8[0x34],r11
8000435e:	95 09       	st.w	r10[0x0],r9
80004360:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004362:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004366:	c0 51       	brne	80004370 <twi_master_interrupt_handler+0x8c>
80004368:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
8000436a:	30 1a       	mov	r10,1
8000436c:	48 b9       	lddpc	r9,80004398 <twi_master_interrupt_handler+0xb4>
8000436e:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004370:	3f f9       	mov	r9,-1
80004372:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004374:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004376:	30 09       	mov	r9,0
80004378:	48 98       	lddpc	r8,8000439c <twi_master_interrupt_handler+0xb8>
8000437a:	b0 89       	st.b	r8[0x0],r9
8000437c:	d6 03       	rete
8000437e:	00 00       	add	r0,r0
80004380:	00 00       	add	r0,r0
80004382:	05 9c       	ld.ub	r12,r2[0x1]
80004384:	00 00       	add	r0,r0
80004386:	05 98       	ld.ub	r8,r2[0x1]
80004388:	00 00       	add	r0,r0
8000438a:	05 a8       	ld.ub	r8,r2[0x2]
8000438c:	00 00       	add	r0,r0
8000438e:	05 a4       	ld.ub	r4,r2[0x2]
80004390:	00 00       	add	r0,r0
80004392:	05 94       	ld.ub	r4,r2[0x1]
80004394:	00 00       	add	r0,r0
80004396:	05 a0       	ld.ub	r0,r2[0x2]
80004398:	00 00       	add	r0,r0
8000439a:	05 91       	ld.ub	r1,r2[0x1]
8000439c:	00 00       	add	r0,r0
8000439e:	05 90       	ld.ub	r0,r2[0x1]

800043a0 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
800043a0:	18 98       	mov	r8,r12
	uint32_t val;

	if (len == 0)
800043a2:	58 0b       	cp.w	r11,0
800043a4:	c0 21       	brne	800043a8 <twi_mk_addr+0x8>
800043a6:	5e fd       	retal	0
		return 0;

	val = addr[0];
800043a8:	19 8c       	ld.ub	r12,r12[0x0]
	if (len > 1) {
800043aa:	58 1b       	cp.w	r11,1
800043ac:	e0 8a 00 05 	brle	800043b6 <twi_mk_addr+0x16>
		val <<= 8;
		val |= addr[1];
800043b0:	11 99       	ld.ub	r9,r8[0x1]
800043b2:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
	}
	if (len > 2) {
800043b6:	58 2b       	cp.w	r11,2
800043b8:	5e ac       	retle	r12
		val <<= 8;
		val |= addr[2];
800043ba:	11 a8       	ld.ub	r8,r8[0x2]
800043bc:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	}
	return val;
}
800043c0:	5e fc       	retal	r12
800043c2:	d7 03       	nop

800043c4 <twi_is_busy>:
}


bool twi_is_busy(void)
{
	if (twi_busy) {
800043c4:	48 28       	lddpc	r8,800043cc <twi_is_busy+0x8>
800043c6:	11 8c       	ld.ub	r12,r8[0x0]
		return true;          // Still receiving/transmitting...
	} else {
		return false;
	}
}
800043c8:	5e fc       	retal	r12
800043ca:	00 00       	add	r0,r0
800043cc:	00 00       	add	r0,r0
800043ce:	05 90       	ld.ub	r0,r2[0x1]

800043d0 <twi_master_write>:
	return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800043d0:	eb cd 40 c0 	pushm	r6-r7,lr
800043d4:	18 96       	mov	r6,r12
800043d6:	16 97       	mov	r7,r11
	// No data to send
	if (package->length == 0) {
800043d8:	76 38       	ld.w	r8,r11[0xc]
800043da:	58 08       	cp.w	r8,0
800043dc:	c0 51       	brne	800043e6 <twi_master_write+0x16>
800043de:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800043e2:	fe cf ff fc 	sub	pc,pc,-4
	// No data to send
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800043e6:	f0 1f 00 1f 	mcall	80004460 <twi_master_write+0x90>
800043ea:	cf c1       	brne	800043e2 <twi_master_write+0x12>
		cpu_relax();
	};

	twi_nack = false;
800043ec:	30 09       	mov	r9,0
800043ee:	49 e8       	lddpc	r8,80004464 <twi_master_write+0x94>
800043f0:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800043f2:	30 19       	mov	r9,1
800043f4:	49 d8       	lddpc	r8,80004468 <twi_master_write+0x98>
800043f6:	b0 89       	st.b	r8[0x0],r9

	// Enable master transfer, disable slave
	twi->cr =   AVR32_TWI_CR_MSEN_MASK
800043f8:	32 48       	mov	r8,36
800043fa:	8d 08       	st.w	r6[0x0],r8
			| AVR32_TWI_CR_SVDIS_MASK
#endif
			;

	// set write mode, slave address and 3 internal address byte length
	twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800043fc:	6e 18       	ld.w	r8,r7[0x4]
800043fe:	a9 68       	lsl	r8,0x8
80004400:	e2 18 03 00 	andl	r8,0x300,COH
80004404:	0f 89       	ld.ub	r9,r7[0x0]
80004406:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000440a:	8d 18       	st.w	r6[0x4],r8
			(package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

	// Set pointer to TWI instance for IT
	twi_inst = twi;
8000440c:	49 88       	lddpc	r8,8000446c <twi_master_write+0x9c>
8000440e:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
80004410:	6e 1b       	ld.w	r11,r7[0x4]
80004412:	ee cc ff ff 	sub	r12,r7,-1
80004416:	f0 1f 00 17 	mcall	80004470 <twi_master_write+0xa0>
8000441a:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_tx_data = package->buffer;
8000441c:	6e 29       	ld.w	r9,r7[0x8]
8000441e:	49 68       	lddpc	r8,80004474 <twi_master_write+0xa4>
80004420:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to write
	twi_tx_nb_bytes = package->length;
80004422:	6e 3a       	ld.w	r10,r7[0xc]
80004424:	49 59       	lddpc	r9,80004478 <twi_master_write+0xa8>
80004426:	93 0a       	st.w	r9[0x0],r10

	// put the first byte in the Transmit Holding Register
	twi->thr = *twi_tx_data++;
80004428:	70 09       	ld.w	r9,r8[0x0]
8000442a:	13 3a       	ld.ub	r10,r9++
8000442c:	8d da       	st.w	r6[0x34],r10
8000442e:	91 09       	st.w	r8[0x0],r9

	// mask NACK and TXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
80004430:	49 38       	lddpc	r8,8000447c <twi_master_write+0xac>
80004432:	e0 69 01 04 	mov	r9,260
80004436:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
80004438:	70 08       	ld.w	r8,r8[0x0]
8000443a:	8d 98       	st.w	r6[0x24],r8

	// send data
	while (twi_is_busy()) {
8000443c:	c0 38       	rjmp	80004442 <twi_master_write+0x72>
		cpu_relax();
8000443e:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// send data
	while (twi_is_busy()) {
80004442:	f0 1f 00 08 	mcall	80004460 <twi_master_write+0x90>
80004446:	cf c1       	brne	8000443e <twi_master_write+0x6e>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80004448:	30 88       	mov	r8,8
8000444a:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
8000444c:	48 68       	lddpc	r8,80004464 <twi_master_write+0x94>
8000444e:	11 8c       	ld.ub	r12,r8[0x0]
80004450:	58 0c       	cp.w	r12,0
80004452:	f9 bc 01 fb 	movne	r12,-5
80004456:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
8000445a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000445e:	00 00       	add	r0,r0
80004460:	80 00       	ld.sh	r0,r0[0x0]
80004462:	43 c4       	lddsp	r4,sp[0xf0]
80004464:	00 00       	add	r0,r0
80004466:	05 91       	ld.ub	r1,r2[0x1]
80004468:	00 00       	add	r0,r0
8000446a:	05 90       	ld.ub	r0,r2[0x1]
8000446c:	00 00       	add	r0,r0
8000446e:	05 9c       	ld.ub	r12,r2[0x1]
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	43 a0       	lddsp	r0,sp[0xe8]
80004474:	00 00       	add	r0,r0
80004476:	05 a0       	ld.ub	r0,r2[0x2]
80004478:	00 00       	add	r0,r0
8000447a:	05 94       	ld.ub	r4,r2[0x1]
8000447c:	00 00       	add	r0,r0
8000447e:	05 98       	ld.ub	r8,r2[0x1]

80004480 <twi_probe>:
	cpu_irq_restore(flags);
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80004480:	d4 01       	pushm	lr
80004482:	20 5d       	sub	sp,20
	twi_package_t package;
	char data[1] = {0};
80004484:	30 08       	mov	r8,0
80004486:	ba 88       	st.b	sp[0x0],r8

	// data to send
	package.buffer = data;
80004488:	50 3d       	stdsp	sp[0xc],sp
	// chip address
	package.chip = chip_addr;
8000448a:	ba cb       	st.b	sp[0x4],r11
	// frame length
	package.length = 1;
8000448c:	30 19       	mov	r9,1
8000448e:	50 49       	stdsp	sp[0x10],r9
	// address length
	package.addr_length = 0;
80004490:	30 09       	mov	r9,0
80004492:	50 29       	stdsp	sp[0x8],r9
	// internal chip address
	package.addr[0] = 0;
80004494:	ba d8       	st.b	sp[0x5],r8
	// perform a master write access
	return (twi_master_write(twi, &package));
80004496:	fa cb ff fc 	sub	r11,sp,-4
8000449a:	f0 1f 00 03 	mcall	800044a4 <twi_probe+0x24>
}
8000449e:	2f bd       	sub	sp,-20
800044a0:	d8 02       	popm	pc
800044a2:	00 00       	add	r0,r0
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	43 d0       	lddsp	r0,sp[0xf4]

800044a8 <twi_master_read>:
	}
	return val;
}

int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800044a8:	eb cd 40 c0 	pushm	r6-r7,lr
800044ac:	18 96       	mov	r6,r12
800044ae:	16 97       	mov	r7,r11
	// check argument
	if (package->length == 0) {
800044b0:	76 38       	ld.w	r8,r11[0xc]
800044b2:	58 08       	cp.w	r8,0
800044b4:	c0 51       	brne	800044be <twi_master_read+0x16>
800044b6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800044ba:	fe cf ff fc 	sub	pc,pc,-4
	// check argument
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800044be:	f0 1f 00 21 	mcall	80004540 <twi_master_read+0x98>
800044c2:	cf c1       	brne	800044ba <twi_master_read+0x12>
		cpu_relax();
	};

	twi_nack = false;
800044c4:	30 09       	mov	r9,0
800044c6:	4a 08       	lddpc	r8,80004544 <twi_master_read+0x9c>
800044c8:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800044ca:	30 19       	mov	r9,1
800044cc:	49 f8       	lddpc	r8,80004548 <twi_master_read+0xa0>
800044ce:	b0 89       	st.b	r8[0x0],r9

	// set read mode, slave address and 3 internal address byte length
	twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
800044d0:	0f 89       	ld.ub	r9,r7[0x0]
800044d2:	6e 18       	ld.w	r8,r7[0x4]
800044d4:	a9 68       	lsl	r8,0x8
800044d6:	e2 18 03 00 	andl	r8,0x300,COH
800044da:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800044de:	ad a8       	sbr	r8,0xc
800044e0:	8d 18       	st.w	r6[0x4],r8
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
			(1 << AVR32_TWI_MMR_MREAD_OFFSET);

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800044e2:	49 b8       	lddpc	r8,8000454c <twi_master_read+0xa4>
800044e4:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800044e6:	6e 1b       	ld.w	r11,r7[0x4]
800044e8:	ee cc ff ff 	sub	r12,r7,-1
800044ec:	f0 1f 00 19 	mcall	80004550 <twi_master_read+0xa8>
800044f0:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_rx_data = package->buffer;
800044f2:	6e 29       	ld.w	r9,r7[0x8]
800044f4:	49 88       	lddpc	r8,80004554 <twi_master_read+0xac>
800044f6:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to read
	twi_rx_nb_bytes = package->length;
800044f8:	6e 39       	ld.w	r9,r7[0xc]
800044fa:	49 88       	lddpc	r8,80004558 <twi_master_read+0xb0>
800044fc:	91 09       	st.w	r8[0x0],r9

	// Enable master transfer
	twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800044fe:	30 49       	mov	r9,4
80004500:	8d 09       	st.w	r6[0x0],r9

	// Send start condition
	twi->cr = AVR32_TWI_START_MASK;
80004502:	30 19       	mov	r9,1
80004504:	8d 09       	st.w	r6[0x0],r9

	// only one byte to receive
	if (twi_rx_nb_bytes == 1) {
80004506:	70 08       	ld.w	r8,r8[0x0]
		// set stop bit
		twi->cr = AVR32_TWI_STOP_MASK;
80004508:	12 38       	cp.w	r8,r9
8000450a:	f9 b8 00 02 	moveq	r8,2
8000450e:	ed f8 0a 00 	st.weq	r6[0x0],r8
	}

	// mask NACK and RXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
80004512:	49 38       	lddpc	r8,8000455c <twi_master_read+0xb4>
80004514:	e0 69 01 02 	mov	r9,258
80004518:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
8000451a:	70 08       	ld.w	r8,r8[0x0]
8000451c:	8d 98       	st.w	r6[0x24],r8

	// get data
	while (twi_is_busy()) {
8000451e:	c0 38       	rjmp	80004524 <twi_master_read+0x7c>
		cpu_relax();
80004520:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// get data
	while (twi_is_busy()) {
80004524:	f0 1f 00 07 	mcall	80004540 <twi_master_read+0x98>
80004528:	cf c1       	brne	80004520 <twi_master_read+0x78>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
8000452a:	30 88       	mov	r8,8
8000452c:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
8000452e:	48 68       	lddpc	r8,80004544 <twi_master_read+0x9c>
80004530:	11 8c       	ld.ub	r12,r8[0x0]
80004532:	58 0c       	cp.w	r12,0
80004534:	f9 bc 01 fb 	movne	r12,-5
80004538:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
8000453c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	43 c4       	lddsp	r4,sp[0xf0]
80004544:	00 00       	add	r0,r0
80004546:	05 91       	ld.ub	r1,r2[0x1]
80004548:	00 00       	add	r0,r0
8000454a:	05 90       	ld.ub	r0,r2[0x1]
8000454c:	00 00       	add	r0,r0
8000454e:	05 9c       	ld.ub	r12,r2[0x1]
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	43 a0       	lddsp	r0,sp[0xe8]
80004554:	00 00       	add	r0,r0
80004556:	05 a8       	ld.ub	r8,r2[0x2]
80004558:	00 00       	add	r0,r0
8000455a:	05 a4       	ld.ub	r4,r2[0x2]
8000455c:	00 00       	add	r0,r0
8000455e:	05 98       	ld.ub	r8,r2[0x1]

80004560 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004560:	eb cd 40 e0 	pushm	r5-r7,lr
80004564:	20 1d       	sub	sp,4
80004566:	18 97       	mov	r7,r12
80004568:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
8000456a:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
8000456e:	4a 29       	lddpc	r9,800045f4 <twi_master_init+0x94>
80004570:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004572:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004574:	3f f9       	mov	r9,-1
80004576:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004578:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
8000457a:	e0 69 00 80 	mov	r9,128
8000457e:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004580:	e6 18 00 01 	andh	r8,0x1,COH
80004584:	c0 21       	brne	80004588 <twi_master_init+0x28>
      cpu_irq_enable();
80004586:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004588:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000458a:	e1 b8 00 00 	mfsr	r8,0x0
8000458e:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80004590:	d3 03       	ssrf	0x10

	return flags;
80004592:	40 06       	lddsp	r6,sp[0x0]

	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();
	INTC_init_interrupts(); /**/
80004594:	f0 1f 00 19 	mcall	800045f8 <twi_master_init+0x98>
	INTC_register_interrupt(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL); /**/
80004598:	30 3a       	mov	r10,3
8000459a:	e0 6b 01 60 	mov	r11,352
8000459e:	49 8c       	lddpc	r12,800045fc <twi_master_init+0x9c>
800045a0:	f0 1f 00 18 	mcall	80004600 <twi_master_init+0xa0>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800045a4:	e6 16 00 01 	andh	r6,0x1,COH
800045a8:	c0 21       	brne	800045ac <twi_master_init+0x4c>
      cpu_irq_enable();
800045aa:	d5 03       	csrf	0x10
	//irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE,
	//CONF_TWI_IRQ_LEVEL);
	cpu_irq_restore(flags);
	cpu_irq_enable(); /**/
800045ac:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
800045ae:	6a 19       	ld.w	r9,r5[0x4]
800045b0:	a1 79       	lsl	r9,0x1
800045b2:	6a 08       	ld.w	r8,r5[0x0]
800045b4:	f0 09 0d 08 	divu	r8,r8,r9
800045b8:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800045ba:	e0 48 00 ff 	cp.w	r8,255
800045be:	e0 8b 00 04 	brhi	800045c6 <twi_master_init+0x66>
800045c2:	30 09       	mov	r9,0
800045c4:	c0 f8       	rjmp	800045e2 <twi_master_init+0x82>
800045c6:	30 09       	mov	r9,0
800045c8:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
800045ca:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
800045cc:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800045ce:	e0 48 00 ff 	cp.w	r8,255
800045d2:	5f bb       	srhi	r11
800045d4:	58 69       	cp.w	r9,6
800045d6:	5f 8a       	srls	r10
800045d8:	f7 ea 00 0a 	and	r10,r11,r10
800045dc:	f8 0a 18 00 	cp.b	r10,r12
800045e0:	cf 51       	brne	800045ca <twi_master_init+0x6a>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800045e2:	b1 69       	lsl	r9,0x10
800045e4:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800045e8:	f3 e8 10 08 	or	r8,r9,r8
800045ec:	8f 48       	st.w	r7[0x10],r8

	// Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800045ee:	2f fd       	sub	sp,-4
800045f0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800045f4:	00 00       	add	r0,r0
800045f6:	05 9c       	ld.ub	r12,r2[0x1]
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	8d 80       	st.w	r6[0x20],r0
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	42 e4       	lddsp	r4,sp[0xb8]
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	8d 00       	st.w	r6[0x0],r0

80004604 <fat_check_open>:
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
80004604:	48 68       	lddpc	r8,8000461c <fat_check_open+0x18>
80004606:	11 89       	ld.ub	r9,r8[0x0]
80004608:	30 08       	mov	r8,0
8000460a:	f0 09 18 00 	cp.b	r9,r8
8000460e:	c0 20       	breq	80004612 <fat_check_open+0xe>
80004610:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
80004612:	31 79       	mov	r9,23
80004614:	48 38       	lddpc	r8,80004620 <fat_check_open+0x1c>
80004616:	b0 89       	st.b	r8[0x0],r9
80004618:	5e fd       	retal	0
8000461a:	00 00       	add	r0,r0
8000461c:	00 00       	add	r0,r0
8000461e:	0a a8       	st.w	r5++,r8
80004620:	00 00       	add	r0,r0
80004622:	0d 38       	ld.ub	r8,r6++

80004624 <fat_check_select>:
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
80004624:	48 68       	lddpc	r8,8000463c <fat_check_select+0x18>
80004626:	90 19       	ld.sh	r9,r8[0x2]
80004628:	3f f8       	mov	r8,-1
8000462a:	f0 09 19 00 	cp.h	r9,r8
8000462e:	c0 20       	breq	80004632 <fat_check_select+0xe>
80004630:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
80004632:	30 f9       	mov	r9,15
80004634:	48 38       	lddpc	r8,80004640 <fat_check_select+0x1c>
80004636:	b0 89       	st.b	r8[0x0],r9
80004638:	5e fd       	retal	0
8000463a:	00 00       	add	r0,r0
8000463c:	00 00       	add	r0,r0
8000463e:	0d 34       	ld.ub	r4,r6++
80004640:	00 00       	add	r0,r0
80004642:	0d 38       	ld.ub	r8,r6++

80004644 <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
80004644:	48 58       	lddpc	r8,80004658 <fat_check_is_file+0x14>
80004646:	11 a8       	ld.ub	r8,r8[0x2]
80004648:	e2 18 00 18 	andl	r8,0x18,COH
8000464c:	c0 21       	brne	80004650 <fat_check_is_file+0xc>
8000464e:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
80004650:	31 39       	mov	r9,19
80004652:	48 38       	lddpc	r8,8000465c <fat_check_is_file+0x18>
80004654:	b0 89       	st.b	r8[0x0],r9
80004656:	5e fd       	retal	0
80004658:	00 00       	add	r0,r0
8000465a:	0a a8       	st.w	r5++,r8
8000465c:	00 00       	add	r0,r0
8000465e:	0d 38       	ld.ub	r8,r6++

80004660 <fat_checkcluster>:
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
80004660:	49 68       	lddpc	r8,800046b8 <fat_checkcluster+0x58>
80004662:	70 18       	ld.w	r8,r8[0x4]
80004664:	58 08       	cp.w	r8,0
80004666:	c0 21       	brne	8000466a <fat_checkcluster+0xa>
80004668:	5e ff       	retal	1
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
8000466a:	49 59       	lddpc	r9,800046bc <fat_checkcluster+0x5c>
8000466c:	13 89       	ld.ub	r9,r9[0x0]
8000466e:	30 3a       	mov	r10,3
80004670:	f4 09 18 00 	cp.b	r9,r10
80004674:	c0 a1       	brne	80004688 <fat_checkcluster+0x28>
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
80004676:	e0 69 ff f7 	mov	r9,65527
8000467a:	ea 19 0f ff 	orh	r9,0xfff
8000467e:	12 38       	cp.w	r8,r9
80004680:	e0 8b 00 19 	brhi	800046b2 <fat_checkcluster+0x52>
80004684:	5f 0c       	sreq	r12
80004686:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
80004688:	30 2a       	mov	r10,2
8000468a:	f4 09 18 00 	cp.b	r9,r10
8000468e:	c0 71       	brne	8000469c <fat_checkcluster+0x3c>
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
80004690:	e0 48 ff f7 	cp.w	r8,65527
80004694:	e0 8b 00 0f 	brhi	800046b2 <fat_checkcluster+0x52>
80004698:	5f 0c       	sreq	r12
8000469a:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
8000469c:	30 1a       	mov	r10,1
8000469e:	f4 09 18 00 	cp.b	r9,r10
800046a2:	c0 20       	breq	800046a6 <fat_checkcluster+0x46>
800046a4:	5e fd       	retal	0
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
800046a6:	e0 48 0f f7 	cp.w	r8,4087
800046aa:	e0 8b 00 04 	brhi	800046b2 <fat_checkcluster+0x52>
800046ae:	5f 0c       	sreq	r12
800046b0:	5e fc       	retal	r12
800046b2:	30 2c       	mov	r12,2
    else if (fs_g_cluster.u32_val == 0xFF7)
      return FS_CLUS_BAD;
  }

  return FS_CLUS_OK;
}
800046b4:	5e fc       	retal	r12
800046b6:	00 00       	add	r0,r0
800046b8:	00 00       	add	r0,r0
800046ba:	0d 88       	ld.ub	r8,r6[0x0]
800046bc:	00 00       	add	r0,r0
800046be:	0d 34       	ld.ub	r4,r6++

800046c0 <fat_cache_clusterlist_reset>:
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
800046c0:	30 0a       	mov	r10,0
800046c2:	48 88       	lddpc	r8,800046e0 <fat_cache_clusterlist_reset+0x20>
800046c4:	b0 8a       	st.b	r8[0x0],r10
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
800046c6:	48 88       	lddpc	r8,800046e4 <fat_cache_clusterlist_reset+0x24>
800046c8:	30 19       	mov	r9,1
800046ca:	b0 89       	st.b	r8[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
800046cc:	3f f9       	mov	r9,-1
800046ce:	b0 a9       	st.b	r8[0x2],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
800046d0:	b0 99       	st.b	r8[0x1],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
800046d2:	f1 6a 00 14 	st.b	r8[20],r10
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
800046d6:	f1 69 00 16 	st.b	r8[22],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
800046da:	f1 69 00 15 	st.b	r8[21],r9
   }
}
800046de:	5e fc       	retal	r12
800046e0:	00 00       	add	r0,r0
800046e2:	0d 3a       	ld.ub	r10,r6++
800046e4:	00 00       	add	r0,r0
800046e6:	0a bc       	st.h	r5++,r12

800046e8 <fat_cache_clusterlist_update_start>:
//! This function initializes a cache in cluster list caches
//!
//! @param     b_for_file  If true then it is a file cluster list else a directory cluster list  <br>
//!
void  fat_cache_clusterlist_update_start( bool b_for_file )
{
800046e8:	48 ea       	lddpc	r10,80004720 <fat_cache_clusterlist_update_start+0x38>
800046ea:	15 88       	ld.ub	r8,r10[0x0]
800046ec:	f8 08 18 00 	cp.b	r8,r12
800046f0:	5f 18       	srne	r8
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
800046f2:	48 d9       	lddpc	r9,80004724 <fat_cache_clusterlist_update_start+0x3c>
800046f4:	b2 88       	st.b	r9[0x0],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
800046f6:	f0 0b 15 02 	lsl	r11,r8,0x2
800046fa:	f6 08 00 09 	add	r9,r11,r8
800046fe:	f4 09 00 29 	add	r9,r10,r9<<0x2
80004702:	b2 8c       	st.b	r9[0x0],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80004704:	3f fc       	mov	r12,-1
80004706:	b2 ac       	st.b	r9[0x2],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
80004708:	f6 08 00 08 	add	r8,r11,r8
8000470c:	2f f8       	sub	r8,-1
8000470e:	48 7b       	lddpc	r11,80004728 <fat_cache_clusterlist_update_start+0x40>
80004710:	76 0b       	ld.w	r11,r11[0x0]
80004712:	f4 08 09 2b 	st.w	r10[r8<<0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
80004716:	48 68       	lddpc	r8,8000472c <fat_cache_clusterlist_update_start+0x44>
80004718:	70 18       	ld.w	r8,r8[0x4]
8000471a:	93 28       	st.w	r9[0x8],r8
}
8000471c:	5e fc       	retal	r12
8000471e:	00 00       	add	r0,r0
80004720:	00 00       	add	r0,r0
80004722:	0a bc       	st.h	r5++,r12
80004724:	00 00       	add	r0,r0
80004726:	0d 3a       	ld.ub	r10,r6++
80004728:	00 00       	add	r0,r0
8000472a:	0d 88       	ld.ub	r8,r6[0x0]
8000472c:	00 00       	add	r0,r0
8000472e:	0d 90       	ld.ub	r0,r6[0x1]

80004730 <fat_cache_clusterlist_update_select>:
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
80004730:	49 88       	lddpc	r8,80004790 <fat_cache_clusterlist_update_select+0x60>
80004732:	11 88       	ld.ub	r8,r8[0x0]
80004734:	49 8a       	lddpc	r10,80004794 <fat_cache_clusterlist_update_select+0x64>
80004736:	f0 08 00 2b 	add	r11,r8,r8<<0x2
8000473a:	f4 0b 00 2b 	add	r11,r10,r11<<0x2
8000473e:	17 89       	ld.ub	r9,r11[0x0]
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
80004740:	17 9b       	ld.ub	r11,r11[0x1]
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
80004742:	15 8a       	ld.ub	r10,r10[0x0]
80004744:	f2 0a 18 00 	cp.b	r10,r9
80004748:	c0 a1       	brne	8000475c <fat_cache_clusterlist_update_select+0x2c>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
8000474a:	49 3a       	lddpc	r10,80004794 <fat_cache_clusterlist_update_select+0x64>
8000474c:	15 9a       	ld.ub	r10,r10[0x1]
8000474e:	f4 0b 18 00 	cp.b	r11,r10
80004752:	e0 88 00 05 	brls	8000475c <fat_cache_clusterlist_update_select+0x2c>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80004756:	2f fa       	sub	r10,-1
80004758:	48 fc       	lddpc	r12,80004794 <fat_cache_clusterlist_update_select+0x64>
8000475a:	b8 9a       	st.b	r12[0x1],r10

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
8000475c:	48 ea       	lddpc	r10,80004794 <fat_cache_clusterlist_update_select+0x64>
8000475e:	f5 3a 00 14 	ld.ub	r10,r10[20]
80004762:	f2 0a 18 00 	cp.b	r10,r9
80004766:	c0 c1       	brne	8000477e <fat_cache_clusterlist_update_select+0x4e>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80004768:	48 b9       	lddpc	r9,80004794 <fat_cache_clusterlist_update_select+0x64>
8000476a:	f3 39 00 15 	ld.ub	r9,r9[21]
8000476e:	f2 0b 18 00 	cp.b	r11,r9
80004772:	e0 88 00 06 	brls	8000477e <fat_cache_clusterlist_update_select+0x4e>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80004776:	2f f9       	sub	r9,-1
80004778:	48 7a       	lddpc	r10,80004794 <fat_cache_clusterlist_update_select+0x64>
8000477a:	f5 69 00 15 	st.b	r10[21],r9
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
8000477e:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004782:	48 59       	lddpc	r9,80004794 <fat_cache_clusterlist_update_select+0x64>
80004784:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004788:	30 09       	mov	r9,0
8000478a:	b0 99       	st.b	r8[0x1],r9
}
8000478c:	5e fc       	retal	r12
8000478e:	00 00       	add	r0,r0
80004790:	00 00       	add	r0,r0
80004792:	0d 3a       	ld.ub	r10,r6++
80004794:	00 00       	add	r0,r0
80004796:	0a bc       	st.h	r5++,r12

80004798 <fat_cache_clusterlist_update_finish>:


//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
80004798:	eb cd 40 c0 	pushm	r6-r7,lr
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
8000479c:	49 08       	lddpc	r8,800047dc <fat_cache_clusterlist_update_finish+0x44>
8000479e:	11 88       	ld.ub	r8,r8[0x0]
800047a0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800047a4:	48 f9       	lddpc	r9,800047e0 <fat_cache_clusterlist_update_finish+0x48>
800047a6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800047aa:	f0 ca ff f8 	sub	r10,r8,-8
800047ae:	48 eb       	lddpc	r11,800047e4 <fat_cache_clusterlist_update_finish+0x4c>
800047b0:	17 97       	ld.ub	r7,r11[0x1]
800047b2:	74 09       	ld.w	r9,r10[0x0]
800047b4:	f2 07 0d 06 	divu	r6,r9,r7
800047b8:	0e 99       	mov	r9,r7
800047ba:	5c 59       	castu.b	r9
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
800047bc:	17 8b       	ld.ub	r11,r11[0x0]
800047be:	b0 ab       	st.b	r8[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
800047c0:	74 0b       	ld.w	r11,r10[0x0]
800047c2:	12 1b       	sub	r11,r9
800047c4:	95 0b       	st.w	r10[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
800047c6:	48 9a       	lddpc	r10,800047e8 <fat_cache_clusterlist_update_finish+0x50>
800047c8:	74 0b       	ld.w	r11,r10[0x0]
800047ca:	12 1b       	sub	r11,r9
800047cc:	91 3b       	st.w	r8[0xc],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
800047ce:	74 1a       	ld.w	r10,r10[0x4]
800047d0:	14 09       	add	r9,r10
800047d2:	91 49       	st.w	r8[0x10],r9

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
800047d4:	f0 1f 00 06 	mcall	800047ec <fat_cache_clusterlist_update_finish+0x54>
}
800047d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047dc:	00 00       	add	r0,r0
800047de:	0d 3a       	ld.ub	r10,r6++
800047e0:	00 00       	add	r0,r0
800047e2:	0a bc       	st.h	r5++,r12
800047e4:	00 00       	add	r0,r0
800047e6:	0c e8       	st.h	--r6,r8
800047e8:	00 00       	add	r0,r0
800047ea:	0d 90       	ld.ub	r0,r6[0x1]
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	47 30       	lddsp	r0,sp[0x1cc]

800047f0 <fat_cache_clusterlist_update_read>:
//!
//! @return    true  cluster list found and global variable fs_g_seg updated
//! @return    false no found in cluster list caches
//!
bool  fat_cache_clusterlist_update_read( bool b_for_file )
{
800047f0:	eb cd 40 c0 	pushm	r6-r7,lr
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
800047f4:	4c 18       	lddpc	r8,800048f8 <fat_cache_clusterlist_update_read+0x108>
800047f6:	11 89       	ld.ub	r9,r8[0x0]
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
800047f8:	4c 18       	lddpc	r8,800048fc <fat_cache_clusterlist_update_read+0x10c>
800047fa:	70 0a       	ld.w	r10,r8[0x0]
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
800047fc:	4c 18       	lddpc	r8,80004900 <fat_cache_clusterlist_update_read+0x110>
800047fe:	70 1b       	ld.w	r11,r8[0x4]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80004800:	4c 18       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
80004802:	11 88       	ld.ub	r8,r8[0x0]
80004804:	f8 08 18 00 	cp.b	r8,r12
80004808:	c1 11       	brne	8000482a <fat_cache_clusterlist_update_read+0x3a>
8000480a:	4b f8       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
8000480c:	11 a8       	ld.ub	r8,r8[0x2]
8000480e:	f2 08 18 00 	cp.b	r8,r9
80004812:	c0 c1       	brne	8000482a <fat_cache_clusterlist_update_read+0x3a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80004814:	4b c8       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
80004816:	70 18       	ld.w	r8,r8[0x4]
80004818:	14 38       	cp.w	r8,r10
8000481a:	c0 81       	brne	8000482a <fat_cache_clusterlist_update_read+0x3a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
8000481c:	4b a8       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
8000481e:	70 28       	ld.w	r8,r8[0x8]
80004820:	10 3b       	cp.w	r11,r8
80004822:	c0 43       	brcs	8000482a <fat_cache_clusterlist_update_read+0x3a>
80004824:	30 0a       	mov	r10,0
80004826:	14 99       	mov	r9,r10
80004828:	c1 88       	rjmp	80004858 <fat_cache_clusterlist_update_read+0x68>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000482a:	4b 78       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
8000482c:	f1 38 00 14 	ld.ub	r8,r8[20]
80004830:	f8 08 18 00 	cp.b	r8,r12
80004834:	c5 e1       	brne	800048f0 <fat_cache_clusterlist_update_read+0x100>
80004836:	4b 48       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
80004838:	f1 38 00 16 	ld.ub	r8,r8[22]
8000483c:	f2 08 18 00 	cp.b	r8,r9
80004840:	c5 81       	brne	800048f0 <fat_cache_clusterlist_update_read+0x100>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80004842:	4b 18       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
80004844:	70 68       	ld.w	r8,r8[0x18]
80004846:	14 38       	cp.w	r8,r10
80004848:	c5 41       	brne	800048f0 <fat_cache_clusterlist_update_read+0x100>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
8000484a:	4a f8       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
8000484c:	70 78       	ld.w	r8,r8[0x1c]
8000484e:	16 38       	cp.w	r8,r11
80004850:	e0 8b 00 50 	brhi	800048f0 <fat_cache_clusterlist_update_read+0x100>
80004854:	30 1a       	mov	r10,1
80004856:	14 99       	mov	r9,r10
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
80004858:	f2 0e 15 02 	lsl	lr,r9,0x2
8000485c:	12 0e       	add	lr,r9
8000485e:	4a ac       	lddpc	r12,80004904 <fat_cache_clusterlist_update_read+0x114>
80004860:	f8 0e 00 2c 	add	r12,r12,lr<<0x2
80004864:	78 4c       	ld.w	r12,r12[0x10]
80004866:	f6 08 01 08 	sub	r8,r11,r8
8000486a:	10 3c       	cp.w	r12,r8
8000486c:	e0 88 00 16 	brls	80004898 <fat_cache_clusterlist_update_read+0xa8>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
80004870:	4a 4b       	lddpc	r11,80004900 <fat_cache_clusterlist_update_read+0x110>
80004872:	f2 0e 15 02 	lsl	lr,r9,0x2
80004876:	fc 09 00 09 	add	r9,lr,r9
8000487a:	4a 3e       	lddpc	lr,80004904 <fat_cache_clusterlist_update_read+0x114>
8000487c:	fc 09 00 29 	add	r9,lr,r9<<0x2
80004880:	72 39       	ld.w	r9,r9[0xc]
80004882:	f0 09 00 09 	add	r9,r8,r9
80004886:	97 09       	st.w	r11[0x0],r9
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
80004888:	10 1c       	sub	r12,r8
8000488a:	97 1c       	st.w	r11[0x4],r12
                  fs_g_u8_current_cache = u8_i;
8000488c:	49 f8       	lddpc	r8,80004908 <fat_cache_clusterlist_update_read+0x118>
8000488e:	b0 8a       	st.b	r8[0x0],r10
                  fat_cache_clusterlist_update_select();
80004890:	f0 1f 00 1f 	mcall	8000490c <fat_cache_clusterlist_update_read+0x11c>
80004894:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
80004898:	49 c8       	lddpc	r8,80004908 <fat_cache_clusterlist_update_read+0x118>
8000489a:	b0 8a       	st.b	r8[0x0],r10
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
8000489c:	f2 08 15 02 	lsl	r8,r9,0x2
800048a0:	f0 09 00 09 	add	r9,r8,r9
800048a4:	49 88       	lddpc	r8,80004904 <fat_cache_clusterlist_update_read+0x114>
800048a6:	f0 09 00 28 	add	r8,r8,r9<<0x2
800048aa:	3f f9       	mov	r9,-1
800048ac:	b0 a9       	st.b	r8[0x2],r9
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
800048ae:	70 4c       	ld.w	r12,r8[0x10]
800048b0:	49 2a       	lddpc	r10,800048f8 <fat_cache_clusterlist_update_read+0x108>
800048b2:	15 99       	ld.ub	r9,r10[0x1]
800048b4:	70 3e       	ld.w	lr,r8[0xc]
800048b6:	f8 0e 00 0e 	add	lr,r12,lr
800048ba:	20 1e       	sub	lr,1
800048bc:	74 57       	ld.w	r7,r10[0x14]
800048be:	fc 07 01 07 	sub	r7,lr,r7
800048c2:	74 4a       	ld.w	r10,r10[0x10]
800048c4:	14 17       	sub	r7,r10
800048c6:	ee 09 0d 06 	divu	r6,r7,r9
800048ca:	0c 97       	mov	r7,r6
800048cc:	2f e7       	sub	r7,-2
800048ce:	48 ca       	lddpc	r10,800048fc <fat_cache_clusterlist_update_read+0x10c>
800048d0:	95 07       	st.w	r10[0x0],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
800048d2:	2f 88       	sub	r8,-8
800048d4:	70 0a       	ld.w	r10,r8[0x0]
800048d6:	14 0c       	add	r12,r10
800048d8:	f8 c7 00 01 	sub	r7,r12,1
800048dc:	ee 09 0d 06 	divu	r6,r7,r9
800048e0:	ad 39       	mul	r9,r6
800048e2:	48 8a       	lddpc	r10,80004900 <fat_cache_clusterlist_update_read+0x110>
800048e4:	f6 09 01 09 	sub	r9,r11,r9
800048e8:	95 19       	st.w	r10[0x4],r9
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
800048ea:	91 0b       	st.w	r8[0x0],r11
800048ec:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
         }
      }
   }
   // No found in cache then read FAT and store the result in cache
   fat_cache_clusterlist_update_start(b_for_file);
800048f0:	f0 1f 00 08 	mcall	80004910 <fat_cache_clusterlist_update_read+0x120>
800048f4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800048f8:	00 00       	add	r0,r0
800048fa:	0c e8       	st.h	--r6,r8
800048fc:	00 00       	add	r0,r0
800048fe:	0d 88       	ld.ub	r8,r6[0x0]
80004900:	00 00       	add	r0,r0
80004902:	0d 90       	ld.ub	r0,r6[0x1]
80004904:	00 00       	add	r0,r0
80004906:	0a bc       	st.h	r5++,r12
80004908:	00 00       	add	r0,r0
8000490a:	0d 3a       	ld.ub	r10,r6++
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	47 30       	lddsp	r0,sp[0x1cc]
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	46 e8       	lddsp	r8,sp[0x1b8]

80004914 <fat_entry_is_dir>:
//! @return    true,    this entry is a directory
//! @return    false,   otherwise
//!
bool  fat_entry_is_dir(void)
{
   fs_g_status = FS_ERR_NO_DIR;
80004914:	30 d9       	mov	r9,13
80004916:	48 48       	lddpc	r8,80004924 <fat_entry_is_dir+0x10>
80004918:	b0 89       	st.b	r8[0x0],r9
8000491a:	48 48       	lddpc	r8,80004928 <fat_entry_is_dir+0x14>
8000491c:	11 ac       	ld.ub	r12,r8[0x2]
   return (FS_ATTR_DIRECTORY & fs_g_nav_entry.u8_attr);
}
8000491e:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80004922:	5e fc       	retal	r12
80004924:	00 00       	add	r0,r0
80004926:	0d 38       	ld.ub	r8,r6++
80004928:	00 00       	add	r0,r0
8000492a:	0a a8       	st.w	r5++,r8

8000492c <fat_clear_entry_info_and_ptr>:

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
8000492c:	3f f9       	mov	r9,-1
8000492e:	48 c8       	lddpc	r8,8000495c <fat_clear_entry_info_and_ptr+0x30>
80004930:	b0 19       	st.h	r8[0x2],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
80004932:	48 c8       	lddpc	r8,80004960 <fat_clear_entry_info_and_ptr+0x34>
80004934:	f1 59 00 24 	st.h	r8[36],r9
   if( !fs_g_nav.b_mode_nav_single )
80004938:	f1 39 00 2d 	ld.ub	r9,r8[45]
8000493c:	30 08       	mov	r8,0
8000493e:	f0 09 18 00 	cp.b	r9,r8
80004942:	c0 51       	brne	8000494c <fat_clear_entry_info_and_ptr+0x20>
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
80004944:	10 99       	mov	r9,r8
80004946:	48 78       	lddpc	r8,80004960 <fat_clear_entry_info_and_ptr+0x34>
80004948:	f1 69 00 2c 	st.b	r8[44],r9
   }
   fs_g_nav_entry.u8_attr     = 0;
8000494c:	48 68       	lddpc	r8,80004964 <fat_clear_entry_info_and_ptr+0x38>
8000494e:	30 09       	mov	r9,0
80004950:	b0 a9       	st.b	r8[0x2],r9
   fs_g_nav_entry.u32_cluster = 0;
80004952:	30 0a       	mov	r10,0
80004954:	91 1a       	st.w	r8[0x4],r10
   fs_g_nav_entry.u32_size    = 0;
80004956:	91 2a       	st.w	r8[0x8],r10
   Fat_file_close();
80004958:	b0 89       	st.b	r8[0x0],r9
}
8000495a:	5e fc       	retal	r12
8000495c:	00 00       	add	r0,r0
8000495e:	0d 34       	ld.ub	r4,r6++
80004960:	00 00       	add	r0,r0
80004962:	0c e8       	st.h	--r6,r8
80004964:	00 00       	add	r0,r0
80004966:	0a a8       	st.w	r5++,r8

80004968 <fat_check_eof_name>:
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
80004968:	30 08       	mov	r8,0
8000496a:	f0 0c 19 00 	cp.h	r12,r8
8000496e:	5f 0a       	sreq	r10
80004970:	35 c9       	mov	r9,92
80004972:	f2 0c 19 00 	cp.h	r12,r9
80004976:	5f 09       	sreq	r9
80004978:	f5 e9 10 09 	or	r9,r10,r9
8000497c:	f0 09 18 00 	cp.b	r9,r8
80004980:	c0 20       	breq	80004984 <fat_check_eof_name+0x1c>
80004982:	5e ff       	retal	1
80004984:	32 f8       	mov	r8,47
80004986:	f0 0c 19 00 	cp.h	r12,r8
8000498a:	5f 0c       	sreq	r12
}
8000498c:	5e fc       	retal	r12
8000498e:	d7 03       	nop

80004990 <fat_get_ptr_entry>:
//! This function returns a cache pointer on the current entry
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
80004990:	48 48       	lddpc	r8,800049a0 <fat_get_ptr_entry+0x10>
80004992:	90 98       	ld.uh	r8,r8[0x2]
80004994:	a5 78       	lsl	r8,0x5
80004996:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
}
8000499a:	48 3c       	lddpc	r12,800049a4 <fat_get_ptr_entry+0x14>
8000499c:	10 0c       	add	r12,r8
8000499e:	5e fc       	retal	r12
800049a0:	00 00       	add	r0,r0
800049a2:	0d 34       	ld.ub	r4,r6++
800049a4:	00 00       	add	r0,r0
800049a6:	0a e8       	st.h	--r5,r8

800049a8 <fat_entry_longname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_longname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case )
{
800049a8:	d4 31       	pushm	r0-r7,lr
800049aa:	20 3d       	sub	sp,12
800049ac:	18 97       	mov	r7,r12
800049ae:	16 94       	mov	r4,r11
800049b0:	14 96       	mov	r6,r10
800049b2:	50 09       	stdsp	sp[0x0],r9
   uint8_t u8_pos_name;
   PTR_CACHE ptr_entry;
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();
800049b4:	f0 1f 00 5e 	mcall	80004b2c <fat_entry_longname+0x184>

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
800049b8:	19 88       	ld.ub	r8,r12[0x0]
800049ba:	30 09       	mov	r9,0
800049bc:	f2 08 18 00 	cp.b	r8,r9
800049c0:	5f 0b       	sreq	r11
800049c2:	3e 5a       	mov	r10,-27
800049c4:	f4 08 18 00 	cp.b	r8,r10
800049c8:	5f 0a       	sreq	r10
800049ca:	f7 ea 10 0a 	or	r10,r11,r10
800049ce:	f2 0a 18 00 	cp.b	r10,r9
800049d2:	c0 71       	brne	800049e0 <fat_entry_longname+0x38>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
800049d4:	f9 3a 00 0b 	ld.ub	r10,r12[11]
800049d8:	30 f9       	mov	r9,15
800049da:	f2 0a 18 00 	cp.b	r10,r9
800049de:	c0 60       	breq	800049ea <fat_entry_longname+0x42>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
800049e0:	30 b9       	mov	r9,11
800049e2:	4d 48       	lddpc	r8,80004b30 <fat_entry_longname+0x188>
800049e4:	b0 89       	st.b	r8[0x0],r9
800049e6:	30 0c       	mov	r12,0
      return false;
800049e8:	c9 c8       	rjmp	80004b20 <fat_entry_longname+0x178>
   }

   if( g_b_string_length )
800049ea:	4d 39       	lddpc	r9,80004b34 <fat_entry_longname+0x18c>
800049ec:	13 8a       	ld.ub	r10,r9[0x0]
800049ee:	30 09       	mov	r9,0
800049f0:	f2 0a 18 00 	cp.b	r10,r9
800049f4:	c0 90       	breq	80004a06 <fat_entry_longname+0x5e>
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
800049f6:	e2 18 00 40 	andl	r8,0x40,COH
800049fa:	c0 61       	brne	80004a06 <fat_entry_longname+0x5e>
      {
         // no necessary -> ((FS_STR_UNICODE)sz_name)[0] = FS_SIZE_LFN_ENTRY;
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
800049fc:	31 09       	mov	r9,16
800049fe:	4c d8       	lddpc	r8,80004b30 <fat_entry_longname+0x188>
80004a00:	b0 89       	st.b	r8[0x0],r9
80004a02:	30 0c       	mov	r12,0
         return false;                          // Other entry long name
80004a04:	c8 e8       	rjmp	80004b20 <fat_entry_longname+0x178>
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
80004a06:	2f fc       	sub	r12,-1
80004a08:	30 08       	mov	r8,0

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80004a0a:	fa ca ff f6 	sub	r10,sp,-10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80004a0e:	30 0b       	mov	r11,0
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
80004a10:	4c 95       	lddpc	r5,80004b34 <fat_entry_longname+0x18c>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80004a12:	20 14       	sub	r4,1
80004a14:	50 14       	stdsp	sp[0x4],r4
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
80004a16:	30 01       	mov	r1,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80004a18:	30 44       	mov	r4,4
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80004a1a:	19 89       	ld.ub	r9,r12[0x0]
80004a1c:	b4 99       	st.b	r10[0x1],r9
      MSB(u16_unicode_entry) = ptr_entry[1];
80004a1e:	19 99       	ld.ub	r9,r12[0x1]
80004a20:	b4 89       	st.b	r10[0x0],r9
      if( FS_NAME_GET == b_mode )
80004a22:	58 06       	cp.w	r6,0
80004a24:	c0 f0       	breq	80004a42 <fat_entry_longname+0x9a>
      {
         if( !g_b_string_length )
80004a26:	0b 89       	ld.ub	r9,r5[0x0]
80004a28:	f6 09 18 00 	cp.b	r9,r11
80004a2c:	c3 91       	brne	80004a9e <fat_entry_longname+0xf6>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80004a2e:	40 1e       	lddsp	lr,sp[0x4]
80004a30:	1c 38       	cp.w	r8,lr
80004a32:	c0 55       	brlt	80004a3c <fat_entry_longname+0x94>
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004a34:	30 08       	mov	r8,0
80004a36:	ae 88       	st.b	r7[0x0],r8
80004a38:	30 1c       	mov	r12,1
               }
               return true;                     // the buffer is full
80004a3a:	c7 38       	rjmp	80004b20 <fat_entry_longname+0x178>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
80004a3c:	9a 59       	ld.sh	r9,sp[0xa]
80004a3e:	ae 89       	st.b	r7[0x0],r9
80004a40:	c2 f8       	rjmp	80004a9e <fat_entry_longname+0xf6>
      {
         if( Is_unicode )
         {
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
80004a42:	0f 89       	ld.ub	r9,r7[0x0]
         }
         // Check the name
         if( '*' == u16_unicode_szname )
80004a44:	32 a3       	mov	r3,42
80004a46:	e6 09 19 00 	cp.h	r9,r3
80004a4a:	c6 a0       	breq	80004b1e <fat_entry_longname+0x176>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80004a4c:	9a 5e       	ld.sh	lr,sp[0xa]
80004a4e:	58 0e       	cp.w	lr,0
80004a50:	c0 e1       	brne	80004a6c <fat_entry_longname+0xc4>
80004a52:	35 c0       	mov	r0,92
80004a54:	e0 09 19 00 	cp.h	r9,r0
80004a58:	5f 12       	srne	r2
80004a5a:	32 f3       	mov	r3,47
80004a5c:	e6 09 19 00 	cp.h	r9,r3
80004a60:	5f 13       	srne	r3
80004a62:	e5 e3 00 03 	and	r3,r2,r3
80004a66:	f6 03 18 00 	cp.b	r3,r11
80004a6a:	c1 e0       	breq	80004aa6 <fat_entry_longname+0xfe>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
80004a6c:	e7 d9 c0 10 	bfextu	r3,r9,0x0,0x10
80004a70:	e5 de c0 10 	bfextu	r2,lr,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80004a74:	e4 c0 ff e0 	sub	r0,r2,-32
80004a78:	00 33       	cp.w	r3,r0
80004a7a:	c0 41       	brne	80004a82 <fat_entry_longname+0xda>
80004a7c:	40 00       	lddsp	r0,sp[0x0]
80004a7e:	58 00       	cp.w	r0,0
80004a80:	c0 f0       	breq	80004a9e <fat_entry_longname+0xf6>
80004a82:	22 02       	sub	r2,32
80004a84:	04 33       	cp.w	r3,r2
80004a86:	c0 41       	brne	80004a8e <fat_entry_longname+0xe6>
80004a88:	40 03       	lddsp	r3,sp[0x0]
80004a8a:	58 03       	cp.w	r3,0
80004a8c:	c0 90       	breq	80004a9e <fat_entry_longname+0xf6>
80004a8e:	fc 09 19 00 	cp.h	r9,lr
80004a92:	c0 60       	breq	80004a9e <fat_entry_longname+0xf6>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
80004a94:	31 69       	mov	r9,22
80004a96:	4a 78       	lddpc	r8,80004b30 <fat_entry_longname+0x188>
80004a98:	b0 89       	st.b	r8[0x0],r9
80004a9a:	30 0c       	mov	r12,0
           return false;
80004a9c:	c4 28       	rjmp	80004b20 <fat_entry_longname+0x178>
         }
      }

      if( 0 == u16_unicode_entry)
80004a9e:	9a 59       	ld.sh	r9,sp[0xa]
80004aa0:	e2 09 19 00 	cp.h	r9,r1
80004aa4:	c0 b1       	brne	80004aba <fat_entry_longname+0x112>
      {
         if( g_b_string_length )
80004aa6:	4a 49       	lddpc	r9,80004b34 <fat_entry_longname+0x18c>
80004aa8:	13 8a       	ld.ub	r10,r9[0x0]
80004aaa:	30 09       	mov	r9,0
80004aac:	f2 0a 18 00 	cp.b	r10,r9
80004ab0:	c3 70       	breq	80004b1e <fat_entry_longname+0x176>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
80004ab2:	2f f8       	sub	r8,-1
80004ab4:	ae 08       	st.h	r7[0x0],r8
80004ab6:	30 1c       	mov	r12,1
80004ab8:	c3 48       	rjmp	80004b20 <fat_entry_longname+0x178>
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80004aba:	e8 08 18 00 	cp.b	r8,r4
80004abe:	c0 31       	brne	80004ac4 <fat_entry_longname+0x11c>
         ptr_entry += 3;                        // Go to second character
80004ac0:	2f dc       	sub	r12,-3
80004ac2:	c2 58       	rjmp	80004b0c <fat_entry_longname+0x164>

      if( 10 == u8_pos_name )
80004ac4:	30 a9       	mov	r9,10
80004ac6:	f2 08 18 00 	cp.b	r8,r9
80004aca:	c0 31       	brne	80004ad0 <fat_entry_longname+0x128>
         ptr_entry += 2;                        // Go to third character
80004acc:	2f ec       	sub	r12,-2
80004ace:	c1 f8       	rjmp	80004b0c <fat_entry_longname+0x164>

      if( 12 == u8_pos_name )
80004ad0:	30 c9       	mov	r9,12
80004ad2:	f2 08 18 00 	cp.b	r8,r9
80004ad6:	c1 b1       	brne	80004b0c <fat_entry_longname+0x164>
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
80004ad8:	f9 38 ff e2 	ld.ub	r8,r12[-30]
80004adc:	e2 18 00 40 	andl	r8,0x40,COH
80004ae0:	c0 61       	brne	80004aec <fat_entry_longname+0x144>
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
80004ae2:	31 09       	mov	r9,16
80004ae4:	49 38       	lddpc	r8,80004b30 <fat_entry_longname+0x188>
80004ae6:	b0 89       	st.b	r8[0x0],r9
80004ae8:	30 0c       	mov	r12,0
            return false;                       // Other long name entry is present
80004aea:	c1 b8       	rjmp	80004b20 <fat_entry_longname+0x178>
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
80004aec:	58 06       	cp.w	r6,0
80004aee:	c0 b0       	breq	80004b04 <fat_entry_longname+0x15c>
80004af0:	49 18       	lddpc	r8,80004b34 <fat_entry_longname+0x18c>
80004af2:	11 89       	ld.ub	r9,r8[0x0]
80004af4:	30 08       	mov	r8,0
80004af6:	f0 09 18 00 	cp.b	r9,r8
80004afa:	c1 50       	breq	80004b24 <fat_entry_longname+0x17c>
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
80004afc:	30 e8       	mov	r8,14
80004afe:	ae 08       	st.h	r7[0x0],r8
80004b00:	30 1c       	mov	r12,1
               return true;
80004b02:	c0 f8       	rjmp	80004b20 <fat_entry_longname+0x178>
               {
                  u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
               }else{
                  u16_unicode_szname = sz_name[0];
               }
               return fat_check_eof_name(u16_unicode_szname);
80004b04:	0f 9c       	ld.ub	r12,r7[0x1]
80004b06:	f0 1f 00 0d 	mcall	80004b38 <fat_entry_longname+0x190>
80004b0a:	c0 b8       	rjmp	80004b20 <fat_entry_longname+0x178>
            }
         }
      }

      if( !g_b_string_length )
80004b0c:	0b 89       	ld.ub	r9,r5[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
80004b0e:	f6 09 18 00 	cp.b	r9,r11
80004b12:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80004b16:	2f f8       	sub	r8,-1
80004b18:	5c 58       	castu.b	r8
      ptr_entry+=2;
80004b1a:	2f ec       	sub	r12,-2
   }
80004b1c:	c7 fb       	rjmp	80004a1a <fat_entry_longname+0x72>
80004b1e:	30 1c       	mov	r12,1
}
80004b20:	2f dd       	sub	sp,-12
80004b22:	d8 32       	popm	r0-r7,pc
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004b24:	30 08       	mov	r8,0
80004b26:	ae 98       	st.b	r7[0x1],r8
80004b28:	30 1c       	mov	r12,1
               }
               return true;
80004b2a:	cf bb       	rjmp	80004b20 <fat_entry_longname+0x178>
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	49 90       	lddpc	r0,80004b90 <fat_entry_shortname+0x54>
80004b30:	00 00       	add	r0,r0
80004b32:	0d 38       	ld.ub	r8,r6++
80004b34:	00 00       	add	r0,r0
80004b36:	0d 39       	ld.ub	r9,r6++
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	49 68       	lddpc	r8,80004b90 <fat_entry_shortname+0x54>

80004b3c <fat_entry_shortname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_shortname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode )
{
80004b3c:	d4 31       	pushm	r0-r7,lr
80004b3e:	20 2d       	sub	sp,8
80004b40:	18 97       	mov	r7,r12
80004b42:	50 1b       	stdsp	sp[0x4],r11
80004b44:	14 96       	mov	r6,r10
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
80004b46:	31 69       	mov	r9,22
80004b48:	4b c8       	lddpc	r8,80004c38 <fat_entry_shortname+0xfc>
80004b4a:	b0 89       	st.b	r8[0x0],r9

   u8_pos_name = 0;
   u8_pos_entry = 0;
   ptr_entry = fat_get_ptr_entry();
80004b4c:	f0 1f 00 3c 	mcall	80004c3c <fat_entry_shortname+0x100>
80004b50:	30 08       	mov	r8,0
80004b52:	10 9a       	mov	r10,r8
80004b54:	30 1b       	mov	r11,1
80004b56:	50 0b       	stdsp	sp[0x0],r11

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
80004b58:	30 be       	mov	lr,11
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004b5a:	10 93       	mov	r3,r8
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
80004b5c:	30 85       	mov	r5,8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004b5e:	32 04       	mov	r4,32
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
80004b60:	32 a2       	mov	r2,42
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
80004b62:	fc 08 18 00 	cp.b	r8,lr
80004b66:	c1 90       	breq	80004b98 <fat_entry_shortname+0x5c>
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
80004b68:	f8 08 07 09 	ld.ub	r9,r12[r8]
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
80004b6c:	ea 08 18 00 	cp.b	r8,r5
80004b70:	c0 41       	brne	80004b78 <fat_entry_shortname+0x3c>
80004b72:	40 01       	lddsp	r1,sp[0x0]
80004b74:	58 01       	cp.w	r1,0
80004b76:	c0 81       	brne	80004b86 <fat_entry_shortname+0x4a>
80004b78:	e8 09 18 00 	cp.b	r9,r4
80004b7c:	c0 f1       	brne	80004b9a <fat_entry_shortname+0x5e>
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
80004b7e:	ea 08 18 00 	cp.b	r8,r5
80004b82:	e0 8b 00 0b 	brhi	80004b98 <fat_entry_shortname+0x5c>
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004b86:	f9 39 00 08 	ld.ub	r9,r12[8]
80004b8a:	e8 09 18 00 	cp.b	r9,r4
80004b8e:	c0 50       	breq	80004b98 <fat_entry_shortname+0x5c>
80004b90:	30 78       	mov	r8,7
80004b92:	32 e9       	mov	r9,46
80004b94:	50 03       	stdsp	sp[0x0],r3
80004b96:	c0 28       	rjmp	80004b9a <fat_entry_shortname+0x5e>
80004b98:	06 99       	mov	r9,r3
               u8_entry_char = 0;                                    // end of name
            }
         }
      }

      if( FS_NAME_GET == b_mode )
80004b9a:	58 06       	cp.w	r6,0
80004b9c:	c1 80       	breq	80004bcc <fat_entry_shortname+0x90>
      {
         if( !g_b_string_length )
80004b9e:	4a 9b       	lddpc	r11,80004c40 <fat_entry_shortname+0x104>
80004ba0:	17 81       	ld.ub	r1,r11[0x0]
80004ba2:	30 0b       	mov	r11,0
80004ba4:	f6 01 18 00 	cp.b	r1,r11
80004ba8:	c2 c1       	brne	80004c00 <fat_entry_shortname+0xc4>
         {
            if(u8_pos_name >= (u8_size_max-1))
80004baa:	40 1b       	lddsp	r11,sp[0x4]
80004bac:	20 1b       	sub	r11,1
80004bae:	16 3a       	cp.w	r10,r11
80004bb0:	c0 35       	brlt	80004bb6 <fat_entry_shortname+0x7a>
80004bb2:	06 99       	mov	r9,r3
80004bb4:	c0 a8       	rjmp	80004bc8 <fat_entry_shortname+0x8c>
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
80004bb6:	f2 c1 00 41 	sub	r1,r9,65
80004bba:	31 9b       	mov	r11,25
80004bbc:	f6 01 18 00 	cp.b	r1,r11
80004bc0:	e0 8b 00 04 	brhi	80004bc8 <fat_entry_shortname+0x8c>
               u8_entry_char += ('a'-'A');                           // display short name in down case
80004bc4:	2e 09       	sub	r9,-32
80004bc6:	5c 59       	castu.b	r9

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
80004bc8:	ae 89       	st.b	r7[0x0],r9
80004bca:	c1 b8       	rjmp	80004c00 <fat_entry_shortname+0xc4>

         if( Is_unicode )
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
80004bcc:	0f 8b       	ld.ub	r11,r7[0x0]
         }
         if ('*' == u8_szname_char)
80004bce:	e4 0b 18 00 	cp.b	r11,r2
80004bd2:	c2 f0       	breq	80004c30 <fat_entry_shortname+0xf4>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
80004bd4:	58 09       	cp.w	r9,0
80004bd6:	c0 c1       	brne	80004bee <fat_entry_shortname+0xb2>
80004bd8:	35 c1       	mov	r1,92
80004bda:	e2 0b 18 00 	cp.b	r11,r1
80004bde:	5f 10       	srne	r0
80004be0:	32 f1       	mov	r1,47
80004be2:	e2 0b 18 00 	cp.b	r11,r1
80004be6:	5f 11       	srne	r1
80004be8:	e1 e1 00 01 	and	r1,r0,r1
80004bec:	c0 c0       	breq	80004c04 <fat_entry_shortname+0xc8>
         {
            if((u8_szname_char != u8_entry_char)
80004bee:	f2 0b 18 00 	cp.b	r11,r9
80004bf2:	c0 70       	breq	80004c00 <fat_entry_shortname+0xc4>
80004bf4:	f2 c1 ff e0 	sub	r1,r9,-32
80004bf8:	02 3b       	cp.w	r11,r1
80004bfa:	c0 30       	breq	80004c00 <fat_entry_shortname+0xc4>
80004bfc:	30 0c       	mov	r12,0
80004bfe:	c1 a8       	rjmp	80004c32 <fat_entry_shortname+0xf6>
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
80004c00:	58 09       	cp.w	r9,0
80004c02:	c0 b1       	brne	80004c18 <fat_entry_shortname+0xdc>
      {
         if( g_b_string_length )
80004c04:	48 f8       	lddpc	r8,80004c40 <fat_entry_shortname+0x104>
80004c06:	11 89       	ld.ub	r9,r8[0x0]
80004c08:	30 08       	mov	r8,0
80004c0a:	f0 09 18 00 	cp.b	r9,r8
80004c0e:	c1 10       	breq	80004c30 <fat_entry_shortname+0xf4>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
80004c10:	2f fa       	sub	r10,-1
80004c12:	ae 0a       	st.h	r7[0x0],r10
80004c14:	30 1c       	mov	r12,1
80004c16:	c0 e8       	rjmp	80004c32 <fat_entry_shortname+0xf6>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
80004c18:	48 a9       	lddpc	r9,80004c40 <fat_entry_shortname+0x104>
80004c1a:	13 8b       	ld.ub	r11,r9[0x0]
80004c1c:	30 09       	mov	r9,0
      {
         sz_name += (Is_unicode? 2 : 1 );
80004c1e:	f2 0b 18 00 	cp.b	r11,r9
80004c22:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80004c26:	2f fa       	sub	r10,-1
80004c28:	5c 5a       	castu.b	r10
      u8_pos_entry++;
80004c2a:	2f f8       	sub	r8,-1
80004c2c:	5c 58       	castu.b	r8
   }
80004c2e:	c9 ab       	rjmp	80004b62 <fat_entry_shortname+0x26>
80004c30:	30 1c       	mov	r12,1
}
80004c32:	2f ed       	sub	sp,-8
80004c34:	d8 32       	popm	r0-r7,pc
80004c36:	00 00       	add	r0,r0
80004c38:	00 00       	add	r0,r0
80004c3a:	0d 38       	ld.ub	r8,r6++
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	49 90       	lddpc	r0,80004ca0 <fat_entry_checkext+0x14>
80004c40:	00 00       	add	r0,r0
80004c42:	0d 39       	ld.ub	r9,r6++

80004c44 <fat_get_entry_info>:
//! OUT:
//!   fs_g_nav_entry. u32_cluster, u8_attr, u32_size
//! @endverbatim
//!
void  fat_get_entry_info( void )
{
80004c44:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
80004c46:	f0 1f 00 10 	mcall	80004c84 <fat_get_entry_info+0x40>

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
80004c4a:	49 08       	lddpc	r8,80004c88 <fat_get_entry_info+0x44>
80004c4c:	f9 39 00 0b 	ld.ub	r9,r12[11]
80004c50:	b0 a9       	st.b	r8[0x2],r9

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
80004c52:	f8 ca ff ec 	sub	r10,r12,-20
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
80004c56:	f0 c9 ff fc 	sub	r9,r8,-4
80004c5a:	15 8b       	ld.ub	r11,r10[0x0]
80004c5c:	b2 9b       	st.b	r9[0x1],r11
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
80004c5e:	15 9a       	ld.ub	r10,r10[0x1]
80004c60:	b2 8a       	st.b	r9[0x0],r10
   ptr_entry += (26-20);
80004c62:	f8 ca ff e6 	sub	r10,r12,-26
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
80004c66:	15 8b       	ld.ub	r11,r10[0x0]
80004c68:	b2 bb       	st.b	r9[0x3],r11
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
80004c6a:	15 9a       	ld.ub	r10,r10[0x1]
80004c6c:	b2 aa       	st.b	r9[0x2],r10

   // Get the size of file
   ptr_entry += (28-26);
80004c6e:	2e 4c       	sub	r12,-28
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
80004c70:	2f 88       	sub	r8,-8
80004c72:	19 89       	ld.ub	r9,r12[0x0]
80004c74:	b0 b9       	st.b	r8[0x3],r9
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
80004c76:	19 99       	ld.ub	r9,r12[0x1]
80004c78:	b0 a9       	st.b	r8[0x2],r9
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
80004c7a:	19 a9       	ld.ub	r9,r12[0x2]
80004c7c:	b0 99       	st.b	r8[0x1],r9
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
80004c7e:	19 b9       	ld.ub	r9,r12[0x3]
80004c80:	b0 89       	st.b	r8[0x0],r9
}
80004c82:	d8 02       	popm	pc
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	49 90       	lddpc	r0,80004ce8 <fat_entry_checkext+0x5c>
80004c88:	00 00       	add	r0,r0
80004c8a:	0a a8       	st.w	r5++,r8

80004c8c <fat_entry_checkext>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_checkext( FS_STRING sz_filter )
{
80004c8c:	eb cd 40 fc 	pushm	r2-r7,lr
80004c90:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();
80004c92:	f0 1f 00 26 	mcall	80004d28 <fat_entry_checkext+0x9c>

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
80004c96:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
80004c98:	32 a9       	mov	r9,42
80004c9a:	f2 08 18 00 	cp.b	r8,r9
80004c9e:	c3 f0       	breq	80004d1c <fat_entry_checkext+0x90>
80004ca0:	30 0a       	mov	r10,0
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
80004ca2:	30 25       	mov	r5,2
      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80004ca4:	30 0e       	mov	lr,0

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
80004ca6:	32 c9       	mov	r9,44
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
80004ca8:	32 03       	mov	r3,32
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004caa:	14 94       	mov	r4,r10

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
      if ('*' == u8_filter_char)
80004cac:	32 a6       	mov	r6,42
80004cae:	c0 68       	rjmp	80004cba <fat_entry_checkext+0x2e>
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004cb0:	2f f7       	sub	r7,-1
   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
80004cb2:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
80004cb4:	ec 08 18 00 	cp.b	r8,r6
80004cb8:	c3 20       	breq	80004d1c <fat_entry_checkext+0x90>
         break; // All extension is good

      u8_entry_char = u8_ptr_entry[8+u8_i];
80004cba:	f8 0a 00 0b 	add	r11,r12,r10
80004cbe:	f7 3b 00 08 	ld.ub	r11,r11[8]

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
80004cc2:	f6 08 18 00 	cp.b	r8,r11
80004cc6:	c2 20       	breq	80004d0a <fat_entry_checkext+0x7e>
80004cc8:	f6 c2 ff e0 	sub	r2,r11,-32
80004ccc:	04 38       	cp.w	r8,r2
80004cce:	c1 e0       	breq	80004d0a <fat_entry_checkext+0x7e>
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80004cd0:	fc 08 18 00 	cp.b	r8,lr
80004cd4:	5f 0a       	sreq	r10

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
80004cd6:	f2 08 18 00 	cp.b	r8,r9
80004cda:	5f 02       	sreq	r2
80004cdc:	f5 e2 10 02 	or	r2,r10,r2
80004ce0:	fc 02 18 00 	cp.b	r2,lr
80004ce4:	c0 71       	brne	80004cf2 <fat_entry_checkext+0x66>
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
80004ce6:	f2 08 18 00 	cp.b	r8,r9
80004cea:	c1 b0       	breq	80004d20 <fat_entry_checkext+0x94>
         {
            if (0  == u8_filter_char)
80004cec:	58 0a       	cp.w	r10,0
80004cee:	c0 80       	breq	80004cfe <fat_entry_checkext+0x72>
80004cf0:	c1 48       	rjmp	80004d18 <fat_entry_checkext+0x8c>
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
80004cf2:	e6 0b 18 00 	cp.b	r11,r3
80004cf6:	cf 81       	brne	80004ce6 <fat_entry_checkext+0x5a>
80004cf8:	c1 28       	rjmp	80004d1c <fat_entry_checkext+0x90>
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
         {
            if (0  == u8_filter_char)
80004cfa:	58 08       	cp.w	r8,0
80004cfc:	c0 e0       	breq	80004d18 <fat_entry_checkext+0x8c>
            {
               return false;   // it is the last filter
            }
            sz_filter++;
80004cfe:	2f f7       	sub	r7,-1
            u8_filter_char = *sz_filter;
80004d00:	0f 88       	ld.ub	r8,r7[0x0]
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
80004d02:	f2 08 18 00 	cp.b	r8,r9
80004d06:	cf a1       	brne	80004cfa <fat_entry_checkext+0x6e>
80004d08:	c0 c8       	rjmp	80004d20 <fat_entry_checkext+0x94>
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
80004d0a:	2f fa       	sub	r10,-1
80004d0c:	5c 5a       	castu.b	r10
80004d0e:	ea 0a 18 00 	cp.b	r10,r5
80004d12:	fe 98 ff cf 	brls	80004cb0 <fat_entry_checkext+0x24>
80004d16:	c0 38       	rjmp	80004d1c <fat_entry_checkext+0x90>
80004d18:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004d1c:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004d20:	2f f7       	sub	r7,-1
80004d22:	08 9a       	mov	r10,r4
80004d24:	cc 7b       	rjmp	80004cb2 <fat_entry_checkext+0x26>
80004d26:	00 00       	add	r0,r0
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	49 90       	lddpc	r0,80004d8c <fat_cache_reset+0x4>

80004d2c <fat_entry_check>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_check( bool b_type )
{
80004d2c:	eb cd 40 80 	pushm	r7,lr
80004d30:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_first_byte, u8_seconde_byte;
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();
80004d32:	f0 1f 00 14 	mcall	80004d80 <fat_entry_check+0x54>

   u8_first_byte = u8_ptr_entry[0];
80004d36:	19 88       	ld.ub	r8,r12[0x0]
   if ( FS_ENTRY_END == u8_first_byte )
80004d38:	58 08       	cp.w	r8,0
80004d3a:	c0 61       	brne	80004d46 <fat_entry_check+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
80004d3c:	30 a9       	mov	r9,10
80004d3e:	49 28       	lddpc	r8,80004d84 <fat_entry_check+0x58>
80004d40:	b0 89       	st.b	r8[0x0],r9
80004d42:	30 07       	mov	r7,0
      return false;
80004d44:	c1 a8       	rjmp	80004d78 <fat_entry_check+0x4c>
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
80004d46:	30 ba       	mov	r10,11
80004d48:	48 f9       	lddpc	r9,80004d84 <fat_entry_check+0x58>
80004d4a:	b2 8a       	st.b	r9[0x0],r10
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
80004d4c:	3e 59       	mov	r9,-27
80004d4e:	f2 08 18 00 	cp.b	r8,r9
80004d52:	c1 20       	breq	80004d76 <fat_entry_check+0x4a>
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
80004d54:	32 e9       	mov	r9,46
80004d56:	f2 08 18 00 	cp.b	r8,r9
80004d5a:	c0 e0       	breq	80004d76 <fat_entry_check+0x4a>
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
80004d5c:	f9 38 00 0b 	ld.ub	r8,r12[11]
80004d60:	10 99       	mov	r9,r8
80004d62:	e2 19 00 08 	andl	r9,0x8,COH
80004d66:	c0 81       	brne	80004d76 <fat_entry_check+0x4a>
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
80004d68:	e2 18 00 10 	andl	r8,0x10,COH
80004d6c:	c0 60       	breq	80004d78 <fat_entry_check+0x4c>
   {
      return (FS_DIR == b_type);
80004d6e:	ec 17 00 01 	eorl	r7,0x1
80004d72:	5c 57       	castu.b	r7
80004d74:	c0 28       	rjmp	80004d78 <fat_entry_check+0x4c>
80004d76:	30 07       	mov	r7,0
   }else{
      return (FS_FILE == b_type);
   }
}
80004d78:	0e 9c       	mov	r12,r7
80004d7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d7e:	00 00       	add	r0,r0
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	49 90       	lddpc	r0,80004de4 <fat_write_entry_file+0x34>
80004d84:	00 00       	add	r0,r0
80004d86:	0d 38       	ld.ub	r8,r6++

80004d88 <fat_cache_reset>:

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
80004d88:	48 58       	lddpc	r8,80004d9c <fat_cache_reset+0x14>
80004d8a:	3f f9       	mov	r9,-1
80004d8c:	b0 89       	st.b	r8[0x0],r9
   fs_g_sectorcache.u8_dirty              = false;
80004d8e:	30 09       	mov	r9,0
80004d90:	f1 69 00 08 	st.b	r8[8],r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
80004d94:	3f f9       	mov	r9,-1
80004d96:	91 39       	st.w	r8[0xc],r9
}
80004d98:	5e fc       	retal	r12
80004d9a:	00 00       	add	r0,r0
80004d9c:	00 00       	add	r0,r0
80004d9e:	0d 70       	ld.ub	r0,--r6

80004da0 <fat_cache_mark_sector_as_dirty>:

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
80004da0:	30 19       	mov	r9,1
80004da2:	48 38       	lddpc	r8,80004dac <fat_cache_mark_sector_as_dirty+0xc>
80004da4:	f1 69 00 08 	st.b	r8[8],r9
}
80004da8:	5e fc       	retal	r12
80004daa:	00 00       	add	r0,r0
80004dac:	00 00       	add	r0,r0
80004dae:	0d 70       	ld.ub	r0,--r6

80004db0 <fat_write_entry_file>:
//! OUT:
//!   fs_g_sector    Updated
//! @endverbatim
//!
void  fat_write_entry_file( void )
{
80004db0:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   fat_cache_mark_sector_as_dirty();
80004db2:	f0 1f 00 11 	mcall	80004df4 <fat_write_entry_file+0x44>
   ptr_entry = fat_get_ptr_entry();
80004db6:	f0 1f 00 11 	mcall	80004df8 <fat_write_entry_file+0x48>
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
80004dba:	49 18       	lddpc	r8,80004dfc <fat_write_entry_file+0x4c>
80004dbc:	11 a9       	ld.ub	r9,r8[0x2]
80004dbe:	f9 69 00 0b 	st.b	r12[11],r9

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
80004dc2:	f8 ca ff ec 	sub	r10,r12,-20
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
80004dc6:	f0 c9 ff fc 	sub	r9,r8,-4
80004dca:	13 9b       	ld.ub	r11,r9[0x1]
80004dcc:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
80004dce:	13 8b       	ld.ub	r11,r9[0x0]
80004dd0:	b4 9b       	st.b	r10[0x1],r11
   ptr_entry += (26-20);
80004dd2:	f8 ca ff e6 	sub	r10,r12,-26
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
80004dd6:	13 bb       	ld.ub	r11,r9[0x3]
80004dd8:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
80004dda:	13 a9       	ld.ub	r9,r9[0x2]
80004ddc:	b4 99       	st.b	r10[0x1],r9

   //! Write the size of file
   ptr_entry += (28-26);
80004dde:	2e 4c       	sub	r12,-28
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
80004de0:	2f 88       	sub	r8,-8
80004de2:	11 b9       	ld.ub	r9,r8[0x3]
80004de4:	b8 89       	st.b	r12[0x0],r9
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
80004de6:	11 a9       	ld.ub	r9,r8[0x2]
80004de8:	b8 99       	st.b	r12[0x1],r9
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
80004dea:	11 99       	ld.ub	r9,r8[0x1]
80004dec:	b8 a9       	st.b	r12[0x2],r9
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
80004dee:	11 88       	ld.ub	r8,r8[0x0]
80004df0:	b8 b8       	st.b	r12[0x3],r8
}
80004df2:	d8 02       	popm	pc
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	4d a0       	lddpc	r0,80004f5c <fat_cache_flush+0x8>
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	49 90       	lddpc	r0,80004e5c <fat_check_nav_access_file+0x5c>
80004dfc:	00 00       	add	r0,r0
80004dfe:	0a a8       	st.w	r5++,r8

80004e00 <fat_check_nav_access_file>:

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
80004e00:	49 88       	lddpc	r8,80004e60 <fat_check_nav_access_file+0x60>
80004e02:	11 89       	ld.ub	r9,r8[0x0]
80004e04:	30 08       	mov	r8,0
80004e06:	f0 09 18 00 	cp.b	r9,r8
80004e0a:	c2 a0       	breq	80004e5e <fat_check_nav_access_file+0x5e>
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004e0c:	49 68       	lddpc	r8,80004e64 <fat_check_nav_access_file+0x64>
80004e0e:	11 89       	ld.ub	r9,r8[0x0]
80004e10:	49 68       	lddpc	r8,80004e68 <fat_check_nav_access_file+0x68>
80004e12:	11 88       	ld.ub	r8,r8[0x0]
80004e14:	f0 09 18 00 	cp.b	r9,r8
80004e18:	c2 31       	brne	80004e5e <fat_check_nav_access_file+0x5e>
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
80004e1a:	49 38       	lddpc	r8,80004e64 <fat_check_nav_access_file+0x64>
80004e1c:	70 89       	ld.w	r9,r8[0x20]
80004e1e:	49 38       	lddpc	r8,80004e68 <fat_check_nav_access_file+0x68>
80004e20:	70 88       	ld.w	r8,r8[0x20]
80004e22:	10 39       	cp.w	r9,r8
80004e24:	c1 d1       	brne	80004e5e <fat_check_nav_access_file+0x5e>
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
80004e26:	49 28       	lddpc	r8,80004e6c <fat_check_nav_access_file+0x6c>
80004e28:	90 19       	ld.sh	r9,r8[0x2]
80004e2a:	48 e8       	lddpc	r8,80004e60 <fat_check_nav_access_file+0x60>
80004e2c:	90 18       	ld.sh	r8,r8[0x2]
80004e2e:	f0 09 19 00 	cp.h	r9,r8
80004e32:	c1 61       	brne	80004e5e <fat_check_nav_access_file+0x5e>
      {
         if( mode )
80004e34:	58 0c       	cp.w	r12,0
80004e36:	c0 b0       	breq	80004e4c <fat_check_nav_access_file+0x4c>
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
80004e38:	48 e8       	lddpc	r8,80004e70 <fat_check_nav_access_file+0x70>
80004e3a:	11 89       	ld.ub	r9,r8[0x0]
80004e3c:	30 08       	mov	r8,0
80004e3e:	f0 09 18 00 	cp.b	r9,r8
80004e42:	c0 e0       	breq	80004e5e <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN;
80004e44:	32 89       	mov	r9,40
80004e46:	48 c8       	lddpc	r8,80004e74 <fat_check_nav_access_file+0x74>
80004e48:	b0 89       	st.b	r8[0x0],r9
80004e4a:	5e fd       	retal	0
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
80004e4c:	48 98       	lddpc	r8,80004e70 <fat_check_nav_access_file+0x70>
80004e4e:	11 88       	ld.ub	r8,r8[0x0]
80004e50:	e2 18 00 02 	andl	r8,0x2,COH
80004e54:	c0 50       	breq	80004e5e <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
80004e56:	32 99       	mov	r9,41
80004e58:	48 78       	lddpc	r8,80004e74 <fat_check_nav_access_file+0x74>
80004e5a:	b0 89       	st.b	r8[0x0],r9
80004e5c:	5e fd       	retal	0
               return false;  // File opened in write mode then read access not possible
80004e5e:	5e ff       	retal	1
80004e60:	00 00       	add	r0,r0
80004e62:	0d 30       	ld.ub	r0,r6++
80004e64:	00 00       	add	r0,r0
80004e66:	0c e8       	st.h	--r6,r8
80004e68:	00 00       	add	r0,r0
80004e6a:	0d 3c       	ld.ub	r12,r6++
80004e6c:	00 00       	add	r0,r0
80004e6e:	0d 34       	ld.ub	r4,r6++
80004e70:	00 00       	add	r0,r0
80004e72:	0d 20       	ld.uh	r0,r6++
80004e74:	00 00       	add	r0,r0
80004e76:	0d 38       	ld.ub	r8,r6++

80004e78 <fat_invert_nav>:
//! This function inverts the current navigation with another
//!
//! @param     u8_idnav    Id navigator to invert
//!
void  fat_invert_nav( uint8_t u8_idnav )
{
80004e78:	d4 21       	pushm	r4-r7,lr
80004e7a:	20 dd       	sub	sp,52
   _MEM_TYPE_SLOW_ uint8_t Temp[Max(Max(sizeof(Fs_management),sizeof(Fs_management_entry)),sizeof(Fs_management_fast))];

   if( u8_idnav == 0 )
80004e7c:	58 0c       	cp.w	r12,0
80004e7e:	c5 a0       	breq	80004f32 <fat_invert_nav+0xba>
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
80004e80:	1a 97       	mov	r7,sp
80004e82:	4a e8       	lddpc	r8,80004f38 <fat_invert_nav+0xc0>
80004e84:	f0 ea 00 00 	ld.d	r10,r8[0]
80004e88:	fa eb 00 00 	st.d	sp[0],r10
80004e8c:	f0 ea 00 08 	ld.d	r10,r8[8]
80004e90:	fa eb 00 08 	st.d	sp[8],r10
80004e94:	f0 ea 00 10 	ld.d	r10,r8[16]
80004e98:	fa eb 00 10 	st.d	sp[16],r10
80004e9c:	f0 ea 00 18 	ld.d	r10,r8[24]
80004ea0:	fa eb 00 18 	st.d	sp[24],r10
80004ea4:	f0 ea 00 20 	ld.d	r10,r8[32]
80004ea8:	fa eb 00 20 	st.d	sp[32],r10
80004eac:	f0 ea 00 28 	ld.d	r10,r8[40]
80004eb0:	fa eb 00 28 	st.d	sp[40],r10
80004eb4:	70 c9       	ld.w	r9,r8[0x30]
80004eb6:	50 c9       	stdsp	sp[0x30],r9
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
80004eb8:	f8 c6 00 01 	sub	r6,r12,1
80004ebc:	5c 56       	castu.b	r6
80004ebe:	ec 04 10 34 	mul	r4,r6,52
80004ec2:	49 f9       	lddpc	r9,80004f3c <fat_invert_nav+0xc4>
80004ec4:	12 04       	add	r4,r9
80004ec6:	33 45       	mov	r5,52
80004ec8:	0a 9a       	mov	r10,r5
80004eca:	08 9b       	mov	r11,r4
80004ecc:	10 9c       	mov	r12,r8
80004ece:	f0 1f 00 1d 	mcall	80004f40 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
80004ed2:	0a 9a       	mov	r10,r5
80004ed4:	1a 9b       	mov	r11,sp
80004ed6:	08 9c       	mov	r12,r4
80004ed8:	f0 1f 00 1a 	mcall	80004f40 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
80004edc:	49 ac       	lddpc	r12,80004f44 <fat_invert_nav+0xcc>
80004ede:	f8 e8 00 00 	ld.d	r8,r12[0]
80004ee2:	fa e9 00 00 	st.d	sp[0],r8
80004ee6:	f8 e8 00 08 	ld.d	r8,r12[8]
80004eea:	fa e9 00 08 	st.d	sp[8],r8
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
80004eee:	ec 04 15 04 	lsl	r4,r6,0x4
80004ef2:	49 68       	lddpc	r8,80004f48 <fat_invert_nav+0xd0>
80004ef4:	10 04       	add	r4,r8
80004ef6:	31 05       	mov	r5,16
80004ef8:	0a 9a       	mov	r10,r5
80004efa:	08 9b       	mov	r11,r4
80004efc:	f0 1f 00 11 	mcall	80004f40 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
80004f00:	0a 9a       	mov	r10,r5
80004f02:	1a 9b       	mov	r11,sp
80004f04:	08 9c       	mov	r12,r4
80004f06:	f0 1f 00 0f 	mcall	80004f40 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
80004f0a:	49 14       	lddpc	r4,80004f4c <fat_invert_nav+0xd4>
80004f0c:	30 45       	mov	r5,4
80004f0e:	0a 9a       	mov	r10,r5
80004f10:	08 9b       	mov	r11,r4
80004f12:	1a 9c       	mov	r12,sp
80004f14:	f0 1f 00 0b 	mcall	80004f40 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
80004f18:	48 e8       	lddpc	r8,80004f50 <fat_invert_nav+0xd8>
80004f1a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004f1e:	0a 9a       	mov	r10,r5
80004f20:	0c 9b       	mov	r11,r6
80004f22:	08 9c       	mov	r12,r4
80004f24:	f0 1f 00 07 	mcall	80004f40 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
80004f28:	0a 9a       	mov	r10,r5
80004f2a:	1a 9b       	mov	r11,sp
80004f2c:	0c 9c       	mov	r12,r6
80004f2e:	f0 1f 00 05 	mcall	80004f40 <fat_invert_nav+0xc8>
}
80004f32:	2f 3d       	sub	sp,-52
80004f34:	d8 22       	popm	r4-r7,pc
80004f36:	00 00       	add	r0,r0
80004f38:	00 00       	add	r0,r0
80004f3a:	0c e8       	st.h	--r6,r8
80004f3c:	00 00       	add	r0,r0
80004f3e:	0d 3c       	ld.ub	r12,r6++
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	98 88       	ld.uh	r8,r12[0x0]
80004f44:	00 00       	add	r0,r0
80004f46:	0a a8       	st.w	r5++,r8
80004f48:	00 00       	add	r0,r0
80004f4a:	0d 20       	ld.uh	r0,r6++
80004f4c:	00 00       	add	r0,r0
80004f4e:	0d 34       	ld.ub	r4,r6++
80004f50:	00 00       	add	r0,r0
80004f52:	0d 30       	ld.ub	r0,r6++

80004f54 <fat_cache_flush>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
80004f54:	d4 01       	pushm	lr
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
80004f56:	49 08       	lddpc	r8,80004f94 <fat_cache_flush+0x40>
80004f58:	f1 39 00 08 	ld.ub	r9,r8[8]
80004f5c:	30 18       	mov	r8,1
80004f5e:	f0 09 18 00 	cp.b	r9,r8
80004f62:	c1 81       	brne	80004f92 <fat_cache_flush+0x3e>
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
80004f64:	48 c8       	lddpc	r8,80004f94 <fat_cache_flush+0x40>
80004f66:	30 09       	mov	r9,0
80004f68:	f1 69 00 08 	st.b	r8[8],r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
80004f6c:	11 8c       	ld.ub	r12,r8[0x0]
80004f6e:	f0 1f 00 0b 	mcall	80004f98 <fat_cache_flush+0x44>
80004f72:	c0 50       	breq	80004f7c <fat_cache_flush+0x28>
      {
         fs_g_status = FS_LUN_WP;
80004f74:	31 49       	mov	r9,20
80004f76:	48 a8       	lddpc	r8,80004f9c <fat_cache_flush+0x48>
80004f78:	b0 89       	st.b	r8[0x0],r9
80004f7a:	d8 0a       	popm	pc,r12=0
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
80004f7c:	48 68       	lddpc	r8,80004f94 <fat_cache_flush+0x40>
80004f7e:	48 9a       	lddpc	r10,80004fa0 <fat_cache_flush+0x4c>
80004f80:	70 1b       	ld.w	r11,r8[0x4]
80004f82:	11 8c       	ld.ub	r12,r8[0x0]
80004f84:	f0 1f 00 08 	mcall	80004fa4 <fat_cache_flush+0x50>
80004f88:	c0 50       	breq	80004f92 <fat_cache_flush+0x3e>
      {
         fs_g_status = FS_ERR_HW;
80004f8a:	30 19       	mov	r9,1
80004f8c:	48 48       	lddpc	r8,80004f9c <fat_cache_flush+0x48>
80004f8e:	b0 89       	st.b	r8[0x0],r9
80004f90:	d8 0a       	popm	pc,r12=0
         return false;
80004f92:	da 0a       	popm	pc,r12=1
80004f94:	00 00       	add	r0,r0
80004f96:	0d 70       	ld.ub	r0,--r6
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	69 4c       	ld.w	r12,r4[0x50]
80004f9c:	00 00       	add	r0,r0
80004f9e:	0d 38       	ld.ub	r8,r6++
80004fa0:	00 00       	add	r0,r0
80004fa2:	0a e8       	st.h	--r5,r8
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	68 8c       	ld.w	r12,r4[0x20]

80004fa8 <fat_cache_clear>:

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
80004fa8:	d4 01       	pushm	lr
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
80004faa:	e0 6a 02 00 	mov	r10,512
80004fae:	30 0b       	mov	r11,0
80004fb0:	48 2c       	lddpc	r12,80004fb8 <fat_cache_clear+0x10>
80004fb2:	f0 1f 00 03 	mcall	80004fbc <fat_cache_clear+0x14>
}
80004fb6:	d8 02       	popm	pc
80004fb8:	00 00       	add	r0,r0
80004fba:	0a e8       	st.h	--r5,r8
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	99 d0       	st.w	r12[0x34],r0

80004fc0 <fat_cache_read_sector>:
//!   fs_g_nav.u8_lun      drive number to read
//!   fs_gu32_addrsector   address to read (unit sector)
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
80004fc0:	eb cd 40 80 	pushm	r7,lr
80004fc4:	18 97       	mov	r7,r12
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
80004fc6:	49 78       	lddpc	r8,80005020 <fat_cache_read_sector+0x60>
80004fc8:	11 89       	ld.ub	r9,r8[0x0]
80004fca:	49 78       	lddpc	r8,80005024 <fat_cache_read_sector+0x64>
80004fcc:	11 88       	ld.ub	r8,r8[0x0]
80004fce:	f0 09 18 00 	cp.b	r9,r8
80004fd2:	c0 91       	brne	80004fe4 <fat_cache_read_sector+0x24>
80004fd4:	49 38       	lddpc	r8,80005020 <fat_cache_read_sector+0x60>
80004fd6:	70 19       	ld.w	r9,r8[0x4]
80004fd8:	49 48       	lddpc	r8,80005028 <fat_cache_read_sector+0x68>
80004fda:	70 08       	ld.w	r8,r8[0x0]
80004fdc:	10 39       	cp.w	r9,r8
80004fde:	c0 31       	brne	80004fe4 <fat_cache_read_sector+0x24>
80004fe0:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      return true;
   }

   // Write previous cache before fill cache with a new sector
   if( !fat_cache_flush())
80004fe4:	f0 1f 00 12 	mcall	8000502c <fat_cache_read_sector+0x6c>
80004fe8:	c1 90       	breq	8000501a <fat_cache_read_sector+0x5a>
      return false;

   // Delete informations about the caches
   fat_cache_reset();
80004fea:	f0 1f 00 12 	mcall	80005030 <fat_cache_read_sector+0x70>

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
80004fee:	48 f8       	lddpc	r8,80005028 <fat_cache_read_sector+0x68>
80004ff0:	70 0b       	ld.w	r11,r8[0x0]
80004ff2:	48 c8       	lddpc	r8,80005020 <fat_cache_read_sector+0x60>
80004ff4:	91 1b       	st.w	r8[0x4],r11
   if( b_load )
80004ff6:	58 07       	cp.w	r7,0
80004ff8:	c0 c0       	breq	80005010 <fat_cache_read_sector+0x50>
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
80004ffa:	48 fa       	lddpc	r10,80005034 <fat_cache_read_sector+0x74>
80004ffc:	48 a8       	lddpc	r8,80005024 <fat_cache_read_sector+0x64>
80004ffe:	11 8c       	ld.ub	r12,r8[0x0]
80005000:	f0 1f 00 0e 	mcall	80005038 <fat_cache_read_sector+0x78>
80005004:	c0 60       	breq	80005010 <fat_cache_read_sector+0x50>
      {
         fs_g_status = FS_ERR_HW;
80005006:	30 19       	mov	r9,1
80005008:	48 d8       	lddpc	r8,8000503c <fat_cache_read_sector+0x7c>
8000500a:	b0 89       	st.b	r8[0x0],r9
8000500c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
80005010:	48 58       	lddpc	r8,80005024 <fat_cache_read_sector+0x64>
80005012:	11 89       	ld.ub	r9,r8[0x0]
80005014:	48 38       	lddpc	r8,80005020 <fat_cache_read_sector+0x60>
80005016:	b0 89       	st.b	r8[0x0],r9
80005018:	30 1c       	mov	r12,1
   return true;
}
8000501a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000501e:	00 00       	add	r0,r0
80005020:	00 00       	add	r0,r0
80005022:	0d 70       	ld.ub	r0,--r6
80005024:	00 00       	add	r0,r0
80005026:	0c e8       	st.h	--r6,r8
80005028:	00 00       	add	r0,r0
8000502a:	0a a4       	st.w	r5++,r4
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	4f 54       	lddpc	r4,80005200 <fat_cluster_val+0x12c>
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	4d 88       	lddpc	r8,80005190 <fat_cluster_val+0xbc>
80005034:	00 00       	add	r0,r0
80005036:	0a e8       	st.h	--r5,r8
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	68 ec       	ld.w	r12,r4[0x38]
8000503c:	00 00       	add	r0,r0
8000503e:	0d 38       	ld.ub	r8,r6++

80005040 <fat_cluster_readnext>:
//!   fs_g_u16_pos_fat        read cluster position in FAT
//!   fs_g_cluster.u32_val    value of cluster read
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
80005040:	d4 01       	pushm	lr
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
80005042:	49 f8       	lddpc	r8,800050bc <fat_cluster_readnext+0x7c>
80005044:	11 89       	ld.ub	r9,r8[0x0]
80005046:	30 38       	mov	r8,3
80005048:	f0 09 18 00 	cp.b	r9,r8
8000504c:	c0 61       	brne	80005058 <fat_cluster_readnext+0x18>
   {
      fs_g_u16_pos_fat += 4;
8000504e:	49 d8       	lddpc	r8,800050c0 <fat_cluster_readnext+0x80>
80005050:	90 09       	ld.sh	r9,r8[0x0]
80005052:	2f c9       	sub	r9,-4
80005054:	b0 09       	st.h	r8[0x0],r9
80005056:	c0 58       	rjmp	80005060 <fat_cluster_readnext+0x20>
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
80005058:	49 a8       	lddpc	r8,800050c0 <fat_cluster_readnext+0x80>
8000505a:	90 09       	ld.sh	r9,r8[0x0]
8000505c:	2f e9       	sub	r9,-2
8000505e:	b0 09       	st.h	r8[0x0],r9
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
80005060:	49 88       	lddpc	r8,800050c0 <fat_cluster_readnext+0x80>
80005062:	90 09       	ld.sh	r9,r8[0x0]
80005064:	e0 68 02 00 	mov	r8,512
80005068:	f0 09 19 00 	cp.h	r9,r8
8000506c:	c0 c1       	brne	80005084 <fat_cluster_readnext+0x44>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000506e:	30 09       	mov	r9,0
80005070:	49 48       	lddpc	r8,800050c0 <fat_cluster_readnext+0x80>
80005072:	b0 09       	st.h	r8[0x0],r9
      fs_gu32_addrsector++;
80005074:	49 48       	lddpc	r8,800050c4 <fat_cluster_readnext+0x84>
80005076:	70 09       	ld.w	r9,r8[0x0]
80005078:	2f f9       	sub	r9,-1
8000507a:	91 09       	st.w	r8[0x0],r9
      if( !fat_cache_read_sector( true ))
8000507c:	30 1c       	mov	r12,1
8000507e:	f0 1f 00 13 	mcall	800050c8 <fat_cluster_readnext+0x88>
80005082:	c1 b0       	breq	800050b8 <fat_cluster_readnext+0x78>
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
80005084:	49 28       	lddpc	r8,800050cc <fat_cluster_readnext+0x8c>
80005086:	2f c8       	sub	r8,-4
80005088:	48 e9       	lddpc	r9,800050c0 <fat_cluster_readnext+0x80>
8000508a:	92 89       	ld.uh	r9,r9[0x0]
8000508c:	49 1a       	lddpc	r10,800050d0 <fat_cluster_readnext+0x90>
8000508e:	f4 09 07 0b 	ld.ub	r11,r10[r9]
80005092:	b0 bb       	st.b	r8[0x3],r11
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
80005094:	12 0a       	add	r10,r9
80005096:	15 9a       	ld.ub	r10,r10[0x1]
80005098:	b0 aa       	st.b	r8[0x2],r10

   if ( Is_fat32 )
8000509a:	48 9a       	lddpc	r10,800050bc <fat_cluster_readnext+0x7c>
8000509c:	15 8b       	ld.ub	r11,r10[0x0]
8000509e:	30 3a       	mov	r10,3
800050a0:	f4 0b 18 00 	cp.b	r11,r10
800050a4:	c0 20       	breq	800050a8 <fat_cluster_readnext+0x68>
800050a6:	da 0a       	popm	pc,r12=1
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
800050a8:	48 aa       	lddpc	r10,800050d0 <fat_cluster_readnext+0x90>
800050aa:	f4 09 00 09 	add	r9,r10,r9
800050ae:	13 aa       	ld.ub	r10,r9[0x2]
800050b0:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
800050b2:	13 b9       	ld.ub	r9,r9[0x3]
800050b4:	b0 89       	st.b	r8[0x0],r9
800050b6:	30 1c       	mov	r12,1
   }
   return true;
}
800050b8:	d8 02       	popm	pc
800050ba:	00 00       	add	r0,r0
800050bc:	00 00       	add	r0,r0
800050be:	0d 34       	ld.ub	r4,r6++
800050c0:	00 00       	add	r0,r0
800050c2:	0a b8       	st.h	r5++,r8
800050c4:	00 00       	add	r0,r0
800050c6:	0a a4       	st.w	r5++,r4
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	4f c0       	lddpc	r0,800052b8 <fat_cluster_val+0x1e4>
800050cc:	00 00       	add	r0,r0
800050ce:	0d 88       	ld.ub	r8,r6[0x0]
800050d0:	00 00       	add	r0,r0
800050d2:	0a e8       	st.h	--r5,r8

800050d4 <fat_cluster_val>:
//!   fs_g_u16_pos_fat        position in FAT of the cluster to read or write
//!                           value init in case of the fat_cluster_readnext() routine is used after
//! @endverbatim
//!
bool  fat_cluster_val( bool b_mode )
{
800050d4:	d4 31       	pushm	r0-r7,lr
800050d6:	18 95       	mov	r5,r12
   _MEM_TYPE_FAST_ uint32_t   u32_offset_fat =0;
   _MEM_TYPE_FAST_ uint8_t    u8_data1, u8_data2,u8_data3,u8_data4;
   _MEM_TYPE_FAST_ PTR_CACHE u8_ptr_cluster;

   //**** Compute the cluster position in FAT (sector address & position in sector)
   if ( Is_fat32 )
800050d8:	fe f8 02 18 	ld.w	r8,pc[536]
800050dc:	11 88       	ld.ub	r8,r8[0x0]
800050de:	30 39       	mov	r9,3
800050e0:	f2 08 18 00 	cp.b	r8,r9
800050e4:	c0 d1       	brne	800050fe <fat_cluster_val+0x2a>
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
800050e6:	fe fa 02 0e 	ld.w	r10,pc[526]
800050ea:	74 09       	ld.w	r9,r10[0x0]
800050ec:	a7 99       	lsr	r9,0x7

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
800050ee:	15 bb       	ld.ub	r11,r10[0x3]
800050f0:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800050f4:	a3 6b       	lsl	r11,0x2
800050f6:	fe fa 02 02 	ld.w	r10,pc[514]
800050fa:	b4 0b       	st.h	r10[0x0],r11
800050fc:	c2 08       	rjmp	8000513c <fat_cluster_val+0x68>
   }
   else if ( Is_fat16 )
800050fe:	30 29       	mov	r9,2
80005100:	f2 08 18 00 	cp.b	r8,r9
80005104:	c0 81       	brne	80005114 <fat_cluster_val+0x40>
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
80005106:	4f ca       	lddpc	r10,800052f4 <fat_cluster_val+0x220>
80005108:	15 a9       	ld.ub	r9,r10[0x2]
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
8000510a:	15 bb       	ld.ub	r11,r10[0x3]
8000510c:	a1 7b       	lsl	r11,0x1
8000510e:	4f ba       	lddpc	r10,800052f8 <fat_cluster_val+0x224>
80005110:	b4 0b       	st.h	r10[0x0],r11
80005112:	c1 58       	rjmp	8000513c <fat_cluster_val+0x68>
   }
   else if ( Is_fat12 )
80005114:	30 19       	mov	r9,1
80005116:	f2 08 18 00 	cp.b	r8,r9
8000511a:	c0 30       	breq	80005120 <fat_cluster_val+0x4c>
8000511c:	30 09       	mov	r9,0
8000511e:	c0 f8       	rjmp	8000513c <fat_cluster_val+0x68>
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
80005120:	4f 59       	lddpc	r9,800052f4 <fat_cluster_val+0x220>
80005122:	72 09       	ld.w	r9,r9[0x0]
80005124:	4f 5a       	lddpc	r10,800052f8 <fat_cluster_val+0x224>
80005126:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
8000512a:	12 0b       	add	r11,r9
8000512c:	b4 0b       	st.h	r10[0x0],r11
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
8000512e:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
80005132:	f6 09 16 01 	lsr	r9,r11,0x1
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
80005136:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
8000513a:	b4 8b       	st.b	r10[0x0],r11
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
8000513c:	58 05       	cp.w	r5,0
8000513e:	c2 20       	breq	80005182 <fat_cluster_val+0xae>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
80005140:	4e fa       	lddpc	r10,800052fc <fat_cluster_val+0x228>
80005142:	74 0a       	ld.w	r10,r10[0x0]
80005144:	14 39       	cp.w	r9,r10
80005146:	c0 32       	brcc	8000514c <fat_cluster_val+0x78>
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
80005148:	4e da       	lddpc	r10,800052fc <fat_cluster_val+0x228>
8000514a:	95 09       	st.w	r10[0x0],r9
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
8000514c:	4e da       	lddpc	r10,80005300 <fat_cluster_val+0x22c>
8000514e:	74 0a       	ld.w	r10,r10[0x0]
80005150:	14 39       	cp.w	r9,r10
80005152:	e0 88 00 04 	brls	8000515a <fat_cluster_val+0x86>
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
80005156:	4e ba       	lddpc	r10,80005300 <fat_cluster_val+0x22c>
80005158:	95 09       	st.w	r10[0x0],r9
      }
      if ( Is_fat12 )
8000515a:	30 1a       	mov	r10,1
8000515c:	f4 08 18 00 	cp.b	r8,r10
80005160:	c1 11       	brne	80005182 <fat_cluster_val+0xae>
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80005162:	4e 68       	lddpc	r8,800052f8 <fat_cluster_val+0x224>
80005164:	90 0a       	ld.sh	r10,r8[0x0]
80005166:	e0 68 01 ff 	mov	r8,511
8000516a:	f0 0a 19 00 	cp.h	r10,r8
8000516e:	c0 a1       	brne	80005182 <fat_cluster_val+0xae>
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
80005170:	f2 c8 ff ff 	sub	r8,r9,-1
80005174:	4e 3a       	lddpc	r10,80005300 <fat_cluster_val+0x22c>
80005176:	74 0a       	ld.w	r10,r10[0x0]
80005178:	14 38       	cp.w	r8,r10
8000517a:	e0 88 00 04 	brls	80005182 <fat_cluster_val+0xae>
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
8000517e:	4e 1a       	lddpc	r10,80005300 <fat_cluster_val+0x22c>
80005180:	95 08       	st.w	r10[0x0],r8
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
80005182:	4e 18       	lddpc	r8,80005304 <fat_cluster_val+0x230>
80005184:	70 48       	ld.w	r8,r8[0x10]
80005186:	10 09       	add	r9,r8
80005188:	4e 08       	lddpc	r8,80005308 <fat_cluster_val+0x234>
8000518a:	91 09       	st.w	r8[0x0],r9
   if( !fat_cache_read_sector( true ))
8000518c:	30 1c       	mov	r12,1
8000518e:	f0 1f 00 60 	mcall	8000530c <fat_cluster_val+0x238>
80005192:	e0 80 00 ad 	breq	800052ec <fat_cluster_val+0x218>
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
80005196:	4d 98       	lddpc	r8,800052f8 <fat_cluster_val+0x224>
80005198:	90 08       	ld.sh	r8,r8[0x0]
8000519a:	ed d8 c0 10 	bfextu	r6,r8,0x0,0x10
8000519e:	4d d9       	lddpc	r9,80005310 <fat_cluster_val+0x23c>
800051a0:	12 06       	add	r6,r9
   u8_data1 = u8_ptr_cluster[0];
800051a2:	0c 97       	mov	r7,r6
800051a4:	0f 32       	ld.ub	r2,r7++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
800051a6:	0f 8b       	ld.ub	r11,r7[0x0]
   u8_data3 = u8_ptr_cluster[2];
800051a8:	ec c4 ff fe 	sub	r4,r6,-2
800051ac:	09 81       	ld.ub	r1,r4[0x0]
   u8_data4 = u8_ptr_cluster[3];
800051ae:	ec c3 ff fd 	sub	r3,r6,-3
800051b2:	07 80       	ld.ub	r0,r3[0x0]

   if ( Is_fat12 )
800051b4:	4c f9       	lddpc	r9,800052f0 <fat_cluster_val+0x21c>
800051b6:	13 8a       	ld.ub	r10,r9[0x0]
800051b8:	30 19       	mov	r9,1
800051ba:	f2 0a 18 00 	cp.b	r10,r9
800051be:	c1 11       	brne	800051e0 <fat_cluster_val+0x10c>
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
800051c0:	e0 69 01 ff 	mov	r9,511
800051c4:	f2 08 19 00 	cp.h	r8,r9
800051c8:	c0 c1       	brne	800051e0 <fat_cluster_val+0x10c>
      {  // Go to next sector
         fs_gu32_addrsector++;
800051ca:	4d 08       	lddpc	r8,80005308 <fat_cluster_val+0x234>
800051cc:	70 09       	ld.w	r9,r8[0x0]
800051ce:	2f f9       	sub	r9,-1
800051d0:	91 09       	st.w	r8[0x0],r9
         if( !fat_cache_read_sector( true ))
800051d2:	30 1c       	mov	r12,1
800051d4:	f0 1f 00 4e 	mcall	8000530c <fat_cluster_val+0x238>
800051d8:	e0 80 00 8a 	breq	800052ec <fat_cluster_val+0x218>
           return false;
         u8_data2 = fs_g_sector[0];
800051dc:	4c d8       	lddpc	r8,80005310 <fat_cluster_val+0x23c>
800051de:	11 8b       	ld.ub	r11,r8[0x0]
      }
   }

   if (false == b_mode)
800051e0:	58 05       	cp.w	r5,0
800051e2:	c3 11       	brne	80005244 <fat_cluster_val+0x170>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
800051e4:	4c 48       	lddpc	r8,800052f4 <fat_cluster_val+0x220>
800051e6:	f0 c9 ff fc 	sub	r9,r8,-4
800051ea:	f0 cc ff f9 	sub	r12,r8,-7
800051ee:	b8 82       	st.b	r12[0x0],r2
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
800051f0:	2f a8       	sub	r8,-6
800051f2:	b0 8b       	st.b	r8[0x0],r11

      if ( Is_fat32 )
800051f4:	4b fa       	lddpc	r10,800052f0 <fat_cluster_val+0x21c>
800051f6:	15 8a       	ld.ub	r10,r10[0x0]
800051f8:	30 3b       	mov	r11,3
800051fa:	f6 0a 18 00 	cp.b	r10,r11
800051fe:	c0 61       	brne	8000520a <fat_cluster_val+0x136>
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
80005200:	b2 91       	st.b	r9[0x1],r1
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
80005202:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80005206:	b2 80       	st.b	r9[0x0],r0
80005208:	da 3a       	popm	r0-r7,pc,r12=1
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
8000520a:	30 0b       	mov	r11,0
8000520c:	b2 9b       	st.b	r9[0x1],r11
         LSB3( fs_g_cluster.u32_val ) = 0;
8000520e:	b2 8b       	st.b	r9[0x0],r11

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
80005210:	30 19       	mov	r9,1
80005212:	f2 0a 18 00 	cp.b	r10,r9
80005216:	c0 20       	breq	8000521a <fat_cluster_val+0x146>
80005218:	da 3a       	popm	r0-r7,pc,r12=1
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
8000521a:	4b 79       	lddpc	r9,800052f4 <fat_cluster_val+0x220>
8000521c:	13 b9       	ld.ub	r9,r9[0x3]
8000521e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005222:	c0 c0       	breq	8000523a <fat_cluster_val+0x166>
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
80005224:	19 8b       	ld.ub	r11,r12[0x0]
80005226:	a5 8b       	lsr	r11,0x4
80005228:	11 89       	ld.ub	r9,r8[0x0]
8000522a:	f2 0a 15 04 	lsl	r10,r9,0x4
8000522e:	f6 0a 00 0a 	add	r10,r11,r10
80005232:	b8 8a       	st.b	r12[0x0],r10
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
80005234:	a5 89       	lsr	r9,0x4
80005236:	b0 89       	st.b	r8[0x0],r9
80005238:	da 3a       	popm	r0-r7,pc,r12=1
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
8000523a:	11 89       	ld.ub	r9,r8[0x0]
8000523c:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80005240:	b0 89       	st.b	r8[0x0],r9
80005242:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
80005244:	4a b8       	lddpc	r8,800052f0 <fat_cluster_val+0x21c>
80005246:	11 88       	ld.ub	r8,r8[0x0]
80005248:	30 19       	mov	r9,1
8000524a:	f2 08 18 00 	cp.b	r8,r9
8000524e:	c3 a1       	brne	800052c2 <fat_cluster_val+0x1ee>
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80005250:	4a 98       	lddpc	r8,800052f4 <fat_cluster_val+0x220>
80005252:	11 b8       	ld.ub	r8,r8[0x3]
80005254:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005258:	c1 10       	breq	8000527a <fat_cluster_val+0x1a6>
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000525a:	eb d2 c0 04 	bfextu	r5,r2,0x0,0x4
8000525e:	4a 68       	lddpc	r8,800052f4 <fat_cluster_val+0x220>
80005260:	2f c8       	sub	r8,-4
80005262:	11 b9       	ld.ub	r9,r8[0x3]
80005264:	f2 0a 15 04 	lsl	r10,r9,0x4
80005268:	14 05       	add	r5,r10
8000526a:	5c 55       	castu.b	r5
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
8000526c:	a5 89       	lsr	r9,0x4
8000526e:	11 a8       	ld.ub	r8,r8[0x2]
80005270:	a5 68       	lsl	r8,0x4
80005272:	f2 08 00 0a 	add	r10,r9,r8
80005276:	5c 5a       	castu.b	r10
80005278:	c0 c8       	rjmp	80005290 <fat_cluster_val+0x1bc>
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
8000527a:	49 f8       	lddpc	r8,800052f4 <fat_cluster_val+0x220>
8000527c:	2f c8       	sub	r8,-4
8000527e:	11 b5       	ld.ub	r5,r8[0x3]
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
80005280:	16 9a       	mov	r10,r11
80005282:	e2 1a 00 f0 	andl	r10,0xf0,COH
80005286:	11 a8       	ld.ub	r8,r8[0x2]
80005288:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000528c:	10 0a       	add	r10,r8
8000528e:	5c 5a       	castu.b	r10
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80005290:	49 a8       	lddpc	r8,800052f8 <fat_cluster_val+0x224>
80005292:	90 09       	ld.sh	r9,r8[0x0]
80005294:	e0 68 01 ff 	mov	r8,511
80005298:	f0 09 19 00 	cp.h	r9,r8
8000529c:	c2 31       	brne	800052e2 <fat_cluster_val+0x20e>
         {
            fs_g_sector[0] = u8_data2;
8000529e:	49 d8       	lddpc	r8,80005310 <fat_cluster_val+0x23c>
800052a0:	b0 8a       	st.b	r8[0x0],r10
            fat_cache_mark_sector_as_dirty();
800052a2:	f0 1f 00 1d 	mcall	80005314 <fat_cluster_val+0x240>
            // Go to previous sector
            fs_gu32_addrsector--;
800052a6:	49 98       	lddpc	r8,80005308 <fat_cluster_val+0x234>
800052a8:	70 09       	ld.w	r9,r8[0x0]
800052aa:	20 19       	sub	r9,1
800052ac:	91 09       	st.w	r8[0x0],r9
            if( !fat_cache_read_sector( true ))
800052ae:	30 1c       	mov	r12,1
800052b0:	f0 1f 00 17 	mcall	8000530c <fat_cluster_val+0x238>
800052b4:	c1 c0       	breq	800052ec <fat_cluster_val+0x218>
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
800052b6:	49 78       	lddpc	r8,80005310 <fat_cluster_val+0x23c>
800052b8:	f1 65 01 ff 	st.b	r8[511],r5
            fat_cache_mark_sector_as_dirty();
800052bc:	f0 1f 00 16 	mcall	80005314 <fat_cluster_val+0x240>
800052c0:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
800052c2:	48 d9       	lddpc	r9,800052f4 <fat_cluster_val+0x220>
800052c4:	2f c9       	sub	r9,-4
800052c6:	13 b5       	ld.ub	r5,r9[0x3]
         u8_data2 = LSB1( fs_g_cluster.u32_val );
800052c8:	13 aa       	ld.ub	r10,r9[0x2]
         if ( Is_fat32 )
800052ca:	30 3b       	mov	r11,3
800052cc:	f6 08 18 00 	cp.b	r8,r11
800052d0:	c0 91       	brne	800052e2 <fat_cluster_val+0x20e>
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
800052d2:	13 98       	ld.ub	r8,r9[0x1]
800052d4:	a8 88       	st.b	r4[0x0],r8
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
800052d6:	e0 10 ff f0 	andl	r0,0xfff0
800052da:	13 88       	ld.ub	r8,r9[0x0]
800052dc:	f0 00 00 00 	add	r0,r8,r0
800052e0:	a6 80       	st.b	r3[0x0],r0
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
800052e2:	ac 85       	st.b	r6[0x0],r5
      u8_ptr_cluster[1] = u8_data2;
800052e4:	ae 8a       	st.b	r7[0x0],r10
      fat_cache_mark_sector_as_dirty();
800052e6:	f0 1f 00 0c 	mcall	80005314 <fat_cluster_val+0x240>
800052ea:	da 3a       	popm	r0-r7,pc,r12=1
800052ec:	d8 3a       	popm	r0-r7,pc,r12=0
800052ee:	00 00       	add	r0,r0
800052f0:	00 00       	add	r0,r0
800052f2:	0d 34       	ld.ub	r4,r6++
800052f4:	00 00       	add	r0,r0
800052f6:	0d 88       	ld.ub	r8,r6[0x0]
800052f8:	00 00       	add	r0,r0
800052fa:	0a b8       	st.h	r5++,r8
800052fc:	00 00       	add	r0,r0
800052fe:	0d 1c       	ld.sh	r12,r6++
80005300:	00 00       	add	r0,r0
80005302:	0a e4       	st.h	--r5,r4
80005304:	00 00       	add	r0,r0
80005306:	0c e8       	st.h	--r6,r8
80005308:	00 00       	add	r0,r0
8000530a:	0a a4       	st.w	r5++,r4
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	4f c0       	lddpc	r0,800054fc <fat_cluster_list+0x1e4>
80005310:	00 00       	add	r0,r0
80005312:	0a e8       	st.h	--r5,r8
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	4d a0       	lddpc	r0,8000547c <fat_cluster_list+0x164>

80005318 <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
80005318:	d4 31       	pushm	r0-r7,lr
8000531a:	20 2d       	sub	sp,8
8000531c:	18 93       	mov	r3,r12
8000531e:	16 97       	mov	r7,r11
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
80005320:	30 89       	mov	r9,8
80005322:	fe f8 02 8e 	ld.w	r8,pc[654]
80005326:	b0 89       	st.b	r8[0x0],r9

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
80005328:	30 38       	mov	r8,3
8000532a:	f0 0c 18 00 	cp.b	r12,r8
8000532e:	5f 0a       	sreq	r10
80005330:	50 0a       	stdsp	sp[0x0],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
80005332:	fe f9 02 82 	ld.w	r9,pc[642]
80005336:	13 89       	ld.ub	r9,r9[0x0]
80005338:	f0 09 18 00 	cp.b	r9,r8
8000533c:	5f 08       	sreq	r8
8000533e:	f5 e8 00 08 	and	r8,r10,r8
80005342:	c0 60       	breq	8000534e <fat_cluster_list+0x36>
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80005344:	3f fc       	mov	r12,-1
80005346:	f0 1f 00 9d 	mcall	800055b8 <fat_cluster_list+0x2a0>
8000534a:	e0 80 01 2f 	breq	800055a8 <fat_cluster_list+0x290>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
8000534e:	fe f8 02 6e 	ld.w	r8,pc[622]
80005352:	70 08       	ld.w	r8,r8[0x0]
80005354:	58 08       	cp.w	r8,0
80005356:	c3 b1       	brne	800053cc <fat_cluster_list+0xb4>
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
80005358:	40 09       	lddsp	r9,sp[0x0]
8000535a:	58 09       	cp.w	r9,0
8000535c:	e0 81 01 26 	brne	800055a8 <fat_cluster_list+0x290>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
80005360:	fe f8 02 54 	ld.w	r8,pc[596]
80005364:	11 88       	ld.ub	r8,r8[0x0]
80005366:	f0 ca 00 01 	sub	r10,r8,1
8000536a:	30 19       	mov	r9,1
8000536c:	f2 0a 18 00 	cp.b	r10,r9
80005370:	e0 8b 00 23 	brhi	800053b6 <fat_cluster_list+0x9e>
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
80005374:	fe f8 02 48 	ld.w	r8,pc[584]
80005378:	70 18       	ld.w	r8,r8[0x4]
8000537a:	fe f9 02 46 	ld.w	r9,pc[582]
8000537e:	f3 19 00 1a 	ld.uh	r9,r9[26]
80005382:	12 38       	cp.w	r8,r9
80005384:	c1 32       	brcc	800053aa <fat_cluster_list+0x92>
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
80005386:	fe f9 02 36 	ld.w	r9,pc[566]
8000538a:	fe fa 02 36 	ld.w	r10,pc[566]
8000538e:	74 4b       	ld.w	r11,r10[0x10]
80005390:	16 08       	add	r8,r11
80005392:	f5 1b 00 18 	ld.uh	r11,r10[24]
80005396:	16 08       	add	r8,r11
80005398:	93 08       	st.w	r9[0x0],r8
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
8000539a:	f5 1a 00 1a 	ld.uh	r10,r10[26]
8000539e:	72 18       	ld.w	r8,r9[0x4]
800053a0:	f4 08 01 08 	sub	r8,r10,r8
800053a4:	93 18       	st.w	r9[0x4],r8
800053a6:	30 1c       	mov	r12,1
            return true;
800053a8:	c0 19       	rjmp	800055aa <fat_cluster_list+0x292>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
800053aa:	31 a9       	mov	r9,26
800053ac:	fe f8 02 04 	ld.w	r8,pc[516]
800053b0:	b0 89       	st.b	r8[0x0],r9
800053b2:	30 0c       	mov	r12,0
            return false;        // Position outside the root area
800053b4:	cf b8       	rjmp	800055aa <fat_cluster_list+0x292>
         }
      }
      if ( Is_fat32 )
800053b6:	30 39       	mov	r9,3
800053b8:	f2 08 18 00 	cp.b	r8,r9
800053bc:	c0 a1       	brne	800053d0 <fat_cluster_list+0xb8>
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
800053be:	fe f8 02 02 	ld.w	r8,pc[514]
800053c2:	70 69       	ld.w	r9,r8[0x18]
800053c4:	fe f8 02 00 	ld.w	r8,pc[512]
800053c8:	91 09       	st.w	r8[0x0],r9
800053ca:	c0 38       	rjmp	800053d0 <fat_cluster_list+0xb8>
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
800053cc:	4f e9       	lddpc	r9,800055c4 <fat_cluster_list+0x2ac>
800053ce:	93 08       	st.w	r9[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
800053d0:	30 38       	mov	r8,3
800053d2:	f0 03 18 00 	cp.b	r3,r8
800053d6:	c0 70       	breq	800053e4 <fat_cluster_list+0xcc>
   {
      if( fat_cache_clusterlist_update_read( b_for_file ) )
800053d8:	0e 9c       	mov	r12,r7
800053da:	f0 1f 00 7c 	mcall	800055c8 <fat_cluster_list+0x2b0>
800053de:	c0 70       	breq	800053ec <fat_cluster_list+0xd4>
800053e0:	30 1c       	mov	r12,1
800053e2:	ce 48       	rjmp	800055aa <fat_cluster_list+0x292>
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
800053e4:	f0 1f 00 7a 	mcall	800055cc <fat_cluster_list+0x2b4>
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
800053e8:	f0 1f 00 7a 	mcall	800055d0 <fat_cluster_list+0x2b8>
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
800053ec:	4f 40       	lddpc	r0,800055bc <fat_cluster_list+0x2a4>
800053ee:	3f f8       	mov	r8,-1
800053f0:	a0 88       	st.b	r0[0x0],r8

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
800053f2:	00 96       	mov	r6,r0
800053f4:	4f 35       	lddpc	r5,800055c0 <fat_cluster_list+0x2a8>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
800053f6:	4f 47       	lddpc	r7,800055c4 <fat_cluster_list+0x2ac>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
800053f8:	30 21       	mov	r1,2
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
800053fa:	e0 c8 ff f9 	sub	r8,r0,-7
800053fe:	50 18       	stdsp	sp[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80005400:	30 12       	mov	r2,1
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80005402:	6c 19       	ld.w	r9,r6[0x4]
80005404:	0b 98       	ld.ub	r8,r5[0x1]
80005406:	10 39       	cp.w	r9,r8
80005408:	c4 32       	brcc	8000548e <fat_cluster_list+0x176>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000540a:	6a 4a       	ld.w	r10,r5[0x10]
8000540c:	14 09       	add	r9,r10
8000540e:	6a 5a       	ld.w	r10,r5[0x14]
80005410:	14 09       	add	r9,r10
80005412:	6e 0a       	ld.w	r10,r7[0x0]
80005414:	20 2a       	sub	r10,2
80005416:	f4 08 02 48 	mul	r8,r10,r8
8000541a:	f2 08 00 08 	add	r8,r9,r8
8000541e:	8d 08       	st.w	r6[0x0],r8
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
80005420:	e2 03 18 00 	cp.b	r3,r1
80005424:	c0 d1       	brne	8000543e <fat_cluster_list+0x126>
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
80005426:	4e 67       	lddpc	r7,800055bc <fat_cluster_list+0x2a4>
80005428:	4e 68       	lddpc	r8,800055c0 <fat_cluster_list+0x2a8>
8000542a:	11 99       	ld.ub	r9,r8[0x1]
8000542c:	6e 18       	ld.w	r8,r7[0x4]
8000542e:	f2 08 01 08 	sub	r8,r9,r8
80005432:	8f 18       	st.w	r7[0x4],r8
            fat_cache_clusterlist_update_finish();
80005434:	f0 1f 00 68 	mcall	800055d4 <fat_cluster_list+0x2bc>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
80005438:	30 1c       	mov	r12,1
8000543a:	8f 1c       	st.w	r7[0x4],r12
            return true;
8000543c:	cb 78       	rjmp	800055aa <fat_cluster_list+0x292>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
8000543e:	0b 99       	ld.ub	r9,r5[0x1]
80005440:	40 1a       	lddsp	r10,sp[0x4]
80005442:	15 88       	ld.ub	r8,r10[0x0]
80005444:	f2 08 01 08 	sub	r8,r9,r8
80005448:	8d 18       	st.w	r6[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
8000544a:	e4 03 18 00 	cp.b	r3,r2
8000544e:	c2 01       	brne	8000548e <fat_cluster_list+0x176>
80005450:	4d 99       	lddpc	r9,800055b4 <fat_cluster_list+0x29c>
80005452:	13 88       	ld.ub	r8,r9[0x0]
80005454:	e4 08 18 00 	cp.b	r8,r2
80005458:	c1 b0       	breq	8000548e <fat_cluster_list+0x176>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
8000545a:	6e 04       	ld.w	r4,r7[0x0]
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
8000545c:	30 0c       	mov	r12,0
8000545e:	f0 1f 00 5f 	mcall	800055d8 <fat_cluster_list+0x2c0>
80005462:	e0 80 00 a3 	breq	800055a8 <fat_cluster_list+0x290>
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
80005466:	6e 09       	ld.w	r9,r7[0x0]
80005468:	f2 c8 ff ff 	sub	r8,r9,-1
8000546c:	8f 08       	st.w	r7[0x0],r8
8000546e:	6e 1a       	ld.w	r10,r7[0x4]
80005470:	14 38       	cp.w	r8,r10
80005472:	c0 a0       	breq	80005486 <fat_cluster_list+0x16e>
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
80005474:	8f 09       	st.w	r7[0x0],r9
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
80005476:	08 19       	sub	r9,r4
80005478:	0b 98       	ld.ub	r8,r5[0x1]
8000547a:	b1 39       	mul	r9,r8
8000547c:	6c 18       	ld.w	r8,r6[0x4]
8000547e:	f2 08 00 08 	add	r8,r9,r8
80005482:	8d 18       	st.w	r6[0x4],r8
                  break;
80005484:	c0 58       	rjmp	8000548e <fat_cluster_list+0x176>
               }
               if( !fat_cluster_readnext() )
80005486:	f0 1f 00 56 	mcall	800055dc <fat_cluster_list+0x2c4>
8000548a:	ce e1       	brne	80005466 <fat_cluster_list+0x14e>
8000548c:	c8 e8       	rjmp	800055a8 <fat_cluster_list+0x290>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
8000548e:	30 0c       	mov	r12,0
80005490:	f0 1f 00 52 	mcall	800055d8 <fat_cluster_list+0x2c0>
80005494:	e0 80 00 8a 	breq	800055a8 <fat_cluster_list+0x290>
         return false;

      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
80005498:	f0 1f 00 52 	mcall	800055e0 <fat_cluster_list+0x2c8>
8000549c:	18 94       	mov	r4,r12
      if (FS_CLUS_BAD == u8_cluster_status)
8000549e:	e4 0c 18 00 	cp.b	r12,r2
800054a2:	e0 80 00 83 	breq	800055a8 <fat_cluster_list+0x290>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
800054a6:	01 89       	ld.ub	r9,r0[0x0]
800054a8:	3f f8       	mov	r8,-1
800054aa:	f0 09 18 00 	cp.b	r9,r8
800054ae:	c4 61       	brne	8000553a <fat_cluster_list+0x222>
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
800054b0:	e2 0c 18 00 	cp.b	r12,r1
800054b4:	c2 b1       	brne	8000550a <fat_cluster_list+0x1f2>
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining
800054b6:	4c 28       	lddpc	r8,800055bc <fat_cluster_list+0x2a4>
800054b8:	70 17       	ld.w	r7,r8[0x4]

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
800054ba:	4c b9       	lddpc	r9,800055e4 <fat_cluster_list+0x2cc>
800054bc:	13 89       	ld.ub	r9,r9[0x0]
800054be:	f2 09 00 29 	add	r9,r9,r9<<0x2
800054c2:	4c aa       	lddpc	r10,800055e8 <fat_cluster_list+0x2d0>
800054c4:	f4 09 00 29 	add	r9,r10,r9<<0x2
800054c8:	72 2a       	ld.w	r10,r9[0x8]
800054ca:	0e 1a       	sub	r10,r7
800054cc:	93 2a       	st.w	r9[0x8],r10
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
800054ce:	4b d9       	lddpc	r9,800055c0 <fat_cluster_list+0x2a8>
800054d0:	72 5b       	ld.w	r11,r9[0x14]
800054d2:	72 4a       	ld.w	r10,r9[0x10]
800054d4:	14 0b       	add	r11,r10
800054d6:	13 99       	ld.ub	r9,r9[0x1]
800054d8:	4b ba       	lddpc	r10,800055c4 <fat_cluster_list+0x2ac>
800054da:	74 0a       	ld.w	r10,r10[0x0]
800054dc:	20 2a       	sub	r10,2
800054de:	f2 0a 02 4a 	mul	r10,r9,r10
800054e2:	f6 0a 00 0a 	add	r10,r11,r10
800054e6:	91 0a       	st.w	r8[0x0],r10
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
800054e8:	91 19       	st.w	r8[0x4],r9
            if (FS_CLUST_ACT_CLR != opt_action)
800054ea:	30 38       	mov	r8,3
800054ec:	f0 03 18 00 	cp.b	r3,r8
800054f0:	c0 30       	breq	800054f6 <fat_cluster_list+0x1de>
               fat_cache_clusterlist_update_finish();
800054f2:	f0 1f 00 39 	mcall	800055d4 <fat_cluster_list+0x2bc>

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
800054f6:	4b 28       	lddpc	r8,800055bc <fat_cluster_list+0x2a4>
800054f8:	4b 39       	lddpc	r9,800055c4 <fat_cluster_list+0x2ac>
800054fa:	72 09       	ld.w	r9,r9[0x0]
800054fc:	91 09       	st.w	r8[0x0],r9
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
800054fe:	91 17       	st.w	r8[0x4],r7
            fs_g_status = FS_ERR_OUT_LIST;
80005500:	31 a9       	mov	r9,26
80005502:	4a c8       	lddpc	r8,800055b0 <fat_cluster_list+0x298>
80005504:	b0 89       	st.b	r8[0x0],r9
80005506:	30 0c       	mov	r12,0
            return false;
80005508:	c5 18       	rjmp	800055aa <fat_cluster_list+0x292>
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
8000550a:	0b 98       	ld.ub	r8,r5[0x1]
8000550c:	6c 19       	ld.w	r9,r6[0x4]
8000550e:	f2 08 01 08 	sub	r8,r9,r8
80005512:	8d 18       	st.w	r6[0x4],r8
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80005514:	40 0a       	lddsp	r10,sp[0x0]
80005516:	58 0a       	cp.w	r10,0
80005518:	c4 50       	breq	800055a2 <fat_cluster_list+0x28a>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
8000551a:	58 08       	cp.w	r8,0
8000551c:	c4 31       	brne	800055a2 <fat_cluster_list+0x28a>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
8000551e:	6e 18       	ld.w	r8,r7[0x4]
80005520:	8d 08       	st.w	r6[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
80005522:	e0 68 ff ff 	mov	r8,65535
80005526:	ea 18 0f ff 	orh	r8,0xfff
8000552a:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
8000552c:	30 1c       	mov	r12,1
8000552e:	f0 1f 00 2b 	mcall	800055d8 <fat_cluster_list+0x2c0>
80005532:	c3 b0       	breq	800055a8 <fat_cluster_list+0x290>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
80005534:	6c 08       	ld.w	r8,r6[0x0]
80005536:	8f 18       	st.w	r7[0x4],r8
80005538:	c3 58       	rjmp	800055a2 <fat_cluster_list+0x28a>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
8000553a:	e4 03 18 00 	cp.b	r3,r2
8000553e:	c0 a1       	brne	80005552 <fat_cluster_list+0x23a>
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
80005540:	6e 09       	ld.w	r9,r7[0x0]
80005542:	2f f9       	sub	r9,-1
80005544:	6e 18       	ld.w	r8,r7[0x4]
80005546:	10 39       	cp.w	r9,r8
80005548:	c1 b0       	breq	8000557e <fat_cluster_list+0x266>
            {
               // The cluster is not a continue cluster or a invalid cluster
               fat_cache_clusterlist_update_finish();
8000554a:	f0 1f 00 23 	mcall	800055d4 <fat_cluster_list+0x2bc>
8000554e:	30 1c       	mov	r12,1
               return true;                              // End of segment
80005550:	c2 d8       	rjmp	800055aa <fat_cluster_list+0x292>
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80005552:	40 09       	lddsp	r9,sp[0x0]
80005554:	58 09       	cp.w	r9,0
80005556:	c1 40       	breq	8000557e <fat_cluster_list+0x266>
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
80005558:	6e 18       	ld.w	r8,r7[0x4]
8000555a:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
8000555c:	30 08       	mov	r8,0
8000555e:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
80005560:	0b 98       	ld.ub	r8,r5[0x1]
80005562:	6c 19       	ld.w	r9,r6[0x4]
80005564:	10 39       	cp.w	r9,r8
80005566:	c0 62       	brcc	80005572 <fat_cluster_list+0x25a>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
80005568:	e0 68 ff ff 	mov	r8,65535
8000556c:	ea 18 0f ff 	orh	r8,0xfff
80005570:	8f 18       	st.w	r7[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80005572:	30 1c       	mov	r12,1
80005574:	f0 1f 00 19 	mcall	800055d8 <fat_cluster_list+0x2c0>
80005578:	c1 80       	breq	800055a8 <fat_cluster_list+0x290>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
8000557a:	6c 08       	ld.w	r8,r6[0x0]
8000557c:	8f 18       	st.w	r7[0x4],r8
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
8000557e:	e2 04 18 00 	cp.b	r4,r1
80005582:	c0 b1       	brne	80005598 <fat_cluster_list+0x280>
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
80005584:	40 0a       	lddsp	r10,sp[0x0]
80005586:	58 0a       	cp.w	r10,0
80005588:	c0 40       	breq	80005590 <fat_cluster_list+0x278>
            {
               return fat_update_fat2();
8000558a:	f0 1f 00 19 	mcall	800055ec <fat_cluster_list+0x2d4>
8000558e:	c0 e8       	rjmp	800055aa <fat_cluster_list+0x292>
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
80005590:	f0 1f 00 11 	mcall	800055d4 <fat_cluster_list+0x2bc>
80005594:	30 1c       	mov	r12,1
            return true; // End of segment
80005596:	c0 a8       	rjmp	800055aa <fat_cluster_list+0x292>
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
80005598:	0b 99       	ld.ub	r9,r5[0x1]
8000559a:	6c 18       	ld.w	r8,r6[0x4]
8000559c:	f2 08 00 08 	add	r8,r9,r8
800055a0:	8d 18       	st.w	r6[0x4],r8
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
800055a2:	6e 18       	ld.w	r8,r7[0x4]
800055a4:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
800055a6:	c2 eb       	rjmp	80005402 <fat_cluster_list+0xea>
800055a8:	30 0c       	mov	r12,0
}
800055aa:	2f ed       	sub	sp,-8
800055ac:	d8 32       	popm	r0-r7,pc
800055ae:	00 00       	add	r0,r0
800055b0:	00 00       	add	r0,r0
800055b2:	0d 38       	ld.ub	r8,r6++
800055b4:	00 00       	add	r0,r0
800055b6:	0d 34       	ld.ub	r4,r6++
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	59 80       	cp.w	r0,24
800055bc:	00 00       	add	r0,r0
800055be:	0d 90       	ld.ub	r0,r6[0x1]
800055c0:	00 00       	add	r0,r0
800055c2:	0c e8       	st.h	--r6,r8
800055c4:	00 00       	add	r0,r0
800055c6:	0d 88       	ld.ub	r8,r6[0x0]
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	47 f0       	lddsp	r0,sp[0x1fc]
800055cc:	80 00       	ld.sh	r0,r0[0x0]
800055ce:	46 c0       	lddsp	r0,sp[0x1b0]
800055d0:	80 00       	ld.sh	r0,r0[0x0]
800055d2:	58 f4       	cp.w	r4,15
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	47 98       	lddsp	r8,sp[0x1e4]
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	50 d4       	stdsp	sp[0x34],r4
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	50 40       	stdsp	sp[0x10],r0
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	46 60       	lddsp	r0,sp[0x198]
800055e4:	00 00       	add	r0,r0
800055e6:	0d 3a       	ld.ub	r10,r6++
800055e8:	00 00       	add	r0,r0
800055ea:	0a bc       	st.h	r5++,r12
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	59 0c       	cp.w	r12,16

800055f0 <fat_read_dir>:
//!   fs_g_nav.u32_cluster_sel_dir           First cluster of current directory
//!   fs_g_nav_fast.u16_entry_pos_sel_file   Position in directory (unit entry)
//! @endverbatim
//!
bool  fat_read_dir( void )
{
800055f0:	eb cd 40 80 	pushm	r7,lr
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);
800055f4:	49 98       	lddpc	r8,80005658 <fat_read_dir+0x68>
800055f6:	90 97       	ld.uh	r7,r8[0x2]
800055f8:	a5 87       	lsr	r7,0x4

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
800055fa:	49 98       	lddpc	r8,8000565c <fat_read_dir+0x6c>
800055fc:	11 89       	ld.ub	r9,r8[0x0]
800055fe:	49 98       	lddpc	r8,80005660 <fat_read_dir+0x70>
80005600:	11 88       	ld.ub	r8,r8[0x0]
80005602:	f0 09 18 00 	cp.b	r9,r8
80005606:	c0 d1       	brne	80005620 <fat_read_dir+0x30>
80005608:	49 58       	lddpc	r8,8000565c <fat_read_dir+0x6c>
8000560a:	70 39       	ld.w	r9,r8[0xc]
8000560c:	49 58       	lddpc	r8,80005660 <fat_read_dir+0x70>
8000560e:	70 88       	ld.w	r8,r8[0x20]
80005610:	10 39       	cp.w	r9,r8
80005612:	c0 71       	brne	80005620 <fat_read_dir+0x30>
80005614:	49 28       	lddpc	r8,8000565c <fat_read_dir+0x6c>
80005616:	70 48       	ld.w	r8,r8[0x10]
80005618:	0e 38       	cp.w	r8,r7
8000561a:	c0 31       	brne	80005620 <fat_read_dir+0x30>
8000561c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
         return true;      // The internal cache contains the sector asked
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
80005620:	49 18       	lddpc	r8,80005664 <fat_read_dir+0x74>
80005622:	49 09       	lddpc	r9,80005660 <fat_read_dir+0x70>
80005624:	72 89       	ld.w	r9,r9[0x20]
80005626:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
80005628:	91 17       	st.w	r8[0x4],r7
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
8000562a:	30 0b       	mov	r11,0
8000562c:	30 2c       	mov	r12,2
8000562e:	f0 1f 00 0f 	mcall	80005668 <fat_read_dir+0x78>
80005632:	c1 00       	breq	80005652 <fat_read_dir+0x62>
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
80005634:	48 c8       	lddpc	r8,80005664 <fat_read_dir+0x74>
80005636:	70 09       	ld.w	r9,r8[0x0]
80005638:	48 d8       	lddpc	r8,8000566c <fat_read_dir+0x7c>
8000563a:	91 09       	st.w	r8[0x0],r9
      if( fat_cache_read_sector( true ) )
8000563c:	30 1c       	mov	r12,1
8000563e:	f0 1f 00 0d 	mcall	80005670 <fat_read_dir+0x80>
80005642:	c0 80       	breq	80005652 <fat_read_dir+0x62>
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
80005644:	48 68       	lddpc	r8,8000565c <fat_read_dir+0x6c>
80005646:	48 79       	lddpc	r9,80005660 <fat_read_dir+0x70>
80005648:	72 89       	ld.w	r9,r9[0x20]
8000564a:	91 39       	st.w	r8[0xc],r9
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
8000564c:	91 47       	st.w	r8[0x10],r7
8000564e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
         return true;
80005652:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005656:	00 00       	add	r0,r0
80005658:	00 00       	add	r0,r0
8000565a:	0d 34       	ld.ub	r4,r6++
8000565c:	00 00       	add	r0,r0
8000565e:	0d 70       	ld.ub	r0,--r6
80005660:	00 00       	add	r0,r0
80005662:	0c e8       	st.h	--r6,r8
80005664:	00 00       	add	r0,r0
80005666:	0d 90       	ld.ub	r0,r6[0x1]
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	53 18       	stdsp	sp[0xc4],r8
8000566c:	00 00       	add	r0,r0
8000566e:	0a a4       	st.w	r5++,r4
80005670:	80 00       	ld.sh	r0,r0[0x0]
80005672:	4f c0       	lddpc	r0,80005860 <fat_check_mount+0x1c>

80005674 <fat_read_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
{
80005674:	eb cd 40 c0 	pushm	r6-r7,lr
80005678:	18 97       	mov	r7,r12
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;
8000567a:	4a e8       	lddpc	r8,80005730 <fat_read_file+0xbc>
8000567c:	70 38       	ld.w	r8,r8[0xc]
8000567e:	f0 06 16 09 	lsr	r6,r8,0x9

   if(FS_CLUST_ACT_ONE  == mode)
80005682:	30 29       	mov	r9,2
80005684:	f2 0c 18 00 	cp.b	r12,r9
80005688:	c1 31       	brne	800056ae <fat_read_file+0x3a>
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
8000568a:	4a b8       	lddpc	r8,80005734 <fat_read_file+0xc0>
8000568c:	11 89       	ld.ub	r9,r8[0x0]
8000568e:	4a b8       	lddpc	r8,80005738 <fat_read_file+0xc4>
80005690:	11 88       	ld.ub	r8,r8[0x0]
80005692:	f0 09 18 00 	cp.b	r9,r8
80005696:	c1 91       	brne	800056c8 <fat_read_file+0x54>
80005698:	4a 78       	lddpc	r8,80005734 <fat_read_file+0xc0>
8000569a:	70 39       	ld.w	r9,r8[0xc]
8000569c:	4a 58       	lddpc	r8,80005730 <fat_read_file+0xbc>
8000569e:	70 18       	ld.w	r8,r8[0x4]
800056a0:	10 39       	cp.w	r9,r8
800056a2:	c1 31       	brne	800056c8 <fat_read_file+0x54>
800056a4:	4a 48       	lddpc	r8,80005734 <fat_read_file+0xc0>
800056a6:	70 48       	ld.w	r8,r8[0x10]
800056a8:	0c 38       	cp.w	r8,r6
800056aa:	c0 f1       	brne	800056c8 <fat_read_file+0x54>
800056ac:	c3 38       	rjmp	80005712 <fat_read_file+0x9e>
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
800056ae:	30 39       	mov	r9,3
800056b0:	f2 0c 18 00 	cp.b	r12,r9
800056b4:	c3 31       	brne	8000571a <fat_read_file+0xa6>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
800056b6:	49 f9       	lddpc	r9,80005730 <fat_read_file+0xbc>
800056b8:	72 19       	ld.w	r9,r9[0x4]
800056ba:	58 09       	cp.w	r9,0
800056bc:	c2 b0       	breq	80005712 <fat_read_file+0x9e>
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
800056be:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800056c2:	c2 c0       	breq	8000571a <fat_read_file+0xa6>
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
800056c4:	2f f6       	sub	r6,-1
800056c6:	c2 a8       	rjmp	8000571a <fat_read_file+0xa6>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
800056c8:	49 d8       	lddpc	r8,8000573c <fat_read_file+0xc8>
800056ca:	49 a9       	lddpc	r9,80005730 <fat_read_file+0xbc>
800056cc:	72 19       	ld.w	r9,r9[0x4]
800056ce:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
800056d0:	91 16       	st.w	r8[0x4],r6
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
800056d2:	30 1b       	mov	r11,1
800056d4:	16 9c       	mov	r12,r11
800056d6:	f0 1f 00 1b 	mcall	80005740 <fat_read_file+0xcc>
800056da:	c1 e0       	breq	80005716 <fat_read_file+0xa2>
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
800056dc:	49 88       	lddpc	r8,8000573c <fat_read_file+0xc8>
800056de:	70 09       	ld.w	r9,r8[0x0]
800056e0:	49 98       	lddpc	r8,80005744 <fat_read_file+0xd0>
800056e2:	91 09       	st.w	r8[0x0],r9
         if( fat_cache_read_sector( true ) )
800056e4:	30 1c       	mov	r12,1
800056e6:	f0 1f 00 19 	mcall	80005748 <fat_read_file+0xd4>
800056ea:	c1 60       	breq	80005716 <fat_read_file+0xa2>
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
800056ec:	49 28       	lddpc	r8,80005734 <fat_read_file+0xc0>
800056ee:	49 19       	lddpc	r9,80005730 <fat_read_file+0xbc>
800056f0:	72 19       	ld.w	r9,r9[0x4]
800056f2:	91 39       	st.w	r8[0xc],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
800056f4:	91 46       	st.w	r8[0x10],r6
800056f6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
800056fa:	30 38       	mov	r8,3
800056fc:	f0 07 18 00 	cp.b	r7,r8
80005700:	c0 b1       	brne	80005716 <fat_read_file+0xa2>
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
80005702:	49 38       	lddpc	r8,8000574c <fat_read_file+0xd8>
80005704:	11 89       	ld.ub	r9,r8[0x0]
80005706:	31 a8       	mov	r8,26
80005708:	f0 09 18 00 	cp.b	r9,r8
8000570c:	5f 0c       	sreq	r12
8000570e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005712:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005716:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
8000571a:	48 98       	lddpc	r8,8000573c <fat_read_file+0xc8>
8000571c:	48 59       	lddpc	r9,80005730 <fat_read_file+0xbc>
8000571e:	72 19       	ld.w	r9,r9[0x4]
80005720:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80005722:	91 16       	st.w	r8[0x4],r6
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
80005724:	30 1b       	mov	r11,1
80005726:	0e 9c       	mov	r12,r7
80005728:	f0 1f 00 06 	mcall	80005740 <fat_read_file+0xcc>
8000572c:	ce 70       	breq	800056fa <fat_read_file+0x86>
8000572e:	cf 2b       	rjmp	80005712 <fat_read_file+0x9e>
80005730:	00 00       	add	r0,r0
80005732:	0a a8       	st.w	r5++,r8
80005734:	00 00       	add	r0,r0
80005736:	0d 70       	ld.ub	r0,--r6
80005738:	00 00       	add	r0,r0
8000573a:	0c e8       	st.h	--r6,r8
8000573c:	00 00       	add	r0,r0
8000573e:	0d 90       	ld.ub	r0,r6[0x1]
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	53 18       	stdsp	sp[0xc4],r8
80005744:	00 00       	add	r0,r0
80005746:	0a a4       	st.w	r5++,r4
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	4f c0       	lddpc	r0,80005938 <fat_update_fat2+0x2c>
8000574c:	00 00       	add	r0,r0
8000574e:	0d 38       	ld.ub	r8,r6++

80005750 <fat_check_device>:
//! @verbatim
//! This function updates all navigator data when the device state change.
//! @endverbatim
//!
bool  fat_check_device( void )
{
80005750:	d4 31       	pushm	r0-r7,lr
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
80005752:	4a 28       	lddpc	r8,800057d8 <fat_check_device+0x88>
80005754:	11 89       	ld.ub	r9,r8[0x0]
80005756:	30 08       	mov	r8,0
80005758:	f0 09 18 00 	cp.b	r9,r8
8000575c:	c3 c1       	brne	800057d4 <fat_check_device+0x84>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000575e:	4a 08       	lddpc	r8,800057dc <fat_check_device+0x8c>
80005760:	11 89       	ld.ub	r9,r8[0x0]
80005762:	3f f8       	mov	r8,-1
80005764:	f0 09 18 00 	cp.b	r9,r8
80005768:	c0 51       	brne	80005772 <fat_check_device+0x22>
   {
      fs_g_status = FS_ERR_HW;
8000576a:	30 19       	mov	r9,1
8000576c:	49 d8       	lddpc	r8,800057e0 <fat_check_device+0x90>
8000576e:	b0 89       	st.b	r8[0x0],r9
80005770:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;                                // No device selected
80005772:	30 02       	mov	r2,0
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80005774:	49 a5       	lddpc	r5,800057dc <fat_check_device+0x8c>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005776:	49 c1       	lddpc	r1,800057e4 <fat_check_device+0x94>
80005778:	30 06       	mov	r6,0
      Fat_file_close();                            // By default the file is not open
8000577a:	49 c0       	lddpc	r0,800057e8 <fat_check_device+0x98>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000577c:	49 c4       	lddpc	r4,800057ec <fat_check_device+0x9c>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000577e:	49 d3       	lddpc	r3,800057f0 <fat_check_device+0xa0>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80005780:	0b 8c       	ld.ub	r12,r5[0x0]
80005782:	f0 1f 00 1d 	mcall	800057f4 <fat_check_device+0xa4>
80005786:	18 97       	mov	r7,r12
      if( CTRL_GOOD       == status )
80005788:	c2 60       	breq	800057d4 <fat_check_device+0x84>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000578a:	a2 86       	st.b	r1[0x0],r6
      Fat_file_close();                            // By default the file is not open
8000578c:	a0 86       	st.b	r0[0x0],r6
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000578e:	0b 88       	ld.ub	r8,r5[0x0]
80005790:	09 89       	ld.ub	r9,r4[0x0]
80005792:	f0 09 18 00 	cp.b	r9,r8
80005796:	c0 51       	brne	800057a0 <fat_check_device+0x50>
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
80005798:	49 89       	lddpc	r9,800057f8 <fat_check_device+0xa8>
8000579a:	b2 86       	st.b	r9[0x0],r6
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000579c:	49 89       	lddpc	r9,800057fc <fat_check_device+0xac>
8000579e:	b2 86       	st.b	r9[0x0],r6
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
800057a0:	07 89       	ld.ub	r9,r3[0x0]
800057a2:	f0 09 18 00 	cp.b	r9,r8
800057a6:	c0 31       	brne	800057ac <fat_check_device+0x5c>
      {
         fat_cache_reset();
800057a8:	f0 1f 00 16 	mcall	80005800 <fat_check_device+0xb0>
      }
      fat_cache_clusterlist_reset();
800057ac:	f0 1f 00 16 	mcall	80005804 <fat_check_device+0xb4>

      fs_g_status = FS_ERR_HW;                     // By default HW error
800057b0:	30 18       	mov	r8,1
800057b2:	48 c9       	lddpc	r9,800057e0 <fat_check_device+0x90>
800057b4:	b2 88       	st.b	r9[0x0],r8
      if( CTRL_BUSY == status )
800057b6:	58 37       	cp.w	r7,3
800057b8:	c0 81       	brne	800057c8 <fat_check_device+0x78>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
800057ba:	10 02       	add	r2,r8
800057bc:	5c 52       	castu.b	r2
800057be:	36 48       	mov	r8,100
800057c0:	f0 02 18 00 	cp.b	r2,r8
800057c4:	cd e1       	brne	80005780 <fat_check_device+0x30>
800057c6:	c0 88       	rjmp	800057d6 <fat_check_device+0x86>

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
800057c8:	58 27       	cp.w	r7,2
800057ca:	c0 61       	brne	800057d6 <fat_check_device+0x86>
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
800057cc:	31 89       	mov	r9,24
800057ce:	48 58       	lddpc	r8,800057e0 <fat_check_device+0x90>
800057d0:	b0 89       	st.b	r8[0x0],r9
800057d2:	d8 3a       	popm	r0-r7,pc,r12=0
800057d4:	da 3a       	popm	r0-r7,pc,r12=1
800057d6:	d8 3a       	popm	r0-r7,pc,r12=0
800057d8:	00 00       	add	r0,r0
800057da:	0a ba       	st.h	r5++,r10
800057dc:	00 00       	add	r0,r0
800057de:	0c e8       	st.h	--r6,r8
800057e0:	00 00       	add	r0,r0
800057e2:	0d 38       	ld.ub	r8,r6++
800057e4:	00 00       	add	r0,r0
800057e6:	0d 34       	ld.ub	r4,r6++
800057e8:	00 00       	add	r0,r0
800057ea:	0a a8       	st.w	r5++,r8
800057ec:	00 00       	add	r0,r0
800057ee:	0d 3c       	ld.ub	r12,r6++
800057f0:	00 00       	add	r0,r0
800057f2:	0d 70       	ld.ub	r0,--r6
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	69 c8       	ld.w	r8,r4[0x70]
800057f8:	00 00       	add	r0,r0
800057fa:	0d 30       	ld.ub	r0,r6++
800057fc:	00 00       	add	r0,r0
800057fe:	0d 20       	ld.uh	r0,r6++
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	4d 88       	lddpc	r8,80005960 <fat_update_fat2+0x54>
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	46 c0       	lddsp	r0,sp[0x1b0]

80005808 <fat_check_noopen>:
//!
//! @return    true  no file opened
//! @return    false otherwise
//!
bool  fat_check_noopen( void )
{
80005808:	d4 01       	pushm	lr
   if( !fat_check_device() )
8000580a:	f0 1f 00 0b 	mcall	80005834 <fat_check_noopen+0x2c>
8000580e:	c1 10       	breq	80005830 <fat_check_noopen+0x28>
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80005810:	48 a8       	lddpc	r8,80005838 <fat_check_noopen+0x30>
80005812:	11 89       	ld.ub	r9,r8[0x0]
80005814:	30 08       	mov	r8,0
80005816:	f0 09 18 00 	cp.b	r9,r8
8000581a:	c0 b0       	breq	80005830 <fat_check_noopen+0x28>
      return true;
   if( Fat_file_is_open() )
8000581c:	48 88       	lddpc	r8,8000583c <fat_check_noopen+0x34>
8000581e:	11 89       	ld.ub	r9,r8[0x0]
80005820:	30 08       	mov	r8,0
80005822:	f0 09 18 00 	cp.b	r9,r8
80005826:	c0 50       	breq	80005830 <fat_check_noopen+0x28>
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
80005828:	30 59       	mov	r9,5
8000582a:	48 68       	lddpc	r8,80005840 <fat_check_noopen+0x38>
8000582c:	b0 89       	st.b	r8[0x0],r9
8000582e:	d8 0a       	popm	pc,r12=0
      return false;
80005830:	da 0a       	popm	pc,r12=1
80005832:	00 00       	add	r0,r0
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	57 50       	stdsp	sp[0x1d4],r0
80005838:	00 00       	add	r0,r0
8000583a:	0d 34       	ld.ub	r4,r6++
8000583c:	00 00       	add	r0,r0
8000583e:	0a a8       	st.w	r5++,r8
80005840:	00 00       	add	r0,r0
80005842:	0d 38       	ld.ub	r8,r6++

80005844 <fat_check_mount>:
//!
//! @return    true  partition mounted
//! @return    false otherwise
//!
bool  fat_check_mount( void )
{
80005844:	d4 01       	pushm	lr
   if( !fat_check_device() )
80005846:	f0 1f 00 0a 	mcall	8000586c <fat_check_mount+0x28>
8000584a:	c0 f0       	breq	80005868 <fat_check_mount+0x24>
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000584c:	48 98       	lddpc	r8,80005870 <fat_check_mount+0x2c>
8000584e:	11 89       	ld.ub	r9,r8[0x0]
80005850:	30 08       	mov	r8,0
80005852:	f0 09 18 00 	cp.b	r9,r8
80005856:	c0 81       	brne	80005866 <fat_check_mount+0x22>
   {
      if( !fat_mount() )
80005858:	f0 1f 00 07 	mcall	80005874 <fat_check_mount+0x30>
8000585c:	c0 51       	brne	80005866 <fat_check_mount+0x22>
      {
         fs_g_status = FS_ERR_NO_MOUNT;
8000585e:	30 e9       	mov	r9,14
80005860:	48 68       	lddpc	r8,80005878 <fat_check_mount+0x34>
80005862:	b0 89       	st.b	r8[0x0],r9
         return false;
80005864:	d8 02       	popm	pc
80005866:	30 1c       	mov	r12,1
      }
   }
   return true;
}
80005868:	d8 02       	popm	pc
8000586a:	00 00       	add	r0,r0
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	57 50       	stdsp	sp[0x1d4],r0
80005870:	00 00       	add	r0,r0
80005872:	0d 34       	ld.ub	r4,r6++
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	5a 20       	cp.w	r0,-30
80005878:	00 00       	add	r0,r0
8000587a:	0d 38       	ld.ub	r8,r6++

8000587c <fat_check_mount_select>:
//!
//! @return    true  partition mounted and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select( void )
{
8000587c:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000587e:	f0 1f 00 04 	mcall	8000588c <fat_check_mount_select+0x10>
80005882:	c0 30       	breq	80005888 <fat_check_mount_select+0xc>
      return false;
   return fat_check_select();
80005884:	f0 1f 00 03 	mcall	80005890 <fat_check_mount_select+0x14>
}
80005888:	d8 02       	popm	pc
8000588a:	00 00       	add	r0,r0
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	58 44       	cp.w	r4,4
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	46 24       	lddsp	r4,sp[0x188]

80005894 <fat_check_mount_select_open>:
//!
//! @return    true  partition mounted and a file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_select_open( void )
{
80005894:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80005896:	f0 1f 00 06 	mcall	800058ac <fat_check_mount_select_open+0x18>
8000589a:	c0 70       	breq	800058a8 <fat_check_mount_select_open+0x14>
      return false;
   if( !fat_check_select() )
8000589c:	f0 1f 00 05 	mcall	800058b0 <fat_check_mount_select_open+0x1c>
800058a0:	c0 40       	breq	800058a8 <fat_check_mount_select_open+0x14>
      return false;
   return fat_check_open();
800058a2:	f0 1f 00 05 	mcall	800058b4 <fat_check_mount_select_open+0x20>
800058a6:	d8 02       	popm	pc
800058a8:	d8 0a       	popm	pc,r12=0
800058aa:	00 00       	add	r0,r0
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	58 44       	cp.w	r4,4
800058b0:	80 00       	ld.sh	r0,r0[0x0]
800058b2:	46 24       	lddsp	r4,sp[0x188]
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	46 04       	lddsp	r4,sp[0x180]

800058b8 <fat_check_mount_select_noopen>:
//!
//! @return    true  partition mounted and no file is opened and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select_noopen( void )
{
800058b8:	d4 01       	pushm	lr
   if( !fat_check_mount() )
800058ba:	f0 1f 00 06 	mcall	800058d0 <fat_check_mount_select_noopen+0x18>
800058be:	c0 70       	breq	800058cc <fat_check_mount_select_noopen+0x14>
      return false;
   if( !fat_check_select() )
800058c0:	f0 1f 00 05 	mcall	800058d4 <fat_check_mount_select_noopen+0x1c>
800058c4:	c0 40       	breq	800058cc <fat_check_mount_select_noopen+0x14>
      return false;
   return fat_check_noopen();
800058c6:	f0 1f 00 05 	mcall	800058d8 <fat_check_mount_select_noopen+0x20>
800058ca:	d8 02       	popm	pc
800058cc:	d8 0a       	popm	pc,r12=0
800058ce:	00 00       	add	r0,r0
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	58 44       	cp.w	r4,4
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	46 24       	lddsp	r4,sp[0x188]
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	58 08       	cp.w	r8,0

800058dc <fat_check_mount_noopen>:
//!
//! @return    true  partition mounted and no file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_noopen( void )
{
800058dc:	d4 01       	pushm	lr
   if( !fat_check_mount() )
800058de:	f0 1f 00 04 	mcall	800058ec <fat_check_mount_noopen+0x10>
800058e2:	c0 30       	breq	800058e8 <fat_check_mount_noopen+0xc>
      return false;
   return fat_check_noopen();
800058e4:	f0 1f 00 03 	mcall	800058f0 <fat_check_mount_noopen+0x14>
}
800058e8:	d8 02       	popm	pc
800058ea:	00 00       	add	r0,r0
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	58 44       	cp.w	r4,4
800058f0:	80 00       	ld.sh	r0,r0[0x0]
800058f2:	58 08       	cp.w	r8,0

800058f4 <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
800058f4:	3f f9       	mov	r9,-1
800058f6:	48 48       	lddpc	r8,80005904 <fat_clear_info_fat_mod+0x10>
800058f8:	91 09       	st.w	r8[0x0],r9
   fs_g_u32_last_mod_fat = 0;
800058fa:	30 09       	mov	r9,0
800058fc:	48 38       	lddpc	r8,80005908 <fat_clear_info_fat_mod+0x14>
800058fe:	91 09       	st.w	r8[0x0],r9
}
80005900:	5e fc       	retal	r12
80005902:	00 00       	add	r0,r0
80005904:	00 00       	add	r0,r0
80005906:	0d 1c       	ld.sh	r12,r6++
80005908:	00 00       	add	r0,r0
8000590a:	0a e4       	st.h	--r5,r4

8000590c <fat_update_fat2>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
8000590c:	eb cd 40 fc 	pushm	r2-r7,lr
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80005910:	49 68       	lddpc	r8,80005968 <fat_update_fat2+0x5c>
80005912:	70 08       	ld.w	r8,r8[0x0]
80005914:	49 69       	lddpc	r9,8000596c <fat_update_fat2+0x60>
80005916:	72 09       	ld.w	r9,r9[0x0]
80005918:	12 38       	cp.w	r8,r9
8000591a:	e0 8b 00 25 	brhi	80005964 <fat_update_fat2+0x58>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000591e:	49 55       	lddpc	r5,80005970 <fat_update_fat2+0x64>
80005920:	49 57       	lddpc	r7,80005974 <fat_update_fat2+0x68>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80005922:	30 13       	mov	r3,1
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80005924:	49 16       	lddpc	r6,80005968 <fat_update_fat2+0x5c>
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80005926:	30 02       	mov	r2,0
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80005928:	49 14       	lddpc	r4,8000596c <fat_update_fat2+0x60>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000592a:	6e 49       	ld.w	r9,r7[0x10]
8000592c:	12 08       	add	r8,r9
8000592e:	8b 08       	st.w	r5[0x0],r8
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80005930:	06 9c       	mov	r12,r3
80005932:	f0 1f 00 12 	mcall	80005978 <fat_update_fat2+0x6c>
80005936:	c1 50       	breq	80005960 <fat_update_fat2+0x54>
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80005938:	6e 19       	ld.w	r9,r7[0x4]
8000593a:	6e 48       	ld.w	r8,r7[0x10]
8000593c:	f2 08 00 08 	add	r8,r9,r8
80005940:	6c 09       	ld.w	r9,r6[0x0]
80005942:	12 08       	add	r8,r9
80005944:	8b 08       	st.w	r5[0x0],r8
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80005946:	04 9c       	mov	r12,r2
80005948:	f0 1f 00 0c 	mcall	80005978 <fat_update_fat2+0x6c>
8000594c:	c0 a0       	breq	80005960 <fat_update_fat2+0x54>
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
8000594e:	f0 1f 00 0c 	mcall	8000597c <fat_update_fat2+0x70>
     fs_g_u32_first_mod_fat++;
80005952:	6c 08       	ld.w	r8,r6[0x0]
80005954:	2f f8       	sub	r8,-1
80005956:	8d 08       	st.w	r6[0x0],r8
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80005958:	68 09       	ld.w	r9,r4[0x0]
8000595a:	10 39       	cp.w	r9,r8
8000595c:	ce 72       	brcc	8000592a <fat_update_fat2+0x1e>
8000595e:	c0 38       	rjmp	80005964 <fat_update_fat2+0x58>
80005960:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005964:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80005968:	00 00       	add	r0,r0
8000596a:	0d 1c       	ld.sh	r12,r6++
8000596c:	00 00       	add	r0,r0
8000596e:	0a e4       	st.h	--r5,r4
80005970:	00 00       	add	r0,r0
80005972:	0a a4       	st.w	r5++,r4
80005974:	00 00       	add	r0,r0
80005976:	0c e8       	st.h	--r6,r8
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	4f c0       	lddpc	r0,80005b68 <fat_mount+0x148>
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	4d a0       	lddpc	r0,80005ae4 <fat_mount+0xc4>

80005980 <fat_write_fat32_FSInfo>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
80005980:	eb cd 40 c0 	pushm	r6-r7,lr
80005984:	20 1d       	sub	sp,4
80005986:	50 0c       	stdsp	sp[0x0],r12
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
80005988:	49 c8       	lddpc	r8,800059f8 <fat_write_fat32_FSInfo+0x78>
8000598a:	90 c9       	ld.uh	r9,r8[0x8]
8000598c:	70 4a       	ld.w	r10,r8[0x10]
8000598e:	49 c8       	lddpc	r8,800059fc <fat_write_fat32_FSInfo+0x7c>
80005990:	12 1a       	sub	r10,r9
80005992:	91 0a       	st.w	r8[0x0],r10

   if( !fat_cache_read_sector( false ))
80005994:	30 0c       	mov	r12,0
80005996:	f0 1f 00 1b 	mcall	80005a00 <fat_write_fat32_FSInfo+0x80>
8000599a:	c2 c0       	breq	800059f2 <fat_write_fat32_FSInfo+0x72>
      return false;
   fat_cache_mark_sector_as_dirty();
8000599c:	f0 1f 00 1a 	mcall	80005a04 <fat_write_fat32_FSInfo+0x84>
   fat_cache_clear();
800059a0:	f0 1f 00 1a 	mcall	80005a08 <fat_write_fat32_FSInfo+0x88>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
800059a4:	49 a7       	lddpc	r7,80005a0c <fat_write_fat32_FSInfo+0x8c>
800059a6:	30 46       	mov	r6,4
800059a8:	0c 9a       	mov	r10,r6
800059aa:	49 ab       	lddpc	r11,80005a10 <fat_write_fat32_FSInfo+0x90>
800059ac:	0e 9c       	mov	r12,r7
800059ae:	f0 1f 00 1a 	mcall	80005a14 <fat_write_fat32_FSInfo+0x94>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
800059b2:	0c 9a       	mov	r10,r6
800059b4:	49 9b       	lddpc	r11,80005a18 <fat_write_fat32_FSInfo+0x98>
800059b6:	ee cc fe 1c 	sub	r12,r7,-484
800059ba:	f0 1f 00 17 	mcall	80005a14 <fat_write_fat32_FSInfo+0x94>
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
800059be:	1b b9       	ld.ub	r9,sp[0x3]
800059c0:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
800059c4:	1b a9       	ld.ub	r9,sp[0x2]
800059c6:	ef 69 01 e9 	st.b	r7[489],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
800059ca:	1b 99       	ld.ub	r9,sp[0x1]
800059cc:	ef 69 01 ea 	st.b	r7[490],r9
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
800059d0:	1b 88       	ld.ub	r8,sp[0x0]
800059d2:	ef 68 01 eb 	st.b	r7[491],r8
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
800059d6:	0c 9a       	mov	r10,r6
800059d8:	e0 6b 00 ff 	mov	r11,255
800059dc:	ee cc fe 14 	sub	r12,r7,-492
800059e0:	f0 1f 00 0f 	mcall	80005a1c <fat_write_fat32_FSInfo+0x9c>
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
800059e4:	35 58       	mov	r8,85
800059e6:	ef 68 01 fe 	st.b	r7[510],r8
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
800059ea:	3a a8       	mov	r8,-86
800059ec:	ef 68 01 ff 	st.b	r7[511],r8
800059f0:	30 1c       	mov	r12,1
   return true;
}
800059f2:	2f fd       	sub	sp,-4
800059f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059f8:	00 00       	add	r0,r0
800059fa:	0c e8       	st.h	--r6,r8
800059fc:	00 00       	add	r0,r0
800059fe:	0a a4       	st.w	r5++,r4
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	4f c0       	lddpc	r0,80005bf0 <fat_mount+0x1d0>
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	4d a0       	lddpc	r0,80005b6c <fat_mount+0x14c>
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	4f a8       	lddpc	r8,80005bf0 <fat_mount+0x1d0>
80005a0c:	00 00       	add	r0,r0
80005a0e:	0a e8       	st.h	--r5,r8
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	a7 30       	mul	r0,r3
80005a14:	80 00       	ld.sh	r0,r0[0x0]
80005a16:	98 88       	ld.uh	r8,r12[0x0]
80005a18:	80 00       	ld.sh	r0,r0[0x0]
80005a1a:	a7 34       	mul	r4,r3
80005a1c:	80 00       	ld.sh	r0,r0[0x0]
80005a1e:	99 d0       	st.w	r12[0x34],r0

80005a20 <fat_mount>:
//! If the FS_MULTI_PARTITION option is disabled
//! then the mount routine selects the first partition supported by file system. <br>
//! @endverbatim
//!
bool  fat_mount( void )
{
80005a20:	d4 31       	pushm	r0-r7,lr
80005a22:	20 3d       	sub	sp,12
   uint8_t  u8_tmp;
   uint16_t u16_tmp;
   uint32_t u32_tmp;

   // Select the root directory
   fs_g_nav.u32_cluster_sel_dir   = 0;
80005a24:	30 07       	mov	r7,0
80005a26:	fe f8 02 d2 	ld.w	r8,pc[722]
80005a2a:	91 87       	st.w	r8[0x20],r7
   // No selected file
   fat_clear_entry_info_and_ptr();
80005a2c:	f0 1f 00 b4 	mcall	80005cfc <fat_mount+0x2dc>

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
80005a30:	fe f8 02 d0 	ld.w	r8,pc[720]
80005a34:	b0 87       	st.b	r8[0x0],r7
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory
80005a36:	fe f8 02 ce 	ld.w	r8,pc[718]
80005a3a:	91 07       	st.w	r8[0x0],r7

   // Check if the drive is available
   if( !fat_check_device() )
80005a3c:	f0 1f 00 b3 	mcall	80005d08 <fat_mount+0x2e8>
80005a40:	e0 80 01 58 	breq	80005cf0 <fat_mount+0x2d0>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80005a44:	fe f5 02 c8 	ld.w	r5,pc[712]
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
80005a48:	ea c8 fe 42 	sub	r8,r5,-446
80005a4c:	50 08       	stdsp	sp[0x0],r8
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005a4e:	38 04       	mov	r4,-128
80005a50:	30 46       	mov	r6,4
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
80005a52:	30 1c       	mov	r12,1
80005a54:	f0 1f 00 af 	mcall	80005d10 <fat_mount+0x2f0>
80005a58:	e0 80 01 4c 	breq	80005cf0 <fat_mount+0x2d0>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80005a5c:	eb 39 01 fe 	ld.ub	r9,r5[510]
80005a60:	35 58       	mov	r8,85
80005a62:	f0 09 18 00 	cp.b	r9,r8
80005a66:	c0 d0       	breq	80005a80 <fat_mount+0x60>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
80005a68:	eb 39 01 ff 	ld.ub	r9,r5[511]
80005a6c:	3a a8       	mov	r8,-86
80005a6e:	f0 09 18 00 	cp.b	r9,r8
80005a72:	c0 70       	breq	80005a80 <fat_mount+0x60>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
80005a74:	30 29       	mov	r9,2
80005a76:	fe f8 02 9e 	ld.w	r8,pc[670]
80005a7a:	b0 89       	st.b	r8[0x0],r9
80005a7c:	30 0c       	mov	r12,0
         return false;
80005a7e:	c3 a9       	rjmp	80005cf2 <fat_mount+0x2d2>
      }

      if ( 0 == fs_gu32_addrsector )
80005a80:	fe f8 02 84 	ld.w	r8,pc[644]
80005a84:	70 08       	ld.w	r8,r8[0x0]
80005a86:	58 08       	cp.w	r8,0
80005a88:	c5 21       	brne	80005b2c <fat_mount+0x10c>
80005a8a:	40 08       	lddsp	r8,sp[0x0]
80005a8c:	30 0a       	mov	r10,0
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005a8e:	30 1e       	mov	lr,1
80005a90:	30 63       	mov	r3,6
80005a92:	30 e2       	mov	r2,14
80005a94:	30 b1       	mov	r1,11
80005a96:	30 c0       	mov	r0,12
80005a98:	11 89       	ld.ub	r9,r8[0x0]
80005a9a:	e8 09 18 00 	cp.b	r9,r4
80005a9e:	5f 0b       	sreq	r11
80005aa0:	ee 09 18 00 	cp.b	r9,r7
80005aa4:	5f 09       	sreq	r9
80005aa6:	f7 e9 10 09 	or	r9,r11,r9
80005aaa:	ee 09 18 00 	cp.b	r9,r7
80005aae:	c1 90       	breq	80005ae0 <fat_mount+0xc0>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
80005ab0:	11 c9       	ld.ub	r9,r8[0x4]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005ab2:	fc 09 18 00 	cp.b	r9,lr
80005ab6:	5f 0c       	sreq	r12
80005ab8:	ec 09 18 00 	cp.b	r9,r6
80005abc:	5f 0b       	sreq	r11
80005abe:	f9 eb 10 0b 	or	r11,r12,r11
80005ac2:	ee 0b 18 00 	cp.b	r11,r7
80005ac6:	c1 41       	brne	80005aee <fat_mount+0xce>
80005ac8:	e6 09 18 00 	cp.b	r9,r3
80005acc:	c1 10       	breq	80005aee <fat_mount+0xce>
80005ace:	e4 09 18 00 	cp.b	r9,r2
80005ad2:	c0 e0       	breq	80005aee <fat_mount+0xce>
80005ad4:	e2 09 18 00 	cp.b	r9,r1
80005ad8:	c0 b0       	breq	80005aee <fat_mount+0xce>
80005ada:	e0 09 18 00 	cp.b	r9,r0
80005ade:	c0 80       	breq	80005aee <fat_mount+0xce>
         //** first sector then check a MBR structure
         // Search the first partition supported
#if (FS_MULTI_PARTITION == true)
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
80005ae0:	2f fa       	sub	r10,-1
80005ae2:	5c 5a       	castu.b	r10
80005ae4:	2f 08       	sub	r8,-16
80005ae6:	ec 0a 18 00 	cp.b	r10,r6
80005aea:	cd 71       	brne	80005a98 <fat_mount+0x78>
80005aec:	c2 08       	rjmp	80005b2c <fat_mount+0x10c>
#else
               break;
#endif
            }
         }
         if( u8_tmp != 4 )
80005aee:	ec 0a 18 00 	cp.b	r10,r6
80005af2:	c1 d0       	breq	80005b2c <fat_mount+0x10c>
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
80005af4:	fe f3 02 10 	ld.w	r3,pc[528]
80005af8:	a5 6a       	lsl	r10,0x4
80005afa:	f4 ca fe 42 	sub	r10,r10,-446
80005afe:	ea 0a 00 0a 	add	r10,r5,r10
80005b02:	f5 38 00 08 	ld.ub	r8,r10[8]
80005b06:	a6 b8       	st.b	r3[0x3],r8
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
80005b08:	f5 38 00 09 	ld.ub	r8,r10[9]
80005b0c:	a6 a8       	st.b	r3[0x2],r8
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
80005b0e:	f5 38 00 0a 	ld.ub	r8,r10[10]
80005b12:	a6 98       	st.b	r3[0x1],r8
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
80005b14:	f5 38 00 0b 	ld.ub	r8,r10[11]
80005b18:	a6 88       	st.b	r3[0x0],r8
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
80005b1a:	4f 88       	lddpc	r8,80005cf8 <fat_mount+0x2d8>
80005b1c:	11 8c       	ld.ub	r12,r8[0x0]
80005b1e:	f0 1f 00 7f 	mcall	80005d18 <fat_mount+0x2f8>
80005b22:	66 08       	ld.w	r8,r3[0x0]
80005b24:	f8 08 02 48 	mul	r8,r12,r8
80005b28:	87 08       	st.w	r3[0x0],r8
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
80005b2a:	c9 4b       	rjmp	80005a52 <fat_mount+0x32>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
80005b2c:	4f 88       	lddpc	r8,80005d0c <fat_mount+0x2ec>
80005b2e:	11 89       	ld.ub	r9,r8[0x0]
80005b30:	3e b8       	mov	r8,-21
80005b32:	f0 09 18 00 	cp.b	r9,r8
80005b36:	c0 f1       	brne	80005b54 <fat_mount+0x134>
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
80005b38:	4f 58       	lddpc	r8,80005d0c <fat_mount+0x2ec>
80005b3a:	11 a9       	ld.ub	r9,r8[0x2]
80005b3c:	39 08       	mov	r8,-112
80005b3e:	f0 09 18 00 	cp.b	r9,r8
80005b42:	c0 91       	brne	80005b54 <fat_mount+0x134>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
80005b44:	4f 28       	lddpc	r8,80005d0c <fat_mount+0x2ec>
80005b46:	f1 38 00 15 	ld.ub	r8,r8[21]
80005b4a:	e2 18 00 f0 	andl	r8,0xf0,COH
80005b4e:	e0 48 00 f0 	cp.w	r8,240
80005b52:	c0 60       	breq	80005b5e <fat_mount+0x13e>
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
80005b54:	30 39       	mov	r9,3
80005b56:	4f 08       	lddpc	r8,80005d14 <fat_mount+0x2f4>
80005b58:	b0 89       	st.b	r8[0x0],r9
80005b5a:	30 0c       	mov	r12,0
      return false;
80005b5c:	cc b8       	rjmp	80005cf2 <fat_mount+0x2d2>
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
80005b5e:	30 49       	mov	r9,4
80005b60:	4e d8       	lddpc	r8,80005d14 <fat_mount+0x2f4>
80005b62:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
80005b64:	4e aa       	lddpc	r10,80005d0c <fat_mount+0x2ec>
80005b66:	f5 39 00 0c 	ld.ub	r9,r10[12]
80005b6a:	a1 99       	lsr	r9,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
80005b6c:	f5 38 00 0d 	ld.ub	r8,r10[13]
80005b70:	b3 38       	mul	r8,r9
80005b72:	5c 58       	castu.b	r8
80005b74:	4e 1b       	lddpc	r11,80005cf8 <fat_mount+0x2d8>
80005b76:	b6 98       	st.b	r11[0x1],r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
80005b78:	30 0b       	mov	r11,0
80005b7a:	50 1b       	stdsp	sp[0x4],r11
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
80005b7c:	fa cb ff fc 	sub	r11,sp,-4
80005b80:	fa c7 ff f9 	sub	r7,sp,-7
80005b84:	f5 3c 00 16 	ld.ub	r12,r10[22]
80005b88:	ae 8c       	st.b	r7[0x0],r12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
80005b8a:	fa ce ff fa 	sub	lr,sp,-6
80005b8e:	f5 3a 00 17 	ld.ub	r10,r10[23]
80005b92:	bc 8a       	st.b	lr[0x0],r10
   if ( 0==u32_tmp )
80005b94:	40 1a       	lddsp	r10,sp[0x4]
80005b96:	58 0a       	cp.w	r10,0
80005b98:	c0 e1       	brne	80005bb4 <fat_mount+0x194>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
80005b9a:	4d da       	lddpc	r10,80005d0c <fat_mount+0x2ec>
80005b9c:	f5 3c 00 24 	ld.ub	r12,r10[36]
80005ba0:	ae 8c       	st.b	r7[0x0],r12
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
80005ba2:	f5 3c 00 25 	ld.ub	r12,r10[37]
80005ba6:	bc 8c       	st.b	lr[0x0],r12
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
80005ba8:	f5 3c 00 26 	ld.ub	r12,r10[38]
80005bac:	b6 9c       	st.b	r11[0x1],r12
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
80005bae:	f5 3a 00 27 	ld.ub	r10,r10[39]
80005bb2:	b6 8a       	st.b	r11[0x0],r10
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
80005bb4:	12 95       	mov	r5,r9
80005bb6:	40 1c       	lddsp	r12,sp[0x4]
80005bb8:	f2 0c 02 4c 	mul	r12,r9,r12
80005bbc:	4c fa       	lddpc	r10,80005cf8 <fat_mount+0x2d8>
80005bbe:	95 1c       	st.w	r10[0x4],r12

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80005bc0:	4d 3a       	lddpc	r10,80005d0c <fat_mount+0x2ec>
80005bc2:	f5 3a 00 13 	ld.ub	r10,r10[19]
80005bc6:	58 0a       	cp.w	r10,0
80005bc8:	c1 61       	brne	80005bf4 <fat_mount+0x1d4>
80005bca:	4d 16       	lddpc	r6,80005d0c <fat_mount+0x2ec>
80005bcc:	ed 34 00 14 	ld.ub	r4,r6[20]
80005bd0:	30 06       	mov	r6,0
80005bd2:	ec 04 18 00 	cp.b	r4,r6
80005bd6:	c0 f1       	brne	80005bf4 <fat_mount+0x1d4>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
80005bd8:	4c da       	lddpc	r10,80005d0c <fat_mount+0x2ec>
80005bda:	f5 36 00 20 	ld.ub	r6,r10[32]
80005bde:	ae 86       	st.b	r7[0x0],r6
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
80005be0:	f5 37 00 21 	ld.ub	r7,r10[33]
80005be4:	bc 87       	st.b	lr[0x0],r7
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
80005be6:	f5 3e 00 22 	ld.ub	lr,r10[34]
80005bea:	b6 9e       	st.b	r11[0x1],lr
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
80005bec:	f5 3a 00 23 	ld.ub	r10,r10[35]
80005bf0:	b6 8a       	st.b	r11[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80005bf2:	c0 98       	rjmp	80005c04 <fat_mount+0x1e4>
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
80005bf4:	ae 8a       	st.b	r7[0x0],r10
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
80005bf6:	4c 6a       	lddpc	r10,80005d0c <fat_mount+0x2ec>
80005bf8:	f5 3a 00 14 	ld.ub	r10,r10[20]
80005bfc:	bc 8a       	st.b	lr[0x0],r10
      LSB2( u32_tmp ) = 0;
80005bfe:	30 0a       	mov	r10,0
80005c00:	b6 9a       	st.b	r11[0x1],r10
      LSB3( u32_tmp ) = 0;
80005c02:	b6 8a       	st.b	r11[0x0],r10
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
80005c04:	40 14       	lddsp	r4,sp[0x4]

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
80005c06:	4b da       	lddpc	r10,80005cf8 <fat_mount+0x2d8>
80005c08:	f8 0b 15 01 	lsl	r11,r12,0x1
80005c0c:	f5 5b 00 18 	st.h	r10[24],r11

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
80005c10:	fa c6 ff f6 	sub	r6,sp,-10
80005c14:	fa c7 ff f4 	sub	r7,sp,-12
80005c18:	4b db       	lddpc	r11,80005d0c <fat_mount+0x2ec>
80005c1a:	f7 3e 00 11 	ld.ub	lr,r11[17]
80005c1e:	0e fe       	st.b	--r7,lr
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
80005c20:	f7 3e 00 12 	ld.ub	lr,r11[18]
80005c24:	ac 8e       	st.b	r6[0x0],lr
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
80005c26:	f2 03 15 04 	lsl	r3,r9,0x4
80005c2a:	9a de       	ld.uh	lr,sp[0xa]
80005c2c:	e6 0e 00 0e 	add	lr,r3,lr
80005c30:	a5 7e       	lsl	lr,0x5
80005c32:	20 1e       	sub	lr,1
80005c34:	f2 03 15 09 	lsl	r3,r9,0x9
80005c38:	fc 03 0c 02 	divs	r2,lr,r3
80005c3c:	e4 09 02 4e 	mul	lr,r2,r9
80005c40:	f5 5e 00 1a 	st.h	r10[26],lr

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
80005c44:	f7 33 00 0e 	ld.ub	r3,r11[14]
80005c48:	ae 83       	st.b	r7[0x0],r3
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
80005c4a:	f7 37 00 0f 	ld.ub	r7,r11[15]
80005c4e:	ac 87       	st.b	r6[0x0],r7
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
80005c50:	9a 57       	ld.sh	r7,sp[0xa]
80005c52:	f7 3b 00 30 	ld.ub	r11,r11[48]
80005c56:	0e 96       	mov	r6,r7
80005c58:	ee 0b 01 0b 	sub	r11,r7,r11
80005c5c:	b3 3b       	mul	r11,r9
80005c5e:	b4 4b       	st.h	r10[0x8],r11
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
80005c60:	ee 09 02 49 	mul	r9,r7,r9
80005c64:	5c 79       	castu.h	r9
80005c66:	4a 8b       	lddpc	r11,80005d04 <fat_mount+0x2e4>
80005c68:	76 0b       	ld.w	r11,r11[0x0]
80005c6a:	f2 0b 00 0b 	add	r11,r9,r11
80005c6e:	95 4b       	st.w	r10[0x10],r11

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
80005c70:	5c 7e       	castu.h	lr
80005c72:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
80005c76:	95 5c       	st.w	r10[0x14],r12
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
80005c78:	58 08       	cp.w	r8,0
80005c7a:	c3 b0       	breq	80005cf0 <fat_mount+0x2d0>

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
80005c7c:	a9 35       	mul	r5,r4
80005c7e:	ea 09 01 09 	sub	r9,r5,r9
80005c82:	18 19       	sub	r9,r12
80005c84:	50 19       	stdsp	sp[0x4],r9

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005c86:	30 1a       	mov	r10,1
80005c88:	f4 08 18 00 	cp.b	r8,r10
80005c8c:	c0 70       	breq	80005c9a <fat_mount+0x27a>
   {
     u32_tmp  >>= 1;   // This computation round down
80005c8e:	a1 99       	lsr	r9,0x1

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005c90:	a1 98       	lsr	r8,0x1
80005c92:	f4 08 18 00 	cp.b	r8,r10
80005c96:	cf c1       	brne	80005c8e <fat_mount+0x26e>
80005c98:	50 19       	stdsp	sp[0x4],r9
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
80005c9a:	40 18       	lddsp	r8,sp[0x4]
80005c9c:	f0 ca ff fe 	sub	r10,r8,-2
80005ca0:	49 69       	lddpc	r9,80005cf8 <fat_mount+0x2d8>
80005ca2:	93 3a       	st.w	r9[0xc],r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
80005ca4:	e0 48 0f f4 	cp.w	r8,4084
80005ca8:	e0 8b 00 07 	brhi	80005cb6 <fat_mount+0x296>
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
80005cac:	30 19       	mov	r9,1
80005cae:	49 58       	lddpc	r8,80005d00 <fat_mount+0x2e0>
80005cb0:	b0 89       	st.b	r8[0x0],r9
80005cb2:	30 1c       	mov	r12,1
80005cb4:	c1 f8       	rjmp	80005cf2 <fat_mount+0x2d2>
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
80005cb6:	e0 48 ff f4 	cp.w	r8,65524
80005cba:	e0 8b 00 07 	brhi	80005cc8 <fat_mount+0x2a8>
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
80005cbe:	30 29       	mov	r9,2
80005cc0:	49 08       	lddpc	r8,80005d00 <fat_mount+0x2e0>
80005cc2:	b0 89       	st.b	r8[0x0],r9
80005cc4:	30 1c       	mov	r12,1
80005cc6:	c1 68       	rjmp	80005cf2 <fat_mount+0x2d2>
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
80005cc8:	30 39       	mov	r9,3
80005cca:	48 e8       	lddpc	r8,80005d00 <fat_mount+0x2e0>
80005ccc:	b0 89       	st.b	r8[0x0],r9
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
80005cce:	48 b8       	lddpc	r8,80005cf8 <fat_mount+0x2d8>
80005cd0:	2e 88       	sub	r8,-24
80005cd2:	48 f9       	lddpc	r9,80005d0c <fat_mount+0x2ec>
80005cd4:	f3 3a 00 2c 	ld.ub	r10,r9[44]
80005cd8:	b0 ba       	st.b	r8[0x3],r10
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
80005cda:	f3 3a 00 2d 	ld.ub	r10,r9[45]
80005cde:	b0 aa       	st.b	r8[0x2],r10
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
80005ce0:	f3 3a 00 2e 	ld.ub	r10,r9[46]
80005ce4:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
80005ce6:	f3 39 00 2f 	ld.ub	r9,r9[47]
80005cea:	b0 89       	st.b	r8[0x0],r9
80005cec:	30 1c       	mov	r12,1
80005cee:	c0 28       	rjmp	80005cf2 <fat_mount+0x2d2>
80005cf0:	30 0c       	mov	r12,0
   }
   }

   return true;
}
80005cf2:	2f dd       	sub	sp,-12
80005cf4:	d8 32       	popm	r0-r7,pc
80005cf6:	00 00       	add	r0,r0
80005cf8:	00 00       	add	r0,r0
80005cfa:	0c e8       	st.h	--r6,r8
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	49 2c       	lddpc	r12,80005d44 <file_close+0x4>
80005d00:	00 00       	add	r0,r0
80005d02:	0d 34       	ld.ub	r4,r6++
80005d04:	00 00       	add	r0,r0
80005d06:	0a a4       	st.w	r5++,r4
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	57 50       	stdsp	sp[0x1d4],r0
80005d0c:	00 00       	add	r0,r0
80005d0e:	0a e8       	st.h	--r5,r8
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	4f c0       	lddpc	r0,80005f00 <nav_file_name+0xc>
80005d14:	00 00       	add	r0,r0
80005d16:	0d 38       	ld.ub	r8,r6++
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	69 90       	ld.w	r0,r4[0x64]

80005d1c <file_eof>:
//! @return    1     the position is at the end of file
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
80005d1c:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
80005d1e:	f0 1f 00 07 	mcall	80005d38 <file_eof+0x1c>
80005d22:	c0 41       	brne	80005d2a <file_eof+0xe>
80005d24:	e0 6c 00 ff 	mov	r12,255
80005d28:	d8 02       	popm	pc
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
80005d2a:	48 58       	lddpc	r8,80005d3c <file_eof+0x20>
80005d2c:	70 29       	ld.w	r9,r8[0x8]
80005d2e:	70 38       	ld.w	r8,r8[0xc]
80005d30:	10 39       	cp.w	r9,r8
80005d32:	5f 8c       	srls	r12
}
80005d34:	d8 02       	popm	pc
80005d36:	00 00       	add	r0,r0
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	58 94       	cp.w	r4,9
80005d3c:	00 00       	add	r0,r0
80005d3e:	0a a8       	st.w	r5++,r8

80005d40 <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
80005d40:	d4 01       	pushm	lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
80005d42:	f0 1f 00 0a 	mcall	80005d68 <file_close+0x28>
80005d46:	c1 00       	breq	80005d66 <file_close+0x26>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
80005d48:	48 98       	lddpc	r8,80005d6c <file_close+0x2c>
80005d4a:	11 88       	ld.ub	r8,r8[0x0]
80005d4c:	e2 18 00 02 	andl	r8,0x2,COH
80005d50:	c0 80       	breq	80005d60 <file_close+0x20>
      {
         // Write file information
         if( !fat_read_dir() )
80005d52:	f0 1f 00 08 	mcall	80005d70 <file_close+0x30>
80005d56:	c0 80       	breq	80005d66 <file_close+0x26>
            return;           // error
         fat_write_entry_file();
80005d58:	f0 1f 00 07 	mcall	80005d74 <file_close+0x34>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
80005d5c:	f0 1f 00 07 	mcall	80005d78 <file_close+0x38>
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
80005d60:	30 09       	mov	r9,0
80005d62:	48 38       	lddpc	r8,80005d6c <file_close+0x2c>
80005d64:	b0 89       	st.b	r8[0x0],r9
80005d66:	d8 02       	popm	pc
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	58 94       	cp.w	r4,9
80005d6c:	00 00       	add	r0,r0
80005d6e:	0a a8       	st.w	r5++,r8
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	55 f0       	stdsp	sp[0x17c],r0
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	4d b0       	lddpc	r0,80005ee0 <nav_file_checkext+0x24>
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	4f 54       	lddpc	r4,80005f4c <nav_file_name+0x58>

80005d7c <file_getc>:
//!
//! @return    The byte read
//! @return    EOF, in case of error or end of file
//!
uint16_t   file_getc( void )
{
80005d7c:	d4 01       	pushm	lr
   uint16_t   u16_byte;

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
80005d7e:	49 78       	lddpc	r8,80005dd8 <file_getc+0x5c>
80005d80:	11 88       	ld.ub	r8,r8[0x0]
80005d82:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005d86:	c0 51       	brne	80005d90 <file_getc+0x14>
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
80005d88:	31 e9       	mov	r9,30
80005d8a:	49 58       	lddpc	r8,80005ddc <file_getc+0x60>
80005d8c:	b0 89       	st.b	r8[0x0],r9
80005d8e:	dc 0a       	popm	pc,r12=-1
         break;
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
80005d90:	49 28       	lddpc	r8,80005dd8 <file_getc+0x5c>
80005d92:	70 29       	ld.w	r9,r8[0x8]
80005d94:	70 38       	ld.w	r8,r8[0xc]
80005d96:	10 39       	cp.w	r9,r8
80005d98:	e0 8b 00 06 	brhi	80005da4 <file_getc+0x28>
      {
         fs_g_status = FS_ERR_EOF;
80005d9c:	32 09       	mov	r9,32
80005d9e:	49 08       	lddpc	r8,80005ddc <file_getc+0x60>
80005da0:	b0 89       	st.b	r8[0x0],r9
80005da2:	dc 0a       	popm	pc,r12=-1
         break;
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
80005da4:	30 2c       	mov	r12,2
80005da6:	f0 1f 00 0f 	mcall	80005de0 <file_getc+0x64>
80005daa:	c0 c1       	brne	80005dc2 <file_getc+0x46>
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
80005dac:	48 c8       	lddpc	r8,80005ddc <file_getc+0x60>
80005dae:	11 89       	ld.ub	r9,r8[0x0]
80005db0:	31 a8       	mov	r8,26
80005db2:	f0 09 18 00 	cp.b	r9,r8
80005db6:	c0 20       	breq	80005dba <file_getc+0x3e>
80005db8:	dc 0a       	popm	pc,r12=-1
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
80005dba:	32 09       	mov	r9,32
80005dbc:	48 88       	lddpc	r8,80005ddc <file_getc+0x60>
80005dbe:	b0 89       	st.b	r8[0x0],r9
80005dc0:	dc 0a       	popm	pc,r12=-1
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
80005dc2:	48 68       	lddpc	r8,80005dd8 <file_getc+0x5c>
80005dc4:	70 39       	ld.w	r9,r8[0xc]
80005dc6:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
80005dca:	48 7b       	lddpc	r11,80005de4 <file_getc+0x68>
80005dcc:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
      fs_g_nav_entry.u32_pos_in_file++;
80005dd0:	2f f9       	sub	r9,-1
80005dd2:	91 39       	st.w	r8[0xc],r9
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
80005dd4:	d8 02       	popm	pc
80005dd6:	00 00       	add	r0,r0
80005dd8:	00 00       	add	r0,r0
80005dda:	0a a8       	st.w	r5++,r8
80005ddc:	00 00       	add	r0,r0
80005dde:	0d 38       	ld.ub	r8,r6++
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	56 74       	stdsp	sp[0x19c],r4
80005de4:	00 00       	add	r0,r0
80005de6:	0a e8       	st.h	--r5,r8

80005de8 <file_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
80005de8:	eb cd 40 c0 	pushm	r6-r7,lr
80005dec:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_noopen())
80005dee:	f0 1f 00 20 	mcall	80005e6c <file_open+0x84>
80005df2:	c3 a0       	breq	80005e66 <file_open+0x7e>
      return false;

   if( !fat_check_is_file())
80005df4:	f0 1f 00 1f 	mcall	80005e70 <file_open+0x88>
80005df8:	c3 70       	breq	80005e66 <file_open+0x7e>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
80005dfa:	0e 96       	mov	r6,r7
80005dfc:	0e 98       	mov	r8,r7
80005dfe:	e2 18 00 02 	andl	r8,0x2,COH
80005e02:	c1 90       	breq	80005e34 <file_open+0x4c>
   {
      if( !fat_check_nav_access_file( true ) )
80005e04:	30 1c       	mov	r12,1
80005e06:	f0 1f 00 1c 	mcall	80005e74 <file_open+0x8c>
80005e0a:	c2 e0       	breq	80005e66 <file_open+0x7e>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
80005e0c:	49 b8       	lddpc	r8,80005e78 <file_open+0x90>
80005e0e:	11 a8       	ld.ub	r8,r8[0x2]
80005e10:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e14:	c0 60       	breq	80005e20 <file_open+0x38>
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
80005e16:	31 59       	mov	r9,21
80005e18:	49 98       	lddpc	r8,80005e7c <file_open+0x94>
80005e1a:	b0 89       	st.b	r8[0x0],r9
80005e1c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
80005e20:	49 88       	lddpc	r8,80005e80 <file_open+0x98>
80005e22:	11 8c       	ld.ub	r12,r8[0x0]
80005e24:	f0 1f 00 18 	mcall	80005e84 <file_open+0x9c>
80005e28:	c0 a0       	breq	80005e3c <file_open+0x54>
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
80005e2a:	31 49       	mov	r9,20
80005e2c:	49 48       	lddpc	r8,80005e7c <file_open+0x94>
80005e2e:	b0 89       	st.b	r8[0x0],r9
80005e30:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
80005e34:	30 0c       	mov	r12,0
80005e36:	f0 1f 00 10 	mcall	80005e74 <file_open+0x8c>
80005e3a:	c1 60       	breq	80005e66 <file_open+0x7e>
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
80005e3c:	0c 98       	mov	r8,r6
80005e3e:	e2 18 00 04 	andl	r8,0x4,COH
80005e42:	c0 40       	breq	80005e4a <file_open+0x62>
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
80005e44:	30 09       	mov	r9,0
80005e46:	48 d8       	lddpc	r8,80005e78 <file_open+0x90>
80005e48:	91 29       	st.w	r8[0x8],r9
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
80005e4a:	e2 16 00 08 	andl	r6,0x8,COH
80005e4e:	c0 50       	breq	80005e58 <file_open+0x70>
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
80005e50:	30 09       	mov	r9,0
80005e52:	48 a8       	lddpc	r8,80005e78 <file_open+0x90>
80005e54:	91 39       	st.w	r8[0xc],r9
80005e56:	c0 48       	rjmp	80005e5e <file_open+0x76>
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
80005e58:	48 88       	lddpc	r8,80005e78 <file_open+0x90>
80005e5a:	70 29       	ld.w	r9,r8[0x8]
80005e5c:	91 39       	st.w	r8[0xc],r9
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
80005e5e:	48 78       	lddpc	r8,80005e78 <file_open+0x90>
80005e60:	b0 87       	st.b	r8[0x0],r7
80005e62:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   return true;
80005e66:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80005e6a:	00 00       	add	r0,r0
80005e6c:	80 00       	ld.sh	r0,r0[0x0]
80005e6e:	58 b8       	cp.w	r8,11
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	46 44       	lddsp	r4,sp[0x190]
80005e74:	80 00       	ld.sh	r0,r0[0x0]
80005e76:	4e 00       	lddpc	r0,80005ff4 <nav_filelist_set+0xc>
80005e78:	00 00       	add	r0,r0
80005e7a:	0a a8       	st.w	r5++,r8
80005e7c:	00 00       	add	r0,r0
80005e7e:	0d 38       	ld.ub	r8,r6++
80005e80:	00 00       	add	r0,r0
80005e82:	0c e8       	st.h	--r6,r8
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	69 4c       	ld.w	r12,r4[0x50]

80005e88 <nav_drive_get>:
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
80005e88:	48 28       	lddpc	r8,80005e90 <nav_drive_get+0x8>
80005e8a:	11 8c       	ld.ub	r12,r8[0x0]
80005e8c:	5e fc       	retal	r12
80005e8e:	00 00       	add	r0,r0
80005e90:	00 00       	add	r0,r0
80005e92:	0c e8       	st.h	--r6,r8

80005e94 <nav_drive_getname>:
//! @return    'A','B',...
//! @return    'X', in case of no drive selected
//!
uint8_t    nav_drive_getname( void )
{
   if(0xFF == fs_g_nav.u8_lun)
80005e94:	48 68       	lddpc	r8,80005eac <nav_drive_getname+0x18>
80005e96:	11 8c       	ld.ub	r12,r8[0x0]
80005e98:	3f f8       	mov	r8,-1
80005e9a:	f0 0c 18 00 	cp.b	r12,r8
80005e9e:	c0 31       	brne	80005ea4 <nav_drive_getname+0x10>
80005ea0:	35 8c       	mov	r12,88
80005ea2:	5e fc       	retal	r12
      return 'X';
#if (FS_MULTI_PARTITION  ==  true)
   return ('A' + (fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return ('A' + fs_g_nav.u8_lun);
80005ea4:	2b fc       	sub	r12,-65
80005ea6:	5c 5c       	castu.b	r12
#endif
}
80005ea8:	5e fc       	retal	r12
80005eaa:	00 00       	add	r0,r0
80005eac:	00 00       	add	r0,r0
80005eae:	0c e8       	st.h	--r6,r8

80005eb0 <nav_filelist_get>:
//! @return    FS_NO_SEL, in case of no file selected
//!
uint16_t   nav_filelist_get( void )
{
   return fs_g_nav.u16_pos_sel_file;
}
80005eb0:	48 28       	lddpc	r8,80005eb8 <nav_filelist_get+0x8>
80005eb2:	f1 0c 00 24 	ld.sh	r12,r8[36]
80005eb6:	5e fc       	retal	r12
80005eb8:	00 00       	add	r0,r0
80005eba:	0c e8       	st.h	--r6,r8

80005ebc <nav_file_checkext>:
//!
//! @return    true, the file extension match with extension filter
//! @return    false, in other case
//!
bool  nav_file_checkext( const FS_STRING sz_filterext )
{
80005ebc:	eb cd 40 80 	pushm	r7,lr
80005ec0:	18 97       	mov	r7,r12
   if ( fat_check_mount_select() )
80005ec2:	f0 1f 00 07 	mcall	80005edc <nav_file_checkext+0x20>
80005ec6:	c0 90       	breq	80005ed8 <nav_file_checkext+0x1c>
   {
      // Read selected entry (=short name entry) in directory
      if ( fat_read_dir())
80005ec8:	f0 1f 00 06 	mcall	80005ee0 <nav_file_checkext+0x24>
80005ecc:	c0 60       	breq	80005ed8 <nav_file_checkext+0x1c>
      {
         // Check the extension with filter
         if ( fat_entry_checkext( (FS_STRING) sz_filterext ) )
80005ece:	0e 9c       	mov	r12,r7
80005ed0:	f0 1f 00 05 	mcall	80005ee4 <nav_file_checkext+0x28>
80005ed4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ed8:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	58 7c       	cp.w	r12,7
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	55 f0       	stdsp	sp[0x17c],r0
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	4c 8c       	lddpc	r12,80006004 <nav_filelist_set+0x1c>

80005ee8 <nav_file_isdir>:
//!
//! @return    true, it is a directory
//! @return    false, in other case
//!
bool  nav_file_isdir( void )
{
80005ee8:	d4 01       	pushm	lr
   return fat_entry_is_dir();
80005eea:	f0 1f 00 02 	mcall	80005ef0 <nav_file_isdir+0x8>
}
80005eee:	d8 02       	popm	pc
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	49 14       	lddpc	r4,80005f34 <nav_file_name+0x40>

80005ef4 <nav_file_name>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_file_name( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case  )
{
80005ef4:	d4 31       	pushm	r0-r7,lr
80005ef6:	20 1d       	sub	sp,4
80005ef8:	18 95       	mov	r5,r12
80005efa:	16 96       	mov	r6,r11
80005efc:	14 97       	mov	r7,r10
80005efe:	12 93       	mov	r3,r9
   _MEM_TYPE_SLOW_   uint16_t u16_lgt;   // Only used if LENGTH string mode enabled
   uint16_t  u16_ptr_save_entry;
   bool  b_readshortname = false;

   if ( !fat_check_mount_select())
80005f00:	f0 1f 00 2f 	mcall	80005fbc <nav_file_name+0xc8>
80005f04:	c5 80       	breq	80005fb4 <nav_file_name+0xc0>
      return false;

   // Check if the string size is not 0
   if( (FS_NAME_GET == b_mode)
80005f06:	58 07       	cp.w	r7,0
80005f08:	c0 50       	breq	80005f12 <nav_file_name+0x1e>
80005f0a:	58 06       	cp.w	r6,0
80005f0c:	c0 31       	brne	80005f12 <nav_file_name+0x1e>
80005f0e:	30 1c       	mov	r12,1
80005f10:	c5 38       	rjmp	80005fb6 <nav_file_name+0xc2>
   {
      return true;
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
80005f12:	4a c8       	lddpc	r8,80005fc0 <nav_file_name+0xcc>
80005f14:	90 14       	ld.sh	r4,r8[0x2]
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
80005f16:	58 04       	cp.w	r4,0
80005f18:	c0 31       	brne	80005f1e <nav_file_name+0x2a>
80005f1a:	30 10       	mov	r0,1
80005f1c:	c0 68       	rjmp	80005f28 <nav_file_name+0x34>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80005f1e:	08 99       	mov	r9,r4
80005f20:	20 19       	sub	r9,1
80005f22:	4a 88       	lddpc	r8,80005fc0 <nav_file_name+0xcc>
80005f24:	b0 19       	st.h	r8[0x2],r9
80005f26:	30 00       	mov	r0,0
80005f28:	30 09       	mov	r9,0
80005f2a:	50 09       	stdsp	sp[0x0],r9
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
80005f2c:	31 01       	mov	r1,16
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80005f2e:	4a 52       	lddpc	r2,80005fc0 <nav_file_name+0xcc>
80005f30:	c0 28       	rjmp	80005f34 <nav_file_name+0x40>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80005f32:	30 10       	mov	r0,1

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
80005f34:	f0 1f 00 24 	mcall	80005fc4 <nav_file_name+0xd0>
80005f38:	c3 e0       	breq	80005fb4 <nav_file_name+0xc0>
         break; // error

      if ( b_readshortname )
80005f3a:	58 00       	cp.w	r0,0
80005f3c:	c0 70       	breq	80005f4a <nav_file_name+0x56>
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
80005f3e:	0e 9a       	mov	r10,r7
80005f40:	0c 9b       	mov	r11,r6
80005f42:	0a 9c       	mov	r12,r5
80005f44:	f0 1f 00 21 	mcall	80005fc8 <nav_file_name+0xd4>
80005f48:	c3 78       	rjmp	80005fb6 <nav_file_name+0xc2>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
80005f4a:	06 99       	mov	r9,r3
80005f4c:	0e 9a       	mov	r10,r7
80005f4e:	0c 9b       	mov	r11,r6
80005f50:	0a 9c       	mov	r12,r5
80005f52:	f0 1f 00 1f 	mcall	80005fcc <nav_file_name+0xd8>
80005f56:	c1 20       	breq	80005f7a <nav_file_name+0x86>
      {
         if( g_b_string_length )
80005f58:	49 e8       	lddpc	r8,80005fd0 <nav_file_name+0xdc>
80005f5a:	11 89       	ld.ub	r9,r8[0x0]
80005f5c:	30 08       	mov	r8,0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
80005f5e:	f0 09 18 00 	cp.b	r9,r8
80005f62:	eb f8 12 00 	ld.shne	r8,r5[0x0]
80005f66:	fb f9 10 00 	ld.wne	r9,sp[0x0]
80005f6a:	f1 d9 e1 08 	addne	r8,r8,r9
80005f6e:	eb f8 1c 00 	st.hne	r5[0x0],r8
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
80005f72:	49 48       	lddpc	r8,80005fc0 <nav_file_name+0xcc>
80005f74:	b0 14       	st.h	r8[0x2],r4
80005f76:	30 1c       	mov	r12,1
         return true;
80005f78:	c1 f8       	rjmp	80005fb6 <nav_file_name+0xc2>
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
80005f7a:	49 79       	lddpc	r9,80005fd4 <nav_file_name+0xe0>
80005f7c:	13 88       	ld.ub	r8,r9[0x0]
80005f7e:	e2 08 18 00 	cp.b	r8,r1
80005f82:	c0 70       	breq	80005f90 <nav_file_name+0x9c>
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
80005f84:	a4 14       	st.h	r2[0x2],r4

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
80005f86:	30 b9       	mov	r9,11
80005f88:	f2 08 18 00 	cp.b	r8,r9
80005f8c:	c1 41       	brne	80005fb4 <nav_file_name+0xc0>
80005f8e:	cd 2b       	rjmp	80005f32 <nav_file_name+0x3e>
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
80005f90:	49 09       	lddpc	r9,80005fd0 <nav_file_name+0xdc>
80005f92:	13 88       	ld.ub	r8,r9[0x0]
80005f94:	30 09       	mov	r9,0
80005f96:	f2 08 18 00 	cp.b	r8,r9
80005f9a:	c0 60       	breq	80005fa6 <nav_file_name+0xb2>
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
80005f9c:	40 08       	lddsp	r8,sp[0x0]
80005f9e:	2f 38       	sub	r8,-13
80005fa0:	5c 88       	casts.h	r8
80005fa2:	50 08       	stdsp	sp[0x0],r8
80005fa4:	c0 48       	rjmp	80005fac <nav_file_name+0xb8>
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
80005fa6:	2f 35       	sub	r5,-13
         u8_size_max -= FS_SIZE_LFN_ENTRY;
80005fa8:	20 d6       	sub	r6,13
80005faa:	5c 56       	castu.b	r6
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80005fac:	84 18       	ld.sh	r8,r2[0x2]
80005fae:	20 18       	sub	r8,1
80005fb0:	a4 18       	st.h	r2[0x2],r8
80005fb2:	cc 1b       	rjmp	80005f34 <nav_file_name+0x40>
80005fb4:	30 0c       	mov	r12,0

   }  // end of loop while(1)
   return false;
}
80005fb6:	2f fd       	sub	sp,-4
80005fb8:	d8 32       	popm	r0-r7,pc
80005fba:	00 00       	add	r0,r0
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	58 7c       	cp.w	r12,7
80005fc0:	00 00       	add	r0,r0
80005fc2:	0d 34       	ld.ub	r4,r6++
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	55 f0       	stdsp	sp[0x17c],r0
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	4b 3c       	lddpc	r12,80006094 <nav_filelist_set+0xac>
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	49 a8       	lddpc	r8,80006034 <nav_filelist_set+0x4c>
80005fd0:	00 00       	add	r0,r0
80005fd2:	0d 39       	ld.ub	r9,r6++
80005fd4:	00 00       	add	r0,r0
80005fd6:	0d 38       	ld.ub	r8,r6++

80005fd8 <nav_file_getname>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool nav_file_getname( FS_STRING sz_name, uint8_t u8_size_max )
{
80005fd8:	d4 01       	pushm	lr
   return nav_file_name( sz_name, u8_size_max, FS_NAME_GET, false );
80005fda:	30 09       	mov	r9,0
80005fdc:	30 1a       	mov	r10,1
80005fde:	f0 1f 00 02 	mcall	80005fe4 <nav_file_getname+0xc>
}
80005fe2:	d8 02       	popm	pc
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	5e f4       	retal	r4

80005fe8 <nav_filelist_set>:
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
80005fe8:	d4 31       	pushm	r0-r7,lr
80005fea:	20 4d       	sub	sp,16
80005fec:	50 0c       	stdsp	sp[0x0],r12
80005fee:	16 92       	mov	r2,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
80005ff0:	f0 1f 00 51 	mcall	80006134 <nav_filelist_set+0x14c>
80005ff4:	e0 80 00 9e 	breq	80006130 <nav_filelist_set+0x148>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
80005ff8:	4d 08       	lddpc	r8,80006138 <nav_filelist_set+0x150>
80005ffa:	90 18       	ld.sh	r8,r8[0x2]
80005ffc:	50 28       	stdsp	sp[0x8],r8
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
80005ffe:	4d 08       	lddpc	r8,8000613c <nav_filelist_set+0x154>
80006000:	f1 0a 00 24 	ld.sh	r10,r8[36]
80006004:	50 1a       	stdsp	sp[0x4],r10
   b_save_entry_type       = fs_g_nav.b_mode_nav;
80006006:	f1 38 00 2c 	ld.ub	r8,r8[44]
8000600a:	50 38       	stdsp	sp[0xc],r8
8000600c:	30 03       	mov	r3,0
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
8000600e:	4c b7       	lddpc	r7,80006138 <nav_filelist_set+0x150>
80006010:	3f f0       	mov	r0,-1
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
80006012:	4c b6       	lddpc	r6,8000613c <nav_filelist_set+0x154>
80006014:	30 04       	mov	r4,0
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
80006016:	3f e1       	mov	r1,-2
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
80006018:	4c a5       	lddpc	r5,80006140 <nav_filelist_set+0x158>
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000601a:	58 02       	cp.w	r2,0
8000601c:	c0 31       	brne	80006022 <nav_filelist_set+0x3a>
8000601e:	58 03       	cp.w	r3,0
80006020:	c0 c0       	breq	80006038 <nav_filelist_set+0x50>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
80006022:	8e 18       	ld.sh	r8,r7[0x2]
80006024:	e2 08 19 00 	cp.h	r8,r1
80006028:	c0 51       	brne	80006032 <nav_filelist_set+0x4a>
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
8000602a:	30 89       	mov	r9,8
8000602c:	4c 58       	lddpc	r8,80006140 <nav_filelist_set+0x158>
8000602e:	b0 89       	st.b	r8[0x0],r9
            break;
80006030:	c7 38       	rjmp	80006116 <nav_filelist_set+0x12e>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
80006032:	2f f8       	sub	r8,-1
80006034:	ae 18       	st.h	r7[0x2],r8
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
80006036:	c1 d8       	rjmp	80006070 <nav_filelist_set+0x88>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
80006038:	8e 18       	ld.sh	r8,r7[0x2]
8000603a:	e0 08 19 00 	cp.h	r8,r0
8000603e:	c0 51       	brne	80006048 <nav_filelist_set+0x60>
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
80006040:	30 99       	mov	r9,9
80006042:	4c 08       	lddpc	r8,80006140 <nav_filelist_set+0x158>
80006044:	b0 89       	st.b	r8[0x0],r9
            break;
80006046:	c6 88       	rjmp	80006116 <nav_filelist_set+0x12e>
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
80006048:	58 08       	cp.w	r8,0
8000604a:	c1 11       	brne	8000606c <nav_filelist_set+0x84>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000604c:	ed 38 00 2c 	ld.ub	r8,r6[44]
80006050:	e8 08 18 00 	cp.b	r8,r4
80006054:	c0 80       	breq	80006064 <nav_filelist_set+0x7c>
80006056:	ed 38 00 2d 	ld.ub	r8,r6[45]
8000605a:	e8 08 18 00 	cp.b	r8,r4
8000605e:	c0 31       	brne	80006064 <nav_filelist_set+0x7c>
80006060:	30 13       	mov	r3,1
80006062:	c0 78       	rjmp	80006070 <nav_filelist_set+0x88>
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
80006064:	30 99       	mov	r9,9
80006066:	4b 78       	lddpc	r8,80006140 <nav_filelist_set+0x158>
80006068:	b0 89       	st.b	r8[0x0],r9
               break;
8000606a:	c5 68       	rjmp	80006116 <nav_filelist_set+0x12e>
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
8000606c:	20 18       	sub	r8,1
8000606e:	ae 18       	st.h	r7[0x2],r8
         }
      }

      if( !fat_read_dir())
80006070:	f0 1f 00 35 	mcall	80006144 <nav_filelist_set+0x15c>
80006074:	c0 71       	brne	80006082 <nav_filelist_set+0x9a>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
80006076:	0b 89       	ld.ub	r9,r5[0x0]
80006078:	31 a8       	mov	r8,26
8000607a:	f0 09 18 00 	cp.b	r9,r8
8000607e:	c3 20       	breq	800060e2 <nav_filelist_set+0xfa>
80006080:	c4 b8       	rjmp	80006116 <nav_filelist_set+0x12e>
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
80006082:	ed 38 00 2c 	ld.ub	r8,r6[44]
80006086:	e8 08 18 00 	cp.b	r8,r4
8000608a:	5f 1c       	srne	r12
8000608c:	f0 1f 00 2f 	mcall	80006148 <nav_filelist_set+0x160>
80006090:	c1 c0       	breq	800060c8 <nav_filelist_set+0xe0>
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
80006092:	58 03       	cp.w	r3,0
80006094:	cc 31       	brne	8000601a <nav_filelist_set+0x32>
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
80006096:	58 02       	cp.w	r2,0
80006098:	ed f8 12 12 	ld.shne	r8,r6[0x24]
8000609c:	f7 b8 01 ff 	subne	r8,-1
800060a0:	ed f8 1c 12 	st.hne	r6[0x24],r8
           else
              fs_g_nav.u16_pos_sel_file--;
800060a4:	ed f8 02 12 	ld.sheq	r8,r6[0x24]
800060a8:	f7 b8 00 01 	subeq	r8,1
800060ac:	ed f8 0c 12 	st.heq	r6[0x24],r8

           if (0 == u16_nb)
800060b0:	40 09       	lddsp	r9,sp[0x0]
800060b2:	58 09       	cp.w	r9,0
800060b4:	c0 51       	brne	800060be <nav_filelist_set+0xd6>
           {
              // It is the end of move then update file information
              fat_get_entry_info();
800060b6:	f0 1f 00 26 	mcall	8000614c <nav_filelist_set+0x164>
800060ba:	30 1c       	mov	r12,1
              return true;         // NB FILE FIND
800060bc:	c3 a8       	rjmp	80006130 <nav_filelist_set+0x148>
           }
           u16_nb--;
800060be:	40 08       	lddsp	r8,sp[0x0]
800060c0:	20 18       	sub	r8,1
800060c2:	5c 88       	casts.h	r8
800060c4:	50 08       	stdsp	sp[0x0],r8
           continue;
800060c6:	ca ab       	rjmp	8000601a <nav_filelist_set+0x32>
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
800060c8:	0b 88       	ld.ub	r8,r5[0x0]
800060ca:	30 a9       	mov	r9,10
800060cc:	f2 08 18 00 	cp.b	r8,r9
800060d0:	5f 09       	sreq	r9
800060d2:	31 aa       	mov	r10,26
800060d4:	f4 08 18 00 	cp.b	r8,r10
800060d8:	5f 08       	sreq	r8
800060da:	10 49       	or	r9,r8
800060dc:	e8 09 18 00 	cp.b	r9,r4
800060e0:	c9 d0       	breq	8000601a <nav_filelist_set+0x32>
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
800060e2:	58 03       	cp.w	r3,0
800060e4:	c0 50       	breq	800060ee <nav_filelist_set+0x106>
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
800060e6:	ed 64 00 2c 	st.b	r6[44],r4
800060ea:	30 03       	mov	r3,0
            continue;
800060ec:	c9 7b       	rjmp	8000601a <nav_filelist_set+0x32>
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
800060ee:	ed 38 00 2c 	ld.ub	r8,r6[44]
800060f2:	30 1a       	mov	r10,1
800060f4:	f4 08 18 00 	cp.b	r8,r10
800060f8:	c0 60       	breq	80006104 <nav_filelist_set+0x11c>
800060fa:	ed 38 00 2d 	ld.ub	r8,r6[45]
800060fe:	e8 08 18 00 	cp.b	r8,r4
80006102:	c0 50       	breq	8000610c <nav_filelist_set+0x124>
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
80006104:	30 99       	mov	r9,9
80006106:	48 f8       	lddpc	r8,80006140 <nav_filelist_set+0x158>
80006108:	b0 89       	st.b	r8[0x0],r9
            break;                        // end of search
8000610a:	c0 68       	rjmp	80006116 <nav_filelist_set+0x12e>
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
8000610c:	ae 10       	st.h	r7[0x2],r0
            fs_g_nav.b_mode_nav = FS_FILE;
8000610e:	30 19       	mov	r9,1
80006110:	ed 69 00 2c 	st.b	r6[44],r9
80006114:	c8 3b       	rjmp	8000601a <nav_filelist_set+0x32>
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
80006116:	48 a8       	lddpc	r8,8000613c <nav_filelist_set+0x154>
80006118:	40 3a       	lddsp	r10,sp[0xc]
8000611a:	58 0a       	cp.w	r10,0
8000611c:	5f 19       	srne	r9
8000611e:	f1 69 00 2c 	st.b	r8[44],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
80006122:	48 69       	lddpc	r9,80006138 <nav_filelist_set+0x150>
80006124:	40 2a       	lddsp	r10,sp[0x8]
80006126:	b2 1a       	st.h	r9[0x2],r10
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
80006128:	40 19       	lddsp	r9,sp[0x4]
8000612a:	f1 59 00 24 	st.h	r8[36],r9
8000612e:	30 0c       	mov	r12,0
   return false;
}
80006130:	2f cd       	sub	sp,-16
80006132:	d8 32       	popm	r0-r7,pc
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	58 dc       	cp.w	r12,13
80006138:	00 00       	add	r0,r0
8000613a:	0d 34       	ld.ub	r4,r6++
8000613c:	00 00       	add	r0,r0
8000613e:	0c e8       	st.h	--r6,r8
80006140:	00 00       	add	r0,r0
80006142:	0d 38       	ld.ub	r8,r6++
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	55 f0       	stdsp	sp[0x17c],r0
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	4d 2c       	lddpc	r12,80006290 <nav_dir_name+0x88>
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	4c 44       	lddpc	r4,8000625c <nav_dir_name+0x54>

80006150 <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
80006150:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
80006152:	f0 1f 00 04 	mcall	80006160 <nav_filelist_reset+0x10>
80006156:	c0 40       	breq	8000615e <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
80006158:	f0 1f 00 03 	mcall	80006164 <nav_filelist_reset+0x14>
8000615c:	30 1c       	mov	r12,1
   return true;
}
8000615e:	d8 02       	popm	pc
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	58 dc       	cp.w	r12,13
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	49 2c       	lddpc	r12,800061ac <nav_dir_gotoparent+0x44>

80006168 <nav_dir_gotoparent>:
//! After, the file list changes and contains the files and directories of the new directory.
//! By default, the file selected in file list is the previous (children) directory.
//! @endverbatim
//!
bool  nav_dir_gotoparent( void )
{
80006168:	d4 21       	pushm	r4-r7,lr
   uint32_t u32_cluster_old_dir;

   if (!fat_check_mount_noopen())
8000616a:	f0 1f 00 1f 	mcall	800061e4 <nav_dir_gotoparent+0x7c>
8000616e:	c3 80       	breq	800061de <nav_dir_gotoparent+0x76>
      return false;

   if (0 == fs_g_nav.u32_cluster_sel_dir)
80006170:	49 e8       	lddpc	r8,800061e8 <nav_dir_gotoparent+0x80>
80006172:	70 88       	ld.w	r8,r8[0x20]
80006174:	58 08       	cp.w	r8,0
80006176:	c0 51       	brne	80006180 <nav_dir_gotoparent+0x18>
   {
      fs_g_status = FS_ERR_IS_ROOT;        // There aren't parent
80006178:	31 99       	mov	r9,25
8000617a:	49 d8       	lddpc	r8,800061ec <nav_dir_gotoparent+0x84>
8000617c:	b0 89       	st.b	r8[0x0],r9
8000617e:	d8 2a       	popm	r4-r7,pc,r12=0
      return false;
   }

   // Select and read information about directory ".."
   fs_g_nav_fast.u16_entry_pos_sel_file = 1;
80006180:	30 19       	mov	r9,1
80006182:	49 c8       	lddpc	r8,800061f0 <nav_dir_gotoparent+0x88>
80006184:	b0 19       	st.h	r8[0x2],r9
   if ( !fat_read_dir())
80006186:	f0 1f 00 1c 	mcall	800061f4 <nav_dir_gotoparent+0x8c>
8000618a:	c2 a0       	breq	800061de <nav_dir_gotoparent+0x76>
      return false;
   fat_get_entry_info();
8000618c:	f0 1f 00 1b 	mcall	800061f8 <nav_dir_gotoparent+0x90>
   // Save the children directory cluster
   u32_cluster_old_dir = fs_g_nav.u32_cluster_sel_dir;
80006190:	49 68       	lddpc	r8,800061e8 <nav_dir_gotoparent+0x80>
80006192:	70 87       	ld.w	r7,r8[0x20]

   // Select the parent directory via information present in the current directory ".."
   fs_g_nav.u32_cluster_sel_dir = fs_g_nav_entry.u32_cluster;
80006194:	49 a9       	lddpc	r9,800061fc <nav_dir_gotoparent+0x94>
80006196:	72 19       	ld.w	r9,r9[0x4]
80006198:	91 89       	st.w	r8[0x20],r9

   // Select the children directory in new directory (=parent directory)
   if( false == nav_filelist_reset())
8000619a:	f0 1f 00 1a 	mcall	80006200 <nav_dir_gotoparent+0x98>
8000619e:	c2 00       	breq	800061de <nav_dir_gotoparent+0x76>
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
800061a0:	49 28       	lddpc	r8,800061e8 <nav_dir_gotoparent+0x80>
800061a2:	f1 39 00 2d 	ld.ub	r9,r8[45]
800061a6:	30 08       	mov	r8,0
800061a8:	f0 09 18 00 	cp.b	r9,r8
800061ac:	c0 d0       	breq	800061c6 <nav_dir_gotoparent+0x5e>
800061ae:	48 f8       	lddpc	r8,800061e8 <nav_dir_gotoparent+0x80>
800061b0:	f1 39 00 2c 	ld.ub	r9,r8[44]
800061b4:	30 08       	mov	r8,0
800061b6:	f0 09 18 00 	cp.b	r9,r8
800061ba:	c0 60       	breq	800061c6 <nav_dir_gotoparent+0x5e>
800061bc:	c1 28       	rjmp	800061e0 <nav_dir_gotoparent+0x78>
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
800061be:	6c 18       	ld.w	r8,r6[0x4]
800061c0:	0e 38       	cp.w	r8,r7
800061c2:	c0 51       	brne	800061cc <nav_dir_gotoparent+0x64>
800061c4:	c0 e8       	rjmp	800061e0 <nav_dir_gotoparent+0x78>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800061c6:	30 15       	mov	r5,1
800061c8:	30 04       	mov	r4,0
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
800061ca:	48 d6       	lddpc	r6,800061fc <nav_dir_gotoparent+0x94>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800061cc:	0a 9b       	mov	r11,r5
800061ce:	08 9c       	mov	r12,r4
800061d0:	f0 1f 00 0d 	mcall	80006204 <nav_dir_gotoparent+0x9c>
800061d4:	cf 51       	brne	800061be <nav_dir_gotoparent+0x56>
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
         return true;         // It is the children directory
   }
   fs_g_status = FS_ERR_FS;
800061d6:	30 89       	mov	r9,8
800061d8:	48 58       	lddpc	r8,800061ec <nav_dir_gotoparent+0x84>
800061da:	b0 89       	st.b	r8[0x0],r9
   return false;
800061dc:	d8 22       	popm	r4-r7,pc
800061de:	d8 2a       	popm	r4-r7,pc,r12=0
800061e0:	da 2a       	popm	r4-r7,pc,r12=1
800061e2:	00 00       	add	r0,r0
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	58 dc       	cp.w	r12,13
800061e8:	00 00       	add	r0,r0
800061ea:	0c e8       	st.h	--r6,r8
800061ec:	00 00       	add	r0,r0
800061ee:	0d 38       	ld.ub	r8,r6++
800061f0:	00 00       	add	r0,r0
800061f2:	0d 34       	ld.ub	r4,r6++
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	55 f0       	stdsp	sp[0x17c],r0
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	4c 44       	lddpc	r4,80006308 <nav_dir_name+0x100>
800061fc:	00 00       	add	r0,r0
800061fe:	0a a8       	st.w	r5++,r8
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	61 50       	ld.w	r0,r0[0x54]
80006204:	80 00       	ld.sh	r0,r0[0x0]
80006206:	5f e8       	srqs	r8

80006208 <nav_dir_name>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_dir_name( FS_STRING sz_path  , uint8_t u8_size_max  )
{
80006208:	d4 31       	pushm	r0-r7,lr
8000620a:	20 2d       	sub	sp,8
8000620c:	18 96       	mov	r6,r12
8000620e:	16 95       	mov	r5,r11
   uint32_t save_u32_cluster      ;
   uint32_t save_u32_size         ;
   bool b_mode_nav_single_save;
   bool b_mode_nav_mode_save;

   if ( !fat_check_mount_noopen())
80006210:	f0 1f 00 37 	mcall	800062ec <nav_dir_name+0xe4>
80006214:	c6 a0       	breq	800062e8 <nav_dir_name+0xe0>
      return false;

   if (0 != fs_g_nav.u32_cluster_sel_dir)
80006216:	4b 78       	lddpc	r8,800062f0 <nav_dir_name+0xe8>
80006218:	70 87       	ld.w	r7,r8[0x20]
8000621a:	58 07       	cp.w	r7,0
8000621c:	c3 b0       	breq	80006292 <nav_dir_name+0x8a>
   {
      // Save context
      save_u16_entry_pos_sel_file= fs_g_nav_fast.u16_entry_pos_sel_file;
8000621e:	4b 68       	lddpc	r8,800062f4 <nav_dir_name+0xec>
80006220:	90 11       	ld.sh	r1,r8[0x2]
      save_u32_cluster_sel_dir   = fs_g_nav.u32_cluster_sel_dir        ;
      save_u8_attr               = fs_g_nav_entry.u8_attr              ;
80006222:	4b 68       	lddpc	r8,800062f8 <nav_dir_name+0xf0>
80006224:	11 a0       	ld.ub	r0,r8[0x2]
      save_u32_cluster           = fs_g_nav_entry.u32_cluster          ;
80006226:	70 19       	ld.w	r9,r8[0x4]
80006228:	50 19       	stdsp	sp[0x4],r9
      save_u32_size              = fs_g_nav_entry.u32_size             ;
8000622a:	70 28       	ld.w	r8,r8[0x8]
8000622c:	50 08       	stdsp	sp[0x0],r8
      b_mode_nav_single_save = fs_g_nav.b_mode_nav_single;
8000622e:	4b 18       	lddpc	r8,800062f0 <nav_dir_name+0xe8>
80006230:	f1 3a 00 2d 	ld.ub	r10,r8[45]
80006234:	30 09       	mov	r9,0
80006236:	f2 0a 18 00 	cp.b	r10,r9
8000623a:	5f 14       	srne	r4
      b_mode_nav_mode_save   = fs_g_nav.b_mode_nav;
8000623c:	f1 3a 00 2c 	ld.ub	r10,r8[44]
80006240:	f2 0a 18 00 	cp.b	r10,r9
80006244:	5f 13       	srne	r3
      fs_g_nav.b_mode_nav_single = true;
80006246:	30 19       	mov	r9,1
80006248:	f1 69 00 2d 	st.b	r8[45],r9
      fs_g_nav.b_mode_nav = FS_FILE;
8000624c:	f1 69 00 2c 	st.b	r8[44],r9
      // Go to parent directory and select the children directory
      if( !nav_dir_gotoparent() )
80006250:	f0 1f 00 2b 	mcall	800062fc <nav_dir_name+0xf4>
80006254:	c0 71       	brne	80006262 <nav_dir_name+0x5a>
      {
         fs_g_nav.b_mode_nav_single = b_mode_nav_single_save;
80006256:	4a 78       	lddpc	r8,800062f0 <nav_dir_name+0xe8>
80006258:	f1 64 00 2d 	st.b	r8[45],r4
         fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
8000625c:	f1 63 00 2c 	st.b	r8[44],r3
         return false;
80006260:	c4 48       	rjmp	800062e8 <nav_dir_name+0xe0>
      }
      fs_g_nav.b_mode_nav_single = b_mode_nav_single_save ;
80006262:	4a 42       	lddpc	r2,800062f0 <nav_dir_name+0xe8>
80006264:	e5 64 00 2d 	st.b	r2[45],r4
      fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
80006268:	e5 63 00 2c 	st.b	r2[44],r3
      // Go to directory name position
      fs_g_nav_fast.u16_entry_pos_sel_file = fs_g_nav.u16_entry_pos_sel_dir;
8000626c:	4a 24       	lddpc	r4,800062f4 <nav_dir_name+0xec>
8000626e:	e5 08 00 1c 	ld.sh	r8,r2[28]
80006272:	a8 18       	st.h	r4[0x2],r8
      status = nav_file_name( sz_path  , u8_size_max , FS_NAME_GET , false  );
80006274:	30 09       	mov	r9,0
80006276:	30 1a       	mov	r10,1
80006278:	0a 9b       	mov	r11,r5
8000627a:	0c 9c       	mov	r12,r6
8000627c:	f0 1f 00 21 	mcall	80006300 <nav_dir_name+0xf8>
      // Restore previous context
      fs_g_nav_fast.u16_entry_pos_sel_file= save_u16_entry_pos_sel_file;
80006280:	a8 11       	st.h	r4[0x2],r1
      fs_g_nav.u32_cluster_sel_dir        = save_u32_cluster_sel_dir   ;
80006282:	85 87       	st.w	r2[0x20],r7
      fs_g_nav_entry.u8_attr              = save_u8_attr               ;
80006284:	49 d8       	lddpc	r8,800062f8 <nav_dir_name+0xf0>
80006286:	b0 a0       	st.b	r8[0x2],r0
      fs_g_nav_entry.u32_cluster          = save_u32_cluster           ;
80006288:	40 19       	lddsp	r9,sp[0x4]
8000628a:	91 19       	st.w	r8[0x4],r9
      fs_g_nav_entry.u32_size             = save_u32_size              ;
8000628c:	40 09       	lddsp	r9,sp[0x0]
8000628e:	91 29       	st.w	r8[0x8],r9
80006290:	c2 c8       	rjmp	800062e8 <nav_dir_name+0xe0>
   }
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
80006292:	49 d8       	lddpc	r8,80006304 <nav_dir_name+0xfc>
80006294:	11 89       	ld.ub	r9,r8[0x0]
80006296:	30 08       	mov	r8,0
80006298:	f0 09 18 00 	cp.b	r9,r8
8000629c:	c0 50       	breq	800062a6 <nav_dir_name+0x9e>
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
8000629e:	30 38       	mov	r8,3
800062a0:	ac 08       	st.h	r6[0x0],r8
800062a2:	30 1c       	mov	r12,1
800062a4:	c2 28       	rjmp	800062e8 <nav_dir_name+0xe0>
800062a6:	2f f6       	sub	r6,-1
800062a8:	30 17       	mov	r7,1
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
800062aa:	30 04       	mov	r4,0
800062ac:	30 15       	mov	r5,1
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
800062ae:	30 23       	mov	r3,2
800062b0:	c0 48       	rjmp	800062b8 <nav_dir_name+0xb0>
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
800062b2:	2f f6       	sub	r6,-1
800062b4:	2f f7       	sub	r7,-1
800062b6:	5c 57       	castu.b	r7
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
800062b8:	0e 98       	mov	r8,r7
800062ba:	20 18       	sub	r8,1
800062bc:	e8 08 18 00 	cp.b	r8,r4
800062c0:	c0 e0       	breq	800062dc <nav_dir_name+0xd4>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
800062c2:	ea 08 18 00 	cp.b	r8,r5
800062c6:	f9 b8 00 3a 	moveq	r8,58
800062ca:	f9 b8 01 00 	movne	r8,0
800062ce:	ed 68 ff ff 	st.b	r6[-1],r8
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
800062d2:	e6 07 18 00 	cp.b	r7,r3
800062d6:	fe 98 ff ee 	brls	800062b2 <nav_dir_name+0xaa>
800062da:	c0 68       	rjmp	800062e6 <nav_dir_name+0xde>
      {
         switch( u8_i )
         {
            case 0:
            u8_character = nav_drive_getname();    // Letter
800062dc:	f0 1f 00 0b 	mcall	80006308 <nav_dir_name+0x100>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
800062e0:	ed 6c ff ff 	st.b	r6[-1],r12
800062e4:	ce 7b       	rjmp	800062b2 <nav_dir_name+0xaa>
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
800062e6:	30 1c       	mov	r12,1
      }
      status = true;

   }
   return status;
}
800062e8:	2f ed       	sub	sp,-8
800062ea:	d8 32       	popm	r0-r7,pc
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	58 dc       	cp.w	r12,13
800062f0:	00 00       	add	r0,r0
800062f2:	0c e8       	st.h	--r6,r8
800062f4:	00 00       	add	r0,r0
800062f6:	0d 34       	ld.ub	r4,r6++
800062f8:	00 00       	add	r0,r0
800062fa:	0a a8       	st.w	r5++,r8
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	61 68       	ld.w	r8,r0[0x58]
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	5e f4       	retal	r4
80006304:	00 00       	add	r0,r0
80006306:	0d 39       	ld.ub	r9,r6++
80006308:	80 00       	ld.sh	r0,r0[0x0]
8000630a:	5e 94       	retgt	r4

8000630c <nav_filelist_first>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_first( bool b_type )
{
8000630c:	d4 21       	pushm	r4-r7,lr
8000630e:	18 97       	mov	r7,r12
   // Reset position
   if ( !nav_filelist_reset())
80006310:	f0 1f 00 0b 	mcall	8000633c <nav_filelist_first+0x30>
80006314:	c0 71       	brne	80006322 <nav_filelist_first+0x16>
80006316:	d8 22       	popm	r4-r7,pc
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( b_type == fs_g_nav.b_mode_nav )
80006318:	e9 38 00 2c 	ld.ub	r8,r4[44]
8000631c:	10 37       	cp.w	r7,r8
8000631e:	c0 51       	brne	80006328 <nav_filelist_first+0x1c>
80006320:	da 2a       	popm	r4-r7,pc,r12=1
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80006322:	30 16       	mov	r6,1
80006324:	30 05       	mov	r5,0
   {
      if( b_type == fs_g_nav.b_mode_nav )
80006326:	48 74       	lddpc	r4,80006340 <nav_filelist_first+0x34>
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80006328:	0c 9b       	mov	r11,r6
8000632a:	0a 9c       	mov	r12,r5
8000632c:	f0 1f 00 06 	mcall	80006344 <nav_filelist_first+0x38>
80006330:	cf 41       	brne	80006318 <nav_filelist_first+0xc>
   {
      if( b_type == fs_g_nav.b_mode_nav )
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
80006332:	30 99       	mov	r9,9
80006334:	48 58       	lddpc	r8,80006348 <nav_filelist_first+0x3c>
80006336:	b0 89       	st.b	r8[0x0],r9
   return false;
}
80006338:	d8 22       	popm	r4-r7,pc
8000633a:	00 00       	add	r0,r0
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	61 50       	ld.w	r0,r0[0x54]
80006340:	00 00       	add	r0,r0
80006342:	0c e8       	st.h	--r6,r8
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	5f e8       	srqs	r8
80006348:	00 00       	add	r0,r0
8000634a:	0d 38       	ld.ub	r8,r6++

8000634c <nav_filelist_nb>:
//!                     FS_FILE to compute the number of files <br>
//!
//! @return    number of files or directories in file list
//!
uint16_t   nav_filelist_nb( bool b_type )
{
8000634c:	d4 31       	pushm	r0-r7,lr
8000634e:	18 90       	mov	r0,r12
   uint16_t   u16_save_position;
   uint16_t   u16_save_number_dir;
   uint16_t   u16_save_number_file;

   // Save current position
   u16_save_position = fs_g_nav.u16_pos_sel_file;
80006350:	49 88       	lddpc	r8,800063b0 <nav_filelist_nb+0x64>
80006352:	f1 01 00 24 	ld.sh	r1,r8[36]
   // Reset position
   if ( !nav_filelist_reset())
80006356:	f0 1f 00 18 	mcall	800063b4 <nav_filelist_nb+0x68>
8000635a:	c0 31       	brne	80006360 <nav_filelist_nb+0x14>
8000635c:	30 02       	mov	r2,0
8000635e:	c2 68       	rjmp	800063aa <nav_filelist_nb+0x5e>
80006360:	30 02       	mov	r2,0
80006362:	04 97       	mov	r7,r2
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80006364:	30 14       	mov	r4,1
80006366:	04 93       	mov	r3,r2
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
80006368:	49 26       	lddpc	r6,800063b0 <nav_filelist_nb+0x64>
8000636a:	30 15       	mov	r5,1
8000636c:	c0 b8       	rjmp	80006382 <nav_filelist_nb+0x36>
8000636e:	ed 38 00 2c 	ld.ub	r8,r6[44]
80006372:	ea 08 18 00 	cp.b	r8,r5
80006376:	c0 41       	brne	8000637e <nav_filelist_nb+0x32>
         u16_save_number_file++;    // It is a file
80006378:	2f f2       	sub	r2,-1
8000637a:	5c 82       	casts.h	r2
8000637c:	c0 38       	rjmp	80006382 <nav_filelist_nb+0x36>
      else
         u16_save_number_dir++;     // It is a directory
8000637e:	2f f7       	sub	r7,-1
80006380:	5c 87       	casts.h	r7
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80006382:	08 9b       	mov	r11,r4
80006384:	06 9c       	mov	r12,r3
80006386:	f0 1f 00 0d 	mcall	800063b8 <nav_filelist_nb+0x6c>
8000638a:	cf 21       	brne	8000636e <nav_filelist_nb+0x22>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
8000638c:	f0 1f 00 0a 	mcall	800063b4 <nav_filelist_nb+0x68>
   if ( u16_save_position != FS_NO_SEL )
80006390:	3f f8       	mov	r8,-1
80006392:	f0 01 19 00 	cp.h	r1,r8
80006396:	c0 60       	breq	800063a2 <nav_filelist_nb+0x56>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
80006398:	30 1b       	mov	r11,1
8000639a:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
8000639e:	f0 1f 00 07 	mcall	800063b8 <nav_filelist_nb+0x6c>
   }
   // Return the value asked
   if( FS_FILE == b_type )
800063a2:	58 00       	cp.w	r0,0
800063a4:	c0 31       	brne	800063aa <nav_filelist_nb+0x5e>
800063a6:	0e 92       	mov	r2,r7
800063a8:	5c 82       	casts.h	r2
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
800063aa:	04 9c       	mov	r12,r2
800063ac:	d8 32       	popm	r0-r7,pc
800063ae:	00 00       	add	r0,r0
800063b0:	00 00       	add	r0,r0
800063b2:	0c e8       	st.h	--r6,r8
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	61 50       	ld.w	r0,r0[0x54]
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	5f e8       	srqs	r8

800063bc <nav_filelist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filelist_goto( uint16_t u16_newpos )
{
800063bc:	eb cd 40 80 	pushm	r7,lr
800063c0:	18 97       	mov	r7,r12
   uint16_t u16_current_pos;

   if( FS_NO_SEL == u16_newpos )
800063c2:	3f f8       	mov	r8,-1
800063c4:	f0 0c 19 00 	cp.h	r12,r8
800063c8:	c0 51       	brne	800063d2 <nav_filelist_goto+0x16>
      return nav_filelist_reset();
800063ca:	f0 1f 00 1d 	mcall	8000643c <nav_filelist_goto+0x80>
800063ce:	e3 cd 80 80 	ldm	sp++,r7,pc

   u16_current_pos = nav_filelist_get();
800063d2:	f0 1f 00 1c 	mcall	80006440 <nav_filelist_goto+0x84>
800063d6:	5c 8c       	casts.h	r12
   if( u16_newpos < (u16_current_pos/2) )
800063d8:	f1 dc c0 2f 	bfextu	r8,r12,0x1,0xf
800063dc:	f0 07 19 00 	cp.h	r7,r8
800063e0:	c0 62       	brcc	800063ec <nav_filelist_goto+0x30>
   {
      // Restart at the beginning of list to accelerate the search
      if( !nav_filelist_reset() )
800063e2:	f0 1f 00 17 	mcall	8000643c <nav_filelist_goto+0x80>
800063e6:	c0 71       	brne	800063f4 <nav_filelist_goto+0x38>
800063e8:	e3 cd 80 80 	ldm	sp++,r7,pc
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
800063ec:	3f f8       	mov	r8,-1
800063ee:	f0 0c 19 00 	cp.h	r12,r8
800063f2:	c0 81       	brne	80006402 <nav_filelist_goto+0x46>
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
800063f4:	30 1b       	mov	r11,1
800063f6:	0e 9c       	mov	r12,r7
800063f8:	5c 7c       	castu.h	r12
800063fa:	f0 1f 00 13 	mcall	80006444 <nav_filelist_goto+0x88>
800063fe:	e3 cd 80 80 	ldm	sp++,r7,pc
   }
   else
   {
      if (u16_newpos < u16_current_pos)
80006402:	f8 07 19 00 	cp.h	r7,r12
80006406:	c0 b2       	brcc	8000641c <nav_filelist_goto+0x60>
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
80006408:	ee 07 11 ff 	rsub	r7,r7,-1
8000640c:	ee 0c 00 0c 	add	r12,r7,r12
80006410:	30 0b       	mov	r11,0
80006412:	5c 7c       	castu.h	r12
80006414:	f0 1f 00 0c 	mcall	80006444 <nav_filelist_goto+0x88>
80006418:	e3 cd 80 80 	ldm	sp++,r7,pc
      }
      if (u16_newpos > u16_current_pos)
8000641c:	f8 07 19 00 	cp.h	r7,r12
80006420:	e0 8b 00 04 	brhi	80006428 <nav_filelist_goto+0x6c>
80006424:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      {
         return nav_filelist_set( u16_newpos -u16_current_pos - 1 , FS_FIND_NEXT );
80006428:	20 17       	sub	r7,1
8000642a:	ee 0c 01 0c 	sub	r12,r7,r12
8000642e:	30 1b       	mov	r11,1
80006430:	5c 7c       	castu.h	r12
80006432:	f0 1f 00 05 	mcall	80006444 <nav_filelist_goto+0x88>
      }
   }
   return true;
}
80006436:	e3 cd 80 80 	ldm	sp++,r7,pc
8000643a:	00 00       	add	r0,r0
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	61 50       	ld.w	r0,r0[0x54]
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	5e b0       	rethi	r0
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	5f e8       	srqs	r8

80006448 <nav_partition_mount>:
//! then the mount routine selects the first partition supported by file system. <br>
//! After mount, the file list contains files and directories of ROOT directory
//! @endverbatim
//!
bool  nav_partition_mount( void )
{
80006448:	d4 01       	pushm	lr
   if ( !fat_check_noopen() )
8000644a:	f0 1f 00 0a 	mcall	80006470 <nav_partition_mount+0x28>
8000644e:	c0 f0       	breq	8000646c <nav_partition_mount+0x24>
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
80006450:	48 98       	lddpc	r8,80006474 <nav_partition_mount+0x2c>
80006452:	11 89       	ld.ub	r9,r8[0x0]
80006454:	30 08       	mov	r8,0
80006456:	f0 09 18 00 	cp.b	r9,r8
8000645a:	c0 70       	breq	80006468 <nav_partition_mount+0x20>
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
8000645c:	30 09       	mov	r9,0
8000645e:	48 78       	lddpc	r8,80006478 <nav_partition_mount+0x30>
80006460:	91 89       	st.w	r8[0x20],r9
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
80006462:	f0 1f 00 07 	mcall	8000647c <nav_partition_mount+0x34>
80006466:	da 0a       	popm	pc,r12=1
      return true;
   }

   return fat_mount();
80006468:	f0 1f 00 06 	mcall	80006480 <nav_partition_mount+0x38>
}
8000646c:	d8 02       	popm	pc
8000646e:	00 00       	add	r0,r0
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	58 08       	cp.w	r8,0
80006474:	00 00       	add	r0,r0
80006476:	0d 34       	ld.ub	r4,r6++
80006478:	00 00       	add	r0,r0
8000647a:	0c e8       	st.h	--r6,r8
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	49 2c       	lddpc	r12,800064c4 <nav_drive_set+0x34>
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	5a 20       	cp.w	r0,-30

80006484 <nav_dir_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_dir_root( void )
{
80006484:	d4 01       	pushm	lr
   return nav_partition_mount();
80006486:	f0 1f 00 02 	mcall	8000648c <nav_dir_root+0x8>
}
8000648a:	d8 02       	popm	pc
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	64 48       	ld.w	r8,r2[0x10]

80006490 <nav_drive_set>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_drive_set( uint8_t u8_number )
{
80006490:	eb cd 40 80 	pushm	r7,lr
80006494:	18 97       	mov	r7,r12
   if ( !fat_check_noopen() )
80006496:	f0 1f 00 0f 	mcall	800064d0 <nav_drive_set+0x40>
8000649a:	c1 90       	breq	800064cc <nav_drive_set+0x3c>
      return false;

   if (u8_number >= get_nb_lun() )
8000649c:	f0 1f 00 0e 	mcall	800064d4 <nav_drive_set+0x44>
800064a0:	ee 0c 18 00 	cp.b	r12,r7
800064a4:	e0 8b 00 07 	brhi	800064b2 <nav_drive_set+0x22>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
800064a8:	30 69       	mov	r9,6
800064aa:	48 c8       	lddpc	r8,800064d8 <nav_drive_set+0x48>
800064ac:	b0 89       	st.b	r8[0x0],r9
800064ae:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
800064b2:	48 b8       	lddpc	r8,800064dc <nav_drive_set+0x4c>
800064b4:	11 88       	ld.ub	r8,r8[0x0]
800064b6:	ee 08 18 00 	cp.b	r8,r7
800064ba:	c0 31       	brne	800064c0 <nav_drive_set+0x30>
800064bc:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
800064c0:	48 78       	lddpc	r8,800064dc <nav_drive_set+0x4c>
800064c2:	b0 87       	st.b	r8[0x0],r7
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
800064c4:	30 09       	mov	r9,0
800064c6:	48 78       	lddpc	r8,800064e0 <nav_drive_set+0x50>
800064c8:	b0 89       	st.b	r8[0x0],r9
800064ca:	30 1c       	mov	r12,1
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
800064cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	58 08       	cp.w	r8,0
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	68 5c       	ld.w	r12,r4[0x14]
800064d8:	00 00       	add	r0,r0
800064da:	0d 38       	ld.ub	r8,r6++
800064dc:	00 00       	add	r0,r0
800064de:	0c e8       	st.h	--r6,r8
800064e0:	00 00       	add	r0,r0
800064e2:	0d 34       	ld.ub	r4,r6++

800064e4 <nav_drive_nb>:
//! @verbatim
//! This value may be dynamic because it depends of memory drivers (e.g. Mass Storage disk on USB host mode)
//! @endverbatim
//!
uint8_t    nav_drive_nb( void )
{
800064e4:	d4 01       	pushm	lr
   return get_nb_lun(); // Number of devices = Number of lun
800064e6:	f0 1f 00 02 	mcall	800064ec <nav_drive_nb+0x8>
}
800064ea:	d8 02       	popm	pc
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	68 5c       	ld.w	r12,r4[0x14]

800064f0 <nav_select>:
//!
//! @return    false if ID navigator don't exist
//! @return    true otherwise
//!
bool  nav_select( uint8_t u8_idnav )
{
800064f0:	eb cd 40 80 	pushm	r7,lr
800064f4:	18 97       	mov	r7,r12
   if( FS_NB_NAVIGATOR <= u8_idnav )
800064f6:	30 18       	mov	r8,1
800064f8:	f0 0c 18 00 	cp.b	r12,r8
800064fc:	e0 88 00 07 	brls	8000650a <nav_select+0x1a>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
80006500:	32 79       	mov	r9,39
80006502:	48 b8       	lddpc	r8,8000652c <nav_select+0x3c>
80006504:	b0 89       	st.b	r8[0x0],r9
80006506:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
8000650a:	48 a8       	lddpc	r8,80006530 <nav_select+0x40>
8000650c:	11 8c       	ld.ub	r12,r8[0x0]
8000650e:	ee 0c 18 00 	cp.b	r12,r7
80006512:	c0 31       	brne	80006518 <nav_select+0x28>
80006514:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
80006518:	f0 1f 00 07 	mcall	80006534 <nav_select+0x44>
      fat_invert_nav( u8_idnav );               // Select new navigator
8000651c:	0e 9c       	mov	r12,r7
8000651e:	f0 1f 00 06 	mcall	80006534 <nav_select+0x44>
      fs_g_u8_nav_selected = u8_idnav;
80006522:	48 48       	lddpc	r8,80006530 <nav_select+0x40>
80006524:	b0 87       	st.b	r8[0x0],r7
80006526:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000652a:	00 00       	add	r0,r0
8000652c:	00 00       	add	r0,r0
8000652e:	0d 38       	ld.ub	r8,r6++
80006530:	00 00       	add	r0,r0
80006532:	0d b0       	ld.ub	r0,r6[0x3]
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	4e 78       	lddpc	r8,800066d0 <nav_filterlist_goto+0x8>

80006538 <nav_exit>:
//! @verbatim
//! Call this at the program exit or before a USB Device session
//! @endverbatim
//!
void  nav_exit( void )
{
80006538:	d4 01       	pushm	lr
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
8000653a:	30 0c       	mov	r12,0
8000653c:	f0 1f 00 06 	mcall	80006554 <nav_exit+0x1c>
      file_close();
80006540:	f0 1f 00 06 	mcall	80006558 <nav_exit+0x20>
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
80006544:	30 1c       	mov	r12,1
80006546:	f0 1f 00 04 	mcall	80006554 <nav_exit+0x1c>
      file_close();
8000654a:	f0 1f 00 04 	mcall	80006558 <nav_exit+0x20>
#else
   nav_select(0);
   file_close();
#endif
   // Flush data eventually present in FAT cache
   fat_cache_flush();
8000654e:	f0 1f 00 04 	mcall	8000655c <nav_exit+0x24>
}
80006552:	d8 02       	popm	pc
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	64 f0       	ld.w	r0,r2[0x3c]
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	5d 40       	*unknown*
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	4f 54       	lddpc	r4,80006730 <nav_filterlist_goto+0x68>

80006560 <nav_reset>:
//! @verbatim
//! Call this at the program startup or before a new session (e.g. USB Device exit)
//! @endverbatim
//!
void  nav_reset( void )
{
80006560:	eb cd 40 f8 	pushm	r3-r7,lr
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
80006564:	30 07       	mov	r7,0
80006566:	49 18       	lddpc	r8,800065a8 <nav_reset+0x48>
80006568:	b0 87       	st.b	r8[0x0],r7
   g_b_no_check_disk = false;
8000656a:	49 18       	lddpc	r8,800065ac <nav_reset+0x4c>
8000656c:	b0 87       	st.b	r8[0x0],r7

   fat_cache_reset();
8000656e:	f0 1f 00 11 	mcall	800065b0 <nav_reset+0x50>
   fat_cache_clusterlist_reset();
80006572:	f0 1f 00 11 	mcall	800065b4 <nav_reset+0x54>
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80006576:	30 0c       	mov	r12,0
80006578:	f0 1f 00 10 	mcall	800065b8 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000657c:	49 03       	lddpc	r3,800065bc <nav_reset+0x5c>
8000657e:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80006580:	49 05       	lddpc	r5,800065c0 <nav_reset+0x60>
80006582:	3f f4       	mov	r4,-1
80006584:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80006586:	49 06       	lddpc	r6,800065c4 <nav_reset+0x64>
80006588:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
8000658a:	eb 67 00 2d 	st.b	r5[45],r7
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
8000658e:	30 1c       	mov	r12,1
80006590:	f0 1f 00 0a 	mcall	800065b8 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80006594:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80006596:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80006598:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
8000659a:	eb 67 00 2d 	st.b	r5[45],r7
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
8000659e:	48 b8       	lddpc	r8,800065c8 <nav_reset+0x68>
800065a0:	b0 87       	st.b	r8[0x0],r7
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
800065a2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800065a6:	00 00       	add	r0,r0
800065a8:	00 00       	add	r0,r0
800065aa:	0d 39       	ld.ub	r9,r6++
800065ac:	00 00       	add	r0,r0
800065ae:	0a ba       	st.h	r5++,r10
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	4d 88       	lddpc	r8,80006710 <nav_filterlist_goto+0x48>
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	46 c0       	lddsp	r0,sp[0x1b0]
800065b8:	80 00       	ld.sh	r0,r0[0x0]
800065ba:	64 f0       	ld.w	r0,r2[0x3c]
800065bc:	00 00       	add	r0,r0
800065be:	0d 34       	ld.ub	r4,r6++
800065c0:	00 00       	add	r0,r0
800065c2:	0c e8       	st.h	--r6,r8
800065c4:	00 00       	add	r0,r0
800065c6:	0a a8       	st.w	r5++,r8
800065c8:	00 00       	add	r0,r0
800065ca:	0d b0       	ld.ub	r0,r6[0x3]

800065cc <nav_filterlist_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_root( void )
{
800065cc:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
800065ce:	3f f9       	mov	r9,-1
800065d0:	48 38       	lddpc	r8,800065dc <nav_filterlist_root+0x10>
800065d2:	f1 59 00 26 	st.h	r8[38],r9
   return nav_dir_root();
800065d6:	f0 1f 00 03 	mcall	800065e0 <nav_filterlist_root+0x14>
}
800065da:	d8 02       	popm	pc
800065dc:	00 00       	add	r0,r0
800065de:	0c e8       	st.h	--r6,r8
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	64 84       	ld.w	r4,r2[0x20]

800065e4 <nav_filterlist_previous>:
//!
//! @return    false in case of an error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_previous( void )
{
800065e4:	eb cd 40 e0 	pushm	r5-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
800065e8:	f0 1f 00 11 	mcall	8000662c <nav_filterlist_previous+0x48>
800065ec:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
800065f0:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
800065f2:	49 06       	lddpc	r6,80006630 <nav_filterlist_previous+0x4c>
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
800065f4:	c1 08       	rjmp	80006614 <nav_filterlist_previous+0x30>
   {
      if( nav_file_isdir()
800065f6:	f0 1f 00 10 	mcall	80006634 <nav_filterlist_previous+0x50>
800065fa:	c0 51       	brne	80006604 <nav_filterlist_previous+0x20>
800065fc:	6c ac       	ld.w	r12,r6[0x28]
800065fe:	f0 1f 00 0f 	mcall	80006638 <nav_filterlist_previous+0x54>
80006602:	c0 90       	breq	80006614 <nav_filterlist_previous+0x30>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         fs_g_nav.u16_pos_filterlist--;
80006604:	48 b8       	lddpc	r8,80006630 <nav_filterlist_previous+0x4c>
80006606:	f1 09 00 26 	ld.sh	r9,r8[38]
8000660a:	20 19       	sub	r9,1
8000660c:	f1 59 00 26 	st.h	r8[38],r9
80006610:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80006614:	0e 9b       	mov	r11,r7
80006616:	0e 9c       	mov	r12,r7
80006618:	f0 1f 00 09 	mcall	8000663c <nav_filterlist_previous+0x58>
8000661c:	ce d1       	brne	800065f6 <nav_filterlist_previous+0x12>
      {
         fs_g_nav.u16_pos_filterlist--;
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000661e:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80006622:	f0 1f 00 08 	mcall	80006640 <nav_filterlist_previous+0x5c>
80006626:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000662a:	00 00       	add	r0,r0
8000662c:	80 00       	ld.sh	r0,r0[0x0]
8000662e:	5e b0       	rethi	r0
80006630:	00 00       	add	r0,r0
80006632:	0c e8       	st.h	--r6,r8
80006634:	80 00       	ld.sh	r0,r0[0x0]
80006636:	5e e8       	retqs	r8
80006638:	80 00       	ld.sh	r0,r0[0x0]
8000663a:	5e bc       	rethi	r12
8000663c:	80 00       	ld.sh	r0,r0[0x0]
8000663e:	5f e8       	srqs	r8
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	63 bc       	ld.w	r12,r1[0x6c]

80006644 <nav_filterlist_next>:
//!
//! @return    false in case of error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_next( void )
{
80006644:	d4 21       	pushm	r4-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
80006646:	f0 1f 00 15 	mcall	80006698 <nav_filterlist_next+0x54>
8000664a:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000664e:	30 16       	mov	r6,1
80006650:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
80006652:	49 35       	lddpc	r5,8000669c <nav_filterlist_next+0x58>
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80006654:	c1 88       	rjmp	80006684 <nav_filterlist_next+0x40>
   {
      if( nav_file_isdir()
80006656:	f0 1f 00 13 	mcall	800066a0 <nav_filterlist_next+0x5c>
8000665a:	c0 51       	brne	80006664 <nav_filterlist_next+0x20>
8000665c:	6a ac       	ld.w	r12,r5[0x28]
8000665e:	f0 1f 00 12 	mcall	800066a4 <nav_filterlist_next+0x60>
80006662:	c1 10       	breq	80006684 <nav_filterlist_next+0x40>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
80006664:	3f f8       	mov	r8,-1
80006666:	f0 04 19 00 	cp.h	r4,r8
8000666a:	c0 61       	brne	80006676 <nav_filterlist_next+0x32>
         {
            fs_g_nav.u16_pos_filterlist = 0;
8000666c:	30 09       	mov	r9,0
8000666e:	48 c8       	lddpc	r8,8000669c <nav_filterlist_next+0x58>
80006670:	f1 59 00 26 	st.h	r8[38],r9
80006674:	da 2a       	popm	r4-r7,pc,r12=1
         }else{
            fs_g_nav.u16_pos_filterlist++;
80006676:	48 a8       	lddpc	r8,8000669c <nav_filterlist_next+0x58>
80006678:	f1 09 00 26 	ld.sh	r9,r8[38]
8000667c:	2f f9       	sub	r9,-1
8000667e:	f1 59 00 26 	st.h	r8[38],r9
80006682:	da 2a       	popm	r4-r7,pc,r12=1
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80006684:	0c 9b       	mov	r11,r6
80006686:	0e 9c       	mov	r12,r7
80006688:	f0 1f 00 08 	mcall	800066a8 <nav_filterlist_next+0x64>
8000668c:	ce 51       	brne	80006656 <nav_filterlist_next+0x12>
            fs_g_nav.u16_pos_filterlist++;
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000668e:	08 9c       	mov	r12,r4
80006690:	5c 7c       	castu.h	r12
80006692:	f0 1f 00 07 	mcall	800066ac <nav_filterlist_next+0x68>
80006696:	d8 2a       	popm	r4-r7,pc,r12=0
80006698:	80 00       	ld.sh	r0,r0[0x0]
8000669a:	5e b0       	rethi	r0
8000669c:	00 00       	add	r0,r0
8000669e:	0c e8       	st.h	--r6,r8
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	5e e8       	retqs	r8
800066a4:	80 00       	ld.sh	r0,r0[0x0]
800066a6:	5e bc       	rethi	r12
800066a8:	80 00       	ld.sh	r0,r0[0x0]
800066aa:	5f e8       	srqs	r8
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	63 bc       	ld.w	r12,r1[0x6c]

800066b0 <nav_filterlist_reset>:
//!
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
800066b0:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
800066b2:	3f f9       	mov	r9,-1
800066b4:	48 38       	lddpc	r8,800066c0 <nav_filterlist_reset+0x10>
800066b6:	f1 59 00 26 	st.h	r8[38],r9
   return nav_filelist_reset();
800066ba:	f0 1f 00 03 	mcall	800066c4 <nav_filterlist_reset+0x14>
}
800066be:	d8 02       	popm	pc
800066c0:	00 00       	add	r0,r0
800066c2:	0c e8       	st.h	--r6,r8
800066c4:	80 00       	ld.sh	r0,r0[0x0]
800066c6:	61 50       	ld.w	r0,r0[0x54]

800066c8 <nav_filterlist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_goto( uint16_t u16_newpos )
{
800066c8:	eb cd 40 c0 	pushm	r6-r7,lr
800066cc:	18 97       	mov	r7,r12
   if (u16_newpos == FS_NO_SEL)
800066ce:	3f f8       	mov	r8,-1
800066d0:	f0 0c 19 00 	cp.h	r12,r8
800066d4:	c0 51       	brne	800066de <nav_filterlist_goto+0x16>
     return nav_filterlist_reset();
800066d6:	f0 1f 00 1d 	mcall	80006748 <nav_filterlist_goto+0x80>
800066da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

   if( u16_newpos < (fs_g_nav.u16_pos_filterlist/2) )
800066de:	49 c8       	lddpc	r8,8000674c <nav_filterlist_goto+0x84>
800066e0:	f1 18 00 26 	ld.uh	r8,r8[38]
800066e4:	a1 98       	lsr	r8,0x1
800066e6:	f0 0c 19 00 	cp.h	r12,r8
800066ea:	c0 42       	brcc	800066f2 <nav_filterlist_goto+0x2a>
   {
      // Restart at the beginning of list to accelerate search
      if( !nav_filterlist_reset() )
800066ec:	f0 1f 00 17 	mcall	80006748 <nav_filterlist_goto+0x80>
800066f0:	c2 a0       	breq	80006744 <nav_filterlist_goto+0x7c>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
800066f2:	49 78       	lddpc	r8,8000674c <nav_filterlist_goto+0x84>
800066f4:	f1 09 00 26 	ld.sh	r9,r8[38]
800066f8:	3f f8       	mov	r8,-1
800066fa:	f0 09 19 00 	cp.h	r9,r8
800066fe:	c0 91       	brne	80006710 <nav_filterlist_goto+0x48>
      if( !nav_filterlist_next() )
80006700:	f0 1f 00 14 	mcall	80006750 <nav_filterlist_goto+0x88>
80006704:	c0 61       	brne	80006710 <nav_filterlist_goto+0x48>
80006706:	c1 f8       	rjmp	80006744 <nav_filterlist_goto+0x7c>
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
80006708:	f0 1f 00 12 	mcall	80006750 <nav_filterlist_goto+0x88>
8000670c:	c0 31       	brne	80006712 <nav_filterlist_goto+0x4a>
8000670e:	c0 c8       	rjmp	80006726 <nav_filterlist_goto+0x5e>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
      if( !nav_filterlist_next() )
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
80006710:	48 f6       	lddpc	r6,8000674c <nav_filterlist_goto+0x84>
80006712:	ed 08 00 26 	ld.sh	r8,r6[38]
80006716:	ee 08 19 00 	cp.h	r8,r7
8000671a:	cf 73       	brcs	80006708 <nav_filterlist_goto+0x40>
8000671c:	c0 58       	rjmp	80006726 <nav_filterlist_goto+0x5e>
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_previous() )
8000671e:	f0 1f 00 0e 	mcall	80006754 <nav_filterlist_goto+0x8c>
80006722:	c0 31       	brne	80006728 <nav_filterlist_goto+0x60>
80006724:	c0 88       	rjmp	80006734 <nav_filterlist_goto+0x6c>
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
80006726:	48 a6       	lddpc	r6,8000674c <nav_filterlist_goto+0x84>
80006728:	ed 08 00 26 	ld.sh	r8,r6[38]
8000672c:	ee 08 19 00 	cp.h	r8,r7
80006730:	fe 9b ff f7 	brhi	8000671e <nav_filterlist_goto+0x56>
   {
      if( !nav_filterlist_previous() )
         break;
   }
   return (u16_newpos == fs_g_nav.u16_pos_filterlist);
80006734:	48 68       	lddpc	r8,8000674c <nav_filterlist_goto+0x84>
80006736:	f1 08 00 26 	ld.sh	r8,r8[38]
8000673a:	ee 08 19 00 	cp.h	r8,r7
8000673e:	5f 0c       	sreq	r12
80006740:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006744:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80006748:	80 00       	ld.sh	r0,r0[0x0]
8000674a:	66 b0       	ld.w	r0,r3[0x2c]
8000674c:	00 00       	add	r0,r0
8000674e:	0c e8       	st.h	--r6,r8
80006750:	80 00       	ld.sh	r0,r0[0x0]
80006752:	66 44       	ld.w	r4,r3[0x10]
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	65 e4       	ld.w	r4,r2[0x78]

80006758 <nav_filterlist_setfilter>:
//! This function affiliates an extension filter at current navigator
//!
//! @param     sz_filterext   extension filter (ASCII format, e.g.: "txt" or "txt,d*,wk" )
//!
void  nav_filterlist_setfilter( const FS_STRING sz_filterext  )
{
80006758:	d4 01       	pushm	lr
   fs_g_nav.sz_filterext = sz_filterext;
8000675a:	48 38       	lddpc	r8,80006764 <nav_filterlist_setfilter+0xc>
8000675c:	91 ac       	st.w	r8[0x28],r12
   nav_filterlist_reset();
8000675e:	f0 1f 00 03 	mcall	80006768 <nav_filterlist_setfilter+0x10>
}
80006762:	d8 02       	popm	pc
80006764:	00 00       	add	r0,r0
80006766:	0c e8       	st.h	--r6,r8
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	66 b0       	ld.w	r0,r3[0x2c]

8000676c <print_char>:
  usart_write_line(usart, str);
}


void print_char(volatile avr32_usart_t *usart, int c)
{
8000676c:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input character with the given USART.
  usart_putchar(usart, c);
8000676e:	f0 1f 00 02 	mcall	80006774 <print_char+0x8>
}
80006772:	d8 02       	popm	pc
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	90 58       	ld.sh	r8,r8[0xa]

80006778 <print_dbg_char>:
  print(DBG_USART, str);
}


void print_dbg_char(int c)
{
80006778:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_char(DBG_USART, c);
8000677a:	18 9b       	mov	r11,r12
8000677c:	fe 7c 14 00 	mov	r12,-60416
80006780:	f0 1f 00 02 	mcall	80006788 <print_dbg_char+0x10>
}
80006784:	d8 02       	popm	pc
80006786:	00 00       	add	r0,r0
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	67 6c       	ld.w	r12,r3[0x58]

8000678c <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
8000678c:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
8000678e:	f0 1f 00 02 	mcall	80006794 <print+0x8>
}
80006792:	d8 02       	popm	pc
80006794:	80 00       	ld.sh	r0,r0[0x0]
80006796:	90 84       	ld.uh	r4,r8[0x0]

80006798 <print_ulong>:
  usart_putchar(usart, c);
}


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
80006798:	eb cd 40 e0 	pushm	r5-r7,lr
8000679c:	20 3d       	sub	sp,12
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
8000679e:	30 08       	mov	r8,0
800067a0:	fb 68 00 0a 	st.b	sp[10],r8
800067a4:	30 a9       	mov	r9,10
  do
  {
    tmp[--i] = '0' + n % 10;
800067a6:	1a 95       	mov	r5,sp
800067a8:	e0 6e cc cd 	mov	lr,52429
800067ac:	ea 1e cc cc 	orh	lr,0xcccc
800067b0:	20 19       	sub	r9,1
800067b2:	f6 0e 06 46 	mulu.d	r6,r11,lr
800067b6:	0e 98       	mov	r8,r7
800067b8:	a3 98       	lsr	r8,0x3
800067ba:	f0 08 00 2a 	add	r10,r8,r8<<0x2
800067be:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
800067c2:	2d 0b       	sub	r11,-48
800067c4:	ea 09 0b 0b 	st.b	r5[r9],r11
    n /= 10;
800067c8:	10 9b       	mov	r11,r8
  } while (n);
800067ca:	58 08       	cp.w	r8,0
800067cc:	cf 21       	brne	800067b0 <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
800067ce:	1a 9b       	mov	r11,sp
800067d0:	12 0b       	add	r11,r9
800067d2:	f0 1f 00 03 	mcall	800067dc <print_ulong+0x44>
}
800067d6:	2f dd       	sub	sp,-12
800067d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800067dc:	80 00       	ld.sh	r0,r0[0x0]
800067de:	67 8c       	ld.w	r12,r3[0x60]

800067e0 <print_dbg_ulong>:
  print_char(DBG_USART, c);
}


void print_dbg_ulong(unsigned long n)
{
800067e0:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
800067e2:	18 9b       	mov	r11,r12
800067e4:	fe 7c 14 00 	mov	r12,-60416
800067e8:	f0 1f 00 02 	mcall	800067f0 <print_dbg_ulong+0x10>
}
800067ec:	d8 02       	popm	pc
800067ee:	00 00       	add	r0,r0
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	67 98       	ld.w	r8,r3[0x64]

800067f4 <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
800067f4:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
800067f6:	18 9b       	mov	r11,r12
800067f8:	fe 7c 14 00 	mov	r12,-60416
800067fc:	f0 1f 00 02 	mcall	80006804 <print_dbg+0x10>
}
80006800:	d8 02       	popm	pc
80006802:	00 00       	add	r0,r0
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	67 8c       	ld.w	r12,r3[0x60]

80006808 <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
80006808:	eb cd 40 80 	pushm	r7,lr
8000680c:	20 3d       	sub	sp,12
8000680e:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
80006810:	50 0c       	stdsp	sp[0x0],r12
80006812:	30 88       	mov	r8,8
80006814:	ba c8       	st.b	sp[0x4],r8
80006816:	30 48       	mov	r8,4
80006818:	ba d8       	st.b	sp[0x5],r8
8000681a:	30 08       	mov	r8,0
8000681c:	ba 38       	st.h	sp[0x6],r8
8000681e:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
80006822:	30 2b       	mov	r11,2
80006824:	48 6c       	lddpc	r12,8000683c <init_dbg_rs232_ex+0x34>
80006826:	f0 1f 00 07 	mcall	80006840 <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
8000682a:	0e 9a       	mov	r10,r7
8000682c:	1a 9b       	mov	r11,sp
8000682e:	fe 7c 14 00 	mov	r12,-60416
80006832:	f0 1f 00 05 	mcall	80006844 <init_dbg_rs232_ex+0x3c>
}
80006836:	2f dd       	sub	sp,-12
80006838:	e3 cd 80 80 	ldm	sp++,r7,pc
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	a7 38       	mul	r8,r3
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	8b e0       	st.w	r5[0x38],r0
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	90 d4       	ld.uh	r4,r8[0xa]

80006848 <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80006848:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
8000684a:	18 9b       	mov	r11,r12
8000684c:	e0 6c e1 00 	mov	r12,57600
80006850:	f0 1f 00 02 	mcall	80006858 <init_dbg_rs232+0x10>
}
80006854:	d8 02       	popm	pc
80006856:	00 00       	add	r0,r0
80006858:	80 00       	ld.sh	r0,r0[0x0]
8000685a:	68 08       	ld.w	r8,r4[0x0]

8000685c <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
8000685c:	5e ff       	retal	1
8000685e:	d7 03       	nop

80006860 <ctrl_access_lock>:
/*! \brief Locks accesses to LUNs.
 *
 * \return \c true if the access was successfully locked, else \c false.
 */
static bool ctrl_access_lock(void)
{
80006860:	eb cd 40 c0 	pushm	r6-r7,lr
  // If the semaphore could not be created, there is no backup solution.
  if (!ctrl_access_semphr) return false;
80006864:	48 88       	lddpc	r8,80006884 <ctrl_access_lock+0x24>
80006866:	70 08       	ld.w	r8,r8[0x0]
80006868:	58 08       	cp.w	r8,0
8000686a:	c0 31       	brne	80006870 <ctrl_access_lock+0x10>
8000686c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

  // Wait for the semaphore.
  while (!xSemaphoreTake(ctrl_access_semphr, portMAX_DELAY));
80006870:	48 56       	lddpc	r6,80006884 <ctrl_access_lock+0x24>
80006872:	3f f7       	mov	r7,-1
80006874:	0e 9b       	mov	r11,r7
80006876:	6c 0c       	ld.w	r12,r6[0x0]
80006878:	f0 1f 00 04 	mcall	80006888 <ctrl_access_lock+0x28>
8000687c:	cf c0       	breq	80006874 <ctrl_access_lock+0x14>
8000687e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006882:	00 00       	add	r0,r0
80006884:	00 00       	add	r0,r0
80006886:	05 ac       	ld.ub	r12,r2[0x2]
80006888:	80 00       	ld.sh	r0,r0[0x0]
8000688a:	6f c8       	ld.w	r8,r7[0x70]

8000688c <ram_2_memory>:
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
8000688c:	eb cd 40 e0 	pushm	r5-r7,lr
80006890:	18 97       	mov	r7,r12
80006892:	16 95       	mov	r5,r11
80006894:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80006896:	f0 1f 00 10 	mcall	800068d4 <ram_2_memory+0x48>
8000689a:	c0 31       	brne	800068a0 <ram_2_memory+0x14>
8000689c:	30 17       	mov	r7,1
8000689e:	c1 88       	rjmp	800068ce <ram_2_memory+0x42>

  memory_start_write_action(1);
800068a0:	30 2c       	mov	r12,2
800068a2:	f0 1f 00 0e 	mcall	800068d8 <ram_2_memory+0x4c>
  status =
800068a6:	58 07       	cp.w	r7,0
800068a8:	c0 30       	breq	800068ae <ram_2_memory+0x22>
800068aa:	30 17       	mov	r7,1
800068ac:	c0 78       	rjmp	800068ba <ram_2_memory+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
800068ae:	48 c8       	lddpc	r8,800068dc <ram_2_memory+0x50>
800068b0:	70 68       	ld.w	r8,r8[0x18]
800068b2:	0c 9b       	mov	r11,r6
800068b4:	0a 9c       	mov	r12,r5
800068b6:	5d 18       	icall	r8
800068b8:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_ram_2_mem(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_write_action();
800068ba:	30 2c       	mov	r12,2
800068bc:	f0 1f 00 09 	mcall	800068e0 <ram_2_memory+0x54>

  Ctrl_access_unlock();
800068c0:	30 09       	mov	r9,0
800068c2:	12 9a       	mov	r10,r9
800068c4:	12 9b       	mov	r11,r9
800068c6:	48 88       	lddpc	r8,800068e4 <ram_2_memory+0x58>
800068c8:	70 0c       	ld.w	r12,r8[0x0]
800068ca:	f0 1f 00 08 	mcall	800068e8 <ram_2_memory+0x5c>

  return status;
}
800068ce:	0e 9c       	mov	r12,r7
800068d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	68 60       	ld.w	r0,r4[0x18]
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	8a c4       	ld.uh	r4,r5[0x8]
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	a7 48       	asr	r8,0x6
800068e0:	80 00       	ld.sh	r0,r0[0x0]
800068e2:	8b 20       	st.w	r5[0x8],r0
800068e4:	00 00       	add	r0,r0
800068e6:	05 ac       	ld.ub	r12,r2[0x2]
800068e8:	80 00       	ld.sh	r0,r0[0x0]
800068ea:	71 ac       	ld.w	r12,r8[0x68]

800068ec <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
800068ec:	eb cd 40 e0 	pushm	r5-r7,lr
800068f0:	18 97       	mov	r7,r12
800068f2:	16 95       	mov	r5,r11
800068f4:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
800068f6:	f0 1f 00 10 	mcall	80006934 <memory_2_ram+0x48>
800068fa:	c0 31       	brne	80006900 <memory_2_ram+0x14>
800068fc:	30 17       	mov	r7,1
800068fe:	c1 88       	rjmp	8000692e <memory_2_ram+0x42>

  memory_start_read_action(1);
80006900:	30 1c       	mov	r12,1
80006902:	f0 1f 00 0e 	mcall	80006938 <memory_2_ram+0x4c>
  status =
80006906:	58 07       	cp.w	r7,0
80006908:	c0 30       	breq	8000690e <memory_2_ram+0x22>
8000690a:	30 17       	mov	r7,1
8000690c:	c0 78       	rjmp	8000691a <memory_2_ram+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
8000690e:	48 c8       	lddpc	r8,8000693c <memory_2_ram+0x50>
80006910:	70 58       	ld.w	r8,r8[0x14]
80006912:	0c 9b       	mov	r11,r6
80006914:	0a 9c       	mov	r12,r5
80006916:	5d 18       	icall	r8
80006918:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_mem_2_ram(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_read_action();
8000691a:	30 1c       	mov	r12,1
8000691c:	f0 1f 00 09 	mcall	80006940 <memory_2_ram+0x54>

  Ctrl_access_unlock();
80006920:	30 09       	mov	r9,0
80006922:	12 9a       	mov	r10,r9
80006924:	12 9b       	mov	r11,r9
80006926:	48 88       	lddpc	r8,80006944 <memory_2_ram+0x58>
80006928:	70 0c       	ld.w	r12,r8[0x0]
8000692a:	f0 1f 00 08 	mcall	80006948 <memory_2_ram+0x5c>

  return status;
}
8000692e:	0e 9c       	mov	r12,r7
80006930:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	68 60       	ld.w	r0,r4[0x18]
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	8a c4       	ld.uh	r4,r5[0x8]
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	a7 48       	asr	r8,0x6
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	8b 20       	st.w	r5[0x8],r0
80006944:	00 00       	add	r0,r0
80006946:	05 ac       	ld.ub	r12,r2[0x2]
80006948:	80 00       	ld.sh	r0,r0[0x0]
8000694a:	71 ac       	ld.w	r12,r8[0x68]

8000694c <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
8000694c:	eb cd 40 80 	pushm	r7,lr
80006950:	18 97       	mov	r7,r12
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;
80006952:	f0 1f 00 0c 	mcall	80006980 <mem_wr_protect+0x34>
80006956:	c0 31       	brne	8000695c <mem_wr_protect+0x10>
80006958:	30 17       	mov	r7,1
8000695a:	c1 08       	rjmp	8000697a <mem_wr_protect+0x2e>

  wr_protect =
8000695c:	58 07       	cp.w	r7,0
8000695e:	c0 30       	breq	80006964 <mem_wr_protect+0x18>
80006960:	30 17       	mov	r7,1
80006962:	c0 58       	rjmp	8000696c <mem_wr_protect+0x20>
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
80006964:	48 88       	lddpc	r8,80006984 <mem_wr_protect+0x38>
80006966:	70 3c       	ld.w	r12,r8[0xc]
80006968:	5d 1c       	icall	r12
8000696a:	18 97       	mov	r7,r12
                                 Lun_usb_wr_protect(lun - LUN_ID_USB);
#else
                                 true;
#endif

  Ctrl_access_unlock();
8000696c:	30 09       	mov	r9,0
8000696e:	12 9a       	mov	r10,r9
80006970:	12 9b       	mov	r11,r9
80006972:	48 68       	lddpc	r8,80006988 <mem_wr_protect+0x3c>
80006974:	70 0c       	ld.w	r12,r8[0x0]
80006976:	f0 1f 00 06 	mcall	8000698c <mem_wr_protect+0x40>

  return wr_protect;
}
8000697a:	0e 9c       	mov	r12,r7
8000697c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	68 60       	ld.w	r0,r4[0x18]
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	a7 48       	asr	r8,0x6
80006988:	00 00       	add	r0,r0
8000698a:	05 ac       	ld.ub	r12,r2[0x2]
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	71 ac       	ld.w	r12,r8[0x68]

80006990 <mem_sector_size>:
  return status;
}


U8 mem_sector_size(U8 lun)
{
80006990:	eb cd 40 80 	pushm	r7,lr
80006994:	18 97       	mov	r7,r12
  U8 sector_size;

  if (!Ctrl_access_lock()) return 0;
80006996:	f0 1f 00 0a 	mcall	800069bc <mem_sector_size+0x2c>
8000699a:	c0 31       	brne	800069a0 <mem_sector_size+0x10>
8000699c:	30 07       	mov	r7,0
8000699e:	c0 c8       	rjmp	800069b6 <mem_sector_size+0x26>

  sector_size =
800069a0:	30 08       	mov	r8,0
800069a2:	f0 07 18 00 	cp.b	r7,r8
800069a6:	5f 07       	sreq	r7
                                  Lun_usb_read_sector_size(lun - LUN_ID_USB);
#else
                                  0;
#endif

  Ctrl_access_unlock();
800069a8:	30 09       	mov	r9,0
800069aa:	12 9a       	mov	r10,r9
800069ac:	12 9b       	mov	r11,r9
800069ae:	48 58       	lddpc	r8,800069c0 <mem_sector_size+0x30>
800069b0:	70 0c       	ld.w	r12,r8[0x0]
800069b2:	f0 1f 00 05 	mcall	800069c4 <mem_sector_size+0x34>

  return sector_size;
}
800069b6:	0e 9c       	mov	r12,r7
800069b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800069bc:	80 00       	ld.sh	r0,r0[0x0]
800069be:	68 60       	ld.w	r0,r4[0x18]
800069c0:	00 00       	add	r0,r0
800069c2:	05 ac       	ld.ub	r12,r2[0x2]
800069c4:	80 00       	ld.sh	r0,r0[0x0]
800069c6:	71 ac       	ld.w	r12,r8[0x68]

800069c8 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
800069c8:	eb cd 40 80 	pushm	r7,lr
800069cc:	18 97       	mov	r7,r12
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;
800069ce:	f0 1f 00 0c 	mcall	800069fc <mem_test_unit_ready+0x34>
800069d2:	c0 31       	brne	800069d8 <mem_test_unit_ready+0x10>
800069d4:	30 17       	mov	r7,1
800069d6:	c1 08       	rjmp	800069f6 <mem_test_unit_ready+0x2e>

  status =
800069d8:	58 07       	cp.w	r7,0
800069da:	c0 30       	breq	800069e0 <mem_test_unit_ready+0x18>
800069dc:	30 17       	mov	r7,1
800069de:	c0 58       	rjmp	800069e8 <mem_test_unit_ready+0x20>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
800069e0:	48 88       	lddpc	r8,80006a00 <mem_test_unit_ready+0x38>
800069e2:	70 0c       	ld.w	r12,r8[0x0]
800069e4:	5d 1c       	icall	r12
800069e6:	18 97       	mov	r7,r12
                             Lun_usb_test_unit_ready(lun - LUN_ID_USB);
#else
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();
800069e8:	30 09       	mov	r9,0
800069ea:	12 9a       	mov	r10,r9
800069ec:	12 9b       	mov	r11,r9
800069ee:	48 68       	lddpc	r8,80006a04 <mem_test_unit_ready+0x3c>
800069f0:	70 0c       	ld.w	r12,r8[0x0]
800069f2:	f0 1f 00 06 	mcall	80006a08 <mem_test_unit_ready+0x40>

  return status;
}
800069f6:	0e 9c       	mov	r12,r7
800069f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800069fc:	80 00       	ld.sh	r0,r0[0x0]
800069fe:	68 60       	ld.w	r0,r4[0x18]
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	a7 48       	asr	r8,0x6
80006a04:	00 00       	add	r0,r0
80006a06:	05 ac       	ld.ub	r12,r2[0x2]
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	71 ac       	ld.w	r12,r8[0x68]

80006a0c <ctrl_access_init>:


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
{
80006a0c:	d4 01       	pushm	lr
  // If the handle to the protecting semaphore is not valid,
  if (!ctrl_access_semphr)
80006a0e:	48 d8       	lddpc	r8,80006a40 <ctrl_access_init+0x34>
80006a10:	70 08       	ld.w	r8,r8[0x0]
80006a12:	58 08       	cp.w	r8,0
80006a14:	c0 20       	breq	80006a18 <ctrl_access_init+0xc>
80006a16:	da 0a       	popm	pc,r12=1
  {
    // try to create the semaphore.
    vSemaphoreCreateBinary(ctrl_access_semphr);
80006a18:	30 3a       	mov	r10,3
80006a1a:	30 0b       	mov	r11,0
80006a1c:	30 1c       	mov	r12,1
80006a1e:	f0 1f 00 0a 	mcall	80006a44 <ctrl_access_init+0x38>
80006a22:	48 88       	lddpc	r8,80006a40 <ctrl_access_init+0x34>
80006a24:	91 0c       	st.w	r8[0x0],r12
80006a26:	58 0c       	cp.w	r12,0
80006a28:	c0 a0       	breq	80006a3c <ctrl_access_init+0x30>
80006a2a:	30 09       	mov	r9,0
80006a2c:	12 9a       	mov	r10,r9
80006a2e:	12 9b       	mov	r11,r9
80006a30:	f0 1f 00 06 	mcall	80006a48 <ctrl_access_init+0x3c>
//! @{


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
80006a34:	48 38       	lddpc	r8,80006a40 <ctrl_access_init+0x34>
80006a36:	70 08       	ld.w	r8,r8[0x0]
80006a38:	58 08       	cp.w	r8,0
80006a3a:	5f 1c       	srne	r12
    // If the semaphore could not be created, there is no backup solution.
    if (!ctrl_access_semphr) return false;
  }

  return true;
}
80006a3c:	d8 02       	popm	pc
80006a3e:	00 00       	add	r0,r0
80006a40:	00 00       	add	r0,r0
80006a42:	05 ac       	ld.ub	r12,r2[0x2]
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	73 40       	ld.w	r0,r9[0x50]
80006a48:	80 00       	ld.sh	r0,r0[0x0]
80006a4a:	71 ac       	ld.w	r12,r8[0x68]

80006a4c <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006a4c:	f8 c8 ff f8 	sub	r8,r12,-8
80006a50:	99 18       	st.w	r12[0x4],r8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
80006a52:	3f f9       	mov	r9,-1
80006a54:	99 29       	st.w	r12[0x8],r9

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006a56:	99 38       	st.w	r12[0xc],r8
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006a58:	99 48       	st.w	r12[0x10],r8

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
80006a5a:	30 08       	mov	r8,0
80006a5c:	99 08       	st.w	r12[0x0],r8

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80006a5e:	5e fc       	retal	r12

80006a60 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
80006a60:	30 08       	mov	r8,0
80006a62:	99 48       	st.w	r12[0x10],r8

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
80006a64:	5e fc       	retal	r12

80006a66 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
80006a66:	78 18       	ld.w	r8,r12[0x4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
80006a68:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80006a6a:	70 29       	ld.w	r9,r8[0x8]
80006a6c:	97 29       	st.w	r11[0x8],r9

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
80006a6e:	70 29       	ld.w	r9,r8[0x8]
80006a70:	93 1b       	st.w	r9[0x4],r11
    pxIndex->pxPrevious = pxNewListItem;
80006a72:	91 2b       	st.w	r8[0x8],r11

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
80006a74:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80006a76:	78 08       	ld.w	r8,r12[0x0]
80006a78:	2f f8       	sub	r8,-1
80006a7a:	99 08       	st.w	r12[0x0],r8
}
80006a7c:	5e fc       	retal	r12

80006a7e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
80006a7e:	d4 01       	pushm	lr
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80006a80:	76 0e       	ld.w	lr,r11[0x0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
80006a82:	5b fe       	cp.w	lr,-1
80006a84:	c0 31       	brne	80006a8a <vListInsert+0xc>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
80006a86:	78 49       	ld.w	r9,r12[0x10]
80006a88:	c0 98       	rjmp	80006a9a <vListInsert+0x1c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
80006a8a:	f8 c9 ff f8 	sub	r9,r12,-8
80006a8e:	72 18       	ld.w	r8,r9[0x4]
80006a90:	70 0a       	ld.w	r10,r8[0x0]
80006a92:	14 3e       	cp.w	lr,r10
80006a94:	c0 33       	brcs	80006a9a <vListInsert+0x1c>
80006a96:	10 99       	mov	r9,r8
80006a98:	cf bb       	rjmp	80006a8e <vListInsert+0x10>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
80006a9a:	72 18       	ld.w	r8,r9[0x4]
80006a9c:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80006a9e:	91 2b       	st.w	r8[0x8],r11
    pxNewListItem->pxPrevious = pxIterator;
80006aa0:	97 29       	st.w	r11[0x8],r9
    pxIterator->pxNext = pxNewListItem;
80006aa2:	93 1b       	st.w	r9[0x4],r11

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
80006aa4:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80006aa6:	78 08       	ld.w	r8,r12[0x0]
80006aa8:	2f f8       	sub	r8,-1
80006aaa:	99 08       	st.w	r12[0x0],r8
}
80006aac:	d8 02       	popm	pc

80006aae <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
80006aae:	78 48       	ld.w	r8,r12[0x10]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006ab0:	78 19       	ld.w	r9,r12[0x4]
80006ab2:	78 2a       	ld.w	r10,r12[0x8]
80006ab4:	93 2a       	st.w	r9[0x8],r10
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006ab6:	78 29       	ld.w	r9,r12[0x8]
80006ab8:	78 1a       	ld.w	r10,r12[0x4]
80006aba:	93 1a       	st.w	r9[0x4],r10

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
80006abc:	70 19       	ld.w	r9,r8[0x4]
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
80006abe:	18 39       	cp.w	r9,r12
80006ac0:	f3 f9 00 02 	ld.weq	r9,r9[0x8]
80006ac4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
80006ac8:	30 09       	mov	r9,0
80006aca:	99 49       	st.w	r12[0x10],r9
    ( pxList->uxNumberOfItems )--;
80006acc:	70 09       	ld.w	r9,r8[0x0]
80006ace:	20 19       	sub	r9,1
80006ad0:	91 09       	st.w	r8[0x0],r9

    return pxList->uxNumberOfItems;
80006ad2:	70 0c       	ld.w	r12,r8[0x0]
}
80006ad4:	5e fc       	retal	r12

80006ad6 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( StackType_t ) 0x08080808;					/* R8 */
80006ad6:	e0 68 08 08 	mov	r8,2056
80006ada:	ea 18 08 08 	orh	r8,0x808
80006ade:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x09090909;					/* R9 */
80006ae0:	e0 68 09 09 	mov	r8,2313
80006ae4:	ea 18 09 09 	orh	r8,0x909
80006ae8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;					/* R10 */
80006aea:	e0 68 0a 0a 	mov	r8,2570
80006aee:	ea 18 0a 0a 	orh	r8,0xa0a
80006af2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;					/* R11 */
80006af4:	e0 68 0b 0b 	mov	r8,2827
80006af8:	ea 18 0b 0b 	orh	r8,0xb0b
80006afc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pvParameters;					/* R12 */
80006afe:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;					/* R14/LR */
80006b00:	e0 68 be ef 	mov	r8,48879
80006b04:	ea 18 de ad 	orh	r8,0xdead
80006b08:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006b0a:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;				/* SR */
80006b0c:	fc 18 00 40 	movh	r8,0x40
80006b10:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;					/* R0 */
80006b12:	e0 68 00 ff 	mov	r8,255
80006b16:	ea 18 ff 00 	orh	r8,0xff00
80006b1a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x01010101;					/* R1 */
80006b1c:	e0 68 01 01 	mov	r8,257
80006b20:	ea 18 01 01 	orh	r8,0x101
80006b24:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x02020202;					/* R2 */
80006b26:	e0 68 02 02 	mov	r8,514
80006b2a:	ea 18 02 02 	orh	r8,0x202
80006b2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x03030303;					/* R3 */
80006b30:	e0 68 03 03 	mov	r8,771
80006b34:	ea 18 03 03 	orh	r8,0x303
80006b38:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x04040404;					/* R4 */
80006b3a:	e0 68 04 04 	mov	r8,1028
80006b3e:	ea 18 04 04 	orh	r8,0x404
80006b42:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x05050505;					/* R5 */
80006b44:	e0 68 05 05 	mov	r8,1285
80006b48:	ea 18 05 05 	orh	r8,0x505
80006b4c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x06060606;					/* R6 */
80006b4e:	e0 68 06 06 	mov	r8,1542
80006b52:	ea 18 06 06 	orh	r8,0x606
80006b56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x07070707;					/* R7 */
80006b58:	e0 68 07 07 	mov	r8,1799
80006b5c:	ea 18 07 07 	orh	r8,0x707
80006b60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006b62:	30 08       	mov	r8,0
80006b64:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006b66:	5e fc       	retal	r12

80006b68 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006b68:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006b6a:	48 38       	lddpc	r8,80006b74 <vPortEnterCritical+0xc>
80006b6c:	70 09       	ld.w	r9,r8[0x0]
80006b6e:	2f f9       	sub	r9,-1
80006b70:	91 09       	st.w	r8[0x0],r9
}
80006b72:	5e fc       	retal	r12
80006b74:	00 00       	add	r0,r0
80006b76:	00 24       	rsub	r4,r0

80006b78 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
80006b78:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006b7a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006b7c:	30 0a       	mov	r10,0
80006b7e:	14 9b       	mov	r11,r10
80006b80:	49 2c       	lddpc	r12,80006bc8 <xPortStartScheduler+0x50>
80006b82:	f0 1f 00 13 	mcall	80006bcc <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80006b86:	e0 68 f2 8c 	mov	r8,62092
80006b8a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006b8e:	30 08       	mov	r8,0
80006b90:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006b94:	e0 68 06 6c 	mov	r8,1644
80006b98:	ea 18 00 00 	orh	r8,0x0
80006b9c:	70 00       	ld.w	r0,r8[0x0]
80006b9e:	60 0d       	ld.w	sp,r0[0x0]
80006ba0:	1b 00       	ld.w	r0,sp++
80006ba2:	e0 68 00 24 	mov	r8,36
80006ba6:	ea 18 00 00 	orh	r8,0x0
80006baa:	91 00       	st.w	r8[0x0],r0
80006bac:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006bb0:	2f ed       	sub	sp,-8
80006bb2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006bb6:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006bba:	e3 b0 00 00 	mtsr	0x0,r0
80006bbe:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006bc2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006bc6:	d8 0a       	popm	pc,r12=0
80006bc8:	80 00       	ld.sh	r0,r0[0x0]
80006bca:	6c 94       	ld.w	r4,r6[0x24]
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	8d 00       	st.w	r6[0x0],r0

80006bd0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006bd0:	20 6d       	sub	sp,24
80006bd2:	eb cd 00 ff 	pushm	r0-r7
80006bd6:	fa c7 ff c0 	sub	r7,sp,-64
80006bda:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006bde:	ef 40 ff e0 	st.w	r7[-32],r0
80006be2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006be6:	ef 40 ff e4 	st.w	r7[-28],r0
80006bea:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006bee:	e0 68 00 24 	mov	r8,36
80006bf2:	ea 18 00 00 	orh	r8,0x0
80006bf6:	70 00       	ld.w	r0,r8[0x0]
80006bf8:	1a d0       	st.w	--sp,r0
80006bfa:	f0 1f 00 1a 	mcall	80006c60 <LABEL_RET_SCALL_244+0x14>
80006bfe:	e0 68 06 6c 	mov	r8,1644
80006c02:	ea 18 00 00 	orh	r8,0x0
80006c06:	70 00       	ld.w	r0,r8[0x0]
80006c08:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006c0a:	f0 1f 00 17 	mcall	80006c64 <LABEL_RET_SCALL_244+0x18>
	portRESTORE_CONTEXT_SCALL();
80006c0e:	e0 68 06 6c 	mov	r8,1644
80006c12:	ea 18 00 00 	orh	r8,0x0
80006c16:	70 00       	ld.w	r0,r8[0x0]
80006c18:	60 0d       	ld.w	sp,r0[0x0]
80006c1a:	1b 00       	ld.w	r0,sp++
80006c1c:	e0 68 00 24 	mov	r8,36
80006c20:	ea 18 00 00 	orh	r8,0x0
80006c24:	91 00       	st.w	r8[0x0],r0
80006c26:	fa c7 ff d8 	sub	r7,sp,-40
80006c2a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006c2e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006c32:	e0 61 00 24 	mov	r1,36
80006c36:	ea 11 00 00 	orh	r1,0x0
80006c3a:	62 02       	ld.w	r2,r1[0x0]
80006c3c:	58 02       	cp.w	r2,0
80006c3e:	c0 70       	breq	80006c4c <LABEL_RET_SCALL_244>
80006c40:	e4 c2 00 01 	sub	r2,r2,1
80006c44:	83 02       	st.w	r1[0x0],r2
80006c46:	58 02       	cp.w	r2,0
80006c48:	c0 21       	brne	80006c4c <LABEL_RET_SCALL_244>
80006c4a:	b1 c0       	cbr	r0,0x10

80006c4c <LABEL_RET_SCALL_244>:
80006c4c:	ef 40 ff f8 	st.w	r7[-8],r0
80006c50:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006c54:	ef 40 ff fc 	st.w	r7[-4],r0
80006c58:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006c5c:	2f ad       	sub	sp,-24
80006c5e:	d6 13       	rets
80006c60:	80 00       	ld.sh	r0,r0[0x0]
80006c62:	6b 68       	ld.w	r8,r5[0x58]
80006c64:	80 00       	ld.sh	r0,r0[0x0]
80006c66:	73 b0       	ld.w	r0,r9[0x6c]

80006c68 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006c68:	e1 b8 00 43 	mfsr	r8,0x10c
80006c6c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006c70:	5e fc       	retal	r12
80006c72:	d7 03       	nop

80006c74 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006c74:	48 78       	lddpc	r8,80006c90 <vPortExitCritical+0x1c>
80006c76:	70 08       	ld.w	r8,r8[0x0]
80006c78:	58 08       	cp.w	r8,0
80006c7a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006c7c:	48 58       	lddpc	r8,80006c90 <vPortExitCritical+0x1c>
80006c7e:	70 09       	ld.w	r9,r8[0x0]
80006c80:	20 19       	sub	r9,1
80006c82:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006c84:	70 08       	ld.w	r8,r8[0x0]
80006c86:	58 08       	cp.w	r8,0
80006c88:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006c8a:	d5 03       	csrf	0x10
80006c8c:	5e fc       	retal	r12
80006c8e:	00 00       	add	r0,r0
80006c90:	00 00       	add	r0,r0
80006c92:	00 24       	rsub	r4,r0

80006c94 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006c94:	eb cd 00 ff 	pushm	r0-r7
80006c98:	e0 68 00 24 	mov	r8,36
80006c9c:	ea 18 00 00 	orh	r8,0x0
80006ca0:	70 00       	ld.w	r0,r8[0x0]
80006ca2:	1a d0       	st.w	--sp,r0
80006ca4:	7a 90       	ld.w	r0,sp[0x24]
80006ca6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006caa:	58 10       	cp.w	r0,1
80006cac:	e0 8b 00 08 	brhi	80006cbc <LABEL_INT_SKIP_SAVE_CONTEXT_217>
80006cb0:	e0 68 06 6c 	mov	r8,1644
80006cb4:	ea 18 00 00 	orh	r8,0x0
80006cb8:	70 00       	ld.w	r0,r8[0x0]
80006cba:	81 0d       	st.w	r0[0x0],sp

80006cbc <LABEL_INT_SKIP_SAVE_CONTEXT_217>:
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
		clock cycles from now. */
		prvClearCcInt();
80006cbc:	f0 1f 00 12 	mcall	80006d04 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006cc0:	f0 1f 00 12 	mcall	80006d08 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x18>
		xTaskIncrementTick();
80006cc4:	f0 1f 00 12 	mcall	80006d0c <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x1c>
	portEXIT_CRITICAL();
80006cc8:	f0 1f 00 12 	mcall	80006d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006ccc:	7a 90       	ld.w	r0,sp[0x24]
80006cce:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006cd2:	58 10       	cp.w	r0,1
80006cd4:	e0 8b 00 0e 	brhi	80006cf0 <LABEL_INT_SKIP_RESTORE_CONTEXT_235>
80006cd8:	f0 1f 00 0c 	mcall	80006d08 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x18>
80006cdc:	f0 1f 00 0e 	mcall	80006d14 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x24>
80006ce0:	f0 1f 00 0c 	mcall	80006d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_235+0x20>
80006ce4:	e0 68 06 6c 	mov	r8,1644
80006ce8:	ea 18 00 00 	orh	r8,0x0
80006cec:	70 00       	ld.w	r0,r8[0x0]
80006cee:	60 0d       	ld.w	sp,r0[0x0]

80006cf0 <LABEL_INT_SKIP_RESTORE_CONTEXT_235>:
80006cf0:	1b 00       	ld.w	r0,sp++
80006cf2:	e0 68 00 24 	mov	r8,36
80006cf6:	ea 18 00 00 	orh	r8,0x0
80006cfa:	91 00       	st.w	r8[0x0],r0
80006cfc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006d00:	d6 03       	rete
80006d02:	00 00       	add	r0,r0
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	6c 68       	ld.w	r8,r6[0x18]
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	6b 68       	ld.w	r8,r5[0x58]
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	77 fc       	ld.w	r12,r11[0x7c]
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	6c 74       	ld.w	r4,r6[0x1c]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	73 b0       	ld.w	r0,r9[0x6c]

80006d18 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006d18:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006d1a:	f0 1f 00 02 	mcall	80006d20 <__malloc_lock+0x8>
}
80006d1e:	d8 02       	popm	pc
80006d20:	80 00       	ld.sh	r0,r0[0x0]
80006d22:	73 a0       	ld.w	r0,r9[0x68]

80006d24 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006d24:	d4 01       	pushm	lr
	xTaskResumeAll();
80006d26:	f0 1f 00 02 	mcall	80006d2c <__malloc_unlock+0x8>
}
80006d2a:	d8 02       	popm	pc
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	79 04       	ld.w	r4,r12[0x40]

80006d30 <_init_startup>:
 * vectors are not compatible with the SCALL management in the current FreeRTOS
 * port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80006d30:	d4 01       	pushm	lr
		extern void __heap_end__;
		BaseType_t *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80006d32:	48 b8       	lddpc	r8,80006d5c <_init_startup+0x2c>
80006d34:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80006d38:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80006d3a:	f0 1f 00 0a 	mcall	80006d60 <_init_startup+0x30>
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		//extern volatile avr32_usart_t *volatile stdio_usart_base;
		//stdio_usart_base = configDBG_USART;
		gpio_enable_module( DBG_USART_GPIO_MAP,
80006d3e:	30 2b       	mov	r11,2
80006d40:	48 9c       	lddpc	r12,80006d64 <_init_startup+0x34>
80006d42:	f0 1f 00 0a 	mcall	80006d68 <_init_startup+0x38>
		sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80006d46:	e0 6a 76 00 	mov	r10,30208
80006d4a:	ea 1a 03 b3 	orh	r10,0x3b3
80006d4e:	48 8b       	lddpc	r11,80006d6c <_init_startup+0x3c>
80006d50:	fe 7c 18 00 	mov	r12,-59392
80006d54:	f0 1f 00 07 	mcall	80006d70 <_init_startup+0x40>
	}
	#endif
	
	// Don't-care value for GCC.
	return 1;
}
80006d58:	da 0a       	popm	pc,r12=1
80006d5a:	00 00       	add	r0,r0
80006d5c:	80 00       	ld.sh	r0,r0[0x0]
80006d5e:	a0 00       	st.h	r0[0x0],r0
80006d60:	80 00       	ld.sh	r0,r0[0x0]
80006d62:	8d 80       	st.w	r6[0x20],r0
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	a7 8c       	lsr	r12,0x6
80006d68:	80 00       	ld.sh	r0,r0[0x0]
80006d6a:	8b e0       	st.w	r5[0x38],r0
80006d6c:	80 00       	ld.sh	r0,r0[0x0]
80006d6e:	a7 80       	lsr	r0,0x6
80006d70:	80 00       	ld.sh	r0,r0[0x0]
80006d72:	90 d4       	ld.uh	r4,r8[0xa]

80006d74 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
80006d74:	eb cd 40 80 	pushm	r7,lr
80006d78:	18 97       	mov	r7,r12
    if( pv )
80006d7a:	58 0c       	cp.w	r12,0
80006d7c:	c0 80       	breq	80006d8c <vPortFree+0x18>
    {
        vTaskSuspendAll();
80006d7e:	f0 1f 00 05 	mcall	80006d90 <vPortFree+0x1c>
        {
            free( pv );
80006d82:	0e 9c       	mov	r12,r7
80006d84:	f0 1f 00 04 	mcall	80006d94 <vPortFree+0x20>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
80006d88:	f0 1f 00 04 	mcall	80006d98 <vPortFree+0x24>
80006d8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	73 a0       	ld.w	r0,r9[0x68]
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	94 34       	ld.sh	r4,r10[0x6]
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	79 04       	ld.w	r4,r12[0x40]

80006d9c <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
80006d9c:	eb cd 40 80 	pushm	r7,lr
80006da0:	18 97       	mov	r7,r12
    void * pvReturn;

    vTaskSuspendAll();
80006da2:	f0 1f 00 06 	mcall	80006db8 <pvPortMalloc+0x1c>
    {
        pvReturn = malloc( xWantedSize );
80006da6:	0e 9c       	mov	r12,r7
80006da8:	f0 1f 00 05 	mcall	80006dbc <pvPortMalloc+0x20>
80006dac:	18 97       	mov	r7,r12
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
80006dae:	f0 1f 00 05 	mcall	80006dc0 <pvPortMalloc+0x24>
            }
        }
    #endif

    return pvReturn;
}
80006db2:	0e 9c       	mov	r12,r7
80006db4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006db8:	80 00       	ld.sh	r0,r0[0x0]
80006dba:	73 a0       	ld.w	r0,r9[0x68]
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	94 44       	ld.sh	r4,r10[0x8]
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	79 04       	ld.w	r4,r12[0x40]

80006dc4 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
80006dc4:	eb cd 40 80 	pushm	r7,lr
80006dc8:	18 97       	mov	r7,r12
    BaseType_t xReturn;

    taskENTER_CRITICAL();
80006dca:	f0 1f 00 05 	mcall	80006ddc <prvIsQueueEmpty+0x18>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
80006dce:	6e e7       	ld.w	r7,r7[0x38]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
80006dd0:	f0 1f 00 04 	mcall	80006de0 <prvIsQueueEmpty+0x1c>
80006dd4:	58 07       	cp.w	r7,0

    return xReturn;
}
80006dd6:	5f 0c       	sreq	r12
80006dd8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ddc:	80 00       	ld.sh	r0,r0[0x0]
80006dde:	6b 68       	ld.w	r8,r5[0x58]
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	6c 74       	ld.w	r4,r6[0x1c]

80006de4 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
80006de4:	d4 01       	pushm	lr
80006de6:	16 98       	mov	r8,r11
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80006de8:	79 09       	ld.w	r9,r12[0x40]
80006dea:	58 09       	cp.w	r9,0
80006dec:	c1 00       	breq	80006e0c <prvCopyDataFromQueue+0x28>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
80006dee:	78 3a       	ld.w	r10,r12[0xc]
80006df0:	f4 09 00 09 	add	r9,r10,r9
80006df4:	99 39       	st.w	r12[0xc],r9

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80006df6:	78 2a       	ld.w	r10,r12[0x8]
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
80006df8:	14 39       	cp.w	r9,r10
80006dfa:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006dfe:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
80006e02:	79 0a       	ld.w	r10,r12[0x40]
80006e04:	78 3b       	ld.w	r11,r12[0xc]
80006e06:	10 9c       	mov	r12,r8
80006e08:	f0 1f 00 02 	mcall	80006e10 <prvCopyDataFromQueue+0x2c>
80006e0c:	d8 02       	popm	pc
80006e0e:	00 00       	add	r0,r0
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	98 88       	ld.uh	r8,r12[0x0]

80006e14 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
80006e14:	d4 21       	pushm	r4-r7,lr
80006e16:	18 96       	mov	r6,r12

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
80006e18:	f0 1f 00 25 	mcall	80006eac <prvUnlockQueue+0x98>
    {
        int8_t cTxLock = pxQueue->cTxLock;
80006e1c:	ed 37 00 45 	ld.ub	r7,r6[69]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80006e20:	30 08       	mov	r8,0
80006e22:	f0 07 18 00 	cp.b	r7,r8
80006e26:	e0 8a 00 18 	brle	80006e56 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006e2a:	6c 98       	ld.w	r8,r6[0x24]
80006e2c:	58 08       	cp.w	r8,0
80006e2e:	c1 40       	breq	80006e56 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006e30:	ec c4 ff dc 	sub	r4,r6,-36
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80006e34:	30 05       	mov	r5,0
80006e36:	c0 48       	rjmp	80006e3e <prvUnlockQueue+0x2a>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006e38:	6c 98       	ld.w	r8,r6[0x24]
80006e3a:	58 08       	cp.w	r8,0
80006e3c:	c0 d0       	breq	80006e56 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006e3e:	08 9c       	mov	r12,r4
80006e40:	f0 1f 00 1c 	mcall	80006eb0 <prvUnlockQueue+0x9c>
80006e44:	c0 30       	breq	80006e4a <prvUnlockQueue+0x36>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
80006e46:	f0 1f 00 1c 	mcall	80006eb4 <prvUnlockQueue+0xa0>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
80006e4a:	20 17       	sub	r7,1
80006e4c:	5c 57       	castu.b	r7
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80006e4e:	ea 07 18 00 	cp.b	r7,r5
80006e52:	fe 99 ff f3 	brgt	80006e38 <prvUnlockQueue+0x24>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
80006e56:	3f f8       	mov	r8,-1
80006e58:	ed 68 00 45 	st.b	r6[69],r8
    }
    taskEXIT_CRITICAL();
80006e5c:	f0 1f 00 17 	mcall	80006eb8 <prvUnlockQueue+0xa4>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
80006e60:	f0 1f 00 13 	mcall	80006eac <prvUnlockQueue+0x98>
    {
        int8_t cRxLock = pxQueue->cRxLock;
80006e64:	ed 37 00 44 	ld.ub	r7,r6[68]

        while( cRxLock > queueLOCKED_UNMODIFIED )
80006e68:	30 08       	mov	r8,0
80006e6a:	f0 07 18 00 	cp.b	r7,r8
80006e6e:	e0 8a 00 18 	brle	80006e9e <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006e72:	6c 48       	ld.w	r8,r6[0x10]
80006e74:	58 08       	cp.w	r8,0
80006e76:	c1 40       	breq	80006e9e <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006e78:	ec c4 ff f0 	sub	r4,r6,-16
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
80006e7c:	30 05       	mov	r5,0
80006e7e:	c0 48       	rjmp	80006e86 <prvUnlockQueue+0x72>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006e80:	6c 48       	ld.w	r8,r6[0x10]
80006e82:	58 08       	cp.w	r8,0
80006e84:	c0 d0       	breq	80006e9e <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006e86:	08 9c       	mov	r12,r4
80006e88:	f0 1f 00 0a 	mcall	80006eb0 <prvUnlockQueue+0x9c>
80006e8c:	c0 30       	breq	80006e92 <prvUnlockQueue+0x7e>
                {
                    vTaskMissedYield();
80006e8e:	f0 1f 00 0a 	mcall	80006eb4 <prvUnlockQueue+0xa0>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
80006e92:	20 17       	sub	r7,1
80006e94:	5c 57       	castu.b	r7
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
80006e96:	ea 07 18 00 	cp.b	r7,r5
80006e9a:	fe 99 ff f3 	brgt	80006e80 <prvUnlockQueue+0x6c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
80006e9e:	3f f8       	mov	r8,-1
80006ea0:	ed 68 00 44 	st.b	r6[68],r8
    }
    taskEXIT_CRITICAL();
80006ea4:	f0 1f 00 05 	mcall	80006eb8 <prvUnlockQueue+0xa4>
}
80006ea8:	d8 22       	popm	r4-r7,pc
80006eaa:	00 00       	add	r0,r0
80006eac:	80 00       	ld.sh	r0,r0[0x0]
80006eae:	6b 68       	ld.w	r8,r5[0x58]
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	77 70       	ld.w	r0,r11[0x5c]
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	74 3c       	ld.w	r12,r10[0xc]
80006eb8:	80 00       	ld.sh	r0,r0[0x0]
80006eba:	6c 74       	ld.w	r4,r6[0x1c]

80006ebc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
80006ebc:	d4 31       	pushm	r0-r7,lr
80006ebe:	20 5d       	sub	sp,20
80006ec0:	18 97       	mov	r7,r12
80006ec2:	50 1b       	stdsp	sp[0x4],r11
80006ec4:	50 2a       	stdsp	sp[0x8],r10
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006ec6:	f8 c8 ff dc 	sub	r8,r12,-36
80006eca:	50 08       	stdsp	sp[0x0],r8
80006ecc:	30 04       	mov	r4,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80006ece:	fa c3 ff f4 	sub	r3,sp,-12
80006ed2:	30 10       	mov	r0,1

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
80006ed4:	3f f5       	mov	r5,-1
80006ed6:	30 01       	mov	r1,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006ed8:	fa c2 ff f8 	sub	r2,sp,-8
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80006edc:	f0 1f 00 30 	mcall	80006f9c <xQueueReceive+0xe0>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80006ee0:	6e e6       	ld.w	r6,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80006ee2:	58 06       	cp.w	r6,0
80006ee4:	c1 40       	breq	80006f0c <xQueueReceive+0x50>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
80006ee6:	40 1b       	lddsp	r11,sp[0x4]
80006ee8:	0e 9c       	mov	r12,r7
80006eea:	f0 1f 00 2e 	mcall	80006fa0 <xQueueReceive+0xe4>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
80006eee:	20 16       	sub	r6,1
80006ef0:	8f e6       	st.w	r7[0x38],r6

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006ef2:	6e 48       	ld.w	r8,r7[0x10]
80006ef4:	58 08       	cp.w	r8,0
80006ef6:	c0 70       	breq	80006f04 <xQueueReceive+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006ef8:	ee cc ff f0 	sub	r12,r7,-16
80006efc:	f0 1f 00 2a 	mcall	80006fa4 <xQueueReceive+0xe8>
80006f00:	c0 20       	breq	80006f04 <xQueueReceive+0x48>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
80006f02:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
80006f04:	f0 1f 00 29 	mcall	80006fa8 <xQueueReceive+0xec>
80006f08:	30 1c       	mov	r12,1
                return pdPASS;
80006f0a:	c4 78       	rjmp	80006f98 <xQueueReceive+0xdc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80006f0c:	40 28       	lddsp	r8,sp[0x8]
80006f0e:	58 08       	cp.w	r8,0
80006f10:	c0 51       	brne	80006f1a <xQueueReceive+0x5e>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
80006f12:	f0 1f 00 26 	mcall	80006fa8 <xQueueReceive+0xec>
80006f16:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80006f18:	c4 08       	rjmp	80006f98 <xQueueReceive+0xdc>
                }
                else if( xEntryTimeSet == pdFALSE )
80006f1a:	58 04       	cp.w	r4,0
80006f1c:	c0 51       	brne	80006f26 <xQueueReceive+0x6a>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80006f1e:	06 9c       	mov	r12,r3
80006f20:	f0 1f 00 23 	mcall	80006fac <xQueueReceive+0xf0>
80006f24:	00 94       	mov	r4,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80006f26:	f0 1f 00 21 	mcall	80006fa8 <xQueueReceive+0xec>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
80006f2a:	f0 1f 00 22 	mcall	80006fb0 <xQueueReceive+0xf4>
        prvLockQueue( pxQueue );
80006f2e:	f0 1f 00 1c 	mcall	80006f9c <xQueueReceive+0xe0>
80006f32:	ef 38 00 44 	ld.ub	r8,r7[68]
80006f36:	ea 08 18 00 	cp.b	r8,r5
80006f3a:	ef f1 0e 44 	st.beq	r7[0x44],r1
80006f3e:	ef 38 00 45 	ld.ub	r8,r7[69]
80006f42:	ea 08 18 00 	cp.b	r8,r5
80006f46:	ef f1 0e 45 	st.beq	r7[0x45],r1
80006f4a:	f0 1f 00 18 	mcall	80006fa8 <xQueueReceive+0xec>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006f4e:	04 9b       	mov	r11,r2
80006f50:	06 9c       	mov	r12,r3
80006f52:	f0 1f 00 19 	mcall	80006fb4 <xQueueReceive+0xf8>
80006f56:	c1 71       	brne	80006f84 <xQueueReceive+0xc8>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80006f58:	0e 9c       	mov	r12,r7
80006f5a:	f0 1f 00 18 	mcall	80006fb8 <xQueueReceive+0xfc>
80006f5e:	c0 d0       	breq	80006f78 <xQueueReceive+0xbc>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006f60:	40 2b       	lddsp	r11,sp[0x8]
80006f62:	40 0c       	lddsp	r12,sp[0x0]
80006f64:	f0 1f 00 16 	mcall	80006fbc <xQueueReceive+0x100>
                prvUnlockQueue( pxQueue );
80006f68:	0e 9c       	mov	r12,r7
80006f6a:	f0 1f 00 16 	mcall	80006fc0 <xQueueReceive+0x104>

                if( xTaskResumeAll() == pdFALSE )
80006f6e:	f0 1f 00 16 	mcall	80006fc4 <xQueueReceive+0x108>
80006f72:	cb 51       	brne	80006edc <xQueueReceive+0x20>
                {
                    portYIELD_WITHIN_API();
80006f74:	d7 33       	scall
80006f76:	cb 3b       	rjmp	80006edc <xQueueReceive+0x20>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
80006f78:	0e 9c       	mov	r12,r7
80006f7a:	f0 1f 00 12 	mcall	80006fc0 <xQueueReceive+0x104>
                ( void ) xTaskResumeAll();
80006f7e:	f0 1f 00 12 	mcall	80006fc4 <xQueueReceive+0x108>
80006f82:	ca db       	rjmp	80006edc <xQueueReceive+0x20>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
80006f84:	0e 9c       	mov	r12,r7
80006f86:	f0 1f 00 0f 	mcall	80006fc0 <xQueueReceive+0x104>
            ( void ) xTaskResumeAll();
80006f8a:	f0 1f 00 0f 	mcall	80006fc4 <xQueueReceive+0x108>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80006f8e:	0e 9c       	mov	r12,r7
80006f90:	f0 1f 00 0a 	mcall	80006fb8 <xQueueReceive+0xfc>
80006f94:	ca 40       	breq	80006edc <xQueueReceive+0x20>
80006f96:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
80006f98:	2f bd       	sub	sp,-20
80006f9a:	d8 32       	popm	r0-r7,pc
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	6b 68       	ld.w	r8,r5[0x58]
80006fa0:	80 00       	ld.sh	r0,r0[0x0]
80006fa2:	6d e4       	ld.w	r4,r6[0x78]
80006fa4:	80 00       	ld.sh	r0,r0[0x0]
80006fa6:	77 70       	ld.w	r0,r11[0x5c]
80006fa8:	80 00       	ld.sh	r0,r0[0x0]
80006faa:	6c 74       	ld.w	r4,r6[0x1c]
80006fac:	80 00       	ld.sh	r0,r0[0x0]
80006fae:	74 24       	ld.w	r4,r10[0x8]
80006fb0:	80 00       	ld.sh	r0,r0[0x0]
80006fb2:	73 a0       	ld.w	r0,r9[0x68]
80006fb4:	80 00       	ld.sh	r0,r0[0x0]
80006fb6:	74 90       	ld.w	r0,r10[0x24]
80006fb8:	80 00       	ld.sh	r0,r0[0x0]
80006fba:	6d c4       	ld.w	r4,r6[0x70]
80006fbc:	80 00       	ld.sh	r0,r0[0x0]
80006fbe:	7d 10       	ld.w	r0,lr[0x44]
80006fc0:	80 00       	ld.sh	r0,r0[0x0]
80006fc2:	6e 14       	ld.w	r4,r7[0x4]
80006fc4:	80 00       	ld.sh	r0,r0[0x0]
80006fc6:	79 04       	ld.w	r4,r12[0x40]

80006fc8 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
80006fc8:	d4 31       	pushm	r0-r7,lr
80006fca:	20 4d       	sub	sp,16
80006fcc:	18 97       	mov	r7,r12
80006fce:	50 1b       	stdsp	sp[0x4],r11
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006fd0:	f8 c1 ff dc 	sub	r1,r12,-36
80006fd4:	30 08       	mov	r8,0
80006fd6:	50 08       	stdsp	sp[0x0],r8
80006fd8:	10 95       	mov	r5,r8
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80006fda:	fa c4 ff f8 	sub	r4,sp,-8
80006fde:	30 10       	mov	r0,1

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
80006fe0:	3f f6       	mov	r6,-1
80006fe2:	30 02       	mov	r2,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006fe4:	fa c3 ff fc 	sub	r3,sp,-4
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80006fe8:	f0 1f 00 42 	mcall	800070f0 <xQueueSemaphoreTake+0x128>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
80006fec:	6e e8       	ld.w	r8,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
80006fee:	58 08       	cp.w	r8,0
80006ff0:	c1 60       	breq	8000701c <xQueueSemaphoreTake+0x54>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
80006ff2:	20 18       	sub	r8,1
80006ff4:	8f e8       	st.w	r7[0x38],r8

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006ff6:	6e 08       	ld.w	r8,r7[0x0]
80006ff8:	58 08       	cp.w	r8,0
80006ffa:	c0 41       	brne	80007002 <xQueueSemaphoreTake+0x3a>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
80006ffc:	f0 1f 00 3e 	mcall	800070f4 <xQueueSemaphoreTake+0x12c>
80007000:	8f 2c       	st.w	r7[0x8],r12
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007002:	6e 48       	ld.w	r8,r7[0x10]
80007004:	58 08       	cp.w	r8,0
80007006:	c0 70       	breq	80007014 <xQueueSemaphoreTake+0x4c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007008:	ee cc ff f0 	sub	r12,r7,-16
8000700c:	f0 1f 00 3b 	mcall	800070f8 <xQueueSemaphoreTake+0x130>
80007010:	c0 20       	breq	80007014 <xQueueSemaphoreTake+0x4c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
80007012:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
80007014:	f0 1f 00 3a 	mcall	800070fc <xQueueSemaphoreTake+0x134>
80007018:	30 1c       	mov	r12,1
                return pdPASS;
8000701a:	c6 88       	rjmp	800070ea <xQueueSemaphoreTake+0x122>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
8000701c:	40 18       	lddsp	r8,sp[0x4]
8000701e:	58 08       	cp.w	r8,0
80007020:	c0 51       	brne	8000702a <xQueueSemaphoreTake+0x62>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
80007022:	f0 1f 00 37 	mcall	800070fc <xQueueSemaphoreTake+0x134>
80007026:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80007028:	c6 18       	rjmp	800070ea <xQueueSemaphoreTake+0x122>
                }
                else if( xEntryTimeSet == pdFALSE )
8000702a:	58 05       	cp.w	r5,0
8000702c:	c0 51       	brne	80007036 <xQueueSemaphoreTake+0x6e>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000702e:	08 9c       	mov	r12,r4
80007030:	f0 1f 00 34 	mcall	80007100 <xQueueSemaphoreTake+0x138>
80007034:	00 95       	mov	r5,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80007036:	f0 1f 00 32 	mcall	800070fc <xQueueSemaphoreTake+0x134>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
8000703a:	f0 1f 00 33 	mcall	80007104 <xQueueSemaphoreTake+0x13c>
        prvLockQueue( pxQueue );
8000703e:	f0 1f 00 2d 	mcall	800070f0 <xQueueSemaphoreTake+0x128>
80007042:	ef 38 00 44 	ld.ub	r8,r7[68]
80007046:	ec 08 18 00 	cp.b	r8,r6
8000704a:	ef f2 0e 44 	st.beq	r7[0x44],r2
8000704e:	ef 38 00 45 	ld.ub	r8,r7[69]
80007052:	ec 08 18 00 	cp.b	r8,r6
80007056:	ef f2 0e 45 	st.beq	r7[0x45],r2
8000705a:	f0 1f 00 29 	mcall	800070fc <xQueueSemaphoreTake+0x134>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000705e:	06 9b       	mov	r11,r3
80007060:	08 9c       	mov	r12,r4
80007062:	f0 1f 00 2a 	mcall	80007108 <xQueueSemaphoreTake+0x140>
80007066:	c2 21       	brne	800070aa <xQueueSemaphoreTake+0xe2>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80007068:	0e 9c       	mov	r12,r7
8000706a:	f0 1f 00 29 	mcall	8000710c <xQueueSemaphoreTake+0x144>
8000706e:	c1 80       	breq	8000709e <xQueueSemaphoreTake+0xd6>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007070:	6e 08       	ld.w	r8,r7[0x0]
80007072:	58 08       	cp.w	r8,0
80007074:	c0 91       	brne	80007086 <xQueueSemaphoreTake+0xbe>
                        {
                            taskENTER_CRITICAL();
80007076:	f0 1f 00 1f 	mcall	800070f0 <xQueueSemaphoreTake+0x128>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
8000707a:	6e 2c       	ld.w	r12,r7[0x8]
8000707c:	f0 1f 00 25 	mcall	80007110 <xQueueSemaphoreTake+0x148>
80007080:	50 0c       	stdsp	sp[0x0],r12
                            }
                            taskEXIT_CRITICAL();
80007082:	f0 1f 00 1f 	mcall	800070fc <xQueueSemaphoreTake+0x134>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007086:	40 1b       	lddsp	r11,sp[0x4]
80007088:	02 9c       	mov	r12,r1
8000708a:	f0 1f 00 23 	mcall	80007114 <xQueueSemaphoreTake+0x14c>
                prvUnlockQueue( pxQueue );
8000708e:	0e 9c       	mov	r12,r7
80007090:	f0 1f 00 22 	mcall	80007118 <xQueueSemaphoreTake+0x150>

                if( xTaskResumeAll() == pdFALSE )
80007094:	f0 1f 00 22 	mcall	8000711c <xQueueSemaphoreTake+0x154>
80007098:	ca 81       	brne	80006fe8 <xQueueSemaphoreTake+0x20>
                {
                    portYIELD_WITHIN_API();
8000709a:	d7 33       	scall
8000709c:	ca 6b       	rjmp	80006fe8 <xQueueSemaphoreTake+0x20>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
8000709e:	0e 9c       	mov	r12,r7
800070a0:	f0 1f 00 1e 	mcall	80007118 <xQueueSemaphoreTake+0x150>
                ( void ) xTaskResumeAll();
800070a4:	f0 1f 00 1e 	mcall	8000711c <xQueueSemaphoreTake+0x154>
800070a8:	ca 0b       	rjmp	80006fe8 <xQueueSemaphoreTake+0x20>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
800070aa:	0e 9c       	mov	r12,r7
800070ac:	f0 1f 00 1b 	mcall	80007118 <xQueueSemaphoreTake+0x150>
            ( void ) xTaskResumeAll();
800070b0:	f0 1f 00 1b 	mcall	8000711c <xQueueSemaphoreTake+0x154>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800070b4:	0e 9c       	mov	r12,r7
800070b6:	f0 1f 00 16 	mcall	8000710c <xQueueSemaphoreTake+0x144>
800070ba:	c9 70       	breq	80006fe8 <xQueueSemaphoreTake+0x20>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
800070bc:	40 08       	lddsp	r8,sp[0x0]
800070be:	58 08       	cp.w	r8,0
800070c0:	c0 31       	brne	800070c6 <xQueueSemaphoreTake+0xfe>
800070c2:	30 0c       	mov	r12,0
800070c4:	c1 38       	rjmp	800070ea <xQueueSemaphoreTake+0x122>
                        {
                            taskENTER_CRITICAL();
800070c6:	f0 1f 00 0b 	mcall	800070f0 <xQueueSemaphoreTake+0x128>
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
800070ca:	6e 98       	ld.w	r8,r7[0x24]
800070cc:	58 08       	cp.w	r8,0
800070ce:	f9 bb 00 00 	moveq	r11,0
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
800070d2:	ef f8 10 0c 	ld.wne	r8,r7[0x30]
800070d6:	f1 fb 10 00 	ld.wne	r11,r8[0x0]
800070da:	fb bb 01 08 	rsubne	r11,8
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
800070de:	6e 2c       	ld.w	r12,r7[0x8]
800070e0:	f0 1f 00 10 	mcall	80007120 <xQueueSemaphoreTake+0x158>
                            }
                            taskEXIT_CRITICAL();
800070e4:	f0 1f 00 06 	mcall	800070fc <xQueueSemaphoreTake+0x134>
800070e8:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
800070ea:	2f cd       	sub	sp,-16
800070ec:	d8 32       	popm	r0-r7,pc
800070ee:	00 00       	add	r0,r0
800070f0:	80 00       	ld.sh	r0,r0[0x0]
800070f2:	6b 68       	ld.w	r8,r5[0x58]
800070f4:	80 00       	ld.sh	r0,r0[0x0]
800070f6:	74 70       	ld.w	r0,r10[0x1c]
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	77 70       	ld.w	r0,r11[0x5c]
800070fc:	80 00       	ld.sh	r0,r0[0x0]
800070fe:	6c 74       	ld.w	r4,r6[0x1c]
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	74 24       	ld.w	r4,r10[0x8]
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	73 a0       	ld.w	r0,r9[0x68]
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	74 90       	ld.w	r0,r10[0x24]
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	6d c4       	ld.w	r4,r6[0x70]
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	76 cc       	ld.w	r12,r11[0x30]
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	7d 10       	ld.w	r0,lr[0x44]
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	6e 14       	ld.w	r4,r7[0x4]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	79 04       	ld.w	r4,r12[0x40]
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	75 e8       	ld.w	r8,r10[0x78]

80007124 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
80007124:	eb cd 40 e0 	pushm	r5-r7,lr
80007128:	18 97       	mov	r7,r12
8000712a:	14 96       	mov	r6,r10
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
8000712c:	78 e5       	ld.w	r5,r12[0x38]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
8000712e:	79 0a       	ld.w	r10,r12[0x40]
80007130:	58 0a       	cp.w	r10,0
80007132:	c0 a1       	brne	80007146 <prvCopyDataToQueue+0x22>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007134:	78 08       	ld.w	r8,r12[0x0]
80007136:	58 08       	cp.w	r8,0
80007138:	c3 11       	brne	8000719a <prvCopyDataToQueue+0x76>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
8000713a:	78 2c       	ld.w	r12,r12[0x8]
8000713c:	f0 1f 00 1a 	mcall	800071a4 <prvCopyDataToQueue+0x80>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
80007140:	30 08       	mov	r8,0
80007142:	8f 28       	st.w	r7[0x8],r8
80007144:	c2 c8       	rjmp	8000719c <prvCopyDataToQueue+0x78>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
80007146:	58 06       	cp.w	r6,0
80007148:	c1 01       	brne	80007168 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
8000714a:	78 1c       	ld.w	r12,r12[0x4]
8000714c:	f0 1f 00 17 	mcall	800071a8 <prvCopyDataToQueue+0x84>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
80007150:	6e 19       	ld.w	r9,r7[0x4]
80007152:	6f 08       	ld.w	r8,r7[0x40]
80007154:	f2 08 00 08 	add	r8,r9,r8
80007158:	8f 18       	st.w	r7[0x4],r8

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
8000715a:	6e 29       	ld.w	r9,r7[0x8]
8000715c:	12 38       	cp.w	r8,r9
8000715e:	c1 e3       	brcs	8000719a <prvCopyDataToQueue+0x76>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
80007160:	6e 08       	ld.w	r8,r7[0x0]
80007162:	8f 18       	st.w	r7[0x4],r8
80007164:	30 0c       	mov	r12,0
80007166:	c1 b8       	rjmp	8000719c <prvCopyDataToQueue+0x78>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
80007168:	78 3c       	ld.w	r12,r12[0xc]
8000716a:	f0 1f 00 10 	mcall	800071a8 <prvCopyDataToQueue+0x84>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
8000716e:	6f 08       	ld.w	r8,r7[0x40]
80007170:	6e 39       	ld.w	r9,r7[0xc]
80007172:	f2 08 01 08 	sub	r8,r9,r8
80007176:	8f 38       	st.w	r7[0xc],r8

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80007178:	6e 09       	ld.w	r9,r7[0x0]
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
8000717a:	12 38       	cp.w	r8,r9
8000717c:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80007180:	ef f9 30 02 	ld.wcs	r9,r7[0x8]
80007184:	f3 d8 e3 19 	subcs	r9,r9,r8
80007188:	ef f9 3a 03 	st.wcs	r7[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
8000718c:	58 26       	cp.w	r6,2
8000718e:	c0 61       	brne	8000719a <prvCopyDataToQueue+0x76>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80007190:	58 05       	cp.w	r5,0
80007192:	c0 40       	breq	8000719a <prvCopyDataToQueue+0x76>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
80007194:	20 15       	sub	r5,1
80007196:	30 0c       	mov	r12,0
80007198:	c0 28       	rjmp	8000719c <prvCopyDataToQueue+0x78>
8000719a:	30 0c       	mov	r12,0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
8000719c:	2f f5       	sub	r5,-1
8000719e:	8f e5       	st.w	r7[0x38],r5

    return xReturn;
}
800071a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	76 64       	ld.w	r4,r11[0x18]
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	98 88       	ld.uh	r8,r12[0x0]

800071ac <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
800071ac:	d4 31       	pushm	r0-r7,lr
800071ae:	20 5d       	sub	sp,20
800071b0:	18 97       	mov	r7,r12
800071b2:	50 1b       	stdsp	sp[0x4],r11
800071b4:	50 2a       	stdsp	sp[0x8],r10
800071b6:	12 91       	mov	r1,r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800071b8:	f8 c8 ff f0 	sub	r8,r12,-16
800071bc:	50 08       	stdsp	sp[0x0],r8
800071be:	30 03       	mov	r3,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800071c0:	fa c2 ff f4 	sub	r2,sp,-12

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
800071c4:	3f f5       	mov	r5,-1

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071c6:	fa c0 ff f8 	sub	r0,sp,-8
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
800071ca:	f0 1f 00 36 	mcall	800072a0 <xQueueGenericSend+0xf4>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
800071ce:	6e e9       	ld.w	r9,r7[0x38]
800071d0:	6e f8       	ld.w	r8,r7[0x3c]
800071d2:	10 39       	cp.w	r9,r8
800071d4:	c0 33       	brcs	800071da <xQueueGenericSend+0x2e>
800071d6:	58 21       	cp.w	r1,2
800071d8:	c1 71       	brne	80007206 <xQueueGenericSend+0x5a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800071da:	02 9a       	mov	r10,r1
800071dc:	40 1b       	lddsp	r11,sp[0x4]
800071de:	0e 9c       	mov	r12,r7
800071e0:	f0 1f 00 31 	mcall	800072a4 <xQueueGenericSend+0xf8>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800071e4:	6e 98       	ld.w	r8,r7[0x24]
800071e6:	58 08       	cp.w	r8,0
800071e8:	c0 80       	breq	800071f8 <xQueueGenericSend+0x4c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800071ea:	ee cc ff dc 	sub	r12,r7,-36
800071ee:	f0 1f 00 2f 	mcall	800072a8 <xQueueGenericSend+0xfc>
800071f2:	c0 60       	breq	800071fe <xQueueGenericSend+0x52>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
800071f4:	d7 33       	scall
800071f6:	c0 48       	rjmp	800071fe <xQueueGenericSend+0x52>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
800071f8:	58 0c       	cp.w	r12,0
800071fa:	c0 20       	breq	800071fe <xQueueGenericSend+0x52>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
800071fc:	d7 33       	scall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
800071fe:	f0 1f 00 2c 	mcall	800072ac <xQueueGenericSend+0x100>
80007202:	30 1c       	mov	r12,1
                return pdPASS;
80007204:	c4 b8       	rjmp	8000729a <xQueueGenericSend+0xee>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007206:	40 28       	lddsp	r8,sp[0x8]
80007208:	58 08       	cp.w	r8,0
8000720a:	c0 51       	brne	80007214 <xQueueGenericSend+0x68>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
8000720c:	f0 1f 00 28 	mcall	800072ac <xQueueGenericSend+0x100>
80007210:	30 0c       	mov	r12,0

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
80007212:	c4 48       	rjmp	8000729a <xQueueGenericSend+0xee>
                }
                else if( xEntryTimeSet == pdFALSE )
80007214:	58 03       	cp.w	r3,0
80007216:	c0 51       	brne	80007220 <xQueueGenericSend+0x74>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007218:	04 9c       	mov	r12,r2
8000721a:	f0 1f 00 26 	mcall	800072b0 <xQueueGenericSend+0x104>
8000721e:	30 13       	mov	r3,1
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80007220:	f0 1f 00 23 	mcall	800072ac <xQueueGenericSend+0x100>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
80007224:	f0 1f 00 24 	mcall	800072b4 <xQueueGenericSend+0x108>
        prvLockQueue( pxQueue );
80007228:	f0 1f 00 1e 	mcall	800072a0 <xQueueGenericSend+0xf4>
8000722c:	ef 38 00 44 	ld.ub	r8,r7[68]
80007230:	ea 08 18 00 	cp.b	r8,r5
80007234:	f9 b8 00 00 	moveq	r8,0
80007238:	ef f8 0e 44 	st.beq	r7[0x44],r8
8000723c:	ef 38 00 45 	ld.ub	r8,r7[69]
80007240:	ea 08 18 00 	cp.b	r8,r5
80007244:	f9 b8 00 00 	moveq	r8,0
80007248:	ef f8 0e 45 	st.beq	r7[0x45],r8
8000724c:	f0 1f 00 18 	mcall	800072ac <xQueueGenericSend+0x100>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007250:	00 9b       	mov	r11,r0
80007252:	04 9c       	mov	r12,r2
80007254:	f0 1f 00 19 	mcall	800072b8 <xQueueGenericSend+0x10c>
80007258:	c1 b1       	brne	8000728e <xQueueGenericSend+0xe2>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
8000725a:	f0 1f 00 12 	mcall	800072a0 <xQueueGenericSend+0xf4>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
8000725e:	6e e4       	ld.w	r4,r7[0x38]
80007260:	6e f6       	ld.w	r6,r7[0x3c]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
80007262:	f0 1f 00 13 	mcall	800072ac <xQueueGenericSend+0x100>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
80007266:	0c 34       	cp.w	r4,r6
80007268:	c0 d1       	brne	80007282 <xQueueGenericSend+0xd6>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000726a:	40 2b       	lddsp	r11,sp[0x8]
8000726c:	40 0c       	lddsp	r12,sp[0x0]
8000726e:	f0 1f 00 14 	mcall	800072bc <xQueueGenericSend+0x110>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
80007272:	0e 9c       	mov	r12,r7
80007274:	f0 1f 00 13 	mcall	800072c0 <xQueueGenericSend+0x114>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
80007278:	f0 1f 00 13 	mcall	800072c4 <xQueueGenericSend+0x118>
8000727c:	ca 71       	brne	800071ca <xQueueGenericSend+0x1e>
                {
                    portYIELD_WITHIN_API();
8000727e:	d7 33       	scall
80007280:	ca 5b       	rjmp	800071ca <xQueueGenericSend+0x1e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
80007282:	0e 9c       	mov	r12,r7
80007284:	f0 1f 00 0f 	mcall	800072c0 <xQueueGenericSend+0x114>
                ( void ) xTaskResumeAll();
80007288:	f0 1f 00 0f 	mcall	800072c4 <xQueueGenericSend+0x118>
8000728c:	c9 fb       	rjmp	800071ca <xQueueGenericSend+0x1e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
8000728e:	0e 9c       	mov	r12,r7
80007290:	f0 1f 00 0c 	mcall	800072c0 <xQueueGenericSend+0x114>
            ( void ) xTaskResumeAll();
80007294:	f0 1f 00 0c 	mcall	800072c4 <xQueueGenericSend+0x118>
80007298:	30 0c       	mov	r12,0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
8000729a:	2f bd       	sub	sp,-20
8000729c:	d8 32       	popm	r0-r7,pc
8000729e:	00 00       	add	r0,r0
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	6b 68       	ld.w	r8,r5[0x58]
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	71 24       	ld.w	r4,r8[0x48]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	77 70       	ld.w	r0,r11[0x5c]
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	6c 74       	ld.w	r4,r6[0x1c]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	74 24       	ld.w	r4,r10[0x8]
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	73 a0       	ld.w	r0,r9[0x68]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	74 90       	ld.w	r0,r10[0x24]
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	7d 10       	ld.w	r0,lr[0x44]
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	6e 14       	ld.w	r4,r7[0x4]
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	79 04       	ld.w	r4,r12[0x40]

800072c8 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
800072c8:	eb cd 40 c0 	pushm	r6-r7,lr
800072cc:	18 97       	mov	r7,r12
800072ce:	16 96       	mov	r6,r11
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
800072d0:	f0 1f 00 18 	mcall	80007330 <xQueueGenericReset+0x68>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
800072d4:	6f 09       	ld.w	r9,r7[0x40]
800072d6:	6e fa       	ld.w	r10,r7[0x3c]
800072d8:	f2 0a 02 4b 	mul	r11,r9,r10
800072dc:	6e 08       	ld.w	r8,r7[0x0]
800072de:	f0 0b 00 0b 	add	r11,r8,r11
800072e2:	8f 2b       	st.w	r7[0x8],r11
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
800072e4:	30 0b       	mov	r11,0
800072e6:	8f eb       	st.w	r7[0x38],r11
        pxQueue->pcWriteTo = pxQueue->pcHead;
800072e8:	8f 18       	st.w	r7[0x4],r8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
800072ea:	20 1a       	sub	r10,1
800072ec:	f4 09 02 49 	mul	r9,r10,r9
800072f0:	12 08       	add	r8,r9
800072f2:	8f 38       	st.w	r7[0xc],r8
        pxQueue->cRxLock = queueUNLOCKED;
800072f4:	3f f8       	mov	r8,-1
800072f6:	ef 68 00 44 	st.b	r7[68],r8
        pxQueue->cTxLock = queueUNLOCKED;
800072fa:	ef 68 00 45 	st.b	r7[69],r8

        if( xNewQueue == pdFALSE )
800072fe:	58 06       	cp.w	r6,0
80007300:	c0 b1       	brne	80007316 <xQueueGenericReset+0x4e>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007302:	6e 48       	ld.w	r8,r7[0x10]
80007304:	58 08       	cp.w	r8,0
80007306:	c1 00       	breq	80007326 <xQueueGenericReset+0x5e>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007308:	ee cc ff f0 	sub	r12,r7,-16
8000730c:	f0 1f 00 0a 	mcall	80007334 <xQueueGenericReset+0x6c>
80007310:	c0 b0       	breq	80007326 <xQueueGenericReset+0x5e>
                {
                    queueYIELD_IF_USING_PREEMPTION();
80007312:	d7 33       	scall
80007314:	c0 98       	rjmp	80007326 <xQueueGenericReset+0x5e>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80007316:	ee cc ff f0 	sub	r12,r7,-16
8000731a:	f0 1f 00 08 	mcall	80007338 <xQueueGenericReset+0x70>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
8000731e:	ee cc ff dc 	sub	r12,r7,-36
80007322:	f0 1f 00 06 	mcall	80007338 <xQueueGenericReset+0x70>
        }
    }
    taskEXIT_CRITICAL();
80007326:	f0 1f 00 06 	mcall	8000733c <xQueueGenericReset+0x74>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
8000732a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000732e:	00 00       	add	r0,r0
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	6b 68       	ld.w	r8,r5[0x58]
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	77 70       	ld.w	r0,r11[0x5c]
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	6a 4c       	ld.w	r12,r5[0x10]
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	6c 74       	ld.w	r4,r6[0x1c]

80007340 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
80007340:	eb cd 40 e0 	pushm	r5-r7,lr
80007344:	18 95       	mov	r5,r12
80007346:	16 96       	mov	r6,r11
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
80007348:	f6 0c 02 4c 	mul	r12,r11,r12
8000734c:	2b 8c       	sub	r12,-72
8000734e:	f0 1f 00 0b 	mcall	80007378 <xQueueGenericCreate+0x38>
80007352:	18 97       	mov	r7,r12

        if( pxNewQueue != NULL )
80007354:	c0 f0       	breq	80007372 <xQueueGenericCreate+0x32>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
80007356:	58 06       	cp.w	r6,0
80007358:	c0 31       	brne	8000735e <xQueueGenericCreate+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
8000735a:	8f 0c       	st.w	r7[0x0],r12
8000735c:	c0 48       	rjmp	80007364 <xQueueGenericCreate+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
8000735e:	f8 c8 ff b8 	sub	r8,r12,-72
80007362:	99 08       	st.w	r12[0x0],r8
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
80007364:	8f f5       	st.w	r7[0x3c],r5
    pxNewQueue->uxItemSize = uxItemSize;
80007366:	ef 46 00 40 	st.w	r7[64],r6
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
8000736a:	30 1b       	mov	r11,1
8000736c:	0e 9c       	mov	r12,r7
8000736e:	f0 1f 00 04 	mcall	8000737c <xQueueGenericCreate+0x3c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
80007372:	0e 9c       	mov	r12,r7
80007374:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	6d 9c       	ld.w	r12,r6[0x64]
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	72 c8       	ld.w	r8,r9[0x30]

80007380 <prvTaskIsTaskSuspended>:

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80007380:	78 59       	ld.w	r9,r12[0x14]
80007382:	48 68       	lddpc	r8,80007398 <prvTaskIsTaskSuspended+0x18>
80007384:	10 39       	cp.w	r9,r8
80007386:	c0 81       	brne	80007396 <prvTaskIsTaskSuspended+0x16>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
80007388:	78 a8       	ld.w	r8,r12[0x28]
8000738a:	48 59       	lddpc	r9,8000739c <prvTaskIsTaskSuspended+0x1c>
8000738c:	12 38       	cp.w	r8,r9
8000738e:	c0 40       	breq	80007396 <prvTaskIsTaskSuspended+0x16>
80007390:	58 08       	cp.w	r8,0
80007392:	5f 0c       	sreq	r12
80007394:	5e fc       	retal	r12
80007396:	5e fd       	retal	0
80007398:	00 00       	add	r0,r0
8000739a:	06 d4       	st.w	--r3,r4
8000739c:	00 00       	add	r0,r0
8000739e:	06 70       	tst	r0,r3

800073a0 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
800073a0:	48 38       	lddpc	r8,800073ac <vTaskSuspendAll+0xc>
800073a2:	70 09       	ld.w	r9,r8[0x0]
800073a4:	2f f9       	sub	r9,-1
800073a6:	91 09       	st.w	r8[0x0],r9

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
800073a8:	5e fc       	retal	r12
800073aa:	00 00       	add	r0,r0
800073ac:	00 00       	add	r0,r0
800073ae:	06 9c       	mov	r12,r3

800073b0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
800073b0:	49 88       	lddpc	r8,80007410 <vTaskSwitchContext+0x60>
800073b2:	70 08       	ld.w	r8,r8[0x0]
800073b4:	58 08       	cp.w	r8,0
800073b6:	c0 50       	breq	800073c0 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
800073b8:	30 19       	mov	r9,1
800073ba:	49 78       	lddpc	r8,80007414 <vTaskSwitchContext+0x64>
800073bc:	91 09       	st.w	r8[0x0],r9
800073be:	5e fc       	retal	r12
    }
    else
    {
        xYieldPending = pdFALSE;
800073c0:	30 09       	mov	r9,0
800073c2:	49 58       	lddpc	r8,80007414 <vTaskSwitchContext+0x64>
800073c4:	91 09       	st.w	r8[0x0],r9
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800073c6:	49 58       	lddpc	r8,80007418 <vTaskSwitchContext+0x68>
800073c8:	70 09       	ld.w	r9,r8[0x0]
800073ca:	f2 09 00 28 	add	r8,r9,r9<<0x2
800073ce:	a3 68       	lsl	r8,0x2
800073d0:	49 3b       	lddpc	r11,8000741c <vTaskSwitchContext+0x6c>
800073d2:	10 0b       	add	r11,r8
800073d4:	76 0a       	ld.w	r10,r11[0x0]
800073d6:	58 0a       	cp.w	r10,0
800073d8:	c0 b1       	brne	800073ee <vTaskSwitchContext+0x3e>
800073da:	21 48       	sub	r8,20
800073dc:	49 0a       	lddpc	r10,8000741c <vTaskSwitchContext+0x6c>
800073de:	f4 08 00 08 	add	r8,r10,r8
800073e2:	20 19       	sub	r9,1
800073e4:	10 9b       	mov	r11,r8
800073e6:	70 0a       	ld.w	r10,r8[0x0]
800073e8:	21 48       	sub	r8,20
800073ea:	58 0a       	cp.w	r10,0
800073ec:	cf b0       	breq	800073e2 <vTaskSwitchContext+0x32>
800073ee:	76 18       	ld.w	r8,r11[0x4]
800073f0:	70 18       	ld.w	r8,r8[0x4]
800073f2:	97 18       	st.w	r11[0x4],r8
800073f4:	f6 ca ff f8 	sub	r10,r11,-8
800073f8:	14 38       	cp.w	r8,r10
800073fa:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
800073fe:	f7 f8 0a 01 	st.weq	r11[0x4],r8
80007402:	76 18       	ld.w	r8,r11[0x4]
80007404:	70 3a       	ld.w	r10,r8[0xc]
80007406:	48 78       	lddpc	r8,80007420 <vTaskSwitchContext+0x70>
80007408:	91 0a       	st.w	r8[0x0],r10
8000740a:	48 48       	lddpc	r8,80007418 <vTaskSwitchContext+0x68>
8000740c:	91 09       	st.w	r8[0x0],r9
8000740e:	5e fc       	retal	r12
80007410:	00 00       	add	r0,r0
80007412:	06 9c       	mov	r12,r3
80007414:	00 00       	add	r0,r0
80007416:	06 ec       	st.h	--r3,r12
80007418:	00 00       	add	r0,r0
8000741a:	06 e8       	st.h	--r3,r8
8000741c:	00 00       	add	r0,r0
8000741e:	05 c8       	ld.ub	r8,r2[0x4]
80007420:	00 00       	add	r0,r0
80007422:	06 6c       	and	r12,r3

80007424 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
80007424:	48 48       	lddpc	r8,80007434 <vTaskInternalSetTimeOutState+0x10>
80007426:	70 08       	ld.w	r8,r8[0x0]
80007428:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
8000742a:	48 48       	lddpc	r8,80007438 <vTaskInternalSetTimeOutState+0x14>
8000742c:	70 08       	ld.w	r8,r8[0x0]
8000742e:	99 18       	st.w	r12[0x4],r8
}
80007430:	5e fc       	retal	r12
80007432:	00 00       	add	r0,r0
80007434:	00 00       	add	r0,r0
80007436:	05 bc       	ld.ub	r12,r2[0x3]
80007438:	00 00       	add	r0,r0
8000743a:	06 98       	mov	r8,r3

8000743c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
8000743c:	30 19       	mov	r9,1
8000743e:	48 28       	lddpc	r8,80007444 <vTaskMissedYield+0x8>
80007440:	91 09       	st.w	r8[0x0],r9
}
80007442:	5e fc       	retal	r12
80007444:	00 00       	add	r0,r0
80007446:	06 ec       	st.h	--r3,r12

80007448 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007448:	48 88       	lddpc	r8,80007468 <prvResetNextTaskUnblockTime+0x20>
8000744a:	70 08       	ld.w	r8,r8[0x0]
8000744c:	70 08       	ld.w	r8,r8[0x0]
8000744e:	58 08       	cp.w	r8,0
80007450:	c0 51       	brne	8000745a <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
80007452:	3f f9       	mov	r9,-1
80007454:	48 68       	lddpc	r8,8000746c <prvResetNextTaskUnblockTime+0x24>
80007456:	91 09       	st.w	r8[0x0],r9
80007458:	5e fc       	retal	r12
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
8000745a:	48 48       	lddpc	r8,80007468 <prvResetNextTaskUnblockTime+0x20>
8000745c:	70 08       	ld.w	r8,r8[0x0]
8000745e:	70 38       	ld.w	r8,r8[0xc]
80007460:	70 09       	ld.w	r9,r8[0x0]
80007462:	48 38       	lddpc	r8,8000746c <prvResetNextTaskUnblockTime+0x24>
80007464:	91 09       	st.w	r8[0x0],r9
80007466:	5e fc       	retal	r12
80007468:	00 00       	add	r0,r0
8000746a:	05 b4       	ld.ub	r4,r2[0x3]
8000746c:	00 00       	add	r0,r0
8000746e:	05 b0       	ld.ub	r0,r2[0x3]

80007470 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
80007470:	48 78       	lddpc	r8,8000748c <pvTaskIncrementMutexHeldCount+0x1c>
80007472:	70 08       	ld.w	r8,r8[0x0]
80007474:	58 08       	cp.w	r8,0
80007476:	c0 70       	breq	80007484 <pvTaskIncrementMutexHeldCount+0x14>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
80007478:	48 58       	lddpc	r8,8000748c <pvTaskIncrementMutexHeldCount+0x1c>
8000747a:	70 08       	ld.w	r8,r8[0x0]
8000747c:	71 29       	ld.w	r9,r8[0x48]
8000747e:	2f f9       	sub	r9,-1
80007480:	f1 49 00 48 	st.w	r8[72],r9
        }

        return pxCurrentTCB;
80007484:	48 28       	lddpc	r8,8000748c <pvTaskIncrementMutexHeldCount+0x1c>
80007486:	70 0c       	ld.w	r12,r8[0x0]
    }
80007488:	5e fc       	retal	r12
8000748a:	00 00       	add	r0,r0
8000748c:	00 00       	add	r0,r0
8000748e:	06 6c       	and	r12,r3

80007490 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
80007490:	eb cd 40 c0 	pushm	r6-r7,lr
80007494:	18 97       	mov	r7,r12
80007496:	16 96       	mov	r6,r11
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
80007498:	f0 1f 00 14 	mcall	800074e8 <xTaskCheckForTimeOut+0x58>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
8000749c:	49 48       	lddpc	r8,800074ec <xTaskCheckForTimeOut+0x5c>
8000749e:	70 0a       	ld.w	r10,r8[0x0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
800074a0:	6e 19       	ld.w	r9,r7[0x4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
800074a2:	6c 08       	ld.w	r8,r6[0x0]
800074a4:	5b f8       	cp.w	r8,-1
800074a6:	c0 31       	brne	800074ac <xTaskCheckForTimeOut+0x1c>
800074a8:	30 07       	mov	r7,0
800074aa:	c1 a8       	rjmp	800074de <xTaskCheckForTimeOut+0x4e>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
800074ac:	49 1b       	lddpc	r11,800074f0 <xTaskCheckForTimeOut+0x60>
800074ae:	76 0b       	ld.w	r11,r11[0x0]
800074b0:	6e 0c       	ld.w	r12,r7[0x0]
800074b2:	16 3c       	cp.w	r12,r11
800074b4:	c0 70       	breq	800074c2 <xTaskCheckForTimeOut+0x32>
800074b6:	12 3a       	cp.w	r10,r9
800074b8:	c0 53       	brcs	800074c2 <xTaskCheckForTimeOut+0x32>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
800074ba:	30 08       	mov	r8,0
800074bc:	8d 08       	st.w	r6[0x0],r8
800074be:	30 17       	mov	r7,1
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
800074c0:	c0 f8       	rjmp	800074de <xTaskCheckForTimeOut+0x4e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
800074c2:	f4 09 01 09 	sub	r9,r10,r9
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
800074c6:	10 39       	cp.w	r9,r8
800074c8:	c0 82       	brcc	800074d8 <xTaskCheckForTimeOut+0x48>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
800074ca:	12 18       	sub	r8,r9
800074cc:	8d 08       	st.w	r6[0x0],r8
            vTaskInternalSetTimeOutState( pxTimeOut );
800074ce:	0e 9c       	mov	r12,r7
800074d0:	f0 1f 00 09 	mcall	800074f4 <xTaskCheckForTimeOut+0x64>
800074d4:	30 07       	mov	r7,0
800074d6:	c0 48       	rjmp	800074de <xTaskCheckForTimeOut+0x4e>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
800074d8:	30 08       	mov	r8,0
800074da:	8d 08       	st.w	r6[0x0],r8
800074dc:	30 17       	mov	r7,1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
800074de:	f0 1f 00 07 	mcall	800074f8 <xTaskCheckForTimeOut+0x68>

    return xReturn;
}
800074e2:	0e 9c       	mov	r12,r7
800074e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800074e8:	80 00       	ld.sh	r0,r0[0x0]
800074ea:	6b 68       	ld.w	r8,r5[0x58]
800074ec:	00 00       	add	r0,r0
800074ee:	06 98       	mov	r8,r3
800074f0:	00 00       	add	r0,r0
800074f2:	05 bc       	ld.ub	r12,r2[0x3]
800074f4:	80 00       	ld.sh	r0,r0[0x0]
800074f6:	74 24       	ld.w	r4,r10[0x8]
800074f8:	80 00       	ld.sh	r0,r0[0x0]
800074fa:	6c 74       	ld.w	r4,r6[0x1c]

800074fc <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
800074fc:	eb cd 40 f8 	pushm	r3-r7,lr
80007500:	18 97       	mov	r7,r12
80007502:	16 95       	mov	r5,r11
80007504:	14 93       	mov	r3,r10
80007506:	12 96       	mov	r6,r9
80007508:	10 94       	mov	r4,r8

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
8000750a:	f0 1f 00 31 	mcall	800075cc <xTaskGenericNotify+0xd0>
        {
            if( pulPreviousNotificationValue != NULL )
8000750e:	58 04       	cp.w	r4,0
80007510:	c0 60       	breq	8000751c <xTaskGenericNotify+0x20>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
80007512:	ea c8 ff ed 	sub	r8,r5,-19
80007516:	ee 08 03 28 	ld.w	r8,r7[r8<<0x2]
8000751a:	89 08       	st.w	r4[0x0],r8
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
8000751c:	ee 05 00 08 	add	r8,r7,r5
80007520:	f1 39 00 50 	ld.ub	r9,r8[80]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
80007524:	30 2a       	mov	r10,2
80007526:	f1 6a 00 50 	st.b	r8[80],r10

            switch( eAction )
8000752a:	58 26       	cp.w	r6,2
8000752c:	c1 20       	breq	80007550 <xTaskGenericNotify+0x54>
8000752e:	e0 8b 00 05 	brhi	80007538 <xTaskGenericNotify+0x3c>
80007532:	58 16       	cp.w	r6,1
80007534:	c2 21       	brne	80007578 <xTaskGenericNotify+0x7c>
80007536:	c0 68       	rjmp	80007542 <xTaskGenericNotify+0x46>
80007538:	58 36       	cp.w	r6,3
8000753a:	c1 20       	breq	8000755e <xTaskGenericNotify+0x62>
8000753c:	58 46       	cp.w	r6,4
8000753e:	c1 d1       	brne	80007578 <xTaskGenericNotify+0x7c>
80007540:	c1 38       	rjmp	80007566 <xTaskGenericNotify+0x6a>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
80007542:	2e d5       	sub	r5,-19
80007544:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
80007548:	10 43       	or	r3,r8
8000754a:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
8000754e:	c1 58       	rjmp	80007578 <xTaskGenericNotify+0x7c>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
80007550:	2e d5       	sub	r5,-19
80007552:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
80007556:	2f f8       	sub	r8,-1
80007558:	ee 05 09 28 	st.w	r7[r5<<0x2],r8
                    break;
8000755c:	c0 e8       	rjmp	80007578 <xTaskGenericNotify+0x7c>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
8000755e:	2e d5       	sub	r5,-19
80007560:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
80007564:	c0 a8       	rjmp	80007578 <xTaskGenericNotify+0x7c>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80007566:	30 28       	mov	r8,2
80007568:	f0 09 18 00 	cp.b	r9,r8
8000756c:	c0 31       	brne	80007572 <xTaskGenericNotify+0x76>
8000756e:	30 07       	mov	r7,0
80007570:	c2 88       	rjmp	800075c0 <xTaskGenericNotify+0xc4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
80007572:	2e d5       	sub	r5,-19
80007574:	ee 05 09 23 	st.w	r7[r5<<0x2],r3

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80007578:	30 18       	mov	r8,1
8000757a:	f0 09 18 00 	cp.b	r9,r8
8000757e:	c2 01       	brne	800075be <xTaskGenericNotify+0xc2>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007580:	ee c6 ff fc 	sub	r6,r7,-4
80007584:	0c 9c       	mov	r12,r6
80007586:	f0 1f 00 13 	mcall	800075d0 <xTaskGenericNotify+0xd4>
                prvAddTaskToReadyList( pxTCB );
8000758a:	6e bc       	ld.w	r12,r7[0x2c]
8000758c:	49 28       	lddpc	r8,800075d4 <xTaskGenericNotify+0xd8>
8000758e:	70 08       	ld.w	r8,r8[0x0]
80007590:	10 3c       	cp.w	r12,r8
80007592:	e0 88 00 04 	brls	8000759a <xTaskGenericNotify+0x9e>
80007596:	49 08       	lddpc	r8,800075d4 <xTaskGenericNotify+0xd8>
80007598:	91 0c       	st.w	r8[0x0],r12
8000759a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000759e:	0c 9b       	mov	r11,r6
800075a0:	48 e8       	lddpc	r8,800075d8 <xTaskGenericNotify+0xdc>
800075a2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075a6:	f0 1f 00 0e 	mcall	800075dc <xTaskGenericNotify+0xe0>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
800075aa:	48 e8       	lddpc	r8,800075e0 <xTaskGenericNotify+0xe4>
800075ac:	70 08       	ld.w	r8,r8[0x0]
800075ae:	6e b9       	ld.w	r9,r7[0x2c]
800075b0:	70 b8       	ld.w	r8,r8[0x2c]
800075b2:	10 39       	cp.w	r9,r8
800075b4:	e0 88 00 05 	brls	800075be <xTaskGenericNotify+0xc2>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
800075b8:	d7 33       	scall
800075ba:	30 17       	mov	r7,1
800075bc:	c0 28       	rjmp	800075c0 <xTaskGenericNotify+0xc4>
800075be:	30 17       	mov	r7,1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
800075c0:	f0 1f 00 09 	mcall	800075e4 <xTaskGenericNotify+0xe8>

        return xReturn;
    }
800075c4:	0e 9c       	mov	r12,r7
800075c6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800075ca:	00 00       	add	r0,r0
800075cc:	80 00       	ld.sh	r0,r0[0x0]
800075ce:	6b 68       	ld.w	r8,r5[0x58]
800075d0:	80 00       	ld.sh	r0,r0[0x0]
800075d2:	6a ae       	ld.w	lr,r5[0x28]
800075d4:	00 00       	add	r0,r0
800075d6:	06 e8       	st.h	--r3,r8
800075d8:	00 00       	add	r0,r0
800075da:	05 c8       	ld.ub	r8,r2[0x4]
800075dc:	80 00       	ld.sh	r0,r0[0x0]
800075de:	6a 66       	ld.w	r6,r5[0x18]
800075e0:	00 00       	add	r0,r0
800075e2:	06 6c       	and	r12,r3
800075e4:	80 00       	ld.sh	r0,r0[0x0]
800075e6:	6c 74       	ld.w	r4,r6[0x1c]

800075e8 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
800075e8:	eb cd 40 c0 	pushm	r6-r7,lr
800075ec:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
800075ee:	58 0c       	cp.w	r12,0
800075f0:	c2 f0       	breq	8000764e <vTaskPriorityDisinheritAfterTimeout+0x66>
800075f2:	79 18       	ld.w	r8,r12[0x44]
800075f4:	10 3b       	cp.w	r11,r8
800075f6:	f0 0b 17 30 	movlo	r11,r8
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
800075fa:	78 b9       	ld.w	r9,r12[0x2c]
800075fc:	16 39       	cp.w	r9,r11
800075fe:	c2 80       	breq	8000764e <vTaskPriorityDisinheritAfterTimeout+0x66>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
80007600:	79 28       	ld.w	r8,r12[0x48]
80007602:	58 18       	cp.w	r8,1
80007604:	c2 51       	brne	8000764e <vTaskPriorityDisinheritAfterTimeout+0x66>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
80007606:	99 bb       	st.w	r12[0x2c],r11

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007608:	78 68       	ld.w	r8,r12[0x18]
8000760a:	58 08       	cp.w	r8,0
8000760c:	c0 45       	brlt	80007614 <vTaskPriorityDisinheritAfterTimeout+0x2c>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000760e:	f6 0b 11 08 	rsub	r11,r11,8
80007612:	99 6b       	st.w	r12[0x18],r11
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80007614:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007618:	48 f8       	lddpc	r8,80007654 <vTaskPriorityDisinheritAfterTimeout+0x6c>
8000761a:	f0 09 00 29 	add	r9,r8,r9<<0x2
8000761e:	6e 58       	ld.w	r8,r7[0x14]
80007620:	12 38       	cp.w	r8,r9
80007622:	c1 61       	brne	8000764e <vTaskPriorityDisinheritAfterTimeout+0x66>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007624:	ee c6 ff fc 	sub	r6,r7,-4
80007628:	0c 9c       	mov	r12,r6
8000762a:	f0 1f 00 0c 	mcall	80007658 <vTaskPriorityDisinheritAfterTimeout+0x70>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
8000762e:	6e bc       	ld.w	r12,r7[0x2c]
80007630:	48 b8       	lddpc	r8,8000765c <vTaskPriorityDisinheritAfterTimeout+0x74>
80007632:	70 08       	ld.w	r8,r8[0x0]
80007634:	10 3c       	cp.w	r12,r8
80007636:	e0 88 00 04 	brls	8000763e <vTaskPriorityDisinheritAfterTimeout+0x56>
8000763a:	48 98       	lddpc	r8,8000765c <vTaskPriorityDisinheritAfterTimeout+0x74>
8000763c:	91 0c       	st.w	r8[0x0],r12
8000763e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007642:	0c 9b       	mov	r11,r6
80007644:	48 48       	lddpc	r8,80007654 <vTaskPriorityDisinheritAfterTimeout+0x6c>
80007646:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000764a:	f0 1f 00 06 	mcall	80007660 <vTaskPriorityDisinheritAfterTimeout+0x78>
8000764e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007652:	00 00       	add	r0,r0
80007654:	00 00       	add	r0,r0
80007656:	05 c8       	ld.ub	r8,r2[0x4]
80007658:	80 00       	ld.sh	r0,r0[0x0]
8000765a:	6a ae       	ld.w	lr,r5[0x28]
8000765c:	00 00       	add	r0,r0
8000765e:	06 e8       	st.h	--r3,r8
80007660:	80 00       	ld.sh	r0,r0[0x0]
80007662:	6a 66       	ld.w	r6,r5[0x18]

80007664 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
80007664:	eb cd 40 c0 	pushm	r6-r7,lr
80007668:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
8000766a:	58 0c       	cp.w	r12,0
8000766c:	c2 60       	breq	800076b8 <xTaskPriorityDisinherit+0x54>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
8000766e:	79 28       	ld.w	r8,r12[0x48]
80007670:	20 18       	sub	r8,1
80007672:	f9 48 00 48 	st.w	r12[72],r8

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80007676:	78 ba       	ld.w	r10,r12[0x2c]
80007678:	79 19       	ld.w	r9,r12[0x44]
8000767a:	12 3a       	cp.w	r10,r9
8000767c:	c1 e0       	breq	800076b8 <xTaskPriorityDisinherit+0x54>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
8000767e:	58 08       	cp.w	r8,0
80007680:	c1 c1       	brne	800076b8 <xTaskPriorityDisinherit+0x54>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007682:	f8 c6 ff fc 	sub	r6,r12,-4
80007686:	0c 9c       	mov	r12,r6
80007688:	f0 1f 00 0d 	mcall	800076bc <xTaskPriorityDisinherit+0x58>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
8000768c:	6f 1c       	ld.w	r12,r7[0x44]
8000768e:	8f bc       	st.w	r7[0x2c],r12

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007690:	f8 08 11 08 	rsub	r8,r12,8
80007694:	8f 68       	st.w	r7[0x18],r8
                    prvAddTaskToReadyList( pxTCB );
80007696:	48 b8       	lddpc	r8,800076c0 <xTaskPriorityDisinherit+0x5c>
80007698:	70 08       	ld.w	r8,r8[0x0]
8000769a:	10 3c       	cp.w	r12,r8
8000769c:	e0 88 00 04 	brls	800076a4 <xTaskPriorityDisinherit+0x40>
800076a0:	48 88       	lddpc	r8,800076c0 <xTaskPriorityDisinherit+0x5c>
800076a2:	91 0c       	st.w	r8[0x0],r12
800076a4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800076a8:	0c 9b       	mov	r11,r6
800076aa:	48 78       	lddpc	r8,800076c4 <xTaskPriorityDisinherit+0x60>
800076ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800076b0:	f0 1f 00 06 	mcall	800076c8 <xTaskPriorityDisinherit+0x64>
800076b4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800076b8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800076bc:	80 00       	ld.sh	r0,r0[0x0]
800076be:	6a ae       	ld.w	lr,r5[0x28]
800076c0:	00 00       	add	r0,r0
800076c2:	06 e8       	st.h	--r3,r8
800076c4:	00 00       	add	r0,r0
800076c6:	05 c8       	ld.ub	r8,r2[0x4]
800076c8:	80 00       	ld.sh	r0,r0[0x0]
800076ca:	6a 66       	ld.w	r6,r5[0x18]

800076cc <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
800076cc:	eb cd 40 c0 	pushm	r6-r7,lr
800076d0:	18 97       	mov	r7,r12
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
800076d2:	58 0c       	cp.w	r12,0
800076d4:	c0 31       	brne	800076da <xTaskPriorityInherit+0xe>
800076d6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
800076da:	4a 18       	lddpc	r8,8000775c <xTaskPriorityInherit+0x90>
800076dc:	70 08       	ld.w	r8,r8[0x0]
800076de:	78 b9       	ld.w	r9,r12[0x2c]
800076e0:	70 b8       	ld.w	r8,r8[0x2c]
800076e2:	10 39       	cp.w	r9,r8
800076e4:	c3 32       	brcc	8000774a <xTaskPriorityInherit+0x7e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
800076e6:	78 68       	ld.w	r8,r12[0x18]
800076e8:	58 08       	cp.w	r8,0
800076ea:	c0 75       	brlt	800076f8 <xTaskPriorityInherit+0x2c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800076ec:	49 c8       	lddpc	r8,8000775c <xTaskPriorityInherit+0x90>
800076ee:	70 08       	ld.w	r8,r8[0x0]
800076f0:	70 b8       	ld.w	r8,r8[0x2c]
800076f2:	f0 08 11 08 	rsub	r8,r8,8
800076f6:	99 68       	st.w	r12[0x18],r8
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
800076f8:	6e b8       	ld.w	r8,r7[0x2c]
800076fa:	f0 08 00 28 	add	r8,r8,r8<<0x2
800076fe:	49 99       	lddpc	r9,80007760 <xTaskPriorityInherit+0x94>
80007700:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007704:	6e 59       	ld.w	r9,r7[0x14]
80007706:	10 39       	cp.w	r9,r8
80007708:	c1 b1       	brne	8000773e <xTaskPriorityInherit+0x72>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8000770a:	ee c6 ff fc 	sub	r6,r7,-4
8000770e:	0c 9c       	mov	r12,r6
80007710:	f0 1f 00 15 	mcall	80007764 <xTaskPriorityInherit+0x98>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
80007714:	49 28       	lddpc	r8,8000775c <xTaskPriorityInherit+0x90>
80007716:	70 08       	ld.w	r8,r8[0x0]
80007718:	70 bc       	ld.w	r12,r8[0x2c]
8000771a:	8f bc       	st.w	r7[0x2c],r12
                    prvAddTaskToReadyList( pxMutexHolderTCB );
8000771c:	49 38       	lddpc	r8,80007768 <xTaskPriorityInherit+0x9c>
8000771e:	70 08       	ld.w	r8,r8[0x0]
80007720:	10 3c       	cp.w	r12,r8
80007722:	e0 88 00 04 	brls	8000772a <xTaskPriorityInherit+0x5e>
80007726:	49 18       	lddpc	r8,80007768 <xTaskPriorityInherit+0x9c>
80007728:	91 0c       	st.w	r8[0x0],r12
8000772a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000772e:	0c 9b       	mov	r11,r6
80007730:	48 c8       	lddpc	r8,80007760 <xTaskPriorityInherit+0x94>
80007732:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007736:	f0 1f 00 0e 	mcall	8000776c <xTaskPriorityInherit+0xa0>
8000773a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
8000773e:	48 88       	lddpc	r8,8000775c <xTaskPriorityInherit+0x90>
80007740:	70 08       	ld.w	r8,r8[0x0]
80007742:	70 b8       	ld.w	r8,r8[0x2c]
80007744:	8f b8       	st.w	r7[0x2c],r8
80007746:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
8000774a:	48 58       	lddpc	r8,8000775c <xTaskPriorityInherit+0x90>
8000774c:	70 08       	ld.w	r8,r8[0x0]
8000774e:	79 19       	ld.w	r9,r12[0x44]
80007750:	70 b8       	ld.w	r8,r8[0x2c]
80007752:	10 39       	cp.w	r9,r8
80007754:	5f 3c       	srlo	r12
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
80007756:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000775a:	00 00       	add	r0,r0
8000775c:	00 00       	add	r0,r0
8000775e:	06 6c       	and	r12,r3
80007760:	00 00       	add	r0,r0
80007762:	05 c8       	ld.ub	r8,r2[0x4]
80007764:	80 00       	ld.sh	r0,r0[0x0]
80007766:	6a ae       	ld.w	lr,r5[0x28]
80007768:	00 00       	add	r0,r0
8000776a:	06 e8       	st.h	--r3,r8
8000776c:	80 00       	ld.sh	r0,r0[0x0]
8000776e:	6a 66       	ld.w	r6,r5[0x18]

80007770 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
80007770:	eb cd 40 c0 	pushm	r6-r7,lr
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007774:	78 38       	ld.w	r8,r12[0xc]
80007776:	70 37       	ld.w	r7,r8[0xc]
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007778:	ee c6 ff e8 	sub	r6,r7,-24
8000777c:	0c 9c       	mov	r12,r6
8000777e:	f0 1f 00 18 	mcall	800077dc <xTaskRemoveFromEventList+0x6c>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007782:	49 88       	lddpc	r8,800077e0 <xTaskRemoveFromEventList+0x70>
80007784:	70 08       	ld.w	r8,r8[0x0]
80007786:	58 08       	cp.w	r8,0
80007788:	c1 71       	brne	800077b6 <xTaskRemoveFromEventList+0x46>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
8000778a:	ee c6 ff fc 	sub	r6,r7,-4
8000778e:	0c 9c       	mov	r12,r6
80007790:	f0 1f 00 13 	mcall	800077dc <xTaskRemoveFromEventList+0x6c>
        prvAddTaskToReadyList( pxUnblockedTCB );
80007794:	6e bc       	ld.w	r12,r7[0x2c]
80007796:	49 48       	lddpc	r8,800077e4 <xTaskRemoveFromEventList+0x74>
80007798:	70 08       	ld.w	r8,r8[0x0]
8000779a:	10 3c       	cp.w	r12,r8
8000779c:	e0 88 00 04 	brls	800077a4 <xTaskRemoveFromEventList+0x34>
800077a0:	49 18       	lddpc	r8,800077e4 <xTaskRemoveFromEventList+0x74>
800077a2:	91 0c       	st.w	r8[0x0],r12
800077a4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800077a8:	0c 9b       	mov	r11,r6
800077aa:	49 08       	lddpc	r8,800077e8 <xTaskRemoveFromEventList+0x78>
800077ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800077b0:	f0 1f 00 0f 	mcall	800077ec <xTaskRemoveFromEventList+0x7c>
800077b4:	c0 58       	rjmp	800077be <xTaskRemoveFromEventList+0x4e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800077b6:	0c 9b       	mov	r11,r6
800077b8:	48 ec       	lddpc	r12,800077f0 <xTaskRemoveFromEventList+0x80>
800077ba:	f0 1f 00 0d 	mcall	800077ec <xTaskRemoveFromEventList+0x7c>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
800077be:	48 e8       	lddpc	r8,800077f4 <xTaskRemoveFromEventList+0x84>
800077c0:	70 08       	ld.w	r8,r8[0x0]
800077c2:	6e b9       	ld.w	r9,r7[0x2c]
800077c4:	70 b8       	ld.w	r8,r8[0x2c]
800077c6:	10 39       	cp.w	r9,r8
800077c8:	e0 8b 00 04 	brhi	800077d0 <xTaskRemoveFromEventList+0x60>
800077cc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
800077d0:	30 1c       	mov	r12,1
800077d2:	48 a8       	lddpc	r8,800077f8 <xTaskRemoveFromEventList+0x88>
800077d4:	91 0c       	st.w	r8[0x0],r12
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
800077d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800077da:	00 00       	add	r0,r0
800077dc:	80 00       	ld.sh	r0,r0[0x0]
800077de:	6a ae       	ld.w	lr,r5[0x28]
800077e0:	00 00       	add	r0,r0
800077e2:	06 9c       	mov	r12,r3
800077e4:	00 00       	add	r0,r0
800077e6:	06 e8       	st.h	--r3,r8
800077e8:	00 00       	add	r0,r0
800077ea:	05 c8       	ld.ub	r8,r2[0x4]
800077ec:	80 00       	ld.sh	r0,r0[0x0]
800077ee:	6a 66       	ld.w	r6,r5[0x18]
800077f0:	00 00       	add	r0,r0
800077f2:	06 70       	tst	r0,r3
800077f4:	00 00       	add	r0,r0
800077f6:	06 6c       	and	r12,r3
800077f8:	00 00       	add	r0,r0
800077fa:	06 ec       	st.h	--r3,r12

800077fc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
800077fc:	d4 31       	pushm	r0-r7,lr
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
800077fe:	4b 48       	lddpc	r8,800078cc <xTaskIncrementTick+0xd0>
80007800:	70 08       	ld.w	r8,r8[0x0]
80007802:	58 08       	cp.w	r8,0
80007804:	c5 d1       	brne	800078be <xTaskIncrementTick+0xc2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
80007806:	4b 38       	lddpc	r8,800078d0 <xTaskIncrementTick+0xd4>
80007808:	70 02       	ld.w	r2,r8[0x0]
8000780a:	2f f2       	sub	r2,-1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
8000780c:	91 02       	st.w	r8[0x0],r2

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
8000780e:	c0 d1       	brne	80007828 <xTaskIncrementTick+0x2c>
        {
            taskSWITCH_DELAYED_LISTS();
80007810:	4b 19       	lddpc	r9,800078d4 <xTaskIncrementTick+0xd8>
80007812:	72 0a       	ld.w	r10,r9[0x0]
80007814:	4b 18       	lddpc	r8,800078d8 <xTaskIncrementTick+0xdc>
80007816:	70 0b       	ld.w	r11,r8[0x0]
80007818:	93 0b       	st.w	r9[0x0],r11
8000781a:	91 0a       	st.w	r8[0x0],r10
8000781c:	4b 08       	lddpc	r8,800078dc <xTaskIncrementTick+0xe0>
8000781e:	70 09       	ld.w	r9,r8[0x0]
80007820:	2f f9       	sub	r9,-1
80007822:	91 09       	st.w	r8[0x0],r9
80007824:	f0 1f 00 2f 	mcall	800078e0 <xTaskIncrementTick+0xe4>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
80007828:	4a f8       	lddpc	r8,800078e4 <xTaskIncrementTick+0xe8>
8000782a:	70 08       	ld.w	r8,r8[0x0]
8000782c:	10 32       	cp.w	r2,r8
8000782e:	c3 63       	brcs	8000789a <xTaskIncrementTick+0x9e>
80007830:	30 06       	mov	r6,0
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007832:	4a 94       	lddpc	r4,800078d4 <xTaskIncrementTick+0xd8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007834:	4a d3       	lddpc	r3,800078e8 <xTaskIncrementTick+0xec>
80007836:	4a e1       	lddpc	r1,800078ec <xTaskIncrementTick+0xf0>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007838:	4a e0       	lddpc	r0,800078f0 <xTaskIncrementTick+0xf4>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000783a:	68 08       	ld.w	r8,r4[0x0]
8000783c:	70 08       	ld.w	r8,r8[0x0]
8000783e:	58 08       	cp.w	r8,0
80007840:	c0 51       	brne	8000784a <xTaskIncrementTick+0x4e>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007842:	3f f9       	mov	r9,-1
80007844:	4a 88       	lddpc	r8,800078e4 <xTaskIncrementTick+0xe8>
80007846:	91 09       	st.w	r8[0x0],r9
                    break;
80007848:	c2 a8       	rjmp	8000789c <xTaskIncrementTick+0xa0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
8000784a:	68 08       	ld.w	r8,r4[0x0]
8000784c:	70 38       	ld.w	r8,r8[0xc]
8000784e:	70 37       	ld.w	r7,r8[0xc]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80007850:	6e 18       	ld.w	r8,r7[0x4]

                    if( xConstTickCount < xItemValue )
80007852:	10 32       	cp.w	r2,r8
80007854:	c0 42       	brcc	8000785c <xTaskIncrementTick+0x60>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
80007856:	4a 49       	lddpc	r9,800078e4 <xTaskIncrementTick+0xe8>
80007858:	93 08       	st.w	r9[0x0],r8
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
8000785a:	c2 18       	rjmp	8000789c <xTaskIncrementTick+0xa0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8000785c:	ee c5 ff fc 	sub	r5,r7,-4
80007860:	0a 9c       	mov	r12,r5
80007862:	f0 1f 00 25 	mcall	800078f4 <xTaskIncrementTick+0xf8>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80007866:	6e a8       	ld.w	r8,r7[0x28]
80007868:	58 08       	cp.w	r8,0
8000786a:	c0 50       	breq	80007874 <xTaskIncrementTick+0x78>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
8000786c:	ee cc ff e8 	sub	r12,r7,-24
80007870:	f0 1f 00 21 	mcall	800078f4 <xTaskIncrementTick+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007874:	6e bc       	ld.w	r12,r7[0x2c]
80007876:	66 08       	ld.w	r8,r3[0x0]
80007878:	10 3c       	cp.w	r12,r8
8000787a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000787e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007882:	0a 9b       	mov	r11,r5
80007884:	e2 0c 00 2c 	add	r12,r1,r12<<0x2
80007888:	f0 1f 00 1c 	mcall	800078f8 <xTaskIncrementTick+0xfc>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000788c:	60 08       	ld.w	r8,r0[0x0]
8000788e:	6e b9       	ld.w	r9,r7[0x2c]
80007890:	70 b8       	ld.w	r8,r8[0x2c]
80007892:	10 39       	cp.w	r9,r8
80007894:	f9 b6 02 01 	movhs	r6,1
80007898:	cd 1b       	rjmp	8000783a <xTaskIncrementTick+0x3e>
8000789a:	30 06       	mov	r6,0
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
8000789c:	49 58       	lddpc	r8,800078f0 <xTaskIncrementTick+0xf4>
8000789e:	70 08       	ld.w	r8,r8[0x0]
800078a0:	70 b8       	ld.w	r8,r8[0x2c]
800078a2:	f0 08 00 28 	add	r8,r8,r8<<0x2
800078a6:	49 29       	lddpc	r9,800078ec <xTaskIncrementTick+0xf0>
800078a8:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800078ac:	58 28       	cp.w	r8,2
800078ae:	f9 b6 02 01 	movhs	r6,1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
800078b2:	49 38       	lddpc	r8,800078fc <xTaskIncrementTick+0x100>
800078b4:	70 08       	ld.w	r8,r8[0x0]
800078b6:	58 08       	cp.w	r8,0
800078b8:	f9 b6 01 01 	movne	r6,1
800078bc:	c0 68       	rjmp	800078c8 <xTaskIncrementTick+0xcc>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
800078be:	49 18       	lddpc	r8,80007900 <xTaskIncrementTick+0x104>
800078c0:	70 09       	ld.w	r9,r8[0x0]
800078c2:	2f f9       	sub	r9,-1
800078c4:	91 09       	st.w	r8[0x0],r9
800078c6:	30 06       	mov	r6,0
            }
        #endif
    }

    return xSwitchRequired;
}
800078c8:	0c 9c       	mov	r12,r6
800078ca:	d8 32       	popm	r0-r7,pc
800078cc:	00 00       	add	r0,r0
800078ce:	06 9c       	mov	r12,r3
800078d0:	00 00       	add	r0,r0
800078d2:	06 98       	mov	r8,r3
800078d4:	00 00       	add	r0,r0
800078d6:	05 b4       	ld.ub	r4,r2[0x3]
800078d8:	00 00       	add	r0,r0
800078da:	05 c0       	ld.ub	r0,r2[0x4]
800078dc:	00 00       	add	r0,r0
800078de:	05 bc       	ld.ub	r12,r2[0x3]
800078e0:	80 00       	ld.sh	r0,r0[0x0]
800078e2:	74 48       	ld.w	r8,r10[0x10]
800078e4:	00 00       	add	r0,r0
800078e6:	05 b0       	ld.ub	r0,r2[0x3]
800078e8:	00 00       	add	r0,r0
800078ea:	06 e8       	st.h	--r3,r8
800078ec:	00 00       	add	r0,r0
800078ee:	05 c8       	ld.ub	r8,r2[0x4]
800078f0:	00 00       	add	r0,r0
800078f2:	06 6c       	and	r12,r3
800078f4:	80 00       	ld.sh	r0,r0[0x0]
800078f6:	6a ae       	ld.w	lr,r5[0x28]
800078f8:	80 00       	ld.sh	r0,r0[0x0]
800078fa:	6a 66       	ld.w	r6,r5[0x18]
800078fc:	00 00       	add	r0,r0
800078fe:	06 ec       	st.h	--r3,r12
80007900:	00 00       	add	r0,r0
80007902:	05 c4       	ld.ub	r4,r2[0x4]

80007904 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
80007904:	d4 31       	pushm	r0-r7,lr
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
80007906:	f0 1f 00 2b 	mcall	800079b0 <xTaskResumeAll+0xac>
    {
        --uxSchedulerSuspended;
8000790a:	4a b8       	lddpc	r8,800079b4 <xTaskResumeAll+0xb0>
8000790c:	70 09       	ld.w	r9,r8[0x0]
8000790e:	20 19       	sub	r9,1
80007910:	91 09       	st.w	r8[0x0],r9

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007912:	70 08       	ld.w	r8,r8[0x0]
80007914:	58 08       	cp.w	r8,0
80007916:	c4 71       	brne	800079a4 <xTaskResumeAll+0xa0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80007918:	4a 88       	lddpc	r8,800079b8 <xTaskResumeAll+0xb4>
8000791a:	70 08       	ld.w	r8,r8[0x0]
8000791c:	58 08       	cp.w	r8,0
8000791e:	c4 30       	breq	800079a4 <xTaskResumeAll+0xa0>
80007920:	30 07       	mov	r7,0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80007922:	4a 76       	lddpc	r6,800079bc <xTaskResumeAll+0xb8>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
80007924:	4a 74       	lddpc	r4,800079c0 <xTaskResumeAll+0xbc>
80007926:	4a 83       	lddpc	r3,800079c4 <xTaskResumeAll+0xc0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007928:	4a 82       	lddpc	r2,800079c8 <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
8000792a:	4a 91       	lddpc	r1,800079cc <xTaskResumeAll+0xc8>
8000792c:	30 10       	mov	r0,1
8000792e:	c1 e8       	rjmp	8000796a <xTaskResumeAll+0x66>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007930:	6c 38       	ld.w	r8,r6[0xc]
80007932:	70 37       	ld.w	r7,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007934:	ee cc ff e8 	sub	r12,r7,-24
80007938:	f0 1f 00 26 	mcall	800079d0 <xTaskResumeAll+0xcc>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8000793c:	ee c5 ff fc 	sub	r5,r7,-4
80007940:	0a 9c       	mov	r12,r5
80007942:	f0 1f 00 24 	mcall	800079d0 <xTaskResumeAll+0xcc>
                    prvAddTaskToReadyList( pxTCB );
80007946:	6e bc       	ld.w	r12,r7[0x2c]
80007948:	68 08       	ld.w	r8,r4[0x0]
8000794a:	10 3c       	cp.w	r12,r8
8000794c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80007950:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007954:	0a 9b       	mov	r11,r5
80007956:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000795a:	f0 1f 00 1f 	mcall	800079d4 <xTaskResumeAll+0xd0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000795e:	64 08       	ld.w	r8,r2[0x0]
80007960:	6e b9       	ld.w	r9,r7[0x2c]
80007962:	70 b8       	ld.w	r8,r8[0x2c]
                    {
                        xYieldPending = pdTRUE;
80007964:	10 39       	cp.w	r9,r8
80007966:	e3 f0 2a 00 	st.wcc	r1[0x0],r0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
8000796a:	6c 08       	ld.w	r8,r6[0x0]
8000796c:	58 08       	cp.w	r8,0
8000796e:	ce 11       	brne	80007930 <xTaskResumeAll+0x2c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
80007970:	58 07       	cp.w	r7,0
80007972:	c0 30       	breq	80007978 <xTaskResumeAll+0x74>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
80007974:	f0 1f 00 19 	mcall	800079d8 <xTaskResumeAll+0xd4>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
80007978:	49 98       	lddpc	r8,800079dc <xTaskResumeAll+0xd8>
8000797a:	70 07       	ld.w	r7,r8[0x0]

                    if( xPendedCounts > ( TickType_t ) 0U )
8000797c:	58 07       	cp.w	r7,0
8000797e:	c0 c0       	breq	80007996 <xTaskResumeAll+0x92>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
80007980:	49 36       	lddpc	r6,800079cc <xTaskResumeAll+0xc8>
80007982:	30 15       	mov	r5,1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
80007984:	f0 1f 00 17 	mcall	800079e0 <xTaskResumeAll+0xdc>
                            {
                                xYieldPending = pdTRUE;
80007988:	ed f5 1a 00 	st.wne	r6[0x0],r5
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
8000798c:	20 17       	sub	r7,1
                        } while( xPendedCounts > ( TickType_t ) 0U );
8000798e:	cf b1       	brne	80007984 <xTaskResumeAll+0x80>

                        xPendedTicks = 0;
80007990:	30 09       	mov	r9,0
80007992:	49 38       	lddpc	r8,800079dc <xTaskResumeAll+0xd8>
80007994:	91 09       	st.w	r8[0x0],r9
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
80007996:	48 e8       	lddpc	r8,800079cc <xTaskResumeAll+0xc8>
80007998:	70 08       	ld.w	r8,r8[0x0]
8000799a:	58 08       	cp.w	r8,0
8000799c:	c0 40       	breq	800079a4 <xTaskResumeAll+0xa0>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
8000799e:	d7 33       	scall
800079a0:	30 17       	mov	r7,1
800079a2:	c0 28       	rjmp	800079a6 <xTaskResumeAll+0xa2>
800079a4:	30 07       	mov	r7,0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
800079a6:	f0 1f 00 10 	mcall	800079e4 <xTaskResumeAll+0xe0>

    return xAlreadyYielded;
}
800079aa:	0e 9c       	mov	r12,r7
800079ac:	d8 32       	popm	r0-r7,pc
800079ae:	00 00       	add	r0,r0
800079b0:	80 00       	ld.sh	r0,r0[0x0]
800079b2:	6b 68       	ld.w	r8,r5[0x58]
800079b4:	00 00       	add	r0,r0
800079b6:	06 9c       	mov	r12,r3
800079b8:	00 00       	add	r0,r0
800079ba:	06 b8       	st.h	r3++,r8
800079bc:	00 00       	add	r0,r0
800079be:	06 70       	tst	r0,r3
800079c0:	00 00       	add	r0,r0
800079c2:	06 e8       	st.h	--r3,r8
800079c4:	00 00       	add	r0,r0
800079c6:	05 c8       	ld.ub	r8,r2[0x4]
800079c8:	00 00       	add	r0,r0
800079ca:	06 6c       	and	r12,r3
800079cc:	00 00       	add	r0,r0
800079ce:	06 ec       	st.h	--r3,r12
800079d0:	80 00       	ld.sh	r0,r0[0x0]
800079d2:	6a ae       	ld.w	lr,r5[0x28]
800079d4:	80 00       	ld.sh	r0,r0[0x0]
800079d6:	6a 66       	ld.w	r6,r5[0x18]
800079d8:	80 00       	ld.sh	r0,r0[0x0]
800079da:	74 48       	ld.w	r8,r10[0x10]
800079dc:	00 00       	add	r0,r0
800079de:	05 c4       	ld.ub	r4,r2[0x4]
800079e0:	80 00       	ld.sh	r0,r0[0x0]
800079e2:	77 fc       	ld.w	r12,r11[0x7c]
800079e4:	80 00       	ld.sh	r0,r0[0x0]
800079e6:	6c 74       	ld.w	r4,r6[0x1c]

800079e8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
800079e8:	eb cd 40 e0 	pushm	r5-r7,lr
800079ec:	18 97       	mov	r7,r12
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
800079ee:	f0 1f 00 1a 	mcall	80007a54 <xTaskResumeFromISR+0x6c>
800079f2:	c0 31       	brne	800079f8 <xTaskResumeFromISR+0x10>
800079f4:	30 06       	mov	r6,0
800079f6:	c2 c8       	rjmp	80007a4e <xTaskResumeFromISR+0x66>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
800079f8:	49 88       	lddpc	r8,80007a58 <xTaskResumeFromISR+0x70>
800079fa:	70 08       	ld.w	r8,r8[0x0]
800079fc:	58 08       	cp.w	r8,0
800079fe:	c2 21       	brne	80007a42 <xTaskResumeFromISR+0x5a>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007a00:	49 78       	lddpc	r8,80007a5c <xTaskResumeFromISR+0x74>
80007a02:	70 08       	ld.w	r8,r8[0x0]
80007a04:	6e b9       	ld.w	r9,r7[0x2c]
80007a06:	70 b8       	ld.w	r8,r8[0x2c]
80007a08:	10 39       	cp.w	r9,r8
80007a0a:	c0 32       	brcc	80007a10 <xTaskResumeFromISR+0x28>
80007a0c:	30 06       	mov	r6,0
80007a0e:	c0 48       	rjmp	80007a16 <xTaskResumeFromISR+0x2e>
                        xYieldRequired = pdTRUE;

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
80007a10:	30 16       	mov	r6,1
80007a12:	49 48       	lddpc	r8,80007a60 <xTaskResumeFromISR+0x78>
80007a14:	91 06       	st.w	r8[0x0],r6
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007a16:	ee c5 ff fc 	sub	r5,r7,-4
80007a1a:	0a 9c       	mov	r12,r5
80007a1c:	f0 1f 00 12 	mcall	80007a64 <xTaskResumeFromISR+0x7c>
                    prvAddTaskToReadyList( pxTCB );
80007a20:	6e bc       	ld.w	r12,r7[0x2c]
80007a22:	49 28       	lddpc	r8,80007a68 <xTaskResumeFromISR+0x80>
80007a24:	70 08       	ld.w	r8,r8[0x0]
80007a26:	10 3c       	cp.w	r12,r8
80007a28:	e0 88 00 04 	brls	80007a30 <xTaskResumeFromISR+0x48>
80007a2c:	48 f8       	lddpc	r8,80007a68 <xTaskResumeFromISR+0x80>
80007a2e:	91 0c       	st.w	r8[0x0],r12
80007a30:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007a34:	0a 9b       	mov	r11,r5
80007a36:	48 e8       	lddpc	r8,80007a6c <xTaskResumeFromISR+0x84>
80007a38:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007a3c:	f0 1f 00 0d 	mcall	80007a70 <xTaskResumeFromISR+0x88>
80007a40:	c0 78       	rjmp	80007a4e <xTaskResumeFromISR+0x66>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80007a42:	ee cb ff e8 	sub	r11,r7,-24
80007a46:	48 cc       	lddpc	r12,80007a74 <xTaskResumeFromISR+0x8c>
80007a48:	f0 1f 00 0a 	mcall	80007a70 <xTaskResumeFromISR+0x88>
80007a4c:	30 06       	mov	r6,0
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
80007a4e:	0c 9c       	mov	r12,r6
80007a50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007a54:	80 00       	ld.sh	r0,r0[0x0]
80007a56:	73 80       	ld.w	r0,r9[0x60]
80007a58:	00 00       	add	r0,r0
80007a5a:	06 9c       	mov	r12,r3
80007a5c:	00 00       	add	r0,r0
80007a5e:	06 6c       	and	r12,r3
80007a60:	00 00       	add	r0,r0
80007a62:	06 ec       	st.h	--r3,r12
80007a64:	80 00       	ld.sh	r0,r0[0x0]
80007a66:	6a ae       	ld.w	lr,r5[0x28]
80007a68:	00 00       	add	r0,r0
80007a6a:	06 e8       	st.h	--r3,r8
80007a6c:	00 00       	add	r0,r0
80007a6e:	05 c8       	ld.ub	r8,r2[0x4]
80007a70:	80 00       	ld.sh	r0,r0[0x0]
80007a72:	6a 66       	ld.w	r6,r5[0x18]
80007a74:	00 00       	add	r0,r0
80007a76:	06 70       	tst	r0,r3

80007a78 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
80007a78:	eb cd 40 c0 	pushm	r6-r7,lr
80007a7c:	18 97       	mov	r7,r12
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
80007a7e:	49 78       	lddpc	r8,80007ad8 <vTaskResume+0x60>
80007a80:	70 08       	ld.w	r8,r8[0x0]
80007a82:	10 3c       	cp.w	r12,r8
80007a84:	c2 70       	breq	80007ad2 <vTaskResume+0x5a>
80007a86:	58 0c       	cp.w	r12,0
80007a88:	c2 50       	breq	80007ad2 <vTaskResume+0x5a>
        {
            taskENTER_CRITICAL();
80007a8a:	f0 1f 00 15 	mcall	80007adc <vTaskResume+0x64>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80007a8e:	0e 9c       	mov	r12,r7
80007a90:	f0 1f 00 14 	mcall	80007ae0 <vTaskResume+0x68>
80007a94:	c1 d0       	breq	80007ace <vTaskResume+0x56>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007a96:	ee c6 ff fc 	sub	r6,r7,-4
80007a9a:	0c 9c       	mov	r12,r6
80007a9c:	f0 1f 00 12 	mcall	80007ae4 <vTaskResume+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80007aa0:	6e bc       	ld.w	r12,r7[0x2c]
80007aa2:	49 28       	lddpc	r8,80007ae8 <vTaskResume+0x70>
80007aa4:	70 08       	ld.w	r8,r8[0x0]
80007aa6:	10 3c       	cp.w	r12,r8
80007aa8:	e0 88 00 04 	brls	80007ab0 <vTaskResume+0x38>
80007aac:	48 f8       	lddpc	r8,80007ae8 <vTaskResume+0x70>
80007aae:	91 0c       	st.w	r8[0x0],r12
80007ab0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007ab4:	0c 9b       	mov	r11,r6
80007ab6:	48 e8       	lddpc	r8,80007aec <vTaskResume+0x74>
80007ab8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007abc:	f0 1f 00 0d 	mcall	80007af0 <vTaskResume+0x78>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007ac0:	48 68       	lddpc	r8,80007ad8 <vTaskResume+0x60>
80007ac2:	70 08       	ld.w	r8,r8[0x0]
80007ac4:	6e b9       	ld.w	r9,r7[0x2c]
80007ac6:	70 b8       	ld.w	r8,r8[0x2c]
80007ac8:	10 39       	cp.w	r9,r8
80007aca:	c0 23       	brcs	80007ace <vTaskResume+0x56>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
80007acc:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
80007ace:	f0 1f 00 0a 	mcall	80007af4 <vTaskResume+0x7c>
80007ad2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007ad6:	00 00       	add	r0,r0
80007ad8:	00 00       	add	r0,r0
80007ada:	06 6c       	and	r12,r3
80007adc:	80 00       	ld.sh	r0,r0[0x0]
80007ade:	6b 68       	ld.w	r8,r5[0x58]
80007ae0:	80 00       	ld.sh	r0,r0[0x0]
80007ae2:	73 80       	ld.w	r0,r9[0x60]
80007ae4:	80 00       	ld.sh	r0,r0[0x0]
80007ae6:	6a ae       	ld.w	lr,r5[0x28]
80007ae8:	00 00       	add	r0,r0
80007aea:	06 e8       	st.h	--r3,r8
80007aec:	00 00       	add	r0,r0
80007aee:	05 c8       	ld.ub	r8,r2[0x4]
80007af0:	80 00       	ld.sh	r0,r0[0x0]
80007af2:	6a 66       	ld.w	r6,r5[0x18]
80007af4:	80 00       	ld.sh	r0,r0[0x0]
80007af6:	6c 74       	ld.w	r4,r6[0x1c]

80007af8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
80007af8:	eb cd 40 c0 	pushm	r6-r7,lr
80007afc:	18 97       	mov	r7,r12
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
80007afe:	f0 1f 00 23 	mcall	80007b88 <vTaskSuspend+0x90>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
80007b02:	58 07       	cp.w	r7,0
80007b04:	c0 31       	brne	80007b0a <vTaskSuspend+0x12>
80007b06:	4a 28       	lddpc	r8,80007b8c <vTaskSuspend+0x94>
80007b08:	70 07       	ld.w	r7,r8[0x0]

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007b0a:	ee c6 ff fc 	sub	r6,r7,-4
80007b0e:	0c 9c       	mov	r12,r6
80007b10:	f0 1f 00 20 	mcall	80007b90 <vTaskSuspend+0x98>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80007b14:	6e a8       	ld.w	r8,r7[0x28]
80007b16:	58 08       	cp.w	r8,0
80007b18:	c0 50       	breq	80007b22 <vTaskSuspend+0x2a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007b1a:	ee cc ff e8 	sub	r12,r7,-24
80007b1e:	f0 1f 00 1d 	mcall	80007b90 <vTaskSuspend+0x98>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
80007b22:	0c 9b       	mov	r11,r6
80007b24:	49 cc       	lddpc	r12,80007b94 <vTaskSuspend+0x9c>
80007b26:	f0 1f 00 1d 	mcall	80007b98 <vTaskSuspend+0xa0>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
80007b2a:	ef 39 00 50 	ld.ub	r9,r7[80]
80007b2e:	30 18       	mov	r8,1
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
80007b30:	f0 09 18 00 	cp.b	r9,r8
80007b34:	f9 b8 00 00 	moveq	r8,0
80007b38:	ef f8 0e 50 	st.beq	r7[0x50],r8
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
80007b3c:	f0 1f 00 18 	mcall	80007b9c <vTaskSuspend+0xa4>

        if( xSchedulerRunning != pdFALSE )
80007b40:	49 88       	lddpc	r8,80007ba0 <vTaskSuspend+0xa8>
80007b42:	70 08       	ld.w	r8,r8[0x0]
80007b44:	58 08       	cp.w	r8,0
80007b46:	c0 70       	breq	80007b54 <vTaskSuspend+0x5c>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
80007b48:	f0 1f 00 10 	mcall	80007b88 <vTaskSuspend+0x90>
            {
                prvResetNextTaskUnblockTime();
80007b4c:	f0 1f 00 16 	mcall	80007ba4 <vTaskSuspend+0xac>
            }
            taskEXIT_CRITICAL();
80007b50:	f0 1f 00 13 	mcall	80007b9c <vTaskSuspend+0xa4>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
80007b54:	48 e8       	lddpc	r8,80007b8c <vTaskSuspend+0x94>
80007b56:	70 08       	ld.w	r8,r8[0x0]
80007b58:	10 37       	cp.w	r7,r8
80007b5a:	c1 51       	brne	80007b84 <vTaskSuspend+0x8c>
        {
            if( xSchedulerRunning != pdFALSE )
80007b5c:	49 18       	lddpc	r8,80007ba0 <vTaskSuspend+0xa8>
80007b5e:	70 08       	ld.w	r8,r8[0x0]
80007b60:	58 08       	cp.w	r8,0
80007b62:	c0 40       	breq	80007b6a <vTaskSuspend+0x72>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
80007b64:	d7 33       	scall
80007b66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
80007b6a:	48 b8       	lddpc	r8,80007b94 <vTaskSuspend+0x9c>
80007b6c:	70 09       	ld.w	r9,r8[0x0]
80007b6e:	48 f8       	lddpc	r8,80007ba8 <vTaskSuspend+0xb0>
80007b70:	70 08       	ld.w	r8,r8[0x0]
80007b72:	10 39       	cp.w	r9,r8
80007b74:	c0 61       	brne	80007b80 <vTaskSuspend+0x88>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
80007b76:	30 09       	mov	r9,0
80007b78:	48 58       	lddpc	r8,80007b8c <vTaskSuspend+0x94>
80007b7a:	91 09       	st.w	r8[0x0],r9
80007b7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                }
                else
                {
                    vTaskSwitchContext();
80007b80:	f0 1f 00 0b 	mcall	80007bac <vTaskSuspend+0xb4>
80007b84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	6b 68       	ld.w	r8,r5[0x58]
80007b8c:	00 00       	add	r0,r0
80007b8e:	06 6c       	and	r12,r3
80007b90:	80 00       	ld.sh	r0,r0[0x0]
80007b92:	6a ae       	ld.w	lr,r5[0x28]
80007b94:	00 00       	add	r0,r0
80007b96:	06 d4       	st.w	--r3,r4
80007b98:	80 00       	ld.sh	r0,r0[0x0]
80007b9a:	6a 66       	ld.w	r6,r5[0x18]
80007b9c:	80 00       	ld.sh	r0,r0[0x0]
80007b9e:	6c 74       	ld.w	r4,r6[0x1c]
80007ba0:	00 00       	add	r0,r0
80007ba2:	05 b8       	ld.ub	r8,r2[0x3]
80007ba4:	80 00       	ld.sh	r0,r0[0x0]
80007ba6:	74 48       	ld.w	r8,r10[0x10]
80007ba8:	00 00       	add	r0,r0
80007baa:	06 b8       	st.h	r3++,r8
80007bac:	80 00       	ld.sh	r0,r0[0x0]
80007bae:	73 b0       	ld.w	r0,r9[0x6c]

80007bb0 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
80007bb0:	eb cd 40 e0 	pushm	r5-r7,lr
80007bb4:	18 97       	mov	r7,r12
80007bb6:	16 95       	mov	r5,r11
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
80007bb8:	49 b8       	lddpc	r8,80007c24 <prvAddCurrentTaskToDelayedList+0x74>
80007bba:	70 06       	ld.w	r6,r8[0x0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007bbc:	49 b8       	lddpc	r8,80007c28 <prvAddCurrentTaskToDelayedList+0x78>
80007bbe:	70 0c       	ld.w	r12,r8[0x0]
80007bc0:	2f cc       	sub	r12,-4
80007bc2:	f0 1f 00 1b 	mcall	80007c2c <prvAddCurrentTaskToDelayedList+0x7c>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80007bc6:	5b f7       	cp.w	r7,-1
80007bc8:	5f 09       	sreq	r9
80007bca:	58 05       	cp.w	r5,0
80007bcc:	5f 18       	srne	r8
80007bce:	f3 e8 00 08 	and	r8,r9,r8
80007bd2:	c0 90       	breq	80007be4 <prvAddCurrentTaskToDelayedList+0x34>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007bd4:	49 58       	lddpc	r8,80007c28 <prvAddCurrentTaskToDelayedList+0x78>
80007bd6:	70 0b       	ld.w	r11,r8[0x0]
80007bd8:	2f cb       	sub	r11,-4
80007bda:	49 6c       	lddpc	r12,80007c30 <prvAddCurrentTaskToDelayedList+0x80>
80007bdc:	f0 1f 00 16 	mcall	80007c34 <prvAddCurrentTaskToDelayedList+0x84>
80007be0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
80007be4:	0c 07       	add	r7,r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80007be6:	49 18       	lddpc	r8,80007c28 <prvAddCurrentTaskToDelayedList+0x78>
80007be8:	70 08       	ld.w	r8,r8[0x0]
80007bea:	91 17       	st.w	r8[0x4],r7

                if( xTimeToWake < xConstTickCount )
80007bec:	0e 36       	cp.w	r6,r7
80007bee:	e0 88 00 0b 	brls	80007c04 <prvAddCurrentTaskToDelayedList+0x54>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007bf2:	48 e8       	lddpc	r8,80007c28 <prvAddCurrentTaskToDelayedList+0x78>
80007bf4:	70 0b       	ld.w	r11,r8[0x0]
80007bf6:	49 18       	lddpc	r8,80007c38 <prvAddCurrentTaskToDelayedList+0x88>
80007bf8:	70 0c       	ld.w	r12,r8[0x0]
80007bfa:	2f cb       	sub	r11,-4
80007bfc:	f0 1f 00 10 	mcall	80007c3c <prvAddCurrentTaskToDelayedList+0x8c>
80007c00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007c04:	48 98       	lddpc	r8,80007c28 <prvAddCurrentTaskToDelayedList+0x78>
80007c06:	70 0b       	ld.w	r11,r8[0x0]
80007c08:	48 e8       	lddpc	r8,80007c40 <prvAddCurrentTaskToDelayedList+0x90>
80007c0a:	70 0c       	ld.w	r12,r8[0x0]
80007c0c:	2f cb       	sub	r11,-4
80007c0e:	f0 1f 00 0c 	mcall	80007c3c <prvAddCurrentTaskToDelayedList+0x8c>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
80007c12:	48 d8       	lddpc	r8,80007c44 <prvAddCurrentTaskToDelayedList+0x94>
80007c14:	70 08       	ld.w	r8,r8[0x0]
80007c16:	10 37       	cp.w	r7,r8
80007c18:	c0 32       	brcc	80007c1e <prvAddCurrentTaskToDelayedList+0x6e>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
80007c1a:	48 b8       	lddpc	r8,80007c44 <prvAddCurrentTaskToDelayedList+0x94>
80007c1c:	91 07       	st.w	r8[0x0],r7
80007c1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007c22:	00 00       	add	r0,r0
80007c24:	00 00       	add	r0,r0
80007c26:	06 98       	mov	r8,r3
80007c28:	00 00       	add	r0,r0
80007c2a:	06 6c       	and	r12,r3
80007c2c:	80 00       	ld.sh	r0,r0[0x0]
80007c2e:	6a ae       	ld.w	lr,r5[0x28]
80007c30:	00 00       	add	r0,r0
80007c32:	06 d4       	st.w	--r3,r4
80007c34:	80 00       	ld.sh	r0,r0[0x0]
80007c36:	6a 66       	ld.w	r6,r5[0x18]
80007c38:	00 00       	add	r0,r0
80007c3a:	05 c0       	ld.ub	r0,r2[0x4]
80007c3c:	80 00       	ld.sh	r0,r0[0x0]
80007c3e:	6a 7e       	ld.w	lr,r5[0x1c]
80007c40:	00 00       	add	r0,r0
80007c42:	05 b4       	ld.ub	r4,r2[0x3]
80007c44:	00 00       	add	r0,r0
80007c46:	05 b0       	ld.ub	r0,r2[0x3]

80007c48 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
80007c48:	eb cd 40 e0 	pushm	r5-r7,lr
80007c4c:	18 97       	mov	r7,r12
80007c4e:	16 95       	mov	r5,r11
80007c50:	14 96       	mov	r6,r10
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
80007c52:	f0 1f 00 20 	mcall	80007cd0 <ulTaskGenericNotifyTake+0x88>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
80007c56:	4a 08       	lddpc	r8,80007cd4 <ulTaskGenericNotifyTake+0x8c>
80007c58:	70 08       	ld.w	r8,r8[0x0]
80007c5a:	ee c9 ff ed 	sub	r9,r7,-19
80007c5e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007c62:	58 08       	cp.w	r8,0
80007c64:	c0 e1       	brne	80007c80 <ulTaskGenericNotifyTake+0x38>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
80007c66:	49 c8       	lddpc	r8,80007cd4 <ulTaskGenericNotifyTake+0x8c>
80007c68:	70 08       	ld.w	r8,r8[0x0]
80007c6a:	0e 08       	add	r8,r7
80007c6c:	30 19       	mov	r9,1
80007c6e:	f1 69 00 50 	st.b	r8[80],r9

                if( xTicksToWait > ( TickType_t ) 0 )
80007c72:	58 06       	cp.w	r6,0
80007c74:	c0 60       	breq	80007c80 <ulTaskGenericNotifyTake+0x38>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80007c76:	30 1b       	mov	r11,1
80007c78:	0c 9c       	mov	r12,r6
80007c7a:	f0 1f 00 18 	mcall	80007cd8 <ulTaskGenericNotifyTake+0x90>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
80007c7e:	d7 33       	scall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80007c80:	f0 1f 00 17 	mcall	80007cdc <ulTaskGenericNotifyTake+0x94>

        taskENTER_CRITICAL();
80007c84:	f0 1f 00 13 	mcall	80007cd0 <ulTaskGenericNotifyTake+0x88>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
80007c88:	49 38       	lddpc	r8,80007cd4 <ulTaskGenericNotifyTake+0x8c>
80007c8a:	70 08       	ld.w	r8,r8[0x0]
80007c8c:	ee c9 ff ed 	sub	r9,r7,-19
80007c90:	f0 09 03 26 	ld.w	r6,r8[r9<<0x2]

            if( ulReturn != 0UL )
80007c94:	58 06       	cp.w	r6,0
80007c96:	c1 10       	breq	80007cb8 <ulTaskGenericNotifyTake+0x70>
            {
                if( xClearCountOnExit != pdFALSE )
80007c98:	58 05       	cp.w	r5,0
80007c9a:	c0 70       	breq	80007ca8 <ulTaskGenericNotifyTake+0x60>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
80007c9c:	48 e8       	lddpc	r8,80007cd4 <ulTaskGenericNotifyTake+0x8c>
80007c9e:	70 08       	ld.w	r8,r8[0x0]
80007ca0:	30 0a       	mov	r10,0
80007ca2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007ca6:	c0 98       	rjmp	80007cb8 <ulTaskGenericNotifyTake+0x70>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
80007ca8:	48 b8       	lddpc	r8,80007cd4 <ulTaskGenericNotifyTake+0x8c>
80007caa:	70 08       	ld.w	r8,r8[0x0]
80007cac:	ec ca 00 01 	sub	r10,r6,1
80007cb0:	ee c9 ff ed 	sub	r9,r7,-19
80007cb4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
80007cb8:	48 78       	lddpc	r8,80007cd4 <ulTaskGenericNotifyTake+0x8c>
80007cba:	70 08       	ld.w	r8,r8[0x0]
80007cbc:	f0 07 00 07 	add	r7,r8,r7
80007cc0:	30 08       	mov	r8,0
80007cc2:	ef 68 00 50 	st.b	r7[80],r8
        }
        taskEXIT_CRITICAL();
80007cc6:	f0 1f 00 06 	mcall	80007cdc <ulTaskGenericNotifyTake+0x94>

        return ulReturn;
    }
80007cca:	0c 9c       	mov	r12,r6
80007ccc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007cd0:	80 00       	ld.sh	r0,r0[0x0]
80007cd2:	6b 68       	ld.w	r8,r5[0x58]
80007cd4:	00 00       	add	r0,r0
80007cd6:	06 6c       	and	r12,r3
80007cd8:	80 00       	ld.sh	r0,r0[0x0]
80007cda:	7b b0       	ld.w	r0,sp[0x6c]
80007cdc:	80 00       	ld.sh	r0,r0[0x0]
80007cde:	6c 74       	ld.w	r4,r6[0x1c]

80007ce0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
80007ce0:	eb cd 40 80 	pushm	r7,lr
80007ce4:	18 97       	mov	r7,r12
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
80007ce6:	58 0c       	cp.w	r12,0
80007ce8:	c0 a0       	breq	80007cfc <vTaskDelay+0x1c>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
80007cea:	f0 1f 00 07 	mcall	80007d04 <vTaskDelay+0x24>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
80007cee:	30 0b       	mov	r11,0
80007cf0:	0e 9c       	mov	r12,r7
80007cf2:	f0 1f 00 06 	mcall	80007d08 <vTaskDelay+0x28>
            }
            xAlreadyYielded = xTaskResumeAll();
80007cf6:	f0 1f 00 06 	mcall	80007d0c <vTaskDelay+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
80007cfa:	c0 21       	brne	80007cfe <vTaskDelay+0x1e>
        {
            portYIELD_WITHIN_API();
80007cfc:	d7 33       	scall
80007cfe:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d02:	00 00       	add	r0,r0
80007d04:	80 00       	ld.sh	r0,r0[0x0]
80007d06:	73 a0       	ld.w	r0,r9[0x68]
80007d08:	80 00       	ld.sh	r0,r0[0x0]
80007d0a:	7b b0       	ld.w	r0,sp[0x6c]
80007d0c:	80 00       	ld.sh	r0,r0[0x0]
80007d0e:	79 04       	ld.w	r4,r12[0x40]

80007d10 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
80007d10:	eb cd 40 80 	pushm	r7,lr
80007d14:	16 97       	mov	r7,r11

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80007d16:	48 68       	lddpc	r8,80007d2c <vTaskPlaceOnEventList+0x1c>
80007d18:	70 0b       	ld.w	r11,r8[0x0]
80007d1a:	2e 8b       	sub	r11,-24
80007d1c:	f0 1f 00 05 	mcall	80007d30 <vTaskPlaceOnEventList+0x20>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80007d20:	30 1b       	mov	r11,1
80007d22:	0e 9c       	mov	r12,r7
80007d24:	f0 1f 00 04 	mcall	80007d34 <vTaskPlaceOnEventList+0x24>
}
80007d28:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d2c:	00 00       	add	r0,r0
80007d2e:	06 6c       	and	r12,r3
80007d30:	80 00       	ld.sh	r0,r0[0x0]
80007d32:	6a 7e       	ld.w	lr,r5[0x1c]
80007d34:	80 00       	ld.sh	r0,r0[0x0]
80007d36:	7b b0       	ld.w	r0,sp[0x6c]

80007d38 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
80007d38:	eb cd 40 80 	pushm	r7,lr
80007d3c:	18 97       	mov	r7,r12

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
80007d3e:	78 cc       	ld.w	r12,r12[0x30]
80007d40:	f0 1f 00 04 	mcall	80007d50 <prvDeleteTCB+0x18>
                vPortFree( pxTCB );
80007d44:	0e 9c       	mov	r12,r7
80007d46:	f0 1f 00 03 	mcall	80007d50 <prvDeleteTCB+0x18>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
80007d4a:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d4e:	00 00       	add	r0,r0
80007d50:	80 00       	ld.sh	r0,r0[0x0]
80007d52:	6d 74       	ld.w	r4,r6[0x5c]

80007d54 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007d54:	eb cd 40 f8 	pushm	r3-r7,lr
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80007d58:	49 17       	lddpc	r7,80007d9c <prvIdleTask+0x48>
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007d5a:	49 25       	lddpc	r5,80007da0 <prvIdleTask+0x4c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
80007d5c:	49 24       	lddpc	r4,80007da4 <prvIdleTask+0x50>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80007d5e:	49 33       	lddpc	r3,80007da8 <prvIdleTask+0x54>
80007d60:	c1 48       	rjmp	80007d88 <prvIdleTask+0x34>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
80007d62:	f0 1f 00 13 	mcall	80007dac <prvIdleTask+0x58>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007d66:	6a 38       	ld.w	r8,r5[0xc]
80007d68:	70 36       	ld.w	r6,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007d6a:	ec cc ff fc 	sub	r12,r6,-4
80007d6e:	f0 1f 00 11 	mcall	80007db0 <prvIdleTask+0x5c>
                    --uxCurrentNumberOfTasks;
80007d72:	68 08       	ld.w	r8,r4[0x0]
80007d74:	20 18       	sub	r8,1
80007d76:	89 08       	st.w	r4[0x0],r8
                    --uxDeletedTasksWaitingCleanUp;
80007d78:	6e 08       	ld.w	r8,r7[0x0]
80007d7a:	20 18       	sub	r8,1
80007d7c:	8f 08       	st.w	r7[0x0],r8
                }
                taskEXIT_CRITICAL();
80007d7e:	f0 1f 00 0e 	mcall	80007db4 <prvIdleTask+0x60>

                prvDeleteTCB( pxTCB );
80007d82:	0c 9c       	mov	r12,r6
80007d84:	f0 1f 00 0d 	mcall	80007db8 <prvIdleTask+0x64>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80007d88:	6e 08       	ld.w	r8,r7[0x0]
80007d8a:	58 08       	cp.w	r8,0
80007d8c:	ce b1       	brne	80007d62 <prvIdleTask+0xe>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80007d8e:	66 08       	ld.w	r8,r3[0x0]
80007d90:	58 18       	cp.w	r8,1
80007d92:	fe 98 ff fb 	brls	80007d88 <prvIdleTask+0x34>
                {
                    taskYIELD();
80007d96:	d7 33       	scall
80007d98:	cf 8b       	rjmp	80007d88 <prvIdleTask+0x34>
80007d9a:	00 00       	add	r0,r0
80007d9c:	00 00       	add	r0,r0
80007d9e:	06 68       	and	r8,r3
80007da0:	00 00       	add	r0,r0
80007da2:	06 bc       	st.h	r3++,r12
80007da4:	00 00       	add	r0,r0
80007da6:	06 b8       	st.h	r3++,r8
80007da8:	00 00       	add	r0,r0
80007daa:	05 c8       	ld.ub	r8,r2[0x4]
80007dac:	80 00       	ld.sh	r0,r0[0x0]
80007dae:	6b 68       	ld.w	r8,r5[0x58]
80007db0:	80 00       	ld.sh	r0,r0[0x0]
80007db2:	6a ae       	ld.w	lr,r5[0x28]
80007db4:	80 00       	ld.sh	r0,r0[0x0]
80007db6:	6c 74       	ld.w	r4,r6[0x1c]
80007db8:	80 00       	ld.sh	r0,r0[0x0]
80007dba:	7d 38       	ld.w	r8,lr[0x4c]

80007dbc <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
80007dbc:	d4 31       	pushm	r0-r7,lr
80007dbe:	20 1d       	sub	sp,4
80007dc0:	50 0c       	stdsp	sp[0x0],r12
80007dc2:	16 97       	mov	r7,r11
80007dc4:	12 90       	mov	r0,r9
80007dc6:	10 94       	mov	r4,r8
80007dc8:	40 a2       	lddsp	r2,sp[0x28]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
80007dca:	e7 da c0 10 	bfextu	r3,r10,0x0,0x10
80007dce:	e6 0c 15 02 	lsl	r12,r3,0x2
80007dd2:	f0 1f 00 61 	mcall	80007f54 <xTaskCreate+0x198>
80007dd6:	18 96       	mov	r6,r12

                if( pxStack != NULL )
80007dd8:	c0 31       	brne	80007dde <xTaskCreate+0x22>
80007dda:	3f fc       	mov	r12,-1
80007ddc:	cb a8       	rjmp	80007f50 <xTaskCreate+0x194>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
80007dde:	35 4c       	mov	r12,84
80007de0:	f0 1f 00 5d 	mcall	80007f54 <xTaskCreate+0x198>
80007de4:	18 95       	mov	r5,r12

                    if( pxNewTCB != NULL )
80007de6:	c0 50       	breq	80007df0 <xTaskCreate+0x34>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
80007de8:	99 c6       	st.w	r12[0x30],r6
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
80007dea:	58 07       	cp.w	r7,0
80007dec:	c0 71       	brne	80007dfa <xTaskCreate+0x3e>
80007dee:	c2 28       	rjmp	80007e32 <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
80007df0:	0c 9c       	mov	r12,r6
80007df2:	f0 1f 00 5a 	mcall	80007f58 <xTaskCreate+0x19c>
80007df6:	3f fc       	mov	r12,-1
80007df8:	ca c8       	rjmp	80007f50 <xTaskCreate+0x194>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80007dfa:	0f 88       	ld.ub	r8,r7[0x0]
80007dfc:	f9 68 00 34 	st.b	r12[52],r8

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80007e00:	0f 89       	ld.ub	r9,r7[0x0]
80007e02:	30 08       	mov	r8,0
80007e04:	f0 09 18 00 	cp.b	r9,r8
80007e08:	c1 10       	breq	80007e2a <xTaskCreate+0x6e>
80007e0a:	2f f7       	sub	r7,-1
80007e0c:	f8 c8 ff cb 	sub	r8,r12,-53
80007e10:	30 19       	mov	r9,1
80007e12:	30 0b       	mov	r11,0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80007e14:	0f 8a       	ld.ub	r10,r7[0x0]
80007e16:	b0 8a       	st.b	r8[0x0],r10

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80007e18:	0f 8a       	ld.ub	r10,r7[0x0]
80007e1a:	f6 0a 18 00 	cp.b	r10,r11
80007e1e:	c0 60       	breq	80007e2a <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80007e20:	2f f9       	sub	r9,-1
80007e22:	2f f7       	sub	r7,-1
80007e24:	2f f8       	sub	r8,-1
80007e26:	59 09       	cp.w	r9,16
80007e28:	cf 61       	brne	80007e14 <xTaskCreate+0x58>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80007e2a:	30 08       	mov	r8,0
80007e2c:	eb 68 00 43 	st.b	r5[67],r8
80007e30:	c0 48       	rjmp	80007e38 <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
80007e32:	30 08       	mov	r8,0
80007e34:	f9 68 00 34 	st.b	r12[52],r8
80007e38:	58 74       	cp.w	r4,7
80007e3a:	f9 b4 0b 07 	movhi	r4,7
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
80007e3e:	8b b4       	st.w	r5[0x2c],r4
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
80007e40:	eb 44 00 44 	st.w	r5[68],r4
            pxNewTCB->uxMutexesHeld = 0;
80007e44:	30 07       	mov	r7,0
80007e46:	eb 47 00 48 	st.w	r5[72],r7
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80007e4a:	ea c1 ff fc 	sub	r1,r5,-4
80007e4e:	02 9c       	mov	r12,r1
80007e50:	f0 1f 00 43 	mcall	80007f5c <xTaskCreate+0x1a0>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80007e54:	ea cc ff e8 	sub	r12,r5,-24
80007e58:	f0 1f 00 41 	mcall	80007f5c <xTaskCreate+0x1a0>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80007e5c:	8b 45       	st.w	r5[0x10],r5

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007e5e:	e8 04 11 08 	rsub	r4,r4,8
80007e62:	8b 64       	st.w	r5[0x18],r4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80007e64:	8b 95       	st.w	r5[0x24],r5
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
80007e66:	ea c8 ff b4 	sub	r8,r5,-76
80007e6a:	91 07       	st.w	r8[0x0],r7
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
80007e6c:	ea c8 ff b0 	sub	r8,r5,-80
80007e70:	b0 87       	st.b	r8[0x0],r7
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
80007e72:	20 13       	sub	r3,1
80007e74:	ec 03 00 26 	add	r6,r6,r3<<0x2
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007e78:	00 9a       	mov	r10,r0
80007e7a:	40 0b       	lddsp	r11,sp[0x0]
80007e7c:	0c 9c       	mov	r12,r6
80007e7e:	e0 1c ff fc 	andl	r12,0xfffc
80007e82:	f0 1f 00 38 	mcall	80007f60 <xTaskCreate+0x1a4>
80007e86:	8b 0c       	st.w	r5[0x0],r12

    if( pxCreatedTask != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80007e88:	58 02       	cp.w	r2,0
80007e8a:	e5 f5 1a 00 	st.wne	r2[0x0],r5

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
80007e8e:	f0 1f 00 36 	mcall	80007f64 <xTaskCreate+0x1a8>
    {
        uxCurrentNumberOfTasks++;
80007e92:	4b 68       	lddpc	r8,80007f68 <xTaskCreate+0x1ac>
80007e94:	70 09       	ld.w	r9,r8[0x0]
80007e96:	2f f9       	sub	r9,-1
80007e98:	91 09       	st.w	r8[0x0],r9

        if( pxCurrentTCB == NULL )
80007e9a:	4b 58       	lddpc	r8,80007f6c <xTaskCreate+0x1b0>
80007e9c:	70 08       	ld.w	r8,r8[0x0]
80007e9e:	58 08       	cp.w	r8,0
80007ea0:	c2 61       	brne	80007eec <xTaskCreate+0x130>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
80007ea2:	4b 38       	lddpc	r8,80007f6c <xTaskCreate+0x1b0>
80007ea4:	91 05       	st.w	r8[0x0],r5

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80007ea6:	4b 18       	lddpc	r8,80007f68 <xTaskCreate+0x1ac>
80007ea8:	70 08       	ld.w	r8,r8[0x0]
80007eaa:	58 18       	cp.w	r8,1
80007eac:	c2 d1       	brne	80007f06 <xTaskCreate+0x14a>
80007eae:	4b 17       	lddpc	r7,80007f70 <xTaskCreate+0x1b4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
80007eb0:	ee c6 ff 60 	sub	r6,r7,-160
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
80007eb4:	0e 9c       	mov	r12,r7
80007eb6:	f0 1f 00 30 	mcall	80007f74 <xTaskCreate+0x1b8>
80007eba:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80007ebc:	0c 37       	cp.w	r7,r6
80007ebe:	cf b1       	brne	80007eb4 <xTaskCreate+0xf8>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
80007ec0:	4a e7       	lddpc	r7,80007f78 <xTaskCreate+0x1bc>
80007ec2:	0e 9c       	mov	r12,r7
80007ec4:	f0 1f 00 2c 	mcall	80007f74 <xTaskCreate+0x1b8>
    vListInitialise( &xDelayedTaskList2 );
80007ec8:	4a d6       	lddpc	r6,80007f7c <xTaskCreate+0x1c0>
80007eca:	0c 9c       	mov	r12,r6
80007ecc:	f0 1f 00 2a 	mcall	80007f74 <xTaskCreate+0x1b8>
    vListInitialise( &xPendingReadyList );
80007ed0:	4a cc       	lddpc	r12,80007f80 <xTaskCreate+0x1c4>
80007ed2:	f0 1f 00 29 	mcall	80007f74 <xTaskCreate+0x1b8>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
80007ed6:	4a cc       	lddpc	r12,80007f84 <xTaskCreate+0x1c8>
80007ed8:	f0 1f 00 27 	mcall	80007f74 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
80007edc:	4a bc       	lddpc	r12,80007f88 <xTaskCreate+0x1cc>
80007ede:	f0 1f 00 26 	mcall	80007f74 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
80007ee2:	4a b8       	lddpc	r8,80007f8c <xTaskCreate+0x1d0>
80007ee4:	91 07       	st.w	r8[0x0],r7
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007ee6:	4a b8       	lddpc	r8,80007f90 <xTaskCreate+0x1d4>
80007ee8:	91 06       	st.w	r8[0x0],r6
80007eea:	c0 e8       	rjmp	80007f06 <xTaskCreate+0x14a>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
80007eec:	4a a8       	lddpc	r8,80007f94 <xTaskCreate+0x1d8>
80007eee:	70 08       	ld.w	r8,r8[0x0]
80007ef0:	58 08       	cp.w	r8,0
80007ef2:	c0 a1       	brne	80007f06 <xTaskCreate+0x14a>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80007ef4:	49 e8       	lddpc	r8,80007f6c <xTaskCreate+0x1b0>
80007ef6:	70 08       	ld.w	r8,r8[0x0]
80007ef8:	70 b9       	ld.w	r9,r8[0x2c]
80007efa:	6a b8       	ld.w	r8,r5[0x2c]
80007efc:	10 39       	cp.w	r9,r8
80007efe:	e0 8b 00 04 	brhi	80007f06 <xTaskCreate+0x14a>
                {
                    pxCurrentTCB = pxNewTCB;
80007f02:	49 b8       	lddpc	r8,80007f6c <xTaskCreate+0x1b0>
80007f04:	91 05       	st.w	r8[0x0],r5
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
80007f06:	4a 58       	lddpc	r8,80007f98 <xTaskCreate+0x1dc>
80007f08:	70 09       	ld.w	r9,r8[0x0]
80007f0a:	2f f9       	sub	r9,-1
80007f0c:	91 09       	st.w	r8[0x0],r9
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
80007f0e:	6a b8       	ld.w	r8,r5[0x2c]
80007f10:	4a 39       	lddpc	r9,80007f9c <xTaskCreate+0x1e0>
80007f12:	72 09       	ld.w	r9,r9[0x0]
80007f14:	12 38       	cp.w	r8,r9
80007f16:	e0 88 00 04 	brls	80007f1e <xTaskCreate+0x162>
80007f1a:	4a 19       	lddpc	r9,80007f9c <xTaskCreate+0x1e0>
80007f1c:	93 08       	st.w	r9[0x0],r8
80007f1e:	6a bc       	ld.w	r12,r5[0x2c]
80007f20:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007f24:	02 9b       	mov	r11,r1
80007f26:	49 38       	lddpc	r8,80007f70 <xTaskCreate+0x1b4>
80007f28:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007f2c:	f0 1f 00 1d 	mcall	80007fa0 <xTaskCreate+0x1e4>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
80007f30:	f0 1f 00 1d 	mcall	80007fa4 <xTaskCreate+0x1e8>

    if( xSchedulerRunning != pdFALSE )
80007f34:	49 88       	lddpc	r8,80007f94 <xTaskCreate+0x1d8>
80007f36:	70 08       	ld.w	r8,r8[0x0]
80007f38:	58 08       	cp.w	r8,0
80007f3a:	c0 a0       	breq	80007f4e <xTaskCreate+0x192>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80007f3c:	48 c8       	lddpc	r8,80007f6c <xTaskCreate+0x1b0>
80007f3e:	70 08       	ld.w	r8,r8[0x0]
80007f40:	70 b9       	ld.w	r9,r8[0x2c]
80007f42:	6a b8       	ld.w	r8,r5[0x2c]
80007f44:	10 39       	cp.w	r9,r8
80007f46:	c0 42       	brcc	80007f4e <xTaskCreate+0x192>
        {
            taskYIELD_IF_USING_PREEMPTION();
80007f48:	d7 33       	scall
80007f4a:	30 1c       	mov	r12,1
80007f4c:	c0 28       	rjmp	80007f50 <xTaskCreate+0x194>
80007f4e:	30 1c       	mov	r12,1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
80007f50:	2f fd       	sub	sp,-4
80007f52:	d8 32       	popm	r0-r7,pc
80007f54:	80 00       	ld.sh	r0,r0[0x0]
80007f56:	6d 9c       	ld.w	r12,r6[0x64]
80007f58:	80 00       	ld.sh	r0,r0[0x0]
80007f5a:	6d 74       	ld.w	r4,r6[0x5c]
80007f5c:	80 00       	ld.sh	r0,r0[0x0]
80007f5e:	6a 60       	ld.w	r0,r5[0x18]
80007f60:	80 00       	ld.sh	r0,r0[0x0]
80007f62:	6a d6       	ld.w	r6,r5[0x34]
80007f64:	80 00       	ld.sh	r0,r0[0x0]
80007f66:	6b 68       	ld.w	r8,r5[0x58]
80007f68:	00 00       	add	r0,r0
80007f6a:	06 b8       	st.h	r3++,r8
80007f6c:	00 00       	add	r0,r0
80007f6e:	06 6c       	and	r12,r3
80007f70:	00 00       	add	r0,r0
80007f72:	05 c8       	ld.ub	r8,r2[0x4]
80007f74:	80 00       	ld.sh	r0,r0[0x0]
80007f76:	6a 4c       	ld.w	r12,r5[0x10]
80007f78:	00 00       	add	r0,r0
80007f7a:	06 84       	andn	r4,r3
80007f7c:	00 00       	add	r0,r0
80007f7e:	06 a0       	st.w	r3++,r0
80007f80:	00 00       	add	r0,r0
80007f82:	06 70       	tst	r0,r3
80007f84:	00 00       	add	r0,r0
80007f86:	06 bc       	st.h	r3++,r12
80007f88:	00 00       	add	r0,r0
80007f8a:	06 d4       	st.w	--r3,r4
80007f8c:	00 00       	add	r0,r0
80007f8e:	05 b4       	ld.ub	r4,r2[0x3]
80007f90:	00 00       	add	r0,r0
80007f92:	05 c0       	ld.ub	r0,r2[0x4]
80007f94:	00 00       	add	r0,r0
80007f96:	05 b8       	ld.ub	r8,r2[0x3]
80007f98:	00 00       	add	r0,r0
80007f9a:	06 b4       	st.h	r3++,r4
80007f9c:	00 00       	add	r0,r0
80007f9e:	06 e8       	st.h	--r3,r8
80007fa0:	80 00       	ld.sh	r0,r0[0x0]
80007fa2:	6a 66       	ld.w	r6,r5[0x18]
80007fa4:	80 00       	ld.sh	r0,r0[0x0]
80007fa6:	6c 74       	ld.w	r4,r6[0x1c]

80007fa8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
80007fa8:	d4 01       	pushm	lr
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
80007faa:	48 f8       	lddpc	r8,80007fe4 <vTaskStartScheduler+0x3c>
80007fac:	1a d8       	st.w	--sp,r8
80007fae:	30 08       	mov	r8,0
80007fb0:	10 99       	mov	r9,r8
80007fb2:	e0 6a 01 00 	mov	r10,256
80007fb6:	48 db       	lddpc	r11,80007fe8 <vTaskStartScheduler+0x40>
80007fb8:	48 dc       	lddpc	r12,80007fec <vTaskStartScheduler+0x44>
80007fba:	f0 1f 00 0e 	mcall	80007ff0 <vTaskStartScheduler+0x48>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
80007fbe:	2f fd       	sub	sp,-4
80007fc0:	58 1c       	cp.w	r12,1
80007fc2:	c0 d1       	brne	80007fdc <vTaskStartScheduler+0x34>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
80007fc4:	d3 03       	ssrf	0x10
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
80007fc6:	3f f9       	mov	r9,-1
80007fc8:	48 b8       	lddpc	r8,80007ff4 <vTaskStartScheduler+0x4c>
80007fca:	91 09       	st.w	r8[0x0],r9
        xSchedulerRunning = pdTRUE;
80007fcc:	30 19       	mov	r9,1
80007fce:	48 b8       	lddpc	r8,80007ff8 <vTaskStartScheduler+0x50>
80007fd0:	91 09       	st.w	r8[0x0],r9
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
80007fd2:	30 09       	mov	r9,0
80007fd4:	48 a8       	lddpc	r8,80007ffc <vTaskStartScheduler+0x54>
80007fd6:	91 09       	st.w	r8[0x0],r9

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
80007fd8:	f0 1f 00 0a 	mcall	80008000 <vTaskStartScheduler+0x58>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
80007fdc:	48 a8       	lddpc	r8,80008004 <vTaskStartScheduler+0x5c>
80007fde:	70 08       	ld.w	r8,r8[0x0]
}
80007fe0:	d8 02       	popm	pc
80007fe2:	00 00       	add	r0,r0
80007fe4:	00 00       	add	r0,r0
80007fe6:	06 d0       	st.w	--r3,r0
80007fe8:	80 00       	ld.sh	r0,r0[0x0]
80007fea:	a7 9c       	lsr	r12,0x7
80007fec:	80 00       	ld.sh	r0,r0[0x0]
80007fee:	7d 54       	ld.w	r4,lr[0x54]
80007ff0:	80 00       	ld.sh	r0,r0[0x0]
80007ff2:	7d bc       	ld.w	r12,lr[0x6c]
80007ff4:	00 00       	add	r0,r0
80007ff6:	05 b0       	ld.ub	r0,r2[0x3]
80007ff8:	00 00       	add	r0,r0
80007ffa:	05 b8       	ld.ub	r8,r2[0x3]
80007ffc:	00 00       	add	r0,r0
80007ffe:	06 98       	mov	r8,r3
80008000:	80 00       	ld.sh	r0,r0[0x0]
80008002:	6b 78       	ld.w	r8,r5[0x5c]
80008004:	00 00       	add	r0,r0
80008006:	00 28       	rsub	r8,r0

80008008 <check_sd_card>:
	pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
	
}

void check_sd_card(void)
{
80008008:	d4 01       	pushm	lr
	// NECESSARY: Initialize USART first.
	print_dbg("\r\nInit SD/MMC Driver");
8000800a:	49 0c       	lddpc	r12,80008048 <check_sd_card+0x40>
8000800c:	f0 1f 00 10 	mcall	8000804c <check_sd_card+0x44>
	print_dbg("\r\nInsert SD/MMC...");
80008010:	49 0c       	lddpc	r12,80008050 <check_sd_card+0x48>
80008012:	f0 1f 00 0f 	mcall	8000804c <check_sd_card+0x44>
		
	while (!sd_mmc_spi_mem_check());
80008016:	f0 1f 00 10 	mcall	80008054 <check_sd_card+0x4c>
8000801a:	cf e0       	breq	80008016 <check_sd_card+0xe>
	print_dbg("\r\nCard detected!");
8000801c:	48 fc       	lddpc	r12,80008058 <check_sd_card+0x50>
8000801e:	f0 1f 00 0c 	mcall	8000804c <check_sd_card+0x44>
		
	// Read Card capacity
	sd_mmc_spi_get_capacity();
80008022:	f0 1f 00 0f 	mcall	8000805c <check_sd_card+0x54>
	print_dbg("Capacity = ");
80008026:	48 fc       	lddpc	r12,80008060 <check_sd_card+0x58>
80008028:	f0 1f 00 09 	mcall	8000804c <check_sd_card+0x44>
	print_dbg_ulong(capacity >> 20);
8000802c:	48 e8       	lddpc	r8,80008064 <check_sd_card+0x5c>
8000802e:	f0 e8 00 00 	ld.d	r8,r8[0]
80008032:	f0 0c 16 14 	lsr	r12,r8,0x14
80008036:	f9 e9 10 cc 	or	r12,r12,r9<<0xc
8000803a:	f0 1f 00 0c 	mcall	80008068 <check_sd_card+0x60>
	print_dbg(" MBytes\r\n");
8000803e:	48 cc       	lddpc	r12,8000806c <check_sd_card+0x64>
80008040:	f0 1f 00 03 	mcall	8000804c <check_sd_card+0x44>
}
80008044:	d8 02       	popm	pc
80008046:	00 00       	add	r0,r0
80008048:	80 00       	ld.sh	r0,r0[0x0]
8000804a:	a7 d4       	cbr	r4,0x7
8000804c:	80 00       	ld.sh	r0,r0[0x0]
8000804e:	67 f4       	ld.w	r4,r3[0x7c]
80008050:	80 00       	ld.sh	r0,r0[0x0]
80008052:	a7 ec       	*unknown*
80008054:	80 00       	ld.sh	r0,r0[0x0]
80008056:	37 70       	mov	r0,119
80008058:	80 00       	ld.sh	r0,r0[0x0]
8000805a:	a8 00       	st.h	r4[0x0],r0
8000805c:	80 00       	ld.sh	r0,r0[0x0]
8000805e:	2c 5c       	sub	r12,-59
80008060:	80 00       	ld.sh	r0,r0[0x0]
80008062:	a8 14       	st.h	r4[0x2],r4
80008064:	00 00       	add	r0,r0
80008066:	0a 78       	tst	r8,r5
80008068:	80 00       	ld.sh	r0,r0[0x0]
8000806a:	67 e0       	ld.w	r0,r3[0x78]
8000806c:	80 00       	ld.sh	r0,r0[0x0]
8000806e:	a8 20       	st.h	r4[0x4],r0

80008070 <sd_mmc_resources_init>:

#include "conf_spi_sd.h"

// SPI
void sd_mmc_resources_init(void)
{
80008070:	eb cd 40 80 	pushm	r7,lr
80008074:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80008076:	49 98       	lddpc	r8,800080d8 <sd_mmc_resources_init+0x68>
80008078:	1a 97       	mov	r7,sp
8000807a:	f0 ea 00 00 	ld.d	r10,r8[0]
8000807e:	fa eb 00 00 	st.d	sp[0],r10
80008082:	f0 e8 00 08 	ld.d	r8,r8[8]
80008086:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
8000808a:	30 4b       	mov	r11,4
8000808c:	49 4c       	lddpc	r12,800080dc <sd_mmc_resources_init+0x6c>
8000808e:	f0 1f 00 15 	mcall	800080e0 <sd_mmc_resources_init+0x70>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80008092:	1a 9b       	mov	r11,sp
80008094:	fe 7c 24 00 	mov	r12,-56320
80008098:	f0 1f 00 13 	mcall	800080e4 <sd_mmc_resources_init+0x74>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
8000809c:	30 09       	mov	r9,0
8000809e:	12 9a       	mov	r10,r9
800080a0:	12 9b       	mov	r11,r9
800080a2:	fe 7c 24 00 	mov	r12,-56320
800080a6:	f0 1f 00 11 	mcall	800080e8 <sd_mmc_resources_init+0x78>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
800080aa:	fe 7c 24 00 	mov	r12,-56320
800080ae:	f0 1f 00 10 	mcall	800080ec <sd_mmc_resources_init+0x7c>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, PBA_HZ);
800080b2:	20 4d       	sub	sp,16
800080b4:	ee e8 00 00 	ld.d	r8,r7[0]
800080b8:	fa e9 00 00 	st.d	sp[0],r8
800080bc:	ee e8 00 08 	ld.d	r8,r7[8]
800080c0:	fa e9 00 08 	st.d	sp[8],r8
800080c4:	e0 6c 76 00 	mov	r12,30208
800080c8:	ea 1c 03 b3 	orh	r12,0x3b3
800080cc:	f0 1f 00 09 	mcall	800080f0 <sd_mmc_resources_init+0x80>
800080d0:	2f cd       	sub	sp,-16
	
}
800080d2:	2f cd       	sub	sp,-16
800080d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800080d8:	80 00       	ld.sh	r0,r0[0x0]
800080da:	a7 a4       	sbr	r4,0x6
800080dc:	80 00       	ld.sh	r0,r0[0x0]
800080de:	a7 b4       	sbr	r4,0x7
800080e0:	80 00       	ld.sh	r0,r0[0x0]
800080e2:	8b e0       	st.w	r5[0x38],r0
800080e4:	80 00       	ld.sh	r0,r0[0x0]
800080e6:	40 a6       	lddsp	r6,sp[0x28]
800080e8:	80 00       	ld.sh	r0,r0[0x0]
800080ea:	40 de       	lddsp	lr,sp[0x34]
800080ec:	80 00       	ld.sh	r0,r0[0x0]
800080ee:	41 0a       	lddsp	r10,sp[0x40]
800080f0:	80 00       	ld.sh	r0,r0[0x0]
800080f2:	37 98       	mov	r8,121

800080f4 <master_callback>:

	else if( arg == AUDIO_ADC_RELOAD_CB )
	{
		adc_reload_callback();;
	}
}
800080f4:	5e fc       	retal	r12
800080f6:	d7 03       	nop

800080f8 <RT_ISR_gpio_qt_71_not_naked>:
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
{
800080f8:	d4 01       	pushm	lr
	// ENTER, LEFT, RIGHT
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER))
800080fa:	33 ac       	mov	r12,58
800080fc:	f0 1f 00 17 	mcall	80008158 <RT_ISR_gpio_qt_71_not_naked+0x60>
80008100:	c0 b0       	breq	80008116 <RT_ISR_gpio_qt_71_not_naked+0x1e>
	{
		INTC_QT_FLAG._enter = true;
80008102:	49 78       	lddpc	r8,8000815c <RT_ISR_gpio_qt_71_not_naked+0x64>
80008104:	11 89       	ld.ub	r9,r8[0x0]
80008106:	30 1a       	mov	r10,1
80008108:	f3 da d0 e1 	bfins	r9,r10,0x7,0x1
8000810c:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER);
8000810e:	33 ac       	mov	r12,58
80008110:	f0 1f 00 14 	mcall	80008160 <RT_ISR_gpio_qt_71_not_naked+0x68>
80008114:	c1 c8       	rjmp	8000814c <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT))
80008116:	33 9c       	mov	r12,57
80008118:	f0 1f 00 10 	mcall	80008158 <RT_ISR_gpio_qt_71_not_naked+0x60>
8000811c:	c0 b0       	breq	80008132 <RT_ISR_gpio_qt_71_not_naked+0x3a>
	{
		INTC_QT_FLAG._left = true;
8000811e:	49 08       	lddpc	r8,8000815c <RT_ISR_gpio_qt_71_not_naked+0x64>
80008120:	11 89       	ld.ub	r9,r8[0x0]
80008122:	30 1a       	mov	r10,1
80008124:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
80008128:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT);
8000812a:	33 9c       	mov	r12,57
8000812c:	f0 1f 00 0d 	mcall	80008160 <RT_ISR_gpio_qt_71_not_naked+0x68>
80008130:	c0 e8       	rjmp	8000814c <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT))
80008132:	33 8c       	mov	r12,56
80008134:	f0 1f 00 09 	mcall	80008158 <RT_ISR_gpio_qt_71_not_naked+0x60>
80008138:	c0 a0       	breq	8000814c <RT_ISR_gpio_qt_71_not_naked+0x54>
	{
		INTC_QT_FLAG._right = true;
8000813a:	48 98       	lddpc	r8,8000815c <RT_ISR_gpio_qt_71_not_naked+0x64>
8000813c:	11 89       	ld.ub	r9,r8[0x0]
8000813e:	30 1a       	mov	r10,1
80008140:	f3 da d0 a1 	bfins	r9,r10,0x5,0x1
80008144:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT);
80008146:	33 8c       	mov	r12,56
80008148:	f0 1f 00 06 	mcall	80008160 <RT_ISR_gpio_qt_71_not_naked+0x68>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
8000814c:	48 68       	lddpc	r8,80008164 <RT_ISR_gpio_qt_71_not_naked+0x6c>
8000814e:	70 0c       	ld.w	r12,r8[0x0]
80008150:	f0 1f 00 06 	mcall	80008168 <RT_ISR_gpio_qt_71_not_naked+0x70>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80008154:	5f 1c       	srne	r12
80008156:	d8 02       	popm	pc
80008158:	80 00       	ld.sh	r0,r0[0x0]
8000815a:	8c ce       	ld.uh	lr,r6[0x8]
8000815c:	00 00       	add	r0,r0
8000815e:	0d e0       	ld.ub	r0,r6[0x6]
80008160:	80 00       	ld.sh	r0,r0[0x0]
80008162:	8c e6       	ld.uh	r6,r6[0xc]
80008164:	00 00       	add	r0,r0
80008166:	06 f0       	st.b	--r3,r0
80008168:	80 00       	ld.sh	r0,r0[0x0]
8000816a:	79 e8       	ld.w	r8,r12[0x78]

8000816c <RT_ISR_gpio_qt_71>:

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
8000816c:	eb cd 00 ff 	pushm	r0-r7
80008170:	e0 68 00 24 	mov	r8,36
80008174:	ea 18 00 00 	orh	r8,0x0
80008178:	70 00       	ld.w	r0,r8[0x0]
8000817a:	1a d0       	st.w	--sp,r0
8000817c:	7a 90       	ld.w	r0,sp[0x24]
8000817e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008182:	58 10       	cp.w	r0,1
80008184:	e0 8b 00 08 	brhi	80008194 <LABEL_ISR_SKIP_SAVE_CONTEXT_833>
80008188:	e0 68 06 6c 	mov	r8,1644
8000818c:	ea 18 00 00 	orh	r8,0x0
80008190:	70 00       	ld.w	r0,r8[0x0]
80008192:	81 0d       	st.w	r0[0x0],sp

80008194 <LABEL_ISR_SKIP_SAVE_CONTEXT_833>:
80008194:	f0 1f 00 10 	mcall	800081d4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_833+0x14>
80008198:	7a 90       	ld.w	r0,sp[0x24]
8000819a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000819e:	58 10       	cp.w	r0,1
800081a0:	e0 8b 00 10 	brhi	800081c0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_833>
800081a4:	58 1c       	cp.w	r12,1
800081a6:	c0 71       	brne	800081b4 <LABEL_ISR_RESTORE_CONTEXT_833>
800081a8:	f0 1f 00 0c 	mcall	800081d8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_833+0x18>
800081ac:	f0 1f 00 0c 	mcall	800081dc <LABEL_ISR_SKIP_RESTORE_CONTEXT_833+0x1c>
800081b0:	f0 1f 00 0c 	mcall	800081e0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_833+0x20>

800081b4 <LABEL_ISR_RESTORE_CONTEXT_833>:
800081b4:	e0 68 06 6c 	mov	r8,1644
800081b8:	ea 18 00 00 	orh	r8,0x0
800081bc:	70 00       	ld.w	r0,r8[0x0]
800081be:	60 0d       	ld.w	sp,r0[0x0]

800081c0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_833>:
800081c0:	1b 00       	ld.w	r0,sp++
800081c2:	e0 68 00 24 	mov	r8,36
800081c6:	ea 18 00 00 	orh	r8,0x0
800081ca:	91 00       	st.w	r8[0x0],r0
800081cc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800081d0:	d6 03       	rete
800081d2:	00 00       	add	r0,r0
800081d4:	80 00       	ld.sh	r0,r0[0x0]
800081d6:	80 f8       	ld.uh	r8,r0[0xe]
800081d8:	80 00       	ld.sh	r0,r0[0x0]
800081da:	6b 68       	ld.w	r8,r5[0x58]
800081dc:	80 00       	ld.sh	r0,r0[0x0]
800081de:	73 b0       	ld.w	r0,r9[0x6c]
800081e0:	80 00       	ld.sh	r0,r0[0x0]
800081e2:	6c 74       	ld.w	r4,r6[0x1c]

800081e4 <RT_ISR_gpio_qt_70_not_naked>:
	
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
{
800081e4:	d4 01       	pushm	lr
	// UP, DOWN
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP))
800081e6:	33 6c       	mov	r12,54
800081e8:	f0 1f 00 10 	mcall	80008228 <RT_ISR_gpio_qt_70_not_naked+0x44>
800081ec:	c0 b0       	breq	80008202 <RT_ISR_gpio_qt_70_not_naked+0x1e>
	{
		INTC_QT_FLAG._up = true;
800081ee:	49 08       	lddpc	r8,8000822c <RT_ISR_gpio_qt_70_not_naked+0x48>
800081f0:	11 89       	ld.ub	r9,r8[0x0]
800081f2:	30 1a       	mov	r10,1
800081f4:	f3 da d0 81 	bfins	r9,r10,0x4,0x1
800081f8:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP);
800081fa:	33 6c       	mov	r12,54
800081fc:	f0 1f 00 0d 	mcall	80008230 <RT_ISR_gpio_qt_70_not_naked+0x4c>
80008200:	c0 e8       	rjmp	8000821c <RT_ISR_gpio_qt_70_not_naked+0x38>

	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN))
80008202:	33 7c       	mov	r12,55
80008204:	f0 1f 00 09 	mcall	80008228 <RT_ISR_gpio_qt_70_not_naked+0x44>
80008208:	c0 a0       	breq	8000821c <RT_ISR_gpio_qt_70_not_naked+0x38>
	{
		INTC_QT_FLAG._down = true;
8000820a:	48 98       	lddpc	r8,8000822c <RT_ISR_gpio_qt_70_not_naked+0x48>
8000820c:	11 89       	ld.ub	r9,r8[0x0]
8000820e:	30 1a       	mov	r10,1
80008210:	f3 da d0 61 	bfins	r9,r10,0x3,0x1
80008214:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN);
80008216:	33 7c       	mov	r12,55
80008218:	f0 1f 00 06 	mcall	80008230 <RT_ISR_gpio_qt_70_not_naked+0x4c>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
8000821c:	48 68       	lddpc	r8,80008234 <RT_ISR_gpio_qt_70_not_naked+0x50>
8000821e:	70 0c       	ld.w	r12,r8[0x0]
80008220:	f0 1f 00 06 	mcall	80008238 <RT_ISR_gpio_qt_70_not_naked+0x54>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80008224:	5f 1c       	srne	r12
80008226:	d8 02       	popm	pc
80008228:	80 00       	ld.sh	r0,r0[0x0]
8000822a:	8c ce       	ld.uh	lr,r6[0x8]
8000822c:	00 00       	add	r0,r0
8000822e:	0d e0       	ld.ub	r0,r6[0x6]
80008230:	80 00       	ld.sh	r0,r0[0x0]
80008232:	8c e6       	ld.uh	r6,r6[0xc]
80008234:	00 00       	add	r0,r0
80008236:	06 f0       	st.b	--r3,r0
80008238:	80 00       	ld.sh	r0,r0[0x0]
8000823a:	79 e8       	ld.w	r8,r12[0x78]

8000823c <RT_ISR_gpio_qt_70>:

	
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
8000823c:	eb cd 00 ff 	pushm	r0-r7
80008240:	e0 68 00 24 	mov	r8,36
80008244:	ea 18 00 00 	orh	r8,0x0
80008248:	70 00       	ld.w	r0,r8[0x0]
8000824a:	1a d0       	st.w	--sp,r0
8000824c:	7a 90       	ld.w	r0,sp[0x24]
8000824e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008252:	58 10       	cp.w	r0,1
80008254:	e0 8b 00 08 	brhi	80008264 <LABEL_ISR_SKIP_SAVE_CONTEXT_812>
80008258:	e0 68 06 6c 	mov	r8,1644
8000825c:	ea 18 00 00 	orh	r8,0x0
80008260:	70 00       	ld.w	r0,r8[0x0]
80008262:	81 0d       	st.w	r0[0x0],sp

80008264 <LABEL_ISR_SKIP_SAVE_CONTEXT_812>:
80008264:	f0 1f 00 10 	mcall	800082a4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_812+0x14>
80008268:	7a 90       	ld.w	r0,sp[0x24]
8000826a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000826e:	58 10       	cp.w	r0,1
80008270:	e0 8b 00 10 	brhi	80008290 <LABEL_ISR_SKIP_RESTORE_CONTEXT_812>
80008274:	58 1c       	cp.w	r12,1
80008276:	c0 71       	brne	80008284 <LABEL_ISR_RESTORE_CONTEXT_812>
80008278:	f0 1f 00 0c 	mcall	800082a8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_812+0x18>
8000827c:	f0 1f 00 0c 	mcall	800082ac <LABEL_ISR_SKIP_RESTORE_CONTEXT_812+0x1c>
80008280:	f0 1f 00 0c 	mcall	800082b0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_812+0x20>

80008284 <LABEL_ISR_RESTORE_CONTEXT_812>:
80008284:	e0 68 06 6c 	mov	r8,1644
80008288:	ea 18 00 00 	orh	r8,0x0
8000828c:	70 00       	ld.w	r0,r8[0x0]
8000828e:	60 0d       	ld.w	sp,r0[0x0]

80008290 <LABEL_ISR_SKIP_RESTORE_CONTEXT_812>:
80008290:	1b 00       	ld.w	r0,sp++
80008292:	e0 68 00 24 	mov	r8,36
80008296:	ea 18 00 00 	orh	r8,0x0
8000829a:	91 00       	st.w	r8[0x0],r0
8000829c:	e3 cd 00 ff 	ldm	sp++,r0-r7
800082a0:	d6 03       	rete
800082a2:	00 00       	add	r0,r0
800082a4:	80 00       	ld.sh	r0,r0[0x0]
800082a6:	81 e4       	st.w	r0[0x38],r4
800082a8:	80 00       	ld.sh	r0,r0[0x0]
800082aa:	6b 68       	ld.w	r8,r5[0x58]
800082ac:	80 00       	ld.sh	r0,r0[0x0]
800082ae:	73 b0       	ld.w	r0,r9[0x6c]
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	6c 74       	ld.w	r4,r6[0x1c]

800082b4 <main>:

	return res;
}

int main (void)
{
800082b4:	eb cd 40 c0 	pushm	r6-r7,lr
800082b8:	21 0d       	sub	sp,64
/*! \brief Static function definitions
 */
static void init_sys_clocks(void)
{
  // Switch to OSC0 to speed up the booting
  pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
800082ba:	30 3a       	mov	r10,3
800082bc:	e0 6b 1b 00 	mov	r11,6912
800082c0:	ea 1b 00 b7 	orh	r11,0xb7
800082c4:	fe 7c 0c 00 	mov	r12,-62464
800082c8:	f0 1f 00 c0 	mcall	800085c8 <main+0x314>

  // Start oscillator1
  pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
800082cc:	e0 6b 44 00 	mov	r11,17408
800082d0:	ea 1b 00 ac 	orh	r11,0xac
800082d4:	fe 7c 0c 00 	mov	r12,-62464
800082d8:	f0 1f 00 bd 	mcall	800085cc <main+0x318>
  pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
800082dc:	30 3b       	mov	r11,3
800082de:	fe 7c 0c 00 	mov	r12,-62464
800082e2:	f0 1f 00 bc 	mcall	800085d0 <main+0x31c>

  // Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
  // We use OSC1 since we need a correct master clock for the SSC module to generate
  //
  pm_pll_setup(&AVR32_PM, 0,  // pll.
800082e6:	31 06       	mov	r6,16
800082e8:	1a d6       	st.w	--sp,r6
800082ea:	30 18       	mov	r8,1
800082ec:	10 99       	mov	r9,r8
800082ee:	30 aa       	mov	r10,10
800082f0:	30 0b       	mov	r11,0
800082f2:	fe 7c 0c 00 	mov	r12,-62464
800082f6:	f0 1f 00 b8 	mcall	800085d4 <main+0x320>
    1,   // osc.
    16); // lockcount.

  // Set PLL operating range and divider (fpll = fvco/2)
  // -> PLL0 output = 62.0928 MHz
  pm_pll_set_option(&AVR32_PM, 0, // pll.
800082fa:	30 08       	mov	r8,0
800082fc:	30 19       	mov	r9,1
800082fe:	12 9a       	mov	r10,r9
80008300:	10 9b       	mov	r11,r8
80008302:	fe 7c 0c 00 	mov	r12,-62464
80008306:	f0 1f 00 b5 	mcall	800085d8 <main+0x324>
    1,  // pll_freq.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL0 and wait for the lock
  pm_pll_enable(&AVR32_PM, 0);
8000830a:	30 0b       	mov	r11,0
8000830c:	fe 7c 0c 00 	mov	r12,-62464
80008310:	f0 1f 00 b3 	mcall	800085dc <main+0x328>
  pm_wait_for_pll0_locked(&AVR32_PM);
80008314:	fe 7c 0c 00 	mov	r12,-62464
80008318:	f0 1f 00 b2 	mcall	800085e0 <main+0x32c>
  // Set all peripheral clocks torun at master clock rate
  pm_cksel(&AVR32_PM,
8000831c:	30 07       	mov	r7,0
8000831e:	1a d7       	st.w	--sp,r7
80008320:	1a d7       	st.w	--sp,r7
80008322:	0e 98       	mov	r8,r7
80008324:	0e 99       	mov	r9,r7
80008326:	0e 9a       	mov	r10,r7
80008328:	0e 9b       	mov	r11,r7
8000832a:	fe 7c 0c 00 	mov	r12,-62464
8000832e:	f0 1f 00 ae 	mcall	800085e4 <main+0x330>
    0,   // pbbsel.
    0,   // hsbdiv.
    0);  // hsbsel.

  // Set one waitstate for the flash
  flashc_set_wait_state(1);
80008332:	30 1c       	mov	r12,1
80008334:	f0 1f 00 ad 	mcall	800085e8 <main+0x334>

  // Switch to PLL0 as the master clock
  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
80008338:	30 2b       	mov	r11,2
8000833a:	fe 7c 0c 00 	mov	r12,-62464
8000833e:	f0 1f 00 ac 	mcall	800085ec <main+0x338>

  // Use 12MHz from OSC0 and generate 96 MHz
  pm_pll_setup(&AVR32_PM, 1,  // pll.
80008342:	1a d6       	st.w	--sp,r6
80008344:	0e 98       	mov	r8,r7
80008346:	30 19       	mov	r9,1
80008348:	30 7a       	mov	r10,7
8000834a:	12 9b       	mov	r11,r9
8000834c:	fe 7c 0c 00 	mov	r12,-62464
80008350:	f0 1f 00 a1 	mcall	800085d4 <main+0x320>
    7,   // mul.
    1,   // div.
    0,   // osc.
    16); // lockcount.

  pm_pll_set_option(&AVR32_PM, 1, // pll.
80008354:	0e 98       	mov	r8,r7
80008356:	30 19       	mov	r9,1
80008358:	12 9a       	mov	r10,r9
8000835a:	12 9b       	mov	r11,r9
8000835c:	fe 7c 0c 00 	mov	r12,-62464
80008360:	f0 1f 00 9e 	mcall	800085d8 <main+0x324>
    1,  // pll_freq: choose the range 80-180MHz.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL1 and wait forl lock
  pm_pll_enable(&AVR32_PM, 1);
80008364:	30 1b       	mov	r11,1
80008366:	fe 7c 0c 00 	mov	r12,-62464
8000836a:	f0 1f 00 9d 	mcall	800085dc <main+0x328>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(&AVR32_PM);
8000836e:	fe 7c 0c 00 	mov	r12,-62464
80008372:	f0 1f 00 a0 	mcall	800085f0 <main+0x33c>
{
	/* Insert system clock initialization code here (sysclk_init()). */
	init_sys_clocks();

	/* Initialize RS232 debug text output. */
	init_dbg_rs232(PBA_HZ); /**/
80008376:	e0 6c 76 00 	mov	r12,30208
8000837a:	ea 1c 03 b3 	orh	r12,0x3b3
8000837e:	f0 1f 00 9e 	mcall	800085f4 <main+0x340>
}

static void init_tft_bl(void)
{
	avr32_pwm_channel_t pwm_channel6;
	pwm_channel6.cdty = 0;
80008382:	50 57       	stdsp	sp[0x14],r7
	pwm_channel6.cprd = 100;
80008384:	36 48       	mov	r8,100
80008386:	50 68       	stdsp	sp[0x18],r8

	et024006_Init(PBA_HZ, PBA_HZ);
80008388:	e0 6b 76 00 	mov	r11,30208
8000838c:	ea 1b 03 b3 	orh	r11,0x3b3
80008390:	16 9c       	mov	r12,r11
80008392:	f0 1f 00 9a 	mcall	800085f8 <main+0x344>

	pwm_opt_t opt;
	opt.diva = 0;
80008396:	51 17       	stdsp	sp[0x44],r7
	opt.divb = 0;
80008398:	51 07       	stdsp	sp[0x40],r7
	opt.prea = 0;
8000839a:	51 37       	stdsp	sp[0x4c],r7
	opt.preb = 0;
8000839c:	51 27       	stdsp	sp[0x48],r7

	pwm_init(&opt);
8000839e:	fa cc ff c0 	sub	r12,sp,-64
800083a2:	f0 1f 00 97 	mcall	800085fc <main+0x348>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
800083a6:	40 48       	lddsp	r8,sp[0x10]
800083a8:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
800083ac:	a9 b8       	sbr	r8,0x9
800083ae:	30 19       	mov	r9,1
800083b0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800083b4:	50 48       	stdsp	sp[0x10],r8

	pwm_channel_init(6, &pwm_channel6);
800083b6:	fa 06 00 0b 	add	r11,sp,r6
800083ba:	30 6c       	mov	r12,6
800083bc:	f0 1f 00 91 	mcall	80008600 <main+0x34c>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
800083c0:	34 0c       	mov	r12,64
800083c2:	f0 1f 00 91 	mcall	80008604 <main+0x350>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
800083c6:	e0 68 ff ff 	mov	r8,65535
800083ca:	e0 69 00 f0 	mov	r9,240
800083ce:	e0 6a 01 40 	mov	r10,320
800083d2:	0e 9b       	mov	r11,r7
800083d4:	0e 9c       	mov	r12,r7
800083d6:	f0 1f 00 8d 	mcall	80008608 <main+0x354>
800083da:	0c 0d       	add	sp,r6
	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
800083dc:	30 67       	mov	r7,6
800083de:	c1 e8       	rjmp	8000841a <main+0x166>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
800083e0:	2f f8       	sub	r8,-1
800083e2:	50 18       	stdsp	sp[0x4],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
800083e4:	50 48       	stdsp	sp[0x10],r8
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
800083e6:	1a 9b       	mov	r11,sp
800083e8:	0e 9c       	mov	r12,r7
800083ea:	f0 1f 00 89 	mcall	8000860c <main+0x358>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800083ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800083f2:	e0 79 d4 c0 	mov	r9,120000
800083f6:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800083fa:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800083fe:	14 38       	cp.w	r8,r10
80008400:	e0 88 00 08 	brls	80008410 <main+0x15c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80008404:	12 38       	cp.w	r8,r9
80008406:	fe 98 ff fa 	brls	800083fa <main+0x146>
8000840a:	12 3a       	cp.w	r10,r9
8000840c:	c0 73       	brcs	8000841a <main+0x166>
8000840e:	cf 6b       	rjmp	800083fa <main+0x146>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80008410:	12 38       	cp.w	r8,r9
80008412:	e0 8b 00 04 	brhi	8000841a <main+0x166>
80008416:	12 3a       	cp.w	r10,r9
80008418:	cf 12       	brcc	800083fa <main+0x146>
	pwm_channel_init(6, &pwm_channel6);
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
8000841a:	40 18       	lddsp	r8,sp[0x4]
8000841c:	40 29       	lddsp	r9,sp[0x8]
8000841e:	12 38       	cp.w	r8,r9
80008420:	ce 03       	brcs	800083e0 <main+0x12c>
	/* TWI */
	const gpio_map_t TPA6130_TWI_GPIO_MAP =
	{
		{TPA6130_TWI_SCL_PIN, TPA6130_TWI_SCL_FUNCTION},
		{TPA6130_TWI_SDA_PIN, TPA6130_TWI_SDA_FUNCTION}
	};
80008422:	4f c8       	lddpc	r8,80008610 <main+0x35c>
80008424:	fa cc ff e0 	sub	r12,sp,-32
80008428:	f0 ea 00 00 	ld.d	r10,r8[0]
8000842c:	f8 eb 00 00 	st.d	r12[0],r10
80008430:	f0 e8 00 08 	ld.d	r8,r8[8]
80008434:	f8 e9 00 08 	st.d	r12[8],r8
	const twi_options_t TPA6130_TWI_OPTIONS =
	{
		.pba_hz = PBA_HZ,
		.speed  = TPA6130_TWI_MASTER_SPEED,
		.chip   = TPA6130_TWI_ADDRESS
	};
80008438:	4f 78       	lddpc	r8,80008614 <main+0x360>
8000843a:	fa c7 ff d0 	sub	r7,sp,-48
8000843e:	f0 ea 00 00 	ld.d	r10,r8[0]
80008442:	ee eb 00 00 	st.d	r7[0],r10
80008446:	70 28       	ld.w	r8,r8[0x8]
80008448:	8f 28       	st.w	r7[0x8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(TPA6130_TWI_GPIO_MAP,
8000844a:	30 2b       	mov	r11,2
8000844c:	f0 1f 00 73 	mcall	80008618 <main+0x364>
	sizeof(TPA6130_TWI_GPIO_MAP) / sizeof(TPA6130_TWI_GPIO_MAP[0]));

	// Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
80008450:	0e 9b       	mov	r11,r7
80008452:	fe 7c 2c 00 	mov	r12,-54272
80008456:	f0 1f 00 72 	mcall	8000861c <main+0x368>

	/* TWA */
	tpa6130_init();
8000845a:	f0 1f 00 72 	mcall	80008620 <main+0x36c>

	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,
8000845e:	e0 68 76 00 	mov	r8,30208
80008462:	ea 18 03 b3 	orh	r8,0x3b3
80008466:	1a d8       	st.w	--sp,r8
80008468:	30 38       	mov	r8,3
8000846a:	1a d8       	st.w	--sp,r8
8000846c:	4e e8       	lddpc	r8,80008624 <main+0x370>
8000846e:	30 09       	mov	r9,0
80008470:	31 0a       	mov	r10,16
80008472:	30 2b       	mov	r11,2
80008474:	e0 6c 2b 11 	mov	r12,11025
80008478:	f0 1f 00 6c 	mcall	80008628 <main+0x374>
						master_callback,
						AUDIO_DAC_OUT_OF_SAMPLE_CB
						| AUDIO_DAC_RELOAD_CB,
						PBA_HZ); /**/

	tpa6130_set_volume(0x35); // 2F
8000847c:	33 5c       	mov	r12,53
8000847e:	f0 1f 00 6c 	mcall	8000862c <main+0x378>
	tpa6130_get_volume();
80008482:	f0 1f 00 6c 	mcall	80008630 <main+0x37c>

	init_tft_bl();

	init_twi_tpa();

	sd_mmc_resources_init();
80008486:	f0 1f 00 6c 	mcall	80008634 <main+0x380>
	check_sd_card();
8000848a:	f0 1f 00 6c 	mcall	80008638 <main+0x384>
	et024006_PrintString("****** INIT SD/MMC ******",(const unsigned char*)&FONT8x8,10,10,BLUE,-1);
8000848e:	3f f8       	mov	r8,-1
80008490:	1a d8       	st.w	--sp,r8
80008492:	31 f8       	mov	r8,31
80008494:	30 a9       	mov	r9,10
80008496:	12 9a       	mov	r10,r9
80008498:	4e 9b       	lddpc	r11,8000863c <main+0x388>
8000849a:	4e ac       	lddpc	r12,80008640 <main+0x38c>
8000849c:	f0 1f 00 6a 	mcall	80008644 <main+0x390>
}

static void init_qt_interrupt(void)
{
	/* INTC */
	Disable_global_interrupt();
800084a0:	d3 03       	ssrf	0x10
	//INTC_init_interrupts();
	// QT
	INTC_register_interrupt(&RT_ISR_gpio_qt_70, 70, AVR32_INTC_INT0);
800084a2:	30 0a       	mov	r10,0
800084a4:	34 6b       	mov	r11,70
800084a6:	4e 9c       	lddpc	r12,80008648 <main+0x394>
800084a8:	f0 1f 00 69 	mcall	8000864c <main+0x398>
	INTC_register_interrupt(&RT_ISR_gpio_qt_71, 71, AVR32_INTC_INT0);
800084ac:	30 0a       	mov	r10,0
800084ae:	34 7b       	mov	r11,71
800084b0:	4e 8c       	lddpc	r12,80008650 <main+0x39c>
800084b2:	f0 1f 00 67 	mcall	8000864c <main+0x398>
	Enable_global_interrupt();
800084b6:	d5 03       	csrf	0x10

	/* GPIO */
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_UP,    GPIO_RISING_EDGE);
800084b8:	30 1b       	mov	r11,1
800084ba:	33 6c       	mov	r12,54
800084bc:	f0 1f 00 66 	mcall	80008654 <main+0x3a0>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_DOWN,  GPIO_RISING_EDGE);
800084c0:	30 1b       	mov	r11,1
800084c2:	33 7c       	mov	r12,55
800084c4:	f0 1f 00 64 	mcall	80008654 <main+0x3a0>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_LEFT,  GPIO_RISING_EDGE);
800084c8:	30 1b       	mov	r11,1
800084ca:	33 9c       	mov	r12,57
800084cc:	f0 1f 00 62 	mcall	80008654 <main+0x3a0>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_RIGHT, GPIO_RISING_EDGE);
800084d0:	30 1b       	mov	r11,1
800084d2:	33 8c       	mov	r12,56
800084d4:	f0 1f 00 60 	mcall	80008654 <main+0x3a0>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_ENTER, GPIO_RISING_EDGE);
800084d8:	30 1b       	mov	r11,1
800084da:	33 ac       	mov	r12,58
800084dc:	f0 1f 00 5e 	mcall	80008654 <main+0x3a0>

	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
800084e0:	30 09       	mov	r9,0
800084e2:	4d e8       	lddpc	r8,80008658 <main+0x3a4>
800084e4:	b0 89       	st.b	r8[0x0],r9
{
	/*Inicialiazamos los archivos de la SD manejada por SPI, para lograr que funcionara tuvo que habilitarla mediante el
	conf_access.h y conf_explorer.h, debido a que por default viene habilitada la memoria incluida en la EVK*/
	
#ifdef FREERTOS_USED
	if (ctrl_access_init())
800084e6:	f0 1f 00 5e 	mcall	8000865c <main+0x3a8>
800084ea:	2f dd       	sub	sp,-12
800084ec:	58 0c       	cp.w	r12,0
800084ee:	c0 40       	breq	800084f6 <main+0x242>
	{
		print_dbg("Access to SD granted.\r\n");
800084f0:	4d cc       	lddpc	r12,80008660 <main+0x3ac>
800084f2:	f0 1f 00 5d 	mcall	80008664 <main+0x3b0>
	}
#endif

	first_ls = true;
800084f6:	30 19       	mov	r9,1
800084f8:	4d c8       	lddpc	r8,80008668 <main+0x3b4>
800084fa:	b0 89       	st.b	r8[0x0],r9
	if (nav_drive_get() >= nav_drive_nb() || first_ls)
800084fc:	f0 1f 00 5c 	mcall	8000866c <main+0x3b8>
80008500:	18 97       	mov	r7,r12
80008502:	f0 1f 00 5c 	mcall	80008670 <main+0x3bc>
80008506:	f8 07 18 00 	cp.b	r7,r12
8000850a:	c0 72       	brcc	80008518 <main+0x264>
8000850c:	4d 78       	lddpc	r8,80008668 <main+0x3b4>
8000850e:	11 89       	ld.ub	r9,r8[0x0]
80008510:	30 08       	mov	r8,0
80008512:	f0 09 18 00 	cp.b	r9,r8
80008516:	c0 e0       	breq	80008532 <main+0x27e>
	{
		first_ls = false;
80008518:	30 09       	mov	r9,0
8000851a:	4d 48       	lddpc	r8,80008668 <main+0x3b4>
8000851c:	b0 89       	st.b	r8[0x0],r9
		// Reset navigators .
		nav_reset();
8000851e:	f0 1f 00 56 	mcall	80008674 <main+0x3c0>
		// Use the last drive available as default.
		nav_drive_set(nav_drive_nb() - 1); // Or sd.drive_number
80008522:	f0 1f 00 54 	mcall	80008670 <main+0x3bc>
80008526:	20 1c       	sub	r12,1
80008528:	5c 5c       	castu.b	r12
8000852a:	f0 1f 00 54 	mcall	80008678 <main+0x3c4>
		//nav_drive_set(nav_drive_nb() - 1);
		// Mount it.
		nav_partition_mount();
8000852e:	f0 1f 00 54 	mcall	8000867c <main+0x3c8>
	}
	nav_dir_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH);
80008532:	31 eb       	mov	r11,30
80008534:	4d 3c       	lddpc	r12,80008680 <main+0x3cc>
80008536:	f0 1f 00 54 	mcall	80008684 <main+0x3d0>
	// Try to sort items by folders
	if (!nav_filelist_first(FS_DIR))
8000853a:	30 0c       	mov	r12,0
8000853c:	f0 1f 00 53 	mcall	80008688 <main+0x3d4>
80008540:	c0 41       	brne	80008548 <main+0x294>
	{
		// Sort items by files
		nav_filelist_first(FS_FILE);
80008542:	30 1c       	mov	r12,1
80008544:	f0 1f 00 51 	mcall	80008688 <main+0x3d4>
	}
	nav_filelist_reset();
80008548:	f0 1f 00 51 	mcall	8000868c <main+0x3d8>
	// Get data
	sd.lun				 = get_nb_lun();				// Read actual LUN
8000854c:	f0 1f 00 51 	mcall	80008690 <main+0x3dc>
80008550:	4d 17       	lddpc	r7,80008694 <main+0x3e0>
80008552:	ae 8c       	st.b	r7[0x0],r12
	sd.drive_name		 = nav_drive_getname();			// Read drive assigned letter
80008554:	f0 1f 00 51 	mcall	80008698 <main+0x3e4>
80008558:	ae 9c       	st.b	r7[0x1],r12
	sd.devices_available = nav_drive_nb();				// Read available devices. Equal to LUN
8000855a:	f0 1f 00 46 	mcall	80008670 <main+0x3bc>
8000855e:	ae ac       	st.b	r7[0x2],r12
	sd.drive_number		 = nav_drive_get();				// Returns nav_drive_nb()-1
80008560:	f0 1f 00 43 	mcall	8000866c <main+0x3b8>
80008564:	ae bc       	st.b	r7[0x3],r12
	sd.number_of_files	 = nav_filelist_nb(FS_FILE);	// Get the number of available files
80008566:	30 1c       	mov	r12,1
80008568:	f0 1f 00 4d 	mcall	8000869c <main+0x3e8>
8000856c:	5c 5c       	castu.b	r12
8000856e:	ae cc       	st.b	r7[0x4],r12
	print_dbg_ulong(sd.number_of_files);
80008570:	f0 1f 00 4c 	mcall	800086a0 <main+0x3ec>
}

static void init_sdram(void)
{
	// Initialize the external SDRAM chip.
	sdramc_init(PBA_HZ);
80008574:	e0 6c 76 00 	mov	r12,30208
80008578:	ea 1c 03 b3 	orh	r12,0x3b3
8000857c:	f0 1f 00 4a 	mcall	800086a4 <main+0x3f0>
	print_dbg("\r\nSDRAM initialized\r\n");
80008580:	4c ac       	lddpc	r12,800086a8 <main+0x3f4>
80008582:	f0 1f 00 39 	mcall	80008664 <main+0x3b0>
	init_fs();
	
	init_sdram();

	// Enable LED0 and LED1
	gpio_enable_gpio_pin(LED0_GPIO);
80008586:	33 bc       	mov	r12,59
80008588:	f0 1f 00 49 	mcall	800086ac <main+0x3f8>
	gpio_enable_gpio_pin(LED1_GPIO);
8000858c:	33 cc       	mov	r12,60
8000858e:	f0 1f 00 48 	mcall	800086ac <main+0x3f8>

	print_dbg(MSG_WELCOME);
80008592:	4c 8c       	lddpc	r12,800086b0 <main+0x3fc>
80008594:	f0 1f 00 34 	mcall	80008664 <main+0x3b0>

	//uint16_t pass = 25;
	//xTaskCreate(myTask1, "taks1", 256, (void *)pass, mainLED_TASK_PRIORITY, &myTask1Handle);
	//xTaskCreate(qtButtonTask,  "tQT",        256,  (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
	//xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
	xTaskCreate(fsTask,		   "tFS",		 1024,  (void *) 0, mainLED_TASK_PRIORITY, &fsHandle);
80008598:	4c 78       	lddpc	r8,800086b4 <main+0x400>
8000859a:	1a d8       	st.w	--sp,r8
8000859c:	30 18       	mov	r8,1
8000859e:	30 09       	mov	r9,0
800085a0:	e0 6a 04 00 	mov	r10,1024
800085a4:	4c 5b       	lddpc	r11,800086b8 <main+0x404>
800085a6:	4c 6c       	lddpc	r12,800086bc <main+0x408>
800085a8:	f0 1f 00 46 	mcall	800086c0 <main+0x40c>
	//xTaskCreate(etTask,		   "tET",		 512,  (void *) 0, mainLED_TASK_PRIORITY, &etHandle);
	xTaskCreate(sdramTask,     "tSDRAM",	 256,  (void *) 0, mainLED_TASK_PRIORITY + 1, &sdramHandle);
800085ac:	4c 68       	lddpc	r8,800086c4 <main+0x410>
800085ae:	1a d8       	st.w	--sp,r8
800085b0:	30 28       	mov	r8,2
800085b2:	30 09       	mov	r9,0
800085b4:	e0 6a 01 00 	mov	r10,256
800085b8:	4c 4b       	lddpc	r11,800086c8 <main+0x414>
800085ba:	4c 5c       	lddpc	r12,800086cc <main+0x418>
800085bc:	f0 1f 00 41 	mcall	800086c0 <main+0x40c>
	
	vTaskStartScheduler();
800085c0:	f0 1f 00 44 	mcall	800086d0 <main+0x41c>
800085c4:	2f ed       	sub	sp,-8
800085c6:	c0 08       	rjmp	800085c6 <main+0x312>
800085c8:	80 00       	ld.sh	r0,r0[0x0]
800085ca:	8f bc       	st.w	r7[0x2c],r12
800085cc:	80 00       	ld.sh	r0,r0[0x0]
800085ce:	8e 98       	ld.uh	r8,r7[0x2]
800085d0:	80 00       	ld.sh	r0,r0[0x0]
800085d2:	8e f0       	ld.uh	r0,r7[0xe]
800085d4:	80 00       	ld.sh	r0,r0[0x0]
800085d6:	8f 52       	st.w	r7[0x14],r2
800085d8:	80 00       	ld.sh	r0,r0[0x0]
800085da:	8f 74       	st.w	r7[0x1c],r4
800085dc:	80 00       	ld.sh	r0,r0[0x0]
800085de:	8f 8e       	st.w	r7[0x20],lr
800085e0:	80 00       	ld.sh	r0,r0[0x0]
800085e2:	8f 9c       	st.w	r7[0x24],r12
800085e4:	80 00       	ld.sh	r0,r0[0x0]
800085e6:	8f 0c       	st.w	r7[0x0],r12
800085e8:	80 00       	ld.sh	r0,r0[0x0]
800085ea:	8b 80       	st.w	r5[0x20],r0
800085ec:	80 00       	ld.sh	r0,r0[0x0]
800085ee:	8f b0       	st.w	r7[0x2c],r0
800085f0:	80 00       	ld.sh	r0,r0[0x0]
800085f2:	8f a6       	st.w	r7[0x28],r6
800085f4:	80 00       	ld.sh	r0,r0[0x0]
800085f6:	68 48       	ld.w	r8,r4[0x10]
800085f8:	80 00       	ld.sh	r0,r0[0x0]
800085fa:	27 b8       	sub	r8,123
800085fc:	80 00       	ld.sh	r0,r0[0x0]
800085fe:	40 40       	lddsp	r0,sp[0x10]
80008600:	80 00       	ld.sh	r0,r0[0x0]
80008602:	3f d0       	mov	r0,-3
80008604:	80 00       	ld.sh	r0,r0[0x0]
80008606:	40 06       	lddsp	r6,sp[0x0]
80008608:	80 00       	ld.sh	r0,r0[0x0]
8000860a:	27 08       	sub	r8,112
8000860c:	80 00       	ld.sh	r0,r0[0x0]
8000860e:	40 18       	lddsp	r8,sp[0x4]
80008610:	80 00       	ld.sh	r0,r0[0x0]
80008612:	aa 48       	st.h	r5[0x8],r8
80008614:	80 00       	ld.sh	r0,r0[0x0]
80008616:	a8 2c       	st.h	r4[0x4],r12
80008618:	80 00       	ld.sh	r0,r0[0x0]
8000861a:	8b e0       	st.w	r5[0x38],r0
8000861c:	80 00       	ld.sh	r0,r0[0x0]
8000861e:	45 60       	lddsp	r0,sp[0x158]
80008620:	80 00       	ld.sh	r0,r0[0x0]
80008622:	22 a0       	sub	r0,42
80008624:	80 00       	ld.sh	r0,r0[0x0]
80008626:	80 f4       	ld.uh	r4,r0[0xe]
80008628:	80 00       	ld.sh	r0,r0[0x0]
8000862a:	23 88       	sub	r8,56
8000862c:	80 00       	ld.sh	r0,r0[0x0]
8000862e:	21 8c       	sub	r12,24
80008630:	80 00       	ld.sh	r0,r0[0x0]
80008632:	22 08       	sub	r8,32
80008634:	80 00       	ld.sh	r0,r0[0x0]
80008636:	80 70       	ld.sh	r0,r0[0xe]
80008638:	80 00       	ld.sh	r0,r0[0x0]
8000863a:	80 08       	ld.sh	r8,r0[0x0]
8000863c:	80 00       	ld.sh	r0,r0[0x0]
8000863e:	a2 50       	st.h	r1[0xa],r0
80008640:	80 00       	ld.sh	r0,r0[0x0]
80008642:	a8 38       	st.h	r4[0x6],r8
80008644:	80 00       	ld.sh	r0,r0[0x0]
80008646:	24 8c       	sub	r12,72
80008648:	80 00       	ld.sh	r0,r0[0x0]
8000864a:	82 3c       	ld.sh	r12,r1[0x6]
8000864c:	80 00       	ld.sh	r0,r0[0x0]
8000864e:	8d 00       	st.w	r6[0x0],r0
80008650:	80 00       	ld.sh	r0,r0[0x0]
80008652:	81 6c       	st.w	r0[0x18],r12
80008654:	80 00       	ld.sh	r0,r0[0x0]
80008656:	8c 88       	ld.uh	r8,r6[0x0]
80008658:	00 00       	add	r0,r0
8000865a:	0d e0       	ld.ub	r0,r6[0x6]
8000865c:	80 00       	ld.sh	r0,r0[0x0]
8000865e:	6a 0c       	ld.w	r12,r5[0x0]
80008660:	80 00       	ld.sh	r0,r0[0x0]
80008662:	a8 54       	st.h	r4[0xa],r4
80008664:	80 00       	ld.sh	r0,r0[0x0]
80008666:	67 f4       	ld.w	r4,r3[0x7c]
80008668:	00 00       	add	r0,r0
8000866a:	06 f4       	st.b	--r3,r4
8000866c:	80 00       	ld.sh	r0,r0[0x0]
8000866e:	5e 88       	retls	r8
80008670:	80 00       	ld.sh	r0,r0[0x0]
80008672:	64 e4       	ld.w	r4,r2[0x38]
80008674:	80 00       	ld.sh	r0,r0[0x0]
80008676:	65 60       	ld.w	r0,r2[0x58]
80008678:	80 00       	ld.sh	r0,r0[0x0]
8000867a:	64 90       	ld.w	r0,r2[0x24]
8000867c:	80 00       	ld.sh	r0,r0[0x0]
8000867e:	64 48       	ld.w	r8,r2[0x10]
80008680:	00 00       	add	r0,r0
80008682:	06 fc       	st.b	--r3,r12
80008684:	80 00       	ld.sh	r0,r0[0x0]
80008686:	62 08       	ld.w	r8,r1[0x0]
80008688:	80 00       	ld.sh	r0,r0[0x0]
8000868a:	63 0c       	ld.w	r12,r1[0x40]
8000868c:	80 00       	ld.sh	r0,r0[0x0]
8000868e:	61 50       	ld.w	r0,r0[0x54]
80008690:	80 00       	ld.sh	r0,r0[0x0]
80008692:	68 5c       	ld.w	r12,r4[0x14]
80008694:	00 00       	add	r0,r0
80008696:	07 20       	ld.uh	r0,r3++
80008698:	80 00       	ld.sh	r0,r0[0x0]
8000869a:	5e 94       	retgt	r4
8000869c:	80 00       	ld.sh	r0,r0[0x0]
8000869e:	63 4c       	ld.w	r12,r1[0x50]
800086a0:	80 00       	ld.sh	r0,r0[0x0]
800086a2:	67 e0       	ld.w	r0,r3[0x78]
800086a4:	80 00       	ld.sh	r0,r0[0x0]
800086a6:	3c 54       	mov	r4,-59
800086a8:	80 00       	ld.sh	r0,r0[0x0]
800086aa:	a8 6c       	st.h	r4[0xc],r12
800086ac:	80 00       	ld.sh	r0,r0[0x0]
800086ae:	8c 10       	ld.sh	r0,r6[0x2]
800086b0:	80 00       	ld.sh	r0,r0[0x0]
800086b2:	a8 84       	st.b	r4[0x0],r4
800086b4:	00 00       	add	r0,r0
800086b6:	07 1c       	ld.sh	r12,r3++
800086b8:	80 00       	ld.sh	r0,r0[0x0]
800086ba:	a8 c0       	st.b	r4[0x4],r0
800086bc:	80 00       	ld.sh	r0,r0[0x0]
800086be:	87 e0       	st.w	r3[0x38],r0
800086c0:	80 00       	ld.sh	r0,r0[0x0]
800086c2:	7d bc       	ld.w	r12,lr[0x6c]
800086c4:	00 00       	add	r0,r0
800086c6:	06 f8       	st.b	--r3,r8
800086c8:	80 00       	ld.sh	r0,r0[0x0]
800086ca:	a8 c4       	st.b	r4[0x4],r4
800086cc:	80 00       	ld.sh	r0,r0[0x0]
800086ce:	86 d4       	ld.uh	r4,r3[0xa]
800086d0:	80 00       	ld.sh	r0,r0[0x0]
800086d2:	7f a8       	ld.w	r8,pc[0x68]

800086d4 <sdramTask>:
}

// sdramHandle
portTASK_FUNCTION_PROTO( sdramTask, p );
portTASK_FUNCTION( sdramTask, p )
{
800086d4:	d4 31       	pushm	r0-r7,lr
800086d6:	20 2d       	sub	sp,8
	
	//sdram_udata_t exram;
	//unsigned long sdram_size, progress_inc, i, j, noErrors = 0;
	unsigned long sdram_size = 0;
	uint32_t samples_collected = 0; // For SDRAM, sample times 4 will give the real number of song samples
	unsigned long sample = 0;
800086d8:	30 03       	mov	r3,0
800086da:	fa c5 ff f8 	sub	r5,sp,-8
800086de:	0a d3       	st.w	--r5,r3
	
	// Calculate SDRAM size in words (32 bits).
	sdram_size = SDRAM_SIZE >> 2;
	print_dbg("\x0CSDRAM size: ");
800086e0:	4b 3c       	lddpc	r12,800087ac <sdramTask+0xd8>
800086e2:	f0 1f 00 34 	mcall	800087b0 <sdramTask+0xdc>
	print_dbg_ulong(SDRAM_SIZE >> 20);
800086e6:	32 0c       	mov	r12,32
800086e8:	f0 1f 00 33 	mcall	800087b4 <sdramTask+0xe0>
	print_dbg(" MB\r\n");
800086ec:	4b 3c       	lddpc	r12,800087b8 <sdramTask+0xe4>
800086ee:	f0 1f 00 31 	mcall	800087b0 <sdramTask+0xdc>
		//vTaskDelay(pdMS_TO_TICKS(1000));
	//
		//}
	//}

	print_dbg("Suspending task");
800086f2:	4b 3c       	lddpc	r12,800087bc <sdramTask+0xe8>
800086f4:	f0 1f 00 2f 	mcall	800087b0 <sdramTask+0xdc>
	xTaskNotifyGive(fsHandle);
800086f8:	06 98       	mov	r8,r3
800086fa:	30 29       	mov	r9,2
800086fc:	06 9a       	mov	r10,r3
800086fe:	06 9b       	mov	r11,r3
80008700:	4b 0c       	lddpc	r12,800087c0 <sdramTask+0xec>
80008702:	78 0c       	ld.w	r12,r12[0x0]
80008704:	f0 1f 00 30 	mcall	800087c4 <sdramTask+0xf0>
	vTaskSuspend(NULL);
80008708:	06 9c       	mov	r12,r3
8000870a:	f0 1f 00 30 	mcall	800087c8 <sdramTask+0xf4>
8000870e:	fc 10 d0 00 	movh	r0,0xd000
	
	while(1)
	{
		if (sdramQueue != 0)
80008712:	4a f4       	lddpc	r4,800087cc <sdramTask+0xf8>
		{
			if (xQueueReceive( sdramQueue, &sample, (TickType_t) 2 ))
80008714:	30 26       	mov	r6,2
			{
				print_dbg("SDRAM QUEUE Received\r\n");
				print_dbg_ulong(sample);
				print_dbg("\r\n");
80008716:	4a f2       	lddpc	r2,800087d0 <sdramTask+0xfc>
				sdram[samples_collected++] = sample;
				print_dbg_ulong(samples_collected);
				if (samples_collected > 15)
				{
					vTaskSuspend(fsHandle);
					for (uint8_t i = 0; i < samples_collected; i++)
80008718:	50 03       	stdsp	sp[0x0],r3
8000871a:	c0 28       	rjmp	8000871e <sdramTask+0x4a>
		//}
	//}

	print_dbg("Suspending task");
	xTaskNotifyGive(fsHandle);
	vTaskSuspend(NULL);
8000871c:	2f c0       	sub	r0,-4
	
	while(1)
	{
		if (sdramQueue != 0)
8000871e:	68 0c       	ld.w	r12,r4[0x0]
80008720:	58 0c       	cp.w	r12,0
80008722:	c4 40       	breq	800087aa <sdramTask+0xd6>
		{
			if (xQueueReceive( sdramQueue, &sample, (TickType_t) 2 ))
80008724:	0c 9a       	mov	r10,r6
80008726:	0a 9b       	mov	r11,r5
80008728:	f0 1f 00 2b 	mcall	800087d4 <sdramTask+0x100>
8000872c:	cf 90       	breq	8000871e <sdramTask+0x4a>
			{
				print_dbg("SDRAM QUEUE Received\r\n");
8000872e:	4a bc       	lddpc	r12,800087d8 <sdramTask+0x104>
80008730:	f0 1f 00 20 	mcall	800087b0 <sdramTask+0xdc>
				print_dbg_ulong(sample);
80008734:	40 1c       	lddsp	r12,sp[0x4]
80008736:	f0 1f 00 20 	mcall	800087b4 <sdramTask+0xe0>
				print_dbg("\r\n");
8000873a:	04 9c       	mov	r12,r2
8000873c:	f0 1f 00 1d 	mcall	800087b0 <sdramTask+0xdc>
				sdram[samples_collected++] = sample;
80008740:	40 18       	lddsp	r8,sp[0x4]
80008742:	81 08       	st.w	r0[0x0],r8
80008744:	2f f3       	sub	r3,-1
				print_dbg_ulong(samples_collected);
80008746:	06 9c       	mov	r12,r3
80008748:	f0 1f 00 1b 	mcall	800087b4 <sdramTask+0xe0>
				if (samples_collected > 15)
8000874c:	58 f3       	cp.w	r3,15
8000874e:	e0 88 00 22 	brls	80008792 <sdramTask+0xbe>
				{
					vTaskSuspend(fsHandle);
80008752:	49 c8       	lddpc	r8,800087c0 <sdramTask+0xec>
80008754:	70 0c       	ld.w	r12,r8[0x0]
80008756:	f0 1f 00 1d 	mcall	800087c8 <sdramTask+0xf4>
					for (uint8_t i = 0; i < samples_collected; i++)
8000875a:	58 03       	cp.w	r3,0
8000875c:	c1 70       	breq	8000878a <sdramTask+0xb6>
8000875e:	30 08       	mov	r8,0
80008760:	40 07       	lddsp	r7,sp[0x0]
					{
						print_dbg_ulong(sdram[i]);
						print_dbg("\r\n");
						vTaskDelay(pdMS_TO_TICKS(1000));
80008762:	e0 61 03 e8 	mov	r1,1000
				if (samples_collected > 15)
				{
					vTaskSuspend(fsHandle);
					for (uint8_t i = 0; i < samples_collected; i++)
					{
						print_dbg_ulong(sdram[i]);
80008766:	fc 19 d0 00 	movh	r9,0xd000
8000876a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
8000876e:	f0 1f 00 12 	mcall	800087b4 <sdramTask+0xe0>
						print_dbg("\r\n");
80008772:	04 9c       	mov	r12,r2
80008774:	f0 1f 00 0f 	mcall	800087b0 <sdramTask+0xdc>
						vTaskDelay(pdMS_TO_TICKS(1000));
80008778:	02 9c       	mov	r12,r1
8000877a:	f0 1f 00 19 	mcall	800087dc <sdramTask+0x108>
				sdram[samples_collected++] = sample;
				print_dbg_ulong(samples_collected);
				if (samples_collected > 15)
				{
					vTaskSuspend(fsHandle);
					for (uint8_t i = 0; i < samples_collected; i++)
8000877e:	2f f7       	sub	r7,-1
80008780:	5c 57       	castu.b	r7
80008782:	0e 98       	mov	r8,r7
80008784:	0e 33       	cp.w	r3,r7
80008786:	fe 9b ff f0 	brhi	80008766 <sdramTask+0x92>
					{
						print_dbg_ulong(sdram[i]);
						print_dbg("\r\n");
						vTaskDelay(pdMS_TO_TICKS(1000));
					}
					vTaskSuspend(NULL);
8000878a:	30 0c       	mov	r12,0
8000878c:	f0 1f 00 0f 	mcall	800087c8 <sdramTask+0xf4>
80008790:	cc 6b       	rjmp	8000871c <sdramTask+0x48>
				}
				else
				{
					xTaskNotifyGive(fsHandle);
80008792:	30 08       	mov	r8,0
80008794:	0c 99       	mov	r9,r6
80008796:	10 9a       	mov	r10,r8
80008798:	10 9b       	mov	r11,r8
8000879a:	48 ac       	lddpc	r12,800087c0 <sdramTask+0xec>
8000879c:	78 0c       	ld.w	r12,r12[0x0]
8000879e:	f0 1f 00 0a 	mcall	800087c4 <sdramTask+0xf0>
					vTaskSuspend(NULL);
800087a2:	30 0c       	mov	r12,0
800087a4:	f0 1f 00 09 	mcall	800087c8 <sdramTask+0xf4>
800087a8:	cb ab       	rjmp	8000871c <sdramTask+0x48>
800087aa:	c0 08       	rjmp	800087aa <sdramTask+0xd6>
800087ac:	80 00       	ld.sh	r0,r0[0x0]
800087ae:	a8 cc       	st.b	r4[0x4],r12
800087b0:	80 00       	ld.sh	r0,r0[0x0]
800087b2:	67 f4       	ld.w	r4,r3[0x7c]
800087b4:	80 00       	ld.sh	r0,r0[0x0]
800087b6:	67 e0       	ld.w	r0,r3[0x78]
800087b8:	80 00       	ld.sh	r0,r0[0x0]
800087ba:	a8 dc       	st.b	r4[0x5],r12
800087bc:	80 00       	ld.sh	r0,r0[0x0]
800087be:	a8 e4       	st.b	r4[0x6],r4
800087c0:	00 00       	add	r0,r0
800087c2:	07 1c       	ld.sh	r12,r3++
800087c4:	80 00       	ld.sh	r0,r0[0x0]
800087c6:	74 fc       	ld.w	r12,r10[0x3c]
800087c8:	80 00       	ld.sh	r0,r0[0x0]
800087ca:	7a f8       	ld.w	r8,sp[0x3c]
800087cc:	00 00       	add	r0,r0
800087ce:	0d e8       	ld.ub	r8,r6[0x6]
800087d0:	80 00       	ld.sh	r0,r0[0x0]
800087d2:	a9 08       	ld.d	r8,r4
800087d4:	80 00       	ld.sh	r0,r0[0x0]
800087d6:	6e bc       	ld.w	r12,r7[0x2c]
800087d8:	80 00       	ld.sh	r0,r0[0x0]
800087da:	a8 f4       	st.b	r4[0x7],r4
800087dc:	80 00       	ld.sh	r0,r0[0x0]
800087de:	7c e0       	ld.w	r0,lr[0x38]

800087e0 <fsTask>:
}

// fsHandle
portTASK_FUNCTION_PROTO( fsTask, p );
portTASK_FUNCTION( fsTask, p )
{
800087e0:	d4 31       	pushm	r0-r7,lr
800087e2:	20 5d       	sub	sp,20
	sdramQueue = xQueueCreate( 1 , sizeof(unsigned long));
800087e4:	30 0a       	mov	r10,0
800087e6:	30 4b       	mov	r11,4
800087e8:	30 1c       	mov	r12,1
800087ea:	f0 1f 00 95 	mcall	80008a3c <fsTask+0x25c>
800087ee:	fe f8 02 52 	ld.w	r8,pc[594]
800087f2:	91 0c       	st.w	r8[0x0],r12
	
	nav_filelist_reset();
800087f4:	f0 1f 00 94 	mcall	80008a44 <fsTask+0x264>
	nav_filelist_goto( 0 );
800087f8:	30 0c       	mov	r12,0
800087fa:	f0 1f 00 94 	mcall	80008a48 <fsTask+0x268>
	uint8_t files = 0;
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
800087fe:	fe f8 02 4e 	ld.w	r8,pc[590]
80008802:	11 c9       	ld.ub	r9,r8[0x4]
80008804:	30 08       	mov	r8,0
80008806:	f0 09 18 00 	cp.b	r9,r8
8000880a:	c2 40       	breq	80008852 <fsTask+0x72>
8000880c:	fe f6 02 40 	ld.w	r6,pc[576]
80008810:	2f 86       	sub	r6,-8
80008812:	30 07       	mov	r7,0
	{
		nav_filelist_set(sd.drive_number, FS_FIND_NEXT);
80008814:	fe f5 02 38 	ld.w	r5,pc[568]
80008818:	30 14       	mov	r4,1
		nav_file_getname(sd.name_of_files[i], 30);
8000881a:	31 e3       	mov	r3,30
		print_dbg(sd.name_of_files[i]);
		print_dbg("\r\n");
8000881c:	fe f2 02 34 	ld.w	r2,pc[564]
	nav_filelist_goto( 0 );
	uint8_t files = 0;
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
	{
		nav_filelist_set(sd.drive_number, FS_FIND_NEXT);
80008820:	08 9b       	mov	r11,r4
80008822:	0b bc       	ld.ub	r12,r5[0x3]
80008824:	f0 1f 00 8c 	mcall	80008a54 <fsTask+0x274>
		nav_file_getname(sd.name_of_files[i], 30);
80008828:	06 9b       	mov	r11,r3
8000882a:	6c 0c       	ld.w	r12,r6[0x0]
8000882c:	f0 1f 00 8b 	mcall	80008a58 <fsTask+0x278>
		print_dbg(sd.name_of_files[i]);
80008830:	0d 0c       	ld.w	r12,r6++
80008832:	f0 1f 00 8b 	mcall	80008a5c <fsTask+0x27c>
		print_dbg("\r\n");
80008836:	04 9c       	mov	r12,r2
80008838:	f0 1f 00 89 	mcall	80008a5c <fsTask+0x27c>
8000883c:	0e 99       	mov	r9,r7
8000883e:	2f f9       	sub	r9,-1
80008840:	5c 59       	castu.b	r9
	
	nav_filelist_reset();
	nav_filelist_goto( 0 );
	uint8_t files = 0;
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
80008842:	2f f7       	sub	r7,-1
80008844:	0b c8       	ld.ub	r8,r5[0x4]
80008846:	0e 38       	cp.w	r8,r7
80008848:	fe 9b ff ec 	brhi	80008820 <fsTask+0x40>
		print_dbg(sd.name_of_files[i]);
		print_dbg("\r\n");
		files++;
		//vTaskDelay(pdMS_TO_TICKS(100));
	}
	if (files == sd.number_of_files)
8000884c:	f0 09 18 00 	cp.b	r9,r8
80008850:	c0 51       	brne	8000885a <fsTask+0x7a>
	{
		print_dbg("Number of files coincide.\r\n");
80008852:	fe fc 02 0e 	ld.w	r12,pc[526]
80008856:	f0 1f 00 82 	mcall	80008a5c <fsTask+0x27c>
	uint8_t word_complete = 0;

	sdram_udata_t data_sd;
	portBASE_TYPE notificationValue = 0;

	nav_filelist_reset();
8000885a:	f0 1f 00 7b 	mcall	80008a44 <fsTask+0x264>
	nav_filterlist_setfilter("h");
8000885e:	fe fc 02 06 	ld.w	r12,pc[518]
80008862:	f0 1f 00 82 	mcall	80008a68 <fsTask+0x288>
	nav_filterlist_root();
80008866:	f0 1f 00 82 	mcall	80008a6c <fsTask+0x28c>
	nav_filterlist_goto( 0 );
8000886a:	30 0c       	mov	r12,0
8000886c:	f0 1f 00 81 	mcall	80008a70 <fsTask+0x290>
80008870:	30 00       	mov	r0,0
80008872:	50 00       	stdsp	sp[0x0],r0
			// Search for size fist, by looking for '[' and ']'
			if (current_char == '[')
			{
				char size_of_song[9] = "";
				current_char = file_getc();
				while( current_char != ']' ){
80008874:	35 d6       	mov	r6,93
	//return x;
	
	unsigned long result = 0;
	const char *c = s;

	while ('0' <= *c && *c <= '9') {
80008876:	30 95       	mov	r5,9

	nav_filelist_reset();
	nav_filterlist_setfilter("h");
	nav_filterlist_root();
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
80008878:	cd 48       	rjmp	80008a20 <fsTask+0x240>
	{
		print_dbg("\r\n Archivo Encontrado\r");
8000887a:	4f fc       	lddpc	r12,80008a74 <fsTask+0x294>
8000887c:	f0 1f 00 78 	mcall	80008a5c <fsTask+0x27c>
		file_open(FOPEN_MODE_R);
80008880:	30 9c       	mov	r12,9
80008882:	f0 1f 00 7e 	mcall	80008a78 <fsTask+0x298>
		while (!file_eof())							//Hasta encontrar el fin del archivo
		{
			char current_char = file_getc();
			print_dbg_char(current_char);
			// Search for size fist, by looking for '[' and ']'
			if (current_char == '[')
80008886:	35 b2       	mov	r2,91
				size_in_bytes = a2ul(size_of_song);
				print_dbg("\r\nSize of song in bytes:");
				print_dbg_ulong(size_in_bytes);
				print_dbg("\r\n");
			}
			else if (current_char == '0')
80008888:	33 01       	mov	r1,48
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
	{
		print_dbg("\r\n Archivo Encontrado\r");
		file_open(FOPEN_MODE_R);
		while (!file_eof())							//Hasta encontrar el fin del archivo
8000888a:	cb f8       	rjmp	80008a08 <fsTask+0x228>
		{
			char current_char = file_getc();
8000888c:	f0 1f 00 7c 	mcall	80008a7c <fsTask+0x29c>
80008890:	5c 5c       	castu.b	r12
80008892:	fb 6c 00 0f 	st.b	sp[15],r12
			print_dbg_char(current_char);
80008896:	f0 1f 00 7b 	mcall	80008a80 <fsTask+0x2a0>
			// Search for size fist, by looking for '[' and ']'
			if (current_char == '[')
8000889a:	fb 38 00 0f 	ld.ub	r8,sp[15]
8000889e:	e4 08 18 00 	cp.b	r8,r2
800088a2:	c4 41       	brne	8000892a <fsTask+0x14a>
			{
				char size_of_song[9] = "";
800088a4:	30 08       	mov	r8,0
800088a6:	30 09       	mov	r9,0
800088a8:	fa e9 00 04 	st.d	sp[4],r8
800088ac:	30 08       	mov	r8,0
800088ae:	fb 68 00 0c 	st.b	sp[12],r8
				current_char = file_getc();
800088b2:	f0 1f 00 73 	mcall	80008a7c <fsTask+0x29c>
800088b6:	fb 6c 00 0f 	st.b	sp[15],r12
				while( current_char != ']' ){
800088ba:	ec 0c 18 00 	cp.b	r12,r6
800088be:	c1 20       	breq	800088e2 <fsTask+0x102>
					strncat(size_of_song, &current_char, 1);
800088c0:	fa c7 ff f1 	sub	r7,sp,-15
800088c4:	fa c4 ff fc 	sub	r4,sp,-4
800088c8:	30 13       	mov	r3,1
800088ca:	06 9a       	mov	r10,r3
800088cc:	0e 9b       	mov	r11,r7
800088ce:	08 9c       	mov	r12,r4
800088d0:	f0 1f 00 6d 	mcall	80008a84 <fsTask+0x2a4>
					current_char = file_getc();
800088d4:	f0 1f 00 6a 	mcall	80008a7c <fsTask+0x29c>
800088d8:	fb 6c 00 0f 	st.b	sp[15],r12
			// Search for size fist, by looking for '[' and ']'
			if (current_char == '[')
			{
				char size_of_song[9] = "";
				current_char = file_getc();
				while( current_char != ']' ){
800088dc:	ec 0c 18 00 	cp.b	r12,r6
800088e0:	cf 51       	brne	800088ca <fsTask+0xea>
	//return x;
	
	unsigned long result = 0;
	const char *c = s;

	while ('0' <= *c && *c <= '9') {
800088e2:	1b c8       	ld.ub	r8,sp[0x4]
800088e4:	f0 c9 00 30 	sub	r9,r8,48
800088e8:	ea 09 18 00 	cp.b	r9,r5
800088ec:	e0 88 00 04 	brls	800088f4 <fsTask+0x114>
800088f0:	30 07       	mov	r7,0
800088f2:	c1 28       	rjmp	80008916 <fsTask+0x136>
800088f4:	fa c9 ff fc 	sub	r9,sp,-4
800088f8:	30 07       	mov	r7,0
		result = result * 10 + (*(c++) - '0');
800088fa:	ee 07 00 27 	add	r7,r7,r7<<0x2
800088fe:	f0 07 00 18 	add	r8,r8,r7<<0x1
80008902:	f0 c7 00 30 	sub	r7,r8,48
80008906:	2f f9       	sub	r9,-1
	//return x;
	
	unsigned long result = 0;
	const char *c = s;

	while ('0' <= *c && *c <= '9') {
80008908:	13 88       	ld.ub	r8,r9[0x0]
8000890a:	f0 ca 00 30 	sub	r10,r8,48
8000890e:	ea 0a 18 00 	cp.b	r10,r5
80008912:	fe 98 ff f4 	brls	800088fa <fsTask+0x11a>
				while( current_char != ']' ){
					strncat(size_of_song, &current_char, 1);
					current_char = file_getc();
				}
				size_in_bytes = a2ul(size_of_song);
				print_dbg("\r\nSize of song in bytes:");
80008916:	4d dc       	lddpc	r12,80008a88 <fsTask+0x2a8>
80008918:	f0 1f 00 51 	mcall	80008a5c <fsTask+0x27c>
				print_dbg_ulong(size_in_bytes);
8000891c:	0e 9c       	mov	r12,r7
8000891e:	f0 1f 00 5c 	mcall	80008a8c <fsTask+0x2ac>
				print_dbg("\r\n");
80008922:	4c cc       	lddpc	r12,80008a50 <fsTask+0x270>
80008924:	f0 1f 00 4e 	mcall	80008a5c <fsTask+0x27c>
80008928:	c6 d8       	rjmp	80008a02 <fsTask+0x222>
			}
			else if (current_char == '0')
8000892a:	e2 08 18 00 	cp.b	r8,r1
8000892e:	c6 a1       	brne	80008a02 <fsTask+0x222>
			{
				char hex_byte[] = "";
80008930:	4d 8a       	lddpc	r10,80008a90 <fsTask+0x2b0>
80008932:	15 88       	ld.ub	r8,r10[0x0]
80008934:	ba c8       	st.b	sp[0x4],r8
				strncat(hex_byte, &current_char, 1);
80008936:	30 1a       	mov	r10,1
80008938:	fa cb ff f1 	sub	r11,sp,-15
8000893c:	fa cc ff fc 	sub	r12,sp,-4
80008940:	f0 1f 00 51 	mcall	80008a84 <fsTask+0x2a4>
80008944:	30 07       	mov	r7,0
				for (uint8_t i = 0; i < 3; i++)
				{
					current_char = file_getc();
					strncat(hex_byte, &current_char, 1);
80008946:	fa c4 ff f1 	sub	r4,sp,-15
8000894a:	fa c3 ff fc 	sub	r3,sp,-4
			{
				char hex_byte[] = "";
				strncat(hex_byte, &current_char, 1);
				for (uint8_t i = 0; i < 3; i++)
				{
					current_char = file_getc();
8000894e:	f0 1f 00 4c 	mcall	80008a7c <fsTask+0x29c>
80008952:	fb 6c 00 0f 	st.b	sp[15],r12
					strncat(hex_byte, &current_char, 1);
80008956:	30 1a       	mov	r10,1
80008958:	08 9b       	mov	r11,r4
8000895a:	06 9c       	mov	r12,r3
8000895c:	f0 1f 00 4a 	mcall	80008a84 <fsTask+0x2a4>
			}
			else if (current_char == '0')
			{
				char hex_byte[] = "";
				strncat(hex_byte, &current_char, 1);
				for (uint8_t i = 0; i < 3; i++)
80008960:	2f f7       	sub	r7,-1
80008962:	5c 57       	castu.b	r7
80008964:	30 38       	mov	r8,3
80008966:	f0 07 18 00 	cp.b	r7,r8
8000896a:	cf 21       	brne	8000894e <fsTask+0x16e>
static uint8_t x2u8(const char *str)
{
	uint8_t res = 0; // uint64_t
	char c;

	while ((c = *str++)) {
8000896c:	1b c8       	ld.ub	r8,sp[0x4]
8000896e:	58 08       	cp.w	r8,0
80008970:	c0 31       	brne	80008976 <fsTask+0x196>
80008972:	30 09       	mov	r9,0
80008974:	c1 68       	rjmp	800089a0 <fsTask+0x1c0>
80008976:	fa ca ff fb 	sub	r10,sp,-5
8000897a:	30 09       	mov	r9,0
		char v = ((c & 0xF) + (c >> 6)) | ((c >> 3) & 0x8);
		res = ((res << 4) | (uint8_t) v);
8000897c:	f0 0b 16 03 	lsr	r11,r8,0x3
80008980:	f0 0c 16 06 	lsr	r12,r8,0x6
80008984:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80008988:	f8 08 00 08 	add	r8,r12,r8
8000898c:	e2 1b 00 08 	andl	r11,0x8,COH
80008990:	f7 e8 10 08 	or	r8,r11,r8
80008994:	f1 e9 10 49 	or	r9,r8,r9<<0x4
80008998:	5c 59       	castu.b	r9
static uint8_t x2u8(const char *str)
{
	uint8_t res = 0; // uint64_t
	char c;

	while ((c = *str++)) {
8000899a:	15 38       	ld.ub	r8,r10++
8000899c:	58 08       	cp.w	r8,0
8000899e:	ce f1       	brne	8000897c <fsTask+0x19c>
				//uint8_t data_byte = strtol(hex_byte, NULL, 0);
				//uint8_t data_byte;
				//sscanf(hex_byte, "%x", &data_byte);
				uint8_t data_byte = x2u8(hex_byte);
				// SDRAM
				data_sd.byte[word_complete] = data_byte;
800089a0:	fa c8 ff ec 	sub	r8,sp,-20
800089a4:	40 0a       	lddsp	r10,sp[0x0]
800089a6:	14 08       	add	r8,r10
800089a8:	f1 69 ff fc 	st.b	r8[-4],r9
				word_complete++;
800089ac:	14 94       	mov	r4,r10
800089ae:	2f f4       	sub	r4,-1
800089b0:	5c 54       	castu.b	r4
800089b2:	50 04       	stdsp	sp[0x0],r4
			
				if (word_complete == 4)
800089b4:	30 48       	mov	r8,4
800089b6:	f0 04 18 00 	cp.b	r4,r8
800089ba:	c2 41       	brne	80008a02 <fsTask+0x222>
				{
					while(!(notificationValue > 0))
800089bc:	58 00       	cp.w	r0,0
800089be:	e0 89 00 0c 	brgt	800089d6 <fsTask+0x1f6>
					{
						notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
800089c2:	30 17       	mov	r7,1
800089c4:	30 04       	mov	r4,0
800089c6:	0e 9a       	mov	r10,r7
800089c8:	0e 9b       	mov	r11,r7
800089ca:	08 9c       	mov	r12,r4
800089cc:	f0 1f 00 32 	mcall	80008a94 <fsTask+0x2b4>
				data_sd.byte[word_complete] = data_byte;
				word_complete++;
			
				if (word_complete == 4)
				{
					while(!(notificationValue > 0))
800089d0:	fe 9a ff fb 	brle	800089c6 <fsTask+0x1e6>
800089d4:	18 90       	mov	r0,r12
					{
						notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
					}
					print_dbg("Here\r\n");
800089d6:	4b 1c       	lddpc	r12,80008a98 <fsTask+0x2b8>
800089d8:	f0 1f 00 21 	mcall	80008a5c <fsTask+0x27c>
					word_complete = 0;
					
					xQueueSend( sdramQueue , &data_sd.word, (TickType_t) 1);
800089dc:	fa c7 ff f0 	sub	r7,sp,-16
800089e0:	30 09       	mov	r9,0
800089e2:	30 1a       	mov	r10,1
800089e4:	0e 9b       	mov	r11,r7
800089e6:	49 78       	lddpc	r8,80008a40 <fsTask+0x260>
800089e8:	70 0c       	ld.w	r12,r8[0x0]
800089ea:	f0 1f 00 2d 	mcall	80008a9c <fsTask+0x2bc>
					vTaskResume(sdramHandle);
800089ee:	4a d8       	lddpc	r8,80008aa0 <fsTask+0x2c0>
800089f0:	70 0c       	ld.w	r12,r8[0x0]
800089f2:	f0 1f 00 2d 	mcall	80008aa4 <fsTask+0x2c4>
					//vTaskDelay(pdMS_TO_TICKS(100));
					
					memset(&data_sd, 0, sizeof(data_sd));
800089f6:	30 04       	mov	r4,0
800089f8:	8f 04       	st.w	r7[0x0],r4
					print_dbg("Saved\r\n");
800089fa:	4a cc       	lddpc	r12,80008aa8 <fsTask+0x2c8>
800089fc:	f0 1f 00 18 	mcall	80008a5c <fsTask+0x27c>
80008a00:	50 04       	stdsp	sp[0x0],r4
				}
			}
		
			//print_dbg_char(file_getc());				// Display next char from file.
			vTaskDelay(pdMS_TO_TICKS(100));
80008a02:	36 4c       	mov	r12,100
80008a04:	f0 1f 00 2a 	mcall	80008aac <fsTask+0x2cc>
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
	{
		print_dbg("\r\n Archivo Encontrado\r");
		file_open(FOPEN_MODE_R);
		while (!file_eof())							//Hasta encontrar el fin del archivo
80008a08:	f0 1f 00 2a 	mcall	80008ab0 <fsTask+0x2d0>
80008a0c:	fe 90 ff 40 	breq	8000888c <fsTask+0xac>
			//print_dbg_char(file_getc());				// Display next char from file.
			vTaskDelay(pdMS_TO_TICKS(100));
		}
		//end_pos = samples_collected;
		// Close the file.
		file_close();
80008a10:	f0 1f 00 29 	mcall	80008ab4 <fsTask+0x2d4>
		print_dbg("DONE WITH FIRST FILE, SAMPLES: ");
80008a14:	4a 9c       	lddpc	r12,80008ab8 <fsTask+0x2d8>
80008a16:	f0 1f 00 12 	mcall	80008a5c <fsTask+0x27c>
		//print_dbg_ulong(samples_collected);
		print_dbg("\r\n");
80008a1a:	48 ec       	lddpc	r12,80008a50 <fsTask+0x270>
80008a1c:	f0 1f 00 10 	mcall	80008a5c <fsTask+0x27c>

	nav_filelist_reset();
	nav_filterlist_setfilter("h");
	nav_filterlist_root();
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
80008a20:	30 1b       	mov	r11,1
80008a22:	48 b8       	lddpc	r8,80008a4c <fsTask+0x26c>
80008a24:	11 bc       	ld.ub	r12,r8[0x3]
80008a26:	f0 1f 00 0c 	mcall	80008a54 <fsTask+0x274>
80008a2a:	fe 91 ff 28 	brne	8000887a <fsTask+0x9a>
		//cpu_delay_ms(5000, PBA_HZ);
	
	}


	print_dbg("DONE");
80008a2e:	4a 4c       	lddpc	r12,80008abc <fsTask+0x2dc>
80008a30:	f0 1f 00 0b 	mcall	80008a5c <fsTask+0x27c>
	nav_exit();										// Cerramos sistemas de archivos
80008a34:	f0 1f 00 23 	mcall	80008ac0 <fsTask+0x2e0>
80008a38:	c0 08       	rjmp	80008a38 <fsTask+0x258>
80008a3a:	00 00       	add	r0,r0
80008a3c:	80 00       	ld.sh	r0,r0[0x0]
80008a3e:	73 40       	ld.w	r0,r9[0x50]
80008a40:	00 00       	add	r0,r0
80008a42:	0d e8       	ld.ub	r8,r6[0x6]
80008a44:	80 00       	ld.sh	r0,r0[0x0]
80008a46:	61 50       	ld.w	r0,r0[0x54]
80008a48:	80 00       	ld.sh	r0,r0[0x0]
80008a4a:	63 bc       	ld.w	r12,r1[0x6c]
80008a4c:	00 00       	add	r0,r0
80008a4e:	07 20       	ld.uh	r0,r3++
80008a50:	80 00       	ld.sh	r0,r0[0x0]
80008a52:	a9 08       	ld.d	r8,r4
80008a54:	80 00       	ld.sh	r0,r0[0x0]
80008a56:	5f e8       	srqs	r8
80008a58:	80 00       	ld.sh	r0,r0[0x0]
80008a5a:	5f d8       	srvc	r8
80008a5c:	80 00       	ld.sh	r0,r0[0x0]
80008a5e:	67 f4       	ld.w	r4,r3[0x7c]
80008a60:	80 00       	ld.sh	r0,r0[0x0]
80008a62:	a9 bc       	sbr	r12,0x9
80008a64:	80 00       	ld.sh	r0,r0[0x0]
80008a66:	a9 d8       	cbr	r8,0x9
80008a68:	80 00       	ld.sh	r0,r0[0x0]
80008a6a:	67 58       	ld.w	r8,r3[0x54]
80008a6c:	80 00       	ld.sh	r0,r0[0x0]
80008a6e:	65 cc       	ld.w	r12,r2[0x70]
80008a70:	80 00       	ld.sh	r0,r0[0x0]
80008a72:	66 c8       	ld.w	r8,r3[0x30]
80008a74:	80 00       	ld.sh	r0,r0[0x0]
80008a76:	a9 dc       	cbr	r12,0x9
80008a78:	80 00       	ld.sh	r0,r0[0x0]
80008a7a:	5d e8       	*unknown*
80008a7c:	80 00       	ld.sh	r0,r0[0x0]
80008a7e:	5d 7c       	*unknown*
80008a80:	80 00       	ld.sh	r0,r0[0x0]
80008a82:	67 78       	ld.w	r8,r3[0x5c]
80008a84:	80 00       	ld.sh	r0,r0[0x0]
80008a86:	9a 00       	ld.sh	r0,sp[0x0]
80008a88:	80 00       	ld.sh	r0,r0[0x0]
80008a8a:	a9 f4       	*unknown*
80008a8c:	80 00       	ld.sh	r0,r0[0x0]
80008a8e:	67 e0       	ld.w	r0,r3[0x78]
80008a90:	80 00       	ld.sh	r0,r0[0x0]
80008a92:	a8 bc       	st.b	r4[0x3],r12
80008a94:	80 00       	ld.sh	r0,r0[0x0]
80008a96:	7c 48       	ld.w	r8,lr[0x10]
80008a98:	80 00       	ld.sh	r0,r0[0x0]
80008a9a:	aa 10       	st.h	r5[0x2],r0
80008a9c:	80 00       	ld.sh	r0,r0[0x0]
80008a9e:	71 ac       	ld.w	r12,r8[0x68]
80008aa0:	00 00       	add	r0,r0
80008aa2:	06 f8       	st.b	--r3,r8
80008aa4:	80 00       	ld.sh	r0,r0[0x0]
80008aa6:	7a 78       	ld.w	r8,sp[0x1c]
80008aa8:	80 00       	ld.sh	r0,r0[0x0]
80008aaa:	aa 18       	st.h	r5[0x2],r8
80008aac:	80 00       	ld.sh	r0,r0[0x0]
80008aae:	7c e0       	ld.w	r0,lr[0x38]
80008ab0:	80 00       	ld.sh	r0,r0[0x0]
80008ab2:	5d 1c       	icall	r12
80008ab4:	80 00       	ld.sh	r0,r0[0x0]
80008ab6:	5d 40       	*unknown*
80008ab8:	80 00       	ld.sh	r0,r0[0x0]
80008aba:	aa 20       	st.h	r5[0x4],r0
80008abc:	80 00       	ld.sh	r0,r0[0x0]
80008abe:	aa 40       	st.h	r5[0x8],r0
80008ac0:	80 00       	ld.sh	r0,r0[0x0]
80008ac2:	65 38       	ld.w	r8,r2[0x4c]

80008ac4 <LED_On>:
  }
}


void LED_On(uint32_t leds)
{
80008ac4:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80008ac6:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);
80008aca:	49 48       	lddpc	r8,80008b18 <LED_On+0x54>
80008acc:	70 09       	ld.w	r9,r8[0x0]
80008ace:	f9 e9 10 09 	or	r9,r12,r9
80008ad2:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80008ad4:	58 0c       	cp.w	r12,0
80008ad6:	c1 f0       	breq	80008b14 <LED_On+0x50>
80008ad8:	49 18       	lddpc	r8,80008b1c <LED_On+0x58>
80008ada:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it on.
    led_shift = 1 + ctz(leds);
80008adc:	32 1e       	mov	lr,33
80008ade:	58 0c       	cp.w	r12,0
80008ae0:	c0 31       	brne	80008ae6 <LED_On+0x22>
80008ae2:	1c 9a       	mov	r10,lr
80008ae4:	c0 68       	rjmp	80008af0 <LED_On+0x2c>
80008ae6:	18 9a       	mov	r10,r12
80008ae8:	5c 9a       	brev	r10
80008aea:	f4 0a 12 00 	clz	r10,r10
80008aee:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80008af0:	f4 09 15 04 	lsl	r9,r10,0x4
80008af4:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80008af6:	70 09       	ld.w	r9,r8[0x0]
80008af8:	a9 69       	lsl	r9,0x8
80008afa:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrc  = led_descriptor->GPIO.PIN_MASK;
80008afe:	70 1b       	ld.w	r11,r8[0x4]
80008b00:	f3 4b 00 58 	st.w	r9[88],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80008b04:	70 1b       	ld.w	r11,r8[0x4]
80008b06:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80008b0a:	70 1b       	ld.w	r11,r8[0x4]
80008b0c:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80008b0e:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80008b12:	ce 61       	brne	80008ade <LED_On+0x1a>
80008b14:	d8 02       	popm	pc
80008b16:	00 00       	add	r0,r0
80008b18:	00 00       	add	r0,r0
80008b1a:	00 2c       	rsub	r12,r0
80008b1c:	80 00       	ld.sh	r0,r0[0x0]
80008b1e:	aa 58       	st.h	r5[0xa],r8

80008b20 <LED_Off>:
  return Tst_bits(LED_State, leds);
}


void LED_Off(uint32_t leds)
{
80008b20:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80008b22:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);
80008b26:	49 58       	lddpc	r8,80008b78 <LED_Off+0x58>
80008b28:	70 09       	ld.w	r9,r8[0x0]
80008b2a:	f8 0a 11 ff 	rsub	r10,r12,-1
80008b2e:	f5 e9 00 09 	and	r9,r10,r9
80008b32:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80008b34:	58 0c       	cp.w	r12,0
80008b36:	c1 f0       	breq	80008b74 <LED_Off+0x54>
80008b38:	49 18       	lddpc	r8,80008b7c <LED_Off+0x5c>
80008b3a:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it off.
    led_shift = 1 + ctz(leds);
80008b3c:	32 1e       	mov	lr,33
80008b3e:	58 0c       	cp.w	r12,0
80008b40:	c0 31       	brne	80008b46 <LED_Off+0x26>
80008b42:	1c 9a       	mov	r10,lr
80008b44:	c0 68       	rjmp	80008b50 <LED_Off+0x30>
80008b46:	18 9a       	mov	r10,r12
80008b48:	5c 9a       	brev	r10
80008b4a:	f4 0a 12 00 	clz	r10,r10
80008b4e:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80008b50:	f4 09 15 04 	lsl	r9,r10,0x4
80008b54:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80008b56:	70 09       	ld.w	r9,r8[0x0]
80008b58:	a9 69       	lsl	r9,0x8
80008b5a:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
80008b5e:	70 1b       	ld.w	r11,r8[0x4]
80008b60:	f3 4b 00 54 	st.w	r9[84],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80008b64:	70 1b       	ld.w	r11,r8[0x4]
80008b66:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80008b6a:	70 1b       	ld.w	r11,r8[0x4]
80008b6c:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80008b6e:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80008b72:	ce 61       	brne	80008b3e <LED_Off+0x1e>
80008b74:	d8 02       	popm	pc
80008b76:	00 00       	add	r0,r0
80008b78:	00 00       	add	r0,r0
80008b7a:	00 2c       	rsub	r12,r0
80008b7c:	80 00       	ld.sh	r0,r0[0x0]
80008b7e:	aa 58       	st.h	r5[0xa],r8

80008b80 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80008b80:	fe 68 14 00 	mov	r8,-125952
80008b84:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80008b86:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80008b8a:	91 09       	st.w	r8[0x0],r9
}
80008b8c:	5e fc       	retal	r12

80008b8e <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008b8e:	f8 08 16 05 	lsr	r8,r12,0x5
80008b92:	a9 68       	lsl	r8,0x8
80008b94:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80008b98:	58 1b       	cp.w	r11,1
80008b9a:	c0 d0       	breq	80008bb4 <gpio_enable_module_pin+0x26>
80008b9c:	c0 63       	brcs	80008ba8 <gpio_enable_module_pin+0x1a>
80008b9e:	58 2b       	cp.w	r11,2
80008ba0:	c1 00       	breq	80008bc0 <gpio_enable_module_pin+0x32>
80008ba2:	58 3b       	cp.w	r11,3
80008ba4:	c1 40       	breq	80008bcc <gpio_enable_module_pin+0x3e>
80008ba6:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80008ba8:	30 19       	mov	r9,1
80008baa:	f2 0c 09 49 	lsl	r9,r9,r12
80008bae:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80008bb0:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80008bb2:	c1 28       	rjmp	80008bd6 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80008bb4:	30 19       	mov	r9,1
80008bb6:	f2 0c 09 49 	lsl	r9,r9,r12
80008bba:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80008bbc:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80008bbe:	c0 c8       	rjmp	80008bd6 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80008bc0:	30 19       	mov	r9,1
80008bc2:	f2 0c 09 49 	lsl	r9,r9,r12
80008bc6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008bc8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80008bca:	c0 68       	rjmp	80008bd6 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80008bcc:	30 19       	mov	r9,1
80008bce:	f2 0c 09 49 	lsl	r9,r9,r12
80008bd2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008bd4:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008bd6:	30 19       	mov	r9,1
80008bd8:	f2 0c 09 4c 	lsl	r12,r9,r12
80008bdc:	91 2c       	st.w	r8[0x8],r12
80008bde:	5e fd       	retal	0

80008be0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80008be0:	d4 21       	pushm	r4-r7,lr
80008be2:	18 97       	mov	r7,r12
80008be4:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008be6:	58 0b       	cp.w	r11,0
80008be8:	c0 31       	brne	80008bee <gpio_enable_module+0xe>
80008bea:	30 05       	mov	r5,0
80008bec:	c0 d8       	rjmp	80008c06 <gpio_enable_module+0x26>
80008bee:	30 06       	mov	r6,0
80008bf0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80008bf2:	6e 1b       	ld.w	r11,r7[0x4]
80008bf4:	6e 0c       	ld.w	r12,r7[0x0]
80008bf6:	f0 1f 00 06 	mcall	80008c0c <gpio_enable_module+0x2c>
80008bfa:	18 45       	or	r5,r12
		gpiomap++;
80008bfc:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008bfe:	2f f6       	sub	r6,-1
80008c00:	0c 34       	cp.w	r4,r6
80008c02:	fe 9b ff f8 	brhi	80008bf2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80008c06:	0a 9c       	mov	r12,r5
80008c08:	d8 22       	popm	r4-r7,pc
80008c0a:	00 00       	add	r0,r0
80008c0c:	80 00       	ld.sh	r0,r0[0x0]
80008c0e:	8b 8e       	st.w	r5[0x20],lr

80008c10 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008c10:	f8 08 16 05 	lsr	r8,r12,0x5
80008c14:	a9 68       	lsl	r8,0x8
80008c16:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80008c1a:	30 19       	mov	r9,1
80008c1c:	f2 0c 09 4c 	lsl	r12,r9,r12
80008c20:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80008c24:	91 1c       	st.w	r8[0x4],r12
}
80008c26:	5e fc       	retal	r12

80008c28 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
80008c28:	eb cd 40 e0 	pushm	r5-r7,lr
80008c2c:	18 97       	mov	r7,r12
80008c2e:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
80008c30:	58 0b       	cp.w	r11,0
80008c32:	c0 a0       	breq	80008c46 <gpio_enable_gpio+0x1e>
80008c34:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
80008c36:	6e 0c       	ld.w	r12,r7[0x0]
80008c38:	f0 1f 00 05 	mcall	80008c4c <gpio_enable_gpio+0x24>
		gpiomap++;
80008c3c:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
80008c3e:	2f f5       	sub	r5,-1
80008c40:	0a 36       	cp.w	r6,r5
80008c42:	fe 9b ff fa 	brhi	80008c36 <gpio_enable_gpio+0xe>
80008c46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008c4a:	00 00       	add	r0,r0
80008c4c:	80 00       	ld.sh	r0,r0[0x0]
80008c4e:	8c 10       	ld.sh	r0,r6[0x2]

80008c50 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008c50:	f8 08 16 05 	lsr	r8,r12,0x5
80008c54:	a9 68       	lsl	r8,0x8
80008c56:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80008c5a:	30 19       	mov	r9,1
80008c5c:	f2 0c 09 4c 	lsl	r12,r9,r12
80008c60:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80008c64:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80008c68:	91 1c       	st.w	r8[0x4],r12
}
80008c6a:	5e fc       	retal	r12

80008c6c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008c6c:	f8 08 16 05 	lsr	r8,r12,0x5
80008c70:	a9 68       	lsl	r8,0x8
80008c72:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80008c76:	30 19       	mov	r9,1
80008c78:	f2 0c 09 4c 	lsl	r12,r9,r12
80008c7c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80008c80:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80008c84:	91 1c       	st.w	r8[0x4],r12
}
80008c86:	5e fc       	retal	r12

80008c88 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008c88:	f8 08 16 05 	lsr	r8,r12,0x5
80008c8c:	a9 68       	lsl	r8,0x8
80008c8e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80008c92:	30 19       	mov	r9,1
80008c94:	f2 0c 09 4c 	lsl	r12,r9,r12
80008c98:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80008c9c:	12 3b       	cp.w	r11,r9
80008c9e:	c0 a0       	breq	80008cb2 <gpio_enable_pin_interrupt+0x2a>
80008ca0:	c0 43       	brcs	80008ca8 <gpio_enable_pin_interrupt+0x20>
80008ca2:	58 2b       	cp.w	r11,2
80008ca4:	c1 11       	brne	80008cc6 <gpio_enable_pin_interrupt+0x3e>
80008ca6:	c0 b8       	rjmp	80008cbc <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80008ca8:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80008cac:	f1 4c 00 b8 	st.w	r8[184],r12
80008cb0:	c0 c8       	rjmp	80008cc8 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80008cb2:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80008cb6:	f1 4c 00 b8 	st.w	r8[184],r12
80008cba:	c0 78       	rjmp	80008cc8 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80008cbc:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
80008cc0:	f1 4c 00 b4 	st.w	r8[180],r12
80008cc4:	c0 28       	rjmp	80008cc8 <gpio_enable_pin_interrupt+0x40>
80008cc6:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80008cc8:	f1 4c 00 94 	st.w	r8[148],r12
80008ccc:	5e fd       	retal	0

80008cce <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008cce:	f8 08 16 05 	lsr	r8,r12,0x5
80008cd2:	a9 68       	lsl	r8,0x8
80008cd4:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80008cd8:	f0 f8 00 d0 	ld.w	r8,r8[208]
80008cdc:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80008ce0:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80008ce4:	5e fc       	retal	r12

80008ce6 <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008ce6:	f8 08 16 05 	lsr	r8,r12,0x5
80008cea:	a9 68       	lsl	r8,0x8
80008cec:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80008cf0:	30 19       	mov	r9,1
80008cf2:	f2 0c 09 4c 	lsl	r12,r9,r12
80008cf6:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
80008cfa:	5e fc       	retal	r12

80008cfc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80008cfc:	c0 08       	rjmp	80008cfc <_unhandled_interrupt>
80008cfe:	d7 03       	nop

80008d00 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80008d00:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80008d04:	49 99       	lddpc	r9,80008d68 <INTC_register_interrupt+0x68>
80008d06:	f2 08 00 39 	add	r9,r9,r8<<0x3
80008d0a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80008d0e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80008d10:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80008d14:	58 0a       	cp.w	r10,0
80008d16:	c0 91       	brne	80008d28 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008d18:	49 59       	lddpc	r9,80008d6c <INTC_register_interrupt+0x6c>
80008d1a:	49 6a       	lddpc	r10,80008d70 <INTC_register_interrupt+0x70>
80008d1c:	12 1a       	sub	r10,r9
80008d1e:	fe 79 08 00 	mov	r9,-63488
80008d22:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80008d26:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80008d28:	58 1a       	cp.w	r10,1
80008d2a:	c0 a1       	brne	80008d3e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80008d2c:	49 09       	lddpc	r9,80008d6c <INTC_register_interrupt+0x6c>
80008d2e:	49 2a       	lddpc	r10,80008d74 <INTC_register_interrupt+0x74>
80008d30:	12 1a       	sub	r10,r9
80008d32:	bf aa       	sbr	r10,0x1e
80008d34:	fe 79 08 00 	mov	r9,-63488
80008d38:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80008d3c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80008d3e:	58 2a       	cp.w	r10,2
80008d40:	c0 a1       	brne	80008d54 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80008d42:	48 b9       	lddpc	r9,80008d6c <INTC_register_interrupt+0x6c>
80008d44:	48 da       	lddpc	r10,80008d78 <INTC_register_interrupt+0x78>
80008d46:	12 1a       	sub	r10,r9
80008d48:	bf ba       	sbr	r10,0x1f
80008d4a:	fe 79 08 00 	mov	r9,-63488
80008d4e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80008d52:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80008d54:	48 69       	lddpc	r9,80008d6c <INTC_register_interrupt+0x6c>
80008d56:	48 aa       	lddpc	r10,80008d7c <INTC_register_interrupt+0x7c>
80008d58:	12 1a       	sub	r10,r9
80008d5a:	ea 1a c0 00 	orh	r10,0xc000
80008d5e:	fe 79 08 00 	mov	r9,-63488
80008d62:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80008d66:	5e fc       	retal	r12
80008d68:	80 00       	ld.sh	r0,r0[0x0]
80008d6a:	aa 98       	st.b	r5[0x1],r8
80008d6c:	80 00       	ld.sh	r0,r0[0x0]
80008d6e:	a0 00       	st.h	r0[0x0],r0
80008d70:	80 00       	ld.sh	r0,r0[0x0]
80008d72:	a1 04       	ld.d	r4,r0
80008d74:	80 00       	ld.sh	r0,r0[0x0]
80008d76:	a1 12       	ld.d	r2,--r0
80008d78:	80 00       	ld.sh	r0,r0[0x0]
80008d7a:	a1 20       	st.d	r0++,r0
80008d7c:	80 00       	ld.sh	r0,r0[0x0]
80008d7e:	a1 2e       	st.d	r0++,lr

80008d80 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80008d80:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80008d82:	49 18       	lddpc	r8,80008dc4 <INTC_init_interrupts+0x44>
80008d84:	e3 b8 00 01 	mtsr	0x4,r8
80008d88:	49 0e       	lddpc	lr,80008dc8 <INTC_init_interrupts+0x48>
80008d8a:	30 07       	mov	r7,0
80008d8c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80008d8e:	49 0c       	lddpc	r12,80008dcc <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008d90:	49 05       	lddpc	r5,80008dd0 <INTC_init_interrupts+0x50>
80008d92:	10 15       	sub	r5,r8
80008d94:	fe 76 08 00 	mov	r6,-63488
80008d98:	c1 08       	rjmp	80008db8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80008d9a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80008d9c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80008d9e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80008da0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80008da4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80008da6:	10 3a       	cp.w	r10,r8
80008da8:	fe 9b ff fc 	brhi	80008da0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008dac:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80008db0:	2f f7       	sub	r7,-1
80008db2:	2f 8e       	sub	lr,-8
80008db4:	59 47       	cp.w	r7,20
80008db6:	c0 50       	breq	80008dc0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80008db8:	7c 08       	ld.w	r8,lr[0x0]
80008dba:	58 08       	cp.w	r8,0
80008dbc:	ce f1       	brne	80008d9a <INTC_init_interrupts+0x1a>
80008dbe:	cf 7b       	rjmp	80008dac <INTC_init_interrupts+0x2c>
80008dc0:	d8 22       	popm	r4-r7,pc
80008dc2:	00 00       	add	r0,r0
80008dc4:	80 00       	ld.sh	r0,r0[0x0]
80008dc6:	a0 00       	st.h	r0[0x0],r0
80008dc8:	80 00       	ld.sh	r0,r0[0x0]
80008dca:	aa 98       	st.b	r5[0x1],r8
80008dcc:	80 00       	ld.sh	r0,r0[0x0]
80008dce:	8c fc       	ld.uh	r12,r6[0xe]
80008dd0:	80 00       	ld.sh	r0,r0[0x0]
80008dd2:	a1 04       	ld.d	r4,r0

80008dd4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80008dd4:	fe 78 08 00 	mov	r8,-63488
80008dd8:	e0 69 00 83 	mov	r9,131
80008ddc:	f2 0c 01 0c 	sub	r12,r9,r12
80008de0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80008de4:	f2 ca ff c0 	sub	r10,r9,-64
80008de8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008dec:	58 08       	cp.w	r8,0
80008dee:	c0 21       	brne	80008df2 <_get_interrupt_handler+0x1e>
80008df0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
80008df2:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80008df6:	48 5a       	lddpc	r10,80008e08 <_get_interrupt_handler+0x34>
80008df8:	f4 09 00 39 	add	r9,r10,r9<<0x3
80008dfc:	f0 08 11 1f 	rsub	r8,r8,31
80008e00:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008e02:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80008e06:	5e fc       	retal	r12
80008e08:	80 00       	ld.sh	r0,r0[0x0]
80008e0a:	aa 98       	st.b	r5[0x1],r8

80008e0c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80008e0c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80008e0e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80008e12:	99 a8       	st.w	r12[0x28],r8
}
80008e14:	5e fc       	retal	r12
80008e16:	d7 03       	nop

80008e18 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80008e18:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80008e1a:	ec 5b bb 9f 	cp.w	r11,899999
80008e1e:	e0 8b 00 04 	brhi	80008e26 <pm_enable_osc0_crystal+0xe>
80008e22:	30 4b       	mov	r11,4
80008e24:	c1 38       	rjmp	80008e4a <pm_enable_osc0_crystal+0x32>
80008e26:	e0 68 c6 bf 	mov	r8,50879
80008e2a:	ea 18 00 2d 	orh	r8,0x2d
80008e2e:	10 3b       	cp.w	r11,r8
80008e30:	e0 8b 00 04 	brhi	80008e38 <pm_enable_osc0_crystal+0x20>
80008e34:	30 5b       	mov	r11,5
80008e36:	c0 a8       	rjmp	80008e4a <pm_enable_osc0_crystal+0x32>
80008e38:	e0 68 12 00 	mov	r8,4608
80008e3c:	ea 18 00 7a 	orh	r8,0x7a
80008e40:	10 3b       	cp.w	r11,r8
80008e42:	f9 bb 03 06 	movlo	r11,6
80008e46:	f9 bb 02 07 	movhs	r11,7
80008e4a:	f0 1f 00 02 	mcall	80008e50 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80008e4e:	d8 02       	popm	pc
80008e50:	80 00       	ld.sh	r0,r0[0x0]
80008e52:	8e 0c       	ld.sh	r12,r7[0x0]

80008e54 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80008e54:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80008e56:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80008e5a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80008e5c:	78 08       	ld.w	r8,r12[0x0]
80008e5e:	a3 a8       	sbr	r8,0x2
80008e60:	99 08       	st.w	r12[0x0],r8
}
80008e62:	5e fc       	retal	r12

80008e64 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80008e64:	79 58       	ld.w	r8,r12[0x54]
80008e66:	e2 18 00 80 	andl	r8,0x80,COH
80008e6a:	cf d0       	breq	80008e64 <pm_wait_for_clk0_ready>
}
80008e6c:	5e fc       	retal	r12
80008e6e:	d7 03       	nop

80008e70 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80008e70:	eb cd 40 80 	pushm	r7,lr
80008e74:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80008e76:	f0 1f 00 04 	mcall	80008e84 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80008e7a:	0e 9c       	mov	r12,r7
80008e7c:	f0 1f 00 03 	mcall	80008e88 <pm_enable_clk0+0x18>
}
80008e80:	e3 cd 80 80 	ldm	sp++,r7,pc
80008e84:	80 00       	ld.sh	r0,r0[0x0]
80008e86:	8e 54       	ld.sh	r4,r7[0xa]
80008e88:	80 00       	ld.sh	r0,r0[0x0]
80008e8a:	8e 64       	ld.sh	r4,r7[0xc]

80008e8c <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80008e8c:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
80008e8e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80008e92:	99 b8       	st.w	r12[0x2c],r8
}
80008e94:	5e fc       	retal	r12
80008e96:	d7 03       	nop

80008e98 <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
80008e98:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
80008e9a:	ec 5b bb 9f 	cp.w	r11,899999
80008e9e:	e0 8b 00 04 	brhi	80008ea6 <pm_enable_osc1_crystal+0xe>
80008ea2:	30 4b       	mov	r11,4
80008ea4:	c1 38       	rjmp	80008eca <pm_enable_osc1_crystal+0x32>
80008ea6:	e0 68 c6 bf 	mov	r8,50879
80008eaa:	ea 18 00 2d 	orh	r8,0x2d
80008eae:	10 3b       	cp.w	r11,r8
80008eb0:	e0 8b 00 04 	brhi	80008eb8 <pm_enable_osc1_crystal+0x20>
80008eb4:	30 5b       	mov	r11,5
80008eb6:	c0 a8       	rjmp	80008eca <pm_enable_osc1_crystal+0x32>
80008eb8:	e0 68 12 00 	mov	r8,4608
80008ebc:	ea 18 00 7a 	orh	r8,0x7a
80008ec0:	10 3b       	cp.w	r11,r8
80008ec2:	f9 bb 03 06 	movlo	r11,6
80008ec6:	f9 bb 02 07 	movhs	r11,7
80008eca:	f0 1f 00 02 	mcall	80008ed0 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80008ece:	d8 02       	popm	pc
80008ed0:	80 00       	ld.sh	r0,r0[0x0]
80008ed2:	8e 8c       	ld.uh	r12,r7[0x0]

80008ed4 <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80008ed4:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
80008ed6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80008eda:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80008edc:	78 08       	ld.w	r8,r12[0x0]
80008ede:	a3 b8       	sbr	r8,0x3
80008ee0:	99 08       	st.w	r12[0x0],r8
}
80008ee2:	5e fc       	retal	r12

80008ee4 <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80008ee4:	79 58       	ld.w	r8,r12[0x54]
80008ee6:	e2 18 01 00 	andl	r8,0x100,COH
80008eea:	cf d0       	breq	80008ee4 <pm_wait_for_clk1_ready>
}
80008eec:	5e fc       	retal	r12
80008eee:	d7 03       	nop

80008ef0 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80008ef0:	eb cd 40 80 	pushm	r7,lr
80008ef4:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
80008ef6:	f0 1f 00 04 	mcall	80008f04 <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
80008efa:	0e 9c       	mov	r12,r7
80008efc:	f0 1f 00 03 	mcall	80008f08 <pm_enable_clk1+0x18>
}
80008f00:	e3 cd 80 80 	ldm	sp++,r7,pc
80008f04:	80 00       	ld.sh	r0,r0[0x0]
80008f06:	8e d4       	ld.uh	r4,r7[0xa]
80008f08:	80 00       	ld.sh	r0,r0[0x0]
80008f0a:	8e e4       	ld.uh	r4,r7[0xc]

80008f0c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80008f0c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80008f10:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80008f14:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80008f16:	09 f7       	ld.ub	r7,r4[0x7]
80008f18:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80008f1c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80008f20:	09 b4       	ld.ub	r4,r4[0x3]
80008f22:	08 96       	mov	r6,r4
80008f24:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80008f28:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80008f2c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80008f30:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80008f34:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80008f38:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80008f3c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80008f40:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80008f44:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80008f46:	79 58       	ld.w	r8,r12[0x54]
80008f48:	e2 18 00 20 	andl	r8,0x20,COH
80008f4c:	cf d0       	breq	80008f46 <pm_cksel+0x3a>
}
80008f4e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80008f52 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80008f52:	eb cd 40 80 	pushm	r7,lr
80008f56:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80008f58:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80008f5a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80008f5e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80008f62:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80008f66:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80008f6a:	2f 8b       	sub	r11,-8
80008f6c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80008f70:	e3 cd 80 80 	ldm	sp++,r7,pc

80008f74 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80008f74:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80008f76:	2f 8b       	sub	r11,-8
80008f78:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80008f7c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80008f80:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80008f84:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80008f88:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80008f8c:	d8 02       	popm	pc

80008f8e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80008f8e:	2f 8b       	sub	r11,-8
80008f90:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80008f94:	a1 a8       	sbr	r8,0x0
80008f96:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80008f9a:	5e fc       	retal	r12

80008f9c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80008f9c:	79 58       	ld.w	r8,r12[0x54]
80008f9e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008fa2:	cf d0       	breq	80008f9c <pm_wait_for_pll0_locked>
}
80008fa4:	5e fc       	retal	r12

80008fa6 <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
80008fa6:	79 58       	ld.w	r8,r12[0x54]
80008fa8:	e2 18 00 02 	andl	r8,0x2,COH
80008fac:	cf d0       	breq	80008fa6 <pm_wait_for_pll1_locked>
}
80008fae:	5e fc       	retal	r12

80008fb0 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80008fb0:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80008fb2:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80008fb6:	99 08       	st.w	r12[0x0],r8
}
80008fb8:	5e fc       	retal	r12
80008fba:	d7 03       	nop

80008fbc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80008fbc:	eb cd 40 c0 	pushm	r6-r7,lr
80008fc0:	18 97       	mov	r7,r12
80008fc2:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80008fc4:	f0 1f 00 06 	mcall	80008fdc <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80008fc8:	0c 9b       	mov	r11,r6
80008fca:	0e 9c       	mov	r12,r7
80008fcc:	f0 1f 00 05 	mcall	80008fe0 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80008fd0:	30 1b       	mov	r11,1
80008fd2:	0e 9c       	mov	r12,r7
80008fd4:	f0 1f 00 04 	mcall	80008fe4 <pm_switch_to_osc0+0x28>
}
80008fd8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008fdc:	80 00       	ld.sh	r0,r0[0x0]
80008fde:	8e 18       	ld.sh	r8,r7[0x2]
80008fe0:	80 00       	ld.sh	r0,r0[0x0]
80008fe2:	8e 70       	ld.sh	r0,r7[0xe]
80008fe4:	80 00       	ld.sh	r0,r0[0x0]
80008fe6:	8f b0       	st.w	r7[0x2c],r0

80008fe8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80008fe8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80008fea:	f6 08 15 04 	lsl	r8,r11,0x4
80008fee:	14 38       	cp.w	r8,r10
80008ff0:	f9 b8 08 10 	movls	r8,16
80008ff4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80008ff8:	f0 0b 02 4b 	mul	r11,r8,r11
80008ffc:	f6 09 16 01 	lsr	r9,r11,0x1
80009000:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80009004:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80009008:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000900c:	f2 cb 00 01 	sub	r11,r9,1
80009010:	e0 4b ff fe 	cp.w	r11,65534
80009014:	e0 88 00 03 	brls	8000901a <usart_set_async_baudrate+0x32>
80009018:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000901a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000901c:	e8 6e 00 00 	mov	lr,524288
80009020:	59 08       	cp.w	r8,16
80009022:	fc 08 17 10 	movne	r8,lr
80009026:	f9 b8 00 00 	moveq	r8,0
8000902a:	e4 1b ff f7 	andh	r11,0xfff7
8000902e:	e0 1b fe cf 	andl	r11,0xfecf
80009032:	16 48       	or	r8,r11
80009034:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80009036:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000903a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000903e:	99 89       	st.w	r12[0x20],r9
80009040:	d8 0a       	popm	pc,r12=0

80009042 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80009042:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80009044:	e2 18 00 02 	andl	r8,0x2,COH
80009048:	c0 31       	brne	8000904e <usart_write_char+0xc>
8000904a:	30 2c       	mov	r12,2
8000904c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000904e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80009052:	99 7b       	st.w	r12[0x1c],r11
80009054:	5e fd       	retal	0
80009056:	d7 03       	nop

80009058 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80009058:	eb cd 40 e0 	pushm	r5-r7,lr
8000905c:	18 96       	mov	r6,r12
8000905e:	16 95       	mov	r5,r11
80009060:	e0 67 27 0f 	mov	r7,9999
80009064:	c0 68       	rjmp	80009070 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80009066:	58 07       	cp.w	r7,0
80009068:	c0 31       	brne	8000906e <usart_putchar+0x16>
8000906a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000906e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80009070:	0a 9b       	mov	r11,r5
80009072:	0c 9c       	mov	r12,r6
80009074:	f0 1f 00 03 	mcall	80009080 <usart_putchar+0x28>
80009078:	cf 71       	brne	80009066 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000907a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000907e:	00 00       	add	r0,r0
80009080:	80 00       	ld.sh	r0,r0[0x0]
80009082:	90 42       	ld.sh	r2,r8[0x8]

80009084 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80009084:	eb cd 40 c0 	pushm	r6-r7,lr
80009088:	18 96       	mov	r6,r12
8000908a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000908c:	17 8b       	ld.ub	r11,r11[0x0]
8000908e:	58 0b       	cp.w	r11,0
80009090:	c0 80       	breq	800090a0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80009092:	2f f7       	sub	r7,-1
80009094:	0c 9c       	mov	r12,r6
80009096:	f0 1f 00 04 	mcall	800090a4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000909a:	0f 8b       	ld.ub	r11,r7[0x0]
8000909c:	58 0b       	cp.w	r11,0
8000909e:	cf a1       	brne	80009092 <usart_write_line+0xe>
800090a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800090a4:	80 00       	ld.sh	r0,r0[0x0]
800090a6:	90 58       	ld.sh	r8,r8[0xa]

800090a8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800090a8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800090ac:	e6 18 00 01 	andh	r8,0x1,COH
800090b0:	c0 71       	brne	800090be <usart_reset+0x16>
800090b2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800090b4:	3f f8       	mov	r8,-1
800090b6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800090b8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800090ba:	d5 03       	csrf	0x10
800090bc:	c0 48       	rjmp	800090c4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800090be:	3f f8       	mov	r8,-1
800090c0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800090c2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800090c4:	30 08       	mov	r8,0
800090c6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800090c8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800090ca:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800090cc:	ea 68 61 0c 	mov	r8,680204
800090d0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800090d2:	5e fc       	retal	r12

800090d4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800090d4:	eb cd 40 e0 	pushm	r5-r7,lr
800090d8:	18 96       	mov	r6,r12
800090da:	16 97       	mov	r7,r11
800090dc:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800090de:	f0 1f 00 2f 	mcall	80009198 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800090e2:	58 07       	cp.w	r7,0
800090e4:	c5 80       	breq	80009194 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800090e6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800090e8:	30 49       	mov	r9,4
800090ea:	f2 08 18 00 	cp.b	r8,r9
800090ee:	e0 88 00 53 	brls	80009194 <usart_init_rs232+0xc0>
800090f2:	30 99       	mov	r9,9
800090f4:	f2 08 18 00 	cp.b	r8,r9
800090f8:	e0 8b 00 4e 	brhi	80009194 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800090fc:	0f d9       	ld.ub	r9,r7[0x5]
800090fe:	30 78       	mov	r8,7
80009100:	f0 09 18 00 	cp.b	r9,r8
80009104:	e0 8b 00 48 	brhi	80009194 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80009108:	8e 39       	ld.sh	r9,r7[0x6]
8000910a:	e0 68 01 01 	mov	r8,257
8000910e:	f0 09 19 00 	cp.h	r9,r8
80009112:	e0 8b 00 41 	brhi	80009194 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80009116:	ef 39 00 08 	ld.ub	r9,r7[8]
8000911a:	30 38       	mov	r8,3
8000911c:	f0 09 18 00 	cp.b	r9,r8
80009120:	e0 8b 00 3a 	brhi	80009194 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80009124:	0a 9a       	mov	r10,r5
80009126:	6e 0b       	ld.w	r11,r7[0x0]
80009128:	0c 9c       	mov	r12,r6
8000912a:	f0 1f 00 1d 	mcall	8000919c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000912e:	58 1c       	cp.w	r12,1
80009130:	c3 20       	breq	80009194 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80009132:	0f c8       	ld.ub	r8,r7[0x4]
80009134:	30 99       	mov	r9,9
80009136:	f2 08 18 00 	cp.b	r8,r9
8000913a:	c0 51       	brne	80009144 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000913c:	6c 18       	ld.w	r8,r6[0x4]
8000913e:	b1 b8       	sbr	r8,0x11
80009140:	8d 18       	st.w	r6[0x4],r8
80009142:	c0 68       	rjmp	8000914e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80009144:	6c 19       	ld.w	r9,r6[0x4]
80009146:	20 58       	sub	r8,5
80009148:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000914c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000914e:	6c 19       	ld.w	r9,r6[0x4]
80009150:	ef 3a 00 08 	ld.ub	r10,r7[8]
80009154:	0f d8       	ld.ub	r8,r7[0x5]
80009156:	a9 78       	lsl	r8,0x9
80009158:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000915c:	12 48       	or	r8,r9
8000915e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80009160:	8e 38       	ld.sh	r8,r7[0x6]
80009162:	30 29       	mov	r9,2
80009164:	f2 08 19 00 	cp.h	r8,r9
80009168:	e0 88 00 09 	brls	8000917a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000916c:	6c 18       	ld.w	r8,r6[0x4]
8000916e:	ad b8       	sbr	r8,0xd
80009170:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80009172:	8e b8       	ld.uh	r8,r7[0x6]
80009174:	20 28       	sub	r8,2
80009176:	8d a8       	st.w	r6[0x28],r8
80009178:	c0 68       	rjmp	80009184 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000917a:	6c 19       	ld.w	r9,r6[0x4]
8000917c:	5c 78       	castu.h	r8
8000917e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80009182:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80009184:	6c 18       	ld.w	r8,r6[0x4]
80009186:	e0 18 ff f0 	andl	r8,0xfff0
8000918a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000918c:	35 08       	mov	r8,80
8000918e:	8d 08       	st.w	r6[0x0],r8
80009190:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80009194:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80009198:	80 00       	ld.sh	r0,r0[0x0]
8000919a:	90 a8       	ld.uh	r8,r8[0x4]
8000919c:	80 00       	ld.sh	r0,r0[0x0]
8000919e:	8f e8       	st.w	r7[0x38],r8

800091a0 <__avr32_udiv64>:
800091a0:	d4 31       	pushm	r0-r7,lr
800091a2:	1a 97       	mov	r7,sp
800091a4:	20 3d       	sub	sp,12
800091a6:	10 9c       	mov	r12,r8
800091a8:	12 9e       	mov	lr,r9
800091aa:	14 93       	mov	r3,r10
800091ac:	58 09       	cp.w	r9,0
800091ae:	e0 81 00 bd 	brne	80009328 <__avr32_udiv64+0x188>
800091b2:	16 38       	cp.w	r8,r11
800091b4:	e0 88 00 40 	brls	80009234 <__avr32_udiv64+0x94>
800091b8:	f0 08 12 00 	clz	r8,r8
800091bc:	c0 d0       	breq	800091d6 <__avr32_udiv64+0x36>
800091be:	f6 08 09 4b 	lsl	r11,r11,r8
800091c2:	f0 09 11 20 	rsub	r9,r8,32
800091c6:	f8 08 09 4c 	lsl	r12,r12,r8
800091ca:	f4 09 0a 49 	lsr	r9,r10,r9
800091ce:	f4 08 09 43 	lsl	r3,r10,r8
800091d2:	f3 eb 10 0b 	or	r11,r9,r11
800091d6:	f8 0e 16 10 	lsr	lr,r12,0x10
800091da:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800091de:	f6 0e 0d 00 	divu	r0,r11,lr
800091e2:	e6 0b 16 10 	lsr	r11,r3,0x10
800091e6:	00 99       	mov	r9,r0
800091e8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800091ec:	e0 0a 02 48 	mul	r8,r0,r10
800091f0:	10 3b       	cp.w	r11,r8
800091f2:	c0 a2       	brcc	80009206 <__avr32_udiv64+0x66>
800091f4:	20 19       	sub	r9,1
800091f6:	18 0b       	add	r11,r12
800091f8:	18 3b       	cp.w	r11,r12
800091fa:	c0 63       	brcs	80009206 <__avr32_udiv64+0x66>
800091fc:	10 3b       	cp.w	r11,r8
800091fe:	f7 b9 03 01 	sublo	r9,1
80009202:	f7 dc e3 0b 	addcs	r11,r11,r12
80009206:	f6 08 01 01 	sub	r1,r11,r8
8000920a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000920e:	e2 0e 0d 00 	divu	r0,r1,lr
80009212:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80009216:	00 98       	mov	r8,r0
80009218:	e0 0a 02 4a 	mul	r10,r0,r10
8000921c:	14 33       	cp.w	r3,r10
8000921e:	c0 82       	brcc	8000922e <__avr32_udiv64+0x8e>
80009220:	20 18       	sub	r8,1
80009222:	18 03       	add	r3,r12
80009224:	18 33       	cp.w	r3,r12
80009226:	c0 43       	brcs	8000922e <__avr32_udiv64+0x8e>
80009228:	14 33       	cp.w	r3,r10
8000922a:	f7 b8 03 01 	sublo	r8,1
8000922e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80009232:	cd f8       	rjmp	800093f0 <__avr32_udiv64+0x250>
80009234:	58 08       	cp.w	r8,0
80009236:	c0 51       	brne	80009240 <__avr32_udiv64+0xa0>
80009238:	30 19       	mov	r9,1
8000923a:	f2 08 0d 08 	divu	r8,r9,r8
8000923e:	10 9c       	mov	r12,r8
80009240:	f8 06 12 00 	clz	r6,r12
80009244:	c0 41       	brne	8000924c <__avr32_udiv64+0xac>
80009246:	18 1b       	sub	r11,r12
80009248:	30 19       	mov	r9,1
8000924a:	c4 08       	rjmp	800092ca <__avr32_udiv64+0x12a>
8000924c:	ec 01 11 20 	rsub	r1,r6,32
80009250:	f4 01 0a 49 	lsr	r9,r10,r1
80009254:	f8 06 09 4c 	lsl	r12,r12,r6
80009258:	f6 06 09 48 	lsl	r8,r11,r6
8000925c:	f6 01 0a 41 	lsr	r1,r11,r1
80009260:	f3 e8 10 08 	or	r8,r9,r8
80009264:	f8 03 16 10 	lsr	r3,r12,0x10
80009268:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000926c:	e2 03 0d 00 	divu	r0,r1,r3
80009270:	f0 0b 16 10 	lsr	r11,r8,0x10
80009274:	00 9e       	mov	lr,r0
80009276:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000927a:	e0 05 02 49 	mul	r9,r0,r5
8000927e:	12 3b       	cp.w	r11,r9
80009280:	c0 a2       	brcc	80009294 <__avr32_udiv64+0xf4>
80009282:	20 1e       	sub	lr,1
80009284:	18 0b       	add	r11,r12
80009286:	18 3b       	cp.w	r11,r12
80009288:	c0 63       	brcs	80009294 <__avr32_udiv64+0xf4>
8000928a:	12 3b       	cp.w	r11,r9
8000928c:	f7 be 03 01 	sublo	lr,1
80009290:	f7 dc e3 0b 	addcs	r11,r11,r12
80009294:	12 1b       	sub	r11,r9
80009296:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000929a:	f6 03 0d 02 	divu	r2,r11,r3
8000929e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
800092a2:	04 99       	mov	r9,r2
800092a4:	e4 05 02 4b 	mul	r11,r2,r5
800092a8:	16 38       	cp.w	r8,r11
800092aa:	c0 a2       	brcc	800092be <__avr32_udiv64+0x11e>
800092ac:	20 19       	sub	r9,1
800092ae:	18 08       	add	r8,r12
800092b0:	18 38       	cp.w	r8,r12
800092b2:	c0 63       	brcs	800092be <__avr32_udiv64+0x11e>
800092b4:	16 38       	cp.w	r8,r11
800092b6:	f7 b9 03 01 	sublo	r9,1
800092ba:	f1 dc e3 08 	addcs	r8,r8,r12
800092be:	f4 06 09 43 	lsl	r3,r10,r6
800092c2:	f0 0b 01 0b 	sub	r11,r8,r11
800092c6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
800092ca:	f8 06 16 10 	lsr	r6,r12,0x10
800092ce:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800092d2:	f6 06 0d 00 	divu	r0,r11,r6
800092d6:	e6 0b 16 10 	lsr	r11,r3,0x10
800092da:	00 9a       	mov	r10,r0
800092dc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800092e0:	e0 0e 02 48 	mul	r8,r0,lr
800092e4:	10 3b       	cp.w	r11,r8
800092e6:	c0 a2       	brcc	800092fa <__avr32_udiv64+0x15a>
800092e8:	20 1a       	sub	r10,1
800092ea:	18 0b       	add	r11,r12
800092ec:	18 3b       	cp.w	r11,r12
800092ee:	c0 63       	brcs	800092fa <__avr32_udiv64+0x15a>
800092f0:	10 3b       	cp.w	r11,r8
800092f2:	f7 ba 03 01 	sublo	r10,1
800092f6:	f7 dc e3 0b 	addcs	r11,r11,r12
800092fa:	f6 08 01 01 	sub	r1,r11,r8
800092fe:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80009302:	e2 06 0d 00 	divu	r0,r1,r6
80009306:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000930a:	00 98       	mov	r8,r0
8000930c:	e0 0e 02 4b 	mul	r11,r0,lr
80009310:	16 33       	cp.w	r3,r11
80009312:	c0 82       	brcc	80009322 <__avr32_udiv64+0x182>
80009314:	20 18       	sub	r8,1
80009316:	18 03       	add	r3,r12
80009318:	18 33       	cp.w	r3,r12
8000931a:	c0 43       	brcs	80009322 <__avr32_udiv64+0x182>
8000931c:	16 33       	cp.w	r3,r11
8000931e:	f7 b8 03 01 	sublo	r8,1
80009322:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80009326:	c6 98       	rjmp	800093f8 <__avr32_udiv64+0x258>
80009328:	16 39       	cp.w	r9,r11
8000932a:	e0 8b 00 65 	brhi	800093f4 <__avr32_udiv64+0x254>
8000932e:	f2 09 12 00 	clz	r9,r9
80009332:	c0 b1       	brne	80009348 <__avr32_udiv64+0x1a8>
80009334:	10 3a       	cp.w	r10,r8
80009336:	5f 2a       	srhs	r10
80009338:	1c 3b       	cp.w	r11,lr
8000933a:	5f b8       	srhi	r8
8000933c:	10 4a       	or	r10,r8
8000933e:	f2 0a 18 00 	cp.b	r10,r9
80009342:	c5 90       	breq	800093f4 <__avr32_udiv64+0x254>
80009344:	30 18       	mov	r8,1
80009346:	c5 98       	rjmp	800093f8 <__avr32_udiv64+0x258>
80009348:	f0 09 09 46 	lsl	r6,r8,r9
8000934c:	f2 03 11 20 	rsub	r3,r9,32
80009350:	fc 09 09 4e 	lsl	lr,lr,r9
80009354:	f0 03 0a 48 	lsr	r8,r8,r3
80009358:	f6 09 09 4c 	lsl	r12,r11,r9
8000935c:	f4 03 0a 42 	lsr	r2,r10,r3
80009360:	ef 46 ff f4 	st.w	r7[-12],r6
80009364:	f6 03 0a 43 	lsr	r3,r11,r3
80009368:	18 42       	or	r2,r12
8000936a:	f1 ee 10 0c 	or	r12,r8,lr
8000936e:	f8 01 16 10 	lsr	r1,r12,0x10
80009372:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80009376:	e6 01 0d 04 	divu	r4,r3,r1
8000937a:	e4 03 16 10 	lsr	r3,r2,0x10
8000937e:	08 9e       	mov	lr,r4
80009380:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80009384:	e8 06 02 48 	mul	r8,r4,r6
80009388:	10 33       	cp.w	r3,r8
8000938a:	c0 a2       	brcc	8000939e <__avr32_udiv64+0x1fe>
8000938c:	20 1e       	sub	lr,1
8000938e:	18 03       	add	r3,r12
80009390:	18 33       	cp.w	r3,r12
80009392:	c0 63       	brcs	8000939e <__avr32_udiv64+0x1fe>
80009394:	10 33       	cp.w	r3,r8
80009396:	f7 be 03 01 	sublo	lr,1
8000939a:	e7 dc e3 03 	addcs	r3,r3,r12
8000939e:	10 13       	sub	r3,r8
800093a0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
800093a4:	e6 01 0d 00 	divu	r0,r3,r1
800093a8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800093ac:	00 98       	mov	r8,r0
800093ae:	e0 06 02 46 	mul	r6,r0,r6
800093b2:	0c 3b       	cp.w	r11,r6
800093b4:	c0 a2       	brcc	800093c8 <__avr32_udiv64+0x228>
800093b6:	20 18       	sub	r8,1
800093b8:	18 0b       	add	r11,r12
800093ba:	18 3b       	cp.w	r11,r12
800093bc:	c0 63       	brcs	800093c8 <__avr32_udiv64+0x228>
800093be:	0c 3b       	cp.w	r11,r6
800093c0:	f7 dc e3 0b 	addcs	r11,r11,r12
800093c4:	f7 b8 03 01 	sublo	r8,1
800093c8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800093cc:	ee f4 ff f4 	ld.w	r4,r7[-12]
800093d0:	0c 1b       	sub	r11,r6
800093d2:	f0 04 06 42 	mulu.d	r2,r8,r4
800093d6:	06 95       	mov	r5,r3
800093d8:	16 35       	cp.w	r5,r11
800093da:	e0 8b 00 0a 	brhi	800093ee <__avr32_udiv64+0x24e>
800093de:	5f 0b       	sreq	r11
800093e0:	f4 09 09 49 	lsl	r9,r10,r9
800093e4:	12 32       	cp.w	r2,r9
800093e6:	5f b9       	srhi	r9
800093e8:	f7 e9 00 09 	and	r9,r11,r9
800093ec:	c0 60       	breq	800093f8 <__avr32_udiv64+0x258>
800093ee:	20 18       	sub	r8,1
800093f0:	30 09       	mov	r9,0
800093f2:	c0 38       	rjmp	800093f8 <__avr32_udiv64+0x258>
800093f4:	30 09       	mov	r9,0
800093f6:	12 98       	mov	r8,r9
800093f8:	10 9a       	mov	r10,r8
800093fa:	12 93       	mov	r3,r9
800093fc:	10 92       	mov	r2,r8
800093fe:	12 9b       	mov	r11,r9
80009400:	2f dd       	sub	sp,-12
80009402:	d8 32       	popm	r0-r7,pc

80009404 <atexit>:
80009404:	d4 01       	pushm	lr
80009406:	30 09       	mov	r9,0
80009408:	18 9b       	mov	r11,r12
8000940a:	12 9a       	mov	r10,r9
8000940c:	12 9c       	mov	r12,r9
8000940e:	e0 a0 03 37 	rcall	80009a7c <__register_exitproc>
80009412:	d8 02       	popm	pc

80009414 <exit>:
80009414:	d4 21       	pushm	r4-r7,lr
80009416:	30 0b       	mov	r11,0
80009418:	18 97       	mov	r7,r12
8000941a:	e0 a0 03 83 	rcall	80009b20 <__call_exitprocs>
8000941e:	fe c8 e8 e2 	sub	r8,pc,-5918
80009422:	70 0c       	ld.w	r12,r8[0x0]
80009424:	78 a8       	ld.w	r8,r12[0x28]
80009426:	58 08       	cp.w	r8,0
80009428:	c0 20       	breq	8000942c <exit+0x18>
8000942a:	5d 18       	icall	r8
8000942c:	0e 9c       	mov	r12,r7
8000942e:	e0 a0 03 05 	rcall	80009a38 <_exit>
80009432:	d7 03       	nop

80009434 <free>:
80009434:	d4 01       	pushm	lr
80009436:	e0 68 01 20 	mov	r8,288
8000943a:	18 9b       	mov	r11,r12
8000943c:	70 0c       	ld.w	r12,r8[0x0]
8000943e:	e0 a0 04 25 	rcall	80009c88 <_free_r>
80009442:	d8 02       	popm	pc

80009444 <malloc>:
80009444:	d4 01       	pushm	lr
80009446:	e0 68 01 20 	mov	r8,288
8000944a:	18 9b       	mov	r11,r12
8000944c:	70 0c       	ld.w	r12,r8[0x0]
8000944e:	c0 3c       	rcall	80009454 <_malloc_r>
80009450:	d8 02       	popm	pc
80009452:	d7 03       	nop

80009454 <_malloc_r>:
80009454:	d4 31       	pushm	r0-r7,lr
80009456:	f6 c8 ff f5 	sub	r8,r11,-11
8000945a:	18 95       	mov	r5,r12
8000945c:	10 97       	mov	r7,r8
8000945e:	e0 17 ff f8 	andl	r7,0xfff8
80009462:	59 68       	cp.w	r8,22
80009464:	f9 b7 08 10 	movls	r7,16
80009468:	16 37       	cp.w	r7,r11
8000946a:	5f 38       	srlo	r8
8000946c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80009470:	c0 50       	breq	8000947a <_malloc_r+0x26>
80009472:	30 c8       	mov	r8,12
80009474:	99 38       	st.w	r12[0xc],r8
80009476:	e0 8f 01 f8 	bral	80009866 <_malloc_r+0x412>
8000947a:	fe b0 ec 4f 	rcall	80006d18 <__malloc_lock>
8000947e:	e0 47 01 f7 	cp.w	r7,503
80009482:	e0 8b 00 1d 	brhi	800094bc <_malloc_r+0x68>
80009486:	ee 03 16 03 	lsr	r3,r7,0x3
8000948a:	e0 68 01 24 	mov	r8,292
8000948e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80009492:	70 36       	ld.w	r6,r8[0xc]
80009494:	10 36       	cp.w	r6,r8
80009496:	c0 61       	brne	800094a2 <_malloc_r+0x4e>
80009498:	ec c8 ff f8 	sub	r8,r6,-8
8000949c:	70 36       	ld.w	r6,r8[0xc]
8000949e:	10 36       	cp.w	r6,r8
800094a0:	c0 c0       	breq	800094b8 <_malloc_r+0x64>
800094a2:	6c 18       	ld.w	r8,r6[0x4]
800094a4:	e0 18 ff fc 	andl	r8,0xfffc
800094a8:	6c 3a       	ld.w	r10,r6[0xc]
800094aa:	ec 08 00 09 	add	r9,r6,r8
800094ae:	0a 9c       	mov	r12,r5
800094b0:	6c 28       	ld.w	r8,r6[0x8]
800094b2:	95 28       	st.w	r10[0x8],r8
800094b4:	91 3a       	st.w	r8[0xc],r10
800094b6:	c4 78       	rjmp	80009544 <_malloc_r+0xf0>
800094b8:	2f e3       	sub	r3,-2
800094ba:	c4 d8       	rjmp	80009554 <_malloc_r+0x100>
800094bc:	ee 03 16 09 	lsr	r3,r7,0x9
800094c0:	c0 41       	brne	800094c8 <_malloc_r+0x74>
800094c2:	ee 03 16 03 	lsr	r3,r7,0x3
800094c6:	c2 68       	rjmp	80009512 <_malloc_r+0xbe>
800094c8:	58 43       	cp.w	r3,4
800094ca:	e0 8b 00 06 	brhi	800094d6 <_malloc_r+0x82>
800094ce:	ee 03 16 06 	lsr	r3,r7,0x6
800094d2:	2c 83       	sub	r3,-56
800094d4:	c1 f8       	rjmp	80009512 <_malloc_r+0xbe>
800094d6:	59 43       	cp.w	r3,20
800094d8:	e0 8b 00 04 	brhi	800094e0 <_malloc_r+0x8c>
800094dc:	2a 53       	sub	r3,-91
800094de:	c1 a8       	rjmp	80009512 <_malloc_r+0xbe>
800094e0:	e0 43 00 54 	cp.w	r3,84
800094e4:	e0 8b 00 06 	brhi	800094f0 <_malloc_r+0x9c>
800094e8:	ee 03 16 0c 	lsr	r3,r7,0xc
800094ec:	29 23       	sub	r3,-110
800094ee:	c1 28       	rjmp	80009512 <_malloc_r+0xbe>
800094f0:	e0 43 01 54 	cp.w	r3,340
800094f4:	e0 8b 00 06 	brhi	80009500 <_malloc_r+0xac>
800094f8:	ee 03 16 0f 	lsr	r3,r7,0xf
800094fc:	28 93       	sub	r3,-119
800094fe:	c0 a8       	rjmp	80009512 <_malloc_r+0xbe>
80009500:	e0 43 05 54 	cp.w	r3,1364
80009504:	e0 88 00 04 	brls	8000950c <_malloc_r+0xb8>
80009508:	37 e3       	mov	r3,126
8000950a:	c0 48       	rjmp	80009512 <_malloc_r+0xbe>
8000950c:	ee 03 16 12 	lsr	r3,r7,0x12
80009510:	28 43       	sub	r3,-124
80009512:	e0 6a 01 24 	mov	r10,292
80009516:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000951a:	74 36       	ld.w	r6,r10[0xc]
8000951c:	c1 98       	rjmp	8000954e <_malloc_r+0xfa>
8000951e:	6c 19       	ld.w	r9,r6[0x4]
80009520:	e0 19 ff fc 	andl	r9,0xfffc
80009524:	f2 07 01 0b 	sub	r11,r9,r7
80009528:	58 fb       	cp.w	r11,15
8000952a:	e0 8a 00 04 	brle	80009532 <_malloc_r+0xde>
8000952e:	20 13       	sub	r3,1
80009530:	c1 18       	rjmp	80009552 <_malloc_r+0xfe>
80009532:	6c 38       	ld.w	r8,r6[0xc]
80009534:	58 0b       	cp.w	r11,0
80009536:	c0 b5       	brlt	8000954c <_malloc_r+0xf8>
80009538:	6c 2a       	ld.w	r10,r6[0x8]
8000953a:	ec 09 00 09 	add	r9,r6,r9
8000953e:	0a 9c       	mov	r12,r5
80009540:	91 2a       	st.w	r8[0x8],r10
80009542:	95 38       	st.w	r10[0xc],r8
80009544:	72 18       	ld.w	r8,r9[0x4]
80009546:	a1 a8       	sbr	r8,0x0
80009548:	93 18       	st.w	r9[0x4],r8
8000954a:	cb c8       	rjmp	800096c2 <_malloc_r+0x26e>
8000954c:	10 96       	mov	r6,r8
8000954e:	14 36       	cp.w	r6,r10
80009550:	ce 71       	brne	8000951e <_malloc_r+0xca>
80009552:	2f f3       	sub	r3,-1
80009554:	e0 6a 01 24 	mov	r10,292
80009558:	f4 cc ff f8 	sub	r12,r10,-8
8000955c:	78 26       	ld.w	r6,r12[0x8]
8000955e:	18 36       	cp.w	r6,r12
80009560:	c6 c0       	breq	80009638 <_malloc_r+0x1e4>
80009562:	6c 19       	ld.w	r9,r6[0x4]
80009564:	e0 19 ff fc 	andl	r9,0xfffc
80009568:	f2 07 01 08 	sub	r8,r9,r7
8000956c:	58 f8       	cp.w	r8,15
8000956e:	e0 89 00 8f 	brgt	8000968c <_malloc_r+0x238>
80009572:	99 3c       	st.w	r12[0xc],r12
80009574:	99 2c       	st.w	r12[0x8],r12
80009576:	58 08       	cp.w	r8,0
80009578:	c0 55       	brlt	80009582 <_malloc_r+0x12e>
8000957a:	ec 09 00 09 	add	r9,r6,r9
8000957e:	0a 9c       	mov	r12,r5
80009580:	ce 2b       	rjmp	80009544 <_malloc_r+0xf0>
80009582:	e0 49 01 ff 	cp.w	r9,511
80009586:	e0 8b 00 13 	brhi	800095ac <_malloc_r+0x158>
8000958a:	a3 99       	lsr	r9,0x3
8000958c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80009590:	70 2b       	ld.w	r11,r8[0x8]
80009592:	8d 38       	st.w	r6[0xc],r8
80009594:	8d 2b       	st.w	r6[0x8],r11
80009596:	97 36       	st.w	r11[0xc],r6
80009598:	91 26       	st.w	r8[0x8],r6
8000959a:	a3 49       	asr	r9,0x2
8000959c:	74 18       	ld.w	r8,r10[0x4]
8000959e:	30 1b       	mov	r11,1
800095a0:	f6 09 09 49 	lsl	r9,r11,r9
800095a4:	f1 e9 10 09 	or	r9,r8,r9
800095a8:	95 19       	st.w	r10[0x4],r9
800095aa:	c4 78       	rjmp	80009638 <_malloc_r+0x1e4>
800095ac:	f2 0a 16 09 	lsr	r10,r9,0x9
800095b0:	58 4a       	cp.w	r10,4
800095b2:	e0 8b 00 07 	brhi	800095c0 <_malloc_r+0x16c>
800095b6:	f2 0a 16 06 	lsr	r10,r9,0x6
800095ba:	2c 8a       	sub	r10,-56
800095bc:	c2 08       	rjmp	800095fc <_malloc_r+0x1a8>
800095be:	d7 03       	nop
800095c0:	59 4a       	cp.w	r10,20
800095c2:	e0 8b 00 04 	brhi	800095ca <_malloc_r+0x176>
800095c6:	2a 5a       	sub	r10,-91
800095c8:	c1 a8       	rjmp	800095fc <_malloc_r+0x1a8>
800095ca:	e0 4a 00 54 	cp.w	r10,84
800095ce:	e0 8b 00 06 	brhi	800095da <_malloc_r+0x186>
800095d2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800095d6:	29 2a       	sub	r10,-110
800095d8:	c1 28       	rjmp	800095fc <_malloc_r+0x1a8>
800095da:	e0 4a 01 54 	cp.w	r10,340
800095de:	e0 8b 00 06 	brhi	800095ea <_malloc_r+0x196>
800095e2:	f2 0a 16 0f 	lsr	r10,r9,0xf
800095e6:	28 9a       	sub	r10,-119
800095e8:	c0 a8       	rjmp	800095fc <_malloc_r+0x1a8>
800095ea:	e0 4a 05 54 	cp.w	r10,1364
800095ee:	e0 88 00 04 	brls	800095f6 <_malloc_r+0x1a2>
800095f2:	37 ea       	mov	r10,126
800095f4:	c0 48       	rjmp	800095fc <_malloc_r+0x1a8>
800095f6:	f2 0a 16 12 	lsr	r10,r9,0x12
800095fa:	28 4a       	sub	r10,-124
800095fc:	e0 6b 01 24 	mov	r11,292
80009600:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80009604:	68 28       	ld.w	r8,r4[0x8]
80009606:	08 38       	cp.w	r8,r4
80009608:	c0 e1       	brne	80009624 <_malloc_r+0x1d0>
8000960a:	76 19       	ld.w	r9,r11[0x4]
8000960c:	a3 4a       	asr	r10,0x2
8000960e:	30 1e       	mov	lr,1
80009610:	fc 0a 09 4a 	lsl	r10,lr,r10
80009614:	f3 ea 10 0a 	or	r10,r9,r10
80009618:	10 99       	mov	r9,r8
8000961a:	97 1a       	st.w	r11[0x4],r10
8000961c:	c0 a8       	rjmp	80009630 <_malloc_r+0x1dc>
8000961e:	70 28       	ld.w	r8,r8[0x8]
80009620:	08 38       	cp.w	r8,r4
80009622:	c0 60       	breq	8000962e <_malloc_r+0x1da>
80009624:	70 1a       	ld.w	r10,r8[0x4]
80009626:	e0 1a ff fc 	andl	r10,0xfffc
8000962a:	14 39       	cp.w	r9,r10
8000962c:	cf 93       	brcs	8000961e <_malloc_r+0x1ca>
8000962e:	70 39       	ld.w	r9,r8[0xc]
80009630:	8d 39       	st.w	r6[0xc],r9
80009632:	8d 28       	st.w	r6[0x8],r8
80009634:	91 36       	st.w	r8[0xc],r6
80009636:	93 26       	st.w	r9[0x8],r6
80009638:	e6 08 14 02 	asr	r8,r3,0x2
8000963c:	30 1b       	mov	r11,1
8000963e:	e0 64 01 24 	mov	r4,292
80009642:	f6 08 09 4b 	lsl	r11,r11,r8
80009646:	68 18       	ld.w	r8,r4[0x4]
80009648:	10 3b       	cp.w	r11,r8
8000964a:	e0 8b 00 6b 	brhi	80009720 <_malloc_r+0x2cc>
8000964e:	f7 e8 00 09 	and	r9,r11,r8
80009652:	c0 b1       	brne	80009668 <_malloc_r+0x214>
80009654:	e0 13 ff fc 	andl	r3,0xfffc
80009658:	a1 7b       	lsl	r11,0x1
8000965a:	2f c3       	sub	r3,-4
8000965c:	c0 38       	rjmp	80009662 <_malloc_r+0x20e>
8000965e:	2f c3       	sub	r3,-4
80009660:	a1 7b       	lsl	r11,0x1
80009662:	f7 e8 00 09 	and	r9,r11,r8
80009666:	cf c0       	breq	8000965e <_malloc_r+0x20a>
80009668:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000966c:	06 92       	mov	r2,r3
8000966e:	1c 91       	mov	r1,lr
80009670:	62 36       	ld.w	r6,r1[0xc]
80009672:	c2 e8       	rjmp	800096ce <_malloc_r+0x27a>
80009674:	6c 1a       	ld.w	r10,r6[0x4]
80009676:	e0 1a ff fc 	andl	r10,0xfffc
8000967a:	f4 07 01 08 	sub	r8,r10,r7
8000967e:	58 f8       	cp.w	r8,15
80009680:	e0 8a 00 15 	brle	800096aa <_malloc_r+0x256>
80009684:	6c 3a       	ld.w	r10,r6[0xc]
80009686:	6c 29       	ld.w	r9,r6[0x8]
80009688:	95 29       	st.w	r10[0x8],r9
8000968a:	93 3a       	st.w	r9[0xc],r10
8000968c:	0e 99       	mov	r9,r7
8000968e:	ec 07 00 07 	add	r7,r6,r7
80009692:	a1 a9       	sbr	r9,0x0
80009694:	99 37       	st.w	r12[0xc],r7
80009696:	99 27       	st.w	r12[0x8],r7
80009698:	8d 19       	st.w	r6[0x4],r9
8000969a:	ee 08 09 08 	st.w	r7[r8],r8
8000969e:	8f 2c       	st.w	r7[0x8],r12
800096a0:	8f 3c       	st.w	r7[0xc],r12
800096a2:	a1 a8       	sbr	r8,0x0
800096a4:	0a 9c       	mov	r12,r5
800096a6:	8f 18       	st.w	r7[0x4],r8
800096a8:	c0 d8       	rjmp	800096c2 <_malloc_r+0x26e>
800096aa:	6c 39       	ld.w	r9,r6[0xc]
800096ac:	58 08       	cp.w	r8,0
800096ae:	c0 f5       	brlt	800096cc <_malloc_r+0x278>
800096b0:	ec 0a 00 0a 	add	r10,r6,r10
800096b4:	74 18       	ld.w	r8,r10[0x4]
800096b6:	a1 a8       	sbr	r8,0x0
800096b8:	0a 9c       	mov	r12,r5
800096ba:	95 18       	st.w	r10[0x4],r8
800096bc:	6c 28       	ld.w	r8,r6[0x8]
800096be:	93 28       	st.w	r9[0x8],r8
800096c0:	91 39       	st.w	r8[0xc],r9
800096c2:	fe b0 eb 31 	rcall	80006d24 <__malloc_unlock>
800096c6:	ec cc ff f8 	sub	r12,r6,-8
800096ca:	d8 32       	popm	r0-r7,pc
800096cc:	12 96       	mov	r6,r9
800096ce:	02 36       	cp.w	r6,r1
800096d0:	cd 21       	brne	80009674 <_malloc_r+0x220>
800096d2:	2f f2       	sub	r2,-1
800096d4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800096d8:	c0 30       	breq	800096de <_malloc_r+0x28a>
800096da:	2f 81       	sub	r1,-8
800096dc:	cc ab       	rjmp	80009670 <_malloc_r+0x21c>
800096de:	1c 98       	mov	r8,lr
800096e0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800096e4:	c0 81       	brne	800096f4 <_malloc_r+0x2a0>
800096e6:	68 19       	ld.w	r9,r4[0x4]
800096e8:	f6 08 11 ff 	rsub	r8,r11,-1
800096ec:	f3 e8 00 08 	and	r8,r9,r8
800096f0:	89 18       	st.w	r4[0x4],r8
800096f2:	c0 78       	rjmp	80009700 <_malloc_r+0x2ac>
800096f4:	f0 c9 00 08 	sub	r9,r8,8
800096f8:	20 13       	sub	r3,1
800096fa:	70 08       	ld.w	r8,r8[0x0]
800096fc:	12 38       	cp.w	r8,r9
800096fe:	cf 10       	breq	800096e0 <_malloc_r+0x28c>
80009700:	a1 7b       	lsl	r11,0x1
80009702:	68 18       	ld.w	r8,r4[0x4]
80009704:	10 3b       	cp.w	r11,r8
80009706:	e0 8b 00 0d 	brhi	80009720 <_malloc_r+0x2cc>
8000970a:	58 0b       	cp.w	r11,0
8000970c:	c0 a0       	breq	80009720 <_malloc_r+0x2cc>
8000970e:	04 93       	mov	r3,r2
80009710:	c0 38       	rjmp	80009716 <_malloc_r+0x2c2>
80009712:	2f c3       	sub	r3,-4
80009714:	a1 7b       	lsl	r11,0x1
80009716:	f7 e8 00 09 	and	r9,r11,r8
8000971a:	ca 71       	brne	80009668 <_malloc_r+0x214>
8000971c:	cf bb       	rjmp	80009712 <_malloc_r+0x2be>
8000971e:	d7 03       	nop
80009720:	68 23       	ld.w	r3,r4[0x8]
80009722:	66 12       	ld.w	r2,r3[0x4]
80009724:	e0 12 ff fc 	andl	r2,0xfffc
80009728:	0e 32       	cp.w	r2,r7
8000972a:	5f 39       	srlo	r9
8000972c:	e4 07 01 08 	sub	r8,r2,r7
80009730:	58 f8       	cp.w	r8,15
80009732:	5f aa       	srle	r10
80009734:	f5 e9 10 09 	or	r9,r10,r9
80009738:	e0 80 00 98 	breq	80009868 <_malloc_r+0x414>
8000973c:	e0 68 08 44 	mov	r8,2116
80009740:	70 01       	ld.w	r1,r8[0x0]
80009742:	e0 68 05 30 	mov	r8,1328
80009746:	2f 01       	sub	r1,-16
80009748:	70 08       	ld.w	r8,r8[0x0]
8000974a:	0e 01       	add	r1,r7
8000974c:	5b f8       	cp.w	r8,-1
8000974e:	c0 40       	breq	80009756 <_malloc_r+0x302>
80009750:	28 11       	sub	r1,-127
80009752:	e0 11 ff 80 	andl	r1,0xff80
80009756:	02 9b       	mov	r11,r1
80009758:	0a 9c       	mov	r12,r5
8000975a:	c4 3d       	rcall	800099e0 <_sbrk_r>
8000975c:	18 96       	mov	r6,r12
8000975e:	5b fc       	cp.w	r12,-1
80009760:	c7 40       	breq	80009848 <_malloc_r+0x3f4>
80009762:	e6 02 00 08 	add	r8,r3,r2
80009766:	10 3c       	cp.w	r12,r8
80009768:	c0 32       	brcc	8000976e <_malloc_r+0x31a>
8000976a:	08 33       	cp.w	r3,r4
8000976c:	c6 e1       	brne	80009848 <_malloc_r+0x3f4>
8000976e:	e0 6a 08 48 	mov	r10,2120
80009772:	74 09       	ld.w	r9,r10[0x0]
80009774:	e2 09 00 09 	add	r9,r1,r9
80009778:	95 09       	st.w	r10[0x0],r9
8000977a:	10 36       	cp.w	r6,r8
8000977c:	c0 a1       	brne	80009790 <_malloc_r+0x33c>
8000977e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80009782:	c0 71       	brne	80009790 <_malloc_r+0x33c>
80009784:	e2 02 00 02 	add	r2,r1,r2
80009788:	68 28       	ld.w	r8,r4[0x8]
8000978a:	a1 a2       	sbr	r2,0x0
8000978c:	91 12       	st.w	r8[0x4],r2
8000978e:	c4 e8       	rjmp	8000982a <_malloc_r+0x3d6>
80009790:	e0 6a 05 30 	mov	r10,1328
80009794:	74 0b       	ld.w	r11,r10[0x0]
80009796:	5b fb       	cp.w	r11,-1
80009798:	c0 31       	brne	8000979e <_malloc_r+0x34a>
8000979a:	95 06       	st.w	r10[0x0],r6
8000979c:	c0 78       	rjmp	800097aa <_malloc_r+0x356>
8000979e:	ec 09 00 09 	add	r9,r6,r9
800097a2:	e0 6a 08 48 	mov	r10,2120
800097a6:	10 19       	sub	r9,r8
800097a8:	95 09       	st.w	r10[0x0],r9
800097aa:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800097ae:	f0 09 11 08 	rsub	r9,r8,8
800097b2:	58 08       	cp.w	r8,0
800097b4:	f2 08 17 10 	movne	r8,r9
800097b8:	ed d8 e1 06 	addne	r6,r6,r8
800097bc:	28 08       	sub	r8,-128
800097be:	ec 01 00 01 	add	r1,r6,r1
800097c2:	0a 9c       	mov	r12,r5
800097c4:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800097c8:	f0 01 01 01 	sub	r1,r8,r1
800097cc:	02 9b       	mov	r11,r1
800097ce:	c0 9d       	rcall	800099e0 <_sbrk_r>
800097d0:	e0 68 08 48 	mov	r8,2120
800097d4:	5b fc       	cp.w	r12,-1
800097d6:	ec 0c 17 00 	moveq	r12,r6
800097da:	f9 b1 00 00 	moveq	r1,0
800097de:	70 09       	ld.w	r9,r8[0x0]
800097e0:	0c 1c       	sub	r12,r6
800097e2:	89 26       	st.w	r4[0x8],r6
800097e4:	02 0c       	add	r12,r1
800097e6:	12 01       	add	r1,r9
800097e8:	a1 ac       	sbr	r12,0x0
800097ea:	91 01       	st.w	r8[0x0],r1
800097ec:	8d 1c       	st.w	r6[0x4],r12
800097ee:	08 33       	cp.w	r3,r4
800097f0:	c1 d0       	breq	8000982a <_malloc_r+0x3d6>
800097f2:	58 f2       	cp.w	r2,15
800097f4:	e0 8b 00 05 	brhi	800097fe <_malloc_r+0x3aa>
800097f8:	30 18       	mov	r8,1
800097fa:	8d 18       	st.w	r6[0x4],r8
800097fc:	c2 68       	rjmp	80009848 <_malloc_r+0x3f4>
800097fe:	30 59       	mov	r9,5
80009800:	20 c2       	sub	r2,12
80009802:	e0 12 ff f8 	andl	r2,0xfff8
80009806:	e6 02 00 08 	add	r8,r3,r2
8000980a:	91 29       	st.w	r8[0x8],r9
8000980c:	91 19       	st.w	r8[0x4],r9
8000980e:	66 18       	ld.w	r8,r3[0x4]
80009810:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009814:	e5 e8 10 08 	or	r8,r2,r8
80009818:	87 18       	st.w	r3[0x4],r8
8000981a:	58 f2       	cp.w	r2,15
8000981c:	e0 88 00 07 	brls	8000982a <_malloc_r+0x3d6>
80009820:	e6 cb ff f8 	sub	r11,r3,-8
80009824:	0a 9c       	mov	r12,r5
80009826:	e0 a0 02 31 	rcall	80009c88 <_free_r>
8000982a:	e0 69 08 40 	mov	r9,2112
8000982e:	72 0a       	ld.w	r10,r9[0x0]
80009830:	e0 68 08 48 	mov	r8,2120
80009834:	70 08       	ld.w	r8,r8[0x0]
80009836:	14 38       	cp.w	r8,r10
80009838:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000983c:	e0 69 08 3c 	mov	r9,2108
80009840:	72 0a       	ld.w	r10,r9[0x0]
80009842:	14 38       	cp.w	r8,r10
80009844:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80009848:	68 28       	ld.w	r8,r4[0x8]
8000984a:	70 18       	ld.w	r8,r8[0x4]
8000984c:	e0 18 ff fc 	andl	r8,0xfffc
80009850:	0e 38       	cp.w	r8,r7
80009852:	5f 39       	srlo	r9
80009854:	0e 18       	sub	r8,r7
80009856:	58 f8       	cp.w	r8,15
80009858:	5f aa       	srle	r10
8000985a:	f5 e9 10 09 	or	r9,r10,r9
8000985e:	c0 50       	breq	80009868 <_malloc_r+0x414>
80009860:	0a 9c       	mov	r12,r5
80009862:	fe b0 ea 61 	rcall	80006d24 <__malloc_unlock>
80009866:	d8 3a       	popm	r0-r7,pc,r12=0
80009868:	68 26       	ld.w	r6,r4[0x8]
8000986a:	a1 a8       	sbr	r8,0x0
8000986c:	0e 99       	mov	r9,r7
8000986e:	a1 a9       	sbr	r9,0x0
80009870:	8d 19       	st.w	r6[0x4],r9
80009872:	ec 07 00 07 	add	r7,r6,r7
80009876:	0a 9c       	mov	r12,r5
80009878:	89 27       	st.w	r4[0x8],r7
8000987a:	8f 18       	st.w	r7[0x4],r8
8000987c:	fe b0 ea 54 	rcall	80006d24 <__malloc_unlock>
80009880:	ec cc ff f8 	sub	r12,r6,-8
80009884:	d8 32       	popm	r0-r7,pc
80009886:	d7 03       	nop

80009888 <memcpy>:
80009888:	58 8a       	cp.w	r10,8
8000988a:	c2 f5       	brlt	800098e8 <memcpy+0x60>
8000988c:	f9 eb 10 09 	or	r9,r12,r11
80009890:	e2 19 00 03 	andl	r9,0x3,COH
80009894:	e0 81 00 97 	brne	800099c2 <memcpy+0x13a>
80009898:	e0 4a 00 20 	cp.w	r10,32
8000989c:	c3 b4       	brge	80009912 <memcpy+0x8a>
8000989e:	f4 08 14 02 	asr	r8,r10,0x2
800098a2:	f0 09 11 08 	rsub	r9,r8,8
800098a6:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800098aa:	76 69       	ld.w	r9,r11[0x18]
800098ac:	99 69       	st.w	r12[0x18],r9
800098ae:	76 59       	ld.w	r9,r11[0x14]
800098b0:	99 59       	st.w	r12[0x14],r9
800098b2:	76 49       	ld.w	r9,r11[0x10]
800098b4:	99 49       	st.w	r12[0x10],r9
800098b6:	76 39       	ld.w	r9,r11[0xc]
800098b8:	99 39       	st.w	r12[0xc],r9
800098ba:	76 29       	ld.w	r9,r11[0x8]
800098bc:	99 29       	st.w	r12[0x8],r9
800098be:	76 19       	ld.w	r9,r11[0x4]
800098c0:	99 19       	st.w	r12[0x4],r9
800098c2:	76 09       	ld.w	r9,r11[0x0]
800098c4:	99 09       	st.w	r12[0x0],r9
800098c6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800098ca:	f8 08 00 28 	add	r8,r12,r8<<0x2
800098ce:	e0 1a 00 03 	andl	r10,0x3
800098d2:	f4 0a 11 04 	rsub	r10,r10,4
800098d6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800098da:	17 a9       	ld.ub	r9,r11[0x2]
800098dc:	b0 a9       	st.b	r8[0x2],r9
800098de:	17 99       	ld.ub	r9,r11[0x1]
800098e0:	b0 99       	st.b	r8[0x1],r9
800098e2:	17 89       	ld.ub	r9,r11[0x0]
800098e4:	b0 89       	st.b	r8[0x0],r9
800098e6:	5e fc       	retal	r12
800098e8:	f4 0a 11 09 	rsub	r10,r10,9
800098ec:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800098f0:	17 f9       	ld.ub	r9,r11[0x7]
800098f2:	b8 f9       	st.b	r12[0x7],r9
800098f4:	17 e9       	ld.ub	r9,r11[0x6]
800098f6:	b8 e9       	st.b	r12[0x6],r9
800098f8:	17 d9       	ld.ub	r9,r11[0x5]
800098fa:	b8 d9       	st.b	r12[0x5],r9
800098fc:	17 c9       	ld.ub	r9,r11[0x4]
800098fe:	b8 c9       	st.b	r12[0x4],r9
80009900:	17 b9       	ld.ub	r9,r11[0x3]
80009902:	b8 b9       	st.b	r12[0x3],r9
80009904:	17 a9       	ld.ub	r9,r11[0x2]
80009906:	b8 a9       	st.b	r12[0x2],r9
80009908:	17 99       	ld.ub	r9,r11[0x1]
8000990a:	b8 99       	st.b	r12[0x1],r9
8000990c:	17 89       	ld.ub	r9,r11[0x0]
8000990e:	b8 89       	st.b	r12[0x0],r9
80009910:	5e fc       	retal	r12
80009912:	eb cd 40 c0 	pushm	r6-r7,lr
80009916:	18 99       	mov	r9,r12
80009918:	22 0a       	sub	r10,32
8000991a:	b7 07       	ld.d	r6,r11++
8000991c:	b3 26       	st.d	r9++,r6
8000991e:	b7 07       	ld.d	r6,r11++
80009920:	b3 26       	st.d	r9++,r6
80009922:	b7 07       	ld.d	r6,r11++
80009924:	b3 26       	st.d	r9++,r6
80009926:	b7 07       	ld.d	r6,r11++
80009928:	b3 26       	st.d	r9++,r6
8000992a:	22 0a       	sub	r10,32
8000992c:	cf 74       	brge	8000991a <memcpy+0x92>
8000992e:	2f 0a       	sub	r10,-16
80009930:	c0 65       	brlt	8000993c <memcpy+0xb4>
80009932:	b7 07       	ld.d	r6,r11++
80009934:	b3 26       	st.d	r9++,r6
80009936:	b7 07       	ld.d	r6,r11++
80009938:	b3 26       	st.d	r9++,r6
8000993a:	21 0a       	sub	r10,16
8000993c:	5c 3a       	neg	r10
8000993e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80009942:	d7 03       	nop
80009944:	d7 03       	nop
80009946:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000994a:	f3 66 00 0e 	st.b	r9[14],r6
8000994e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80009952:	f3 66 00 0d 	st.b	r9[13],r6
80009956:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000995a:	f3 66 00 0c 	st.b	r9[12],r6
8000995e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80009962:	f3 66 00 0b 	st.b	r9[11],r6
80009966:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000996a:	f3 66 00 0a 	st.b	r9[10],r6
8000996e:	f7 36 00 09 	ld.ub	r6,r11[9]
80009972:	f3 66 00 09 	st.b	r9[9],r6
80009976:	f7 36 00 08 	ld.ub	r6,r11[8]
8000997a:	f3 66 00 08 	st.b	r9[8],r6
8000997e:	f7 36 00 07 	ld.ub	r6,r11[7]
80009982:	f3 66 00 07 	st.b	r9[7],r6
80009986:	f7 36 00 06 	ld.ub	r6,r11[6]
8000998a:	f3 66 00 06 	st.b	r9[6],r6
8000998e:	f7 36 00 05 	ld.ub	r6,r11[5]
80009992:	f3 66 00 05 	st.b	r9[5],r6
80009996:	f7 36 00 04 	ld.ub	r6,r11[4]
8000999a:	f3 66 00 04 	st.b	r9[4],r6
8000999e:	f7 36 00 03 	ld.ub	r6,r11[3]
800099a2:	f3 66 00 03 	st.b	r9[3],r6
800099a6:	f7 36 00 02 	ld.ub	r6,r11[2]
800099aa:	f3 66 00 02 	st.b	r9[2],r6
800099ae:	f7 36 00 01 	ld.ub	r6,r11[1]
800099b2:	f3 66 00 01 	st.b	r9[1],r6
800099b6:	f7 36 00 00 	ld.ub	r6,r11[0]
800099ba:	f3 66 00 00 	st.b	r9[0],r6
800099be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800099c2:	20 1a       	sub	r10,1
800099c4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800099c8:	f8 0a 0b 09 	st.b	r12[r10],r9
800099cc:	cf b1       	brne	800099c2 <memcpy+0x13a>
800099ce:	5e fc       	retal	r12

800099d0 <memset>:
800099d0:	18 98       	mov	r8,r12
800099d2:	c0 38       	rjmp	800099d8 <memset+0x8>
800099d4:	10 cb       	st.b	r8++,r11
800099d6:	20 1a       	sub	r10,1
800099d8:	58 0a       	cp.w	r10,0
800099da:	cf d1       	brne	800099d4 <memset+0x4>
800099dc:	5e fc       	retal	r12
800099de:	d7 03       	nop

800099e0 <_sbrk_r>:
800099e0:	d4 21       	pushm	r4-r7,lr
800099e2:	30 08       	mov	r8,0
800099e4:	18 97       	mov	r7,r12
800099e6:	e0 66 10 04 	mov	r6,4100
800099ea:	16 9c       	mov	r12,r11
800099ec:	8d 08       	st.w	r6[0x0],r8
800099ee:	c2 bc       	rcall	80009a44 <_sbrk>
800099f0:	5b fc       	cp.w	r12,-1
800099f2:	c0 51       	brne	800099fc <_sbrk_r+0x1c>
800099f4:	6c 08       	ld.w	r8,r6[0x0]
800099f6:	58 08       	cp.w	r8,0
800099f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
800099fc:	d8 22       	popm	r4-r7,pc
800099fe:	d7 03       	nop

80009a00 <strncat>:
80009a00:	d4 01       	pushm	lr
80009a02:	30 09       	mov	r9,0
80009a04:	18 98       	mov	r8,r12
80009a06:	c0 28       	rjmp	80009a0a <strncat+0xa>
80009a08:	2f f8       	sub	r8,-1
80009a0a:	11 8e       	ld.ub	lr,r8[0x0]
80009a0c:	f2 0e 18 00 	cp.b	lr,r9
80009a10:	cf c1       	brne	80009a08 <strncat+0x8>
80009a12:	c0 78       	rjmp	80009a20 <strncat+0x20>
80009a14:	20 1a       	sub	r10,1
80009a16:	2f f8       	sub	r8,-1
80009a18:	2f fb       	sub	r11,-1
80009a1a:	58 0a       	cp.w	r10,0
80009a1c:	f1 fa 0e 00 	st.beq	r8[0x0],r10
80009a20:	58 0a       	cp.w	r10,0
80009a22:	c0 50       	breq	80009a2c <strncat+0x2c>
80009a24:	17 89       	ld.ub	r9,r11[0x0]
80009a26:	b0 89       	st.b	r8[0x0],r9
80009a28:	58 09       	cp.w	r9,0
80009a2a:	cf 51       	brne	80009a14 <strncat+0x14>
80009a2c:	d8 02       	popm	pc

80009a2e <_init_argv>:
80009a2e:	30 e8       	mov	r8,14
80009a30:	d6 73       	breakpoint
80009a32:	3f fc       	mov	r12,-1
80009a34:	35 8b       	mov	r11,88
80009a36:	5e fc       	retal	r12

80009a38 <_exit>:
80009a38:	30 d8       	mov	r8,13
80009a3a:	d6 73       	breakpoint
80009a3c:	3f fc       	mov	r12,-1
80009a3e:	35 8b       	mov	r11,88
80009a40:	c0 08       	rjmp	80009a40 <_exit+0x8>
80009a42:	d7 03       	nop

80009a44 <_sbrk>:
80009a44:	d4 01       	pushm	lr
80009a46:	e0 68 08 70 	mov	r8,2160
80009a4a:	70 09       	ld.w	r9,r8[0x0]
80009a4c:	58 09       	cp.w	r9,0
80009a4e:	c0 41       	brne	80009a56 <_sbrk+0x12>
80009a50:	e0 69 10 08 	mov	r9,4104
80009a54:	91 09       	st.w	r8[0x0],r9
80009a56:	e0 69 08 70 	mov	r9,2160
80009a5a:	e0 6a f0 00 	mov	r10,61440
80009a5e:	72 08       	ld.w	r8,r9[0x0]
80009a60:	f0 0c 00 0c 	add	r12,r8,r12
80009a64:	14 3c       	cp.w	r12,r10
80009a66:	e0 8b 00 04 	brhi	80009a6e <_sbrk+0x2a>
80009a6a:	93 0c       	st.w	r9[0x0],r12
80009a6c:	c0 58       	rjmp	80009a76 <_sbrk+0x32>
80009a6e:	cb fc       	rcall	80009bec <__errno>
80009a70:	30 c8       	mov	r8,12
80009a72:	99 08       	st.w	r12[0x0],r8
80009a74:	3f f8       	mov	r8,-1
80009a76:	10 9c       	mov	r12,r8
80009a78:	d8 02       	popm	pc
80009a7a:	d7 03       	nop

80009a7c <__register_exitproc>:
80009a7c:	d4 31       	pushm	r0-r7,lr
80009a7e:	fe c8 ef 42 	sub	r8,pc,-4286
80009a82:	70 03       	ld.w	r3,r8[0x0]
80009a84:	67 24       	ld.w	r4,r3[0x48]
80009a86:	e6 c8 ff b4 	sub	r8,r3,-76
80009a8a:	58 04       	cp.w	r4,0
80009a8c:	f0 04 17 00 	moveq	r4,r8
80009a90:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80009a94:	18 97       	mov	r7,r12
80009a96:	16 96       	mov	r6,r11
80009a98:	14 95       	mov	r5,r10
80009a9a:	12 92       	mov	r2,r9
80009a9c:	68 18       	ld.w	r8,r4[0x4]
80009a9e:	59 f8       	cp.w	r8,31
80009aa0:	e0 8a 00 0e 	brle	80009abc <__register_exitproc+0x40>
80009aa4:	e0 6c 00 8c 	mov	r12,140
80009aa8:	fe b0 fc ce 	rcall	80009444 <malloc>
80009aac:	18 94       	mov	r4,r12
80009aae:	c3 80       	breq	80009b1e <__register_exitproc+0xa2>
80009ab0:	67 28       	ld.w	r8,r3[0x48]
80009ab2:	99 08       	st.w	r12[0x0],r8
80009ab4:	e7 4c 00 48 	st.w	r3[72],r12
80009ab8:	30 08       	mov	r8,0
80009aba:	99 18       	st.w	r12[0x4],r8
80009abc:	58 07       	cp.w	r7,0
80009abe:	c2 70       	breq	80009b0c <__register_exitproc+0x90>
80009ac0:	e8 fc 00 88 	ld.w	r12,r4[136]
80009ac4:	58 0c       	cp.w	r12,0
80009ac6:	c0 d1       	brne	80009ae0 <__register_exitproc+0x64>
80009ac8:	e0 6c 01 08 	mov	r12,264
80009acc:	fe b0 fc bc 	rcall	80009444 <malloc>
80009ad0:	c2 70       	breq	80009b1e <__register_exitproc+0xa2>
80009ad2:	30 08       	mov	r8,0
80009ad4:	e9 4c 00 88 	st.w	r4[136],r12
80009ad8:	f9 48 01 04 	st.w	r12[260],r8
80009adc:	f9 48 01 00 	st.w	r12[256],r8
80009ae0:	68 18       	ld.w	r8,r4[0x4]
80009ae2:	f0 c9 ff e0 	sub	r9,r8,-32
80009ae6:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80009aea:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80009aee:	30 1a       	mov	r10,1
80009af0:	f8 f9 01 00 	ld.w	r9,r12[256]
80009af4:	f4 08 09 48 	lsl	r8,r10,r8
80009af8:	10 49       	or	r9,r8
80009afa:	f9 49 01 00 	st.w	r12[256],r9
80009afe:	58 27       	cp.w	r7,2
80009b00:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80009b04:	f3 d8 e0 38 	oreq	r8,r9,r8
80009b08:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80009b0c:	68 18       	ld.w	r8,r4[0x4]
80009b0e:	30 0c       	mov	r12,0
80009b10:	f0 c9 ff ff 	sub	r9,r8,-1
80009b14:	2f e8       	sub	r8,-2
80009b16:	89 19       	st.w	r4[0x4],r9
80009b18:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80009b1c:	d8 32       	popm	r0-r7,pc
80009b1e:	dc 3a       	popm	r0-r7,pc,r12=-1

80009b20 <__call_exitprocs>:
80009b20:	d4 31       	pushm	r0-r7,lr
80009b22:	20 3d       	sub	sp,12
80009b24:	fe c8 ef e8 	sub	r8,pc,-4120
80009b28:	50 2c       	stdsp	sp[0x8],r12
80009b2a:	70 08       	ld.w	r8,r8[0x0]
80009b2c:	16 91       	mov	r1,r11
80009b2e:	50 08       	stdsp	sp[0x0],r8
80009b30:	2b 88       	sub	r8,-72
80009b32:	50 18       	stdsp	sp[0x4],r8
80009b34:	40 0a       	lddsp	r10,sp[0x0]
80009b36:	40 14       	lddsp	r4,sp[0x4]
80009b38:	75 27       	ld.w	r7,r10[0x48]
80009b3a:	c5 58       	rjmp	80009be4 <__call_exitprocs+0xc4>
80009b3c:	6e 15       	ld.w	r5,r7[0x4]
80009b3e:	ee f6 00 88 	ld.w	r6,r7[136]
80009b42:	ea c2 ff ff 	sub	r2,r5,-1
80009b46:	20 15       	sub	r5,1
80009b48:	ee 02 00 22 	add	r2,r7,r2<<0x2
80009b4c:	ec 05 00 23 	add	r3,r6,r5<<0x2
80009b50:	c3 58       	rjmp	80009bba <__call_exitprocs+0x9a>
80009b52:	58 01       	cp.w	r1,0
80009b54:	c0 70       	breq	80009b62 <__call_exitprocs+0x42>
80009b56:	58 06       	cp.w	r6,0
80009b58:	c2 e0       	breq	80009bb4 <__call_exitprocs+0x94>
80009b5a:	e6 f8 00 80 	ld.w	r8,r3[128]
80009b5e:	02 38       	cp.w	r8,r1
80009b60:	c2 a1       	brne	80009bb4 <__call_exitprocs+0x94>
80009b62:	6e 19       	ld.w	r9,r7[0x4]
80009b64:	64 08       	ld.w	r8,r2[0x0]
80009b66:	20 19       	sub	r9,1
80009b68:	12 35       	cp.w	r5,r9
80009b6a:	ef f5 0a 01 	st.weq	r7[0x4],r5
80009b6e:	f9 b9 01 00 	movne	r9,0
80009b72:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80009b76:	58 08       	cp.w	r8,0
80009b78:	c1 e0       	breq	80009bb4 <__call_exitprocs+0x94>
80009b7a:	6e 10       	ld.w	r0,r7[0x4]
80009b7c:	58 06       	cp.w	r6,0
80009b7e:	c0 90       	breq	80009b90 <__call_exitprocs+0x70>
80009b80:	30 1a       	mov	r10,1
80009b82:	f4 05 09 49 	lsl	r9,r10,r5
80009b86:	ec fa 01 00 	ld.w	r10,r6[256]
80009b8a:	f3 ea 00 0a 	and	r10,r9,r10
80009b8e:	c0 31       	brne	80009b94 <__call_exitprocs+0x74>
80009b90:	5d 18       	icall	r8
80009b92:	c0 b8       	rjmp	80009ba8 <__call_exitprocs+0x88>
80009b94:	ec fa 01 04 	ld.w	r10,r6[260]
80009b98:	66 0b       	ld.w	r11,r3[0x0]
80009b9a:	14 69       	and	r9,r10
80009b9c:	c0 41       	brne	80009ba4 <__call_exitprocs+0x84>
80009b9e:	40 2c       	lddsp	r12,sp[0x8]
80009ba0:	5d 18       	icall	r8
80009ba2:	c0 38       	rjmp	80009ba8 <__call_exitprocs+0x88>
80009ba4:	16 9c       	mov	r12,r11
80009ba6:	5d 18       	icall	r8
80009ba8:	6e 18       	ld.w	r8,r7[0x4]
80009baa:	10 30       	cp.w	r0,r8
80009bac:	cc 41       	brne	80009b34 <__call_exitprocs+0x14>
80009bae:	68 08       	ld.w	r8,r4[0x0]
80009bb0:	0e 38       	cp.w	r8,r7
80009bb2:	cc 11       	brne	80009b34 <__call_exitprocs+0x14>
80009bb4:	20 15       	sub	r5,1
80009bb6:	20 43       	sub	r3,4
80009bb8:	20 42       	sub	r2,4
80009bba:	58 05       	cp.w	r5,0
80009bbc:	cc b4       	brge	80009b52 <__call_exitprocs+0x32>
80009bbe:	6e 18       	ld.w	r8,r7[0x4]
80009bc0:	58 08       	cp.w	r8,0
80009bc2:	c0 f1       	brne	80009be0 <__call_exitprocs+0xc0>
80009bc4:	6e 08       	ld.w	r8,r7[0x0]
80009bc6:	58 08       	cp.w	r8,0
80009bc8:	c0 c0       	breq	80009be0 <__call_exitprocs+0xc0>
80009bca:	89 08       	st.w	r4[0x0],r8
80009bcc:	58 06       	cp.w	r6,0
80009bce:	c0 40       	breq	80009bd6 <__call_exitprocs+0xb6>
80009bd0:	0c 9c       	mov	r12,r6
80009bd2:	fe b0 fc 31 	rcall	80009434 <free>
80009bd6:	0e 9c       	mov	r12,r7
80009bd8:	fe b0 fc 2e 	rcall	80009434 <free>
80009bdc:	68 07       	ld.w	r7,r4[0x0]
80009bde:	c0 38       	rjmp	80009be4 <__call_exitprocs+0xc4>
80009be0:	0e 94       	mov	r4,r7
80009be2:	6e 07       	ld.w	r7,r7[0x0]
80009be4:	58 07       	cp.w	r7,0
80009be6:	ca b1       	brne	80009b3c <__call_exitprocs+0x1c>
80009be8:	2f dd       	sub	sp,-12
80009bea:	d8 32       	popm	r0-r7,pc

80009bec <__errno>:
80009bec:	e0 68 01 20 	mov	r8,288
80009bf0:	70 0c       	ld.w	r12,r8[0x0]
80009bf2:	2f 4c       	sub	r12,-12
80009bf4:	5e fc       	retal	r12
80009bf6:	d7 03       	nop

80009bf8 <_malloc_trim_r>:
80009bf8:	d4 21       	pushm	r4-r7,lr
80009bfa:	16 95       	mov	r5,r11
80009bfc:	18 97       	mov	r7,r12
80009bfe:	fe b0 e8 8d 	rcall	80006d18 <__malloc_lock>
80009c02:	e0 64 01 24 	mov	r4,292
80009c06:	68 28       	ld.w	r8,r4[0x8]
80009c08:	70 16       	ld.w	r6,r8[0x4]
80009c0a:	e0 16 ff fc 	andl	r6,0xfffc
80009c0e:	ec c8 ff 91 	sub	r8,r6,-111
80009c12:	f0 05 01 05 	sub	r5,r8,r5
80009c16:	e0 15 ff 80 	andl	r5,0xff80
80009c1a:	ea c5 00 80 	sub	r5,r5,128
80009c1e:	e0 45 00 7f 	cp.w	r5,127
80009c22:	e0 8a 00 22 	brle	80009c66 <_malloc_trim_r+0x6e>
80009c26:	30 0b       	mov	r11,0
80009c28:	0e 9c       	mov	r12,r7
80009c2a:	cd be       	rcall	800099e0 <_sbrk_r>
80009c2c:	68 28       	ld.w	r8,r4[0x8]
80009c2e:	0c 08       	add	r8,r6
80009c30:	10 3c       	cp.w	r12,r8
80009c32:	c1 a1       	brne	80009c66 <_malloc_trim_r+0x6e>
80009c34:	ea 0b 11 00 	rsub	r11,r5,0
80009c38:	0e 9c       	mov	r12,r7
80009c3a:	cd 3e       	rcall	800099e0 <_sbrk_r>
80009c3c:	5b fc       	cp.w	r12,-1
80009c3e:	c1 81       	brne	80009c6e <_malloc_trim_r+0x76>
80009c40:	30 0b       	mov	r11,0
80009c42:	0e 9c       	mov	r12,r7
80009c44:	cc ee       	rcall	800099e0 <_sbrk_r>
80009c46:	68 28       	ld.w	r8,r4[0x8]
80009c48:	f8 08 01 09 	sub	r9,r12,r8
80009c4c:	58 f9       	cp.w	r9,15
80009c4e:	e0 8a 00 0c 	brle	80009c66 <_malloc_trim_r+0x6e>
80009c52:	a1 a9       	sbr	r9,0x0
80009c54:	91 19       	st.w	r8[0x4],r9
80009c56:	e0 68 05 30 	mov	r8,1328
80009c5a:	70 09       	ld.w	r9,r8[0x0]
80009c5c:	e0 68 08 48 	mov	r8,2120
80009c60:	f8 09 01 09 	sub	r9,r12,r9
80009c64:	91 09       	st.w	r8[0x0],r9
80009c66:	0e 9c       	mov	r12,r7
80009c68:	fe b0 e8 5e 	rcall	80006d24 <__malloc_unlock>
80009c6c:	d8 2a       	popm	r4-r7,pc,r12=0
80009c6e:	68 28       	ld.w	r8,r4[0x8]
80009c70:	0a 16       	sub	r6,r5
80009c72:	a1 a6       	sbr	r6,0x0
80009c74:	91 16       	st.w	r8[0x4],r6
80009c76:	e0 68 08 48 	mov	r8,2120
80009c7a:	70 09       	ld.w	r9,r8[0x0]
80009c7c:	0a 19       	sub	r9,r5
80009c7e:	0e 9c       	mov	r12,r7
80009c80:	91 09       	st.w	r8[0x0],r9
80009c82:	fe b0 e8 51 	rcall	80006d24 <__malloc_unlock>
80009c86:	da 2a       	popm	r4-r7,pc,r12=1

80009c88 <_free_r>:
80009c88:	d4 21       	pushm	r4-r7,lr
80009c8a:	16 96       	mov	r6,r11
80009c8c:	18 97       	mov	r7,r12
80009c8e:	58 0b       	cp.w	r11,0
80009c90:	e0 80 00 c0 	breq	80009e10 <_free_r+0x188>
80009c94:	fe b0 e8 42 	rcall	80006d18 <__malloc_lock>
80009c98:	20 86       	sub	r6,8
80009c9a:	e0 6a 01 24 	mov	r10,292
80009c9e:	6c 18       	ld.w	r8,r6[0x4]
80009ca0:	74 2e       	ld.w	lr,r10[0x8]
80009ca2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009ca6:	a1 c8       	cbr	r8,0x0
80009ca8:	ec 08 00 09 	add	r9,r6,r8
80009cac:	72 1b       	ld.w	r11,r9[0x4]
80009cae:	e0 1b ff fc 	andl	r11,0xfffc
80009cb2:	1c 39       	cp.w	r9,lr
80009cb4:	c1 e1       	brne	80009cf0 <_free_r+0x68>
80009cb6:	f6 08 00 08 	add	r8,r11,r8
80009cba:	58 0c       	cp.w	r12,0
80009cbc:	c0 81       	brne	80009ccc <_free_r+0x44>
80009cbe:	6c 09       	ld.w	r9,r6[0x0]
80009cc0:	12 16       	sub	r6,r9
80009cc2:	12 08       	add	r8,r9
80009cc4:	6c 3b       	ld.w	r11,r6[0xc]
80009cc6:	6c 29       	ld.w	r9,r6[0x8]
80009cc8:	97 29       	st.w	r11[0x8],r9
80009cca:	93 3b       	st.w	r9[0xc],r11
80009ccc:	10 99       	mov	r9,r8
80009cce:	95 26       	st.w	r10[0x8],r6
80009cd0:	a1 a9       	sbr	r9,0x0
80009cd2:	8d 19       	st.w	r6[0x4],r9
80009cd4:	e0 69 05 2c 	mov	r9,1324
80009cd8:	72 09       	ld.w	r9,r9[0x0]
80009cda:	12 38       	cp.w	r8,r9
80009cdc:	c0 63       	brcs	80009ce8 <_free_r+0x60>
80009cde:	e0 68 08 44 	mov	r8,2116
80009ce2:	0e 9c       	mov	r12,r7
80009ce4:	70 0b       	ld.w	r11,r8[0x0]
80009ce6:	c8 9f       	rcall	80009bf8 <_malloc_trim_r>
80009ce8:	0e 9c       	mov	r12,r7
80009cea:	fe b0 e8 1d 	rcall	80006d24 <__malloc_unlock>
80009cee:	d8 22       	popm	r4-r7,pc
80009cf0:	93 1b       	st.w	r9[0x4],r11
80009cf2:	58 0c       	cp.w	r12,0
80009cf4:	c0 30       	breq	80009cfa <_free_r+0x72>
80009cf6:	30 0c       	mov	r12,0
80009cf8:	c1 08       	rjmp	80009d18 <_free_r+0x90>
80009cfa:	6c 0e       	ld.w	lr,r6[0x0]
80009cfc:	f4 c5 ff f8 	sub	r5,r10,-8
80009d00:	1c 16       	sub	r6,lr
80009d02:	1c 08       	add	r8,lr
80009d04:	6c 2e       	ld.w	lr,r6[0x8]
80009d06:	0a 3e       	cp.w	lr,r5
80009d08:	f9 bc 00 01 	moveq	r12,1
80009d0c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009d10:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009d14:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009d18:	f2 0b 00 0e 	add	lr,r9,r11
80009d1c:	7c 1e       	ld.w	lr,lr[0x4]
80009d1e:	ed be 00 00 	bld	lr,0x0
80009d22:	c1 40       	breq	80009d4a <_free_r+0xc2>
80009d24:	16 08       	add	r8,r11
80009d26:	58 0c       	cp.w	r12,0
80009d28:	c0 d1       	brne	80009d42 <_free_r+0xba>
80009d2a:	e0 6e 01 24 	mov	lr,292
80009d2e:	72 2b       	ld.w	r11,r9[0x8]
80009d30:	2f 8e       	sub	lr,-8
80009d32:	1c 3b       	cp.w	r11,lr
80009d34:	c0 71       	brne	80009d42 <_free_r+0xba>
80009d36:	97 36       	st.w	r11[0xc],r6
80009d38:	97 26       	st.w	r11[0x8],r6
80009d3a:	8d 2b       	st.w	r6[0x8],r11
80009d3c:	8d 3b       	st.w	r6[0xc],r11
80009d3e:	30 1c       	mov	r12,1
80009d40:	c0 58       	rjmp	80009d4a <_free_r+0xc2>
80009d42:	72 2b       	ld.w	r11,r9[0x8]
80009d44:	72 39       	ld.w	r9,r9[0xc]
80009d46:	93 2b       	st.w	r9[0x8],r11
80009d48:	97 39       	st.w	r11[0xc],r9
80009d4a:	10 99       	mov	r9,r8
80009d4c:	ec 08 09 08 	st.w	r6[r8],r8
80009d50:	a1 a9       	sbr	r9,0x0
80009d52:	8d 19       	st.w	r6[0x4],r9
80009d54:	58 0c       	cp.w	r12,0
80009d56:	c5 a1       	brne	80009e0a <_free_r+0x182>
80009d58:	e0 48 01 ff 	cp.w	r8,511
80009d5c:	e0 8b 00 13 	brhi	80009d82 <_free_r+0xfa>
80009d60:	a3 98       	lsr	r8,0x3
80009d62:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009d66:	72 2b       	ld.w	r11,r9[0x8]
80009d68:	8d 39       	st.w	r6[0xc],r9
80009d6a:	8d 2b       	st.w	r6[0x8],r11
80009d6c:	97 36       	st.w	r11[0xc],r6
80009d6e:	93 26       	st.w	r9[0x8],r6
80009d70:	a3 48       	asr	r8,0x2
80009d72:	74 19       	ld.w	r9,r10[0x4]
80009d74:	30 1b       	mov	r11,1
80009d76:	f6 08 09 48 	lsl	r8,r11,r8
80009d7a:	f3 e8 10 08 	or	r8,r9,r8
80009d7e:	95 18       	st.w	r10[0x4],r8
80009d80:	c4 58       	rjmp	80009e0a <_free_r+0x182>
80009d82:	f0 0b 16 09 	lsr	r11,r8,0x9
80009d86:	58 4b       	cp.w	r11,4
80009d88:	e0 8b 00 06 	brhi	80009d94 <_free_r+0x10c>
80009d8c:	f0 0b 16 06 	lsr	r11,r8,0x6
80009d90:	2c 8b       	sub	r11,-56
80009d92:	c2 08       	rjmp	80009dd2 <_free_r+0x14a>
80009d94:	59 4b       	cp.w	r11,20
80009d96:	e0 8b 00 04 	brhi	80009d9e <_free_r+0x116>
80009d9a:	2a 5b       	sub	r11,-91
80009d9c:	c1 b8       	rjmp	80009dd2 <_free_r+0x14a>
80009d9e:	e0 4b 00 54 	cp.w	r11,84
80009da2:	e0 8b 00 06 	brhi	80009dae <_free_r+0x126>
80009da6:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009daa:	29 2b       	sub	r11,-110
80009dac:	c1 38       	rjmp	80009dd2 <_free_r+0x14a>
80009dae:	e0 4b 01 54 	cp.w	r11,340
80009db2:	e0 8b 00 06 	brhi	80009dbe <_free_r+0x136>
80009db6:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009dba:	28 9b       	sub	r11,-119
80009dbc:	c0 b8       	rjmp	80009dd2 <_free_r+0x14a>
80009dbe:	e0 4b 05 54 	cp.w	r11,1364
80009dc2:	e0 88 00 05 	brls	80009dcc <_free_r+0x144>
80009dc6:	37 eb       	mov	r11,126
80009dc8:	c0 58       	rjmp	80009dd2 <_free_r+0x14a>
80009dca:	d7 03       	nop
80009dcc:	f0 0b 16 12 	lsr	r11,r8,0x12
80009dd0:	28 4b       	sub	r11,-124
80009dd2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009dd6:	78 29       	ld.w	r9,r12[0x8]
80009dd8:	18 39       	cp.w	r9,r12
80009dda:	c0 e1       	brne	80009df6 <_free_r+0x16e>
80009ddc:	74 18       	ld.w	r8,r10[0x4]
80009dde:	a3 4b       	asr	r11,0x2
80009de0:	30 1c       	mov	r12,1
80009de2:	f8 0b 09 4b 	lsl	r11,r12,r11
80009de6:	f1 eb 10 0b 	or	r11,r8,r11
80009dea:	12 98       	mov	r8,r9
80009dec:	95 1b       	st.w	r10[0x4],r11
80009dee:	c0 a8       	rjmp	80009e02 <_free_r+0x17a>
80009df0:	72 29       	ld.w	r9,r9[0x8]
80009df2:	18 39       	cp.w	r9,r12
80009df4:	c0 60       	breq	80009e00 <_free_r+0x178>
80009df6:	72 1a       	ld.w	r10,r9[0x4]
80009df8:	e0 1a ff fc 	andl	r10,0xfffc
80009dfc:	14 38       	cp.w	r8,r10
80009dfe:	cf 93       	brcs	80009df0 <_free_r+0x168>
80009e00:	72 38       	ld.w	r8,r9[0xc]
80009e02:	8d 38       	st.w	r6[0xc],r8
80009e04:	8d 29       	st.w	r6[0x8],r9
80009e06:	93 36       	st.w	r9[0xc],r6
80009e08:	91 26       	st.w	r8[0x8],r6
80009e0a:	0e 9c       	mov	r12,r7
80009e0c:	fe b0 e7 8c 	rcall	80006d24 <__malloc_unlock>
80009e10:	d8 22       	popm	r4-r7,pc
80009e12:	d7 03       	nop

80009e14 <__do_global_ctors_aux>:
80009e14:	d4 21       	pushm	r4-r7,lr
80009e16:	30 c7       	mov	r7,12
80009e18:	c0 28       	rjmp	80009e1c <__do_global_ctors_aux+0x8>
80009e1a:	5d 18       	icall	r8
80009e1c:	20 47       	sub	r7,4
80009e1e:	6e 08       	ld.w	r8,r7[0x0]
80009e20:	5b f8       	cp.w	r8,-1
80009e22:	cf c1       	brne	80009e1a <__do_global_ctors_aux+0x6>
80009e24:	d8 22       	popm	r4-r7,pc
80009e26:	d7 03       	nop

Disassembly of section .exception:

8000a000 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000a000:	c0 08       	rjmp	8000a000 <_evba>
	...

8000a004 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000a004:	c0 08       	rjmp	8000a004 <_handle_TLB_Multiple_Hit>
	...

8000a008 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000a008:	c0 08       	rjmp	8000a008 <_handle_Bus_Error_Data_Fetch>
	...

8000a00c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000a00c:	c0 08       	rjmp	8000a00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000a010 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000a010:	c0 08       	rjmp	8000a010 <_handle_NMI>
	...

8000a014 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000a014:	c0 08       	rjmp	8000a014 <_handle_Instruction_Address>
	...

8000a018 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000a018:	c0 08       	rjmp	8000a018 <_handle_ITLB_Protection>
	...

8000a01c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000a01c:	c0 08       	rjmp	8000a01c <_handle_Breakpoint>
	...

8000a020 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000a020:	c0 08       	rjmp	8000a020 <_handle_Illegal_Opcode>
	...

8000a024 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000a024:	c0 08       	rjmp	8000a024 <_handle_Unimplemented_Instruction>
	...

8000a028 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000a028:	c0 08       	rjmp	8000a028 <_handle_Privilege_Violation>
	...

8000a02c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000a02c:	c0 08       	rjmp	8000a02c <_handle_Floating_Point>
	...

8000a030 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000a030:	c0 08       	rjmp	8000a030 <_handle_Coprocessor_Absent>
	...

8000a034 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000a034:	c0 08       	rjmp	8000a034 <_handle_Data_Address_Read>
	...

8000a038 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000a038:	c0 08       	rjmp	8000a038 <_handle_Data_Address_Write>
	...

8000a03c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000a03c:	c0 08       	rjmp	8000a03c <_handle_DTLB_Protection_Read>
	...

8000a040 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000a040:	c0 08       	rjmp	8000a040 <_handle_DTLB_Protection_Write>
	...

8000a044 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000a044:	c0 08       	rjmp	8000a044 <_handle_DTLB_Modified>
	...

8000a050 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000a050:	c0 08       	rjmp	8000a050 <_handle_ITLB_Miss>
	...

8000a060 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000a060:	c0 08       	rjmp	8000a060 <_handle_DTLB_Miss_Read>
	...

8000a070 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000a070:	c0 08       	rjmp	8000a070 <_handle_DTLB_Miss_Write>
	...

8000a100 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000a100:	fe cf 35 30 	sub	pc,pc,13616

8000a104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000a104:	30 0c       	mov	r12,0
8000a106:	fe b0 f6 67 	rcall	80008dd4 <_get_interrupt_handler>
8000a10a:	58 0c       	cp.w	r12,0
8000a10c:	f8 0f 17 10 	movne	pc,r12
8000a110:	d6 03       	rete

8000a112 <_int1>:
8000a112:	30 1c       	mov	r12,1
8000a114:	fe b0 f6 60 	rcall	80008dd4 <_get_interrupt_handler>
8000a118:	58 0c       	cp.w	r12,0
8000a11a:	f8 0f 17 10 	movne	pc,r12
8000a11e:	d6 03       	rete

8000a120 <_int2>:
8000a120:	30 2c       	mov	r12,2
8000a122:	fe b0 f6 59 	rcall	80008dd4 <_get_interrupt_handler>
8000a126:	58 0c       	cp.w	r12,0
8000a128:	f8 0f 17 10 	movne	pc,r12
8000a12c:	d6 03       	rete

8000a12e <_int3>:
8000a12e:	30 3c       	mov	r12,3
8000a130:	fe b0 f6 52 	rcall	80008dd4 <_get_interrupt_handler>
8000a134:	58 0c       	cp.w	r12,0
8000a136:	f8 0f 17 10 	movne	pc,r12
8000a13a:	d6 03       	rete
8000a13c:	d7 03       	nop
8000a13e:	d7 03       	nop
8000a140:	d7 03       	nop
8000a142:	d7 03       	nop
8000a144:	d7 03       	nop
8000a146:	d7 03       	nop
8000a148:	d7 03       	nop
8000a14a:	d7 03       	nop
8000a14c:	d7 03       	nop
8000a14e:	d7 03       	nop
8000a150:	d7 03       	nop
8000a152:	d7 03       	nop
8000a154:	d7 03       	nop
8000a156:	d7 03       	nop
8000a158:	d7 03       	nop
8000a15a:	d7 03       	nop
8000a15c:	d7 03       	nop
8000a15e:	d7 03       	nop
8000a160:	d7 03       	nop
8000a162:	d7 03       	nop
8000a164:	d7 03       	nop
8000a166:	d7 03       	nop
8000a168:	d7 03       	nop
8000a16a:	d7 03       	nop
8000a16c:	d7 03       	nop
8000a16e:	d7 03       	nop
8000a170:	d7 03       	nop
8000a172:	d7 03       	nop
8000a174:	d7 03       	nop
8000a176:	d7 03       	nop
8000a178:	d7 03       	nop
8000a17a:	d7 03       	nop
8000a17c:	d7 03       	nop
8000a17e:	d7 03       	nop
8000a180:	d7 03       	nop
8000a182:	d7 03       	nop
8000a184:	d7 03       	nop
8000a186:	d7 03       	nop
8000a188:	d7 03       	nop
8000a18a:	d7 03       	nop
8000a18c:	d7 03       	nop
8000a18e:	d7 03       	nop
8000a190:	d7 03       	nop
8000a192:	d7 03       	nop
8000a194:	d7 03       	nop
8000a196:	d7 03       	nop
8000a198:	d7 03       	nop
8000a19a:	d7 03       	nop
8000a19c:	d7 03       	nop
8000a19e:	d7 03       	nop
8000a1a0:	d7 03       	nop
8000a1a2:	d7 03       	nop
8000a1a4:	d7 03       	nop
8000a1a6:	d7 03       	nop
8000a1a8:	d7 03       	nop
8000a1aa:	d7 03       	nop
8000a1ac:	d7 03       	nop
8000a1ae:	d7 03       	nop
8000a1b0:	d7 03       	nop
8000a1b2:	d7 03       	nop
8000a1b4:	d7 03       	nop
8000a1b6:	d7 03       	nop
8000a1b8:	d7 03       	nop
8000a1ba:	d7 03       	nop
8000a1bc:	d7 03       	nop
8000a1be:	d7 03       	nop
8000a1c0:	d7 03       	nop
8000a1c2:	d7 03       	nop
8000a1c4:	d7 03       	nop
8000a1c6:	d7 03       	nop
8000a1c8:	d7 03       	nop
8000a1ca:	d7 03       	nop
8000a1cc:	d7 03       	nop
8000a1ce:	d7 03       	nop
8000a1d0:	d7 03       	nop
8000a1d2:	d7 03       	nop
8000a1d4:	d7 03       	nop
8000a1d6:	d7 03       	nop
8000a1d8:	d7 03       	nop
8000a1da:	d7 03       	nop
8000a1dc:	d7 03       	nop
8000a1de:	d7 03       	nop
8000a1e0:	d7 03       	nop
8000a1e2:	d7 03       	nop
8000a1e4:	d7 03       	nop
8000a1e6:	d7 03       	nop
8000a1e8:	d7 03       	nop
8000a1ea:	d7 03       	nop
8000a1ec:	d7 03       	nop
8000a1ee:	d7 03       	nop
8000a1f0:	d7 03       	nop
8000a1f2:	d7 03       	nop
8000a1f4:	d7 03       	nop
8000a1f6:	d7 03       	nop
8000a1f8:	d7 03       	nop
8000a1fa:	d7 03       	nop
8000a1fc:	d7 03       	nop
8000a1fe:	d7 03       	nop

Disassembly of section .fini:

8000a200 <_fini>:
8000a200:	eb cd 40 40 	pushm	r6,lr
8000a204:	48 26       	lddpc	r6,8000a20c <_fini+0xc>
8000a206:	1e 26       	rsub	r6,pc
8000a208:	c0 48       	rjmp	8000a210 <_fini+0x10>
8000a20a:	d7 03       	nop
8000a20c:	80 00       	ld.sh	r0,r0[0x0]
8000a20e:	a1 ea       	*unknown*
8000a210:	fe b0 bf 3e 	rcall	8000208c <__do_global_dtors_aux>
8000a214:	e3 cd 80 40 	ldm	sp++,r6,pc
