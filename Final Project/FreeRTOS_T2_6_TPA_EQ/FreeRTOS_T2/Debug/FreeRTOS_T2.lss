
FreeRTOS_T2.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000040a8  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80006200  80006200  00006600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00030a40  80006400  80006400  00006800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000054c  00000008  80036e40  00037408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000554  8003738c  00037954  2**0
                  ALLOC
  8 .bss          00000500  00000558  00000558  00000000  2**2
                  ALLOC
  9 .heap         0000e5a8  00000a58  00000a58  00000000  2**0
                  ALLOC
 10 .comment      00000053  00000000  00000000  00037954  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000ef8  00000000  00000000  000379a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002550  00000000  00000000  000388a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00018662  00000000  00000000  0003adf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00003641  00000000  00000000  00053452  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000b87a  00000000  00000000  00056a93  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000274c  00000000  00000000  00062310  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000052b2  00000000  00000000  00064a5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00006afe  00000000  00000000  00069d0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00f1fede  00000000  00000000  0007080c  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000f00  00000000  00000000  00f906f0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf bd e8 	sub	pc,pc,-16920

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf dd ec 	sub	pc,pc,-8724

Disassembly of section .text:

80002008 <tpa6130_abdac_tx_pdca_int_handler>:
80002008:	d4 01       	pushm	lr
8000200a:	30 0c       	mov	r12,0
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
8000200c:	f0 1f 00 13 	mcall	80002058 <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002010:	e2 1c 00 02 	andl	r12,0x2,COH
80002014:	c0 d0       	breq	8000202e <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002016:	30 0c       	mov	r12,0
80002018:	f0 1f 00 11 	mcall	8000205c <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
8000201c:	49 18       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
8000201e:	70 28       	ld.w	r8,r8[0x8]
80002020:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002024:	c0 50       	breq	8000202e <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
80002026:	48 f8       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002028:	70 18       	ld.w	r8,r8[0x4]
8000202a:	30 1c       	mov	r12,1
8000202c:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
8000202e:	30 0c       	mov	r12,0
80002030:	f0 1f 00 0a 	mcall	80002058 <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002034:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002038:	c0 d0       	breq	80002052 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
8000203a:	30 0c       	mov	r12,0
8000203c:	f0 1f 00 0a 	mcall	80002064 <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002040:	48 88       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002042:	70 28       	ld.w	r8,r8[0x8]
80002044:	e2 18 00 02 	andl	r8,0x2,COH
80002048:	c0 50       	breq	80002052 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
8000204a:	48 68       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
8000204c:	70 18       	ld.w	r8,r8[0x4]
8000204e:	30 2c       	mov	r12,2
80002050:	5d 18       	icall	r8
  }
}
80002052:	d4 02       	popm	lr
80002054:	d6 03       	rete
80002056:	00 00       	add	r0,r0
80002058:	80 00       	ld.sh	r0,r0[0x0]
8000205a:	26 a0       	sub	r0,106
8000205c:	80 00       	ld.sh	r0,r0[0x0]
8000205e:	26 d8       	sub	r8,109
80002060:	00 00       	add	r0,r0
80002062:	05 58       	ld.sh	r8,--r2
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	26 b0       	sub	r0,107

80002068 <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80002068:	d4 21       	pushm	r4-r7,lr
8000206a:	20 5d       	sub	sp,20
8000206c:	18 94       	mov	r4,r12
8000206e:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80002070:	f7 ec 10 88 	or	r8,r11,r12<<0x8
80002074:	fb 58 00 12 	st.h	sp[18],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80002078:	30 08       	mov	r8,0
8000207a:	30 09       	mov	r9,0
8000207c:	fa e9 00 00 	st.d	sp[0],r8
80002080:	36 08       	mov	r8,96
80002082:	ba 88       	st.b	sp[0x0],r8
80002084:	fa c8 ff ee 	sub	r8,sp,-18
80002088:	50 28       	stdsp	sp[0x8],r8
8000208a:	30 28       	mov	r8,2
8000208c:	50 38       	stdsp	sp[0xc],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
8000208e:	1a 96       	mov	r6,sp
80002090:	fe 77 2c 00 	mov	r7,-54272
80002094:	1a 9b       	mov	r11,sp
80002096:	0e 9c       	mov	r12,r7
80002098:	f0 1f 00 05 	mcall	800020ac <tpa6130_write_data+0x44>
  }
  while( twi_status != TWI_SUCCESS );
8000209c:	cf c1       	brne	80002094 <tpa6130_write_data+0x2c>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
8000209e:	48 58       	lddpc	r8,800020b0 <tpa6130_write_data+0x48>
800020a0:	f0 04 00 04 	add	r4,r8,r4
800020a4:	e9 65 ff ff 	st.b	r4[-1],r5
}
800020a8:	2f bd       	sub	sp,-20
800020aa:	d8 22       	popm	r4-r7,pc
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	28 98       	sub	r8,-119
800020b0:	00 00       	add	r0,r0
800020b2:	00 08       	add	r8,r0

800020b4 <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
800020b4:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
800020b6:	33 f8       	mov	r8,63
800020b8:	f0 0c 18 00 	cp.b	r12,r8
800020bc:	e0 8a 00 04 	brle	800020c4 <tpa6130_set_volume+0x10>
800020c0:	33 fb       	mov	r11,63
800020c2:	c0 b8       	rjmp	800020d8 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
800020c4:	30 08       	mov	r8,0
800020c6:	f0 0c 18 00 	cp.b	r12,r8
800020ca:	e0 89 00 05 	brgt	800020d4 <tpa6130_set_volume+0x20>
800020ce:	e0 6b 00 c0 	mov	r11,192
800020d2:	c0 38       	rjmp	800020d8 <tpa6130_set_volume+0x24>
800020d4:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
800020d8:	30 2c       	mov	r12,2
800020da:	f0 1f 00 02 	mcall	800020e0 <tpa6130_set_volume+0x2c>
}
800020de:	d8 02       	popm	pc
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	20 68       	sub	r8,6

800020e4 <tpa6130_dac_output>:
 * which contain two (16-bit) samples, one for each channel.
 *
 * \note The DACs must have been started beforehand.
 */
bool tpa6130_dac_output(void *sample_buffer, size_t sample_length)
{
800020e4:	eb cd 40 c0 	pushm	r6-r7,lr
800020e8:	18 96       	mov	r6,r12
800020ea:	16 97       	mov	r7,r11
  //int global_interrupt_enabled;

  /*Wait until the PDCA loads the reload value to its transfer
   * counter register(TCRR=0). Then we are ready to set up a new
   * transfer */
  if(!(pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) &
800020ec:	30 0c       	mov	r12,0
800020ee:	f0 1f 00 11 	mcall	80002130 <tpa6130_dac_output+0x4c>
800020f2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800020f6:	c1 b0       	breq	8000212c <tpa6130_dac_output+0x48>
  {
    return false;
  }

  /* Nothing to do if we get no data. */
  if(sample_length)
800020f8:	58 07       	cp.w	r7,0
800020fa:	c1 80       	breq	8000212a <tpa6130_dac_output+0x46>
    //if((global_interrupt_enabled = cpu_irq_is_enabled()))
    //  cpu_irq_disable();

    /*FIXME This assumes a stereo 16-bit sample size */
    // one sample here consists of 2x16-bit (16-bit stereo)
    pdca_reload_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800020fc:	0e 9a       	mov	r10,r7
800020fe:	0c 9b       	mov	r11,r6
80002100:	30 0c       	mov	r12,0
80002102:	f0 1f 00 0d 	mcall	80002134 <tpa6130_dac_output+0x50>
    //if(global_interrupt_enabled)
    //  cpu_irq_enable();

    /*TODO enable transfer complete interrupt
     * Is it possible to move this to setup or other places?*/
    if(tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80002106:	48 d8       	lddpc	r8,80002138 <tpa6130_dac_output+0x54>
80002108:	70 28       	ld.w	r8,r8[0x8]
8000210a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000210e:	c0 40       	breq	80002116 <tpa6130_dac_output+0x32>
      pdca_enable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002110:	30 0c       	mov	r12,0
80002112:	f0 1f 00 0b 	mcall	8000213c <tpa6130_dac_output+0x58>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002116:	48 98       	lddpc	r8,80002138 <tpa6130_dac_output+0x54>
80002118:	70 28       	ld.w	r8,r8[0x8]
8000211a:	e2 18 00 02 	andl	r8,0x2,COH
8000211e:	c0 60       	breq	8000212a <tpa6130_dac_output+0x46>
      pdca_enable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002120:	30 0c       	mov	r12,0
80002122:	f0 1f 00 08 	mcall	80002140 <tpa6130_dac_output+0x5c>
80002126:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000212a:	30 1c       	mov	r12,1
  }
  return true;
}
8000212c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	26 a0       	sub	r0,106
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	27 00       	sub	r0,112
80002138:	00 00       	add	r0,r0
8000213a:	05 58       	ld.sh	r8,--r2
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	26 80       	sub	r0,104
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	26 90       	sub	r0,105

80002144 <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
80002144:	d4 01       	pushm	lr
80002146:	20 5d       	sub	sp,20
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
80002148:	58 0b       	cp.w	r11,0
8000214a:	c0 90       	breq	8000215c <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
8000214c:	48 f8       	lddpc	r8,80002188 <tpa6130_read_data+0x44>
8000214e:	f0 0c 00 0c 	add	r12,r8,r12
80002152:	f9 38 ff ff 	ld.ub	r8,r12[-1]
80002156:	fb 68 00 13 	st.b	sp[19],r8
8000215a:	c1 38       	rjmp	80002180 <tpa6130_read_data+0x3c>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr[0] = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
8000215c:	30 08       	mov	r8,0
8000215e:	30 09       	mov	r9,0
80002160:	fa e9 00 00 	st.d	sp[0],r8
80002164:	36 08       	mov	r8,96
80002166:	ba 88       	st.b	sp[0x0],r8
80002168:	ba 9c       	st.b	sp[0x1],r12
8000216a:	30 18       	mov	r8,1
8000216c:	50 18       	stdsp	sp[0x4],r8
8000216e:	fa c9 ff ed 	sub	r9,sp,-19
80002172:	50 29       	stdsp	sp[0x8],r9
80002174:	50 38       	stdsp	sp[0xc],r8
    twi_master_read(TPA6130_TWI, &twi_package);
80002176:	1a 9b       	mov	r11,sp
80002178:	fe 7c 2c 00 	mov	r12,-54272
8000217c:	f0 1f 00 04 	mcall	8000218c <tpa6130_read_data+0x48>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80002180:	fb 3c 00 13 	ld.ub	r12,sp[19]
80002184:	2f bd       	sub	sp,-20
80002186:	d8 02       	popm	pc
80002188:	00 00       	add	r0,r0
8000218a:	00 08       	add	r8,r0
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	29 70       	sub	r0,-105

80002190 <tpa6130_get_volume>:
/*! \brief Gets the current volume settings.
 *  \returns Current volume settings. Value is between 0 (-59dB) and
 *  63 (4dB).
 */
int8_t tpa6130_get_volume(void)
{
80002190:	d4 01       	pushm	lr
  return tpa6130_read_data(TPA6130_VOLUME_AND_MUTE, TWI_READ_SR);
80002192:	30 1b       	mov	r11,1
80002194:	30 2c       	mov	r12,2
80002196:	f0 1f 00 03 	mcall	800021a0 <tpa6130_get_volume+0x10>
}
8000219a:	5c 5c       	castu.b	r12
8000219c:	d8 02       	popm	pc
8000219e:	00 00       	add	r0,r0
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	21 44       	sub	r4,20

800021a4 <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
800021a4:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
800021a6:	30 0b       	mov	r11,0
800021a8:	30 1c       	mov	r12,1
800021aa:	f0 1f 00 05 	mcall	800021bc <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
800021ae:	18 9b       	mov	r11,r12
800021b0:	e2 1b 00 fe 	andl	r11,0xfe,COH
800021b4:	30 1c       	mov	r12,1
800021b6:	f0 1f 00 03 	mcall	800021c0 <tpa6130_powerup+0x1c>
}
800021ba:	d8 02       	popm	pc
800021bc:	80 00       	ld.sh	r0,r0[0x0]
800021be:	21 44       	sub	r4,20
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	20 68       	sub	r8,6

800021c4 <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
800021c4:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
800021c6:	30 0b       	mov	r11,0
800021c8:	30 1c       	mov	r12,1
800021ca:	f0 1f 00 05 	mcall	800021dc <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
800021ce:	18 9b       	mov	r11,r12
800021d0:	a1 ab       	sbr	r11,0x0
800021d2:	5c 5b       	castu.b	r11
800021d4:	30 1c       	mov	r12,1
800021d6:	f0 1f 00 03 	mcall	800021e0 <tpa6130_shutdown+0x1c>
}
800021da:	d8 02       	popm	pc
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	21 44       	sub	r4,20
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	20 68       	sub	r8,6

800021e4 <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
800021e4:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
800021e6:	f0 1f 00 0b 	mcall	80002210 <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
800021ea:	fe 7c 40 00 	mov	r12,-49152
800021ee:	f0 1f 00 0a 	mcall	80002214 <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
800021f2:	30 0c       	mov	r12,0
800021f4:	f0 1f 00 09 	mcall	80002218 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
800021f8:	30 4b       	mov	r11,4
800021fa:	48 9c       	lddpc	r12,8000221c <tpa6130_dac_stop+0x38>
800021fc:	f0 1f 00 09 	mcall	80002220 <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
80002200:	48 98       	lddpc	r8,80002224 <tpa6130_dac_stop+0x40>
80002202:	30 09       	mov	r9,0
80002204:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
80002206:	30 09       	mov	r9,0
80002208:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
8000220a:	91 29       	st.w	r8[0x8],r9
}
8000220c:	d8 02       	popm	pc
8000220e:	00 00       	add	r0,r0
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	21 c4       	sub	r4,28
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	23 88       	sub	r8,56
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	26 60       	sub	r0,102
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	64 18       	ld.w	r8,r2[0x4]
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	40 34       	lddsp	r4,sp[0xc]
80002224:	00 00       	add	r0,r0
80002226:	05 58       	ld.sh	r8,--r2

80002228 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
80002228:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
8000222a:	36 0b       	mov	r11,96
8000222c:	fe 7c 2c 00 	mov	r12,-54272
80002230:	f0 1f 00 0e 	mcall	80002268 <tpa6130_init+0x40>
80002234:	c0 40       	breq	8000223c <tpa6130_init+0x14>
80002236:	e0 6c 00 fd 	mov	r12,253
8000223a:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
8000223c:	30 0b       	mov	r11,0
8000223e:	30 4c       	mov	r12,4
80002240:	f0 1f 00 0b 	mcall	8000226c <tpa6130_init+0x44>
80002244:	30 28       	mov	r8,2
80002246:	f0 0c 18 00 	cp.b	r12,r8
8000224a:	c0 40       	breq	80002252 <tpa6130_init+0x2a>
8000224c:	e0 6c 00 f8 	mov	r12,248
80002250:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
80002252:	48 88       	lddpc	r8,80002270 <tpa6130_init+0x48>
80002254:	11 9b       	ld.ub	r11,r8[0x1]
80002256:	30 2c       	mov	r12,2
80002258:	f0 1f 00 07 	mcall	80002274 <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
8000225c:	e0 6b 00 c0 	mov	r11,192
80002260:	30 1c       	mov	r12,1
80002262:	f0 1f 00 05 	mcall	80002274 <tpa6130_init+0x4c>
80002266:	d8 0a       	popm	pc,r12=0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	29 48       	sub	r8,-108
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	21 44       	sub	r4,20
80002270:	00 00       	add	r0,r0
80002272:	00 08       	add	r8,r0
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	20 68       	sub	r8,6

80002278 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002278:	eb cd 40 c0 	pushm	r6-r7,lr
8000227c:	20 6d       	sub	sp,24
8000227e:	18 97       	mov	r7,r12
80002280:	12 96       	mov	r6,r9
80002282:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
80002284:	49 a9       	lddpc	r9,800022ec <tpa6130_dac_setup+0x74>
80002286:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80002288:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
8000228a:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
8000228c:	f0 1f 00 19 	mcall	800022f0 <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
80002290:	0e 9c       	mov	r12,r7
80002292:	f0 1f 00 19 	mcall	800022f4 <tpa6130_dac_setup+0x7c>
80002296:	c0 a1       	brne	800022aa <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
80002298:	0e 9a       	mov	r10,r7
8000229a:	e0 6b 44 00 	mov	r11,17408
8000229e:	ea 1b 00 ac 	orh	r11,0xac
800022a2:	fe 7c 40 00 	mov	r12,-49152
800022a6:	f0 1f 00 15 	mcall	800022f8 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
800022aa:	58 06       	cp.w	r6,0
800022ac:	c0 50       	breq	800022b6 <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
800022ae:	fe 7c 40 00 	mov	r12,-49152
800022b2:	f0 1f 00 13 	mcall	800022fc <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
800022b6:	fe 7c 40 00 	mov	r12,-49152
800022ba:	f0 1f 00 12 	mcall	80002300 <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
800022be:	49 28       	lddpc	r8,80002304 <tpa6130_dac_setup+0x8c>
800022c0:	1a 9b       	mov	r11,sp
800022c2:	f0 e6 00 00 	ld.d	r6,r8[0]
800022c6:	fa e7 00 00 	st.d	sp[0],r6
800022ca:	f0 e6 00 08 	ld.d	r6,r8[8]
800022ce:	fa e7 00 08 	st.d	sp[8],r6
800022d2:	f0 e8 00 10 	ld.d	r8,r8[16]
800022d6:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800022da:	30 0c       	mov	r12,0
800022dc:	f0 1f 00 0b 	mcall	80002308 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
800022e0:	30 0c       	mov	r12,0
800022e2:	f0 1f 00 0b 	mcall	8000230c <tpa6130_dac_setup+0x94>

}
800022e6:	2f ad       	sub	sp,-24
800022e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800022ec:	00 00       	add	r0,r0
800022ee:	05 58       	ld.sh	r8,--r2
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	22 28       	sub	r8,34
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	24 34       	sub	r4,67
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	23 b6       	sub	r6,59
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	23 9e       	sub	lr,57
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	23 74       	sub	r4,55
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	64 00       	ld.w	r0,r2[0x0]
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	27 38       	sub	r8,115
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	26 70       	sub	r0,103

80002310 <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002310:	eb cd 40 fe 	pushm	r1-r7,lr
80002314:	fa c4 ff e0 	sub	r4,sp,-32
80002318:	18 92       	mov	r2,r12
8000231a:	16 93       	mov	r3,r11
8000231c:	14 95       	mov	r5,r10
8000231e:	12 97       	mov	r7,r9
80002320:	10 96       	mov	r6,r8
80002322:	68 01       	ld.w	r1,r4[0x0]
80002324:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
80002326:	f0 1f 00 0d 	mcall	80002358 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
8000232a:	30 4b       	mov	r11,4
8000232c:	48 cc       	lddpc	r12,8000235c <tpa6130_dac_start+0x4c>
8000232e:	f0 1f 00 0d 	mcall	80002360 <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
80002332:	1a d4       	st.w	--sp,r4
80002334:	1a d1       	st.w	--sp,r1
80002336:	0c 98       	mov	r8,r6
80002338:	0e 99       	mov	r9,r7
8000233a:	0a 9a       	mov	r10,r5
8000233c:	06 9b       	mov	r11,r3
8000233e:	04 9c       	mov	r12,r2
80002340:	f0 1f 00 09 	mcall	80002364 <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
80002344:	30 1a       	mov	r10,1
80002346:	36 0b       	mov	r11,96
80002348:	48 8c       	lddpc	r12,80002368 <tpa6130_dac_start+0x58>
8000234a:	f0 1f 00 09 	mcall	8000236c <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
8000234e:	f0 1f 00 09 	mcall	80002370 <tpa6130_dac_start+0x60>
80002352:	2f ed       	sub	sp,-8

}
80002354:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	21 e4       	sub	r4,30
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	64 18       	ld.w	r8,r2[0x4]
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	3f ec       	mov	r12,-2
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	22 78       	sub	r8,39
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	20 08       	sub	r8,0
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	41 0c       	lddsp	r12,sp[0x40]
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	21 a4       	sub	r4,26

80002374 <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80002374:	fe 78 0c 00 	mov	r8,-62464
80002378:	71 d9       	ld.w	r9,r8[0x74]
8000237a:	a3 a9       	sbr	r9,0x2
8000237c:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80002380:	78 28       	ld.w	r8,r12[0x8]
80002382:	bf b8       	sbr	r8,0x1f
80002384:	99 28       	st.w	r12[0x8],r8
}
80002386:	5e fc       	retal	r12

80002388 <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
80002388:	78 28       	ld.w	r8,r12[0x8]
8000238a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000238e:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
80002390:	fe 78 0c 00 	mov	r8,-62464
80002394:	71 d9       	ld.w	r9,r8[0x74]
80002396:	a3 c9       	cbr	r9,0x2
80002398:	f1 49 00 74 	st.w	r8[116],r9
}
8000239c:	5e fc       	retal	r12

8000239e <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
8000239e:	78 28       	ld.w	r8,r12[0x8]
800023a0:	e6 18 40 00 	andh	r8,0x4000,COH
800023a4:	c0 50       	breq	800023ae <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
800023a6:	78 28       	ld.w	r8,r12[0x8]
800023a8:	bf c8       	cbr	r8,0x1e
800023aa:	99 28       	st.w	r12[0x8],r8
800023ac:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
800023ae:	78 28       	ld.w	r8,r12[0x8]
800023b0:	bf a8       	sbr	r8,0x1e
800023b2:	99 28       	st.w	r12[0x8],r8
800023b4:	5e fc       	retal	r12

800023b6 <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800023b6:	fe 78 0c 00 	mov	r8,-62464
800023ba:	71 d9       	ld.w	r9,r8[0x74]
800023bc:	30 0c       	mov	r12,0
800023be:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800023c2:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
800023c6:	71 d9       	ld.w	r9,r8[0x74]
800023c8:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800023cc:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
800023d0:	a9 6a       	lsl	r10,0x8
800023d2:	16 3a       	cp.w	r10,r11
800023d4:	e0 88 00 09 	brls	800023e6 <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
800023d8:	71 d9       	ld.w	r9,r8[0x74]
800023da:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800023de:	f1 49 00 74 	st.w	r8[116],r9
800023e2:	31 6c       	mov	r12,22
    return EINVAL;
800023e4:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
800023e6:	f6 0a 0d 08 	divu	r8,r11,r10
800023ea:	5c 88       	casts.h	r8

  if (div > 1) {
800023ec:	30 19       	mov	r9,1
800023ee:	f2 08 19 00 	cp.h	r8,r9
800023f2:	e0 88 00 14 	brls	8000241a <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
800023f6:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
800023fa:	20 1c       	sub	r12,1
800023fc:	5c 5c       	castu.b	r12
800023fe:	fe 79 0c 00 	mov	r9,-62464
80002402:	73 da       	ld.w	r10,r9[0x74]
80002404:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
80002408:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
8000240c:	73 da       	ld.w	r10,r9[0x74]
8000240e:	30 1c       	mov	r12,1
80002410:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80002414:	f3 4a 00 74 	st.w	r9[116],r10
80002418:	c0 98       	rjmp	8000242a <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
8000241a:	fe 79 0c 00 	mov	r9,-62464
8000241e:	73 da       	ld.w	r10,r9[0x74]
80002420:	30 0c       	mov	r12,0
80002422:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80002426:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
8000242a:	5c 78       	castu.h	r8
8000242c:	a9 68       	lsl	r8,0x8
8000242e:	f6 08 0d 0a 	divu	r10,r11,r8
80002432:	5e fa       	retal	r10

80002434 <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80002434:	e0 4c 56 22 	cp.w	r12,22050
80002438:	e0 80 00 8d 	breq	80002552 <abdac_set_dac_sample_rate+0x11e>
8000243c:	e0 8b 00 12 	brhi	80002460 <abdac_set_dac_sample_rate+0x2c>
80002440:	e0 4c 2b 11 	cp.w	r12,11025
80002444:	c3 b0       	breq	800024ba <abdac_set_dac_sample_rate+0x86>
80002446:	e0 8b 00 06 	brhi	80002452 <abdac_set_dac_sample_rate+0x1e>
8000244a:	e0 4c 1f 40 	cp.w	r12,8000
8000244e:	c1 b1       	brne	80002484 <abdac_set_dac_sample_rate+0x50>
80002450:	c1 b8       	rjmp	80002486 <abdac_set_dac_sample_rate+0x52>
80002452:	e0 4c 2e e0 	cp.w	r12,12000
80002456:	c4 b0       	breq	800024ec <abdac_set_dac_sample_rate+0xb8>
80002458:	e0 4c 3e 80 	cp.w	r12,16000
8000245c:	c1 41       	brne	80002484 <abdac_set_dac_sample_rate+0x50>
8000245e:	c6 18       	rjmp	80002520 <abdac_set_dac_sample_rate+0xec>
80002460:	e0 4c 7d 00 	cp.w	r12,32000
80002464:	e0 80 00 aa 	breq	800025b8 <abdac_set_dac_sample_rate+0x184>
80002468:	e0 8b 00 06 	brhi	80002474 <abdac_set_dac_sample_rate+0x40>
8000246c:	e0 4c 5d c0 	cp.w	r12,24000
80002470:	c0 a1       	brne	80002484 <abdac_set_dac_sample_rate+0x50>
80002472:	c8 98       	rjmp	80002584 <abdac_set_dac_sample_rate+0x150>
80002474:	e0 4c ac 44 	cp.w	r12,44100
80002478:	e0 80 00 b9 	breq	800025ea <abdac_set_dac_sample_rate+0x1b6>
8000247c:	e0 4c bb 80 	cp.w	r12,48000
80002480:	e0 80 00 ce 	breq	8000261c <abdac_set_dac_sample_rate+0x1e8>
80002484:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80002486:	fe 78 0c 00 	mov	r8,-62464
8000248a:	71 d9       	ld.w	r9,r8[0x74]
8000248c:	30 ea       	mov	r10,14
8000248e:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80002492:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80002496:	71 d9       	ld.w	r9,r8[0x74]
80002498:	30 1c       	mov	r12,1
8000249a:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000249e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800024a2:	71 d9       	ld.w	r9,r8[0x74]
800024a4:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800024a8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800024ac:	71 d9       	ld.w	r9,r8[0x74]
800024ae:	30 0a       	mov	r10,0
800024b0:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800024b4:	f1 49 00 74 	st.w	r8[116],r9
      break;
800024b8:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
800024ba:	fe 78 0c 00 	mov	r8,-62464
800024be:	71 d9       	ld.w	r9,r8[0x74]
800024c0:	30 1c       	mov	r12,1
800024c2:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
800024c6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800024ca:	71 d9       	ld.w	r9,r8[0x74]
800024cc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800024d0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800024d4:	71 d9       	ld.w	r9,r8[0x74]
800024d6:	30 0a       	mov	r10,0
800024d8:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
800024dc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
800024e0:	71 d9       	ld.w	r9,r8[0x74]
800024e2:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800024e6:	f1 49 00 74 	st.w	r8[116],r9
        break;
800024ea:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
800024ec:	fe 78 0c 00 	mov	r8,-62464
800024f0:	71 d9       	ld.w	r9,r8[0x74]
800024f2:	30 9a       	mov	r10,9
800024f4:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800024f8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800024fc:	71 d9       	ld.w	r9,r8[0x74]
800024fe:	30 1c       	mov	r12,1
80002500:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80002504:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80002508:	71 d9       	ld.w	r9,r8[0x74]
8000250a:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
8000250e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80002512:	71 d9       	ld.w	r9,r8[0x74]
80002514:	30 0a       	mov	r10,0
80002516:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
8000251a:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000251e:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80002520:	fe 78 0c 00 	mov	r8,-62464
80002524:	71 d9       	ld.w	r9,r8[0x74]
80002526:	30 5a       	mov	r10,5
80002528:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000252c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80002530:	71 d9       	ld.w	r9,r8[0x74]
80002532:	30 1c       	mov	r12,1
80002534:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80002538:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
8000253c:	71 d9       	ld.w	r9,r8[0x74]
8000253e:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80002542:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80002546:	71 d9       	ld.w	r9,r8[0x74]
80002548:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000254c:	f1 49 00 74 	st.w	r8[116],r9
        break;
80002550:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80002552:	fe 78 0c 00 	mov	r8,-62464
80002556:	71 d9       	ld.w	r9,r8[0x74]
80002558:	30 0a       	mov	r10,0
8000255a:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000255e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80002562:	71 d9       	ld.w	r9,r8[0x74]
80002564:	30 1c       	mov	r12,1
80002566:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000256a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
8000256e:	71 d9       	ld.w	r9,r8[0x74]
80002570:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80002574:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80002578:	71 d9       	ld.w	r9,r8[0x74]
8000257a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000257e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80002582:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80002584:	fe 78 0c 00 	mov	r8,-62464
80002588:	71 d9       	ld.w	r9,r8[0x74]
8000258a:	30 4a       	mov	r10,4
8000258c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80002590:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80002594:	71 d9       	ld.w	r9,r8[0x74]
80002596:	30 1c       	mov	r12,1
80002598:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000259c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800025a0:	71 d9       	ld.w	r9,r8[0x74]
800025a2:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800025a6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800025aa:	71 d9       	ld.w	r9,r8[0x74]
800025ac:	30 0a       	mov	r10,0
800025ae:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800025b2:	f1 49 00 74 	st.w	r8[116],r9
        break;
800025b6:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
800025b8:	fe 78 0c 00 	mov	r8,-62464
800025bc:	71 d9       	ld.w	r9,r8[0x74]
800025be:	30 2a       	mov	r10,2
800025c0:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800025c4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800025c8:	71 d9       	ld.w	r9,r8[0x74]
800025ca:	30 1c       	mov	r12,1
800025cc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800025d0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800025d4:	71 d9       	ld.w	r9,r8[0x74]
800025d6:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800025da:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
800025de:	71 d9       	ld.w	r9,r8[0x74]
800025e0:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800025e4:	f1 49 00 74 	st.w	r8[116],r9
        break;
800025e8:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
800025ea:	fe 78 0c 00 	mov	r8,-62464
800025ee:	71 da       	ld.w	r10,r8[0x74]
800025f0:	30 09       	mov	r9,0
800025f2:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
800025f6:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
800025fa:	71 da       	ld.w	r10,r8[0x74]
800025fc:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80002600:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80002604:	71 da       	ld.w	r10,r8[0x74]
80002606:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
8000260a:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
8000260e:	71 d9       	ld.w	r9,r8[0x74]
80002610:	30 1c       	mov	r12,1
80002612:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80002616:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000261a:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
8000261c:	fe 78 0c 00 	mov	r8,-62464
80002620:	71 d9       	ld.w	r9,r8[0x74]
80002622:	30 1c       	mov	r12,1
80002624:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80002628:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
8000262c:	71 d9       	ld.w	r9,r8[0x74]
8000262e:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80002632:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80002636:	71 d9       	ld.w	r9,r8[0x74]
80002638:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
8000263c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80002640:	71 d9       	ld.w	r9,r8[0x74]
80002642:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80002646:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
8000264a:	5e fc       	retal	r12

8000264c <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000264c:	30 e8       	mov	r8,14
8000264e:	f0 0c 18 00 	cp.b	r12,r8
80002652:	e0 88 00 03 	brls	80002658 <pdca_get_handler+0xc>
80002656:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002658:	a7 6c       	lsl	r12,0x6
8000265a:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
8000265e:	5e fc       	retal	r12

80002660 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80002660:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002662:	f0 1f 00 03 	mcall	8000266c <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80002666:	30 28       	mov	r8,2
80002668:	99 58       	st.w	r12[0x14],r8
}
8000266a:	d8 02       	popm	pc
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	26 4c       	sub	r12,100

80002670 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
80002670:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002672:	f0 1f 00 03 	mcall	8000267c <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
80002676:	30 18       	mov	r8,1
80002678:	99 58       	st.w	r12[0x14],r8
}
8000267a:	d8 02       	popm	pc
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	26 4c       	sub	r12,100

80002680 <pdca_enable_interrupt_transfer_complete>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
80002680:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002682:	f0 1f 00 03 	mcall	8000268c <pdca_enable_interrupt_transfer_complete+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80002686:	30 28       	mov	r8,2
80002688:	99 88       	st.w	r12[0x20],r8
}
8000268a:	d8 02       	popm	pc
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	26 4c       	sub	r12,100

80002690 <pdca_enable_interrupt_reload_counter_zero>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80002690:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002692:	f0 1f 00 03 	mcall	8000269c <pdca_enable_interrupt_reload_counter_zero+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
80002696:	30 18       	mov	r8,1
80002698:	99 88       	st.w	r12[0x20],r8
}
8000269a:	d8 02       	popm	pc
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	26 4c       	sub	r12,100

800026a0 <pdca_get_transfer_status>:

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
800026a0:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800026a2:	f0 1f 00 03 	mcall	800026ac <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
800026a6:	78 bc       	ld.w	r12,r12[0x2c]
}
800026a8:	d8 02       	popm	pc
800026aa:	00 00       	add	r0,r0
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	26 4c       	sub	r12,100

800026b0 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800026b0:	d4 01       	pushm	lr
800026b2:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800026b4:	f0 1f 00 08 	mcall	800026d4 <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026b8:	e1 b8 00 00 	mfsr	r8,0x0
800026bc:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800026be:	d3 03       	ssrf	0x10

	return flags;
800026c0:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800026c2:	30 19       	mov	r9,1
800026c4:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800026c6:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800026c8:	e6 18 00 01 	andh	r8,0x1,COH
800026cc:	c0 21       	brne	800026d0 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
800026ce:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800026d0:	2f fd       	sub	sp,-4
800026d2:	d8 02       	popm	pc
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	26 4c       	sub	r12,100

800026d8 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800026d8:	d4 01       	pushm	lr
800026da:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800026dc:	f0 1f 00 08 	mcall	800026fc <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026e0:	e1 b8 00 00 	mfsr	r8,0x0
800026e4:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800026e6:	d3 03       	ssrf	0x10

	return flags;
800026e8:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800026ea:	30 29       	mov	r9,2
800026ec:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800026ee:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800026f0:	e6 18 00 01 	andh	r8,0x1,COH
800026f4:	c0 21       	brne	800026f8 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800026f6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800026f8:	2f fd       	sub	sp,-4
800026fa:	d8 02       	popm	pc
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	26 4c       	sub	r12,100

80002700 <pdca_reload_channel>:
	return pdca_channel->tcrr;
}

void pdca_reload_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
80002700:	eb cd 40 c0 	pushm	r6-r7,lr
80002704:	20 1d       	sub	sp,4
80002706:	16 96       	mov	r6,r11
80002708:	14 97       	mov	r7,r10
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000270a:	f0 1f 00 0b 	mcall	80002734 <pdca_reload_channel+0x34>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000270e:	e1 b8 00 00 	mfsr	r8,0x0
80002712:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80002714:	d3 03       	ssrf	0x10

	return flags;
80002716:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	/* set up next memory address */
	pdca_channel->marr = (uint32_t)addr;
80002718:	99 36       	st.w	r12[0xc],r6
	/* set up next memory size */
	pdca_channel->tcrr = size;
8000271a:	99 47       	st.w	r12[0x10],r7
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000271c:	e0 69 01 00 	mov	r9,256
80002720:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
80002722:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002724:	e6 18 00 01 	andh	r8,0x1,COH
80002728:	c0 21       	brne	8000272c <pdca_reload_channel+0x2c>
      cpu_irq_enable();
8000272a:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
8000272c:	2f fd       	sub	sp,-4
8000272e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002732:	00 00       	add	r0,r0
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	26 4c       	sub	r12,100

80002738 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80002738:	eb cd 40 e0 	pushm	r5-r7,lr
8000273c:	20 1d       	sub	sp,4
8000273e:	18 95       	mov	r5,r12
80002740:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002742:	f0 1f 00 13 	mcall	8000278c <pdca_init_channel+0x54>
80002746:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80002748:	0a 9c       	mov	r12,r5
8000274a:	f0 1f 00 12 	mcall	80002790 <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
8000274e:	0a 9c       	mov	r12,r5
80002750:	f0 1f 00 11 	mcall	80002794 <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002754:	e1 b8 00 00 	mfsr	r8,0x0
80002758:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
8000275a:	d3 03       	ssrf	0x10

	return flags;
8000275c:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
8000275e:	6c 09       	ld.w	r9,r6[0x0]
80002760:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
80002762:	6c 19       	ld.w	r9,r6[0x4]
80002764:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
80002766:	6c 49       	ld.w	r9,r6[0x10]
80002768:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
8000276a:	6c 29       	ld.w	r9,r6[0x8]
8000276c:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
8000276e:	6c 39       	ld.w	r9,r6[0xc]
80002770:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
80002772:	6c 59       	ld.w	r9,r6[0x14]
80002774:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80002776:	e0 69 01 00 	mov	r9,256
8000277a:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
8000277c:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000277e:	e6 18 00 01 	andh	r8,0x1,COH
80002782:	c0 21       	brne	80002786 <pdca_init_channel+0x4e>
      cpu_irq_enable();
80002784:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80002786:	2f fd       	sub	sp,-4
80002788:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	26 4c       	sub	r12,100
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	26 d8       	sub	r8,109
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	26 b0       	sub	r0,107

80002798 <twi_master_interrupt_handler_not_naked>:
/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80002798:	4a 78       	lddpc	r8,80002834 <twi_master_interrupt_handler_not_naked+0x9c>
8000279a:	70 08       	ld.w	r8,r8[0x0]
8000279c:	70 89       	ld.w	r9,r8[0x20]
8000279e:	4a 7a       	lddpc	r10,80002838 <twi_master_interrupt_handler_not_naked+0xa0>
800027a0:	74 0a       	ld.w	r10,r10[0x0]
800027a2:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800027a6:	12 9a       	mov	r10,r9
800027a8:	e2 1a 01 00 	andl	r10,0x100,COH
800027ac:	c3 91       	brne	8000281e <twi_master_interrupt_handler_not_naked+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800027ae:	12 9a       	mov	r10,r9
800027b0:	e2 1a 00 02 	andl	r10,0x2,COH
800027b4:	c1 70       	breq	800027e2 <twi_master_interrupt_handler_not_naked+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800027b6:	4a 29       	lddpc	r9,8000283c <twi_master_interrupt_handler_not_naked+0xa4>
800027b8:	72 0a       	ld.w	r10,r9[0x0]
800027ba:	70 cb       	ld.w	r11,r8[0x30]
800027bc:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
800027be:	72 0a       	ld.w	r10,r9[0x0]
800027c0:	2f fa       	sub	r10,-1
800027c2:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800027c4:	49 f9       	lddpc	r9,80002840 <twi_master_interrupt_handler_not_naked+0xa8>
800027c6:	72 0a       	ld.w	r10,r9[0x0]
800027c8:	20 1a       	sub	r10,1
800027ca:	93 0a       	st.w	r9[0x0],r10
800027cc:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800027ce:	58 19       	cp.w	r9,1
800027d0:	f9 b9 00 02 	moveq	r9,2
800027d4:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800027d8:	49 a9       	lddpc	r9,80002840 <twi_master_interrupt_handler_not_naked+0xa8>
800027da:	72 09       	ld.w	r9,r9[0x0]
800027dc:	58 09       	cp.w	r9,0
800027de:	c2 30       	breq	80002824 <twi_master_interrupt_handler_not_naked+0x8c>
800027e0:	5e fc       	retal	r12
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800027e2:	12 9a       	mov	r10,r9
800027e4:	e2 1a 00 04 	andl	r10,0x4,COH
800027e8:	c1 70       	breq	80002816 <twi_master_interrupt_handler_not_naked+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800027ea:	49 79       	lddpc	r9,80002844 <twi_master_interrupt_handler_not_naked+0xac>
800027ec:	72 0a       	ld.w	r10,r9[0x0]
800027ee:	20 1a       	sub	r10,1
800027f0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800027f2:	72 09       	ld.w	r9,r9[0x0]
800027f4:	58 09       	cp.w	r9,0
800027f6:	e0 89 00 0a 	brgt	8000280a <twi_master_interrupt_handler_not_naked+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800027fa:	49 09       	lddpc	r9,80002838 <twi_master_interrupt_handler_not_naked+0xa0>
800027fc:	30 1a       	mov	r10,1
800027fe:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80002800:	3f fa       	mov	r10,-1
80002802:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80002804:	72 09       	ld.w	r9,r9[0x0]
80002806:	91 99       	st.w	r8[0x24],r9
80002808:	5e fc       	retal	r12
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
8000280a:	49 0a       	lddpc	r10,80002848 <twi_master_interrupt_handler_not_naked+0xb0>
8000280c:	74 09       	ld.w	r9,r10[0x0]
8000280e:	13 3b       	ld.ub	r11,r9++
80002810:	91 db       	st.w	r8[0x34],r11
80002812:	95 09       	st.w	r10[0x0],r9
80002814:	5e fc       	retal	r12
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80002816:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000281a:	c0 51       	brne	80002824 <twi_master_interrupt_handler_not_naked+0x8c>
8000281c:	5e fc       	retal	r12
	}

	return;

nack:
	twi_nack = true;
8000281e:	30 1a       	mov	r10,1
80002820:	48 b9       	lddpc	r9,8000284c <twi_master_interrupt_handler_not_naked+0xb4>
80002822:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80002824:	3f f9       	mov	r9,-1
80002826:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80002828:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
8000282a:	30 09       	mov	r9,0
8000282c:	48 98       	lddpc	r8,80002850 <twi_master_interrupt_handler_not_naked+0xb8>
8000282e:	b0 89       	st.b	r8[0x0],r9

	return;
}
80002830:	5e fc       	retal	r12
80002832:	00 00       	add	r0,r0
80002834:	00 00       	add	r0,r0
80002836:	05 70       	ld.ub	r0,--r2
80002838:	00 00       	add	r0,r0
8000283a:	05 6c       	ld.uh	r12,--r2
8000283c:	00 00       	add	r0,r0
8000283e:	05 7c       	ld.ub	r12,--r2
80002840:	00 00       	add	r0,r0
80002842:	05 78       	ld.ub	r8,--r2
80002844:	00 00       	add	r0,r0
80002846:	05 68       	ld.uh	r8,--r2
80002848:	00 00       	add	r0,r0
8000284a:	05 74       	ld.ub	r4,--r2
8000284c:	00 00       	add	r0,r0
8000284e:	05 65       	ld.uh	r5,--r2
80002850:	00 00       	add	r0,r0
80002852:	05 64       	ld.uh	r4,--r2

80002854 <twi_master_interrupt_handler>:
#define CONF_TWI_IRQ_GROUP         AVR32_TWI_IRQ_GROUP


/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
80002854:	eb cd 00 ff 	pushm	r0-r7
80002858:	f0 1f 00 03 	mcall	80002864 <twi_master_interrupt_handler+0x10>
8000285c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002860:	d6 03       	rete
80002862:	00 00       	add	r0,r0
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	27 98       	sub	r8,121

80002868 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
80002868:	18 98       	mov	r8,r12
	uint32_t val;

	if (len == 0)
8000286a:	58 0b       	cp.w	r11,0
8000286c:	c0 21       	brne	80002870 <twi_mk_addr+0x8>
8000286e:	5e fd       	retal	0
		return 0;

	val = addr[0];
80002870:	19 8c       	ld.ub	r12,r12[0x0]
	if (len > 1) {
80002872:	58 1b       	cp.w	r11,1
80002874:	e0 8a 00 05 	brle	8000287e <twi_mk_addr+0x16>
		val <<= 8;
		val |= addr[1];
80002878:	11 99       	ld.ub	r9,r8[0x1]
8000287a:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
	}
	if (len > 2) {
8000287e:	58 2b       	cp.w	r11,2
80002880:	5e ac       	retle	r12
		val <<= 8;
		val |= addr[2];
80002882:	11 a8       	ld.ub	r8,r8[0x2]
80002884:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	}
	return val;
}
80002888:	5e fc       	retal	r12
8000288a:	d7 03       	nop

8000288c <twi_is_busy>:
}


bool twi_is_busy(void)
{
	if (twi_busy) {
8000288c:	48 28       	lddpc	r8,80002894 <twi_is_busy+0x8>
8000288e:	11 8c       	ld.ub	r12,r8[0x0]
		return true;          // Still receiving/transmitting...
	} else {
		return false;
	}
}
80002890:	5e fc       	retal	r12
80002892:	00 00       	add	r0,r0
80002894:	00 00       	add	r0,r0
80002896:	05 64       	ld.uh	r4,--r2

80002898 <twi_master_write>:
	return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80002898:	eb cd 40 c0 	pushm	r6-r7,lr
8000289c:	18 96       	mov	r6,r12
8000289e:	16 97       	mov	r7,r11
	// No data to send
	if (package->length == 0) {
800028a0:	76 38       	ld.w	r8,r11[0xc]
800028a2:	58 08       	cp.w	r8,0
800028a4:	c0 51       	brne	800028ae <twi_master_write+0x16>
800028a6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800028aa:	fe cf ff fc 	sub	pc,pc,-4
	// No data to send
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800028ae:	f0 1f 00 1f 	mcall	80002928 <twi_master_write+0x90>
800028b2:	cf c1       	brne	800028aa <twi_master_write+0x12>
		cpu_relax();
	};

	twi_nack = false;
800028b4:	30 09       	mov	r9,0
800028b6:	49 e8       	lddpc	r8,8000292c <twi_master_write+0x94>
800028b8:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800028ba:	30 19       	mov	r9,1
800028bc:	49 d8       	lddpc	r8,80002930 <twi_master_write+0x98>
800028be:	b0 89       	st.b	r8[0x0],r9

	// Enable master transfer, disable slave
	twi->cr =   AVR32_TWI_CR_MSEN_MASK
800028c0:	32 48       	mov	r8,36
800028c2:	8d 08       	st.w	r6[0x0],r8
			| AVR32_TWI_CR_SVDIS_MASK
#endif
			;

	// set write mode, slave address and 3 internal address byte length
	twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800028c4:	6e 18       	ld.w	r8,r7[0x4]
800028c6:	a9 68       	lsl	r8,0x8
800028c8:	e2 18 03 00 	andl	r8,0x300,COH
800028cc:	0f 89       	ld.ub	r9,r7[0x0]
800028ce:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800028d2:	8d 18       	st.w	r6[0x4],r8
			(package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

	// Set pointer to TWI instance for IT
	twi_inst = twi;
800028d4:	49 88       	lddpc	r8,80002934 <twi_master_write+0x9c>
800028d6:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800028d8:	6e 1b       	ld.w	r11,r7[0x4]
800028da:	ee cc ff ff 	sub	r12,r7,-1
800028de:	f0 1f 00 17 	mcall	80002938 <twi_master_write+0xa0>
800028e2:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_tx_data = package->buffer;
800028e4:	6e 29       	ld.w	r9,r7[0x8]
800028e6:	49 68       	lddpc	r8,8000293c <twi_master_write+0xa4>
800028e8:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to write
	twi_tx_nb_bytes = package->length;
800028ea:	6e 3a       	ld.w	r10,r7[0xc]
800028ec:	49 59       	lddpc	r9,80002940 <twi_master_write+0xa8>
800028ee:	93 0a       	st.w	r9[0x0],r10

	// put the first byte in the Transmit Holding Register
	twi->thr = *twi_tx_data++;
800028f0:	70 09       	ld.w	r9,r8[0x0]
800028f2:	13 3a       	ld.ub	r10,r9++
800028f4:	8d da       	st.w	r6[0x34],r10
800028f6:	91 09       	st.w	r8[0x0],r9

	// mask NACK and TXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
800028f8:	49 38       	lddpc	r8,80002944 <twi_master_write+0xac>
800028fa:	e0 69 01 04 	mov	r9,260
800028fe:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
80002900:	70 08       	ld.w	r8,r8[0x0]
80002902:	8d 98       	st.w	r6[0x24],r8

	// send data
	while (twi_is_busy()) {
80002904:	c0 38       	rjmp	8000290a <twi_master_write+0x72>
		cpu_relax();
80002906:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// send data
	while (twi_is_busy()) {
8000290a:	f0 1f 00 08 	mcall	80002928 <twi_master_write+0x90>
8000290e:	cf c1       	brne	80002906 <twi_master_write+0x6e>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80002910:	30 88       	mov	r8,8
80002912:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
80002914:	48 68       	lddpc	r8,8000292c <twi_master_write+0x94>
80002916:	11 8c       	ld.ub	r12,r8[0x0]
80002918:	58 0c       	cp.w	r12,0
8000291a:	f9 bc 01 fb 	movne	r12,-5
8000291e:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80002922:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002926:	00 00       	add	r0,r0
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	28 8c       	sub	r12,-120
8000292c:	00 00       	add	r0,r0
8000292e:	05 65       	ld.uh	r5,--r2
80002930:	00 00       	add	r0,r0
80002932:	05 64       	ld.uh	r4,--r2
80002934:	00 00       	add	r0,r0
80002936:	05 70       	ld.ub	r0,--r2
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	28 68       	sub	r8,-122
8000293c:	00 00       	add	r0,r0
8000293e:	05 74       	ld.ub	r4,--r2
80002940:	00 00       	add	r0,r0
80002942:	05 68       	ld.uh	r8,--r2
80002944:	00 00       	add	r0,r0
80002946:	05 6c       	ld.uh	r12,--r2

80002948 <twi_probe>:
	cpu_irq_restore(flags);
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80002948:	d4 01       	pushm	lr
8000294a:	20 5d       	sub	sp,20
	twi_package_t package;
	char data[1] = {0};
8000294c:	30 08       	mov	r8,0
8000294e:	ba 88       	st.b	sp[0x0],r8

	// data to send
	package.buffer = data;
80002950:	50 3d       	stdsp	sp[0xc],sp
	// chip address
	package.chip = chip_addr;
80002952:	ba cb       	st.b	sp[0x4],r11
	// frame length
	package.length = 1;
80002954:	30 19       	mov	r9,1
80002956:	50 49       	stdsp	sp[0x10],r9
	// address length
	package.addr_length = 0;
80002958:	30 09       	mov	r9,0
8000295a:	50 29       	stdsp	sp[0x8],r9
	// internal chip address
	package.addr[0] = 0;
8000295c:	ba d8       	st.b	sp[0x5],r8
	// perform a master write access
	return (twi_master_write(twi, &package));
8000295e:	fa cb ff fc 	sub	r11,sp,-4
80002962:	f0 1f 00 03 	mcall	8000296c <twi_probe+0x24>
}
80002966:	2f bd       	sub	sp,-20
80002968:	d8 02       	popm	pc
8000296a:	00 00       	add	r0,r0
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	28 98       	sub	r8,-119

80002970 <twi_master_read>:
	}
	return val;
}

int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80002970:	eb cd 40 c0 	pushm	r6-r7,lr
80002974:	18 96       	mov	r6,r12
80002976:	16 97       	mov	r7,r11
	// check argument
	if (package->length == 0) {
80002978:	76 38       	ld.w	r8,r11[0xc]
8000297a:	58 08       	cp.w	r8,0
8000297c:	c0 51       	brne	80002986 <twi_master_read+0x16>
8000297e:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
80002982:	fe cf ff fc 	sub	pc,pc,-4
	// check argument
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
80002986:	f0 1f 00 21 	mcall	80002a08 <twi_master_read+0x98>
8000298a:	cf c1       	brne	80002982 <twi_master_read+0x12>
		cpu_relax();
	};

	twi_nack = false;
8000298c:	30 09       	mov	r9,0
8000298e:	4a 08       	lddpc	r8,80002a0c <twi_master_read+0x9c>
80002990:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
80002992:	30 19       	mov	r9,1
80002994:	49 f8       	lddpc	r8,80002a10 <twi_master_read+0xa0>
80002996:	b0 89       	st.b	r8[0x0],r9

	// set read mode, slave address and 3 internal address byte length
	twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
80002998:	0f 89       	ld.ub	r9,r7[0x0]
8000299a:	6e 18       	ld.w	r8,r7[0x4]
8000299c:	a9 68       	lsl	r8,0x8
8000299e:	e2 18 03 00 	andl	r8,0x300,COH
800029a2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800029a6:	ad a8       	sbr	r8,0xc
800029a8:	8d 18       	st.w	r6[0x4],r8
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
			(1 << AVR32_TWI_MMR_MREAD_OFFSET);

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800029aa:	49 b8       	lddpc	r8,80002a14 <twi_master_read+0xa4>
800029ac:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800029ae:	6e 1b       	ld.w	r11,r7[0x4]
800029b0:	ee cc ff ff 	sub	r12,r7,-1
800029b4:	f0 1f 00 19 	mcall	80002a18 <twi_master_read+0xa8>
800029b8:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_rx_data = package->buffer;
800029ba:	6e 29       	ld.w	r9,r7[0x8]
800029bc:	49 88       	lddpc	r8,80002a1c <twi_master_read+0xac>
800029be:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to read
	twi_rx_nb_bytes = package->length;
800029c0:	6e 39       	ld.w	r9,r7[0xc]
800029c2:	49 88       	lddpc	r8,80002a20 <twi_master_read+0xb0>
800029c4:	91 09       	st.w	r8[0x0],r9

	// Enable master transfer
	twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800029c6:	30 49       	mov	r9,4
800029c8:	8d 09       	st.w	r6[0x0],r9

	// Send start condition
	twi->cr = AVR32_TWI_START_MASK;
800029ca:	30 19       	mov	r9,1
800029cc:	8d 09       	st.w	r6[0x0],r9

	// only one byte to receive
	if (twi_rx_nb_bytes == 1) {
800029ce:	70 08       	ld.w	r8,r8[0x0]
		// set stop bit
		twi->cr = AVR32_TWI_STOP_MASK;
800029d0:	12 38       	cp.w	r8,r9
800029d2:	f9 b8 00 02 	moveq	r8,2
800029d6:	ed f8 0a 00 	st.weq	r6[0x0],r8
	}

	// mask NACK and RXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
800029da:	49 38       	lddpc	r8,80002a24 <twi_master_read+0xb4>
800029dc:	e0 69 01 02 	mov	r9,258
800029e0:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
800029e2:	70 08       	ld.w	r8,r8[0x0]
800029e4:	8d 98       	st.w	r6[0x24],r8

	// get data
	while (twi_is_busy()) {
800029e6:	c0 38       	rjmp	800029ec <twi_master_read+0x7c>
		cpu_relax();
800029e8:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// get data
	while (twi_is_busy()) {
800029ec:	f0 1f 00 07 	mcall	80002a08 <twi_master_read+0x98>
800029f0:	cf c1       	brne	800029e8 <twi_master_read+0x78>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
800029f2:	30 88       	mov	r8,8
800029f4:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
800029f6:	48 68       	lddpc	r8,80002a0c <twi_master_read+0x9c>
800029f8:	11 8c       	ld.ub	r12,r8[0x0]
800029fa:	58 0c       	cp.w	r12,0
800029fc:	f9 bc 01 fb 	movne	r12,-5
80002a00:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80002a04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	28 8c       	sub	r12,-120
80002a0c:	00 00       	add	r0,r0
80002a0e:	05 65       	ld.uh	r5,--r2
80002a10:	00 00       	add	r0,r0
80002a12:	05 64       	ld.uh	r4,--r2
80002a14:	00 00       	add	r0,r0
80002a16:	05 70       	ld.ub	r0,--r2
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	28 68       	sub	r8,-122
80002a1c:	00 00       	add	r0,r0
80002a1e:	05 7c       	ld.ub	r12,--r2
80002a20:	00 00       	add	r0,r0
80002a22:	05 78       	ld.ub	r8,--r2
80002a24:	00 00       	add	r0,r0
80002a26:	05 6c       	ld.uh	r12,--r2

80002a28 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80002a28:	eb cd 40 e0 	pushm	r5-r7,lr
80002a2c:	20 1d       	sub	sp,4
80002a2e:	18 97       	mov	r7,r12
80002a30:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80002a32:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80002a36:	4a 29       	lddpc	r9,80002abc <twi_master_init+0x94>
80002a38:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80002a3a:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80002a3c:	3f f9       	mov	r9,-1
80002a3e:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80002a40:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80002a42:	e0 69 00 80 	mov	r9,128
80002a46:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002a48:	e6 18 00 01 	andh	r8,0x1,COH
80002a4c:	c0 21       	brne	80002a50 <twi_master_init+0x28>
      cpu_irq_enable();
80002a4e:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80002a50:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002a52:	e1 b8 00 00 	mfsr	r8,0x0
80002a56:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80002a58:	d3 03       	ssrf	0x10

	return flags;
80002a5a:	40 06       	lddsp	r6,sp[0x0]

	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();
	INTC_init_interrupts(); /**/
80002a5c:	f0 1f 00 19 	mcall	80002ac0 <twi_master_init+0x98>
	INTC_register_interrupt(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL); /**/
80002a60:	30 3a       	mov	r10,3
80002a62:	e0 6b 01 60 	mov	r11,352
80002a66:	49 8c       	lddpc	r12,80002ac4 <twi_master_init+0x9c>
80002a68:	f0 1f 00 18 	mcall	80002ac8 <twi_master_init+0xa0>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002a6c:	e6 16 00 01 	andh	r6,0x1,COH
80002a70:	c0 21       	brne	80002a74 <twi_master_init+0x4c>
      cpu_irq_enable();
80002a72:	d5 03       	csrf	0x10
	//irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE,
	//CONF_TWI_IRQ_LEVEL);
	cpu_irq_restore(flags);
	cpu_irq_enable(); /**/
80002a74:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80002a76:	6a 19       	ld.w	r9,r5[0x4]
80002a78:	a1 79       	lsl	r9,0x1
80002a7a:	6a 08       	ld.w	r8,r5[0x0]
80002a7c:	f0 09 0d 08 	divu	r8,r8,r9
80002a80:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80002a82:	e0 48 00 ff 	cp.w	r8,255
80002a86:	e0 8b 00 04 	brhi	80002a8e <twi_master_init+0x66>
80002a8a:	30 09       	mov	r9,0
80002a8c:	c0 f8       	rjmp	80002aaa <twi_master_init+0x82>
80002a8e:	30 09       	mov	r9,0
80002a90:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80002a92:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80002a94:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80002a96:	e0 48 00 ff 	cp.w	r8,255
80002a9a:	5f bb       	srhi	r11
80002a9c:	58 69       	cp.w	r9,6
80002a9e:	5f 8a       	srls	r10
80002aa0:	f7 ea 00 0a 	and	r10,r11,r10
80002aa4:	f8 0a 18 00 	cp.b	r10,r12
80002aa8:	cf 51       	brne	80002a92 <twi_master_init+0x6a>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80002aaa:	b1 69       	lsl	r9,0x10
80002aac:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80002ab0:	f3 e8 10 08 	or	r8,r9,r8
80002ab4:	8f 48       	st.w	r7[0x10],r8

	// Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80002ab6:	2f fd       	sub	sp,-4
80002ab8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80002abc:	00 00       	add	r0,r0
80002abe:	05 70       	ld.ub	r0,--r2
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	41 8c       	lddsp	r12,sp[0x60]
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	28 54       	sub	r4,-123
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	41 0c       	lddsp	r12,sp[0x40]

80002acc <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80002acc:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80002ace:	f0 1f 00 02 	mcall	80002ad4 <print+0x8>
}
80002ad2:	d8 02       	popm	pc
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	2d c4       	sub	r4,-36

80002ad8 <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
80002ad8:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
80002ada:	18 9b       	mov	r11,r12
80002adc:	fe 7c 14 00 	mov	r12,-60416
80002ae0:	f0 1f 00 02 	mcall	80002ae8 <print_dbg+0x10>
}
80002ae4:	d8 02       	popm	pc
80002ae6:	00 00       	add	r0,r0
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2a cc       	sub	r12,-84

80002aec <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
80002aec:	eb cd 40 80 	pushm	r7,lr
80002af0:	20 3d       	sub	sp,12
80002af2:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
80002af4:	50 0c       	stdsp	sp[0x0],r12
80002af6:	30 88       	mov	r8,8
80002af8:	ba c8       	st.b	sp[0x4],r8
80002afa:	30 48       	mov	r8,4
80002afc:	ba d8       	st.b	sp[0x5],r8
80002afe:	30 08       	mov	r8,0
80002b00:	ba 38       	st.h	sp[0x6],r8
80002b02:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
80002b06:	30 2b       	mov	r11,2
80002b08:	48 6c       	lddpc	r12,80002b20 <init_dbg_rs232_ex+0x34>
80002b0a:	f0 1f 00 07 	mcall	80002b24 <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
80002b0e:	0e 9a       	mov	r10,r7
80002b10:	1a 9b       	mov	r11,sp
80002b12:	fe 7c 14 00 	mov	r12,-60416
80002b16:	f0 1f 00 05 	mcall	80002b28 <init_dbg_rs232_ex+0x3c>
}
80002b1a:	2f dd       	sub	sp,-12
80002b1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	64 38       	ld.w	r8,r2[0xc]
80002b24:	80 00       	ld.sh	r0,r0[0x0]
80002b26:	3f ec       	mov	r12,-2
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	2e 14       	sub	r4,-31

80002b2c <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80002b2c:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
80002b2e:	18 9b       	mov	r11,r12
80002b30:	e0 6c e1 00 	mov	r12,57600
80002b34:	f0 1f 00 02 	mcall	80002b3c <init_dbg_rs232+0x10>
}
80002b38:	d8 02       	popm	pc
80002b3a:	00 00       	add	r0,r0
80002b3c:	80 00       	ld.sh	r0,r0[0x0]
80002b3e:	2a ec       	sub	r12,-82

80002b40 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80002b40:	fe 68 14 00 	mov	r8,-125952
80002b44:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80002b46:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80002b4a:	91 09       	st.w	r8[0x0],r9
}
80002b4c:	5e fc       	retal	r12

80002b4e <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002b4e:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002b50:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002b54:	99 a8       	st.w	r12[0x28],r8
}
80002b56:	5e fc       	retal	r12

80002b58 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002b58:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002b5a:	ec 5b bb 9f 	cp.w	r11,899999
80002b5e:	e0 8b 00 04 	brhi	80002b66 <pm_enable_osc0_crystal+0xe>
80002b62:	30 4b       	mov	r11,4
80002b64:	c1 38       	rjmp	80002b8a <pm_enable_osc0_crystal+0x32>
80002b66:	e0 68 c6 bf 	mov	r8,50879
80002b6a:	ea 18 00 2d 	orh	r8,0x2d
80002b6e:	10 3b       	cp.w	r11,r8
80002b70:	e0 8b 00 04 	brhi	80002b78 <pm_enable_osc0_crystal+0x20>
80002b74:	30 5b       	mov	r11,5
80002b76:	c0 a8       	rjmp	80002b8a <pm_enable_osc0_crystal+0x32>
80002b78:	e0 68 12 00 	mov	r8,4608
80002b7c:	ea 18 00 7a 	orh	r8,0x7a
80002b80:	10 3b       	cp.w	r11,r8
80002b82:	f9 bb 03 06 	movlo	r11,6
80002b86:	f9 bb 02 07 	movhs	r11,7
80002b8a:	f0 1f 00 02 	mcall	80002b90 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002b8e:	d8 02       	popm	pc
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	2b 4e       	sub	lr,-76

80002b94 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002b94:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002b96:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002b9a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002b9c:	78 08       	ld.w	r8,r12[0x0]
80002b9e:	a3 a8       	sbr	r8,0x2
80002ba0:	99 08       	st.w	r12[0x0],r8
}
80002ba2:	5e fc       	retal	r12

80002ba4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002ba4:	79 58       	ld.w	r8,r12[0x54]
80002ba6:	e2 18 00 80 	andl	r8,0x80,COH
80002baa:	cf d0       	breq	80002ba4 <pm_wait_for_clk0_ready>
}
80002bac:	5e fc       	retal	r12
80002bae:	d7 03       	nop

80002bb0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002bb0:	eb cd 40 80 	pushm	r7,lr
80002bb4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002bb6:	f0 1f 00 04 	mcall	80002bc4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002bba:	0e 9c       	mov	r12,r7
80002bbc:	f0 1f 00 03 	mcall	80002bc8 <pm_enable_clk0+0x18>
}
80002bc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	2b 94       	sub	r4,-71
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	2b a4       	sub	r4,-70

80002bcc <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80002bcc:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
80002bce:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80002bd2:	99 b8       	st.w	r12[0x2c],r8
}
80002bd4:	5e fc       	retal	r12
80002bd6:	d7 03       	nop

80002bd8 <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
80002bd8:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
80002bda:	ec 5b bb 9f 	cp.w	r11,899999
80002bde:	e0 8b 00 04 	brhi	80002be6 <pm_enable_osc1_crystal+0xe>
80002be2:	30 4b       	mov	r11,4
80002be4:	c1 38       	rjmp	80002c0a <pm_enable_osc1_crystal+0x32>
80002be6:	e0 68 c6 bf 	mov	r8,50879
80002bea:	ea 18 00 2d 	orh	r8,0x2d
80002bee:	10 3b       	cp.w	r11,r8
80002bf0:	e0 8b 00 04 	brhi	80002bf8 <pm_enable_osc1_crystal+0x20>
80002bf4:	30 5b       	mov	r11,5
80002bf6:	c0 a8       	rjmp	80002c0a <pm_enable_osc1_crystal+0x32>
80002bf8:	e0 68 12 00 	mov	r8,4608
80002bfc:	ea 18 00 7a 	orh	r8,0x7a
80002c00:	10 3b       	cp.w	r11,r8
80002c02:	f9 bb 03 06 	movlo	r11,6
80002c06:	f9 bb 02 07 	movhs	r11,7
80002c0a:	f0 1f 00 02 	mcall	80002c10 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80002c0e:	d8 02       	popm	pc
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	2b cc       	sub	r12,-68

80002c14 <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80002c14:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
80002c16:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80002c1a:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80002c1c:	78 08       	ld.w	r8,r12[0x0]
80002c1e:	a3 b8       	sbr	r8,0x3
80002c20:	99 08       	st.w	r12[0x0],r8
}
80002c22:	5e fc       	retal	r12

80002c24 <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80002c24:	79 58       	ld.w	r8,r12[0x54]
80002c26:	e2 18 01 00 	andl	r8,0x100,COH
80002c2a:	cf d0       	breq	80002c24 <pm_wait_for_clk1_ready>
}
80002c2c:	5e fc       	retal	r12
80002c2e:	d7 03       	nop

80002c30 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80002c30:	eb cd 40 80 	pushm	r7,lr
80002c34:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
80002c36:	f0 1f 00 04 	mcall	80002c44 <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
80002c3a:	0e 9c       	mov	r12,r7
80002c3c:	f0 1f 00 03 	mcall	80002c48 <pm_enable_clk1+0x18>
}
80002c40:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c44:	80 00       	ld.sh	r0,r0[0x0]
80002c46:	2c 14       	sub	r4,-63
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	2c 24       	sub	r4,-62

80002c4c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80002c4c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80002c50:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80002c54:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80002c56:	09 f7       	ld.ub	r7,r4[0x7]
80002c58:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80002c5c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80002c60:	09 b4       	ld.ub	r4,r4[0x3]
80002c62:	08 96       	mov	r6,r4
80002c64:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80002c68:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80002c6c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80002c70:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80002c74:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80002c78:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80002c7c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80002c80:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80002c84:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80002c86:	79 58       	ld.w	r8,r12[0x54]
80002c88:	e2 18 00 20 	andl	r8,0x20,COH
80002c8c:	cf d0       	breq	80002c86 <pm_cksel+0x3a>
}
80002c8e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80002c92 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80002c92:	eb cd 40 80 	pushm	r7,lr
80002c96:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80002c98:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80002c9a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80002c9e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80002ca2:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80002ca6:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80002caa:	2f 8b       	sub	r11,-8
80002cac:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80002cb0:	e3 cd 80 80 	ldm	sp++,r7,pc

80002cb4 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80002cb4:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80002cb6:	2f 8b       	sub	r11,-8
80002cb8:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80002cbc:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80002cc0:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80002cc4:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80002cc8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80002ccc:	d8 02       	popm	pc

80002cce <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80002cce:	2f 8b       	sub	r11,-8
80002cd0:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80002cd4:	a1 a8       	sbr	r8,0x0
80002cd6:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80002cda:	5e fc       	retal	r12

80002cdc <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80002cdc:	79 58       	ld.w	r8,r12[0x54]
80002cde:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002ce2:	cf d0       	breq	80002cdc <pm_wait_for_pll0_locked>
}
80002ce4:	5e fc       	retal	r12

80002ce6 <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
80002ce6:	79 58       	ld.w	r8,r12[0x54]
80002ce8:	e2 18 00 02 	andl	r8,0x2,COH
80002cec:	cf d0       	breq	80002ce6 <pm_wait_for_pll1_locked>
}
80002cee:	5e fc       	retal	r12

80002cf0 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002cf0:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002cf2:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002cf6:	99 08       	st.w	r12[0x0],r8
}
80002cf8:	5e fc       	retal	r12
80002cfa:	d7 03       	nop

80002cfc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002cfc:	eb cd 40 c0 	pushm	r6-r7,lr
80002d00:	18 97       	mov	r7,r12
80002d02:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002d04:	f0 1f 00 06 	mcall	80002d1c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002d08:	0c 9b       	mov	r11,r6
80002d0a:	0e 9c       	mov	r12,r7
80002d0c:	f0 1f 00 05 	mcall	80002d20 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002d10:	30 1b       	mov	r11,1
80002d12:	0e 9c       	mov	r12,r7
80002d14:	f0 1f 00 04 	mcall	80002d24 <pm_switch_to_osc0+0x28>
}
80002d18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	2b 58       	sub	r8,-75
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	2b b0       	sub	r0,-69
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	2c f0       	sub	r0,-49

80002d28 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002d28:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002d2a:	f6 08 15 04 	lsl	r8,r11,0x4
80002d2e:	14 38       	cp.w	r8,r10
80002d30:	f9 b8 08 10 	movls	r8,16
80002d34:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002d38:	f0 0b 02 4b 	mul	r11,r8,r11
80002d3c:	f6 09 16 01 	lsr	r9,r11,0x1
80002d40:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80002d44:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002d48:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002d4c:	f2 cb 00 01 	sub	r11,r9,1
80002d50:	e0 4b ff fe 	cp.w	r11,65534
80002d54:	e0 88 00 03 	brls	80002d5a <usart_set_async_baudrate+0x32>
80002d58:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002d5a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002d5c:	e8 6e 00 00 	mov	lr,524288
80002d60:	59 08       	cp.w	r8,16
80002d62:	fc 08 17 10 	movne	r8,lr
80002d66:	f9 b8 00 00 	moveq	r8,0
80002d6a:	e4 1b ff f7 	andh	r11,0xfff7
80002d6e:	e0 1b fe cf 	andl	r11,0xfecf
80002d72:	16 48       	or	r8,r11
80002d74:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002d76:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80002d7a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002d7e:	99 89       	st.w	r12[0x20],r9
80002d80:	d8 0a       	popm	pc,r12=0

80002d82 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002d82:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80002d84:	e2 18 00 02 	andl	r8,0x2,COH
80002d88:	c0 31       	brne	80002d8e <usart_write_char+0xc>
80002d8a:	30 2c       	mov	r12,2
80002d8c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002d8e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002d92:	99 7b       	st.w	r12[0x1c],r11
80002d94:	5e fd       	retal	0
80002d96:	d7 03       	nop

80002d98 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80002d98:	eb cd 40 e0 	pushm	r5-r7,lr
80002d9c:	18 96       	mov	r6,r12
80002d9e:	16 95       	mov	r5,r11
80002da0:	e0 67 27 0f 	mov	r7,9999
80002da4:	c0 68       	rjmp	80002db0 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80002da6:	58 07       	cp.w	r7,0
80002da8:	c0 31       	brne	80002dae <usart_putchar+0x16>
80002daa:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80002dae:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80002db0:	0a 9b       	mov	r11,r5
80002db2:	0c 9c       	mov	r12,r6
80002db4:	f0 1f 00 03 	mcall	80002dc0 <usart_putchar+0x28>
80002db8:	cf 71       	brne	80002da6 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80002dba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002dbe:	00 00       	add	r0,r0
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	2d 82       	sub	r2,-40

80002dc4 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80002dc4:	eb cd 40 c0 	pushm	r6-r7,lr
80002dc8:	18 96       	mov	r6,r12
80002dca:	16 97       	mov	r7,r11
  while (*string != '\0')
80002dcc:	17 8b       	ld.ub	r11,r11[0x0]
80002dce:	58 0b       	cp.w	r11,0
80002dd0:	c0 80       	breq	80002de0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80002dd2:	2f f7       	sub	r7,-1
80002dd4:	0c 9c       	mov	r12,r6
80002dd6:	f0 1f 00 04 	mcall	80002de4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002dda:	0f 8b       	ld.ub	r11,r7[0x0]
80002ddc:	58 0b       	cp.w	r11,0
80002dde:	cf a1       	brne	80002dd2 <usart_write_line+0xe>
80002de0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	2d 98       	sub	r8,-39

80002de8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002de8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002dec:	e6 18 00 01 	andh	r8,0x1,COH
80002df0:	c0 71       	brne	80002dfe <usart_reset+0x16>
80002df2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80002df4:	3f f8       	mov	r8,-1
80002df6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002df8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002dfa:	d5 03       	csrf	0x10
80002dfc:	c0 48       	rjmp	80002e04 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80002dfe:	3f f8       	mov	r8,-1
80002e00:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002e02:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80002e04:	30 08       	mov	r8,0
80002e06:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80002e08:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80002e0a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002e0c:	ea 68 61 0c 	mov	r8,680204
80002e10:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002e12:	5e fc       	retal	r12

80002e14 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002e14:	eb cd 40 e0 	pushm	r5-r7,lr
80002e18:	18 96       	mov	r6,r12
80002e1a:	16 97       	mov	r7,r11
80002e1c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002e1e:	f0 1f 00 2f 	mcall	80002ed8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80002e22:	58 07       	cp.w	r7,0
80002e24:	c5 80       	breq	80002ed4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80002e26:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002e28:	30 49       	mov	r9,4
80002e2a:	f2 08 18 00 	cp.b	r8,r9
80002e2e:	e0 88 00 53 	brls	80002ed4 <usart_init_rs232+0xc0>
80002e32:	30 99       	mov	r9,9
80002e34:	f2 08 18 00 	cp.b	r8,r9
80002e38:	e0 8b 00 4e 	brhi	80002ed4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002e3c:	0f d9       	ld.ub	r9,r7[0x5]
80002e3e:	30 78       	mov	r8,7
80002e40:	f0 09 18 00 	cp.b	r9,r8
80002e44:	e0 8b 00 48 	brhi	80002ed4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80002e48:	8e 39       	ld.sh	r9,r7[0x6]
80002e4a:	e0 68 01 01 	mov	r8,257
80002e4e:	f0 09 19 00 	cp.h	r9,r8
80002e52:	e0 8b 00 41 	brhi	80002ed4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80002e56:	ef 39 00 08 	ld.ub	r9,r7[8]
80002e5a:	30 38       	mov	r8,3
80002e5c:	f0 09 18 00 	cp.b	r9,r8
80002e60:	e0 8b 00 3a 	brhi	80002ed4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002e64:	0a 9a       	mov	r10,r5
80002e66:	6e 0b       	ld.w	r11,r7[0x0]
80002e68:	0c 9c       	mov	r12,r6
80002e6a:	f0 1f 00 1d 	mcall	80002edc <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002e6e:	58 1c       	cp.w	r12,1
80002e70:	c3 20       	breq	80002ed4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80002e72:	0f c8       	ld.ub	r8,r7[0x4]
80002e74:	30 99       	mov	r9,9
80002e76:	f2 08 18 00 	cp.b	r8,r9
80002e7a:	c0 51       	brne	80002e84 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002e7c:	6c 18       	ld.w	r8,r6[0x4]
80002e7e:	b1 b8       	sbr	r8,0x11
80002e80:	8d 18       	st.w	r6[0x4],r8
80002e82:	c0 68       	rjmp	80002e8e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002e84:	6c 19       	ld.w	r9,r6[0x4]
80002e86:	20 58       	sub	r8,5
80002e88:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80002e8c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002e8e:	6c 19       	ld.w	r9,r6[0x4]
80002e90:	ef 3a 00 08 	ld.ub	r10,r7[8]
80002e94:	0f d8       	ld.ub	r8,r7[0x5]
80002e96:	a9 78       	lsl	r8,0x9
80002e98:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80002e9c:	12 48       	or	r8,r9
80002e9e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002ea0:	8e 38       	ld.sh	r8,r7[0x6]
80002ea2:	30 29       	mov	r9,2
80002ea4:	f2 08 19 00 	cp.h	r8,r9
80002ea8:	e0 88 00 09 	brls	80002eba <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002eac:	6c 18       	ld.w	r8,r6[0x4]
80002eae:	ad b8       	sbr	r8,0xd
80002eb0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002eb2:	8e b8       	ld.uh	r8,r7[0x6]
80002eb4:	20 28       	sub	r8,2
80002eb6:	8d a8       	st.w	r6[0x28],r8
80002eb8:	c0 68       	rjmp	80002ec4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002eba:	6c 19       	ld.w	r9,r6[0x4]
80002ebc:	5c 78       	castu.h	r8
80002ebe:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80002ec2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002ec4:	6c 18       	ld.w	r8,r6[0x4]
80002ec6:	e0 18 ff f0 	andl	r8,0xfff0
80002eca:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002ecc:	35 08       	mov	r8,80
80002ece:	8d 08       	st.w	r6[0x0],r8
80002ed0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002ed4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	2d e8       	sub	r8,-34
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	2d 28       	sub	r8,-46

80002ee0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002ee0:	f8 c8 ff f8 	sub	r8,r12,-8
80002ee4:	99 18       	st.w	r12[0x4],r8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
80002ee6:	3f f9       	mov	r9,-1
80002ee8:	99 29       	st.w	r12[0x8],r9

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002eea:	99 38       	st.w	r12[0xc],r8
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002eec:	99 48       	st.w	r12[0x10],r8

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
80002eee:	30 08       	mov	r8,0
80002ef0:	99 08       	st.w	r12[0x0],r8

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80002ef2:	5e fc       	retal	r12

80002ef4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
80002ef4:	30 08       	mov	r8,0
80002ef6:	99 48       	st.w	r12[0x10],r8

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
80002ef8:	5e fc       	retal	r12

80002efa <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
80002efa:	78 18       	ld.w	r8,r12[0x4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
80002efc:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80002efe:	70 29       	ld.w	r9,r8[0x8]
80002f00:	97 29       	st.w	r11[0x8],r9

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
80002f02:	70 29       	ld.w	r9,r8[0x8]
80002f04:	93 1b       	st.w	r9[0x4],r11
    pxIndex->pxPrevious = pxNewListItem;
80002f06:	91 2b       	st.w	r8[0x8],r11

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
80002f08:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80002f0a:	78 08       	ld.w	r8,r12[0x0]
80002f0c:	2f f8       	sub	r8,-1
80002f0e:	99 08       	st.w	r12[0x0],r8
}
80002f10:	5e fc       	retal	r12

80002f12 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
80002f12:	d4 01       	pushm	lr
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80002f14:	76 0e       	ld.w	lr,r11[0x0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
80002f16:	5b fe       	cp.w	lr,-1
80002f18:	c0 31       	brne	80002f1e <vListInsert+0xc>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
80002f1a:	78 49       	ld.w	r9,r12[0x10]
80002f1c:	c0 98       	rjmp	80002f2e <vListInsert+0x1c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
80002f1e:	f8 c9 ff f8 	sub	r9,r12,-8
80002f22:	72 18       	ld.w	r8,r9[0x4]
80002f24:	70 0a       	ld.w	r10,r8[0x0]
80002f26:	14 3e       	cp.w	lr,r10
80002f28:	c0 33       	brcs	80002f2e <vListInsert+0x1c>
80002f2a:	10 99       	mov	r9,r8
80002f2c:	cf bb       	rjmp	80002f22 <vListInsert+0x10>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
80002f2e:	72 18       	ld.w	r8,r9[0x4]
80002f30:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80002f32:	91 2b       	st.w	r8[0x8],r11
    pxNewListItem->pxPrevious = pxIterator;
80002f34:	97 29       	st.w	r11[0x8],r9
    pxIterator->pxNext = pxNewListItem;
80002f36:	93 1b       	st.w	r9[0x4],r11

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
80002f38:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80002f3a:	78 08       	ld.w	r8,r12[0x0]
80002f3c:	2f f8       	sub	r8,-1
80002f3e:	99 08       	st.w	r12[0x0],r8
}
80002f40:	d8 02       	popm	pc

80002f42 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
80002f42:	78 48       	ld.w	r8,r12[0x10]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002f44:	78 19       	ld.w	r9,r12[0x4]
80002f46:	78 2a       	ld.w	r10,r12[0x8]
80002f48:	93 2a       	st.w	r9[0x8],r10
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002f4a:	78 29       	ld.w	r9,r12[0x8]
80002f4c:	78 1a       	ld.w	r10,r12[0x4]
80002f4e:	93 1a       	st.w	r9[0x4],r10

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
80002f50:	70 19       	ld.w	r9,r8[0x4]
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
80002f52:	18 39       	cp.w	r9,r12
80002f54:	f3 f9 00 02 	ld.weq	r9,r9[0x8]
80002f58:	f1 f9 0a 01 	st.weq	r8[0x4],r9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
80002f5c:	30 09       	mov	r9,0
80002f5e:	99 49       	st.w	r12[0x10],r9
    ( pxList->uxNumberOfItems )--;
80002f60:	70 09       	ld.w	r9,r8[0x0]
80002f62:	20 19       	sub	r9,1
80002f64:	91 09       	st.w	r8[0x0],r9

    return pxList->uxNumberOfItems;
80002f66:	70 0c       	ld.w	r12,r8[0x0]
}
80002f68:	5e fc       	retal	r12

80002f6a <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( StackType_t ) 0x08080808;					/* R8 */
80002f6a:	e0 68 08 08 	mov	r8,2056
80002f6e:	ea 18 08 08 	orh	r8,0x808
80002f72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x09090909;					/* R9 */
80002f74:	e0 68 09 09 	mov	r8,2313
80002f78:	ea 18 09 09 	orh	r8,0x909
80002f7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;					/* R10 */
80002f7e:	e0 68 0a 0a 	mov	r8,2570
80002f82:	ea 18 0a 0a 	orh	r8,0xa0a
80002f86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;					/* R11 */
80002f88:	e0 68 0b 0b 	mov	r8,2827
80002f8c:	ea 18 0b 0b 	orh	r8,0xb0b
80002f90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pvParameters;					/* R12 */
80002f92:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;					/* R14/LR */
80002f94:	e0 68 be ef 	mov	r8,48879
80002f98:	ea 18 de ad 	orh	r8,0xdead
80002f9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80002f9e:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;				/* SR */
80002fa0:	fc 18 00 40 	movh	r8,0x40
80002fa4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;					/* R0 */
80002fa6:	e0 68 00 ff 	mov	r8,255
80002faa:	ea 18 ff 00 	orh	r8,0xff00
80002fae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x01010101;					/* R1 */
80002fb0:	e0 68 01 01 	mov	r8,257
80002fb4:	ea 18 01 01 	orh	r8,0x101
80002fb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x02020202;					/* R2 */
80002fba:	e0 68 02 02 	mov	r8,514
80002fbe:	ea 18 02 02 	orh	r8,0x202
80002fc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x03030303;					/* R3 */
80002fc4:	e0 68 03 03 	mov	r8,771
80002fc8:	ea 18 03 03 	orh	r8,0x303
80002fcc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x04040404;					/* R4 */
80002fce:	e0 68 04 04 	mov	r8,1028
80002fd2:	ea 18 04 04 	orh	r8,0x404
80002fd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x05050505;					/* R5 */
80002fd8:	e0 68 05 05 	mov	r8,1285
80002fdc:	ea 18 05 05 	orh	r8,0x505
80002fe0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x06060606;					/* R6 */
80002fe2:	e0 68 06 06 	mov	r8,1542
80002fe6:	ea 18 06 06 	orh	r8,0x606
80002fea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x07070707;					/* R7 */
80002fec:	e0 68 07 07 	mov	r8,1799
80002ff0:	ea 18 07 07 	orh	r8,0x707
80002ff4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80002ff6:	30 08       	mov	r8,0
80002ff8:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80002ffa:	5e fc       	retal	r12

80002ffc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002ffc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80002ffe:	48 38       	lddpc	r8,80003008 <vPortEnterCritical+0xc>
80003000:	70 09       	ld.w	r9,r8[0x0]
80003002:	2f f9       	sub	r9,-1
80003004:	91 09       	st.w	r8[0x0],r9
}
80003006:	5e fc       	retal	r12
80003008:	00 00       	add	r0,r0
8000300a:	00 0c       	add	r12,r0

8000300c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
8000300c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000300e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80003010:	30 0a       	mov	r10,0
80003012:	14 9b       	mov	r11,r10
80003014:	49 2c       	lddpc	r12,8000305c <xPortStartScheduler+0x50>
80003016:	f0 1f 00 13 	mcall	80003060 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000301a:	e0 68 2e e0 	mov	r8,12000
8000301e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80003022:	30 08       	mov	r8,0
80003024:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80003028:	e0 68 06 3c 	mov	r8,1596
8000302c:	ea 18 00 00 	orh	r8,0x0
80003030:	70 00       	ld.w	r0,r8[0x0]
80003032:	60 0d       	ld.w	sp,r0[0x0]
80003034:	1b 00       	ld.w	r0,sp++
80003036:	e0 68 00 0c 	mov	r8,12
8000303a:	ea 18 00 00 	orh	r8,0x0
8000303e:	91 00       	st.w	r8[0x0],r0
80003040:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003044:	2f ed       	sub	sp,-8
80003046:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000304a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000304e:	e3 b0 00 00 	mtsr	0x0,r0
80003052:	fa f0 ff dc 	ld.w	r0,sp[-36]
80003056:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000305a:	d8 0a       	popm	pc,r12=0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	31 28       	mov	r8,18
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	41 0c       	lddsp	r12,sp[0x40]

80003064 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80003064:	20 6d       	sub	sp,24
80003066:	eb cd 00 ff 	pushm	r0-r7
8000306a:	fa c7 ff c0 	sub	r7,sp,-64
8000306e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80003072:	ef 40 ff e0 	st.w	r7[-32],r0
80003076:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000307a:	ef 40 ff e4 	st.w	r7[-28],r0
8000307e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80003082:	e0 68 00 0c 	mov	r8,12
80003086:	ea 18 00 00 	orh	r8,0x0
8000308a:	70 00       	ld.w	r0,r8[0x0]
8000308c:	1a d0       	st.w	--sp,r0
8000308e:	f0 1f 00 1a 	mcall	800030f4 <LABEL_RET_SCALL_243+0x14>
80003092:	e0 68 06 3c 	mov	r8,1596
80003096:	ea 18 00 00 	orh	r8,0x0
8000309a:	70 00       	ld.w	r0,r8[0x0]
8000309c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000309e:	f0 1f 00 17 	mcall	800030f8 <LABEL_RET_SCALL_243+0x18>
	portRESTORE_CONTEXT_SCALL();
800030a2:	e0 68 06 3c 	mov	r8,1596
800030a6:	ea 18 00 00 	orh	r8,0x0
800030aa:	70 00       	ld.w	r0,r8[0x0]
800030ac:	60 0d       	ld.w	sp,r0[0x0]
800030ae:	1b 00       	ld.w	r0,sp++
800030b0:	e0 68 00 0c 	mov	r8,12
800030b4:	ea 18 00 00 	orh	r8,0x0
800030b8:	91 00       	st.w	r8[0x0],r0
800030ba:	fa c7 ff d8 	sub	r7,sp,-40
800030be:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800030c2:	ee f0 ff e0 	ld.w	r0,r7[-32]
800030c6:	e0 61 00 0c 	mov	r1,12
800030ca:	ea 11 00 00 	orh	r1,0x0
800030ce:	62 02       	ld.w	r2,r1[0x0]
800030d0:	58 02       	cp.w	r2,0
800030d2:	c0 70       	breq	800030e0 <LABEL_RET_SCALL_243>
800030d4:	e4 c2 00 01 	sub	r2,r2,1
800030d8:	83 02       	st.w	r1[0x0],r2
800030da:	58 02       	cp.w	r2,0
800030dc:	c0 21       	brne	800030e0 <LABEL_RET_SCALL_243>
800030de:	b1 c0       	cbr	r0,0x10

800030e0 <LABEL_RET_SCALL_243>:
800030e0:	ef 40 ff f8 	st.w	r7[-8],r0
800030e4:	ee f0 ff e4 	ld.w	r0,r7[-28]
800030e8:	ef 40 ff fc 	st.w	r7[-4],r0
800030ec:	e3 cd 00 ff 	ldm	sp++,r0-r7
800030f0:	2f ad       	sub	sp,-24
800030f2:	d6 13       	rets
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	2f fc       	sub	r12,-1
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	35 48       	mov	r8,84

800030fc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800030fc:	e1 b8 00 43 	mfsr	r8,0x10c
80003100:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80003104:	5e fc       	retal	r12
80003106:	d7 03       	nop

80003108 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80003108:	48 78       	lddpc	r8,80003124 <vPortExitCritical+0x1c>
8000310a:	70 08       	ld.w	r8,r8[0x0]
8000310c:	58 08       	cp.w	r8,0
8000310e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80003110:	48 58       	lddpc	r8,80003124 <vPortExitCritical+0x1c>
80003112:	70 09       	ld.w	r9,r8[0x0]
80003114:	20 19       	sub	r9,1
80003116:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80003118:	70 08       	ld.w	r8,r8[0x0]
8000311a:	58 08       	cp.w	r8,0
8000311c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000311e:	d5 03       	csrf	0x10
80003120:	5e fc       	retal	r12
80003122:	00 00       	add	r0,r0
80003124:	00 00       	add	r0,r0
80003126:	00 0c       	add	r12,r0

80003128 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80003128:	eb cd 00 ff 	pushm	r0-r7
8000312c:	e0 68 00 0c 	mov	r8,12
80003130:	ea 18 00 00 	orh	r8,0x0
80003134:	70 00       	ld.w	r0,r8[0x0]
80003136:	1a d0       	st.w	--sp,r0
80003138:	7a 90       	ld.w	r0,sp[0x24]
8000313a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000313e:	58 10       	cp.w	r0,1
80003140:	e0 8b 00 08 	brhi	80003150 <LABEL_INT_SKIP_SAVE_CONTEXT_216>
80003144:	e0 68 06 3c 	mov	r8,1596
80003148:	ea 18 00 00 	orh	r8,0x0
8000314c:	70 00       	ld.w	r0,r8[0x0]
8000314e:	81 0d       	st.w	r0[0x0],sp

80003150 <LABEL_INT_SKIP_SAVE_CONTEXT_216>:
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
		clock cycles from now. */
		prvClearCcInt();
80003150:	f0 1f 00 12 	mcall	80003198 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80003154:	f0 1f 00 12 	mcall	8000319c <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
		xTaskIncrementTick();
80003158:	f0 1f 00 12 	mcall	800031a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x1c>
	portEXIT_CRITICAL();
8000315c:	f0 1f 00 12 	mcall	800031a4 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80003160:	7a 90       	ld.w	r0,sp[0x24]
80003162:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80003166:	58 10       	cp.w	r0,1
80003168:	e0 8b 00 0e 	brhi	80003184 <LABEL_INT_SKIP_RESTORE_CONTEXT_234>
8000316c:	f0 1f 00 0c 	mcall	8000319c <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
80003170:	f0 1f 00 0e 	mcall	800031a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x24>
80003174:	f0 1f 00 0c 	mcall	800031a4 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>
80003178:	e0 68 06 3c 	mov	r8,1596
8000317c:	ea 18 00 00 	orh	r8,0x0
80003180:	70 00       	ld.w	r0,r8[0x0]
80003182:	60 0d       	ld.w	sp,r0[0x0]

80003184 <LABEL_INT_SKIP_RESTORE_CONTEXT_234>:
80003184:	1b 00       	ld.w	r0,sp++
80003186:	e0 68 00 0c 	mov	r8,12
8000318a:	ea 18 00 00 	orh	r8,0x0
8000318e:	91 00       	st.w	r8[0x0],r0
80003190:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003194:	d6 03       	rete
80003196:	00 00       	add	r0,r0
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	30 fc       	mov	r12,15
8000319c:	80 00       	ld.sh	r0,r0[0x0]
8000319e:	2f fc       	sub	r12,-1
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	38 54       	mov	r4,-123
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	31 08       	mov	r8,16
800031a8:	80 00       	ld.sh	r0,r0[0x0]
800031aa:	35 48       	mov	r8,84

800031ac <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800031ac:	d4 01       	pushm	lr
	vTaskSuspendAll();
800031ae:	f0 1f 00 02 	mcall	800031b4 <__malloc_lock+0x8>
}
800031b2:	d8 02       	popm	pc
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	35 38       	mov	r8,83

800031b8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800031b8:	d4 01       	pushm	lr
	xTaskResumeAll();
800031ba:	f0 1f 00 02 	mcall	800031c0 <__malloc_unlock+0x8>
}
800031be:	d8 02       	popm	pc
800031c0:	80 00       	ld.sh	r0,r0[0x0]
800031c2:	39 5c       	mov	r12,-107

800031c4 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
800031c4:	eb cd 40 80 	pushm	r7,lr
800031c8:	18 97       	mov	r7,r12
    if( pv )
800031ca:	58 0c       	cp.w	r12,0
800031cc:	c0 80       	breq	800031dc <vPortFree+0x18>
    {
        vTaskSuspendAll();
800031ce:	f0 1f 00 05 	mcall	800031e0 <vPortFree+0x1c>
        {
            free( pv );
800031d2:	0e 9c       	mov	r12,r7
800031d4:	f0 1f 00 04 	mcall	800031e4 <vPortFree+0x20>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
800031d8:	f0 1f 00 04 	mcall	800031e8 <vPortFree+0x24>
800031dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	35 38       	mov	r8,83
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	58 94       	cp.w	r4,9
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	39 5c       	mov	r12,-107

800031ec <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
800031ec:	eb cd 40 80 	pushm	r7,lr
800031f0:	18 97       	mov	r7,r12
    void * pvReturn;

    vTaskSuspendAll();
800031f2:	f0 1f 00 06 	mcall	80003208 <pvPortMalloc+0x1c>
    {
        pvReturn = malloc( xWantedSize );
800031f6:	0e 9c       	mov	r12,r7
800031f8:	f0 1f 00 05 	mcall	8000320c <pvPortMalloc+0x20>
800031fc:	18 97       	mov	r7,r12
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
800031fe:	f0 1f 00 05 	mcall	80003210 <pvPortMalloc+0x24>
            }
        }
    #endif

    return pvReturn;
}
80003202:	0e 9c       	mov	r12,r7
80003204:	e3 cd 80 80 	ldm	sp++,r7,pc
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	35 38       	mov	r8,83
8000320c:	80 00       	ld.sh	r0,r0[0x0]
8000320e:	58 a4       	cp.w	r4,10
80003210:	80 00       	ld.sh	r0,r0[0x0]
80003212:	39 5c       	mov	r12,-107

80003214 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
80003214:	d4 21       	pushm	r4-r7,lr
80003216:	18 96       	mov	r6,r12

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
80003218:	f0 1f 00 25 	mcall	800032ac <prvUnlockQueue+0x98>
    {
        int8_t cTxLock = pxQueue->cTxLock;
8000321c:	ed 37 00 45 	ld.ub	r7,r6[69]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80003220:	30 08       	mov	r8,0
80003222:	f0 07 18 00 	cp.b	r7,r8
80003226:	e0 8a 00 18 	brle	80003256 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000322a:	6c 98       	ld.w	r8,r6[0x24]
8000322c:	58 08       	cp.w	r8,0
8000322e:	c1 40       	breq	80003256 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003230:	ec c4 ff dc 	sub	r4,r6,-36
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80003234:	30 05       	mov	r5,0
80003236:	c0 48       	rjmp	8000323e <prvUnlockQueue+0x2a>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003238:	6c 98       	ld.w	r8,r6[0x24]
8000323a:	58 08       	cp.w	r8,0
8000323c:	c0 d0       	breq	80003256 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000323e:	08 9c       	mov	r12,r4
80003240:	f0 1f 00 1c 	mcall	800032b0 <prvUnlockQueue+0x9c>
80003244:	c0 30       	breq	8000324a <prvUnlockQueue+0x36>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
80003246:	f0 1f 00 1c 	mcall	800032b4 <prvUnlockQueue+0xa0>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
8000324a:	20 17       	sub	r7,1
8000324c:	5c 57       	castu.b	r7
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
8000324e:	ea 07 18 00 	cp.b	r7,r5
80003252:	fe 99 ff f3 	brgt	80003238 <prvUnlockQueue+0x24>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
80003256:	3f f8       	mov	r8,-1
80003258:	ed 68 00 45 	st.b	r6[69],r8
    }
    taskEXIT_CRITICAL();
8000325c:	f0 1f 00 17 	mcall	800032b8 <prvUnlockQueue+0xa4>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
80003260:	f0 1f 00 13 	mcall	800032ac <prvUnlockQueue+0x98>
    {
        int8_t cRxLock = pxQueue->cRxLock;
80003264:	ed 37 00 44 	ld.ub	r7,r6[68]

        while( cRxLock > queueLOCKED_UNMODIFIED )
80003268:	30 08       	mov	r8,0
8000326a:	f0 07 18 00 	cp.b	r7,r8
8000326e:	e0 8a 00 18 	brle	8000329e <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80003272:	6c 48       	ld.w	r8,r6[0x10]
80003274:	58 08       	cp.w	r8,0
80003276:	c1 40       	breq	8000329e <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80003278:	ec c4 ff f0 	sub	r4,r6,-16
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
8000327c:	30 05       	mov	r5,0
8000327e:	c0 48       	rjmp	80003286 <prvUnlockQueue+0x72>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80003280:	6c 48       	ld.w	r8,r6[0x10]
80003282:	58 08       	cp.w	r8,0
80003284:	c0 d0       	breq	8000329e <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80003286:	08 9c       	mov	r12,r4
80003288:	f0 1f 00 0a 	mcall	800032b0 <prvUnlockQueue+0x9c>
8000328c:	c0 30       	breq	80003292 <prvUnlockQueue+0x7e>
                {
                    vTaskMissedYield();
8000328e:	f0 1f 00 0a 	mcall	800032b4 <prvUnlockQueue+0xa0>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
80003292:	20 17       	sub	r7,1
80003294:	5c 57       	castu.b	r7
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
80003296:	ea 07 18 00 	cp.b	r7,r5
8000329a:	fe 99 ff f3 	brgt	80003280 <prvUnlockQueue+0x6c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
8000329e:	3f f8       	mov	r8,-1
800032a0:	ed 68 00 44 	st.b	r6[68],r8
    }
    taskEXIT_CRITICAL();
800032a4:	f0 1f 00 05 	mcall	800032b8 <prvUnlockQueue+0xa4>
}
800032a8:	d8 22       	popm	r4-r7,pc
800032aa:	00 00       	add	r0,r0
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	2f fc       	sub	r12,-1
800032b0:	80 00       	ld.sh	r0,r0[0x0]
800032b2:	37 c8       	mov	r8,124
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	35 d4       	mov	r4,93
800032b8:	80 00       	ld.sh	r0,r0[0x0]
800032ba:	31 08       	mov	r8,16

800032bc <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
800032bc:	eb cd 40 e0 	pushm	r5-r7,lr
800032c0:	18 97       	mov	r7,r12
800032c2:	14 96       	mov	r6,r10
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
800032c4:	78 e5       	ld.w	r5,r12[0x38]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
800032c6:	79 0a       	ld.w	r10,r12[0x40]
800032c8:	58 0a       	cp.w	r10,0
800032ca:	c0 a1       	brne	800032de <prvCopyDataToQueue+0x22>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800032cc:	78 08       	ld.w	r8,r12[0x0]
800032ce:	58 08       	cp.w	r8,0
800032d0:	c3 11       	brne	80003332 <prvCopyDataToQueue+0x76>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
800032d2:	78 2c       	ld.w	r12,r12[0x8]
800032d4:	f0 1f 00 1a 	mcall	8000333c <prvCopyDataToQueue+0x80>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
800032d8:	30 08       	mov	r8,0
800032da:	8f 28       	st.w	r7[0x8],r8
800032dc:	c2 c8       	rjmp	80003334 <prvCopyDataToQueue+0x78>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
800032de:	58 06       	cp.w	r6,0
800032e0:	c1 01       	brne	80003300 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
800032e2:	78 1c       	ld.w	r12,r12[0x4]
800032e4:	f0 1f 00 17 	mcall	80003340 <prvCopyDataToQueue+0x84>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
800032e8:	6e 19       	ld.w	r9,r7[0x4]
800032ea:	6f 08       	ld.w	r8,r7[0x40]
800032ec:	f2 08 00 08 	add	r8,r9,r8
800032f0:	8f 18       	st.w	r7[0x4],r8

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
800032f2:	6e 29       	ld.w	r9,r7[0x8]
800032f4:	12 38       	cp.w	r8,r9
800032f6:	c1 e3       	brcs	80003332 <prvCopyDataToQueue+0x76>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
800032f8:	6e 08       	ld.w	r8,r7[0x0]
800032fa:	8f 18       	st.w	r7[0x4],r8
800032fc:	30 0c       	mov	r12,0
800032fe:	c1 b8       	rjmp	80003334 <prvCopyDataToQueue+0x78>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
80003300:	78 3c       	ld.w	r12,r12[0xc]
80003302:	f0 1f 00 10 	mcall	80003340 <prvCopyDataToQueue+0x84>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
80003306:	6f 08       	ld.w	r8,r7[0x40]
80003308:	6e 39       	ld.w	r9,r7[0xc]
8000330a:	f2 08 01 08 	sub	r8,r9,r8
8000330e:	8f 38       	st.w	r7[0xc],r8

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80003310:	6e 09       	ld.w	r9,r7[0x0]
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
80003312:	12 38       	cp.w	r8,r9
80003314:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80003318:	ef f9 30 02 	ld.wcs	r9,r7[0x8]
8000331c:	f3 d8 e3 19 	subcs	r9,r9,r8
80003320:	ef f9 3a 03 	st.wcs	r7[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
80003324:	58 26       	cp.w	r6,2
80003326:	c0 61       	brne	80003332 <prvCopyDataToQueue+0x76>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80003328:	58 05       	cp.w	r5,0
8000332a:	c0 40       	breq	80003332 <prvCopyDataToQueue+0x76>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
8000332c:	20 15       	sub	r5,1
8000332e:	30 0c       	mov	r12,0
80003330:	c0 28       	rjmp	80003334 <prvCopyDataToQueue+0x78>
80003332:	30 0c       	mov	r12,0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
80003334:	2f f5       	sub	r5,-1
80003336:	8f e5       	st.w	r7[0x38],r5

    return xReturn;
}
80003338:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000333c:	80 00       	ld.sh	r0,r0[0x0]
8000333e:	37 60       	mov	r0,118
80003340:	80 00       	ld.sh	r0,r0[0x0]
80003342:	5c e8       	tnbz	r8

80003344 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
80003344:	d4 31       	pushm	r0-r7,lr
80003346:	20 5d       	sub	sp,20
80003348:	18 97       	mov	r7,r12
8000334a:	50 1b       	stdsp	sp[0x4],r11
8000334c:	50 2a       	stdsp	sp[0x8],r10
8000334e:	12 91       	mov	r1,r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003350:	f8 c8 ff f0 	sub	r8,r12,-16
80003354:	50 08       	stdsp	sp[0x0],r8
80003356:	30 03       	mov	r3,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80003358:	fa c2 ff f4 	sub	r2,sp,-12

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
8000335c:	3f f5       	mov	r5,-1

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000335e:	fa c0 ff f8 	sub	r0,sp,-8
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80003362:	f0 1f 00 36 	mcall	80003438 <xQueueGenericSend+0xf4>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80003366:	6e e9       	ld.w	r9,r7[0x38]
80003368:	6e f8       	ld.w	r8,r7[0x3c]
8000336a:	10 39       	cp.w	r9,r8
8000336c:	c0 33       	brcs	80003372 <xQueueGenericSend+0x2e>
8000336e:	58 21       	cp.w	r1,2
80003370:	c1 71       	brne	8000339e <xQueueGenericSend+0x5a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80003372:	02 9a       	mov	r10,r1
80003374:	40 1b       	lddsp	r11,sp[0x4]
80003376:	0e 9c       	mov	r12,r7
80003378:	f0 1f 00 31 	mcall	8000343c <xQueueGenericSend+0xf8>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000337c:	6e 98       	ld.w	r8,r7[0x24]
8000337e:	58 08       	cp.w	r8,0
80003380:	c0 80       	breq	80003390 <xQueueGenericSend+0x4c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003382:	ee cc ff dc 	sub	r12,r7,-36
80003386:	f0 1f 00 2f 	mcall	80003440 <xQueueGenericSend+0xfc>
8000338a:	c0 60       	breq	80003396 <xQueueGenericSend+0x52>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
8000338c:	d7 33       	scall
8000338e:	c0 48       	rjmp	80003396 <xQueueGenericSend+0x52>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
80003390:	58 0c       	cp.w	r12,0
80003392:	c0 20       	breq	80003396 <xQueueGenericSend+0x52>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
80003394:	d7 33       	scall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
80003396:	f0 1f 00 2c 	mcall	80003444 <xQueueGenericSend+0x100>
8000339a:	30 1c       	mov	r12,1
                return pdPASS;
8000339c:	c4 b8       	rjmp	80003432 <xQueueGenericSend+0xee>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
8000339e:	40 28       	lddsp	r8,sp[0x8]
800033a0:	58 08       	cp.w	r8,0
800033a2:	c0 51       	brne	800033ac <xQueueGenericSend+0x68>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
800033a4:	f0 1f 00 28 	mcall	80003444 <xQueueGenericSend+0x100>
800033a8:	30 0c       	mov	r12,0

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
800033aa:	c4 48       	rjmp	80003432 <xQueueGenericSend+0xee>
                }
                else if( xEntryTimeSet == pdFALSE )
800033ac:	58 03       	cp.w	r3,0
800033ae:	c0 51       	brne	800033b8 <xQueueGenericSend+0x74>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800033b0:	04 9c       	mov	r12,r2
800033b2:	f0 1f 00 26 	mcall	80003448 <xQueueGenericSend+0x104>
800033b6:	30 13       	mov	r3,1
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
800033b8:	f0 1f 00 23 	mcall	80003444 <xQueueGenericSend+0x100>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
800033bc:	f0 1f 00 24 	mcall	8000344c <xQueueGenericSend+0x108>
        prvLockQueue( pxQueue );
800033c0:	f0 1f 00 1e 	mcall	80003438 <xQueueGenericSend+0xf4>
800033c4:	ef 38 00 44 	ld.ub	r8,r7[68]
800033c8:	ea 08 18 00 	cp.b	r8,r5
800033cc:	f9 b8 00 00 	moveq	r8,0
800033d0:	ef f8 0e 44 	st.beq	r7[0x44],r8
800033d4:	ef 38 00 45 	ld.ub	r8,r7[69]
800033d8:	ea 08 18 00 	cp.b	r8,r5
800033dc:	f9 b8 00 00 	moveq	r8,0
800033e0:	ef f8 0e 45 	st.beq	r7[0x45],r8
800033e4:	f0 1f 00 18 	mcall	80003444 <xQueueGenericSend+0x100>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800033e8:	00 9b       	mov	r11,r0
800033ea:	04 9c       	mov	r12,r2
800033ec:	f0 1f 00 19 	mcall	80003450 <xQueueGenericSend+0x10c>
800033f0:	c1 b1       	brne	80003426 <xQueueGenericSend+0xe2>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
800033f2:	f0 1f 00 12 	mcall	80003438 <xQueueGenericSend+0xf4>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
800033f6:	6e e4       	ld.w	r4,r7[0x38]
800033f8:	6e f6       	ld.w	r6,r7[0x3c]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
800033fa:	f0 1f 00 13 	mcall	80003444 <xQueueGenericSend+0x100>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
800033fe:	0c 34       	cp.w	r4,r6
80003400:	c0 d1       	brne	8000341a <xQueueGenericSend+0xd6>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003402:	40 2b       	lddsp	r11,sp[0x8]
80003404:	40 0c       	lddsp	r12,sp[0x0]
80003406:	f0 1f 00 14 	mcall	80003454 <xQueueGenericSend+0x110>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
8000340a:	0e 9c       	mov	r12,r7
8000340c:	f0 1f 00 13 	mcall	80003458 <xQueueGenericSend+0x114>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
80003410:	f0 1f 00 13 	mcall	8000345c <xQueueGenericSend+0x118>
80003414:	ca 71       	brne	80003362 <xQueueGenericSend+0x1e>
                {
                    portYIELD_WITHIN_API();
80003416:	d7 33       	scall
80003418:	ca 5b       	rjmp	80003362 <xQueueGenericSend+0x1e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
8000341a:	0e 9c       	mov	r12,r7
8000341c:	f0 1f 00 0f 	mcall	80003458 <xQueueGenericSend+0x114>
                ( void ) xTaskResumeAll();
80003420:	f0 1f 00 0f 	mcall	8000345c <xQueueGenericSend+0x118>
80003424:	c9 fb       	rjmp	80003362 <xQueueGenericSend+0x1e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
80003426:	0e 9c       	mov	r12,r7
80003428:	f0 1f 00 0c 	mcall	80003458 <xQueueGenericSend+0x114>
            ( void ) xTaskResumeAll();
8000342c:	f0 1f 00 0c 	mcall	8000345c <xQueueGenericSend+0x118>
80003430:	30 0c       	mov	r12,0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
80003432:	2f bd       	sub	sp,-20
80003434:	d8 32       	popm	r0-r7,pc
80003436:	00 00       	add	r0,r0
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	2f fc       	sub	r12,-1
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	32 bc       	mov	r12,43
80003440:	80 00       	ld.sh	r0,r0[0x0]
80003442:	37 c8       	mov	r8,124
80003444:	80 00       	ld.sh	r0,r0[0x0]
80003446:	31 08       	mov	r8,16
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	35 bc       	mov	r12,91
8000344c:	80 00       	ld.sh	r0,r0[0x0]
8000344e:	35 38       	mov	r8,83
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	36 08       	mov	r8,96
80003454:	80 00       	ld.sh	r0,r0[0x0]
80003456:	3c a8       	mov	r8,-54
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	32 14       	mov	r4,33
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	39 5c       	mov	r12,-107

80003460 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
80003460:	eb cd 40 c0 	pushm	r6-r7,lr
80003464:	18 97       	mov	r7,r12
80003466:	16 96       	mov	r6,r11
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
80003468:	f0 1f 00 18 	mcall	800034c8 <xQueueGenericReset+0x68>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
8000346c:	6f 09       	ld.w	r9,r7[0x40]
8000346e:	6e fa       	ld.w	r10,r7[0x3c]
80003470:	f2 0a 02 4b 	mul	r11,r9,r10
80003474:	6e 08       	ld.w	r8,r7[0x0]
80003476:	f0 0b 00 0b 	add	r11,r8,r11
8000347a:	8f 2b       	st.w	r7[0x8],r11
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
8000347c:	30 0b       	mov	r11,0
8000347e:	8f eb       	st.w	r7[0x38],r11
        pxQueue->pcWriteTo = pxQueue->pcHead;
80003480:	8f 18       	st.w	r7[0x4],r8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
80003482:	20 1a       	sub	r10,1
80003484:	f4 09 02 49 	mul	r9,r10,r9
80003488:	12 08       	add	r8,r9
8000348a:	8f 38       	st.w	r7[0xc],r8
        pxQueue->cRxLock = queueUNLOCKED;
8000348c:	3f f8       	mov	r8,-1
8000348e:	ef 68 00 44 	st.b	r7[68],r8
        pxQueue->cTxLock = queueUNLOCKED;
80003492:	ef 68 00 45 	st.b	r7[69],r8

        if( xNewQueue == pdFALSE )
80003496:	58 06       	cp.w	r6,0
80003498:	c0 b1       	brne	800034ae <xQueueGenericReset+0x4e>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000349a:	6e 48       	ld.w	r8,r7[0x10]
8000349c:	58 08       	cp.w	r8,0
8000349e:	c1 00       	breq	800034be <xQueueGenericReset+0x5e>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800034a0:	ee cc ff f0 	sub	r12,r7,-16
800034a4:	f0 1f 00 0a 	mcall	800034cc <xQueueGenericReset+0x6c>
800034a8:	c0 b0       	breq	800034be <xQueueGenericReset+0x5e>
                {
                    queueYIELD_IF_USING_PREEMPTION();
800034aa:	d7 33       	scall
800034ac:	c0 98       	rjmp	800034be <xQueueGenericReset+0x5e>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
800034ae:	ee cc ff f0 	sub	r12,r7,-16
800034b2:	f0 1f 00 08 	mcall	800034d0 <xQueueGenericReset+0x70>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
800034b6:	ee cc ff dc 	sub	r12,r7,-36
800034ba:	f0 1f 00 06 	mcall	800034d0 <xQueueGenericReset+0x70>
        }
    }
    taskEXIT_CRITICAL();
800034be:	f0 1f 00 06 	mcall	800034d4 <xQueueGenericReset+0x74>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
800034c2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800034c6:	00 00       	add	r0,r0
800034c8:	80 00       	ld.sh	r0,r0[0x0]
800034ca:	2f fc       	sub	r12,-1
800034cc:	80 00       	ld.sh	r0,r0[0x0]
800034ce:	37 c8       	mov	r8,124
800034d0:	80 00       	ld.sh	r0,r0[0x0]
800034d2:	2e e0       	sub	r0,-18
800034d4:	80 00       	ld.sh	r0,r0[0x0]
800034d6:	31 08       	mov	r8,16

800034d8 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
800034d8:	eb cd 40 e0 	pushm	r5-r7,lr
800034dc:	18 95       	mov	r5,r12
800034de:	16 96       	mov	r6,r11
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
800034e0:	f6 0c 02 4c 	mul	r12,r11,r12
800034e4:	2b 8c       	sub	r12,-72
800034e6:	f0 1f 00 0b 	mcall	80003510 <xQueueGenericCreate+0x38>
800034ea:	18 97       	mov	r7,r12

        if( pxNewQueue != NULL )
800034ec:	c0 f0       	breq	8000350a <xQueueGenericCreate+0x32>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
800034ee:	58 06       	cp.w	r6,0
800034f0:	c0 31       	brne	800034f6 <xQueueGenericCreate+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
800034f2:	8f 0c       	st.w	r7[0x0],r12
800034f4:	c0 48       	rjmp	800034fc <xQueueGenericCreate+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
800034f6:	f8 c8 ff b8 	sub	r8,r12,-72
800034fa:	99 08       	st.w	r12[0x0],r8
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
800034fc:	8f f5       	st.w	r7[0x3c],r5
    pxNewQueue->uxItemSize = uxItemSize;
800034fe:	ef 46 00 40 	st.w	r7[64],r6
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
80003502:	30 1b       	mov	r11,1
80003504:	0e 9c       	mov	r12,r7
80003506:	f0 1f 00 04 	mcall	80003514 <xQueueGenericCreate+0x3c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
8000350a:	0e 9c       	mov	r12,r7
8000350c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	31 ec       	mov	r12,30
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	34 60       	mov	r0,70

80003518 <prvTaskIsTaskSuspended>:

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80003518:	78 59       	ld.w	r9,r12[0x14]
8000351a:	48 68       	lddpc	r8,80003530 <prvTaskIsTaskSuspended+0x18>
8000351c:	10 39       	cp.w	r9,r8
8000351e:	c0 81       	brne	8000352e <prvTaskIsTaskSuspended+0x16>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
80003520:	78 a8       	ld.w	r8,r12[0x28]
80003522:	48 59       	lddpc	r9,80003534 <prvTaskIsTaskSuspended+0x1c>
80003524:	12 38       	cp.w	r8,r9
80003526:	c0 40       	breq	8000352e <prvTaskIsTaskSuspended+0x16>
80003528:	58 08       	cp.w	r8,0
8000352a:	5f 0c       	sreq	r12
8000352c:	5e fc       	retal	r12
8000352e:	5e fd       	retal	0
80003530:	00 00       	add	r0,r0
80003532:	06 a4       	st.w	r3++,r4
80003534:	00 00       	add	r0,r0
80003536:	06 40       	or	r0,r3

80003538 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
80003538:	48 38       	lddpc	r8,80003544 <vTaskSuspendAll+0xc>
8000353a:	70 09       	ld.w	r9,r8[0x0]
8000353c:	2f f9       	sub	r9,-1
8000353e:	91 09       	st.w	r8[0x0],r9

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
80003540:	5e fc       	retal	r12
80003542:	00 00       	add	r0,r0
80003544:	00 00       	add	r0,r0
80003546:	06 6c       	and	r12,r3

80003548 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
80003548:	49 88       	lddpc	r8,800035a8 <vTaskSwitchContext+0x60>
8000354a:	70 08       	ld.w	r8,r8[0x0]
8000354c:	58 08       	cp.w	r8,0
8000354e:	c0 50       	breq	80003558 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
80003550:	30 19       	mov	r9,1
80003552:	49 78       	lddpc	r8,800035ac <vTaskSwitchContext+0x64>
80003554:	91 09       	st.w	r8[0x0],r9
80003556:	5e fc       	retal	r12
    }
    else
    {
        xYieldPending = pdFALSE;
80003558:	30 09       	mov	r9,0
8000355a:	49 58       	lddpc	r8,800035ac <vTaskSwitchContext+0x64>
8000355c:	91 09       	st.w	r8[0x0],r9
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
8000355e:	49 58       	lddpc	r8,800035b0 <vTaskSwitchContext+0x68>
80003560:	70 09       	ld.w	r9,r8[0x0]
80003562:	f2 09 00 28 	add	r8,r9,r9<<0x2
80003566:	a3 68       	lsl	r8,0x2
80003568:	49 3b       	lddpc	r11,800035b4 <vTaskSwitchContext+0x6c>
8000356a:	10 0b       	add	r11,r8
8000356c:	76 0a       	ld.w	r10,r11[0x0]
8000356e:	58 0a       	cp.w	r10,0
80003570:	c0 b1       	brne	80003586 <vTaskSwitchContext+0x3e>
80003572:	21 48       	sub	r8,20
80003574:	49 0a       	lddpc	r10,800035b4 <vTaskSwitchContext+0x6c>
80003576:	f4 08 00 08 	add	r8,r10,r8
8000357a:	20 19       	sub	r9,1
8000357c:	10 9b       	mov	r11,r8
8000357e:	70 0a       	ld.w	r10,r8[0x0]
80003580:	21 48       	sub	r8,20
80003582:	58 0a       	cp.w	r10,0
80003584:	cf b0       	breq	8000357a <vTaskSwitchContext+0x32>
80003586:	76 18       	ld.w	r8,r11[0x4]
80003588:	70 18       	ld.w	r8,r8[0x4]
8000358a:	97 18       	st.w	r11[0x4],r8
8000358c:	f6 ca ff f8 	sub	r10,r11,-8
80003590:	14 38       	cp.w	r8,r10
80003592:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
80003596:	f7 f8 0a 01 	st.weq	r11[0x4],r8
8000359a:	76 18       	ld.w	r8,r11[0x4]
8000359c:	70 3a       	ld.w	r10,r8[0xc]
8000359e:	48 78       	lddpc	r8,800035b8 <vTaskSwitchContext+0x70>
800035a0:	91 0a       	st.w	r8[0x0],r10
800035a2:	48 48       	lddpc	r8,800035b0 <vTaskSwitchContext+0x68>
800035a4:	91 09       	st.w	r8[0x0],r9
800035a6:	5e fc       	retal	r12
800035a8:	00 00       	add	r0,r0
800035aa:	06 6c       	and	r12,r3
800035ac:	00 00       	add	r0,r0
800035ae:	06 bc       	st.h	r3++,r12
800035b0:	00 00       	add	r0,r0
800035b2:	06 b8       	st.h	r3++,r8
800035b4:	00 00       	add	r0,r0
800035b6:	05 98       	ld.ub	r8,r2[0x1]
800035b8:	00 00       	add	r0,r0
800035ba:	06 3c       	cp.w	r12,r3

800035bc <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
800035bc:	48 48       	lddpc	r8,800035cc <vTaskInternalSetTimeOutState+0x10>
800035be:	70 08       	ld.w	r8,r8[0x0]
800035c0:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
800035c2:	48 48       	lddpc	r8,800035d0 <vTaskInternalSetTimeOutState+0x14>
800035c4:	70 08       	ld.w	r8,r8[0x0]
800035c6:	99 18       	st.w	r12[0x4],r8
}
800035c8:	5e fc       	retal	r12
800035ca:	00 00       	add	r0,r0
800035cc:	00 00       	add	r0,r0
800035ce:	05 8c       	ld.ub	r12,r2[0x0]
800035d0:	00 00       	add	r0,r0
800035d2:	06 68       	and	r8,r3

800035d4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
800035d4:	30 19       	mov	r9,1
800035d6:	48 28       	lddpc	r8,800035dc <vTaskMissedYield+0x8>
800035d8:	91 09       	st.w	r8[0x0],r9
}
800035da:	5e fc       	retal	r12
800035dc:	00 00       	add	r0,r0
800035de:	06 bc       	st.h	r3++,r12

800035e0 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800035e0:	48 88       	lddpc	r8,80003600 <prvResetNextTaskUnblockTime+0x20>
800035e2:	70 08       	ld.w	r8,r8[0x0]
800035e4:	70 08       	ld.w	r8,r8[0x0]
800035e6:	58 08       	cp.w	r8,0
800035e8:	c0 51       	brne	800035f2 <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
800035ea:	3f f9       	mov	r9,-1
800035ec:	48 68       	lddpc	r8,80003604 <prvResetNextTaskUnblockTime+0x24>
800035ee:	91 09       	st.w	r8[0x0],r9
800035f0:	5e fc       	retal	r12
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
800035f2:	48 48       	lddpc	r8,80003600 <prvResetNextTaskUnblockTime+0x20>
800035f4:	70 08       	ld.w	r8,r8[0x0]
800035f6:	70 38       	ld.w	r8,r8[0xc]
800035f8:	70 09       	ld.w	r9,r8[0x0]
800035fa:	48 38       	lddpc	r8,80003604 <prvResetNextTaskUnblockTime+0x24>
800035fc:	91 09       	st.w	r8[0x0],r9
800035fe:	5e fc       	retal	r12
80003600:	00 00       	add	r0,r0
80003602:	05 84       	ld.ub	r4,r2[0x0]
80003604:	00 00       	add	r0,r0
80003606:	05 80       	ld.ub	r0,r2[0x0]

80003608 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
80003608:	eb cd 40 c0 	pushm	r6-r7,lr
8000360c:	18 97       	mov	r7,r12
8000360e:	16 96       	mov	r6,r11
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
80003610:	f0 1f 00 14 	mcall	80003660 <xTaskCheckForTimeOut+0x58>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
80003614:	49 48       	lddpc	r8,80003664 <xTaskCheckForTimeOut+0x5c>
80003616:	70 0a       	ld.w	r10,r8[0x0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
80003618:	6e 19       	ld.w	r9,r7[0x4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
8000361a:	6c 08       	ld.w	r8,r6[0x0]
8000361c:	5b f8       	cp.w	r8,-1
8000361e:	c0 31       	brne	80003624 <xTaskCheckForTimeOut+0x1c>
80003620:	30 07       	mov	r7,0
80003622:	c1 a8       	rjmp	80003656 <xTaskCheckForTimeOut+0x4e>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80003624:	49 1b       	lddpc	r11,80003668 <xTaskCheckForTimeOut+0x60>
80003626:	76 0b       	ld.w	r11,r11[0x0]
80003628:	6e 0c       	ld.w	r12,r7[0x0]
8000362a:	16 3c       	cp.w	r12,r11
8000362c:	c0 70       	breq	8000363a <xTaskCheckForTimeOut+0x32>
8000362e:	12 3a       	cp.w	r10,r9
80003630:	c0 53       	brcs	8000363a <xTaskCheckForTimeOut+0x32>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
80003632:	30 08       	mov	r8,0
80003634:	8d 08       	st.w	r6[0x0],r8
80003636:	30 17       	mov	r7,1
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80003638:	c0 f8       	rjmp	80003656 <xTaskCheckForTimeOut+0x4e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
8000363a:	f4 09 01 09 	sub	r9,r10,r9
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
8000363e:	10 39       	cp.w	r9,r8
80003640:	c0 82       	brcc	80003650 <xTaskCheckForTimeOut+0x48>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
80003642:	12 18       	sub	r8,r9
80003644:	8d 08       	st.w	r6[0x0],r8
            vTaskInternalSetTimeOutState( pxTimeOut );
80003646:	0e 9c       	mov	r12,r7
80003648:	f0 1f 00 09 	mcall	8000366c <xTaskCheckForTimeOut+0x64>
8000364c:	30 07       	mov	r7,0
8000364e:	c0 48       	rjmp	80003656 <xTaskCheckForTimeOut+0x4e>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
80003650:	30 08       	mov	r8,0
80003652:	8d 08       	st.w	r6[0x0],r8
80003654:	30 17       	mov	r7,1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
80003656:	f0 1f 00 07 	mcall	80003670 <xTaskCheckForTimeOut+0x68>

    return xReturn;
}
8000365a:	0e 9c       	mov	r12,r7
8000365c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003660:	80 00       	ld.sh	r0,r0[0x0]
80003662:	2f fc       	sub	r12,-1
80003664:	00 00       	add	r0,r0
80003666:	06 68       	and	r8,r3
80003668:	00 00       	add	r0,r0
8000366a:	05 8c       	ld.ub	r12,r2[0x0]
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	35 bc       	mov	r12,91
80003670:	80 00       	ld.sh	r0,r0[0x0]
80003672:	31 08       	mov	r8,16

80003674 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
80003674:	eb cd 40 f8 	pushm	r3-r7,lr
80003678:	18 97       	mov	r7,r12
8000367a:	16 95       	mov	r5,r11
8000367c:	14 93       	mov	r3,r10
8000367e:	12 96       	mov	r6,r9
80003680:	10 94       	mov	r4,r8

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
80003682:	f0 1f 00 31 	mcall	80003744 <xTaskGenericNotify+0xd0>
        {
            if( pulPreviousNotificationValue != NULL )
80003686:	58 04       	cp.w	r4,0
80003688:	c0 60       	breq	80003694 <xTaskGenericNotify+0x20>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
8000368a:	ea c8 ff ed 	sub	r8,r5,-19
8000368e:	ee 08 03 28 	ld.w	r8,r7[r8<<0x2]
80003692:	89 08       	st.w	r4[0x0],r8
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
80003694:	ee 05 00 08 	add	r8,r7,r5
80003698:	f1 39 00 50 	ld.ub	r9,r8[80]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
8000369c:	30 2a       	mov	r10,2
8000369e:	f1 6a 00 50 	st.b	r8[80],r10

            switch( eAction )
800036a2:	58 26       	cp.w	r6,2
800036a4:	c1 20       	breq	800036c8 <xTaskGenericNotify+0x54>
800036a6:	e0 8b 00 05 	brhi	800036b0 <xTaskGenericNotify+0x3c>
800036aa:	58 16       	cp.w	r6,1
800036ac:	c2 21       	brne	800036f0 <xTaskGenericNotify+0x7c>
800036ae:	c0 68       	rjmp	800036ba <xTaskGenericNotify+0x46>
800036b0:	58 36       	cp.w	r6,3
800036b2:	c1 20       	breq	800036d6 <xTaskGenericNotify+0x62>
800036b4:	58 46       	cp.w	r6,4
800036b6:	c1 d1       	brne	800036f0 <xTaskGenericNotify+0x7c>
800036b8:	c1 38       	rjmp	800036de <xTaskGenericNotify+0x6a>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
800036ba:	2e d5       	sub	r5,-19
800036bc:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
800036c0:	10 43       	or	r3,r8
800036c2:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
800036c6:	c1 58       	rjmp	800036f0 <xTaskGenericNotify+0x7c>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
800036c8:	2e d5       	sub	r5,-19
800036ca:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
800036ce:	2f f8       	sub	r8,-1
800036d0:	ee 05 09 28 	st.w	r7[r5<<0x2],r8
                    break;
800036d4:	c0 e8       	rjmp	800036f0 <xTaskGenericNotify+0x7c>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
800036d6:	2e d5       	sub	r5,-19
800036d8:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
800036dc:	c0 a8       	rjmp	800036f0 <xTaskGenericNotify+0x7c>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
800036de:	30 28       	mov	r8,2
800036e0:	f0 09 18 00 	cp.b	r9,r8
800036e4:	c0 31       	brne	800036ea <xTaskGenericNotify+0x76>
800036e6:	30 07       	mov	r7,0
800036e8:	c2 88       	rjmp	80003738 <xTaskGenericNotify+0xc4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
800036ea:	2e d5       	sub	r5,-19
800036ec:	ee 05 09 23 	st.w	r7[r5<<0x2],r3

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
800036f0:	30 18       	mov	r8,1
800036f2:	f0 09 18 00 	cp.b	r9,r8
800036f6:	c2 01       	brne	80003736 <xTaskGenericNotify+0xc2>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
800036f8:	ee c6 ff fc 	sub	r6,r7,-4
800036fc:	0c 9c       	mov	r12,r6
800036fe:	f0 1f 00 13 	mcall	80003748 <xTaskGenericNotify+0xd4>
                prvAddTaskToReadyList( pxTCB );
80003702:	6e bc       	ld.w	r12,r7[0x2c]
80003704:	49 28       	lddpc	r8,8000374c <xTaskGenericNotify+0xd8>
80003706:	70 08       	ld.w	r8,r8[0x0]
80003708:	10 3c       	cp.w	r12,r8
8000370a:	e0 88 00 04 	brls	80003712 <xTaskGenericNotify+0x9e>
8000370e:	49 08       	lddpc	r8,8000374c <xTaskGenericNotify+0xd8>
80003710:	91 0c       	st.w	r8[0x0],r12
80003712:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003716:	0c 9b       	mov	r11,r6
80003718:	48 e8       	lddpc	r8,80003750 <xTaskGenericNotify+0xdc>
8000371a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000371e:	f0 1f 00 0e 	mcall	80003754 <xTaskGenericNotify+0xe0>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80003722:	48 e8       	lddpc	r8,80003758 <xTaskGenericNotify+0xe4>
80003724:	70 08       	ld.w	r8,r8[0x0]
80003726:	6e b9       	ld.w	r9,r7[0x2c]
80003728:	70 b8       	ld.w	r8,r8[0x2c]
8000372a:	10 39       	cp.w	r9,r8
8000372c:	e0 88 00 05 	brls	80003736 <xTaskGenericNotify+0xc2>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
80003730:	d7 33       	scall
80003732:	30 17       	mov	r7,1
80003734:	c0 28       	rjmp	80003738 <xTaskGenericNotify+0xc4>
80003736:	30 17       	mov	r7,1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80003738:	f0 1f 00 09 	mcall	8000375c <xTaskGenericNotify+0xe8>

        return xReturn;
    }
8000373c:	0e 9c       	mov	r12,r7
8000373e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003742:	00 00       	add	r0,r0
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	2f fc       	sub	r12,-1
80003748:	80 00       	ld.sh	r0,r0[0x0]
8000374a:	2f 42       	sub	r2,-12
8000374c:	00 00       	add	r0,r0
8000374e:	06 b8       	st.h	r3++,r8
80003750:	00 00       	add	r0,r0
80003752:	05 98       	ld.ub	r8,r2[0x1]
80003754:	80 00       	ld.sh	r0,r0[0x0]
80003756:	2e fa       	sub	r10,-17
80003758:	00 00       	add	r0,r0
8000375a:	06 3c       	cp.w	r12,r3
8000375c:	80 00       	ld.sh	r0,r0[0x0]
8000375e:	31 08       	mov	r8,16

80003760 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
80003760:	eb cd 40 c0 	pushm	r6-r7,lr
80003764:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
80003766:	58 0c       	cp.w	r12,0
80003768:	c2 60       	breq	800037b4 <xTaskPriorityDisinherit+0x54>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
8000376a:	79 28       	ld.w	r8,r12[0x48]
8000376c:	20 18       	sub	r8,1
8000376e:	f9 48 00 48 	st.w	r12[72],r8

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80003772:	78 ba       	ld.w	r10,r12[0x2c]
80003774:	79 19       	ld.w	r9,r12[0x44]
80003776:	12 3a       	cp.w	r10,r9
80003778:	c1 e0       	breq	800037b4 <xTaskPriorityDisinherit+0x54>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
8000377a:	58 08       	cp.w	r8,0
8000377c:	c1 c1       	brne	800037b4 <xTaskPriorityDisinherit+0x54>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8000377e:	f8 c6 ff fc 	sub	r6,r12,-4
80003782:	0c 9c       	mov	r12,r6
80003784:	f0 1f 00 0d 	mcall	800037b8 <xTaskPriorityDisinherit+0x58>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
80003788:	6f 1c       	ld.w	r12,r7[0x44]
8000378a:	8f bc       	st.w	r7[0x2c],r12

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000378c:	f8 08 11 08 	rsub	r8,r12,8
80003790:	8f 68       	st.w	r7[0x18],r8
                    prvAddTaskToReadyList( pxTCB );
80003792:	48 b8       	lddpc	r8,800037bc <xTaskPriorityDisinherit+0x5c>
80003794:	70 08       	ld.w	r8,r8[0x0]
80003796:	10 3c       	cp.w	r12,r8
80003798:	e0 88 00 04 	brls	800037a0 <xTaskPriorityDisinherit+0x40>
8000379c:	48 88       	lddpc	r8,800037bc <xTaskPriorityDisinherit+0x5c>
8000379e:	91 0c       	st.w	r8[0x0],r12
800037a0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800037a4:	0c 9b       	mov	r11,r6
800037a6:	48 78       	lddpc	r8,800037c0 <xTaskPriorityDisinherit+0x60>
800037a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800037ac:	f0 1f 00 06 	mcall	800037c4 <xTaskPriorityDisinherit+0x64>
800037b0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800037b4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	2f 42       	sub	r2,-12
800037bc:	00 00       	add	r0,r0
800037be:	06 b8       	st.h	r3++,r8
800037c0:	00 00       	add	r0,r0
800037c2:	05 98       	ld.ub	r8,r2[0x1]
800037c4:	80 00       	ld.sh	r0,r0[0x0]
800037c6:	2e fa       	sub	r10,-17

800037c8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
800037c8:	eb cd 40 c0 	pushm	r6-r7,lr
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800037cc:	78 38       	ld.w	r8,r12[0xc]
800037ce:	70 37       	ld.w	r7,r8[0xc]
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
800037d0:	ee c6 ff e8 	sub	r6,r7,-24
800037d4:	0c 9c       	mov	r12,r6
800037d6:	f0 1f 00 18 	mcall	80003834 <xTaskRemoveFromEventList+0x6c>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
800037da:	49 88       	lddpc	r8,80003838 <xTaskRemoveFromEventList+0x70>
800037dc:	70 08       	ld.w	r8,r8[0x0]
800037de:	58 08       	cp.w	r8,0
800037e0:	c1 71       	brne	8000380e <xTaskRemoveFromEventList+0x46>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
800037e2:	ee c6 ff fc 	sub	r6,r7,-4
800037e6:	0c 9c       	mov	r12,r6
800037e8:	f0 1f 00 13 	mcall	80003834 <xTaskRemoveFromEventList+0x6c>
        prvAddTaskToReadyList( pxUnblockedTCB );
800037ec:	6e bc       	ld.w	r12,r7[0x2c]
800037ee:	49 48       	lddpc	r8,8000383c <xTaskRemoveFromEventList+0x74>
800037f0:	70 08       	ld.w	r8,r8[0x0]
800037f2:	10 3c       	cp.w	r12,r8
800037f4:	e0 88 00 04 	brls	800037fc <xTaskRemoveFromEventList+0x34>
800037f8:	49 18       	lddpc	r8,8000383c <xTaskRemoveFromEventList+0x74>
800037fa:	91 0c       	st.w	r8[0x0],r12
800037fc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003800:	0c 9b       	mov	r11,r6
80003802:	49 08       	lddpc	r8,80003840 <xTaskRemoveFromEventList+0x78>
80003804:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003808:	f0 1f 00 0f 	mcall	80003844 <xTaskRemoveFromEventList+0x7c>
8000380c:	c0 58       	rjmp	80003816 <xTaskRemoveFromEventList+0x4e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000380e:	0c 9b       	mov	r11,r6
80003810:	48 ec       	lddpc	r12,80003848 <xTaskRemoveFromEventList+0x80>
80003812:	f0 1f 00 0d 	mcall	80003844 <xTaskRemoveFromEventList+0x7c>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80003816:	48 e8       	lddpc	r8,8000384c <xTaskRemoveFromEventList+0x84>
80003818:	70 08       	ld.w	r8,r8[0x0]
8000381a:	6e b9       	ld.w	r9,r7[0x2c]
8000381c:	70 b8       	ld.w	r8,r8[0x2c]
8000381e:	10 39       	cp.w	r9,r8
80003820:	e0 8b 00 04 	brhi	80003828 <xTaskRemoveFromEventList+0x60>
80003824:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
80003828:	30 1c       	mov	r12,1
8000382a:	48 a8       	lddpc	r8,80003850 <xTaskRemoveFromEventList+0x88>
8000382c:	91 0c       	st.w	r8[0x0],r12
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
8000382e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003832:	00 00       	add	r0,r0
80003834:	80 00       	ld.sh	r0,r0[0x0]
80003836:	2f 42       	sub	r2,-12
80003838:	00 00       	add	r0,r0
8000383a:	06 6c       	and	r12,r3
8000383c:	00 00       	add	r0,r0
8000383e:	06 b8       	st.h	r3++,r8
80003840:	00 00       	add	r0,r0
80003842:	05 98       	ld.ub	r8,r2[0x1]
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	2e fa       	sub	r10,-17
80003848:	00 00       	add	r0,r0
8000384a:	06 40       	or	r0,r3
8000384c:	00 00       	add	r0,r0
8000384e:	06 3c       	cp.w	r12,r3
80003850:	00 00       	add	r0,r0
80003852:	06 bc       	st.h	r3++,r12

80003854 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
80003854:	d4 31       	pushm	r0-r7,lr
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003856:	4b 48       	lddpc	r8,80003924 <xTaskIncrementTick+0xd0>
80003858:	70 08       	ld.w	r8,r8[0x0]
8000385a:	58 08       	cp.w	r8,0
8000385c:	c5 d1       	brne	80003916 <xTaskIncrementTick+0xc2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
8000385e:	4b 38       	lddpc	r8,80003928 <xTaskIncrementTick+0xd4>
80003860:	70 02       	ld.w	r2,r8[0x0]
80003862:	2f f2       	sub	r2,-1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
80003864:	91 02       	st.w	r8[0x0],r2

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
80003866:	c0 d1       	brne	80003880 <xTaskIncrementTick+0x2c>
        {
            taskSWITCH_DELAYED_LISTS();
80003868:	4b 19       	lddpc	r9,8000392c <xTaskIncrementTick+0xd8>
8000386a:	72 0a       	ld.w	r10,r9[0x0]
8000386c:	4b 18       	lddpc	r8,80003930 <xTaskIncrementTick+0xdc>
8000386e:	70 0b       	ld.w	r11,r8[0x0]
80003870:	93 0b       	st.w	r9[0x0],r11
80003872:	91 0a       	st.w	r8[0x0],r10
80003874:	4b 08       	lddpc	r8,80003934 <xTaskIncrementTick+0xe0>
80003876:	70 09       	ld.w	r9,r8[0x0]
80003878:	2f f9       	sub	r9,-1
8000387a:	91 09       	st.w	r8[0x0],r9
8000387c:	f0 1f 00 2f 	mcall	80003938 <xTaskIncrementTick+0xe4>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
80003880:	4a f8       	lddpc	r8,8000393c <xTaskIncrementTick+0xe8>
80003882:	70 08       	ld.w	r8,r8[0x0]
80003884:	10 32       	cp.w	r2,r8
80003886:	c3 63       	brcs	800038f2 <xTaskIncrementTick+0x9e>
80003888:	30 06       	mov	r6,0
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000388a:	4a 94       	lddpc	r4,8000392c <xTaskIncrementTick+0xd8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
8000388c:	4a d3       	lddpc	r3,80003940 <xTaskIncrementTick+0xec>
8000388e:	4a e1       	lddpc	r1,80003944 <xTaskIncrementTick+0xf0>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003890:	4a e0       	lddpc	r0,80003948 <xTaskIncrementTick+0xf4>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80003892:	68 08       	ld.w	r8,r4[0x0]
80003894:	70 08       	ld.w	r8,r8[0x0]
80003896:	58 08       	cp.w	r8,0
80003898:	c0 51       	brne	800038a2 <xTaskIncrementTick+0x4e>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000389a:	3f f9       	mov	r9,-1
8000389c:	4a 88       	lddpc	r8,8000393c <xTaskIncrementTick+0xe8>
8000389e:	91 09       	st.w	r8[0x0],r9
                    break;
800038a0:	c2 a8       	rjmp	800038f4 <xTaskIncrementTick+0xa0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800038a2:	68 08       	ld.w	r8,r4[0x0]
800038a4:	70 38       	ld.w	r8,r8[0xc]
800038a6:	70 37       	ld.w	r7,r8[0xc]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
800038a8:	6e 18       	ld.w	r8,r7[0x4]

                    if( xConstTickCount < xItemValue )
800038aa:	10 32       	cp.w	r2,r8
800038ac:	c0 42       	brcc	800038b4 <xTaskIncrementTick+0x60>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
800038ae:	4a 49       	lddpc	r9,8000393c <xTaskIncrementTick+0xe8>
800038b0:	93 08       	st.w	r9[0x0],r8
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
800038b2:	c2 18       	rjmp	800038f4 <xTaskIncrementTick+0xa0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
800038b4:	ee c5 ff fc 	sub	r5,r7,-4
800038b8:	0a 9c       	mov	r12,r5
800038ba:	f0 1f 00 25 	mcall	8000394c <xTaskIncrementTick+0xf8>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
800038be:	6e a8       	ld.w	r8,r7[0x28]
800038c0:	58 08       	cp.w	r8,0
800038c2:	c0 50       	breq	800038cc <xTaskIncrementTick+0x78>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
800038c4:	ee cc ff e8 	sub	r12,r7,-24
800038c8:	f0 1f 00 21 	mcall	8000394c <xTaskIncrementTick+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
800038cc:	6e bc       	ld.w	r12,r7[0x2c]
800038ce:	66 08       	ld.w	r8,r3[0x0]
800038d0:	10 3c       	cp.w	r12,r8
800038d2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800038d6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800038da:	0a 9b       	mov	r11,r5
800038dc:	e2 0c 00 2c 	add	r12,r1,r12<<0x2
800038e0:	f0 1f 00 1c 	mcall	80003950 <xTaskIncrementTick+0xfc>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800038e4:	60 08       	ld.w	r8,r0[0x0]
800038e6:	6e b9       	ld.w	r9,r7[0x2c]
800038e8:	70 b8       	ld.w	r8,r8[0x2c]
800038ea:	10 39       	cp.w	r9,r8
800038ec:	f9 b6 02 01 	movhs	r6,1
800038f0:	cd 1b       	rjmp	80003892 <xTaskIncrementTick+0x3e>
800038f2:	30 06       	mov	r6,0
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
800038f4:	49 58       	lddpc	r8,80003948 <xTaskIncrementTick+0xf4>
800038f6:	70 08       	ld.w	r8,r8[0x0]
800038f8:	70 b8       	ld.w	r8,r8[0x2c]
800038fa:	f0 08 00 28 	add	r8,r8,r8<<0x2
800038fe:	49 29       	lddpc	r9,80003944 <xTaskIncrementTick+0xf0>
80003900:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80003904:	58 28       	cp.w	r8,2
80003906:	f9 b6 02 01 	movhs	r6,1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
8000390a:	49 38       	lddpc	r8,80003954 <xTaskIncrementTick+0x100>
8000390c:	70 08       	ld.w	r8,r8[0x0]
8000390e:	58 08       	cp.w	r8,0
80003910:	f9 b6 01 01 	movne	r6,1
80003914:	c0 68       	rjmp	80003920 <xTaskIncrementTick+0xcc>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
80003916:	49 18       	lddpc	r8,80003958 <xTaskIncrementTick+0x104>
80003918:	70 09       	ld.w	r9,r8[0x0]
8000391a:	2f f9       	sub	r9,-1
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	30 06       	mov	r6,0
            }
        #endif
    }

    return xSwitchRequired;
}
80003920:	0c 9c       	mov	r12,r6
80003922:	d8 32       	popm	r0-r7,pc
80003924:	00 00       	add	r0,r0
80003926:	06 6c       	and	r12,r3
80003928:	00 00       	add	r0,r0
8000392a:	06 68       	and	r8,r3
8000392c:	00 00       	add	r0,r0
8000392e:	05 84       	ld.ub	r4,r2[0x0]
80003930:	00 00       	add	r0,r0
80003932:	05 90       	ld.ub	r0,r2[0x1]
80003934:	00 00       	add	r0,r0
80003936:	05 8c       	ld.ub	r12,r2[0x0]
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	35 e0       	mov	r0,94
8000393c:	00 00       	add	r0,r0
8000393e:	05 80       	ld.ub	r0,r2[0x0]
80003940:	00 00       	add	r0,r0
80003942:	06 b8       	st.h	r3++,r8
80003944:	00 00       	add	r0,r0
80003946:	05 98       	ld.ub	r8,r2[0x1]
80003948:	00 00       	add	r0,r0
8000394a:	06 3c       	cp.w	r12,r3
8000394c:	80 00       	ld.sh	r0,r0[0x0]
8000394e:	2f 42       	sub	r2,-12
80003950:	80 00       	ld.sh	r0,r0[0x0]
80003952:	2e fa       	sub	r10,-17
80003954:	00 00       	add	r0,r0
80003956:	06 bc       	st.h	r3++,r12
80003958:	00 00       	add	r0,r0
8000395a:	05 94       	ld.ub	r4,r2[0x1]

8000395c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
8000395c:	d4 31       	pushm	r0-r7,lr
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
8000395e:	f0 1f 00 2b 	mcall	80003a08 <xTaskResumeAll+0xac>
    {
        --uxSchedulerSuspended;
80003962:	4a b8       	lddpc	r8,80003a0c <xTaskResumeAll+0xb0>
80003964:	70 09       	ld.w	r9,r8[0x0]
80003966:	20 19       	sub	r9,1
80003968:	91 09       	st.w	r8[0x0],r9

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
8000396a:	70 08       	ld.w	r8,r8[0x0]
8000396c:	58 08       	cp.w	r8,0
8000396e:	c4 71       	brne	800039fc <xTaskResumeAll+0xa0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80003970:	4a 88       	lddpc	r8,80003a10 <xTaskResumeAll+0xb4>
80003972:	70 08       	ld.w	r8,r8[0x0]
80003974:	58 08       	cp.w	r8,0
80003976:	c4 30       	breq	800039fc <xTaskResumeAll+0xa0>
80003978:	30 07       	mov	r7,0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
8000397a:	4a 76       	lddpc	r6,80003a14 <xTaskResumeAll+0xb8>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
8000397c:	4a 74       	lddpc	r4,80003a18 <xTaskResumeAll+0xbc>
8000397e:	4a 83       	lddpc	r3,80003a1c <xTaskResumeAll+0xc0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003980:	4a 82       	lddpc	r2,80003a20 <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
80003982:	4a 91       	lddpc	r1,80003a24 <xTaskResumeAll+0xc8>
80003984:	30 10       	mov	r0,1
80003986:	c1 e8       	rjmp	800039c2 <xTaskResumeAll+0x66>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003988:	6c 38       	ld.w	r8,r6[0xc]
8000398a:	70 37       	ld.w	r7,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
8000398c:	ee cc ff e8 	sub	r12,r7,-24
80003990:	f0 1f 00 26 	mcall	80003a28 <xTaskResumeAll+0xcc>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003994:	ee c5 ff fc 	sub	r5,r7,-4
80003998:	0a 9c       	mov	r12,r5
8000399a:	f0 1f 00 24 	mcall	80003a28 <xTaskResumeAll+0xcc>
                    prvAddTaskToReadyList( pxTCB );
8000399e:	6e bc       	ld.w	r12,r7[0x2c]
800039a0:	68 08       	ld.w	r8,r4[0x0]
800039a2:	10 3c       	cp.w	r12,r8
800039a4:	e9 fc ba 00 	st.whi	r4[0x0],r12
800039a8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800039ac:	0a 9b       	mov	r11,r5
800039ae:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800039b2:	f0 1f 00 1f 	mcall	80003a2c <xTaskResumeAll+0xd0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800039b6:	64 08       	ld.w	r8,r2[0x0]
800039b8:	6e b9       	ld.w	r9,r7[0x2c]
800039ba:	70 b8       	ld.w	r8,r8[0x2c]
                    {
                        xYieldPending = pdTRUE;
800039bc:	10 39       	cp.w	r9,r8
800039be:	e3 f0 2a 00 	st.wcc	r1[0x0],r0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
800039c2:	6c 08       	ld.w	r8,r6[0x0]
800039c4:	58 08       	cp.w	r8,0
800039c6:	ce 11       	brne	80003988 <xTaskResumeAll+0x2c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
800039c8:	58 07       	cp.w	r7,0
800039ca:	c0 30       	breq	800039d0 <xTaskResumeAll+0x74>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
800039cc:	f0 1f 00 19 	mcall	80003a30 <xTaskResumeAll+0xd4>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
800039d0:	49 98       	lddpc	r8,80003a34 <xTaskResumeAll+0xd8>
800039d2:	70 07       	ld.w	r7,r8[0x0]

                    if( xPendedCounts > ( TickType_t ) 0U )
800039d4:	58 07       	cp.w	r7,0
800039d6:	c0 c0       	breq	800039ee <xTaskResumeAll+0x92>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
800039d8:	49 36       	lddpc	r6,80003a24 <xTaskResumeAll+0xc8>
800039da:	30 15       	mov	r5,1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
800039dc:	f0 1f 00 17 	mcall	80003a38 <xTaskResumeAll+0xdc>
                            {
                                xYieldPending = pdTRUE;
800039e0:	ed f5 1a 00 	st.wne	r6[0x0],r5
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
800039e4:	20 17       	sub	r7,1
                        } while( xPendedCounts > ( TickType_t ) 0U );
800039e6:	cf b1       	brne	800039dc <xTaskResumeAll+0x80>

                        xPendedTicks = 0;
800039e8:	30 09       	mov	r9,0
800039ea:	49 38       	lddpc	r8,80003a34 <xTaskResumeAll+0xd8>
800039ec:	91 09       	st.w	r8[0x0],r9
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
800039ee:	48 e8       	lddpc	r8,80003a24 <xTaskResumeAll+0xc8>
800039f0:	70 08       	ld.w	r8,r8[0x0]
800039f2:	58 08       	cp.w	r8,0
800039f4:	c0 40       	breq	800039fc <xTaskResumeAll+0xa0>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
800039f6:	d7 33       	scall
800039f8:	30 17       	mov	r7,1
800039fa:	c0 28       	rjmp	800039fe <xTaskResumeAll+0xa2>
800039fc:	30 07       	mov	r7,0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
800039fe:	f0 1f 00 10 	mcall	80003a3c <xTaskResumeAll+0xe0>

    return xAlreadyYielded;
}
80003a02:	0e 9c       	mov	r12,r7
80003a04:	d8 32       	popm	r0-r7,pc
80003a06:	00 00       	add	r0,r0
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	2f fc       	sub	r12,-1
80003a0c:	00 00       	add	r0,r0
80003a0e:	06 6c       	and	r12,r3
80003a10:	00 00       	add	r0,r0
80003a12:	06 88       	andn	r8,r3
80003a14:	00 00       	add	r0,r0
80003a16:	06 40       	or	r0,r3
80003a18:	00 00       	add	r0,r0
80003a1a:	06 b8       	st.h	r3++,r8
80003a1c:	00 00       	add	r0,r0
80003a1e:	05 98       	ld.ub	r8,r2[0x1]
80003a20:	00 00       	add	r0,r0
80003a22:	06 3c       	cp.w	r12,r3
80003a24:	00 00       	add	r0,r0
80003a26:	06 bc       	st.h	r3++,r12
80003a28:	80 00       	ld.sh	r0,r0[0x0]
80003a2a:	2f 42       	sub	r2,-12
80003a2c:	80 00       	ld.sh	r0,r0[0x0]
80003a2e:	2e fa       	sub	r10,-17
80003a30:	80 00       	ld.sh	r0,r0[0x0]
80003a32:	35 e0       	mov	r0,94
80003a34:	00 00       	add	r0,r0
80003a36:	05 94       	ld.ub	r4,r2[0x1]
80003a38:	80 00       	ld.sh	r0,r0[0x0]
80003a3a:	38 54       	mov	r4,-123
80003a3c:	80 00       	ld.sh	r0,r0[0x0]
80003a3e:	31 08       	mov	r8,16

80003a40 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
80003a40:	d4 21       	pushm	r4-r7,lr
80003a42:	18 97       	mov	r7,r12
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80003a44:	f0 1f 00 17 	mcall	80003aa0 <xTaskResumeFromISR+0x60>
80003a48:	c0 31       	brne	80003a4e <xTaskResumeFromISR+0xe>
80003a4a:	30 07       	mov	r7,0
80003a4c:	c2 78       	rjmp	80003a9a <xTaskResumeFromISR+0x5a>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003a4e:	49 68       	lddpc	r8,80003aa4 <xTaskResumeFromISR+0x64>
80003a50:	70 08       	ld.w	r8,r8[0x0]
80003a52:	58 08       	cp.w	r8,0
80003a54:	c1 d1       	brne	80003a8e <xTaskResumeFromISR+0x4e>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003a56:	6e b5       	ld.w	r5,r7[0x2c]
80003a58:	49 48       	lddpc	r8,80003aa8 <xTaskResumeFromISR+0x68>
80003a5a:	70 08       	ld.w	r8,r8[0x0]
80003a5c:	70 b4       	ld.w	r4,r8[0x2c]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003a5e:	ee c6 ff fc 	sub	r6,r7,-4
80003a62:	0c 9c       	mov	r12,r6
80003a64:	f0 1f 00 12 	mcall	80003aac <xTaskResumeFromISR+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80003a68:	6e bc       	ld.w	r12,r7[0x2c]
80003a6a:	49 28       	lddpc	r8,80003ab0 <xTaskResumeFromISR+0x70>
80003a6c:	70 08       	ld.w	r8,r8[0x0]
80003a6e:	10 3c       	cp.w	r12,r8
80003a70:	e0 88 00 04 	brls	80003a78 <xTaskResumeFromISR+0x38>
80003a74:	48 f8       	lddpc	r8,80003ab0 <xTaskResumeFromISR+0x70>
80003a76:	91 0c       	st.w	r8[0x0],r12
80003a78:	08 35       	cp.w	r5,r4
80003a7a:	5f 27       	srhs	r7
80003a7c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003a80:	0c 9b       	mov	r11,r6
80003a82:	48 d8       	lddpc	r8,80003ab4 <xTaskResumeFromISR+0x74>
80003a84:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003a88:	f0 1f 00 0c 	mcall	80003ab8 <xTaskResumeFromISR+0x78>
80003a8c:	c0 78       	rjmp	80003a9a <xTaskResumeFromISR+0x5a>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80003a8e:	ee cb ff e8 	sub	r11,r7,-24
80003a92:	48 bc       	lddpc	r12,80003abc <xTaskResumeFromISR+0x7c>
80003a94:	f0 1f 00 09 	mcall	80003ab8 <xTaskResumeFromISR+0x78>
80003a98:	30 07       	mov	r7,0
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
80003a9a:	0e 9c       	mov	r12,r7
80003a9c:	d8 22       	popm	r4-r7,pc
80003a9e:	00 00       	add	r0,r0
80003aa0:	80 00       	ld.sh	r0,r0[0x0]
80003aa2:	35 18       	mov	r8,81
80003aa4:	00 00       	add	r0,r0
80003aa6:	06 6c       	and	r12,r3
80003aa8:	00 00       	add	r0,r0
80003aaa:	06 3c       	cp.w	r12,r3
80003aac:	80 00       	ld.sh	r0,r0[0x0]
80003aae:	2f 42       	sub	r2,-12
80003ab0:	00 00       	add	r0,r0
80003ab2:	06 b8       	st.h	r3++,r8
80003ab4:	00 00       	add	r0,r0
80003ab6:	05 98       	ld.ub	r8,r2[0x1]
80003ab8:	80 00       	ld.sh	r0,r0[0x0]
80003aba:	2e fa       	sub	r10,-17
80003abc:	00 00       	add	r0,r0
80003abe:	06 40       	or	r0,r3

80003ac0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
80003ac0:	eb cd 40 c0 	pushm	r6-r7,lr
80003ac4:	18 97       	mov	r7,r12
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
80003ac6:	f0 1f 00 23 	mcall	80003b50 <vTaskSuspend+0x90>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
80003aca:	58 07       	cp.w	r7,0
80003acc:	c0 31       	brne	80003ad2 <vTaskSuspend+0x12>
80003ace:	4a 28       	lddpc	r8,80003b54 <vTaskSuspend+0x94>
80003ad0:	70 07       	ld.w	r7,r8[0x0]

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80003ad2:	ee c6 ff fc 	sub	r6,r7,-4
80003ad6:	0c 9c       	mov	r12,r6
80003ad8:	f0 1f 00 20 	mcall	80003b58 <vTaskSuspend+0x98>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80003adc:	6e a8       	ld.w	r8,r7[0x28]
80003ade:	58 08       	cp.w	r8,0
80003ae0:	c0 50       	breq	80003aea <vTaskSuspend+0x2a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80003ae2:	ee cc ff e8 	sub	r12,r7,-24
80003ae6:	f0 1f 00 1d 	mcall	80003b58 <vTaskSuspend+0x98>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
80003aea:	0c 9b       	mov	r11,r6
80003aec:	49 cc       	lddpc	r12,80003b5c <vTaskSuspend+0x9c>
80003aee:	f0 1f 00 1d 	mcall	80003b60 <vTaskSuspend+0xa0>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
80003af2:	ef 39 00 50 	ld.ub	r9,r7[80]
80003af6:	30 18       	mov	r8,1
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
80003af8:	f0 09 18 00 	cp.b	r9,r8
80003afc:	f9 b8 00 00 	moveq	r8,0
80003b00:	ef f8 0e 50 	st.beq	r7[0x50],r8
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
80003b04:	f0 1f 00 18 	mcall	80003b64 <vTaskSuspend+0xa4>

        if( xSchedulerRunning != pdFALSE )
80003b08:	49 88       	lddpc	r8,80003b68 <vTaskSuspend+0xa8>
80003b0a:	70 08       	ld.w	r8,r8[0x0]
80003b0c:	58 08       	cp.w	r8,0
80003b0e:	c0 70       	breq	80003b1c <vTaskSuspend+0x5c>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
80003b10:	f0 1f 00 10 	mcall	80003b50 <vTaskSuspend+0x90>
            {
                prvResetNextTaskUnblockTime();
80003b14:	f0 1f 00 16 	mcall	80003b6c <vTaskSuspend+0xac>
            }
            taskEXIT_CRITICAL();
80003b18:	f0 1f 00 13 	mcall	80003b64 <vTaskSuspend+0xa4>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
80003b1c:	48 e8       	lddpc	r8,80003b54 <vTaskSuspend+0x94>
80003b1e:	70 08       	ld.w	r8,r8[0x0]
80003b20:	10 37       	cp.w	r7,r8
80003b22:	c1 51       	brne	80003b4c <vTaskSuspend+0x8c>
        {
            if( xSchedulerRunning != pdFALSE )
80003b24:	49 18       	lddpc	r8,80003b68 <vTaskSuspend+0xa8>
80003b26:	70 08       	ld.w	r8,r8[0x0]
80003b28:	58 08       	cp.w	r8,0
80003b2a:	c0 40       	breq	80003b32 <vTaskSuspend+0x72>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
80003b2c:	d7 33       	scall
80003b2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
80003b32:	48 b8       	lddpc	r8,80003b5c <vTaskSuspend+0x9c>
80003b34:	70 09       	ld.w	r9,r8[0x0]
80003b36:	48 f8       	lddpc	r8,80003b70 <vTaskSuspend+0xb0>
80003b38:	70 08       	ld.w	r8,r8[0x0]
80003b3a:	10 39       	cp.w	r9,r8
80003b3c:	c0 61       	brne	80003b48 <vTaskSuspend+0x88>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
80003b3e:	30 09       	mov	r9,0
80003b40:	48 58       	lddpc	r8,80003b54 <vTaskSuspend+0x94>
80003b42:	91 09       	st.w	r8[0x0],r9
80003b44:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                }
                else
                {
                    vTaskSwitchContext();
80003b48:	f0 1f 00 0b 	mcall	80003b74 <vTaskSuspend+0xb4>
80003b4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003b50:	80 00       	ld.sh	r0,r0[0x0]
80003b52:	2f fc       	sub	r12,-1
80003b54:	00 00       	add	r0,r0
80003b56:	06 3c       	cp.w	r12,r3
80003b58:	80 00       	ld.sh	r0,r0[0x0]
80003b5a:	2f 42       	sub	r2,-12
80003b5c:	00 00       	add	r0,r0
80003b5e:	06 a4       	st.w	r3++,r4
80003b60:	80 00       	ld.sh	r0,r0[0x0]
80003b62:	2e fa       	sub	r10,-17
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	31 08       	mov	r8,16
80003b68:	00 00       	add	r0,r0
80003b6a:	05 88       	ld.ub	r8,r2[0x0]
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	35 e0       	mov	r0,94
80003b70:	00 00       	add	r0,r0
80003b72:	06 88       	andn	r8,r3
80003b74:	80 00       	ld.sh	r0,r0[0x0]
80003b76:	35 48       	mov	r8,84

80003b78 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
80003b78:	eb cd 40 e0 	pushm	r5-r7,lr
80003b7c:	18 97       	mov	r7,r12
80003b7e:	16 95       	mov	r5,r11
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
80003b80:	49 b8       	lddpc	r8,80003bec <prvAddCurrentTaskToDelayedList+0x74>
80003b82:	70 06       	ld.w	r6,r8[0x0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80003b84:	49 b8       	lddpc	r8,80003bf0 <prvAddCurrentTaskToDelayedList+0x78>
80003b86:	70 0c       	ld.w	r12,r8[0x0]
80003b88:	2f cc       	sub	r12,-4
80003b8a:	f0 1f 00 1b 	mcall	80003bf4 <prvAddCurrentTaskToDelayedList+0x7c>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80003b8e:	5b f7       	cp.w	r7,-1
80003b90:	5f 09       	sreq	r9
80003b92:	58 05       	cp.w	r5,0
80003b94:	5f 18       	srne	r8
80003b96:	f3 e8 00 08 	and	r8,r9,r8
80003b9a:	c0 90       	breq	80003bac <prvAddCurrentTaskToDelayedList+0x34>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003b9c:	49 58       	lddpc	r8,80003bf0 <prvAddCurrentTaskToDelayedList+0x78>
80003b9e:	70 0b       	ld.w	r11,r8[0x0]
80003ba0:	2f cb       	sub	r11,-4
80003ba2:	49 6c       	lddpc	r12,80003bf8 <prvAddCurrentTaskToDelayedList+0x80>
80003ba4:	f0 1f 00 16 	mcall	80003bfc <prvAddCurrentTaskToDelayedList+0x84>
80003ba8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
80003bac:	0c 07       	add	r7,r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80003bae:	49 18       	lddpc	r8,80003bf0 <prvAddCurrentTaskToDelayedList+0x78>
80003bb0:	70 08       	ld.w	r8,r8[0x0]
80003bb2:	91 17       	st.w	r8[0x4],r7

                if( xTimeToWake < xConstTickCount )
80003bb4:	0e 36       	cp.w	r6,r7
80003bb6:	e0 88 00 0b 	brls	80003bcc <prvAddCurrentTaskToDelayedList+0x54>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003bba:	48 e8       	lddpc	r8,80003bf0 <prvAddCurrentTaskToDelayedList+0x78>
80003bbc:	70 0b       	ld.w	r11,r8[0x0]
80003bbe:	49 18       	lddpc	r8,80003c00 <prvAddCurrentTaskToDelayedList+0x88>
80003bc0:	70 0c       	ld.w	r12,r8[0x0]
80003bc2:	2f cb       	sub	r11,-4
80003bc4:	f0 1f 00 10 	mcall	80003c04 <prvAddCurrentTaskToDelayedList+0x8c>
80003bc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003bcc:	48 98       	lddpc	r8,80003bf0 <prvAddCurrentTaskToDelayedList+0x78>
80003bce:	70 0b       	ld.w	r11,r8[0x0]
80003bd0:	48 e8       	lddpc	r8,80003c08 <prvAddCurrentTaskToDelayedList+0x90>
80003bd2:	70 0c       	ld.w	r12,r8[0x0]
80003bd4:	2f cb       	sub	r11,-4
80003bd6:	f0 1f 00 0c 	mcall	80003c04 <prvAddCurrentTaskToDelayedList+0x8c>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
80003bda:	48 d8       	lddpc	r8,80003c0c <prvAddCurrentTaskToDelayedList+0x94>
80003bdc:	70 08       	ld.w	r8,r8[0x0]
80003bde:	10 37       	cp.w	r7,r8
80003be0:	c0 32       	brcc	80003be6 <prvAddCurrentTaskToDelayedList+0x6e>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
80003be2:	48 b8       	lddpc	r8,80003c0c <prvAddCurrentTaskToDelayedList+0x94>
80003be4:	91 07       	st.w	r8[0x0],r7
80003be6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003bea:	00 00       	add	r0,r0
80003bec:	00 00       	add	r0,r0
80003bee:	06 68       	and	r8,r3
80003bf0:	00 00       	add	r0,r0
80003bf2:	06 3c       	cp.w	r12,r3
80003bf4:	80 00       	ld.sh	r0,r0[0x0]
80003bf6:	2f 42       	sub	r2,-12
80003bf8:	00 00       	add	r0,r0
80003bfa:	06 a4       	st.w	r3++,r4
80003bfc:	80 00       	ld.sh	r0,r0[0x0]
80003bfe:	2e fa       	sub	r10,-17
80003c00:	00 00       	add	r0,r0
80003c02:	05 90       	ld.ub	r0,r2[0x1]
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	2f 12       	sub	r2,-15
80003c08:	00 00       	add	r0,r0
80003c0a:	05 84       	ld.ub	r4,r2[0x0]
80003c0c:	00 00       	add	r0,r0
80003c0e:	05 80       	ld.ub	r0,r2[0x0]

80003c10 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
80003c10:	eb cd 40 e0 	pushm	r5-r7,lr
80003c14:	18 97       	mov	r7,r12
80003c16:	16 95       	mov	r5,r11
80003c18:	14 96       	mov	r6,r10
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
80003c1a:	f0 1f 00 20 	mcall	80003c98 <ulTaskGenericNotifyTake+0x88>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
80003c1e:	4a 08       	lddpc	r8,80003c9c <ulTaskGenericNotifyTake+0x8c>
80003c20:	70 08       	ld.w	r8,r8[0x0]
80003c22:	ee c9 ff ed 	sub	r9,r7,-19
80003c26:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80003c2a:	58 08       	cp.w	r8,0
80003c2c:	c0 e1       	brne	80003c48 <ulTaskGenericNotifyTake+0x38>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
80003c2e:	49 c8       	lddpc	r8,80003c9c <ulTaskGenericNotifyTake+0x8c>
80003c30:	70 08       	ld.w	r8,r8[0x0]
80003c32:	0e 08       	add	r8,r7
80003c34:	30 19       	mov	r9,1
80003c36:	f1 69 00 50 	st.b	r8[80],r9

                if( xTicksToWait > ( TickType_t ) 0 )
80003c3a:	58 06       	cp.w	r6,0
80003c3c:	c0 60       	breq	80003c48 <ulTaskGenericNotifyTake+0x38>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80003c3e:	30 1b       	mov	r11,1
80003c40:	0c 9c       	mov	r12,r6
80003c42:	f0 1f 00 18 	mcall	80003ca0 <ulTaskGenericNotifyTake+0x90>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
80003c46:	d7 33       	scall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80003c48:	f0 1f 00 17 	mcall	80003ca4 <ulTaskGenericNotifyTake+0x94>

        taskENTER_CRITICAL();
80003c4c:	f0 1f 00 13 	mcall	80003c98 <ulTaskGenericNotifyTake+0x88>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
80003c50:	49 38       	lddpc	r8,80003c9c <ulTaskGenericNotifyTake+0x8c>
80003c52:	70 08       	ld.w	r8,r8[0x0]
80003c54:	ee c9 ff ed 	sub	r9,r7,-19
80003c58:	f0 09 03 26 	ld.w	r6,r8[r9<<0x2]

            if( ulReturn != 0UL )
80003c5c:	58 06       	cp.w	r6,0
80003c5e:	c1 10       	breq	80003c80 <ulTaskGenericNotifyTake+0x70>
            {
                if( xClearCountOnExit != pdFALSE )
80003c60:	58 05       	cp.w	r5,0
80003c62:	c0 70       	breq	80003c70 <ulTaskGenericNotifyTake+0x60>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
80003c64:	48 e8       	lddpc	r8,80003c9c <ulTaskGenericNotifyTake+0x8c>
80003c66:	70 08       	ld.w	r8,r8[0x0]
80003c68:	30 0a       	mov	r10,0
80003c6a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80003c6e:	c0 98       	rjmp	80003c80 <ulTaskGenericNotifyTake+0x70>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
80003c70:	48 b8       	lddpc	r8,80003c9c <ulTaskGenericNotifyTake+0x8c>
80003c72:	70 08       	ld.w	r8,r8[0x0]
80003c74:	ec ca 00 01 	sub	r10,r6,1
80003c78:	ee c9 ff ed 	sub	r9,r7,-19
80003c7c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
80003c80:	48 78       	lddpc	r8,80003c9c <ulTaskGenericNotifyTake+0x8c>
80003c82:	70 08       	ld.w	r8,r8[0x0]
80003c84:	f0 07 00 07 	add	r7,r8,r7
80003c88:	30 08       	mov	r8,0
80003c8a:	ef 68 00 50 	st.b	r7[80],r8
        }
        taskEXIT_CRITICAL();
80003c8e:	f0 1f 00 06 	mcall	80003ca4 <ulTaskGenericNotifyTake+0x94>

        return ulReturn;
    }
80003c92:	0c 9c       	mov	r12,r6
80003c94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	2f fc       	sub	r12,-1
80003c9c:	00 00       	add	r0,r0
80003c9e:	06 3c       	cp.w	r12,r3
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	3b 78       	mov	r8,-73
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	31 08       	mov	r8,16

80003ca8 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
80003ca8:	eb cd 40 80 	pushm	r7,lr
80003cac:	16 97       	mov	r7,r11

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80003cae:	48 68       	lddpc	r8,80003cc4 <vTaskPlaceOnEventList+0x1c>
80003cb0:	70 0b       	ld.w	r11,r8[0x0]
80003cb2:	2e 8b       	sub	r11,-24
80003cb4:	f0 1f 00 05 	mcall	80003cc8 <vTaskPlaceOnEventList+0x20>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80003cb8:	30 1b       	mov	r11,1
80003cba:	0e 9c       	mov	r12,r7
80003cbc:	f0 1f 00 04 	mcall	80003ccc <vTaskPlaceOnEventList+0x24>
}
80003cc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cc4:	00 00       	add	r0,r0
80003cc6:	06 3c       	cp.w	r12,r3
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	2f 12       	sub	r2,-15
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	3b 78       	mov	r8,-73

80003cd0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
80003cd0:	eb cd 40 80 	pushm	r7,lr
80003cd4:	18 97       	mov	r7,r12

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
80003cd6:	78 cc       	ld.w	r12,r12[0x30]
80003cd8:	f0 1f 00 04 	mcall	80003ce8 <prvDeleteTCB+0x18>
                vPortFree( pxTCB );
80003cdc:	0e 9c       	mov	r12,r7
80003cde:	f0 1f 00 03 	mcall	80003ce8 <prvDeleteTCB+0x18>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
80003ce2:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ce6:	00 00       	add	r0,r0
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	31 c4       	mov	r4,28

80003cec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80003cec:	eb cd 40 f8 	pushm	r3-r7,lr
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80003cf0:	49 17       	lddpc	r7,80003d34 <prvIdleTask+0x48>
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003cf2:	49 25       	lddpc	r5,80003d38 <prvIdleTask+0x4c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
80003cf4:	49 24       	lddpc	r4,80003d3c <prvIdleTask+0x50>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80003cf6:	49 33       	lddpc	r3,80003d40 <prvIdleTask+0x54>
80003cf8:	c1 48       	rjmp	80003d20 <prvIdleTask+0x34>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
80003cfa:	f0 1f 00 13 	mcall	80003d44 <prvIdleTask+0x58>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003cfe:	6a 38       	ld.w	r8,r5[0xc]
80003d00:	70 36       	ld.w	r6,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003d02:	ec cc ff fc 	sub	r12,r6,-4
80003d06:	f0 1f 00 11 	mcall	80003d48 <prvIdleTask+0x5c>
                    --uxCurrentNumberOfTasks;
80003d0a:	68 08       	ld.w	r8,r4[0x0]
80003d0c:	20 18       	sub	r8,1
80003d0e:	89 08       	st.w	r4[0x0],r8
                    --uxDeletedTasksWaitingCleanUp;
80003d10:	6e 08       	ld.w	r8,r7[0x0]
80003d12:	20 18       	sub	r8,1
80003d14:	8f 08       	st.w	r7[0x0],r8
                }
                taskEXIT_CRITICAL();
80003d16:	f0 1f 00 0e 	mcall	80003d4c <prvIdleTask+0x60>

                prvDeleteTCB( pxTCB );
80003d1a:	0c 9c       	mov	r12,r6
80003d1c:	f0 1f 00 0d 	mcall	80003d50 <prvIdleTask+0x64>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80003d20:	6e 08       	ld.w	r8,r7[0x0]
80003d22:	58 08       	cp.w	r8,0
80003d24:	ce b1       	brne	80003cfa <prvIdleTask+0xe>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80003d26:	66 08       	ld.w	r8,r3[0x0]
80003d28:	58 18       	cp.w	r8,1
80003d2a:	fe 98 ff fb 	brls	80003d20 <prvIdleTask+0x34>
                {
                    taskYIELD();
80003d2e:	d7 33       	scall
80003d30:	cf 8b       	rjmp	80003d20 <prvIdleTask+0x34>
80003d32:	00 00       	add	r0,r0
80003d34:	00 00       	add	r0,r0
80003d36:	06 38       	cp.w	r8,r3
80003d38:	00 00       	add	r0,r0
80003d3a:	06 8c       	andn	r12,r3
80003d3c:	00 00       	add	r0,r0
80003d3e:	06 88       	andn	r8,r3
80003d40:	00 00       	add	r0,r0
80003d42:	05 98       	ld.ub	r8,r2[0x1]
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	2f fc       	sub	r12,-1
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	2f 42       	sub	r2,-12
80003d4c:	80 00       	ld.sh	r0,r0[0x0]
80003d4e:	31 08       	mov	r8,16
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	3c d0       	mov	r0,-51

80003d54 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
80003d54:	d4 31       	pushm	r0-r7,lr
80003d56:	20 1d       	sub	sp,4
80003d58:	50 0c       	stdsp	sp[0x0],r12
80003d5a:	16 97       	mov	r7,r11
80003d5c:	12 90       	mov	r0,r9
80003d5e:	10 94       	mov	r4,r8
80003d60:	40 a2       	lddsp	r2,sp[0x28]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
80003d62:	e7 da c0 10 	bfextu	r3,r10,0x0,0x10
80003d66:	e6 0c 15 02 	lsl	r12,r3,0x2
80003d6a:	f0 1f 00 61 	mcall	80003eec <xTaskCreate+0x198>
80003d6e:	18 96       	mov	r6,r12

                if( pxStack != NULL )
80003d70:	c0 31       	brne	80003d76 <xTaskCreate+0x22>
80003d72:	3f fc       	mov	r12,-1
80003d74:	cb a8       	rjmp	80003ee8 <xTaskCreate+0x194>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
80003d76:	35 4c       	mov	r12,84
80003d78:	f0 1f 00 5d 	mcall	80003eec <xTaskCreate+0x198>
80003d7c:	18 95       	mov	r5,r12

                    if( pxNewTCB != NULL )
80003d7e:	c0 50       	breq	80003d88 <xTaskCreate+0x34>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
80003d80:	99 c6       	st.w	r12[0x30],r6
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
80003d82:	58 07       	cp.w	r7,0
80003d84:	c0 71       	brne	80003d92 <xTaskCreate+0x3e>
80003d86:	c2 28       	rjmp	80003dca <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
80003d88:	0c 9c       	mov	r12,r6
80003d8a:	f0 1f 00 5a 	mcall	80003ef0 <xTaskCreate+0x19c>
80003d8e:	3f fc       	mov	r12,-1
80003d90:	ca c8       	rjmp	80003ee8 <xTaskCreate+0x194>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80003d92:	0f 88       	ld.ub	r8,r7[0x0]
80003d94:	f9 68 00 34 	st.b	r12[52],r8

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80003d98:	0f 89       	ld.ub	r9,r7[0x0]
80003d9a:	30 08       	mov	r8,0
80003d9c:	f0 09 18 00 	cp.b	r9,r8
80003da0:	c1 10       	breq	80003dc2 <xTaskCreate+0x6e>
80003da2:	2f f7       	sub	r7,-1
80003da4:	f8 c8 ff cb 	sub	r8,r12,-53
80003da8:	30 19       	mov	r9,1
80003daa:	30 0b       	mov	r11,0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80003dac:	0f 8a       	ld.ub	r10,r7[0x0]
80003dae:	b0 8a       	st.b	r8[0x0],r10

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80003db0:	0f 8a       	ld.ub	r10,r7[0x0]
80003db2:	f6 0a 18 00 	cp.b	r10,r11
80003db6:	c0 60       	breq	80003dc2 <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80003db8:	2f f9       	sub	r9,-1
80003dba:	2f f7       	sub	r7,-1
80003dbc:	2f f8       	sub	r8,-1
80003dbe:	59 09       	cp.w	r9,16
80003dc0:	cf 61       	brne	80003dac <xTaskCreate+0x58>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80003dc2:	30 08       	mov	r8,0
80003dc4:	eb 68 00 43 	st.b	r5[67],r8
80003dc8:	c0 48       	rjmp	80003dd0 <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
80003dca:	30 08       	mov	r8,0
80003dcc:	f9 68 00 34 	st.b	r12[52],r8
80003dd0:	58 74       	cp.w	r4,7
80003dd2:	f9 b4 0b 07 	movhi	r4,7
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
80003dd6:	8b b4       	st.w	r5[0x2c],r4
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
80003dd8:	eb 44 00 44 	st.w	r5[68],r4
            pxNewTCB->uxMutexesHeld = 0;
80003ddc:	30 07       	mov	r7,0
80003dde:	eb 47 00 48 	st.w	r5[72],r7
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80003de2:	ea c1 ff fc 	sub	r1,r5,-4
80003de6:	02 9c       	mov	r12,r1
80003de8:	f0 1f 00 43 	mcall	80003ef4 <xTaskCreate+0x1a0>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80003dec:	ea cc ff e8 	sub	r12,r5,-24
80003df0:	f0 1f 00 41 	mcall	80003ef4 <xTaskCreate+0x1a0>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80003df4:	8b 45       	st.w	r5[0x10],r5

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80003df6:	e8 04 11 08 	rsub	r4,r4,8
80003dfa:	8b 64       	st.w	r5[0x18],r4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80003dfc:	8b 95       	st.w	r5[0x24],r5
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
80003dfe:	ea c8 ff b4 	sub	r8,r5,-76
80003e02:	91 07       	st.w	r8[0x0],r7
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
80003e04:	ea c8 ff b0 	sub	r8,r5,-80
80003e08:	b0 87       	st.b	r8[0x0],r7
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
80003e0a:	20 13       	sub	r3,1
80003e0c:	ec 03 00 26 	add	r6,r6,r3<<0x2
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003e10:	00 9a       	mov	r10,r0
80003e12:	40 0b       	lddsp	r11,sp[0x0]
80003e14:	0c 9c       	mov	r12,r6
80003e16:	e0 1c ff fc 	andl	r12,0xfffc
80003e1a:	f0 1f 00 38 	mcall	80003ef8 <xTaskCreate+0x1a4>
80003e1e:	8b 0c       	st.w	r5[0x0],r12

    if( pxCreatedTask != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80003e20:	58 02       	cp.w	r2,0
80003e22:	e5 f5 1a 00 	st.wne	r2[0x0],r5

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
80003e26:	f0 1f 00 36 	mcall	80003efc <xTaskCreate+0x1a8>
    {
        uxCurrentNumberOfTasks++;
80003e2a:	4b 68       	lddpc	r8,80003f00 <xTaskCreate+0x1ac>
80003e2c:	70 09       	ld.w	r9,r8[0x0]
80003e2e:	2f f9       	sub	r9,-1
80003e30:	91 09       	st.w	r8[0x0],r9

        if( pxCurrentTCB == NULL )
80003e32:	4b 58       	lddpc	r8,80003f04 <xTaskCreate+0x1b0>
80003e34:	70 08       	ld.w	r8,r8[0x0]
80003e36:	58 08       	cp.w	r8,0
80003e38:	c2 61       	brne	80003e84 <xTaskCreate+0x130>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
80003e3a:	4b 38       	lddpc	r8,80003f04 <xTaskCreate+0x1b0>
80003e3c:	91 05       	st.w	r8[0x0],r5

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80003e3e:	4b 18       	lddpc	r8,80003f00 <xTaskCreate+0x1ac>
80003e40:	70 08       	ld.w	r8,r8[0x0]
80003e42:	58 18       	cp.w	r8,1
80003e44:	c2 d1       	brne	80003e9e <xTaskCreate+0x14a>
80003e46:	4b 17       	lddpc	r7,80003f08 <xTaskCreate+0x1b4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
80003e48:	ee c6 ff 60 	sub	r6,r7,-160
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
80003e4c:	0e 9c       	mov	r12,r7
80003e4e:	f0 1f 00 30 	mcall	80003f0c <xTaskCreate+0x1b8>
80003e52:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80003e54:	0c 37       	cp.w	r7,r6
80003e56:	cf b1       	brne	80003e4c <xTaskCreate+0xf8>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
80003e58:	4a e7       	lddpc	r7,80003f10 <xTaskCreate+0x1bc>
80003e5a:	0e 9c       	mov	r12,r7
80003e5c:	f0 1f 00 2c 	mcall	80003f0c <xTaskCreate+0x1b8>
    vListInitialise( &xDelayedTaskList2 );
80003e60:	4a d6       	lddpc	r6,80003f14 <xTaskCreate+0x1c0>
80003e62:	0c 9c       	mov	r12,r6
80003e64:	f0 1f 00 2a 	mcall	80003f0c <xTaskCreate+0x1b8>
    vListInitialise( &xPendingReadyList );
80003e68:	4a cc       	lddpc	r12,80003f18 <xTaskCreate+0x1c4>
80003e6a:	f0 1f 00 29 	mcall	80003f0c <xTaskCreate+0x1b8>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
80003e6e:	4a cc       	lddpc	r12,80003f1c <xTaskCreate+0x1c8>
80003e70:	f0 1f 00 27 	mcall	80003f0c <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
80003e74:	4a bc       	lddpc	r12,80003f20 <xTaskCreate+0x1cc>
80003e76:	f0 1f 00 26 	mcall	80003f0c <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
80003e7a:	4a b8       	lddpc	r8,80003f24 <xTaskCreate+0x1d0>
80003e7c:	91 07       	st.w	r8[0x0],r7
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
80003e7e:	4a b8       	lddpc	r8,80003f28 <xTaskCreate+0x1d4>
80003e80:	91 06       	st.w	r8[0x0],r6
80003e82:	c0 e8       	rjmp	80003e9e <xTaskCreate+0x14a>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
80003e84:	4a a8       	lddpc	r8,80003f2c <xTaskCreate+0x1d8>
80003e86:	70 08       	ld.w	r8,r8[0x0]
80003e88:	58 08       	cp.w	r8,0
80003e8a:	c0 a1       	brne	80003e9e <xTaskCreate+0x14a>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80003e8c:	49 e8       	lddpc	r8,80003f04 <xTaskCreate+0x1b0>
80003e8e:	70 08       	ld.w	r8,r8[0x0]
80003e90:	70 b9       	ld.w	r9,r8[0x2c]
80003e92:	6a b8       	ld.w	r8,r5[0x2c]
80003e94:	10 39       	cp.w	r9,r8
80003e96:	e0 8b 00 04 	brhi	80003e9e <xTaskCreate+0x14a>
                {
                    pxCurrentTCB = pxNewTCB;
80003e9a:	49 b8       	lddpc	r8,80003f04 <xTaskCreate+0x1b0>
80003e9c:	91 05       	st.w	r8[0x0],r5
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
80003e9e:	4a 58       	lddpc	r8,80003f30 <xTaskCreate+0x1dc>
80003ea0:	70 09       	ld.w	r9,r8[0x0]
80003ea2:	2f f9       	sub	r9,-1
80003ea4:	91 09       	st.w	r8[0x0],r9
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
80003ea6:	6a b8       	ld.w	r8,r5[0x2c]
80003ea8:	4a 39       	lddpc	r9,80003f34 <xTaskCreate+0x1e0>
80003eaa:	72 09       	ld.w	r9,r9[0x0]
80003eac:	12 38       	cp.w	r8,r9
80003eae:	e0 88 00 04 	brls	80003eb6 <xTaskCreate+0x162>
80003eb2:	4a 19       	lddpc	r9,80003f34 <xTaskCreate+0x1e0>
80003eb4:	93 08       	st.w	r9[0x0],r8
80003eb6:	6a bc       	ld.w	r12,r5[0x2c]
80003eb8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003ebc:	02 9b       	mov	r11,r1
80003ebe:	49 38       	lddpc	r8,80003f08 <xTaskCreate+0x1b4>
80003ec0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003ec4:	f0 1f 00 1d 	mcall	80003f38 <xTaskCreate+0x1e4>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
80003ec8:	f0 1f 00 1d 	mcall	80003f3c <xTaskCreate+0x1e8>

    if( xSchedulerRunning != pdFALSE )
80003ecc:	49 88       	lddpc	r8,80003f2c <xTaskCreate+0x1d8>
80003ece:	70 08       	ld.w	r8,r8[0x0]
80003ed0:	58 08       	cp.w	r8,0
80003ed2:	c0 a0       	breq	80003ee6 <xTaskCreate+0x192>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80003ed4:	48 c8       	lddpc	r8,80003f04 <xTaskCreate+0x1b0>
80003ed6:	70 08       	ld.w	r8,r8[0x0]
80003ed8:	70 b9       	ld.w	r9,r8[0x2c]
80003eda:	6a b8       	ld.w	r8,r5[0x2c]
80003edc:	10 39       	cp.w	r9,r8
80003ede:	c0 42       	brcc	80003ee6 <xTaskCreate+0x192>
        {
            taskYIELD_IF_USING_PREEMPTION();
80003ee0:	d7 33       	scall
80003ee2:	30 1c       	mov	r12,1
80003ee4:	c0 28       	rjmp	80003ee8 <xTaskCreate+0x194>
80003ee6:	30 1c       	mov	r12,1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
80003ee8:	2f fd       	sub	sp,-4
80003eea:	d8 32       	popm	r0-r7,pc
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	31 ec       	mov	r12,30
80003ef0:	80 00       	ld.sh	r0,r0[0x0]
80003ef2:	31 c4       	mov	r4,28
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	2e f4       	sub	r4,-17
80003ef8:	80 00       	ld.sh	r0,r0[0x0]
80003efa:	2f 6a       	sub	r10,-10
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	2f fc       	sub	r12,-1
80003f00:	00 00       	add	r0,r0
80003f02:	06 88       	andn	r8,r3
80003f04:	00 00       	add	r0,r0
80003f06:	06 3c       	cp.w	r12,r3
80003f08:	00 00       	add	r0,r0
80003f0a:	05 98       	ld.ub	r8,r2[0x1]
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	2e e0       	sub	r0,-18
80003f10:	00 00       	add	r0,r0
80003f12:	06 54       	eor	r4,r3
80003f14:	00 00       	add	r0,r0
80003f16:	06 70       	tst	r0,r3
80003f18:	00 00       	add	r0,r0
80003f1a:	06 40       	or	r0,r3
80003f1c:	00 00       	add	r0,r0
80003f1e:	06 8c       	andn	r12,r3
80003f20:	00 00       	add	r0,r0
80003f22:	06 a4       	st.w	r3++,r4
80003f24:	00 00       	add	r0,r0
80003f26:	05 84       	ld.ub	r4,r2[0x0]
80003f28:	00 00       	add	r0,r0
80003f2a:	05 90       	ld.ub	r0,r2[0x1]
80003f2c:	00 00       	add	r0,r0
80003f2e:	05 88       	ld.ub	r8,r2[0x0]
80003f30:	00 00       	add	r0,r0
80003f32:	06 84       	andn	r4,r3
80003f34:	00 00       	add	r0,r0
80003f36:	06 b8       	st.h	r3++,r8
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	2e fa       	sub	r10,-17
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	31 08       	mov	r8,16

80003f40 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
80003f40:	d4 01       	pushm	lr
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
80003f42:	48 e8       	lddpc	r8,80003f78 <vTaskStartScheduler+0x38>
80003f44:	1a d8       	st.w	--sp,r8
80003f46:	30 08       	mov	r8,0
80003f48:	10 99       	mov	r9,r8
80003f4a:	e0 6a 01 00 	mov	r10,256
80003f4e:	48 cb       	lddpc	r11,80003f7c <vTaskStartScheduler+0x3c>
80003f50:	48 cc       	lddpc	r12,80003f80 <vTaskStartScheduler+0x40>
80003f52:	f0 1f 00 0d 	mcall	80003f84 <vTaskStartScheduler+0x44>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
80003f56:	2f fd       	sub	sp,-4
80003f58:	58 1c       	cp.w	r12,1
80003f5a:	c0 d1       	brne	80003f74 <vTaskStartScheduler+0x34>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
80003f5c:	d3 03       	ssrf	0x10
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
80003f5e:	3f f9       	mov	r9,-1
80003f60:	48 a8       	lddpc	r8,80003f88 <vTaskStartScheduler+0x48>
80003f62:	91 09       	st.w	r8[0x0],r9
        xSchedulerRunning = pdTRUE;
80003f64:	30 19       	mov	r9,1
80003f66:	48 a8       	lddpc	r8,80003f8c <vTaskStartScheduler+0x4c>
80003f68:	91 09       	st.w	r8[0x0],r9
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
80003f6a:	30 09       	mov	r9,0
80003f6c:	48 98       	lddpc	r8,80003f90 <vTaskStartScheduler+0x50>
80003f6e:	91 09       	st.w	r8[0x0],r9

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
80003f70:	f0 1f 00 09 	mcall	80003f94 <vTaskStartScheduler+0x54>
80003f74:	d8 02       	popm	pc
80003f76:	00 00       	add	r0,r0
80003f78:	00 00       	add	r0,r0
80003f7a:	06 a0       	st.w	r3++,r0
80003f7c:	80 00       	ld.sh	r0,r0[0x0]
80003f7e:	64 48       	ld.w	r8,r2[0x10]
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3c ec       	mov	r12,-50
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	3d 54       	mov	r4,-43
80003f88:	00 00       	add	r0,r0
80003f8a:	05 80       	ld.ub	r0,r2[0x0]
80003f8c:	00 00       	add	r0,r0
80003f8e:	05 88       	ld.ub	r8,r2[0x0]
80003f90:	00 00       	add	r0,r0
80003f92:	06 68       	and	r8,r3
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	30 0c       	mov	r12,0

80003f98 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003f98:	f8 08 16 05 	lsr	r8,r12,0x5
80003f9c:	a9 68       	lsl	r8,0x8
80003f9e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80003fa2:	58 1b       	cp.w	r11,1
80003fa4:	c0 d0       	breq	80003fbe <gpio_enable_module_pin+0x26>
80003fa6:	c0 63       	brcs	80003fb2 <gpio_enable_module_pin+0x1a>
80003fa8:	58 2b       	cp.w	r11,2
80003faa:	c1 00       	breq	80003fca <gpio_enable_module_pin+0x32>
80003fac:	58 3b       	cp.w	r11,3
80003fae:	c1 40       	breq	80003fd6 <gpio_enable_module_pin+0x3e>
80003fb0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003fb2:	30 19       	mov	r9,1
80003fb4:	f2 0c 09 49 	lsl	r9,r9,r12
80003fb8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003fba:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003fbc:	c1 28       	rjmp	80003fe0 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003fbe:	30 19       	mov	r9,1
80003fc0:	f2 0c 09 49 	lsl	r9,r9,r12
80003fc4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003fc6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003fc8:	c0 c8       	rjmp	80003fe0 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003fca:	30 19       	mov	r9,1
80003fcc:	f2 0c 09 49 	lsl	r9,r9,r12
80003fd0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003fd2:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003fd4:	c0 68       	rjmp	80003fe0 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003fd6:	30 19       	mov	r9,1
80003fd8:	f2 0c 09 49 	lsl	r9,r9,r12
80003fdc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003fde:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80003fe0:	30 19       	mov	r9,1
80003fe2:	f2 0c 09 4c 	lsl	r12,r9,r12
80003fe6:	91 2c       	st.w	r8[0x8],r12
80003fe8:	5e fd       	retal	0
80003fea:	d7 03       	nop

80003fec <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80003fec:	d4 21       	pushm	r4-r7,lr
80003fee:	18 97       	mov	r7,r12
80003ff0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80003ff2:	58 0b       	cp.w	r11,0
80003ff4:	c0 31       	brne	80003ffa <gpio_enable_module+0xe>
80003ff6:	30 05       	mov	r5,0
80003ff8:	c0 d8       	rjmp	80004012 <gpio_enable_module+0x26>
80003ffa:	30 06       	mov	r6,0
80003ffc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80003ffe:	6e 1b       	ld.w	r11,r7[0x4]
80004000:	6e 0c       	ld.w	r12,r7[0x0]
80004002:	f0 1f 00 06 	mcall	80004018 <gpio_enable_module+0x2c>
80004006:	18 45       	or	r5,r12
		gpiomap++;
80004008:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000400a:	2f f6       	sub	r6,-1
8000400c:	0c 34       	cp.w	r4,r6
8000400e:	fe 9b ff f8 	brhi	80003ffe <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004012:	0a 9c       	mov	r12,r5
80004014:	d8 22       	popm	r4-r7,pc
80004016:	00 00       	add	r0,r0
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	3f 98       	mov	r8,-7

8000401c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000401c:	f8 08 16 05 	lsr	r8,r12,0x5
80004020:	a9 68       	lsl	r8,0x8
80004022:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004026:	30 19       	mov	r9,1
80004028:	f2 0c 09 4c 	lsl	r12,r9,r12
8000402c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004030:	91 1c       	st.w	r8[0x4],r12
}
80004032:	5e fc       	retal	r12

80004034 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
80004034:	eb cd 40 e0 	pushm	r5-r7,lr
80004038:	18 97       	mov	r7,r12
8000403a:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
8000403c:	58 0b       	cp.w	r11,0
8000403e:	c0 a0       	breq	80004052 <gpio_enable_gpio+0x1e>
80004040:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
80004042:	6e 0c       	ld.w	r12,r7[0x0]
80004044:	f0 1f 00 05 	mcall	80004058 <gpio_enable_gpio+0x24>
		gpiomap++;
80004048:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
8000404a:	2f f5       	sub	r5,-1
8000404c:	0a 36       	cp.w	r6,r5
8000404e:	fe 9b ff fa 	brhi	80004042 <gpio_enable_gpio+0xe>
80004052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004056:	00 00       	add	r0,r0
80004058:	80 00       	ld.sh	r0,r0[0x0]
8000405a:	40 1c       	lddsp	r12,sp[0x4]

8000405c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000405c:	f8 08 16 05 	lsr	r8,r12,0x5
80004060:	a9 68       	lsl	r8,0x8
80004062:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004066:	30 19       	mov	r9,1
80004068:	f2 0c 09 4c 	lsl	r12,r9,r12
8000406c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004070:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004074:	91 1c       	st.w	r8[0x4],r12
}
80004076:	5e fc       	retal	r12

80004078 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004078:	f8 08 16 05 	lsr	r8,r12,0x5
8000407c:	a9 68       	lsl	r8,0x8
8000407e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004082:	30 19       	mov	r9,1
80004084:	f2 0c 09 4c 	lsl	r12,r9,r12
80004088:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000408c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004090:	91 1c       	st.w	r8[0x4],r12
}
80004092:	5e fc       	retal	r12

80004094 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004094:	f8 08 16 05 	lsr	r8,r12,0x5
80004098:	a9 68       	lsl	r8,0x8
8000409a:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
8000409e:	30 19       	mov	r9,1
800040a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800040a4:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
800040a8:	12 3b       	cp.w	r11,r9
800040aa:	c0 a0       	breq	800040be <gpio_enable_pin_interrupt+0x2a>
800040ac:	c0 43       	brcs	800040b4 <gpio_enable_pin_interrupt+0x20>
800040ae:	58 2b       	cp.w	r11,2
800040b0:	c1 11       	brne	800040d2 <gpio_enable_pin_interrupt+0x3e>
800040b2:	c0 b8       	rjmp	800040c8 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800040b4:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800040b8:	f1 4c 00 b8 	st.w	r8[184],r12
800040bc:	c0 c8       	rjmp	800040d4 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
800040be:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800040c2:	f1 4c 00 b8 	st.w	r8[184],r12
800040c6:	c0 78       	rjmp	800040d4 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800040c8:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
800040cc:	f1 4c 00 b4 	st.w	r8[180],r12
800040d0:	c0 28       	rjmp	800040d4 <gpio_enable_pin_interrupt+0x40>
800040d2:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
800040d4:	f1 4c 00 94 	st.w	r8[148],r12
800040d8:	5e fd       	retal	0

800040da <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800040da:	f8 08 16 05 	lsr	r8,r12,0x5
800040de:	a9 68       	lsl	r8,0x8
800040e0:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
800040e4:	f0 f8 00 d0 	ld.w	r8,r8[208]
800040e8:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800040ec:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800040f0:	5e fc       	retal	r12

800040f2 <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800040f2:	f8 08 16 05 	lsr	r8,r12,0x5
800040f6:	a9 68       	lsl	r8,0x8
800040f8:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800040fc:	30 19       	mov	r9,1
800040fe:	f2 0c 09 4c 	lsl	r12,r9,r12
80004102:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
80004106:	5e fc       	retal	r12

80004108 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004108:	c0 08       	rjmp	80004108 <_unhandled_interrupt>
8000410a:	d7 03       	nop

8000410c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000410c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004110:	49 99       	lddpc	r9,80004174 <INTC_register_interrupt+0x68>
80004112:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004116:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000411a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000411c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004120:	58 0a       	cp.w	r10,0
80004122:	c0 91       	brne	80004134 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004124:	49 59       	lddpc	r9,80004178 <INTC_register_interrupt+0x6c>
80004126:	49 6a       	lddpc	r10,8000417c <INTC_register_interrupt+0x70>
80004128:	12 1a       	sub	r10,r9
8000412a:	fe 79 08 00 	mov	r9,-63488
8000412e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004132:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004134:	58 1a       	cp.w	r10,1
80004136:	c0 a1       	brne	8000414a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004138:	49 09       	lddpc	r9,80004178 <INTC_register_interrupt+0x6c>
8000413a:	49 2a       	lddpc	r10,80004180 <INTC_register_interrupt+0x74>
8000413c:	12 1a       	sub	r10,r9
8000413e:	bf aa       	sbr	r10,0x1e
80004140:	fe 79 08 00 	mov	r9,-63488
80004144:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004148:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000414a:	58 2a       	cp.w	r10,2
8000414c:	c0 a1       	brne	80004160 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000414e:	48 b9       	lddpc	r9,80004178 <INTC_register_interrupt+0x6c>
80004150:	48 da       	lddpc	r10,80004184 <INTC_register_interrupt+0x78>
80004152:	12 1a       	sub	r10,r9
80004154:	bf ba       	sbr	r10,0x1f
80004156:	fe 79 08 00 	mov	r9,-63488
8000415a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000415e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004160:	48 69       	lddpc	r9,80004178 <INTC_register_interrupt+0x6c>
80004162:	48 aa       	lddpc	r10,80004188 <INTC_register_interrupt+0x7c>
80004164:	12 1a       	sub	r10,r9
80004166:	ea 1a c0 00 	orh	r10,0xc000
8000416a:	fe 79 08 00 	mov	r9,-63488
8000416e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004172:	5e fc       	retal	r12
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	64 50       	ld.w	r0,r2[0x14]
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	62 00       	ld.w	r0,r1[0x0]
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	63 04       	ld.w	r4,r1[0x40]
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	63 12       	ld.w	r2,r1[0x44]
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	63 20       	ld.w	r0,r1[0x48]
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	63 2e       	ld.w	lr,r1[0x48]

8000418c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000418c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000418e:	49 18       	lddpc	r8,800041d0 <INTC_init_interrupts+0x44>
80004190:	e3 b8 00 01 	mtsr	0x4,r8
80004194:	49 0e       	lddpc	lr,800041d4 <INTC_init_interrupts+0x48>
80004196:	30 07       	mov	r7,0
80004198:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000419a:	49 0c       	lddpc	r12,800041d8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000419c:	49 05       	lddpc	r5,800041dc <INTC_init_interrupts+0x50>
8000419e:	10 15       	sub	r5,r8
800041a0:	fe 76 08 00 	mov	r6,-63488
800041a4:	c1 08       	rjmp	800041c4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800041a6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800041a8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800041aa:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800041ac:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800041b0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800041b2:	10 3a       	cp.w	r10,r8
800041b4:	fe 9b ff fc 	brhi	800041ac <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800041b8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800041bc:	2f f7       	sub	r7,-1
800041be:	2f 8e       	sub	lr,-8
800041c0:	59 47       	cp.w	r7,20
800041c2:	c0 50       	breq	800041cc <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800041c4:	7c 08       	ld.w	r8,lr[0x0]
800041c6:	58 08       	cp.w	r8,0
800041c8:	ce f1       	brne	800041a6 <INTC_init_interrupts+0x1a>
800041ca:	cf 7b       	rjmp	800041b8 <INTC_init_interrupts+0x2c>
800041cc:	d8 22       	popm	r4-r7,pc
800041ce:	00 00       	add	r0,r0
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	62 00       	ld.w	r0,r1[0x0]
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	64 50       	ld.w	r0,r2[0x14]
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	41 08       	lddsp	r8,sp[0x40]
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	63 04       	ld.w	r4,r1[0x40]

800041e0 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800041e0:	fe 78 08 00 	mov	r8,-63488
800041e4:	e0 69 00 83 	mov	r9,131
800041e8:	f2 0c 01 0c 	sub	r12,r9,r12
800041ec:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800041f0:	f2 ca ff c0 	sub	r10,r9,-64
800041f4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800041f8:	58 08       	cp.w	r8,0
800041fa:	c0 21       	brne	800041fe <_get_interrupt_handler+0x1e>
800041fc:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
800041fe:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004202:	48 5a       	lddpc	r10,80004214 <_get_interrupt_handler+0x34>
80004204:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004208:	f0 08 11 1f 	rsub	r8,r8,31
8000420c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000420e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004212:	5e fc       	retal	r12
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	64 50       	ld.w	r0,r2[0x14]

80004218 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004218:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000421c:	fe c0 e0 1c 	sub	r0,pc,-8164

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004220:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004224:	d5 53       	csrf	0x15
  cp      r0, r1
80004226:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80004228:	e0 61 05 58 	mov	r1,1368
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000422c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000422e:	c0 62       	brcc	8000423a <idata_load_loop_end>
  cp      r0, r1
80004230:	48 92       	lddpc	r2,80004254 <udata_clear_loop_end+0x4>

80004232 <idata_load_loop>:
  brlo    idata_load_loop
80004232:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004234:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004236:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004238:	cf d3       	brcs	80004232 <idata_load_loop>

8000423a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000423a:	e0 60 05 58 	mov	r0,1368
  mov     r2, 0
  mov     r3, 0
8000423e:	e0 61 0a 58 	mov	r1,2648
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004242:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004244:	c0 62       	brcc	80004250 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004246:	30 02       	mov	r2,0
80004248:	30 03       	mov	r3,0

8000424a <udata_clear_loop>:
8000424a:	a1 22       	st.d	r0++,r2
8000424c:	02 30       	cp.w	r0,r1
8000424e:	cf e3       	brcs	8000424a <udata_clear_loop>

80004250 <udata_clear_loop_end>:
80004250:	fe cf ff f4 	sub	pc,pc,-12
80004254:	80 03       	ld.sh	r3,r0[0x0]
80004256:	6e 40       	ld.w	r0,r7[0x10]

80004258 <master_callback>:

	else if( arg == AUDIO_ADC_RELOAD_CB )
	{
		adc_reload_callback();;
	}
}
80004258:	5e fc       	retal	r12
8000425a:	d7 03       	nop

8000425c <main>:
		
	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
}

int main (void)
{
8000425c:	eb cd 40 e0 	pushm	r5-r7,lr
80004260:	20 7d       	sub	sp,28
/*! \brief Static function definitions
 */
static void init_sys_clocks(void)
{
  // Switch to OSC0 to speed up the booting
  pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80004262:	30 3a       	mov	r10,3
80004264:	e0 6b 1b 00 	mov	r11,6912
80004268:	ea 1b 00 b7 	orh	r11,0xb7
8000426c:	fe 7c 0c 00 	mov	r12,-62464
80004270:	f0 1f 00 69 	mcall	80004414 <main+0x1b8>

  // Start oscillator1
  pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
80004274:	e0 6b 44 00 	mov	r11,17408
80004278:	ea 1b 00 ac 	orh	r11,0xac
8000427c:	fe 7c 0c 00 	mov	r12,-62464
80004280:	f0 1f 00 66 	mcall	80004418 <main+0x1bc>
  pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
80004284:	30 3b       	mov	r11,3
80004286:	fe 7c 0c 00 	mov	r12,-62464
8000428a:	f0 1f 00 65 	mcall	8000441c <main+0x1c0>

  // Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
  // We use OSC1 since we need a correct master clock for the SSC module to generate
  // 
  pm_pll_setup(&AVR32_PM, 0,  // pll.
8000428e:	31 05       	mov	r5,16
80004290:	1a d5       	st.w	--sp,r5
80004292:	30 18       	mov	r8,1
80004294:	10 99       	mov	r9,r8
80004296:	30 aa       	mov	r10,10
80004298:	30 0b       	mov	r11,0
8000429a:	fe 7c 0c 00 	mov	r12,-62464
8000429e:	f0 1f 00 61 	mcall	80004420 <main+0x1c4>
    1,   // osc.
    16); // lockcount.

  // Set PLL operating range and divider (fpll = fvco/2)
  // -> PLL0 output = 62.0928 MHz
  pm_pll_set_option(&AVR32_PM, 0, // pll.
800042a2:	30 08       	mov	r8,0
800042a4:	30 19       	mov	r9,1
800042a6:	12 9a       	mov	r10,r9
800042a8:	10 9b       	mov	r11,r8
800042aa:	fe 7c 0c 00 	mov	r12,-62464
800042ae:	f0 1f 00 5e 	mcall	80004424 <main+0x1c8>
    1,  // pll_freq.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL0 and wait for the lock
  pm_pll_enable(&AVR32_PM, 0);
800042b2:	30 0b       	mov	r11,0
800042b4:	fe 7c 0c 00 	mov	r12,-62464
800042b8:	f0 1f 00 5c 	mcall	80004428 <main+0x1cc>
  pm_wait_for_pll0_locked(&AVR32_PM);
800042bc:	fe 7c 0c 00 	mov	r12,-62464
800042c0:	f0 1f 00 5b 	mcall	8000442c <main+0x1d0>
  // Set all peripheral clocks torun at master clock rate
  pm_cksel(&AVR32_PM,
800042c4:	30 07       	mov	r7,0
800042c6:	1a d7       	st.w	--sp,r7
800042c8:	1a d7       	st.w	--sp,r7
800042ca:	0e 98       	mov	r8,r7
800042cc:	0e 99       	mov	r9,r7
800042ce:	0e 9a       	mov	r10,r7
800042d0:	0e 9b       	mov	r11,r7
800042d2:	fe 7c 0c 00 	mov	r12,-62464
800042d6:	f0 1f 00 57 	mcall	80004430 <main+0x1d4>
    0,   // pbbsel.
    0,   // hsbdiv.
    0);  // hsbsel.

  // Set one waitstate for the flash
  flashc_set_wait_state(1);
800042da:	30 1c       	mov	r12,1
800042dc:	f0 1f 00 56 	mcall	80004434 <main+0x1d8>

  // Switch to PLL0 as the master clock
  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
800042e0:	30 2b       	mov	r11,2
800042e2:	fe 7c 0c 00 	mov	r12,-62464
800042e6:	f0 1f 00 55 	mcall	80004438 <main+0x1dc>

  // Use 12MHz from OSC0 and generate 96 MHz
  pm_pll_setup(&AVR32_PM, 1,  // pll.
800042ea:	1a d5       	st.w	--sp,r5
800042ec:	0e 98       	mov	r8,r7
800042ee:	30 19       	mov	r9,1
800042f0:	30 7a       	mov	r10,7
800042f2:	12 9b       	mov	r11,r9
800042f4:	fe 7c 0c 00 	mov	r12,-62464
800042f8:	f0 1f 00 4a 	mcall	80004420 <main+0x1c4>
    7,   // mul.
    1,   // div.
    0,   // osc.
    16); // lockcount.

  pm_pll_set_option(&AVR32_PM, 1, // pll.
800042fc:	0e 98       	mov	r8,r7
800042fe:	30 19       	mov	r9,1
80004300:	12 9a       	mov	r10,r9
80004302:	12 9b       	mov	r11,r9
80004304:	fe 7c 0c 00 	mov	r12,-62464
80004308:	f0 1f 00 47 	mcall	80004424 <main+0x1c8>
    1,  // pll_freq: choose the range 80-180MHz.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL1 and wait forl lock
  pm_pll_enable(&AVR32_PM, 1);
8000430c:	30 1b       	mov	r11,1
8000430e:	fe 7c 0c 00 	mov	r12,-62464
80004312:	f0 1f 00 46 	mcall	80004428 <main+0x1cc>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(&AVR32_PM);
80004316:	fe 7c 0c 00 	mov	r12,-62464
8000431a:	f0 1f 00 49 	mcall	8000443c <main+0x1e0>
{
	/* Insert system clock initialization code here (sysclk_init()). */
	init_sys_clocks();
	
	/* Initialize RS232 debug text output. */
	init_dbg_rs232(FPBA_HZ); /**/
8000431e:	e0 6c 76 00 	mov	r12,30208
80004322:	ea 1c 03 b3 	orh	r12,0x3b3
80004326:	f0 1f 00 47 	mcall	80004440 <main+0x1e4>
	/* TWI */
	const gpio_map_t TPA6130_TWI_GPIO_MAP =
	{
		{TPA6130_TWI_SCL_PIN, TPA6130_TWI_SCL_FUNCTION},
		{TPA6130_TWI_SDA_PIN, TPA6130_TWI_SDA_FUNCTION}
	};
8000432a:	4c 78       	lddpc	r8,80004444 <main+0x1e8>
8000432c:	fa 05 00 0c 	add	r12,sp,r5
80004330:	f0 ea 00 00 	ld.d	r10,r8[0]
80004334:	f8 eb 00 00 	st.d	r12[0],r10
80004338:	f0 e8 00 08 	ld.d	r8,r8[8]
8000433c:	f8 e9 00 08 	st.d	r12[8],r8
	const twi_options_t TPA6130_TWI_OPTIONS =
	{
		.pba_hz = FPBA_HZ,
		.speed  = TPA6130_TWI_MASTER_SPEED,
		.chip   = TPA6130_TWI_ADDRESS
	};
80004340:	4c 28       	lddpc	r8,80004448 <main+0x1ec>
80004342:	fa c6 ff e0 	sub	r6,sp,-32
80004346:	f0 ea 00 00 	ld.d	r10,r8[0]
8000434a:	ec eb 00 00 	st.d	r6[0],r10
8000434e:	70 28       	ld.w	r8,r8[0x8]
80004350:	8d 28       	st.w	r6[0x8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(TPA6130_TWI_GPIO_MAP,
80004352:	30 2b       	mov	r11,2
80004354:	f0 1f 00 3e 	mcall	8000444c <main+0x1f0>
	sizeof(TPA6130_TWI_GPIO_MAP) / sizeof(TPA6130_TWI_GPIO_MAP[0]));

	// Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
80004358:	0c 9b       	mov	r11,r6
8000435a:	fe 7c 2c 00 	mov	r12,-54272
8000435e:	f0 1f 00 3d 	mcall	80004450 <main+0x1f4>
	
	/* TWA */
	tpa6130_init();
80004362:	f0 1f 00 3d 	mcall	80004454 <main+0x1f8>
	
	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,
80004366:	e0 68 76 00 	mov	r8,30208
8000436a:	ea 18 03 b3 	orh	r8,0x3b3
8000436e:	1a d8       	st.w	--sp,r8
80004370:	30 38       	mov	r8,3
80004372:	1a d8       	st.w	--sp,r8
80004374:	4b 98       	lddpc	r8,80004458 <main+0x1fc>
80004376:	0e 99       	mov	r9,r7
80004378:	0a 9a       	mov	r10,r5
8000437a:	30 2b       	mov	r11,2
8000437c:	e0 6c 2b 11 	mov	r12,11025
80004380:	f0 1f 00 37 	mcall	8000445c <main+0x200>
						master_callback,
						AUDIO_DAC_OUT_OF_SAMPLE_CB
						| AUDIO_DAC_RELOAD_CB,
						FPBA_HZ); /**/

	tpa6130_set_volume(0x20); // 2F
80004384:	32 0c       	mov	r12,32
80004386:	f0 1f 00 37 	mcall	80004460 <main+0x204>
	tpa6130_get_volume();
8000438a:	f0 1f 00 37 	mcall	80004464 <main+0x208>
}

static void init_qt_interrupt(void)
{
	/* INTC */
	Disable_global_interrupt();
8000438e:	d3 03       	ssrf	0x10
	//INTC_init_interrupts();
	// QT
	INTC_register_interrupt(&RT_ISR_gpio_qt_70, 70, AVR32_INTC_INT0);
80004390:	0e 9a       	mov	r10,r7
80004392:	34 6b       	mov	r11,70
80004394:	4b 5c       	lddpc	r12,80004468 <main+0x20c>
80004396:	f0 1f 00 36 	mcall	8000446c <main+0x210>
	INTC_register_interrupt(&RT_ISR_gpio_qt_71, 71, AVR32_INTC_INT0);
8000439a:	0e 9a       	mov	r10,r7
8000439c:	34 7b       	mov	r11,71
8000439e:	4b 5c       	lddpc	r12,80004470 <main+0x214>
800043a0:	f0 1f 00 33 	mcall	8000446c <main+0x210>
	Enable_global_interrupt();
800043a4:	d5 03       	csrf	0x10
		
	/* GPIO */
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_UP,    GPIO_RISING_EDGE);
800043a6:	30 1b       	mov	r11,1
800043a8:	33 6c       	mov	r12,54
800043aa:	f0 1f 00 33 	mcall	80004474 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_DOWN,  GPIO_RISING_EDGE);
800043ae:	30 1b       	mov	r11,1
800043b0:	33 7c       	mov	r12,55
800043b2:	f0 1f 00 31 	mcall	80004474 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_LEFT,  GPIO_RISING_EDGE);
800043b6:	30 1b       	mov	r11,1
800043b8:	33 9c       	mov	r12,57
800043ba:	f0 1f 00 2f 	mcall	80004474 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_RIGHT, GPIO_RISING_EDGE);
800043be:	30 1b       	mov	r11,1
800043c0:	33 8c       	mov	r12,56
800043c2:	f0 1f 00 2d 	mcall	80004474 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_ENTER, GPIO_RISING_EDGE);
800043c6:	30 1b       	mov	r11,1
800043c8:	33 ac       	mov	r12,58
800043ca:	f0 1f 00 2b 	mcall	80004474 <main+0x218>
		
	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
800043ce:	4a b8       	lddpc	r8,80004478 <main+0x21c>
800043d0:	b0 87       	st.b	r8[0x0],r7
	init_twi_tpa();
	
	init_qt_interrupt();
	
	// Enable LED0 and LED1
	gpio_enable_gpio_pin(LED0_GPIO);
800043d2:	33 bc       	mov	r12,59
800043d4:	f0 1f 00 2a 	mcall	8000447c <main+0x220>
	gpio_enable_gpio_pin(LED1_GPIO);
800043d8:	33 cc       	mov	r12,60
800043da:	f0 1f 00 29 	mcall	8000447c <main+0x220>
	
	print_dbg(MSG_WELCOME);
800043de:	4a 9c       	lddpc	r12,80004480 <main+0x224>
800043e0:	f0 1f 00 29 	mcall	80004484 <main+0x228>
	
	/* Insert application code here, after the board has been initialized. */
	
	//uint16_t pass = 25;
	//xTaskCreate(myTask1, "taks1", 256, (void *)pass, mainLED_TASK_PRIORITY, &myTask1Handle);
	xTaskCreate(qtButtonTask,  "tQT",        256, (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
800043e4:	4a 98       	lddpc	r8,80004488 <main+0x22c>
800043e6:	1a d8       	st.w	--sp,r8
800043e8:	30 28       	mov	r8,2
800043ea:	0e 99       	mov	r9,r7
800043ec:	e0 6a 01 00 	mov	r10,256
800043f0:	4a 7b       	lddpc	r11,8000448c <main+0x230>
800043f2:	4a 8c       	lddpc	r12,80004490 <main+0x234>
800043f4:	f0 1f 00 28 	mcall	80004494 <main+0x238>
	xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
800043f8:	4a 88       	lddpc	r8,80004498 <main+0x23c>
800043fa:	1a d8       	st.w	--sp,r8
800043fc:	30 18       	mov	r8,1
800043fe:	0e 99       	mov	r9,r7
80004400:	e0 6a 08 00 	mov	r10,2048
80004404:	4a 6b       	lddpc	r11,8000449c <main+0x240>
80004406:	4a 7c       	lddpc	r12,800044a0 <main+0x244>
80004408:	f0 1f 00 23 	mcall	80004494 <main+0x238>
	
	vTaskStartScheduler();
8000440c:	2f 8d       	sub	sp,-32
8000440e:	f0 1f 00 26 	mcall	800044a4 <main+0x248>
80004412:	c0 08       	rjmp	80004412 <main+0x1b6>
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	2c fc       	sub	r12,-49
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	2b d8       	sub	r8,-67
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	2c 30       	sub	r0,-61
80004420:	80 00       	ld.sh	r0,r0[0x0]
80004422:	2c 92       	sub	r2,-55
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	2c b4       	sub	r4,-53
80004428:	80 00       	ld.sh	r0,r0[0x0]
8000442a:	2c ce       	sub	lr,-52
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	2c dc       	sub	r12,-51
80004430:	80 00       	ld.sh	r0,r0[0x0]
80004432:	2c 4c       	sub	r12,-60
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	2b 40       	sub	r0,-76
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	2c f0       	sub	r0,-49
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	2c e6       	sub	r6,-50
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	2b 2c       	sub	r12,-78
80004444:	80 03       	ld.sh	r3,r0[0x0]
80004446:	6d 44       	ld.w	r4,r6[0x50]
80004448:	80 03       	ld.sh	r3,r0[0x0]
8000444a:	6d a0       	ld.w	r0,r6[0x68]
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	3f ec       	mov	r12,-2
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	2a 28       	sub	r8,-94
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	22 28       	sub	r8,34
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	42 58       	lddsp	r8,sp[0x94]
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	23 10       	sub	r0,49
80004460:	80 00       	ld.sh	r0,r0[0x0]
80004462:	20 b4       	sub	r4,11
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	21 90       	sub	r0,25
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	45 ec       	lddsp	r12,sp[0x178]
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	41 0c       	lddsp	r12,sp[0x40]
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	45 1c       	lddsp	r12,sp[0x144]
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	40 94       	lddsp	r4,sp[0x24]
80004478:	00 00       	add	r0,r0
8000447a:	08 48       	or	r8,r4
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	40 1c       	lddsp	r12,sp[0x4]
80004480:	80 03       	ld.sh	r3,r0[0x0]
80004482:	6d 54       	ld.w	r4,r6[0x54]
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	2a d8       	sub	r8,-83
80004488:	00 00       	add	r0,r0
8000448a:	07 ac       	ld.ub	r12,r3[0x2]
8000448c:	80 03       	ld.sh	r3,r0[0x0]
8000448e:	6d 90       	ld.w	r0,r6[0x64]
80004490:	80 00       	ld.sh	r0,r0[0x0]
80004492:	46 64       	lddsp	r4,sp[0x198]
80004494:	80 00       	ld.sh	r0,r0[0x0]
80004496:	3d 54       	mov	r4,-43
80004498:	00 00       	add	r0,r0
8000449a:	07 dc       	ld.ub	r12,r3[0x5]
8000449c:	80 03       	ld.sh	r3,r0[0x0]
8000449e:	6d 94       	ld.w	r4,r6[0x64]
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	47 78       	lddsp	r8,sp[0x1dc]
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	3f 40       	mov	r0,-12

800044a8 <RT_ISR_gpio_qt_71_not_naked>:
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
{
800044a8:	d4 01       	pushm	lr
	// ENTER, LEFT, RIGHT
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER))
800044aa:	33 ac       	mov	r12,58
800044ac:	f0 1f 00 17 	mcall	80004508 <RT_ISR_gpio_qt_71_not_naked+0x60>
800044b0:	c0 b0       	breq	800044c6 <RT_ISR_gpio_qt_71_not_naked+0x1e>
	{
		INTC_QT_FLAG._enter = true;
800044b2:	49 78       	lddpc	r8,8000450c <RT_ISR_gpio_qt_71_not_naked+0x64>
800044b4:	11 89       	ld.ub	r9,r8[0x0]
800044b6:	30 1a       	mov	r10,1
800044b8:	f3 da d0 e1 	bfins	r9,r10,0x7,0x1
800044bc:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER);
800044be:	33 ac       	mov	r12,58
800044c0:	f0 1f 00 14 	mcall	80004510 <RT_ISR_gpio_qt_71_not_naked+0x68>
800044c4:	c1 c8       	rjmp	800044fc <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT))
800044c6:	33 9c       	mov	r12,57
800044c8:	f0 1f 00 10 	mcall	80004508 <RT_ISR_gpio_qt_71_not_naked+0x60>
800044cc:	c0 b0       	breq	800044e2 <RT_ISR_gpio_qt_71_not_naked+0x3a>
	{
		INTC_QT_FLAG._left = true;
800044ce:	49 08       	lddpc	r8,8000450c <RT_ISR_gpio_qt_71_not_naked+0x64>
800044d0:	11 89       	ld.ub	r9,r8[0x0]
800044d2:	30 1a       	mov	r10,1
800044d4:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
800044d8:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT);
800044da:	33 9c       	mov	r12,57
800044dc:	f0 1f 00 0d 	mcall	80004510 <RT_ISR_gpio_qt_71_not_naked+0x68>
800044e0:	c0 e8       	rjmp	800044fc <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT))
800044e2:	33 8c       	mov	r12,56
800044e4:	f0 1f 00 09 	mcall	80004508 <RT_ISR_gpio_qt_71_not_naked+0x60>
800044e8:	c0 a0       	breq	800044fc <RT_ISR_gpio_qt_71_not_naked+0x54>
	{
		INTC_QT_FLAG._right = true;
800044ea:	48 98       	lddpc	r8,8000450c <RT_ISR_gpio_qt_71_not_naked+0x64>
800044ec:	11 89       	ld.ub	r9,r8[0x0]
800044ee:	30 1a       	mov	r10,1
800044f0:	f3 da d0 a1 	bfins	r9,r10,0x5,0x1
800044f4:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT);
800044f6:	33 8c       	mov	r12,56
800044f8:	f0 1f 00 06 	mcall	80004510 <RT_ISR_gpio_qt_71_not_naked+0x68>
	}
	
	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
800044fc:	48 68       	lddpc	r8,80004514 <RT_ISR_gpio_qt_71_not_naked+0x6c>
800044fe:	70 0c       	ld.w	r12,r8[0x0]
80004500:	f0 1f 00 06 	mcall	80004518 <RT_ISR_gpio_qt_71_not_naked+0x70>
	return (checkIfYieldRequired ? 1 : 0);
	
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80004504:	5f 1c       	srne	r12
80004506:	d8 02       	popm	pc
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	40 da       	lddsp	r10,sp[0x34]
8000450c:	00 00       	add	r0,r0
8000450e:	08 48       	or	r8,r4
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	40 f2       	lddsp	r2,sp[0x3c]
80004514:	00 00       	add	r0,r0
80004516:	07 ac       	ld.ub	r12,r3[0x2]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	3a 40       	mov	r0,-92

8000451c <RT_ISR_gpio_qt_71>:
	
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
8000451c:	eb cd 00 ff 	pushm	r0-r7
80004520:	e0 68 00 0c 	mov	r8,12
80004524:	ea 18 00 00 	orh	r8,0x0
80004528:	70 00       	ld.w	r0,r8[0x0]
8000452a:	1a d0       	st.w	--sp,r0
8000452c:	7a 90       	ld.w	r0,sp[0x24]
8000452e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004532:	58 10       	cp.w	r0,1
80004534:	e0 8b 00 08 	brhi	80004544 <LABEL_ISR_SKIP_SAVE_CONTEXT_539>
80004538:	e0 68 06 3c 	mov	r8,1596
8000453c:	ea 18 00 00 	orh	r8,0x0
80004540:	70 00       	ld.w	r0,r8[0x0]
80004542:	81 0d       	st.w	r0[0x0],sp

80004544 <LABEL_ISR_SKIP_SAVE_CONTEXT_539>:
80004544:	f0 1f 00 10 	mcall	80004584 <LABEL_ISR_SKIP_RESTORE_CONTEXT_539+0x14>
80004548:	7a 90       	ld.w	r0,sp[0x24]
8000454a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000454e:	58 10       	cp.w	r0,1
80004550:	e0 8b 00 10 	brhi	80004570 <LABEL_ISR_SKIP_RESTORE_CONTEXT_539>
80004554:	58 1c       	cp.w	r12,1
80004556:	c0 71       	brne	80004564 <LABEL_ISR_RESTORE_CONTEXT_539>
80004558:	f0 1f 00 0c 	mcall	80004588 <LABEL_ISR_SKIP_RESTORE_CONTEXT_539+0x18>
8000455c:	f0 1f 00 0c 	mcall	8000458c <LABEL_ISR_SKIP_RESTORE_CONTEXT_539+0x1c>
80004560:	f0 1f 00 0c 	mcall	80004590 <LABEL_ISR_SKIP_RESTORE_CONTEXT_539+0x20>

80004564 <LABEL_ISR_RESTORE_CONTEXT_539>:
80004564:	e0 68 06 3c 	mov	r8,1596
80004568:	ea 18 00 00 	orh	r8,0x0
8000456c:	70 00       	ld.w	r0,r8[0x0]
8000456e:	60 0d       	ld.w	sp,r0[0x0]

80004570 <LABEL_ISR_SKIP_RESTORE_CONTEXT_539>:
80004570:	1b 00       	ld.w	r0,sp++
80004572:	e0 68 00 0c 	mov	r8,12
80004576:	ea 18 00 00 	orh	r8,0x0
8000457a:	91 00       	st.w	r8[0x0],r0
8000457c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004580:	d6 03       	rete
80004582:	00 00       	add	r0,r0
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	44 a8       	lddsp	r8,sp[0x128]
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	2f fc       	sub	r12,-1
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	35 48       	mov	r8,84
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	31 08       	mov	r8,16

80004594 <RT_ISR_gpio_qt_70_not_naked>:
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
{
80004594:	d4 01       	pushm	lr
	// UP, DOWN
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP))
80004596:	33 6c       	mov	r12,54
80004598:	f0 1f 00 10 	mcall	800045d8 <RT_ISR_gpio_qt_70_not_naked+0x44>
8000459c:	c0 b0       	breq	800045b2 <RT_ISR_gpio_qt_70_not_naked+0x1e>
	{
		INTC_QT_FLAG._up = true;
8000459e:	49 08       	lddpc	r8,800045dc <RT_ISR_gpio_qt_70_not_naked+0x48>
800045a0:	11 89       	ld.ub	r9,r8[0x0]
800045a2:	30 1a       	mov	r10,1
800045a4:	f3 da d0 81 	bfins	r9,r10,0x4,0x1
800045a8:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP);
800045aa:	33 6c       	mov	r12,54
800045ac:	f0 1f 00 0d 	mcall	800045e0 <RT_ISR_gpio_qt_70_not_naked+0x4c>
800045b0:	c0 e8       	rjmp	800045cc <RT_ISR_gpio_qt_70_not_naked+0x38>
		
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN))
800045b2:	33 7c       	mov	r12,55
800045b4:	f0 1f 00 09 	mcall	800045d8 <RT_ISR_gpio_qt_70_not_naked+0x44>
800045b8:	c0 a0       	breq	800045cc <RT_ISR_gpio_qt_70_not_naked+0x38>
	{
		INTC_QT_FLAG._down = true;
800045ba:	48 98       	lddpc	r8,800045dc <RT_ISR_gpio_qt_70_not_naked+0x48>
800045bc:	11 89       	ld.ub	r9,r8[0x0]
800045be:	30 1a       	mov	r10,1
800045c0:	f3 da d0 61 	bfins	r9,r10,0x3,0x1
800045c4:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN);
800045c6:	33 7c       	mov	r12,55
800045c8:	f0 1f 00 06 	mcall	800045e0 <RT_ISR_gpio_qt_70_not_naked+0x4c>
	}
	
	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
800045cc:	48 68       	lddpc	r8,800045e4 <RT_ISR_gpio_qt_70_not_naked+0x50>
800045ce:	70 0c       	ld.w	r12,r8[0x0]
800045d0:	f0 1f 00 06 	mcall	800045e8 <RT_ISR_gpio_qt_70_not_naked+0x54>
	return (checkIfYieldRequired ? 1 : 0);
	
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
800045d4:	5f 1c       	srne	r12
800045d6:	d8 02       	popm	pc
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	40 da       	lddsp	r10,sp[0x34]
800045dc:	00 00       	add	r0,r0
800045de:	08 48       	or	r8,r4
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	40 f2       	lddsp	r2,sp[0x3c]
800045e4:	00 00       	add	r0,r0
800045e6:	07 ac       	ld.ub	r12,r3[0x2]
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	3a 40       	mov	r0,-92

800045ec <RT_ISR_gpio_qt_70>:

	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
800045ec:	eb cd 00 ff 	pushm	r0-r7
800045f0:	e0 68 00 0c 	mov	r8,12
800045f4:	ea 18 00 00 	orh	r8,0x0
800045f8:	70 00       	ld.w	r0,r8[0x0]
800045fa:	1a d0       	st.w	--sp,r0
800045fc:	7a 90       	ld.w	r0,sp[0x24]
800045fe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004602:	58 10       	cp.w	r0,1
80004604:	e0 8b 00 08 	brhi	80004614 <LABEL_ISR_SKIP_SAVE_CONTEXT_518>
80004608:	e0 68 06 3c 	mov	r8,1596
8000460c:	ea 18 00 00 	orh	r8,0x0
80004610:	70 00       	ld.w	r0,r8[0x0]
80004612:	81 0d       	st.w	r0[0x0],sp

80004614 <LABEL_ISR_SKIP_SAVE_CONTEXT_518>:
80004614:	f0 1f 00 10 	mcall	80004654 <LABEL_ISR_SKIP_RESTORE_CONTEXT_518+0x14>
80004618:	7a 90       	ld.w	r0,sp[0x24]
8000461a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000461e:	58 10       	cp.w	r0,1
80004620:	e0 8b 00 10 	brhi	80004640 <LABEL_ISR_SKIP_RESTORE_CONTEXT_518>
80004624:	58 1c       	cp.w	r12,1
80004626:	c0 71       	brne	80004634 <LABEL_ISR_RESTORE_CONTEXT_518>
80004628:	f0 1f 00 0c 	mcall	80004658 <LABEL_ISR_SKIP_RESTORE_CONTEXT_518+0x18>
8000462c:	f0 1f 00 0c 	mcall	8000465c <LABEL_ISR_SKIP_RESTORE_CONTEXT_518+0x1c>
80004630:	f0 1f 00 0c 	mcall	80004660 <LABEL_ISR_SKIP_RESTORE_CONTEXT_518+0x20>

80004634 <LABEL_ISR_RESTORE_CONTEXT_518>:
80004634:	e0 68 06 3c 	mov	r8,1596
80004638:	ea 18 00 00 	orh	r8,0x0
8000463c:	70 00       	ld.w	r0,r8[0x0]
8000463e:	60 0d       	ld.w	sp,r0[0x0]

80004640 <LABEL_ISR_SKIP_RESTORE_CONTEXT_518>:
80004640:	1b 00       	ld.w	r0,sp++
80004642:	e0 68 00 0c 	mov	r8,12
80004646:	ea 18 00 00 	orh	r8,0x0
8000464a:	91 00       	st.w	r8[0x0],r0
8000464c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004650:	d6 03       	rete
80004652:	00 00       	add	r0,r0
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	45 94       	lddsp	r4,sp[0x164]
80004658:	80 00       	ld.sh	r0,r0[0x0]
8000465a:	2f fc       	sub	r12,-1
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	35 48       	mov	r8,84
80004660:	80 00       	ld.sh	r0,r0[0x0]
80004662:	31 08       	mov	r8,16

80004664 <qtButtonTask>:
}

// qtHandle
portTASK_FUNCTION( qtButtonTask, p );
portTASK_FUNCTION( qtButtonTask, p )
{
80004664:	d4 31       	pushm	r0-r7,lr
	gpio_set_gpio_pin(LED0_GPIO);
80004666:	33 bc       	mov	r12,59
80004668:	f0 1f 00 3a 	mcall	80004750 <qtButtonTask+0xec>
	gpio_set_gpio_pin(LED1_GPIO);
8000466c:	33 cc       	mov	r12,60
8000466e:	f0 1f 00 39 	mcall	80004750 <qtButtonTask+0xec>
	gpio_set_gpio_pin(LED2_GPIO);
80004672:	30 5c       	mov	r12,5
80004674:	f0 1f 00 37 	mcall	80004750 <qtButtonTask+0xec>
	gpio_set_gpio_pin(LED3_GPIO);
80004678:	30 6c       	mov	r12,6
8000467a:	f0 1f 00 36 	mcall	80004750 <qtButtonTask+0xec>
	
	static uint16_t samplesToMove;
	forwardQueue = xQueueCreate( 1 , sizeof(uint16_t));
8000467e:	30 0a       	mov	r10,0
80004680:	30 2b       	mov	r11,2
80004682:	30 1c       	mov	r12,1
80004684:	f0 1f 00 34 	mcall	80004754 <qtButtonTask+0xf0>
80004688:	4b 48       	lddpc	r8,80004758 <qtButtonTask+0xf4>
8000468a:	91 0c       	st.w	r8[0x0],r12
	reverseQueue = xQueueCreate( 1 , sizeof(uint16_t));
8000468c:	30 0a       	mov	r10,0
8000468e:	30 2b       	mov	r11,2
80004690:	30 1c       	mov	r12,1
80004692:	f0 1f 00 31 	mcall	80004754 <qtButtonTask+0xf0>
80004696:	4b 28       	lddpc	r8,8000475c <qtButtonTask+0xf8>
80004698:	91 0c       	st.w	r8[0x0],r12
	
	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
8000469a:	30 07       	mov	r7,0
		if (INTC_QT_FLAG._left) {
8000469c:	4b 15       	lddpc	r5,80004760 <qtButtonTask+0xfc>
8000469e:	30 06       	mov	r6,0
			INTC_QT_FLAG._left = false;
			//gpio_tgl_gpio_pin(LED0_GPIO);
			samplesToMove = 4096;
800046a0:	4b 14       	lddpc	r4,80004764 <qtButtonTask+0x100>
800046a2:	e0 63 10 00 	mov	r3,4096
			xQueueSend( reverseQueue, &samplesToMove, (TickType_t) 0 );
800046a6:	10 92       	mov	r2,r8
			INTC_QT_FLAG._down = false;
			//gpio_tgl_gpio_pin(LED3_GPIO);
		}
		else if (INTC_QT_FLAG._enter) {
			INTC_QT_FLAG._enter = false;
			xTaskNotifyGive(audioHandle);
800046a8:	4b 00       	lddpc	r0,80004768 <qtButtonTask+0x104>
			xQueueSend( reverseQueue, &samplesToMove, (TickType_t) 0 );
		}
		else if (INTC_QT_FLAG._right) {
			INTC_QT_FLAG._right = false;
			//gpio_tgl_gpio_pin(LED1_GPIO);
			samplesToMove = 2048;
800046aa:	e0 61 08 00 	mov	r1,2048
	forwardQueue = xQueueCreate( 1 , sizeof(uint16_t));
	reverseQueue = xQueueCreate( 1 , sizeof(uint16_t));
	
	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
800046ae:	0e 9c       	mov	r12,r7
800046b0:	f0 1f 00 2f 	mcall	8000476c <qtButtonTask+0x108>
		if (INTC_QT_FLAG._left) {
800046b4:	0b 88       	ld.ub	r8,r5[0x0]
800046b6:	10 99       	mov	r9,r8
800046b8:	e2 19 00 40 	andl	r9,0x40,COH
800046bc:	ec 09 18 00 	cp.b	r9,r6
800046c0:	c0 d0       	breq	800046da <qtButtonTask+0x76>
			INTC_QT_FLAG._left = false;
800046c2:	0b 88       	ld.ub	r8,r5[0x0]
800046c4:	f1 d7 d0 c1 	bfins	r8,r7,0x6,0x1
800046c8:	aa 88       	st.b	r5[0x0],r8
			//gpio_tgl_gpio_pin(LED0_GPIO);
			samplesToMove = 4096;
800046ca:	a8 03       	st.h	r4[0x0],r3
			xQueueSend( reverseQueue, &samplesToMove, (TickType_t) 0 );
800046cc:	0e 99       	mov	r9,r7
800046ce:	0e 9a       	mov	r10,r7
800046d0:	08 9b       	mov	r11,r4
800046d2:	64 0c       	ld.w	r12,r2[0x0]
800046d4:	f0 1f 00 27 	mcall	80004770 <qtButtonTask+0x10c>
800046d8:	ce bb       	rjmp	800046ae <qtButtonTask+0x4a>
		}
		else if (INTC_QT_FLAG._right) {
800046da:	10 99       	mov	r9,r8
800046dc:	e2 19 00 20 	andl	r9,0x20,COH
800046e0:	ec 09 18 00 	cp.b	r9,r6
800046e4:	c0 e0       	breq	80004700 <qtButtonTask+0x9c>
			INTC_QT_FLAG._right = false;
800046e6:	0b 88       	ld.ub	r8,r5[0x0]
800046e8:	f1 d7 d0 a1 	bfins	r8,r7,0x5,0x1
800046ec:	aa 88       	st.b	r5[0x0],r8
			//gpio_tgl_gpio_pin(LED1_GPIO);
			samplesToMove = 2048;
800046ee:	a8 01       	st.h	r4[0x0],r1
			xQueueSend( forwardQueue, &samplesToMove, (TickType_t) 0 );
800046f0:	0e 99       	mov	r9,r7
800046f2:	0e 9a       	mov	r10,r7
800046f4:	08 9b       	mov	r11,r4
800046f6:	49 98       	lddpc	r8,80004758 <qtButtonTask+0xf4>
800046f8:	70 0c       	ld.w	r12,r8[0x0]
800046fa:	f0 1f 00 1e 	mcall	80004770 <qtButtonTask+0x10c>
800046fe:	cd 8b       	rjmp	800046ae <qtButtonTask+0x4a>
		}
		else if (INTC_QT_FLAG._up) {
80004700:	10 99       	mov	r9,r8
80004702:	e2 19 00 10 	andl	r9,0x10,COH
80004706:	ec 09 18 00 	cp.b	r9,r6
8000470a:	c0 60       	breq	80004716 <qtButtonTask+0xb2>
			INTC_QT_FLAG._up = false;
8000470c:	0b 88       	ld.ub	r8,r5[0x0]
8000470e:	f1 d7 d0 81 	bfins	r8,r7,0x4,0x1
80004712:	aa 88       	st.b	r5[0x0],r8
80004714:	cc db       	rjmp	800046ae <qtButtonTask+0x4a>
			//gpio_tgl_gpio_pin(LED2_GPIO);
		}
		else if (INTC_QT_FLAG._down) {
80004716:	10 99       	mov	r9,r8
80004718:	e2 19 00 08 	andl	r9,0x8,COH
8000471c:	ec 09 18 00 	cp.b	r9,r6
80004720:	c0 60       	breq	8000472c <qtButtonTask+0xc8>
			INTC_QT_FLAG._down = false;
80004722:	0b 88       	ld.ub	r8,r5[0x0]
80004724:	f1 d7 d0 61 	bfins	r8,r7,0x3,0x1
80004728:	aa 88       	st.b	r5[0x0],r8
8000472a:	cc 2b       	rjmp	800046ae <qtButtonTask+0x4a>
			//gpio_tgl_gpio_pin(LED3_GPIO);
		}
		else if (INTC_QT_FLAG._enter) {
8000472c:	e0 18 ff 80 	andl	r8,0xff80
80004730:	ec 08 18 00 	cp.b	r8,r6
80004734:	cb d0       	breq	800046ae <qtButtonTask+0x4a>
			INTC_QT_FLAG._enter = false;
80004736:	0b 88       	ld.ub	r8,r5[0x0]
80004738:	f1 d7 d0 e1 	bfins	r8,r7,0x7,0x1
8000473c:	aa 88       	st.b	r5[0x0],r8
			xTaskNotifyGive(audioHandle);
8000473e:	0e 98       	mov	r8,r7
80004740:	30 29       	mov	r9,2
80004742:	0e 9a       	mov	r10,r7
80004744:	0e 9b       	mov	r11,r7
80004746:	60 0c       	ld.w	r12,r0[0x0]
80004748:	f0 1f 00 0b 	mcall	80004774 <qtButtonTask+0x110>
8000474c:	cb 1b       	rjmp	800046ae <qtButtonTask+0x4a>
8000474e:	00 00       	add	r0,r0
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	40 5c       	lddsp	r12,sp[0x14]
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	34 d8       	mov	r8,77
80004758:	00 00       	add	r0,r0
8000475a:	08 50       	eor	r0,r4
8000475c:	00 00       	add	r0,r0
8000475e:	08 44       	or	r4,r4
80004760:	00 00       	add	r0,r0
80004762:	08 48       	or	r8,r4
80004764:	00 00       	add	r0,r0
80004766:	07 b8       	ld.ub	r8,r3[0x3]
80004768:	00 00       	add	r0,r0
8000476a:	07 dc       	ld.ub	r12,r3[0x5]
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	3a c0       	mov	r0,-84
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	33 44       	mov	r4,52
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	36 74       	mov	r4,103

80004778 <playAudioTask>:
}

// audioHandle
portTASK_FUNCTION(playAudioTask, p );
portTASK_FUNCTION(playAudioTask, p )
{
80004778:	d4 31       	pushm	r0-r7,lr
8000477a:	20 5d       	sub	sp,20
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				
				sam[0] =  DSP16_Q((float)sound_table[i]/SONG_BASE_VALUE);
8000477c:	fe f5 02 14 	ld.w	r5,pc[532]
				
				dsp16_filt_iir(o1, sam, 3, filter_coef_num[0], 3, filter_coef_den[0], 3, 15, 15);
80004780:	fe f2 02 14 	ld.w	r2,pc[532]
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
				i++;
				if (i >= sizeof(sound_table))
				{ 
					i = 0;
					memset(sam, DSP16_Q(0.0), sizeof(sam));
80004784:	ea c1 ff fe 	sub	r1,r5,-2
					memset(o1, DSP16_Q(0.0), sizeof(o1));
80004788:	e4 ce ff fe 	sub	lr,r2,-2
8000478c:	50 0e       	stdsp	sp[0x0],lr
8000478e:	2f ee       	sub	lr,-2
80004790:	50 1e       	stdsp	sp[0x4],lr
80004792:	2f ee       	sub	lr,-2
80004794:	50 2e       	stdsp	sp[0x8],lr
80004796:	2f ee       	sub	lr,-2
80004798:	50 3e       	stdsp	sp[0xc],lr
8000479a:	2f ee       	sub	lr,-2
8000479c:	50 4e       	stdsp	sp[0x10],lr
	static dsp16_t sam[3] = {DSP16_Q(0.0), DSP16_Q(0.0), DSP16_Q(0.0)};
	static dsp16_t ototal[1];

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
8000479e:	30 1a       	mov	r10,1
800047a0:	14 9b       	mov	r11,r10
800047a2:	30 0c       	mov	r12,0
800047a4:	f0 1f 00 7d 	mcall	80004998 <playAudioTask+0x220>
800047a8:	4f d8       	lddpc	r8,8000499c <playAudioTask+0x224>
800047aa:	91 0c       	st.w	r8[0x0],r12
		
		if (notificationValue > 0)
800047ac:	58 0c       	cp.w	r12,0
800047ae:	e0 8a 00 07 	brle	800047bc <playAudioTask+0x44>
		{
			//playAudio = !playAudio;
			notify = !notify;
800047b2:	4f c8       	lddpc	r8,800049a0 <playAudioTask+0x228>
800047b4:	11 89       	ld.ub	r9,r8[0x0]
800047b6:	ec 19 00 01 	eorl	r9,0x1
800047ba:	b0 89       	st.b	r8[0x0],r9
			//print_dbg("Notification received.");

		}

		
		if ((pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE) && (notify == true))
800047bc:	30 0c       	mov	r12,0
800047be:	f0 1f 00 7a 	mcall	800049a4 <playAudioTask+0x22c>
800047c2:	e2 1c 00 02 	andl	r12,0x2,COH
800047c6:	c0 70       	breq	800047d4 <playAudioTask+0x5c>
800047c8:	4f 68       	lddpc	r8,800049a0 <playAudioTask+0x228>
800047ca:	11 89       	ld.ub	r9,r8[0x0]
800047cc:	30 08       	mov	r8,0
800047ce:	f0 09 18 00 	cp.b	r9,r8
800047d2:	c0 71       	brne	800047e0 <playAudioTask+0x68>
					//i = (i > samplesRx) ? (i - samplesRx) : i;
				//}
			//}
		}
		
		if (playAudio)
800047d4:	4f 58       	lddpc	r8,800049a8 <playAudioTask+0x230>
800047d6:	11 89       	ld.ub	r9,r8[0x0]
800047d8:	30 08       	mov	r8,0
800047da:	f0 09 18 00 	cp.b	r9,r8
800047de:	ce 00       	breq	8000479e <playAudioTask+0x26>
		{
			playAudio = false;
800047e0:	30 09       	mov	r9,0
800047e2:	4f 28       	lddpc	r8,800049a8 <playAudioTask+0x230>
800047e4:	b0 89       	st.b	r8[0x0],r9
			count = 0;
800047e6:	30 09       	mov	r9,0
800047e8:	4f 18       	lddpc	r8,800049ac <playAudioTask+0x234>
800047ea:	91 09       	st.w	r8[0x0],r9
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
				i++;
				if (i >= sizeof(sound_table))
				{ 
					i = 0;
					memset(sam, DSP16_Q(0.0), sizeof(sam));
800047ec:	e2 c0 ff fe 	sub	r0,r1,-2
		if (playAudio)
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
800047f0:	cb 78       	rjmp	8000495e <playAudioTask+0x1e6>
				
				sam[0] =  DSP16_Q((float)sound_table[i]/SONG_BASE_VALUE);
800047f2:	4f 08       	lddpc	r8,800049b0 <playAudioTask+0x238>
800047f4:	70 08       	ld.w	r8,r8[0x0]
800047f6:	4f 09       	lddpc	r9,800049b4 <playAudioTask+0x23c>
800047f8:	f2 08 07 0c 	ld.ub	r12,r9[r8]
800047fc:	f0 1f 00 6f 	mcall	800049b8 <playAudioTask+0x240>
80004800:	fc 1b 3b 80 	movh	r11,0x3b80
80004804:	f0 1f 00 6e 	mcall	800049bc <playAudioTask+0x244>
80004808:	18 97       	mov	r7,r12
8000480a:	e0 6b fc 00 	mov	r11,64512
8000480e:	ea 1b 3f 7f 	orh	r11,0x3f7f
80004812:	f0 1f 00 6c 	mcall	800049c0 <playAudioTask+0x248>
80004816:	c0 40       	breq	8000481e <playAudioTask+0xa6>
80004818:	e0 6c 7f ff 	mov	r12,32767
8000481c:	c1 38       	rjmp	80004842 <playAudioTask+0xca>
8000481e:	0e 9b       	mov	r11,r7
80004820:	e0 6c fe 00 	mov	r12,65024
80004824:	ea 1c bf 7f 	orh	r12,0xbf7f
80004828:	f0 1f 00 66 	mcall	800049c0 <playAudioTask+0x248>
8000482c:	c0 40       	breq	80004834 <playAudioTask+0xbc>
8000482e:	fe 7c 80 00 	mov	r12,-32768
80004832:	c0 88       	rjmp	80004842 <playAudioTask+0xca>
80004834:	fc 1b 47 00 	movh	r11,0x4700
80004838:	0e 9c       	mov	r12,r7
8000483a:	f0 1f 00 61 	mcall	800049bc <playAudioTask+0x244>
8000483e:	f0 1f 00 62 	mcall	800049c4 <playAudioTask+0x24c>
80004842:	aa 0c       	st.h	r5[0x0],r12
				
				dsp16_filt_iir(o1, sam, 3, filter_coef_num[0], 3, filter_coef_den[0], 3, 15, 15);
80004844:	4e 13       	lddpc	r3,800049c8 <playAudioTask+0x250>
80004846:	30 f6       	mov	r6,15
80004848:	1a d6       	st.w	--sp,r6
8000484a:	1a d6       	st.w	--sp,r6
8000484c:	30 37       	mov	r7,3
8000484e:	1a d7       	st.w	--sp,r7
80004850:	4d f4       	lddpc	r4,800049cc <playAudioTask+0x254>
80004852:	1a d4       	st.w	--sp,r4
80004854:	0e 98       	mov	r8,r7
80004856:	06 99       	mov	r9,r3
80004858:	0e 9a       	mov	r10,r7
8000485a:	0a 9b       	mov	r11,r5
8000485c:	04 9c       	mov	r12,r2
8000485e:	f0 1f 00 5d 	mcall	800049d0 <playAudioTask+0x258>
				dsp16_filt_iir(o2, sam, 3, filter_coef_num[1], 3, filter_coef_den[1], 3, 15, 15);
80004862:	1a d6       	st.w	--sp,r6
80004864:	1a d6       	st.w	--sp,r6
80004866:	1a d7       	st.w	--sp,r7
80004868:	e8 c8 ff fa 	sub	r8,r4,-6
8000486c:	1a d8       	st.w	--sp,r8
8000486e:	0e 98       	mov	r8,r7
80004870:	e6 c9 ff fa 	sub	r9,r3,-6
80004874:	0e 9a       	mov	r10,r7
80004876:	0a 9b       	mov	r11,r5
80004878:	4d 7c       	lddpc	r12,800049d4 <playAudioTask+0x25c>
8000487a:	f0 1f 00 56 	mcall	800049d0 <playAudioTask+0x258>
				dsp16_filt_iir(o3, sam, 3, filter_coef_num[2], 3, filter_coef_den[2], 3, 15, 15);
8000487e:	2f 8d       	sub	sp,-32
80004880:	1a d6       	st.w	--sp,r6
80004882:	1a d6       	st.w	--sp,r6
80004884:	1a d7       	st.w	--sp,r7
80004886:	e8 c8 ff f4 	sub	r8,r4,-12
8000488a:	1a d8       	st.w	--sp,r8
8000488c:	0e 98       	mov	r8,r7
8000488e:	e6 c9 ff f4 	sub	r9,r3,-12
80004892:	0e 9a       	mov	r10,r7
80004894:	0a 9b       	mov	r11,r5
80004896:	4d 1c       	lddpc	r12,800049d8 <playAudioTask+0x260>
80004898:	f0 1f 00 4e 	mcall	800049d0 <playAudioTask+0x258>
				dsp16_filt_iir(o4, sam, 3, filter_coef_num[3], 3, filter_coef_den[3], 3, 15, 15);
8000489c:	1a d6       	st.w	--sp,r6
8000489e:	1a d6       	st.w	--sp,r6
800048a0:	1a d7       	st.w	--sp,r7
800048a2:	e8 c8 ff ee 	sub	r8,r4,-18
800048a6:	1a d8       	st.w	--sp,r8
800048a8:	0e 98       	mov	r8,r7
800048aa:	e6 c9 ff ee 	sub	r9,r3,-18
800048ae:	0e 9a       	mov	r10,r7
800048b0:	0a 9b       	mov	r11,r5
800048b2:	4c bc       	lddpc	r12,800049dc <playAudioTask+0x264>
800048b4:	f0 1f 00 47 	mcall	800049d0 <playAudioTask+0x258>
				dsp16_filt_iir(o5, sam, 3, filter_coef_num[4], 3, filter_coef_den[4], 3, 15, 15);
800048b8:	2f 8d       	sub	sp,-32
800048ba:	1a d6       	st.w	--sp,r6
800048bc:	1a d6       	st.w	--sp,r6
800048be:	1a d7       	st.w	--sp,r7
800048c0:	2e 84       	sub	r4,-24
800048c2:	1a d4       	st.w	--sp,r4
800048c4:	0e 98       	mov	r8,r7
800048c6:	e6 c9 ff e8 	sub	r9,r3,-24
800048ca:	0e 9a       	mov	r10,r7
800048cc:	0a 9b       	mov	r11,r5
800048ce:	4c 5c       	lddpc	r12,800049e0 <playAudioTask+0x268>
800048d0:	f0 1f 00 40 	mcall	800049d0 <playAudioTask+0x258>
				//1.0 * o1[0] + 1.0 * o2[0] + 
				
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
800048d4:	4b 6a       	lddpc	r10,800049ac <playAudioTask+0x234>
800048d6:	74 0b       	ld.w	r11,r10[0x0]
800048d8:	4b 68       	lddpc	r8,800049b0 <playAudioTask+0x238>
800048da:	70 09       	ld.w	r9,r8[0x0]
800048dc:	4b 6c       	lddpc	r12,800049b4 <playAudioTask+0x23c>
800048de:	f8 09 07 07 	ld.ub	r7,r12[r9]
800048e2:	28 07       	sub	r7,-128
800048e4:	a9 67       	lsl	r7,0x8
800048e6:	4c 0c       	lddpc	r12,800049e4 <playAudioTask+0x26c>
800048e8:	f8 0b 0a 17 	st.h	r12[r11<<0x1],r7
800048ec:	2f fb       	sub	r11,-1
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
800048ee:	f8 0b 0a 17 	st.h	r12[r11<<0x1],r7
800048f2:	2f fb       	sub	r11,-1
800048f4:	95 0b       	st.w	r10[0x0],r11
				i++;
800048f6:	2f f9       	sub	r9,-1
800048f8:	91 09       	st.w	r8[0x0],r9
				if (i >= sizeof(sound_table))
800048fa:	2f cd       	sub	sp,-16
800048fc:	e2 59 08 53 	cp.w	r9,198739
80004900:	e0 88 00 2f 	brls	8000495e <playAudioTask+0x1e6>
				{ 
					i = 0;
80004904:	30 08       	mov	r8,0
80004906:	4a b9       	lddpc	r9,800049b0 <playAudioTask+0x238>
80004908:	93 08       	st.w	r9[0x0],r8
					memset(sam, DSP16_Q(0.0), sizeof(sam));
8000490a:	aa 08       	st.h	r5[0x0],r8
8000490c:	a2 08       	st.h	r1[0x0],r8
8000490e:	a0 08       	st.h	r0[0x0],r8
					memset(o1, DSP16_Q(0.0), sizeof(o1));
80004910:	a4 08       	st.h	r2[0x0],r8
80004912:	40 09       	lddsp	r9,sp[0x0]
80004914:	b2 08       	st.h	r9[0x0],r8
80004916:	40 1e       	lddsp	lr,sp[0x4]
80004918:	bc 08       	st.h	lr[0x0],r8
8000491a:	40 29       	lddsp	r9,sp[0x8]
8000491c:	b2 08       	st.h	r9[0x0],r8
8000491e:	40 3e       	lddsp	lr,sp[0xc]
80004920:	bc 08       	st.h	lr[0x0],r8
80004922:	40 49       	lddsp	r9,sp[0x10]
80004924:	b2 08       	st.h	r9[0x0],r8
					memset(o2, DSP16_Q(0.0), sizeof(o2));
80004926:	4a c9       	lddpc	r9,800049d4 <playAudioTask+0x25c>
80004928:	12 b8       	st.h	r9++,r8
8000492a:	12 b8       	st.h	r9++,r8
8000492c:	12 b8       	st.h	r9++,r8
8000492e:	12 b8       	st.h	r9++,r8
80004930:	12 b8       	st.h	r9++,r8
80004932:	b2 08       	st.h	r9[0x0],r8
					memset(o3, DSP16_Q(0.0), sizeof(o3));
80004934:	4a 99       	lddpc	r9,800049d8 <playAudioTask+0x260>
80004936:	12 b8       	st.h	r9++,r8
80004938:	12 b8       	st.h	r9++,r8
8000493a:	12 b8       	st.h	r9++,r8
8000493c:	12 b8       	st.h	r9++,r8
8000493e:	12 b8       	st.h	r9++,r8
80004940:	b2 08       	st.h	r9[0x0],r8
					memset(o4, DSP16_Q(0.0), sizeof(o4));
80004942:	4a 79       	lddpc	r9,800049dc <playAudioTask+0x264>
80004944:	12 b8       	st.h	r9++,r8
80004946:	12 b8       	st.h	r9++,r8
80004948:	12 b8       	st.h	r9++,r8
8000494a:	12 b8       	st.h	r9++,r8
8000494c:	12 b8       	st.h	r9++,r8
8000494e:	b2 08       	st.h	r9[0x0],r8
					memset(o5, DSP16_Q(0.0), sizeof(o5));
80004950:	4a 49       	lddpc	r9,800049e0 <playAudioTask+0x268>
80004952:	12 b8       	st.h	r9++,r8
80004954:	12 b8       	st.h	r9++,r8
80004956:	12 b8       	st.h	r9++,r8
80004958:	12 b8       	st.h	r9++,r8
8000495a:	12 b8       	st.h	r9++,r8
8000495c:	b2 08       	st.h	r9[0x0],r8
		if (playAudio)
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
8000495e:	49 48       	lddpc	r8,800049ac <playAudioTask+0x234>
80004960:	70 08       	ld.w	r8,r8[0x0]
80004962:	e0 48 00 ff 	cp.w	r8,255
80004966:	fe 98 ff 46 	brls	800047f2 <playAudioTask+0x7a>
				//o4[1] = o4[0];
				//o5[2] = o5[1];
				//o5[1] = o5[0];
			}
			
			gpio_set_gpio_pin(LED0_GPIO);
8000496a:	33 bc       	mov	r12,59
8000496c:	f0 1f 00 1f 	mcall	800049e8 <playAudioTask+0x270>
			gpio_clr_gpio_pin(LED1_GPIO);
80004970:	33 cc       	mov	r12,60
80004972:	f0 1f 00 1f 	mcall	800049ec <playAudioTask+0x274>

			// Play buffer
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
80004976:	e0 6b 00 80 	mov	r11,128
8000497a:	49 bc       	lddpc	r12,800049e4 <playAudioTask+0x26c>
8000497c:	f0 1f 00 1d 	mcall	800049f0 <playAudioTask+0x278>

			gpio_clr_gpio_pin(LED0_GPIO);
80004980:	33 bc       	mov	r12,59
80004982:	f0 1f 00 1b 	mcall	800049ec <playAudioTask+0x274>
			gpio_set_gpio_pin(LED1_GPIO);
80004986:	33 cc       	mov	r12,60
80004988:	f0 1f 00 18 	mcall	800049e8 <playAudioTask+0x270>
8000498c:	c0 9b       	rjmp	8000479e <playAudioTask+0x26>
8000498e:	00 00       	add	r0,r0
80004990:	00 00       	add	r0,r0
80004992:	07 ba       	ld.ub	r10,r3[0x3]
80004994:	00 00       	add	r0,r0
80004996:	07 c0       	ld.ub	r0,r3[0x4]
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	3c 10       	mov	r0,-63
8000499c:	00 00       	add	r0,r0
8000499e:	07 cc       	ld.ub	r12,r3[0x4]
800049a0:	00 00       	add	r0,r0
800049a2:	07 b0       	ld.ub	r0,r3[0x3]
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	26 a0       	sub	r0,106
800049a8:	00 00       	add	r0,r0
800049aa:	07 e0       	ld.ub	r0,r3[0x6]
800049ac:	00 00       	add	r0,r0
800049ae:	07 fc       	ld.ub	r12,r3[0x7]
800049b0:	00 00       	add	r0,r0
800049b2:	07 b4       	ld.ub	r4,r3[0x3]
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	64 f0       	ld.w	r0,r2[0x3c]
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	58 06       	cp.w	r6,0
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	57 24       	stdsp	sp[0x1c8],r4
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	56 f0       	stdsp	sp[0x1bc],r0
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	58 76       	cp.w	r6,7
800049c8:	00 00       	add	r0,r0
800049ca:	00 30       	cp.w	r0,r0
800049cc:	00 00       	add	r0,r0
800049ce:	00 10       	sub	r0,r0
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	55 b8       	stdsp	sp[0x16c],r8
800049d4:	00 00       	add	r0,r0
800049d6:	07 e2       	ld.ub	r2,r3[0x6]
800049d8:	00 00       	add	r0,r0
800049da:	08 00       	add	r0,r4
800049dc:	00 00       	add	r0,r0
800049de:	07 d0       	ld.ub	r0,r3[0x5]
800049e0:	00 00       	add	r0,r0
800049e2:	07 ee       	ld.ub	lr,r3[0x6]
800049e4:	00 00       	add	r0,r0
800049e6:	08 54       	eor	r4,r4
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	40 5c       	lddsp	r12,sp[0x14]
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	40 78       	lddsp	r8,sp[0x1c]
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	20 e4       	sub	r4,14

800049f4 <dsp16_filt_iir_kernel_num_x0>:
800049f4:	d4 31       	pushm	r0-r7,lr
800049f6:	20 3d       	sub	sp,12
800049f8:	40 c4       	lddsp	r4,sp[0x30]
800049fa:	e8 04 11 0f 	rsub	r4,r4,15
800049fe:	50 c4       	stdsp	sp[0x30],r4
80004a00:	16 91       	mov	r1,r11
80004a02:	18 9b       	mov	r11,r12
80004a04:	02 9c       	mov	r12,r1
80004a06:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004a0a:	30 3e       	mov	lr,3
80004a0c:	1c 89       	andn	r9,lr
80004a0e:	50 29       	stdsp	sp[0x8],r9
80004a10:	20 38       	sub	r8,3

80004a12 <__dsp16_iir_num_loop_main0>:
80004a12:	50 1b       	stdsp	sp[0x4],r11
80004a14:	50 0a       	stdsp	sp[0x0],r10
80004a16:	40 29       	lddsp	r9,sp[0x8]
80004a18:	30 00       	mov	r0,0
80004a1a:	00 91       	mov	r1,r0
80004a1c:	00 92       	mov	r2,r0
80004a1e:	00 93       	mov	r3,r0
80004a20:	00 9e       	mov	lr,r0

80004a22 <__dsp16_iir_num_loop_tap0>:
80004a22:	f0 0e 19 00 	cp.h	lr,r8
80004a26:	c2 94       	brge	80004a78 <__dsp16_iir_num_endloop_tap0>
80004a28:	b3 14       	ld.d	r4,--r9
80004a2a:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
80004a2e:	e8 07 04 93 	machh.w	r3,r4:b,r7:t
80004a32:	e8 07 04 a3 	machh.w	r3,r4:t,r7:b
80004a36:	ea 06 04 93 	machh.w	r3,r5:b,r6:t
80004a3a:	ea 06 04 a3 	machh.w	r3,r5:t,r6:b
80004a3e:	2f ce       	sub	lr,-4
80004a40:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004a44:	e8 07 04 82 	machh.w	r2,r4:b,r7:b
80004a48:	e8 06 04 b2 	machh.w	r2,r4:t,r6:t
80004a4c:	ea 06 04 82 	machh.w	r2,r5:b,r6:b
80004a50:	ea 0b 04 b2 	machh.w	r2,r5:t,r11:t
80004a54:	e8 06 04 91 	machh.w	r1,r4:b,r6:t
80004a58:	e8 06 04 a1 	machh.w	r1,r4:t,r6:b
80004a5c:	ea 0b 04 91 	machh.w	r1,r5:b,r11:t
80004a60:	ea 0b 04 a1 	machh.w	r1,r5:t,r11:b
80004a64:	e8 06 04 80 	machh.w	r0,r4:b,r6:b
80004a68:	e8 0b 04 b0 	machh.w	r0,r4:t,r11:t
80004a6c:	ea 0b 04 80 	machh.w	r0,r5:b,r11:b
80004a70:	ea 0a 04 b0 	machh.w	r0,r5:t,r10:t
80004a74:	fe 9f ff d7 	bral	80004a22 <__dsp16_iir_num_loop_tap0>

80004a78 <__dsp16_iir_num_endloop_tap0>:
80004a78:	40 c4       	lddsp	r4,sp[0x30]
80004a7a:	e6 04 08 43 	asr	r3,r3,r4
80004a7e:	e4 04 08 42 	asr	r2,r2,r4
80004a82:	e2 04 08 41 	asr	r1,r1,r4
80004a86:	e0 04 08 40 	asr	r0,r0,r4
80004a8a:	40 1b       	lddsp	r11,sp[0x4]
80004a8c:	e7 e2 c0 0b 	sthh.w	r11[0x0],r3:b,r2:b
80004a90:	e3 e0 c0 1b 	sthh.w	r11[0x4],r1:b,r0:b
80004a94:	2f 8b       	sub	r11,-8
80004a96:	2f 8c       	sub	r12,-8
80004a98:	40 0a       	lddsp	r10,sp[0x0]
80004a9a:	20 4a       	sub	r10,4
80004a9c:	fe 99 ff bb 	brgt	80004a12 <__dsp16_iir_num_loop_main0>
80004aa0:	2f dd       	sub	sp,-12
80004aa2:	d8 32       	popm	r0-r7,pc

80004aa4 <dsp16_filt_iir_kernel_num_x1>:
80004aa4:	d4 31       	pushm	r0-r7,lr
80004aa6:	20 3d       	sub	sp,12
80004aa8:	40 c4       	lddsp	r4,sp[0x30]
80004aaa:	e8 04 11 0f 	rsub	r4,r4,15
80004aae:	50 c4       	stdsp	sp[0x30],r4
80004ab0:	16 91       	mov	r1,r11
80004ab2:	18 9b       	mov	r11,r12
80004ab4:	02 9c       	mov	r12,r1
80004ab6:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004aba:	30 3e       	mov	lr,3
80004abc:	1c 89       	andn	r9,lr
80004abe:	50 29       	stdsp	sp[0x8],r9
80004ac0:	20 38       	sub	r8,3

80004ac2 <__dsp16_iir_num_loop_main1>:
80004ac2:	50 1b       	stdsp	sp[0x4],r11
80004ac4:	50 0a       	stdsp	sp[0x0],r10
80004ac6:	40 29       	lddsp	r9,sp[0x8]
80004ac8:	30 00       	mov	r0,0
80004aca:	00 91       	mov	r1,r0
80004acc:	00 92       	mov	r2,r0
80004ace:	00 93       	mov	r3,r0
80004ad0:	00 9e       	mov	lr,r0

80004ad2 <__dsp16_iir_num_loop_tap1>:
80004ad2:	f0 0e 19 00 	cp.h	lr,r8
80004ad6:	c2 b4       	brge	80004b2c <__dsp16_iir_num_endloop_tap1>
80004ad8:	b3 14       	ld.d	r4,--r9
80004ada:	f3 d5 10 04 	ldins.h	r5:t,r9[8]
80004ade:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
80004ae2:	ea 07 04 b3 	machh.w	r3,r5:t,r7:t
80004ae6:	e8 07 04 83 	machh.w	r3,r4:b,r7:b
80004aea:	e8 06 04 b3 	machh.w	r3,r4:t,r6:t
80004aee:	ea 06 04 83 	machh.w	r3,r5:b,r6:b
80004af2:	2f ce       	sub	lr,-4
80004af4:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004af8:	ea 07 04 a2 	machh.w	r2,r5:t,r7:b
80004afc:	e8 06 04 92 	machh.w	r2,r4:b,r6:t
80004b00:	e8 06 04 a2 	machh.w	r2,r4:t,r6:b
80004b04:	ea 0b 04 92 	machh.w	r2,r5:b,r11:t
80004b08:	ea 06 04 b1 	machh.w	r1,r5:t,r6:t
80004b0c:	e8 06 04 81 	machh.w	r1,r4:b,r6:b
80004b10:	e8 0b 04 b1 	machh.w	r1,r4:t,r11:t
80004b14:	ea 0b 04 81 	machh.w	r1,r5:b,r11:b
80004b18:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004b1c:	e8 0b 04 90 	machh.w	r0,r4:b,r11:t
80004b20:	e8 0b 04 a0 	machh.w	r0,r4:t,r11:b
80004b24:	ea 0a 04 90 	machh.w	r0,r5:b,r10:t
80004b28:	fe 9f ff d5 	bral	80004ad2 <__dsp16_iir_num_loop_tap1>

80004b2c <__dsp16_iir_num_endloop_tap1>:
80004b2c:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004b30:	92 04       	ld.sh	r4,r9[0x0]
80004b32:	e8 0b 04 93 	machh.w	r3,r4:b,r11:t
80004b36:	e8 0b 04 82 	machh.w	r2,r4:b,r11:b
80004b3a:	e8 0a 04 91 	machh.w	r1,r4:b,r10:t
80004b3e:	e8 0a 04 80 	machh.w	r0,r4:b,r10:b
80004b42:	40 c4       	lddsp	r4,sp[0x30]
80004b44:	e6 04 08 43 	asr	r3,r3,r4
80004b48:	e4 04 08 42 	asr	r2,r2,r4
80004b4c:	e2 04 08 41 	asr	r1,r1,r4
80004b50:	e0 04 08 40 	asr	r0,r0,r4
80004b54:	40 1b       	lddsp	r11,sp[0x4]
80004b56:	e7 e2 c0 0b 	sthh.w	r11[0x0],r3:b,r2:b
80004b5a:	e3 e0 c0 1b 	sthh.w	r11[0x4],r1:b,r0:b
80004b5e:	2f 8b       	sub	r11,-8
80004b60:	2f 8c       	sub	r12,-8
80004b62:	40 0a       	lddsp	r10,sp[0x0]
80004b64:	20 4a       	sub	r10,4
80004b66:	fe 99 ff ae 	brgt	80004ac2 <__dsp16_iir_num_loop_main1>
80004b6a:	2f dd       	sub	sp,-12
80004b6c:	d8 32       	popm	r0-r7,pc

80004b6e <dsp16_filt_iir_kernel_num_x2>:
80004b6e:	d4 31       	pushm	r0-r7,lr
80004b70:	20 3d       	sub	sp,12
80004b72:	40 c4       	lddsp	r4,sp[0x30]
80004b74:	e8 04 11 0f 	rsub	r4,r4,15
80004b78:	50 c4       	stdsp	sp[0x30],r4
80004b7a:	16 91       	mov	r1,r11
80004b7c:	18 9b       	mov	r11,r12
80004b7e:	02 9c       	mov	r12,r1
80004b80:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004b84:	30 3e       	mov	lr,3
80004b86:	1c 89       	andn	r9,lr
80004b88:	50 29       	stdsp	sp[0x8],r9
80004b8a:	20 38       	sub	r8,3

80004b8c <__dsp16_iir_num_loop_main2>:
80004b8c:	50 1b       	stdsp	sp[0x4],r11
80004b8e:	50 0a       	stdsp	sp[0x0],r10
80004b90:	40 29       	lddsp	r9,sp[0x8]
80004b92:	30 00       	mov	r0,0
80004b94:	00 91       	mov	r1,r0
80004b96:	00 92       	mov	r2,r0
80004b98:	00 93       	mov	r3,r0
80004b9a:	00 9e       	mov	lr,r0

80004b9c <__dsp16_iir_num_loop_tap2>:
80004b9c:	f0 0e 19 00 	cp.h	lr,r8
80004ba0:	c2 94       	brge	80004bf2 <__dsp16_iir_num_endloop_tap2>
80004ba2:	b3 14       	ld.d	r4,--r9
80004ba4:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
80004ba8:	e8 07 04 93 	machh.w	r3,r4:b,r7:t
80004bac:	e8 07 04 a3 	machh.w	r3,r4:t,r7:b
80004bb0:	ea 06 04 93 	machh.w	r3,r5:b,r6:t
80004bb4:	ea 06 04 a3 	machh.w	r3,r5:t,r6:b
80004bb8:	2f ce       	sub	lr,-4
80004bba:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004bbe:	e8 07 04 82 	machh.w	r2,r4:b,r7:b
80004bc2:	e8 06 04 b2 	machh.w	r2,r4:t,r6:t
80004bc6:	ea 06 04 82 	machh.w	r2,r5:b,r6:b
80004bca:	ea 0b 04 b2 	machh.w	r2,r5:t,r11:t
80004bce:	e8 06 04 91 	machh.w	r1,r4:b,r6:t
80004bd2:	e8 06 04 a1 	machh.w	r1,r4:t,r6:b
80004bd6:	ea 0b 04 91 	machh.w	r1,r5:b,r11:t
80004bda:	ea 0b 04 a1 	machh.w	r1,r5:t,r11:b
80004bde:	e8 06 04 80 	machh.w	r0,r4:b,r6:b
80004be2:	e8 0b 04 b0 	machh.w	r0,r4:t,r11:t
80004be6:	ea 0b 04 80 	machh.w	r0,r5:b,r11:b
80004bea:	ea 0a 04 b0 	machh.w	r0,r5:t,r10:t
80004bee:	fe 9f ff d7 	bral	80004b9c <__dsp16_iir_num_loop_tap2>

80004bf2 <__dsp16_iir_num_endloop_tap2>:
80004bf2:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004bf6:	13 44       	ld.w	r4,--r9
80004bf8:	2f ce       	sub	lr,-4
80004bfa:	f8 0e 05 16 	ld.uh	r6,r12[lr<<0x1]
80004bfe:	e8 0b 04 93 	machh.w	r3,r4:b,r11:t
80004c02:	e8 0b 04 a3 	machh.w	r3,r4:t,r11:b
80004c06:	e8 0b 04 82 	machh.w	r2,r4:b,r11:b
80004c0a:	e8 0a 04 b2 	machh.w	r2,r4:t,r10:t
80004c0e:	e8 0a 04 91 	machh.w	r1,r4:b,r10:t
80004c12:	e8 0a 04 a1 	machh.w	r1,r4:t,r10:b
80004c16:	e8 0a 04 80 	machh.w	r0,r4:b,r10:b
80004c1a:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
80004c1e:	40 c4       	lddsp	r4,sp[0x30]
80004c20:	e6 04 08 43 	asr	r3,r3,r4
80004c24:	e4 04 08 42 	asr	r2,r2,r4
80004c28:	e2 04 08 41 	asr	r1,r1,r4
80004c2c:	e0 04 08 40 	asr	r0,r0,r4
80004c30:	40 1b       	lddsp	r11,sp[0x4]
80004c32:	e7 e2 c0 0b 	sthh.w	r11[0x0],r3:b,r2:b
80004c36:	e3 e0 c0 1b 	sthh.w	r11[0x4],r1:b,r0:b
80004c3a:	2f 8b       	sub	r11,-8
80004c3c:	2f 8c       	sub	r12,-8
80004c3e:	40 0a       	lddsp	r10,sp[0x0]
80004c40:	20 4a       	sub	r10,4
80004c42:	fe 99 ff a5 	brgt	80004b8c <__dsp16_iir_num_loop_main2>
80004c46:	2f dd       	sub	sp,-12
80004c48:	d8 32       	popm	r0-r7,pc

80004c4a <dsp16_filt_iir_kernel_num_x3>:
80004c4a:	d4 31       	pushm	r0-r7,lr
80004c4c:	20 3d       	sub	sp,12
80004c4e:	40 c4       	lddsp	r4,sp[0x30]
80004c50:	e8 04 11 0f 	rsub	r4,r4,15
80004c54:	50 c4       	stdsp	sp[0x30],r4
80004c56:	16 91       	mov	r1,r11
80004c58:	18 9b       	mov	r11,r12
80004c5a:	02 9c       	mov	r12,r1
80004c5c:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004c60:	30 3e       	mov	lr,3
80004c62:	1c 89       	andn	r9,lr
80004c64:	50 29       	stdsp	sp[0x8],r9
80004c66:	20 38       	sub	r8,3

80004c68 <__dsp16_iir_num_loop_main3>:
80004c68:	50 1b       	stdsp	sp[0x4],r11
80004c6a:	50 0a       	stdsp	sp[0x0],r10
80004c6c:	40 29       	lddsp	r9,sp[0x8]
80004c6e:	30 00       	mov	r0,0
80004c70:	00 91       	mov	r1,r0
80004c72:	00 92       	mov	r2,r0
80004c74:	00 93       	mov	r3,r0
80004c76:	00 9e       	mov	lr,r0

80004c78 <__dsp16_iir_num_loop_tap3>:
80004c78:	f0 0e 19 00 	cp.h	lr,r8
80004c7c:	c2 b4       	brge	80004cd2 <__dsp16_iir_num_endloop_tap3>
80004c7e:	b3 14       	ld.d	r4,--r9
80004c80:	f3 d5 10 04 	ldins.h	r5:t,r9[8]
80004c84:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
80004c88:	ea 07 04 b3 	machh.w	r3,r5:t,r7:t
80004c8c:	e8 07 04 83 	machh.w	r3,r4:b,r7:b
80004c90:	e8 06 04 b3 	machh.w	r3,r4:t,r6:t
80004c94:	ea 06 04 83 	machh.w	r3,r5:b,r6:b
80004c98:	2f ce       	sub	lr,-4
80004c9a:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004c9e:	ea 07 04 a2 	machh.w	r2,r5:t,r7:b
80004ca2:	e8 06 04 92 	machh.w	r2,r4:b,r6:t
80004ca6:	e8 06 04 a2 	machh.w	r2,r4:t,r6:b
80004caa:	ea 0b 04 92 	machh.w	r2,r5:b,r11:t
80004cae:	ea 06 04 b1 	machh.w	r1,r5:t,r6:t
80004cb2:	e8 06 04 81 	machh.w	r1,r4:b,r6:b
80004cb6:	e8 0b 04 b1 	machh.w	r1,r4:t,r11:t
80004cba:	ea 0b 04 81 	machh.w	r1,r5:b,r11:b
80004cbe:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004cc2:	e8 0b 04 90 	machh.w	r0,r4:b,r11:t
80004cc6:	e8 0b 04 a0 	machh.w	r0,r4:t,r11:b
80004cca:	ea 0a 04 90 	machh.w	r0,r5:b,r10:t
80004cce:	fe 9f ff d5 	bral	80004c78 <__dsp16_iir_num_loop_tap3>

80004cd2 <__dsp16_iir_num_endloop_tap3>:
80004cd2:	f8 0e 02 1a 	ld.d	r10,r12[lr<<0x1]
80004cd6:	20 49       	sub	r9,4
80004cd8:	b3 04       	ld.d	r4,r9
80004cda:	2f ce       	sub	lr,-4
80004cdc:	f8 0e 03 16 	ld.w	r6,r12[lr<<0x1]
80004ce0:	e8 0b 04 b3 	machh.w	r3,r4:t,r11:t
80004ce4:	ea 0b 04 83 	machh.w	r3,r5:b,r11:b
80004ce8:	ea 0a 04 b3 	machh.w	r3,r5:t,r10:t
80004cec:	e8 0b 04 a2 	machh.w	r2,r4:t,r11:b
80004cf0:	ea 0a 04 92 	machh.w	r2,r5:b,r10:t
80004cf4:	ea 0a 04 a2 	machh.w	r2,r5:t,r10:b
80004cf8:	e8 0a 04 b1 	machh.w	r1,r4:t,r10:t
80004cfc:	ea 0a 04 81 	machh.w	r1,r5:b,r10:b
80004d00:	ea 06 04 b1 	machh.w	r1,r5:t,r6:t
80004d04:	e8 0a 04 a0 	machh.w	r0,r4:t,r10:b
80004d08:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80004d0c:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004d10:	40 c4       	lddsp	r4,sp[0x30]
80004d12:	e6 04 08 43 	asr	r3,r3,r4
80004d16:	e4 04 08 42 	asr	r2,r2,r4
80004d1a:	e2 04 08 41 	asr	r1,r1,r4
80004d1e:	e0 04 08 40 	asr	r0,r0,r4
80004d22:	40 1b       	lddsp	r11,sp[0x4]
80004d24:	e7 e2 c0 0b 	sthh.w	r11[0x0],r3:b,r2:b
80004d28:	e3 e0 c0 1b 	sthh.w	r11[0x4],r1:b,r0:b
80004d2c:	2f 8b       	sub	r11,-8
80004d2e:	2f 8c       	sub	r12,-8
80004d30:	40 0a       	lddsp	r10,sp[0x0]
80004d32:	20 4a       	sub	r10,4
80004d34:	fe 99 ff 9a 	brgt	80004c68 <__dsp16_iir_num_loop_main3>
80004d38:	2f dd       	sub	sp,-12
80004d3a:	d8 32       	popm	r0-r7,pc

80004d3c <dsp16_filt_iir_kernel_den_x0>:
80004d3c:	d4 31       	pushm	r0-r7,lr
80004d3e:	20 3d       	sub	sp,12
80004d40:	16 91       	mov	r1,r11
80004d42:	18 9b       	mov	r11,r12
80004d44:	02 9c       	mov	r12,r1
80004d46:	40 c1       	lddsp	r1,sp[0x30]
80004d48:	e2 01 11 0f 	rsub	r1,r1,15
80004d4c:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004d50:	50 29       	stdsp	sp[0x8],r9
80004d52:	20 78       	sub	r8,7

80004d54 <__dsp16_iir_den_loop_main0>:
80004d54:	50 1b       	stdsp	sp[0x4],r11
80004d56:	50 0a       	stdsp	sp[0x0],r10
80004d58:	40 29       	lddsp	r9,sp[0x8]
80004d5a:	30 00       	mov	r0,0
80004d5c:	00 9e       	mov	lr,r0

80004d5e <__dsp16_iir_den_loop_tap0>:
80004d5e:	f0 0e 19 00 	cp.h	lr,r8
80004d62:	c1 f4       	brge	80004da0 <__dsp16_iir_den_endloop_tap0>
80004d64:	21 09       	sub	r9,16
80004d66:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80004d6a:	f2 e4 00 08 	ld.d	r4,r9[8]
80004d6e:	e4 e6 00 00 	ld.d	r6,r2[0]
80004d72:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80004d76:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80004d7a:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80004d7e:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004d82:	f2 e4 00 00 	ld.d	r4,r9[0]
80004d86:	e4 e6 00 08 	ld.d	r6,r2[8]
80004d8a:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80004d8e:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80004d92:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80004d96:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004d9a:	2f 8e       	sub	lr,-8
80004d9c:	fe 9f ff e1 	bral	80004d5e <__dsp16_iir_den_loop_tap0>

80004da0 <__dsp16_iir_den_endloop_tap0>:
80004da0:	e0 01 08 40 	asr	r0,r0,r1
80004da4:	40 1b       	lddsp	r11,sp[0x4]
80004da6:	96 02       	ld.sh	r2,r11[0x0]
80004da8:	00 12       	sub	r2,r0
80004daa:	16 b2       	st.h	r11++,r2
80004dac:	50 1b       	stdsp	sp[0x4],r11
80004dae:	40 29       	lddsp	r9,sp[0x8]
80004db0:	30 00       	mov	r0,0
80004db2:	00 9e       	mov	lr,r0

80004db4 <__dsp16_iir_den_loop_tap_bis0>:
80004db4:	f0 0e 19 00 	cp.h	lr,r8
80004db8:	c2 14       	brge	80004dfa <__dsp16_iir_den_endloop_tap_bis0>
80004dba:	21 09       	sub	r9,16
80004dbc:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80004dc0:	f2 e4 00 08 	ld.d	r4,r9[8]
80004dc4:	e4 e6 00 00 	ld.d	r6,r2[0]
80004dc8:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004dcc:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004dd0:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004dd4:	e4 e6 00 08 	ld.d	r6,r2[8]
80004dd8:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
80004ddc:	f2 e4 00 00 	ld.d	r4,r9[0]
80004de0:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004de4:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004de8:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004dec:	e5 16 00 10 	ld.uh	r6,r2[16]
80004df0:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004df4:	2f 8e       	sub	lr,-8
80004df6:	fe 9f ff df 	bral	80004db4 <__dsp16_iir_den_loop_tap_bis0>

80004dfa <__dsp16_iir_den_endloop_tap_bis0>:
80004dfa:	e0 01 08 40 	asr	r0,r0,r1
80004dfe:	40 1b       	lddsp	r11,sp[0x4]
80004e00:	96 02       	ld.sh	r2,r11[0x0]
80004e02:	00 12       	sub	r2,r0
80004e04:	16 b2       	st.h	r11++,r2
80004e06:	2f cc       	sub	r12,-4
80004e08:	40 0a       	lddsp	r10,sp[0x0]
80004e0a:	20 2a       	sub	r10,2
80004e0c:	fe 99 ff a4 	brgt	80004d54 <__dsp16_iir_den_loop_main0>
80004e10:	2f dd       	sub	sp,-12
80004e12:	d8 32       	popm	r0-r7,pc

80004e14 <dsp16_filt_iir_kernel_den_x1>:
80004e14:	d4 31       	pushm	r0-r7,lr
80004e16:	20 3d       	sub	sp,12
80004e18:	16 91       	mov	r1,r11
80004e1a:	18 9b       	mov	r11,r12
80004e1c:	02 9c       	mov	r12,r1
80004e1e:	40 c1       	lddsp	r1,sp[0x30]
80004e20:	e2 01 11 0f 	rsub	r1,r1,15
80004e24:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004e28:	50 29       	stdsp	sp[0x8],r9
80004e2a:	20 78       	sub	r8,7

80004e2c <__dsp16_iir_den_loop_main1>:
80004e2c:	50 1b       	stdsp	sp[0x4],r11
80004e2e:	50 0a       	stdsp	sp[0x0],r10
80004e30:	40 29       	lddsp	r9,sp[0x8]
80004e32:	30 00       	mov	r0,0
80004e34:	00 9e       	mov	lr,r0

80004e36 <__dsp16_iir_den_loop_tap1>:
80004e36:	f0 0e 19 00 	cp.h	lr,r8
80004e3a:	c2 24       	brge	80004e7e <__dsp16_iir_den_endloop_tap1>
80004e3c:	21 29       	sub	r9,18
80004e3e:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80004e42:	f3 14 00 10 	ld.uh	r4,r9[16]
80004e46:	e4 e6 00 00 	ld.d	r6,r2[0]
80004e4a:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80004e4e:	f2 e4 00 08 	ld.d	r4,r9[8]
80004e52:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004e56:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004e5a:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004e5e:	e4 e6 00 08 	ld.d	r6,r2[8]
80004e62:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
80004e66:	f2 e4 00 00 	ld.d	r4,r9[0]
80004e6a:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004e6e:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004e72:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004e76:	2f 8e       	sub	lr,-8
80004e78:	2f e9       	sub	r9,-2
80004e7a:	fe 9f ff de 	bral	80004e36 <__dsp16_iir_den_loop_tap1>

80004e7e <__dsp16_iir_den_endloop_tap1>:
80004e7e:	13 64       	ld.uh	r4,--r9
80004e80:	f8 0e 05 16 	ld.uh	r6,r12[lr<<0x1]
80004e84:	e8 06 04 80 	machh.w	r0,r4:b,r6:b
80004e88:	e0 01 08 40 	asr	r0,r0,r1
80004e8c:	40 1b       	lddsp	r11,sp[0x4]
80004e8e:	96 02       	ld.sh	r2,r11[0x0]
80004e90:	00 12       	sub	r2,r0
80004e92:	16 b2       	st.h	r11++,r2
80004e94:	50 1b       	stdsp	sp[0x4],r11
80004e96:	40 29       	lddsp	r9,sp[0x8]
80004e98:	30 00       	mov	r0,0
80004e9a:	00 9e       	mov	lr,r0

80004e9c <__dsp16_iir_den_loop_tap_bis1>:
80004e9c:	f0 0e 19 00 	cp.h	lr,r8
80004ea0:	c2 44       	brge	80004ee8 <__dsp16_iir_den_endloop_tap_bis1>
80004ea2:	21 29       	sub	r9,18
80004ea4:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80004ea8:	f3 14 00 10 	ld.uh	r4,r9[16]
80004eac:	e4 e6 00 00 	ld.d	r6,r2[0]
80004eb0:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004eb4:	f2 e4 00 08 	ld.d	r4,r9[8]
80004eb8:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
80004ebc:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
80004ec0:	e4 e6 00 08 	ld.d	r6,r2[8]
80004ec4:	ea 07 04 90 	machh.w	r0,r5:b,r7:t
80004ec8:	ea 07 04 a0 	machh.w	r0,r5:t,r7:b
80004ecc:	f2 e4 00 00 	ld.d	r4,r9[0]
80004ed0:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
80004ed4:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
80004ed8:	e5 16 00 10 	ld.uh	r6,r2[16]
80004edc:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004ee0:	2f 8e       	sub	lr,-8
80004ee2:	2f e9       	sub	r9,-2
80004ee4:	fe 9f ff dc 	bral	80004e9c <__dsp16_iir_den_loop_tap_bis1>

80004ee8 <__dsp16_iir_den_endloop_tap_bis1>:
80004ee8:	13 64       	ld.uh	r4,--r9
80004eea:	f8 0e 03 16 	ld.w	r6,r12[lr<<0x1]
80004eee:	e8 06 04 80 	machh.w	r0,r4:b,r6:b
80004ef2:	e0 01 08 40 	asr	r0,r0,r1
80004ef6:	40 1b       	lddsp	r11,sp[0x4]
80004ef8:	96 02       	ld.sh	r2,r11[0x0]
80004efa:	00 12       	sub	r2,r0
80004efc:	16 b2       	st.h	r11++,r2
80004efe:	2f cc       	sub	r12,-4
80004f00:	40 0a       	lddsp	r10,sp[0x0]
80004f02:	20 2a       	sub	r10,2
80004f04:	fe 99 ff 94 	brgt	80004e2c <__dsp16_iir_den_loop_main1>
80004f08:	2f dd       	sub	sp,-12
80004f0a:	d8 32       	popm	r0-r7,pc

80004f0c <dsp16_filt_iir_kernel_den_x2>:
80004f0c:	d4 31       	pushm	r0-r7,lr
80004f0e:	20 3d       	sub	sp,12
80004f10:	16 91       	mov	r1,r11
80004f12:	18 9b       	mov	r11,r12
80004f14:	02 9c       	mov	r12,r1
80004f16:	40 c1       	lddsp	r1,sp[0x30]
80004f18:	e2 01 11 0f 	rsub	r1,r1,15
80004f1c:	f2 08 00 19 	add	r9,r9,r8<<0x1
80004f20:	50 29       	stdsp	sp[0x8],r9
80004f22:	20 78       	sub	r8,7

80004f24 <__dsp16_iir_den_loop_main2>:
80004f24:	50 1b       	stdsp	sp[0x4],r11
80004f26:	50 0a       	stdsp	sp[0x0],r10
80004f28:	40 29       	lddsp	r9,sp[0x8]
80004f2a:	30 00       	mov	r0,0
80004f2c:	00 9e       	mov	lr,r0

80004f2e <__dsp16_iir_den_loop_tap2>:
80004f2e:	f0 0e 19 00 	cp.h	lr,r8
80004f32:	c1 f4       	brge	80004f70 <__dsp16_iir_den_endloop_tap2>
80004f34:	21 09       	sub	r9,16
80004f36:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80004f3a:	f2 e4 00 08 	ld.d	r4,r9[8]
80004f3e:	e4 e6 00 00 	ld.d	r6,r2[0]
80004f42:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80004f46:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80004f4a:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80004f4e:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004f52:	f2 e4 00 00 	ld.d	r4,r9[0]
80004f56:	e4 e6 00 08 	ld.d	r6,r2[8]
80004f5a:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80004f5e:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80004f62:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80004f66:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004f6a:	2f 8e       	sub	lr,-8
80004f6c:	fe 9f ff e1 	bral	80004f2e <__dsp16_iir_den_loop_tap2>

80004f70 <__dsp16_iir_den_endloop_tap2>:
80004f70:	13 44       	ld.w	r4,--r9
80004f72:	f8 0e 03 16 	ld.w	r6,r12[lr<<0x1]
80004f76:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
80004f7a:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
80004f7e:	e0 01 08 40 	asr	r0,r0,r1
80004f82:	40 1b       	lddsp	r11,sp[0x4]
80004f84:	96 02       	ld.sh	r2,r11[0x0]
80004f86:	00 12       	sub	r2,r0
80004f88:	16 b2       	st.h	r11++,r2
80004f8a:	50 1b       	stdsp	sp[0x4],r11
80004f8c:	40 29       	lddsp	r9,sp[0x8]
80004f8e:	30 00       	mov	r0,0
80004f90:	00 9e       	mov	lr,r0

80004f92 <__dsp16_iir_den_loop_tap_bis2>:
80004f92:	f0 0e 19 00 	cp.h	lr,r8
80004f96:	c2 14       	brge	80004fd8 <__dsp16_iir_den_endloop_tap_bis2>
80004f98:	21 09       	sub	r9,16
80004f9a:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80004f9e:	f2 e4 00 08 	ld.d	r4,r9[8]
80004fa2:	e4 e6 00 00 	ld.d	r6,r2[0]
80004fa6:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004faa:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004fae:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004fb2:	e4 e6 00 08 	ld.d	r6,r2[8]
80004fb6:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
80004fba:	f2 e4 00 00 	ld.d	r4,r9[0]
80004fbe:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004fc2:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004fc6:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80004fca:	e5 16 00 10 	ld.uh	r6,r2[16]
80004fce:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80004fd2:	2f 8e       	sub	lr,-8
80004fd4:	fe 9f ff df 	bral	80004f92 <__dsp16_iir_den_loop_tap_bis2>

80004fd8 <__dsp16_iir_den_endloop_tap_bis2>:
80004fd8:	13 44       	ld.w	r4,--r9
80004fda:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
80004fde:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80004fe2:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80004fe6:	e0 01 08 40 	asr	r0,r0,r1
80004fea:	40 1b       	lddsp	r11,sp[0x4]
80004fec:	96 02       	ld.sh	r2,r11[0x0]
80004fee:	00 12       	sub	r2,r0
80004ff0:	16 b2       	st.h	r11++,r2
80004ff2:	2f cc       	sub	r12,-4
80004ff4:	40 0a       	lddsp	r10,sp[0x0]
80004ff6:	20 2a       	sub	r10,2
80004ff8:	fe 99 ff 96 	brgt	80004f24 <__dsp16_iir_den_loop_main2>
80004ffc:	2f dd       	sub	sp,-12
80004ffe:	d8 32       	popm	r0-r7,pc

80005000 <dsp16_filt_iir_kernel_den_x3>:
80005000:	d4 31       	pushm	r0-r7,lr
80005002:	20 3d       	sub	sp,12
80005004:	16 91       	mov	r1,r11
80005006:	18 9b       	mov	r11,r12
80005008:	02 9c       	mov	r12,r1
8000500a:	40 c1       	lddsp	r1,sp[0x30]
8000500c:	e2 01 11 0f 	rsub	r1,r1,15
80005010:	f2 08 00 19 	add	r9,r9,r8<<0x1
80005014:	50 29       	stdsp	sp[0x8],r9
80005016:	20 78       	sub	r8,7

80005018 <__dsp16_iir_den_loop_main3>:
80005018:	50 1b       	stdsp	sp[0x4],r11
8000501a:	50 0a       	stdsp	sp[0x0],r10
8000501c:	40 29       	lddsp	r9,sp[0x8]
8000501e:	30 00       	mov	r0,0
80005020:	00 9e       	mov	lr,r0

80005022 <__dsp16_iir_den_loop_tap3>:
80005022:	f0 0e 19 00 	cp.h	lr,r8
80005026:	c2 24       	brge	8000506a <__dsp16_iir_den_endloop_tap3>
80005028:	21 29       	sub	r9,18
8000502a:	f8 0e 00 12 	add	r2,r12,lr<<0x1
8000502e:	f3 14 00 10 	ld.uh	r4,r9[16]
80005032:	e4 e6 00 00 	ld.d	r6,r2[0]
80005036:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
8000503a:	f2 e4 00 08 	ld.d	r4,r9[8]
8000503e:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80005042:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80005046:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
8000504a:	e4 e6 00 08 	ld.d	r6,r2[8]
8000504e:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
80005052:	f2 e4 00 00 	ld.d	r4,r9[0]
80005056:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
8000505a:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
8000505e:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005062:	2f 8e       	sub	lr,-8
80005064:	2f e9       	sub	r9,-2
80005066:	fe 9f ff de 	bral	80005022 <__dsp16_iir_den_loop_tap3>

8000506a <__dsp16_iir_den_endloop_tap3>:
8000506a:	20 69       	sub	r9,6
8000506c:	f2 e4 00 00 	ld.d	r4,r9[0]
80005070:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
80005074:	e8 07 04 b0 	machh.w	r0,r4:t,r7:t
80005078:	ea 07 04 80 	machh.w	r0,r5:b,r7:b
8000507c:	ea 06 04 b0 	machh.w	r0,r5:t,r6:t
80005080:	e0 01 08 40 	asr	r0,r0,r1
80005084:	40 1b       	lddsp	r11,sp[0x4]
80005086:	96 02       	ld.sh	r2,r11[0x0]
80005088:	00 12       	sub	r2,r0
8000508a:	16 b2       	st.h	r11++,r2
8000508c:	50 1b       	stdsp	sp[0x4],r11
8000508e:	40 29       	lddsp	r9,sp[0x8]
80005090:	30 00       	mov	r0,0
80005092:	00 9e       	mov	lr,r0

80005094 <__dsp16_iir_den_loop_tap_bis3>:
80005094:	f0 0e 19 00 	cp.h	lr,r8
80005098:	c2 44       	brge	800050e0 <__dsp16_iir_den_endloop_tap_bis3>
8000509a:	21 29       	sub	r9,18
8000509c:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800050a0:	f3 14 00 10 	ld.uh	r4,r9[16]
800050a4:	e4 e6 00 00 	ld.d	r6,r2[0]
800050a8:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800050ac:	f2 e4 00 08 	ld.d	r4,r9[8]
800050b0:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
800050b4:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
800050b8:	e4 e6 00 08 	ld.d	r6,r2[8]
800050bc:	ea 07 04 90 	machh.w	r0,r5:b,r7:t
800050c0:	ea 07 04 a0 	machh.w	r0,r5:t,r7:b
800050c4:	f2 e4 00 00 	ld.d	r4,r9[0]
800050c8:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
800050cc:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
800050d0:	e5 16 00 10 	ld.uh	r6,r2[16]
800050d4:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
800050d8:	2f 8e       	sub	lr,-8
800050da:	2f e9       	sub	r9,-2
800050dc:	fe 9f ff dc 	bral	80005094 <__dsp16_iir_den_loop_tap_bis3>

800050e0 <__dsp16_iir_den_endloop_tap_bis3>:
800050e0:	20 69       	sub	r9,6
800050e2:	f2 e4 00 00 	ld.d	r4,r9[0]
800050e6:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
800050ea:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
800050ee:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
800050f2:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
800050f6:	e0 01 08 40 	asr	r0,r0,r1
800050fa:	40 1b       	lddsp	r11,sp[0x4]
800050fc:	96 02       	ld.sh	r2,r11[0x0]
800050fe:	00 12       	sub	r2,r0
80005100:	16 b2       	st.h	r11++,r2
80005102:	2f cc       	sub	r12,-4
80005104:	40 0a       	lddsp	r10,sp[0x0]
80005106:	20 2a       	sub	r10,2
80005108:	fe 99 ff 88 	brgt	80005018 <__dsp16_iir_den_loop_main3>
8000510c:	2f dd       	sub	sp,-12
8000510e:	d8 32       	popm	r0-r7,pc

80005110 <dsp16_filt_iir_kernel_den_x4>:
80005110:	d4 31       	pushm	r0-r7,lr
80005112:	20 3d       	sub	sp,12
80005114:	16 91       	mov	r1,r11
80005116:	18 9b       	mov	r11,r12
80005118:	02 9c       	mov	r12,r1
8000511a:	40 c1       	lddsp	r1,sp[0x30]
8000511c:	e2 01 11 0f 	rsub	r1,r1,15
80005120:	f2 08 00 19 	add	r9,r9,r8<<0x1
80005124:	50 29       	stdsp	sp[0x8],r9
80005126:	20 78       	sub	r8,7

80005128 <__dsp16_iir_den_loop_main4>:
80005128:	50 1b       	stdsp	sp[0x4],r11
8000512a:	50 0a       	stdsp	sp[0x0],r10
8000512c:	40 29       	lddsp	r9,sp[0x8]
8000512e:	30 00       	mov	r0,0
80005130:	00 9e       	mov	lr,r0

80005132 <__dsp16_iir_den_loop_tap4>:
80005132:	f0 0e 19 00 	cp.h	lr,r8
80005136:	c1 f4       	brge	80005174 <__dsp16_iir_den_endloop_tap4>
80005138:	21 09       	sub	r9,16
8000513a:	f8 0e 00 12 	add	r2,r12,lr<<0x1
8000513e:	f2 e4 00 08 	ld.d	r4,r9[8]
80005142:	e4 e6 00 00 	ld.d	r6,r2[0]
80005146:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
8000514a:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
8000514e:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80005152:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80005156:	f2 e4 00 00 	ld.d	r4,r9[0]
8000515a:	e4 e6 00 08 	ld.d	r6,r2[8]
8000515e:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80005162:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80005166:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
8000516a:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
8000516e:	2f 8e       	sub	lr,-8
80005170:	fe 9f ff e1 	bral	80005132 <__dsp16_iir_den_loop_tap4>

80005174 <__dsp16_iir_den_endloop_tap4>:
80005174:	b3 14       	ld.d	r4,--r9
80005176:	f8 0e 02 16 	ld.d	r6,r12[lr<<0x1]
8000517a:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
8000517e:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80005182:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80005186:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
8000518a:	e0 01 08 40 	asr	r0,r0,r1
8000518e:	40 1b       	lddsp	r11,sp[0x4]
80005190:	96 02       	ld.sh	r2,r11[0x0]
80005192:	00 12       	sub	r2,r0
80005194:	16 b2       	st.h	r11++,r2
80005196:	50 1b       	stdsp	sp[0x4],r11
80005198:	40 29       	lddsp	r9,sp[0x8]
8000519a:	30 00       	mov	r0,0
8000519c:	00 9e       	mov	lr,r0

8000519e <__dsp16_iir_den_loop_tap_bis4>:
8000519e:	f0 0e 19 00 	cp.h	lr,r8
800051a2:	c2 14       	brge	800051e4 <__dsp16_iir_den_endloop_tap_bis4>
800051a4:	21 09       	sub	r9,16
800051a6:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800051aa:	f2 e4 00 08 	ld.d	r4,r9[8]
800051ae:	e4 e6 00 00 	ld.d	r6,r2[0]
800051b2:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800051b6:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
800051ba:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
800051be:	e4 e6 00 08 	ld.d	r6,r2[8]
800051c2:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
800051c6:	f2 e4 00 00 	ld.d	r4,r9[0]
800051ca:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800051ce:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
800051d2:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
800051d6:	e5 16 00 10 	ld.uh	r6,r2[16]
800051da:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
800051de:	2f 8e       	sub	lr,-8
800051e0:	fe 9f ff df 	bral	8000519e <__dsp16_iir_den_loop_tap_bis4>

800051e4 <__dsp16_iir_den_endloop_tap_bis4>:
800051e4:	b3 14       	ld.d	r4,--r9
800051e6:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800051ea:	e4 e6 00 00 	ld.d	r6,r2[0]
800051ee:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800051f2:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
800051f6:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
800051fa:	84 c6       	ld.uh	r6,r2[0x8]
800051fc:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80005200:	e0 01 08 40 	asr	r0,r0,r1
80005204:	40 1b       	lddsp	r11,sp[0x4]
80005206:	96 02       	ld.sh	r2,r11[0x0]
80005208:	00 12       	sub	r2,r0
8000520a:	16 b2       	st.h	r11++,r2
8000520c:	2f cc       	sub	r12,-4
8000520e:	40 0a       	lddsp	r10,sp[0x0]
80005210:	20 2a       	sub	r10,2
80005212:	fe 99 ff 8b 	brgt	80005128 <__dsp16_iir_den_loop_main4>
80005216:	2f dd       	sub	sp,-12
80005218:	d8 32       	popm	r0-r7,pc

8000521a <dsp16_filt_iir_kernel_den_x5>:
8000521a:	d4 31       	pushm	r0-r7,lr
8000521c:	20 3d       	sub	sp,12
8000521e:	16 91       	mov	r1,r11
80005220:	18 9b       	mov	r11,r12
80005222:	02 9c       	mov	r12,r1
80005224:	40 c1       	lddsp	r1,sp[0x30]
80005226:	e2 01 11 0f 	rsub	r1,r1,15
8000522a:	f2 08 00 19 	add	r9,r9,r8<<0x1
8000522e:	50 29       	stdsp	sp[0x8],r9
80005230:	20 78       	sub	r8,7

80005232 <__dsp16_iir_den_loop_main5>:
80005232:	50 1b       	stdsp	sp[0x4],r11
80005234:	50 0a       	stdsp	sp[0x0],r10
80005236:	40 29       	lddsp	r9,sp[0x8]
80005238:	30 00       	mov	r0,0
8000523a:	00 9e       	mov	lr,r0

8000523c <__dsp16_iir_den_loop_tap5>:
8000523c:	f0 0e 19 00 	cp.h	lr,r8
80005240:	c2 24       	brge	80005284 <__dsp16_iir_den_endloop_tap5>
80005242:	21 29       	sub	r9,18
80005244:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80005248:	f3 14 00 10 	ld.uh	r4,r9[16]
8000524c:	e4 e6 00 00 	ld.d	r6,r2[0]
80005250:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80005254:	f2 e4 00 08 	ld.d	r4,r9[8]
80005258:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
8000525c:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80005260:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005264:	e4 e6 00 08 	ld.d	r6,r2[8]
80005268:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
8000526c:	f2 e4 00 00 	ld.d	r4,r9[0]
80005270:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80005274:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80005278:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
8000527c:	2f 8e       	sub	lr,-8
8000527e:	2f e9       	sub	r9,-2
80005280:	fe 9f ff de 	bral	8000523c <__dsp16_iir_den_loop_tap5>

80005284 <__dsp16_iir_den_endloop_tap5>:
80005284:	20 a9       	sub	r9,10
80005286:	f2 e4 00 04 	ld.d	r4,r9[4]
8000528a:	f8 0e 00 12 	add	r2,r12,lr<<0x1
8000528e:	e4 e6 00 00 	ld.d	r6,r2[0]
80005292:	e8 07 04 b0 	machh.w	r0,r4:t,r7:t
80005296:	ea 07 04 80 	machh.w	r0,r5:b,r7:b
8000529a:	ea 06 04 b0 	machh.w	r0,r5:t,r6:t
8000529e:	72 04       	ld.w	r4,r9[0x0]
800052a0:	e8 06 04 80 	machh.w	r0,r4:b,r6:b
800052a4:	84 c6       	ld.uh	r6,r2[0x8]
800052a6:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
800052aa:	e0 01 08 40 	asr	r0,r0,r1
800052ae:	40 1b       	lddsp	r11,sp[0x4]
800052b0:	96 02       	ld.sh	r2,r11[0x0]
800052b2:	00 12       	sub	r2,r0
800052b4:	16 b2       	st.h	r11++,r2
800052b6:	50 1b       	stdsp	sp[0x4],r11
800052b8:	40 29       	lddsp	r9,sp[0x8]
800052ba:	30 00       	mov	r0,0
800052bc:	00 9e       	mov	lr,r0

800052be <__dsp16_iir_den_loop_tap_bis5>:
800052be:	f0 0e 19 00 	cp.h	lr,r8
800052c2:	c2 44       	brge	8000530a <__dsp16_iir_den_endloop_tap_bis5>
800052c4:	21 29       	sub	r9,18
800052c6:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800052ca:	f3 14 00 10 	ld.uh	r4,r9[16]
800052ce:	e4 e6 00 00 	ld.d	r6,r2[0]
800052d2:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800052d6:	f2 e4 00 08 	ld.d	r4,r9[8]
800052da:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
800052de:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
800052e2:	e4 e6 00 08 	ld.d	r6,r2[8]
800052e6:	ea 07 04 90 	machh.w	r0,r5:b,r7:t
800052ea:	ea 07 04 a0 	machh.w	r0,r5:t,r7:b
800052ee:	f2 e4 00 00 	ld.d	r4,r9[0]
800052f2:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
800052f6:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
800052fa:	e5 16 00 10 	ld.uh	r6,r2[16]
800052fe:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005302:	2f 8e       	sub	lr,-8
80005304:	2f e9       	sub	r9,-2
80005306:	fe 9f ff dc 	bral	800052be <__dsp16_iir_den_loop_tap_bis5>

8000530a <__dsp16_iir_den_endloop_tap_bis5>:
8000530a:	20 a9       	sub	r9,10
8000530c:	f2 e4 00 04 	ld.d	r4,r9[4]
80005310:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80005314:	e4 e6 00 00 	ld.d	r6,r2[0]
80005318:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
8000531c:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80005320:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80005324:	72 04       	ld.w	r4,r9[0x0]
80005326:	64 26       	ld.w	r6,r2[0x8]
80005328:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
8000532c:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
80005330:	e0 01 08 40 	asr	r0,r0,r1
80005334:	40 1b       	lddsp	r11,sp[0x4]
80005336:	96 02       	ld.sh	r2,r11[0x0]
80005338:	00 12       	sub	r2,r0
8000533a:	16 b2       	st.h	r11++,r2
8000533c:	2f cc       	sub	r12,-4
8000533e:	40 0a       	lddsp	r10,sp[0x0]
80005340:	20 2a       	sub	r10,2
80005342:	fe 99 ff 78 	brgt	80005232 <__dsp16_iir_den_loop_main5>
80005346:	2f dd       	sub	sp,-12
80005348:	d8 32       	popm	r0-r7,pc

8000534a <dsp16_filt_iir_kernel_den_x6>:
8000534a:	d4 31       	pushm	r0-r7,lr
8000534c:	20 3d       	sub	sp,12
8000534e:	16 91       	mov	r1,r11
80005350:	18 9b       	mov	r11,r12
80005352:	02 9c       	mov	r12,r1
80005354:	40 c1       	lddsp	r1,sp[0x30]
80005356:	e2 01 11 0f 	rsub	r1,r1,15
8000535a:	f2 08 00 19 	add	r9,r9,r8<<0x1
8000535e:	50 29       	stdsp	sp[0x8],r9
80005360:	20 78       	sub	r8,7

80005362 <__dsp16_iir_den_loop_main6>:
80005362:	50 1b       	stdsp	sp[0x4],r11
80005364:	50 0a       	stdsp	sp[0x0],r10
80005366:	40 29       	lddsp	r9,sp[0x8]
80005368:	30 00       	mov	r0,0
8000536a:	00 9e       	mov	lr,r0

8000536c <__dsp16_iir_den_loop_tap6>:
8000536c:	f0 0e 19 00 	cp.h	lr,r8
80005370:	c1 f4       	brge	800053ae <__dsp16_iir_den_endloop_tap6>
80005372:	21 09       	sub	r9,16
80005374:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80005378:	f2 e4 00 08 	ld.d	r4,r9[8]
8000537c:	e4 e6 00 00 	ld.d	r6,r2[0]
80005380:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80005384:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80005388:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
8000538c:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80005390:	f2 e4 00 00 	ld.d	r4,r9[0]
80005394:	e4 e6 00 08 	ld.d	r6,r2[8]
80005398:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
8000539c:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
800053a0:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
800053a4:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
800053a8:	2f 8e       	sub	lr,-8
800053aa:	fe 9f ff e1 	bral	8000536c <__dsp16_iir_den_loop_tap6>

800053ae <__dsp16_iir_den_endloop_tap6>:
800053ae:	b3 14       	ld.d	r4,--r9
800053b0:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800053b4:	e4 e6 00 00 	ld.d	r6,r2[0]
800053b8:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
800053bc:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
800053c0:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
800053c4:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
800053c8:	13 44       	ld.w	r4,--r9
800053ca:	64 26       	ld.w	r6,r2[0x8]
800053cc:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
800053d0:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
800053d4:	e0 01 08 40 	asr	r0,r0,r1
800053d8:	40 1b       	lddsp	r11,sp[0x4]
800053da:	96 02       	ld.sh	r2,r11[0x0]
800053dc:	00 12       	sub	r2,r0
800053de:	16 b2       	st.h	r11++,r2
800053e0:	50 1b       	stdsp	sp[0x4],r11
800053e2:	40 29       	lddsp	r9,sp[0x8]
800053e4:	30 00       	mov	r0,0
800053e6:	00 9e       	mov	lr,r0

800053e8 <__dsp16_iir_den_loop_tap_bis6>:
800053e8:	f0 0e 19 00 	cp.h	lr,r8
800053ec:	c2 14       	brge	8000542e <__dsp16_iir_den_endloop_tap_bis6>
800053ee:	21 09       	sub	r9,16
800053f0:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800053f4:	f2 e4 00 08 	ld.d	r4,r9[8]
800053f8:	e4 e6 00 00 	ld.d	r6,r2[0]
800053fc:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80005400:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80005404:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005408:	e4 e6 00 08 	ld.d	r6,r2[8]
8000540c:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
80005410:	f2 e4 00 00 	ld.d	r4,r9[0]
80005414:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80005418:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
8000541c:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005420:	e5 16 00 10 	ld.uh	r6,r2[16]
80005424:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80005428:	2f 8e       	sub	lr,-8
8000542a:	fe 9f ff df 	bral	800053e8 <__dsp16_iir_den_loop_tap_bis6>

8000542e <__dsp16_iir_den_endloop_tap_bis6>:
8000542e:	b3 14       	ld.d	r4,--r9
80005430:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80005434:	e4 e6 00 00 	ld.d	r6,r2[0]
80005438:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
8000543c:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80005440:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005444:	e4 e6 00 08 	ld.d	r6,r2[8]
80005448:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
8000544c:	13 44       	ld.w	r4,--r9
8000544e:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80005452:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
80005456:	e0 01 08 40 	asr	r0,r0,r1
8000545a:	40 1b       	lddsp	r11,sp[0x4]
8000545c:	96 02       	ld.sh	r2,r11[0x0]
8000545e:	00 12       	sub	r2,r0
80005460:	16 b2       	st.h	r11++,r2
80005462:	2f cc       	sub	r12,-4
80005464:	40 0a       	lddsp	r10,sp[0x0]
80005466:	20 2a       	sub	r10,2
80005468:	fe 99 ff 7d 	brgt	80005362 <__dsp16_iir_den_loop_main6>
8000546c:	2f dd       	sub	sp,-12
8000546e:	d8 32       	popm	r0-r7,pc

80005470 <dsp16_filt_iir_kernel_den_x7>:
80005470:	d4 31       	pushm	r0-r7,lr
80005472:	20 3d       	sub	sp,12
80005474:	16 91       	mov	r1,r11
80005476:	18 9b       	mov	r11,r12
80005478:	02 9c       	mov	r12,r1
8000547a:	40 c1       	lddsp	r1,sp[0x30]
8000547c:	e2 01 11 0f 	rsub	r1,r1,15
80005480:	f2 08 00 19 	add	r9,r9,r8<<0x1
80005484:	50 29       	stdsp	sp[0x8],r9
80005486:	20 78       	sub	r8,7

80005488 <__dsp16_iir_den_loop_main7>:
80005488:	50 1b       	stdsp	sp[0x4],r11
8000548a:	50 0a       	stdsp	sp[0x0],r10
8000548c:	40 29       	lddsp	r9,sp[0x8]
8000548e:	30 00       	mov	r0,0
80005490:	00 9e       	mov	lr,r0

80005492 <__dsp16_iir_den_loop_tap7>:
80005492:	f0 0e 19 00 	cp.h	lr,r8
80005496:	c2 24       	brge	800054da <__dsp16_iir_den_endloop_tap7>
80005498:	21 29       	sub	r9,18
8000549a:	f8 0e 00 12 	add	r2,r12,lr<<0x1
8000549e:	f3 14 00 10 	ld.uh	r4,r9[16]
800054a2:	e4 e6 00 00 	ld.d	r6,r2[0]
800054a6:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
800054aa:	f2 e4 00 08 	ld.d	r4,r9[8]
800054ae:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800054b2:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
800054b6:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
800054ba:	e4 e6 00 08 	ld.d	r6,r2[8]
800054be:	ea 07 04 b0 	machh.w	r0,r5:t,r7:t
800054c2:	f2 e4 00 00 	ld.d	r4,r9[0]
800054c6:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
800054ca:	e8 06 04 b0 	machh.w	r0,r4:t,r6:t
800054ce:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
800054d2:	2f 8e       	sub	lr,-8
800054d4:	2f e9       	sub	r9,-2
800054d6:	fe 9f ff de 	bral	80005492 <__dsp16_iir_den_loop_tap7>

800054da <__dsp16_iir_den_endloop_tap7>:
800054da:	20 e9       	sub	r9,14
800054dc:	f2 e4 00 08 	ld.d	r4,r9[8]
800054e0:	f8 0e 00 12 	add	r2,r12,lr<<0x1
800054e4:	e4 e6 00 00 	ld.d	r6,r2[0]
800054e8:	e8 07 04 b0 	machh.w	r0,r4:t,r7:t
800054ec:	ea 07 04 80 	machh.w	r0,r5:b,r7:b
800054f0:	ea 06 04 b0 	machh.w	r0,r5:t,r6:t
800054f4:	f2 e4 00 00 	ld.d	r4,r9[0]
800054f8:	e8 06 04 80 	machh.w	r0,r4:b,r6:b
800054fc:	e4 e6 00 08 	ld.d	r6,r2[8]
80005500:	e8 07 04 b0 	machh.w	r0,r4:t,r7:t
80005504:	ea 07 04 80 	machh.w	r0,r5:b,r7:b
80005508:	ea 06 04 b0 	machh.w	r0,r5:t,r6:t
8000550c:	e0 01 08 40 	asr	r0,r0,r1
80005510:	40 1b       	lddsp	r11,sp[0x4]
80005512:	96 02       	ld.sh	r2,r11[0x0]
80005514:	00 12       	sub	r2,r0
80005516:	16 b2       	st.h	r11++,r2
80005518:	50 1b       	stdsp	sp[0x4],r11
8000551a:	40 29       	lddsp	r9,sp[0x8]
8000551c:	30 00       	mov	r0,0
8000551e:	00 9e       	mov	lr,r0

80005520 <__dsp16_iir_den_loop_tap_bis7>:
80005520:	f0 0e 19 00 	cp.h	lr,r8
80005524:	c2 44       	brge	8000556c <__dsp16_iir_den_endloop_tap_bis7>
80005526:	21 29       	sub	r9,18
80005528:	f8 0e 00 12 	add	r2,r12,lr<<0x1
8000552c:	f3 14 00 10 	ld.uh	r4,r9[16]
80005530:	e4 e6 00 00 	ld.d	r6,r2[0]
80005534:	e8 07 04 80 	machh.w	r0,r4:b,r7:b
80005538:	f2 e4 00 08 	ld.d	r4,r9[8]
8000553c:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
80005540:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
80005544:	e4 e6 00 08 	ld.d	r6,r2[8]
80005548:	ea 07 04 90 	machh.w	r0,r5:b,r7:t
8000554c:	ea 07 04 a0 	machh.w	r0,r5:t,r7:b
80005550:	f2 e4 00 00 	ld.d	r4,r9[0]
80005554:	e8 06 04 90 	machh.w	r0,r4:b,r6:t
80005558:	e8 06 04 a0 	machh.w	r0,r4:t,r6:b
8000555c:	e5 16 00 10 	ld.uh	r6,r2[16]
80005560:	ea 06 04 80 	machh.w	r0,r5:b,r6:b
80005564:	2f 8e       	sub	lr,-8
80005566:	2f e9       	sub	r9,-2
80005568:	fe 9f ff dc 	bral	80005520 <__dsp16_iir_den_loop_tap_bis7>

8000556c <__dsp16_iir_den_endloop_tap_bis7>:
8000556c:	20 e9       	sub	r9,14
8000556e:	f2 e4 00 08 	ld.d	r4,r9[8]
80005572:	f8 0e 00 12 	add	r2,r12,lr<<0x1
80005576:	e4 e6 00 00 	ld.d	r6,r2[0]
8000557a:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
8000557e:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
80005582:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
80005586:	f2 e4 00 00 	ld.d	r4,r9[0]
8000558a:	e4 e6 00 08 	ld.d	r6,r2[8]
8000558e:	e8 07 04 90 	machh.w	r0,r4:b,r7:t
80005592:	e8 07 04 a0 	machh.w	r0,r4:t,r7:b
80005596:	ea 06 04 90 	machh.w	r0,r5:b,r6:t
8000559a:	ea 06 04 a0 	machh.w	r0,r5:t,r6:b
8000559e:	e0 01 08 40 	asr	r0,r0,r1
800055a2:	40 1b       	lddsp	r11,sp[0x4]
800055a4:	96 02       	ld.sh	r2,r11[0x0]
800055a6:	00 12       	sub	r2,r0
800055a8:	16 b2       	st.h	r11++,r2
800055aa:	2f cc       	sub	r12,-4
800055ac:	40 0a       	lddsp	r10,sp[0x0]
800055ae:	20 2a       	sub	r10,2
800055b0:	fe 99 ff 6c 	brgt	80005488 <__dsp16_iir_den_loop_main7>
800055b4:	2f dd       	sub	sp,-12
800055b6:	d8 32       	popm	r0-r7,pc

800055b8 <dsp16_filt_iir>:
800055b8:	d4 31       	pushm	r0-r7,lr
800055ba:	20 4d       	sub	sp,16
800055bc:	fa ce ff cc 	sub	lr,sp,-52
800055c0:	16 91       	mov	r1,r11
800055c2:	7c 3b       	ld.w	r11,lr[0xc]
800055c4:	50 0b       	stdsp	sp[0x0],r11
800055c6:	7c 0b       	ld.w	r11,lr[0x0]
800055c8:	50 39       	stdsp	sp[0xc],r9
800055ca:	50 2b       	stdsp	sp[0x8],r11
800055cc:	7c 1b       	ld.w	r11,lr[0x4]
800055ce:	50 1b       	stdsp	sp[0x4],r11
800055d0:	18 97       	mov	r7,r12
800055d2:	14 92       	mov	r2,r10
800055d4:	10 93       	mov	r3,r8
800055d6:	7c 20       	ld.w	r0,lr[0x8]
800055d8:	f7 dc c0 02 	bfextu	r11,r12,0x0,0x2
800055dc:	c5 70       	breq	8000568a <dsp16_filt_iir+0xd2>
800055de:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
800055e2:	f4 c5 00 01 	sub	r5,r10,1
800055e6:	4c 1a       	lddpc	r10,800056e8 <dsp16_filt_iir+0x130>
800055e8:	1a d0       	st.w	--sp,r0
800055ea:	f4 0b 03 26 	ld.w	r6,r10[r11<<0x2]
800055ee:	f8 c4 ff fe 	sub	r4,r12,-2
800055f2:	f0 0b 11 01 	rsub	r11,r8,1
800055f6:	0a 9a       	mov	r10,r5
800055f8:	e2 0b 00 1b 	add	r11,r1,r11<<0x1
800055fc:	08 9c       	mov	r12,r4
800055fe:	5d 16       	icall	r6
80005600:	2f fd       	sub	sp,-4
80005602:	58 05       	cp.w	r5,0
80005604:	e0 8a 00 6a 	brle	800056d8 <dsp16_filt_iir+0x120>
80005608:	58 15       	cp.w	r5,1
8000560a:	5f b8       	srhi	r8
8000560c:	e9 e7 10 09 	or	r9,r4,r7
80005610:	f3 d9 c0 02 	bfextu	r9,r9,0x0,0x2
80005614:	5f 0a       	sreq	r10
80005616:	14 68       	and	r8,r10
80005618:	c5 60       	breq	800056c4 <dsp16_filt_iir+0x10c>
8000561a:	ea 0a 16 01 	lsr	r10,r5,0x1
8000561e:	f4 0b 15 01 	lsl	r11,r10,0x1
80005622:	c6 00       	breq	800056e2 <dsp16_filt_iir+0x12a>
80005624:	08 9c       	mov	r12,r4
80005626:	30 09       	mov	r9,0
80005628:	78 08       	ld.w	r8,r12[0x0]
8000562a:	f9 48 ff fe 	st.w	r12[-2],r8
8000562e:	2f f9       	sub	r9,-1
80005630:	2f cc       	sub	r12,-4
80005632:	14 39       	cp.w	r9,r10
80005634:	cf a3       	brcs	80005628 <dsp16_filt_iir+0x70>
80005636:	16 98       	mov	r8,r11
80005638:	16 35       	cp.w	r5,r11
8000563a:	c0 e0       	breq	80005656 <dsp16_filt_iir+0x9e>
8000563c:	f0 c9 ff ff 	sub	r9,r8,-1
80005640:	ee 08 00 1b 	add	r11,r7,r8<<0x1
80005644:	ee 09 00 1a 	add	r10,r7,r9<<0x1
80005648:	c0 28       	rjmp	8000564c <dsp16_filt_iir+0x94>
8000564a:	2f f9       	sub	r9,-1
8000564c:	15 18       	ld.sh	r8,r10++
8000564e:	16 b8       	st.h	r11++,r8
80005650:	12 35       	cp.w	r5,r9
80005652:	fe 99 ff fc 	brgt	8000564a <dsp16_filt_iir+0x92>
80005656:	ea 06 15 01 	lsl	r6,r5,0x1
8000565a:	58 03       	cp.w	r3,0
8000565c:	e0 8a 00 41 	brle	800056de <dsp16_filt_iir+0x126>
80005660:	30 0c       	mov	r12,0
80005662:	e2 05 00 1b 	add	r11,r1,r5<<0x1
80005666:	40 3e       	lddsp	lr,sp[0xc]
80005668:	18 9a       	mov	r10,r12
8000566a:	96 09       	ld.sh	r9,r11[0x0]
8000566c:	1d 18       	ld.sh	r8,lr++
8000566e:	2f fc       	sub	r12,-1
80005670:	20 2b       	sub	r11,2
80005672:	f2 08 04 8a 	machh.w	r10,r9:b,r8:b
80005676:	18 33       	cp.w	r3,r12
80005678:	fe 99 ff f9 	brgt	8000566a <dsp16_filt_iir+0xb2>
8000567c:	e0 08 11 0f 	rsub	r8,r0,15
80005680:	f4 08 08 48 	asr	r8,r10,r8
80005684:	ee 06 0a 08 	st.h	r7[r6],r8
80005688:	c0 d8       	rjmp	800056a2 <dsp16_filt_iir+0xea>
8000568a:	1a d0       	st.w	--sp,r0
8000568c:	f0 0b 11 01 	rsub	r11,r8,1
80005690:	e7 d8 c0 02 	bfextu	r3,r8,0x0,0x2
80005694:	e2 0b 00 1b 	add	r11,r1,r11<<0x1
80005698:	49 46       	lddpc	r6,800056e8 <dsp16_filt_iir+0x130>
8000569a:	ec 03 03 25 	ld.w	r5,r6[r3<<0x2]
8000569e:	5d 15       	icall	r5
800056a0:	2f fd       	sub	sp,-4
800056a2:	40 08       	lddsp	r8,sp[0x0]
800056a4:	49 2e       	lddpc	lr,800056ec <dsp16_filt_iir+0x134>
800056a6:	1a d8       	st.w	--sp,r8
800056a8:	40 28       	lddsp	r8,sp[0x8]
800056aa:	f7 d8 c0 03 	bfextu	r11,r8,0x0,0x3
800056ae:	40 39       	lddsp	r9,sp[0xc]
800056b0:	fc 0b 03 26 	ld.w	r6,lr[r11<<0x2]
800056b4:	04 9a       	mov	r10,r2
800056b6:	0e 9c       	mov	r12,r7
800056b8:	ee 08 01 1b 	sub	r11,r7,r8<<0x1
800056bc:	5d 16       	icall	r6
800056be:	2f fd       	sub	sp,-4
800056c0:	2f cd       	sub	sp,-16
800056c2:	d8 32       	popm	r0-r7,pc
800056c4:	08 9c       	mov	r12,r4
800056c6:	30 19       	mov	r9,1
800056c8:	98 08       	ld.sh	r8,r12[0x0]
800056ca:	f9 58 ff fe 	st.h	r12[-2],r8
800056ce:	2f f9       	sub	r9,-1
800056d0:	2f ec       	sub	r12,-2
800056d2:	12 32       	cp.w	r2,r9
800056d4:	cf a1       	brne	800056c8 <dsp16_filt_iir+0x110>
800056d6:	cc 0b       	rjmp	80005656 <dsp16_filt_iir+0x9e>
800056d8:	30 05       	mov	r5,0
800056da:	0a 96       	mov	r6,r5
800056dc:	cb fb       	rjmp	8000565a <dsp16_filt_iir+0xa2>
800056de:	30 08       	mov	r8,0
800056e0:	cd 2b       	rjmp	80005684 <dsp16_filt_iir+0xcc>
800056e2:	16 98       	mov	r8,r11
800056e4:	ca cb       	rjmp	8000563c <dsp16_filt_iir+0x84>
800056e6:	d7 03       	nop
800056e8:	80 03       	ld.sh	r3,r0[0x0]
800056ea:	6d cc       	ld.w	r12,r6[0x70]
800056ec:	80 03       	ld.sh	r3,r0[0x0]
800056ee:	6d ac       	ld.w	r12,r6[0x68]

800056f0 <__avr32_f32_cmp_ge>:
800056f0:	f8 0a 15 01 	lsl	r10,r12,0x1
800056f4:	f6 09 15 01 	lsl	r9,r11,0x1
800056f8:	f5 ba 00 00 	subfeq	r10,0
800056fc:	5e 0f       	reteq	1
800056fe:	fc 18 ff 00 	movh	r8,0xff00
80005702:	10 3a       	cp.w	r10,r8
80005704:	5e bd       	rethi	0
80005706:	10 39       	cp.w	r9,r8
80005708:	5e bd       	rethi	0
8000570a:	f7 ec 20 08 	eor	r8,r11,r12
8000570e:	ed bc 00 1f 	bld	r12,0x1f
80005712:	5f 28       	srhs	r8
80005714:	5e 68       	retmi	r8
80005716:	c0 43       	brcs	8000571e <__avr32_f32_cmp_ge+0x2e>
80005718:	16 3c       	cp.w	r12,r11
8000571a:	5e 2f       	reths	1
8000571c:	5e 3d       	retlo	0
8000571e:	18 3b       	cp.w	r11,r12
80005720:	5e 2f       	reths	1
80005722:	5e 3d       	retlo	0

80005724 <__avr32_f32_mul>:
80005724:	18 98       	mov	r8,r12
80005726:	16 5c       	eor	r12,r11
80005728:	e6 1c 80 00 	andh	r12,0x8000,COH
8000572c:	bf d8       	cbr	r8,0x1f
8000572e:	c6 60       	breq	800057fa <__avr32_f32_mul_op1_zero>
80005730:	bf db       	cbr	r11,0x1f
80005732:	f0 0b 0c 4a 	max	r10,r8,r11
80005736:	f0 0b 0d 49 	min	r9,r8,r11
8000573a:	f4 08 15 08 	lsl	r8,r10,0x8
8000573e:	bf b8       	sbr	r8,0x1f
80005740:	b7 9a       	lsr	r10,0x17
80005742:	e0 4a 00 ff 	cp.w	r10,255
80005746:	c3 d0       	breq	800057c0 <__avr32_f32_mul_op1_nan_or_inf>
80005748:	f2 0b 15 08 	lsl	r11,r9,0x8
8000574c:	bf bb       	sbr	r11,0x1f
8000574e:	b7 99       	lsr	r9,0x17
80005750:	c2 40       	breq	80005798 <__avr32_f32_mul_op2_subnormal>
80005752:	14 09       	add	r9,r10
80005754:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80005758:	f6 08 15 01 	lsl	r8,r11,0x1
8000575c:	f0 0b 17 20 	movhs	r11,r8
80005760:	f7 b9 02 01 	subhs	r9,1
80005764:	a9 8a       	lsr	r10,0x8
80005766:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
8000576a:	27 e9       	sub	r9,126
8000576c:	e0 8a 00 39 	brle	800057de <__avr32_f32_mul_res_subnormal>
80005770:	e0 49 00 ff 	cp.w	r9,255
80005774:	c0 f4       	brge	80005792 <__avr32_f32_mul_round+0x14>
80005776:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
8000577a:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

8000577e <__avr32_f32_mul_round>:
8000577e:	fc 18 80 00 	movh	r8,0x8000
80005782:	ed bc 00 00 	bld	r12,0x0
80005786:	f7 b8 01 ff 	subne	r8,-1
8000578a:	10 3a       	cp.w	r10,r8
8000578c:	f7 bc 02 ff 	subhs	r12,-1
80005790:	5e fc       	retal	r12
80005792:	ea 1c 7f 80 	orh	r12,0x7f80
80005796:	5e fc       	retal	r12

80005798 <__avr32_f32_mul_op2_subnormal>:
80005798:	bf db       	cbr	r11,0x1f
8000579a:	f6 09 12 00 	clz	r9,r11
8000579e:	5e 3d       	retlo	0
800057a0:	20 89       	sub	r9,8
800057a2:	f6 09 09 4b 	lsl	r11,r11,r9
800057a6:	f2 09 11 01 	rsub	r9,r9,1
800057aa:	14 7a       	tst	r10,r10
800057ac:	cd 31       	brne	80005752 <__avr32_f32_mul+0x2e>
800057ae:	bf d8       	cbr	r8,0x1f
800057b0:	f6 0a 12 00 	clz	r10,r11
800057b4:	5e 3d       	retlo	0
800057b6:	f0 0a 09 48 	lsl	r8,r8,r10
800057ba:	f4 0a 11 01 	rsub	r10,r10,1
800057be:	cc ab       	rjmp	80005752 <__avr32_f32_mul+0x2e>

800057c0 <__avr32_f32_mul_op1_nan_or_inf>:
800057c0:	f0 0b 15 01 	lsl	r11,r8,0x1
800057c4:	5e 1e       	retne	-1
800057c6:	12 79       	tst	r9,r9
800057c8:	5e 0e       	reteq	-1
800057ca:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
800057ce:	f2 0b 16 17 	lsr	r11,r9,0x17
800057d2:	e0 4b 00 ff 	cp.w	r11,255
800057d6:	5e 1c       	retne	r12
800057d8:	a9 79       	lsl	r9,0x9
800057da:	5e 0c       	reteq	r12
800057dc:	5e fe       	retal	-1

800057de <__avr32_f32_mul_res_subnormal>:
800057de:	f2 09 11 09 	rsub	r9,r9,9
800057e2:	f2 08 11 20 	rsub	r8,r9,32
800057e6:	5e 3d       	retlo	0
800057e8:	f6 09 0a 49 	lsr	r9,r11,r9
800057ec:	12 4c       	or	r12,r9
800057ee:	f6 08 09 4b 	lsl	r11,r11,r8
800057f2:	e4 1a 00 ff 	andh	r10,0xff
800057f6:	16 4a       	or	r10,r11
800057f8:	cc 3b       	rjmp	8000577e <__avr32_f32_mul_round>

800057fa <__avr32_f32_mul_op1_zero>:
800057fa:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
800057fe:	e0 4a 00 ff 	cp.w	r10,255
80005802:	5e 1c       	retne	r12
80005804:	5e 0e       	reteq	-1

80005806 <__avr32_u32_to_f32>:
80005806:	58 0c       	cp.w	r12,0
80005808:	5e 0c       	reteq	r12
8000580a:	e0 6a 00 9e 	mov	r10,158
8000580e:	f8 09 12 00 	clz	r9,r12
80005812:	12 1a       	sub	r10,r9
80005814:	f8 09 09 4c 	lsl	r12,r12,r9
80005818:	58 0a       	cp.w	r10,0
8000581a:	e0 8a 00 14 	brle	80005842 <__avr32_u32_to_f32_subnormal>
8000581e:	37 f9       	mov	r9,127
80005820:	ed bc 00 08 	bld	r12,0x8
80005824:	f7 b9 00 ff 	subeq	r9,-1
80005828:	12 0c       	add	r12,r9
8000582a:	f7 ba 03 fe 	sublo	r10,-2
8000582e:	ed bc 00 1f 	bld	r12,0x1f
80005832:	f7 ba 01 01 	subne	r10,1
80005836:	f8 0c 16 07 	lsr	r12,r12,0x7
8000583a:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
8000583e:	a1 9c       	lsr	r12,0x1
80005840:	5e fc       	retal	r12

80005842 <__avr32_u32_to_f32_subnormal>:
80005842:	30 08       	mov	r8,0
80005844:	f4 0a 11 01 	rsub	r10,r10,1
80005848:	59 9a       	cp.w	r10,25
8000584a:	f9 bc 02 00 	movhs	r12,0
8000584e:	c1 32       	brcc	80005874 <__avr32_u32_to_f32_subnormal+0x32>
80005850:	f4 09 11 20 	rsub	r9,r10,32
80005854:	f8 09 09 49 	lsl	r9,r12,r9
80005858:	5f 19       	srne	r9
8000585a:	f8 0a 0a 4c 	lsr	r12,r12,r10
8000585e:	12 4c       	or	r12,r9
80005860:	37 f9       	mov	r9,127
80005862:	ed bc 00 08 	bld	r12,0x8
80005866:	f7 b9 00 ff 	subeq	r9,-1
8000586a:	12 0c       	add	r12,r9
8000586c:	f8 0c 16 07 	lsr	r12,r12,0x7
80005870:	a1 78       	lsl	r8,0x1
80005872:	5d 0c       	ror	r12
80005874:	5e fc       	retal	r12

80005876 <__avr32_f32_to_s32>:
80005876:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
8000587a:	27 fb       	sub	r11,127
8000587c:	5e 3d       	retlo	0
8000587e:	f6 0b 11 1f 	rsub	r11,r11,31
80005882:	f8 0a 15 08 	lsl	r10,r12,0x8
80005886:	bf ba       	sbr	r10,0x1f
80005888:	f4 0b 0a 4a 	lsr	r10,r10,r11
8000588c:	a1 7c       	lsl	r12,0x1
8000588e:	5e 2a       	reths	r10
80005890:	5c 3a       	neg	r10
80005892:	5e fa       	retal	r10

80005894 <free>:
80005894:	d4 01       	pushm	lr
80005896:	e0 68 01 40 	mov	r8,320
8000589a:	18 9b       	mov	r11,r12
8000589c:	70 0c       	ld.w	r12,r8[0x0]
8000589e:	e0 a0 03 43 	rcall	80005f24 <_free_r>
800058a2:	d8 02       	popm	pc

800058a4 <malloc>:
800058a4:	d4 01       	pushm	lr
800058a6:	e0 68 01 40 	mov	r8,320
800058aa:	18 9b       	mov	r11,r12
800058ac:	70 0c       	ld.w	r12,r8[0x0]
800058ae:	c0 3c       	rcall	800058b4 <_malloc_r>
800058b0:	d8 02       	popm	pc
800058b2:	d7 03       	nop

800058b4 <_malloc_r>:
800058b4:	d4 31       	pushm	r0-r7,lr
800058b6:	f6 c8 ff f5 	sub	r8,r11,-11
800058ba:	18 95       	mov	r5,r12
800058bc:	10 97       	mov	r7,r8
800058be:	e0 17 ff f8 	andl	r7,0xfff8
800058c2:	59 68       	cp.w	r8,22
800058c4:	f9 b7 08 10 	movls	r7,16
800058c8:	16 37       	cp.w	r7,r11
800058ca:	5f 38       	srlo	r8
800058cc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800058d0:	c0 50       	breq	800058da <_malloc_r+0x26>
800058d2:	30 c8       	mov	r8,12
800058d4:	99 38       	st.w	r12[0xc],r8
800058d6:	e0 8f 01 f7 	bral	80005cc4 <_malloc_r+0x410>
800058da:	fe b0 ec 69 	rcall	800031ac <__malloc_lock>
800058de:	e0 47 01 f7 	cp.w	r7,503
800058e2:	e0 8b 00 1d 	brhi	8000591c <_malloc_r+0x68>
800058e6:	ee 03 16 03 	lsr	r3,r7,0x3
800058ea:	e0 68 01 44 	mov	r8,324
800058ee:	f0 03 00 38 	add	r8,r8,r3<<0x3
800058f2:	70 36       	ld.w	r6,r8[0xc]
800058f4:	10 36       	cp.w	r6,r8
800058f6:	c0 61       	brne	80005902 <_malloc_r+0x4e>
800058f8:	ec c8 ff f8 	sub	r8,r6,-8
800058fc:	70 36       	ld.w	r6,r8[0xc]
800058fe:	10 36       	cp.w	r6,r8
80005900:	c0 c0       	breq	80005918 <_malloc_r+0x64>
80005902:	6c 18       	ld.w	r8,r6[0x4]
80005904:	e0 18 ff fc 	andl	r8,0xfffc
80005908:	6c 3a       	ld.w	r10,r6[0xc]
8000590a:	ec 08 00 09 	add	r9,r6,r8
8000590e:	0a 9c       	mov	r12,r5
80005910:	6c 28       	ld.w	r8,r6[0x8]
80005912:	95 28       	st.w	r10[0x8],r8
80005914:	91 3a       	st.w	r8[0xc],r10
80005916:	c4 78       	rjmp	800059a4 <_malloc_r+0xf0>
80005918:	2f e3       	sub	r3,-2
8000591a:	c4 d8       	rjmp	800059b4 <_malloc_r+0x100>
8000591c:	ee 03 16 09 	lsr	r3,r7,0x9
80005920:	c0 41       	brne	80005928 <_malloc_r+0x74>
80005922:	ee 03 16 03 	lsr	r3,r7,0x3
80005926:	c2 68       	rjmp	80005972 <_malloc_r+0xbe>
80005928:	58 43       	cp.w	r3,4
8000592a:	e0 8b 00 06 	brhi	80005936 <_malloc_r+0x82>
8000592e:	ee 03 16 06 	lsr	r3,r7,0x6
80005932:	2c 83       	sub	r3,-56
80005934:	c1 f8       	rjmp	80005972 <_malloc_r+0xbe>
80005936:	59 43       	cp.w	r3,20
80005938:	e0 8b 00 04 	brhi	80005940 <_malloc_r+0x8c>
8000593c:	2a 53       	sub	r3,-91
8000593e:	c1 a8       	rjmp	80005972 <_malloc_r+0xbe>
80005940:	e0 43 00 54 	cp.w	r3,84
80005944:	e0 8b 00 06 	brhi	80005950 <_malloc_r+0x9c>
80005948:	ee 03 16 0c 	lsr	r3,r7,0xc
8000594c:	29 23       	sub	r3,-110
8000594e:	c1 28       	rjmp	80005972 <_malloc_r+0xbe>
80005950:	e0 43 01 54 	cp.w	r3,340
80005954:	e0 8b 00 06 	brhi	80005960 <_malloc_r+0xac>
80005958:	ee 03 16 0f 	lsr	r3,r7,0xf
8000595c:	28 93       	sub	r3,-119
8000595e:	c0 a8       	rjmp	80005972 <_malloc_r+0xbe>
80005960:	e0 43 05 54 	cp.w	r3,1364
80005964:	e0 88 00 04 	brls	8000596c <_malloc_r+0xb8>
80005968:	37 e3       	mov	r3,126
8000596a:	c0 48       	rjmp	80005972 <_malloc_r+0xbe>
8000596c:	ee 03 16 12 	lsr	r3,r7,0x12
80005970:	28 43       	sub	r3,-124
80005972:	e0 6a 01 44 	mov	r10,324
80005976:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000597a:	74 36       	ld.w	r6,r10[0xc]
8000597c:	c1 98       	rjmp	800059ae <_malloc_r+0xfa>
8000597e:	6c 19       	ld.w	r9,r6[0x4]
80005980:	e0 19 ff fc 	andl	r9,0xfffc
80005984:	f2 07 01 0b 	sub	r11,r9,r7
80005988:	58 fb       	cp.w	r11,15
8000598a:	e0 8a 00 04 	brle	80005992 <_malloc_r+0xde>
8000598e:	20 13       	sub	r3,1
80005990:	c1 18       	rjmp	800059b2 <_malloc_r+0xfe>
80005992:	6c 38       	ld.w	r8,r6[0xc]
80005994:	58 0b       	cp.w	r11,0
80005996:	c0 b5       	brlt	800059ac <_malloc_r+0xf8>
80005998:	6c 2a       	ld.w	r10,r6[0x8]
8000599a:	ec 09 00 09 	add	r9,r6,r9
8000599e:	0a 9c       	mov	r12,r5
800059a0:	91 2a       	st.w	r8[0x8],r10
800059a2:	95 38       	st.w	r10[0xc],r8
800059a4:	72 18       	ld.w	r8,r9[0x4]
800059a6:	a1 a8       	sbr	r8,0x0
800059a8:	93 18       	st.w	r9[0x4],r8
800059aa:	cb c8       	rjmp	80005b22 <_malloc_r+0x26e>
800059ac:	10 96       	mov	r6,r8
800059ae:	14 36       	cp.w	r6,r10
800059b0:	ce 71       	brne	8000597e <_malloc_r+0xca>
800059b2:	2f f3       	sub	r3,-1
800059b4:	e0 6a 01 44 	mov	r10,324
800059b8:	f4 cc ff f8 	sub	r12,r10,-8
800059bc:	78 26       	ld.w	r6,r12[0x8]
800059be:	18 36       	cp.w	r6,r12
800059c0:	c6 c0       	breq	80005a98 <_malloc_r+0x1e4>
800059c2:	6c 19       	ld.w	r9,r6[0x4]
800059c4:	e0 19 ff fc 	andl	r9,0xfffc
800059c8:	f2 07 01 08 	sub	r8,r9,r7
800059cc:	58 f8       	cp.w	r8,15
800059ce:	e0 89 00 8f 	brgt	80005aec <_malloc_r+0x238>
800059d2:	99 3c       	st.w	r12[0xc],r12
800059d4:	99 2c       	st.w	r12[0x8],r12
800059d6:	58 08       	cp.w	r8,0
800059d8:	c0 55       	brlt	800059e2 <_malloc_r+0x12e>
800059da:	ec 09 00 09 	add	r9,r6,r9
800059de:	0a 9c       	mov	r12,r5
800059e0:	ce 2b       	rjmp	800059a4 <_malloc_r+0xf0>
800059e2:	e0 49 01 ff 	cp.w	r9,511
800059e6:	e0 8b 00 13 	brhi	80005a0c <_malloc_r+0x158>
800059ea:	a3 99       	lsr	r9,0x3
800059ec:	f4 09 00 38 	add	r8,r10,r9<<0x3
800059f0:	70 2b       	ld.w	r11,r8[0x8]
800059f2:	8d 38       	st.w	r6[0xc],r8
800059f4:	8d 2b       	st.w	r6[0x8],r11
800059f6:	97 36       	st.w	r11[0xc],r6
800059f8:	91 26       	st.w	r8[0x8],r6
800059fa:	a3 49       	asr	r9,0x2
800059fc:	74 18       	ld.w	r8,r10[0x4]
800059fe:	30 1b       	mov	r11,1
80005a00:	f6 09 09 49 	lsl	r9,r11,r9
80005a04:	f1 e9 10 09 	or	r9,r8,r9
80005a08:	95 19       	st.w	r10[0x4],r9
80005a0a:	c4 78       	rjmp	80005a98 <_malloc_r+0x1e4>
80005a0c:	f2 0a 16 09 	lsr	r10,r9,0x9
80005a10:	58 4a       	cp.w	r10,4
80005a12:	e0 8b 00 07 	brhi	80005a20 <_malloc_r+0x16c>
80005a16:	f2 0a 16 06 	lsr	r10,r9,0x6
80005a1a:	2c 8a       	sub	r10,-56
80005a1c:	c2 08       	rjmp	80005a5c <_malloc_r+0x1a8>
80005a1e:	d7 03       	nop
80005a20:	59 4a       	cp.w	r10,20
80005a22:	e0 8b 00 04 	brhi	80005a2a <_malloc_r+0x176>
80005a26:	2a 5a       	sub	r10,-91
80005a28:	c1 a8       	rjmp	80005a5c <_malloc_r+0x1a8>
80005a2a:	e0 4a 00 54 	cp.w	r10,84
80005a2e:	e0 8b 00 06 	brhi	80005a3a <_malloc_r+0x186>
80005a32:	f2 0a 16 0c 	lsr	r10,r9,0xc
80005a36:	29 2a       	sub	r10,-110
80005a38:	c1 28       	rjmp	80005a5c <_malloc_r+0x1a8>
80005a3a:	e0 4a 01 54 	cp.w	r10,340
80005a3e:	e0 8b 00 06 	brhi	80005a4a <_malloc_r+0x196>
80005a42:	f2 0a 16 0f 	lsr	r10,r9,0xf
80005a46:	28 9a       	sub	r10,-119
80005a48:	c0 a8       	rjmp	80005a5c <_malloc_r+0x1a8>
80005a4a:	e0 4a 05 54 	cp.w	r10,1364
80005a4e:	e0 88 00 04 	brls	80005a56 <_malloc_r+0x1a2>
80005a52:	37 ea       	mov	r10,126
80005a54:	c0 48       	rjmp	80005a5c <_malloc_r+0x1a8>
80005a56:	f2 0a 16 12 	lsr	r10,r9,0x12
80005a5a:	28 4a       	sub	r10,-124
80005a5c:	e0 6b 01 44 	mov	r11,324
80005a60:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80005a64:	68 28       	ld.w	r8,r4[0x8]
80005a66:	08 38       	cp.w	r8,r4
80005a68:	c0 e1       	brne	80005a84 <_malloc_r+0x1d0>
80005a6a:	76 19       	ld.w	r9,r11[0x4]
80005a6c:	a3 4a       	asr	r10,0x2
80005a6e:	30 1e       	mov	lr,1
80005a70:	fc 0a 09 4a 	lsl	r10,lr,r10
80005a74:	f3 ea 10 0a 	or	r10,r9,r10
80005a78:	10 99       	mov	r9,r8
80005a7a:	97 1a       	st.w	r11[0x4],r10
80005a7c:	c0 a8       	rjmp	80005a90 <_malloc_r+0x1dc>
80005a7e:	70 28       	ld.w	r8,r8[0x8]
80005a80:	08 38       	cp.w	r8,r4
80005a82:	c0 60       	breq	80005a8e <_malloc_r+0x1da>
80005a84:	70 1a       	ld.w	r10,r8[0x4]
80005a86:	e0 1a ff fc 	andl	r10,0xfffc
80005a8a:	14 39       	cp.w	r9,r10
80005a8c:	cf 93       	brcs	80005a7e <_malloc_r+0x1ca>
80005a8e:	70 39       	ld.w	r9,r8[0xc]
80005a90:	8d 39       	st.w	r6[0xc],r9
80005a92:	8d 28       	st.w	r6[0x8],r8
80005a94:	91 36       	st.w	r8[0xc],r6
80005a96:	93 26       	st.w	r9[0x8],r6
80005a98:	e6 08 14 02 	asr	r8,r3,0x2
80005a9c:	30 1b       	mov	r11,1
80005a9e:	e0 64 01 44 	mov	r4,324
80005aa2:	f6 08 09 4b 	lsl	r11,r11,r8
80005aa6:	68 18       	ld.w	r8,r4[0x4]
80005aa8:	10 3b       	cp.w	r11,r8
80005aaa:	e0 8b 00 6b 	brhi	80005b80 <_malloc_r+0x2cc>
80005aae:	f7 e8 00 09 	and	r9,r11,r8
80005ab2:	c0 b1       	brne	80005ac8 <_malloc_r+0x214>
80005ab4:	e0 13 ff fc 	andl	r3,0xfffc
80005ab8:	a1 7b       	lsl	r11,0x1
80005aba:	2f c3       	sub	r3,-4
80005abc:	c0 38       	rjmp	80005ac2 <_malloc_r+0x20e>
80005abe:	2f c3       	sub	r3,-4
80005ac0:	a1 7b       	lsl	r11,0x1
80005ac2:	f7 e8 00 09 	and	r9,r11,r8
80005ac6:	cf c0       	breq	80005abe <_malloc_r+0x20a>
80005ac8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80005acc:	06 92       	mov	r2,r3
80005ace:	1c 91       	mov	r1,lr
80005ad0:	62 36       	ld.w	r6,r1[0xc]
80005ad2:	c2 e8       	rjmp	80005b2e <_malloc_r+0x27a>
80005ad4:	6c 1a       	ld.w	r10,r6[0x4]
80005ad6:	e0 1a ff fc 	andl	r10,0xfffc
80005ada:	f4 07 01 08 	sub	r8,r10,r7
80005ade:	58 f8       	cp.w	r8,15
80005ae0:	e0 8a 00 15 	brle	80005b0a <_malloc_r+0x256>
80005ae4:	6c 3a       	ld.w	r10,r6[0xc]
80005ae6:	6c 29       	ld.w	r9,r6[0x8]
80005ae8:	95 29       	st.w	r10[0x8],r9
80005aea:	93 3a       	st.w	r9[0xc],r10
80005aec:	0e 99       	mov	r9,r7
80005aee:	ec 07 00 07 	add	r7,r6,r7
80005af2:	a1 a9       	sbr	r9,0x0
80005af4:	99 37       	st.w	r12[0xc],r7
80005af6:	99 27       	st.w	r12[0x8],r7
80005af8:	8d 19       	st.w	r6[0x4],r9
80005afa:	ee 08 09 08 	st.w	r7[r8],r8
80005afe:	8f 2c       	st.w	r7[0x8],r12
80005b00:	8f 3c       	st.w	r7[0xc],r12
80005b02:	a1 a8       	sbr	r8,0x0
80005b04:	0a 9c       	mov	r12,r5
80005b06:	8f 18       	st.w	r7[0x4],r8
80005b08:	c0 d8       	rjmp	80005b22 <_malloc_r+0x26e>
80005b0a:	6c 39       	ld.w	r9,r6[0xc]
80005b0c:	58 08       	cp.w	r8,0
80005b0e:	c0 f5       	brlt	80005b2c <_malloc_r+0x278>
80005b10:	ec 0a 00 0a 	add	r10,r6,r10
80005b14:	74 18       	ld.w	r8,r10[0x4]
80005b16:	a1 a8       	sbr	r8,0x0
80005b18:	0a 9c       	mov	r12,r5
80005b1a:	95 18       	st.w	r10[0x4],r8
80005b1c:	6c 28       	ld.w	r8,r6[0x8]
80005b1e:	93 28       	st.w	r9[0x8],r8
80005b20:	91 39       	st.w	r8[0xc],r9
80005b22:	fe b0 eb 4b 	rcall	800031b8 <__malloc_unlock>
80005b26:	ec cc ff f8 	sub	r12,r6,-8
80005b2a:	d8 32       	popm	r0-r7,pc
80005b2c:	12 96       	mov	r6,r9
80005b2e:	02 36       	cp.w	r6,r1
80005b30:	cd 21       	brne	80005ad4 <_malloc_r+0x220>
80005b32:	2f f2       	sub	r2,-1
80005b34:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80005b38:	c0 30       	breq	80005b3e <_malloc_r+0x28a>
80005b3a:	2f 81       	sub	r1,-8
80005b3c:	cc ab       	rjmp	80005ad0 <_malloc_r+0x21c>
80005b3e:	1c 98       	mov	r8,lr
80005b40:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80005b44:	c0 81       	brne	80005b54 <_malloc_r+0x2a0>
80005b46:	68 19       	ld.w	r9,r4[0x4]
80005b48:	f6 08 11 ff 	rsub	r8,r11,-1
80005b4c:	f3 e8 00 08 	and	r8,r9,r8
80005b50:	89 18       	st.w	r4[0x4],r8
80005b52:	c0 78       	rjmp	80005b60 <_malloc_r+0x2ac>
80005b54:	f0 c9 00 08 	sub	r9,r8,8
80005b58:	20 13       	sub	r3,1
80005b5a:	70 08       	ld.w	r8,r8[0x0]
80005b5c:	12 38       	cp.w	r8,r9
80005b5e:	cf 10       	breq	80005b40 <_malloc_r+0x28c>
80005b60:	a1 7b       	lsl	r11,0x1
80005b62:	68 18       	ld.w	r8,r4[0x4]
80005b64:	10 3b       	cp.w	r11,r8
80005b66:	e0 8b 00 0d 	brhi	80005b80 <_malloc_r+0x2cc>
80005b6a:	58 0b       	cp.w	r11,0
80005b6c:	c0 a0       	breq	80005b80 <_malloc_r+0x2cc>
80005b6e:	04 93       	mov	r3,r2
80005b70:	c0 38       	rjmp	80005b76 <_malloc_r+0x2c2>
80005b72:	2f c3       	sub	r3,-4
80005b74:	a1 7b       	lsl	r11,0x1
80005b76:	f7 e8 00 09 	and	r9,r11,r8
80005b7a:	ca 71       	brne	80005ac8 <_malloc_r+0x214>
80005b7c:	cf bb       	rjmp	80005b72 <_malloc_r+0x2be>
80005b7e:	d7 03       	nop
80005b80:	68 23       	ld.w	r3,r4[0x8]
80005b82:	66 12       	ld.w	r2,r3[0x4]
80005b84:	e0 12 ff fc 	andl	r2,0xfffc
80005b88:	0e 32       	cp.w	r2,r7
80005b8a:	5f 39       	srlo	r9
80005b8c:	e4 07 01 08 	sub	r8,r2,r7
80005b90:	58 f8       	cp.w	r8,15
80005b92:	5f aa       	srle	r10
80005b94:	f5 e9 10 09 	or	r9,r10,r9
80005b98:	e0 80 00 98 	breq	80005cc8 <_malloc_r+0x414>
80005b9c:	e0 68 08 14 	mov	r8,2068
80005ba0:	70 01       	ld.w	r1,r8[0x0]
80005ba2:	e0 68 05 50 	mov	r8,1360
80005ba6:	2f 01       	sub	r1,-16
80005ba8:	70 08       	ld.w	r8,r8[0x0]
80005baa:	0e 01       	add	r1,r7
80005bac:	5b f8       	cp.w	r8,-1
80005bae:	c0 40       	breq	80005bb6 <_malloc_r+0x302>
80005bb0:	28 11       	sub	r1,-127
80005bb2:	e0 11 ff 80 	andl	r1,0xff80
80005bb6:	02 9b       	mov	r11,r1
80005bb8:	0a 9c       	mov	r12,r5
80005bba:	c3 bd       	rcall	80005e30 <_sbrk_r>
80005bbc:	18 96       	mov	r6,r12
80005bbe:	5b fc       	cp.w	r12,-1
80005bc0:	c7 30       	breq	80005ca6 <_malloc_r+0x3f2>
80005bc2:	e6 02 00 08 	add	r8,r3,r2
80005bc6:	10 3c       	cp.w	r12,r8
80005bc8:	c0 32       	brcc	80005bce <_malloc_r+0x31a>
80005bca:	08 33       	cp.w	r3,r4
80005bcc:	c6 d1       	brne	80005ca6 <_malloc_r+0x3f2>
80005bce:	e0 6a 08 18 	mov	r10,2072
80005bd2:	74 09       	ld.w	r9,r10[0x0]
80005bd4:	e2 09 00 09 	add	r9,r1,r9
80005bd8:	95 09       	st.w	r10[0x0],r9
80005bda:	10 36       	cp.w	r6,r8
80005bdc:	c0 a1       	brne	80005bf0 <_malloc_r+0x33c>
80005bde:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80005be2:	c0 71       	brne	80005bf0 <_malloc_r+0x33c>
80005be4:	e2 02 00 02 	add	r2,r1,r2
80005be8:	68 28       	ld.w	r8,r4[0x8]
80005bea:	a1 a2       	sbr	r2,0x0
80005bec:	91 12       	st.w	r8[0x4],r2
80005bee:	c4 d8       	rjmp	80005c88 <_malloc_r+0x3d4>
80005bf0:	e0 6a 05 50 	mov	r10,1360
80005bf4:	74 0b       	ld.w	r11,r10[0x0]
80005bf6:	5b fb       	cp.w	r11,-1
80005bf8:	c0 31       	brne	80005bfe <_malloc_r+0x34a>
80005bfa:	95 06       	st.w	r10[0x0],r6
80005bfc:	c0 78       	rjmp	80005c0a <_malloc_r+0x356>
80005bfe:	ec 09 00 09 	add	r9,r6,r9
80005c02:	e0 6a 08 18 	mov	r10,2072
80005c06:	10 19       	sub	r9,r8
80005c08:	95 09       	st.w	r10[0x0],r9
80005c0a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80005c0e:	f0 09 11 08 	rsub	r9,r8,8
80005c12:	58 08       	cp.w	r8,0
80005c14:	f2 08 17 10 	movne	r8,r9
80005c18:	ed d8 e1 06 	addne	r6,r6,r8
80005c1c:	28 08       	sub	r8,-128
80005c1e:	ec 01 00 01 	add	r1,r6,r1
80005c22:	0a 9c       	mov	r12,r5
80005c24:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80005c28:	f0 01 01 01 	sub	r1,r8,r1
80005c2c:	02 9b       	mov	r11,r1
80005c2e:	c0 1d       	rcall	80005e30 <_sbrk_r>
80005c30:	e0 68 08 18 	mov	r8,2072
80005c34:	5b fc       	cp.w	r12,-1
80005c36:	ec 0c 17 00 	moveq	r12,r6
80005c3a:	f9 b1 00 00 	moveq	r1,0
80005c3e:	70 09       	ld.w	r9,r8[0x0]
80005c40:	0c 1c       	sub	r12,r6
80005c42:	89 26       	st.w	r4[0x8],r6
80005c44:	02 0c       	add	r12,r1
80005c46:	12 01       	add	r1,r9
80005c48:	a1 ac       	sbr	r12,0x0
80005c4a:	91 01       	st.w	r8[0x0],r1
80005c4c:	8d 1c       	st.w	r6[0x4],r12
80005c4e:	08 33       	cp.w	r3,r4
80005c50:	c1 c0       	breq	80005c88 <_malloc_r+0x3d4>
80005c52:	58 f2       	cp.w	r2,15
80005c54:	e0 8b 00 05 	brhi	80005c5e <_malloc_r+0x3aa>
80005c58:	30 18       	mov	r8,1
80005c5a:	8d 18       	st.w	r6[0x4],r8
80005c5c:	c2 58       	rjmp	80005ca6 <_malloc_r+0x3f2>
80005c5e:	30 59       	mov	r9,5
80005c60:	20 c2       	sub	r2,12
80005c62:	e0 12 ff f8 	andl	r2,0xfff8
80005c66:	e6 02 00 08 	add	r8,r3,r2
80005c6a:	91 29       	st.w	r8[0x8],r9
80005c6c:	91 19       	st.w	r8[0x4],r9
80005c6e:	66 18       	ld.w	r8,r3[0x4]
80005c70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005c74:	e5 e8 10 08 	or	r8,r2,r8
80005c78:	87 18       	st.w	r3[0x4],r8
80005c7a:	58 f2       	cp.w	r2,15
80005c7c:	e0 88 00 06 	brls	80005c88 <_malloc_r+0x3d4>
80005c80:	e6 cb ff f8 	sub	r11,r3,-8
80005c84:	0a 9c       	mov	r12,r5
80005c86:	c4 fd       	rcall	80005f24 <_free_r>
80005c88:	e0 69 08 10 	mov	r9,2064
80005c8c:	72 0a       	ld.w	r10,r9[0x0]
80005c8e:	e0 68 08 18 	mov	r8,2072
80005c92:	70 08       	ld.w	r8,r8[0x0]
80005c94:	14 38       	cp.w	r8,r10
80005c96:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80005c9a:	e0 69 08 0c 	mov	r9,2060
80005c9e:	72 0a       	ld.w	r10,r9[0x0]
80005ca0:	14 38       	cp.w	r8,r10
80005ca2:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80005ca6:	68 28       	ld.w	r8,r4[0x8]
80005ca8:	70 18       	ld.w	r8,r8[0x4]
80005caa:	e0 18 ff fc 	andl	r8,0xfffc
80005cae:	0e 38       	cp.w	r8,r7
80005cb0:	5f 39       	srlo	r9
80005cb2:	0e 18       	sub	r8,r7
80005cb4:	58 f8       	cp.w	r8,15
80005cb6:	5f aa       	srle	r10
80005cb8:	f5 e9 10 09 	or	r9,r10,r9
80005cbc:	c0 60       	breq	80005cc8 <_malloc_r+0x414>
80005cbe:	0a 9c       	mov	r12,r5
80005cc0:	fe b0 ea 7c 	rcall	800031b8 <__malloc_unlock>
80005cc4:	d8 3a       	popm	r0-r7,pc,r12=0
80005cc6:	d7 03       	nop
80005cc8:	68 26       	ld.w	r6,r4[0x8]
80005cca:	a1 a8       	sbr	r8,0x0
80005ccc:	0e 99       	mov	r9,r7
80005cce:	a1 a9       	sbr	r9,0x0
80005cd0:	8d 19       	st.w	r6[0x4],r9
80005cd2:	ec 07 00 07 	add	r7,r6,r7
80005cd6:	0a 9c       	mov	r12,r5
80005cd8:	89 27       	st.w	r4[0x8],r7
80005cda:	8f 18       	st.w	r7[0x4],r8
80005cdc:	fe b0 ea 6e 	rcall	800031b8 <__malloc_unlock>
80005ce0:	ec cc ff f8 	sub	r12,r6,-8
80005ce4:	d8 32       	popm	r0-r7,pc
80005ce6:	d7 03       	nop

80005ce8 <memcpy>:
80005ce8:	58 8a       	cp.w	r10,8
80005cea:	c2 f5       	brlt	80005d48 <memcpy+0x60>
80005cec:	f9 eb 10 09 	or	r9,r12,r11
80005cf0:	e2 19 00 03 	andl	r9,0x3,COH
80005cf4:	e0 81 00 97 	brne	80005e22 <memcpy+0x13a>
80005cf8:	e0 4a 00 20 	cp.w	r10,32
80005cfc:	c3 b4       	brge	80005d72 <memcpy+0x8a>
80005cfe:	f4 08 14 02 	asr	r8,r10,0x2
80005d02:	f0 09 11 08 	rsub	r9,r8,8
80005d06:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80005d0a:	76 69       	ld.w	r9,r11[0x18]
80005d0c:	99 69       	st.w	r12[0x18],r9
80005d0e:	76 59       	ld.w	r9,r11[0x14]
80005d10:	99 59       	st.w	r12[0x14],r9
80005d12:	76 49       	ld.w	r9,r11[0x10]
80005d14:	99 49       	st.w	r12[0x10],r9
80005d16:	76 39       	ld.w	r9,r11[0xc]
80005d18:	99 39       	st.w	r12[0xc],r9
80005d1a:	76 29       	ld.w	r9,r11[0x8]
80005d1c:	99 29       	st.w	r12[0x8],r9
80005d1e:	76 19       	ld.w	r9,r11[0x4]
80005d20:	99 19       	st.w	r12[0x4],r9
80005d22:	76 09       	ld.w	r9,r11[0x0]
80005d24:	99 09       	st.w	r12[0x0],r9
80005d26:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80005d2a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80005d2e:	e0 1a 00 03 	andl	r10,0x3
80005d32:	f4 0a 11 04 	rsub	r10,r10,4
80005d36:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005d3a:	17 a9       	ld.ub	r9,r11[0x2]
80005d3c:	b0 a9       	st.b	r8[0x2],r9
80005d3e:	17 99       	ld.ub	r9,r11[0x1]
80005d40:	b0 99       	st.b	r8[0x1],r9
80005d42:	17 89       	ld.ub	r9,r11[0x0]
80005d44:	b0 89       	st.b	r8[0x0],r9
80005d46:	5e fc       	retal	r12
80005d48:	f4 0a 11 09 	rsub	r10,r10,9
80005d4c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005d50:	17 f9       	ld.ub	r9,r11[0x7]
80005d52:	b8 f9       	st.b	r12[0x7],r9
80005d54:	17 e9       	ld.ub	r9,r11[0x6]
80005d56:	b8 e9       	st.b	r12[0x6],r9
80005d58:	17 d9       	ld.ub	r9,r11[0x5]
80005d5a:	b8 d9       	st.b	r12[0x5],r9
80005d5c:	17 c9       	ld.ub	r9,r11[0x4]
80005d5e:	b8 c9       	st.b	r12[0x4],r9
80005d60:	17 b9       	ld.ub	r9,r11[0x3]
80005d62:	b8 b9       	st.b	r12[0x3],r9
80005d64:	17 a9       	ld.ub	r9,r11[0x2]
80005d66:	b8 a9       	st.b	r12[0x2],r9
80005d68:	17 99       	ld.ub	r9,r11[0x1]
80005d6a:	b8 99       	st.b	r12[0x1],r9
80005d6c:	17 89       	ld.ub	r9,r11[0x0]
80005d6e:	b8 89       	st.b	r12[0x0],r9
80005d70:	5e fc       	retal	r12
80005d72:	eb cd 40 c0 	pushm	r6-r7,lr
80005d76:	18 99       	mov	r9,r12
80005d78:	22 0a       	sub	r10,32
80005d7a:	b7 07       	ld.d	r6,r11++
80005d7c:	b3 26       	st.d	r9++,r6
80005d7e:	b7 07       	ld.d	r6,r11++
80005d80:	b3 26       	st.d	r9++,r6
80005d82:	b7 07       	ld.d	r6,r11++
80005d84:	b3 26       	st.d	r9++,r6
80005d86:	b7 07       	ld.d	r6,r11++
80005d88:	b3 26       	st.d	r9++,r6
80005d8a:	22 0a       	sub	r10,32
80005d8c:	cf 74       	brge	80005d7a <memcpy+0x92>
80005d8e:	2f 0a       	sub	r10,-16
80005d90:	c0 65       	brlt	80005d9c <memcpy+0xb4>
80005d92:	b7 07       	ld.d	r6,r11++
80005d94:	b3 26       	st.d	r9++,r6
80005d96:	b7 07       	ld.d	r6,r11++
80005d98:	b3 26       	st.d	r9++,r6
80005d9a:	21 0a       	sub	r10,16
80005d9c:	5c 3a       	neg	r10
80005d9e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80005da2:	d7 03       	nop
80005da4:	d7 03       	nop
80005da6:	f7 36 00 0e 	ld.ub	r6,r11[14]
80005daa:	f3 66 00 0e 	st.b	r9[14],r6
80005dae:	f7 36 00 0d 	ld.ub	r6,r11[13]
80005db2:	f3 66 00 0d 	st.b	r9[13],r6
80005db6:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005dba:	f3 66 00 0c 	st.b	r9[12],r6
80005dbe:	f7 36 00 0b 	ld.ub	r6,r11[11]
80005dc2:	f3 66 00 0b 	st.b	r9[11],r6
80005dc6:	f7 36 00 0a 	ld.ub	r6,r11[10]
80005dca:	f3 66 00 0a 	st.b	r9[10],r6
80005dce:	f7 36 00 09 	ld.ub	r6,r11[9]
80005dd2:	f3 66 00 09 	st.b	r9[9],r6
80005dd6:	f7 36 00 08 	ld.ub	r6,r11[8]
80005dda:	f3 66 00 08 	st.b	r9[8],r6
80005dde:	f7 36 00 07 	ld.ub	r6,r11[7]
80005de2:	f3 66 00 07 	st.b	r9[7],r6
80005de6:	f7 36 00 06 	ld.ub	r6,r11[6]
80005dea:	f3 66 00 06 	st.b	r9[6],r6
80005dee:	f7 36 00 05 	ld.ub	r6,r11[5]
80005df2:	f3 66 00 05 	st.b	r9[5],r6
80005df6:	f7 36 00 04 	ld.ub	r6,r11[4]
80005dfa:	f3 66 00 04 	st.b	r9[4],r6
80005dfe:	f7 36 00 03 	ld.ub	r6,r11[3]
80005e02:	f3 66 00 03 	st.b	r9[3],r6
80005e06:	f7 36 00 02 	ld.ub	r6,r11[2]
80005e0a:	f3 66 00 02 	st.b	r9[2],r6
80005e0e:	f7 36 00 01 	ld.ub	r6,r11[1]
80005e12:	f3 66 00 01 	st.b	r9[1],r6
80005e16:	f7 36 00 00 	ld.ub	r6,r11[0]
80005e1a:	f3 66 00 00 	st.b	r9[0],r6
80005e1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e22:	20 1a       	sub	r10,1
80005e24:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80005e28:	f8 0a 0b 09 	st.b	r12[r10],r9
80005e2c:	cf b1       	brne	80005e22 <memcpy+0x13a>
80005e2e:	5e fc       	retal	r12

80005e30 <_sbrk_r>:
80005e30:	d4 21       	pushm	r4-r7,lr
80005e32:	30 08       	mov	r8,0
80005e34:	18 97       	mov	r7,r12
80005e36:	e0 66 0a 54 	mov	r6,2644
80005e3a:	16 9c       	mov	r12,r11
80005e3c:	8d 08       	st.w	r6[0x0],r8
80005e3e:	c0 9c       	rcall	80005e50 <_sbrk>
80005e40:	5b fc       	cp.w	r12,-1
80005e42:	c0 51       	brne	80005e4c <_sbrk_r+0x1c>
80005e44:	6c 08       	ld.w	r8,r6[0x0]
80005e46:	58 08       	cp.w	r8,0
80005e48:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005e4c:	d8 22       	popm	r4-r7,pc
80005e4e:	d7 03       	nop

80005e50 <_sbrk>:
80005e50:	d4 01       	pushm	lr
80005e52:	e0 68 08 40 	mov	r8,2112
80005e56:	70 09       	ld.w	r9,r8[0x0]
80005e58:	58 09       	cp.w	r9,0
80005e5a:	c0 41       	brne	80005e62 <_sbrk+0x12>
80005e5c:	e0 69 0a 58 	mov	r9,2648
80005e60:	91 09       	st.w	r8[0x0],r9
80005e62:	e0 69 08 40 	mov	r9,2112
80005e66:	e0 6a f0 00 	mov	r10,61440
80005e6a:	72 08       	ld.w	r8,r9[0x0]
80005e6c:	f0 0c 00 0c 	add	r12,r8,r12
80005e70:	14 3c       	cp.w	r12,r10
80005e72:	e0 8b 00 04 	brhi	80005e7a <_sbrk+0x2a>
80005e76:	93 0c       	st.w	r9[0x0],r12
80005e78:	c0 58       	rjmp	80005e82 <_sbrk+0x32>
80005e7a:	c0 7c       	rcall	80005e88 <__errno>
80005e7c:	30 c8       	mov	r8,12
80005e7e:	99 08       	st.w	r12[0x0],r8
80005e80:	3f f8       	mov	r8,-1
80005e82:	10 9c       	mov	r12,r8
80005e84:	d8 02       	popm	pc
80005e86:	d7 03       	nop

80005e88 <__errno>:
80005e88:	e0 68 01 40 	mov	r8,320
80005e8c:	70 0c       	ld.w	r12,r8[0x0]
80005e8e:	2f 4c       	sub	r12,-12
80005e90:	5e fc       	retal	r12
80005e92:	d7 03       	nop

80005e94 <_malloc_trim_r>:
80005e94:	d4 21       	pushm	r4-r7,lr
80005e96:	16 95       	mov	r5,r11
80005e98:	18 97       	mov	r7,r12
80005e9a:	fe b0 e9 89 	rcall	800031ac <__malloc_lock>
80005e9e:	e0 64 01 44 	mov	r4,324
80005ea2:	68 28       	ld.w	r8,r4[0x8]
80005ea4:	70 16       	ld.w	r6,r8[0x4]
80005ea6:	e0 16 ff fc 	andl	r6,0xfffc
80005eaa:	ec c8 ff 91 	sub	r8,r6,-111
80005eae:	f0 05 01 05 	sub	r5,r8,r5
80005eb2:	e0 15 ff 80 	andl	r5,0xff80
80005eb6:	ea c5 00 80 	sub	r5,r5,128
80005eba:	e0 45 00 7f 	cp.w	r5,127
80005ebe:	e0 8a 00 22 	brle	80005f02 <_malloc_trim_r+0x6e>
80005ec2:	30 0b       	mov	r11,0
80005ec4:	0e 9c       	mov	r12,r7
80005ec6:	cb 5f       	rcall	80005e30 <_sbrk_r>
80005ec8:	68 28       	ld.w	r8,r4[0x8]
80005eca:	0c 08       	add	r8,r6
80005ecc:	10 3c       	cp.w	r12,r8
80005ece:	c1 a1       	brne	80005f02 <_malloc_trim_r+0x6e>
80005ed0:	ea 0b 11 00 	rsub	r11,r5,0
80005ed4:	0e 9c       	mov	r12,r7
80005ed6:	ca df       	rcall	80005e30 <_sbrk_r>
80005ed8:	5b fc       	cp.w	r12,-1
80005eda:	c1 81       	brne	80005f0a <_malloc_trim_r+0x76>
80005edc:	30 0b       	mov	r11,0
80005ede:	0e 9c       	mov	r12,r7
80005ee0:	ca 8f       	rcall	80005e30 <_sbrk_r>
80005ee2:	68 28       	ld.w	r8,r4[0x8]
80005ee4:	f8 08 01 09 	sub	r9,r12,r8
80005ee8:	58 f9       	cp.w	r9,15
80005eea:	e0 8a 00 0c 	brle	80005f02 <_malloc_trim_r+0x6e>
80005eee:	a1 a9       	sbr	r9,0x0
80005ef0:	91 19       	st.w	r8[0x4],r9
80005ef2:	e0 68 05 50 	mov	r8,1360
80005ef6:	70 09       	ld.w	r9,r8[0x0]
80005ef8:	e0 68 08 18 	mov	r8,2072
80005efc:	f8 09 01 09 	sub	r9,r12,r9
80005f00:	91 09       	st.w	r8[0x0],r9
80005f02:	0e 9c       	mov	r12,r7
80005f04:	fe b0 e9 5a 	rcall	800031b8 <__malloc_unlock>
80005f08:	d8 2a       	popm	r4-r7,pc,r12=0
80005f0a:	68 28       	ld.w	r8,r4[0x8]
80005f0c:	0a 16       	sub	r6,r5
80005f0e:	a1 a6       	sbr	r6,0x0
80005f10:	91 16       	st.w	r8[0x4],r6
80005f12:	e0 68 08 18 	mov	r8,2072
80005f16:	70 09       	ld.w	r9,r8[0x0]
80005f18:	0a 19       	sub	r9,r5
80005f1a:	0e 9c       	mov	r12,r7
80005f1c:	91 09       	st.w	r8[0x0],r9
80005f1e:	fe b0 e9 4d 	rcall	800031b8 <__malloc_unlock>
80005f22:	da 2a       	popm	r4-r7,pc,r12=1

80005f24 <_free_r>:
80005f24:	d4 21       	pushm	r4-r7,lr
80005f26:	16 96       	mov	r6,r11
80005f28:	18 97       	mov	r7,r12
80005f2a:	58 0b       	cp.w	r11,0
80005f2c:	e0 80 00 c0 	breq	800060ac <_free_r+0x188>
80005f30:	fe b0 e9 3e 	rcall	800031ac <__malloc_lock>
80005f34:	20 86       	sub	r6,8
80005f36:	e0 6a 01 44 	mov	r10,324
80005f3a:	6c 18       	ld.w	r8,r6[0x4]
80005f3c:	74 2e       	ld.w	lr,r10[0x8]
80005f3e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005f42:	a1 c8       	cbr	r8,0x0
80005f44:	ec 08 00 09 	add	r9,r6,r8
80005f48:	72 1b       	ld.w	r11,r9[0x4]
80005f4a:	e0 1b ff fc 	andl	r11,0xfffc
80005f4e:	1c 39       	cp.w	r9,lr
80005f50:	c1 e1       	brne	80005f8c <_free_r+0x68>
80005f52:	f6 08 00 08 	add	r8,r11,r8
80005f56:	58 0c       	cp.w	r12,0
80005f58:	c0 81       	brne	80005f68 <_free_r+0x44>
80005f5a:	6c 09       	ld.w	r9,r6[0x0]
80005f5c:	12 16       	sub	r6,r9
80005f5e:	12 08       	add	r8,r9
80005f60:	6c 3b       	ld.w	r11,r6[0xc]
80005f62:	6c 29       	ld.w	r9,r6[0x8]
80005f64:	97 29       	st.w	r11[0x8],r9
80005f66:	93 3b       	st.w	r9[0xc],r11
80005f68:	10 99       	mov	r9,r8
80005f6a:	95 26       	st.w	r10[0x8],r6
80005f6c:	a1 a9       	sbr	r9,0x0
80005f6e:	8d 19       	st.w	r6[0x4],r9
80005f70:	e0 69 05 4c 	mov	r9,1356
80005f74:	72 09       	ld.w	r9,r9[0x0]
80005f76:	12 38       	cp.w	r8,r9
80005f78:	c0 63       	brcs	80005f84 <_free_r+0x60>
80005f7a:	e0 68 08 14 	mov	r8,2068
80005f7e:	0e 9c       	mov	r12,r7
80005f80:	70 0b       	ld.w	r11,r8[0x0]
80005f82:	c8 9f       	rcall	80005e94 <_malloc_trim_r>
80005f84:	0e 9c       	mov	r12,r7
80005f86:	fe b0 e9 19 	rcall	800031b8 <__malloc_unlock>
80005f8a:	d8 22       	popm	r4-r7,pc
80005f8c:	93 1b       	st.w	r9[0x4],r11
80005f8e:	58 0c       	cp.w	r12,0
80005f90:	c0 30       	breq	80005f96 <_free_r+0x72>
80005f92:	30 0c       	mov	r12,0
80005f94:	c1 08       	rjmp	80005fb4 <_free_r+0x90>
80005f96:	6c 0e       	ld.w	lr,r6[0x0]
80005f98:	f4 c5 ff f8 	sub	r5,r10,-8
80005f9c:	1c 16       	sub	r6,lr
80005f9e:	1c 08       	add	r8,lr
80005fa0:	6c 2e       	ld.w	lr,r6[0x8]
80005fa2:	0a 3e       	cp.w	lr,r5
80005fa4:	f9 bc 00 01 	moveq	r12,1
80005fa8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80005fac:	eb fe 1a 02 	st.wne	r5[0x8],lr
80005fb0:	fd f5 1a 03 	st.wne	lr[0xc],r5
80005fb4:	f2 0b 00 0e 	add	lr,r9,r11
80005fb8:	7c 1e       	ld.w	lr,lr[0x4]
80005fba:	ed be 00 00 	bld	lr,0x0
80005fbe:	c1 40       	breq	80005fe6 <_free_r+0xc2>
80005fc0:	16 08       	add	r8,r11
80005fc2:	58 0c       	cp.w	r12,0
80005fc4:	c0 d1       	brne	80005fde <_free_r+0xba>
80005fc6:	e0 6e 01 44 	mov	lr,324
80005fca:	72 2b       	ld.w	r11,r9[0x8]
80005fcc:	2f 8e       	sub	lr,-8
80005fce:	1c 3b       	cp.w	r11,lr
80005fd0:	c0 71       	brne	80005fde <_free_r+0xba>
80005fd2:	97 36       	st.w	r11[0xc],r6
80005fd4:	97 26       	st.w	r11[0x8],r6
80005fd6:	8d 2b       	st.w	r6[0x8],r11
80005fd8:	8d 3b       	st.w	r6[0xc],r11
80005fda:	30 1c       	mov	r12,1
80005fdc:	c0 58       	rjmp	80005fe6 <_free_r+0xc2>
80005fde:	72 2b       	ld.w	r11,r9[0x8]
80005fe0:	72 39       	ld.w	r9,r9[0xc]
80005fe2:	93 2b       	st.w	r9[0x8],r11
80005fe4:	97 39       	st.w	r11[0xc],r9
80005fe6:	10 99       	mov	r9,r8
80005fe8:	ec 08 09 08 	st.w	r6[r8],r8
80005fec:	a1 a9       	sbr	r9,0x0
80005fee:	8d 19       	st.w	r6[0x4],r9
80005ff0:	58 0c       	cp.w	r12,0
80005ff2:	c5 a1       	brne	800060a6 <_free_r+0x182>
80005ff4:	e0 48 01 ff 	cp.w	r8,511
80005ff8:	e0 8b 00 13 	brhi	8000601e <_free_r+0xfa>
80005ffc:	a3 98       	lsr	r8,0x3
80005ffe:	f4 08 00 39 	add	r9,r10,r8<<0x3
80006002:	72 2b       	ld.w	r11,r9[0x8]
80006004:	8d 39       	st.w	r6[0xc],r9
80006006:	8d 2b       	st.w	r6[0x8],r11
80006008:	97 36       	st.w	r11[0xc],r6
8000600a:	93 26       	st.w	r9[0x8],r6
8000600c:	a3 48       	asr	r8,0x2
8000600e:	74 19       	ld.w	r9,r10[0x4]
80006010:	30 1b       	mov	r11,1
80006012:	f6 08 09 48 	lsl	r8,r11,r8
80006016:	f3 e8 10 08 	or	r8,r9,r8
8000601a:	95 18       	st.w	r10[0x4],r8
8000601c:	c4 58       	rjmp	800060a6 <_free_r+0x182>
8000601e:	f0 0b 16 09 	lsr	r11,r8,0x9
80006022:	58 4b       	cp.w	r11,4
80006024:	e0 8b 00 06 	brhi	80006030 <_free_r+0x10c>
80006028:	f0 0b 16 06 	lsr	r11,r8,0x6
8000602c:	2c 8b       	sub	r11,-56
8000602e:	c2 08       	rjmp	8000606e <_free_r+0x14a>
80006030:	59 4b       	cp.w	r11,20
80006032:	e0 8b 00 04 	brhi	8000603a <_free_r+0x116>
80006036:	2a 5b       	sub	r11,-91
80006038:	c1 b8       	rjmp	8000606e <_free_r+0x14a>
8000603a:	e0 4b 00 54 	cp.w	r11,84
8000603e:	e0 8b 00 06 	brhi	8000604a <_free_r+0x126>
80006042:	f0 0b 16 0c 	lsr	r11,r8,0xc
80006046:	29 2b       	sub	r11,-110
80006048:	c1 38       	rjmp	8000606e <_free_r+0x14a>
8000604a:	e0 4b 01 54 	cp.w	r11,340
8000604e:	e0 8b 00 06 	brhi	8000605a <_free_r+0x136>
80006052:	f0 0b 16 0f 	lsr	r11,r8,0xf
80006056:	28 9b       	sub	r11,-119
80006058:	c0 b8       	rjmp	8000606e <_free_r+0x14a>
8000605a:	e0 4b 05 54 	cp.w	r11,1364
8000605e:	e0 88 00 05 	brls	80006068 <_free_r+0x144>
80006062:	37 eb       	mov	r11,126
80006064:	c0 58       	rjmp	8000606e <_free_r+0x14a>
80006066:	d7 03       	nop
80006068:	f0 0b 16 12 	lsr	r11,r8,0x12
8000606c:	28 4b       	sub	r11,-124
8000606e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80006072:	78 29       	ld.w	r9,r12[0x8]
80006074:	18 39       	cp.w	r9,r12
80006076:	c0 e1       	brne	80006092 <_free_r+0x16e>
80006078:	74 18       	ld.w	r8,r10[0x4]
8000607a:	a3 4b       	asr	r11,0x2
8000607c:	30 1c       	mov	r12,1
8000607e:	f8 0b 09 4b 	lsl	r11,r12,r11
80006082:	f1 eb 10 0b 	or	r11,r8,r11
80006086:	12 98       	mov	r8,r9
80006088:	95 1b       	st.w	r10[0x4],r11
8000608a:	c0 a8       	rjmp	8000609e <_free_r+0x17a>
8000608c:	72 29       	ld.w	r9,r9[0x8]
8000608e:	18 39       	cp.w	r9,r12
80006090:	c0 60       	breq	8000609c <_free_r+0x178>
80006092:	72 1a       	ld.w	r10,r9[0x4]
80006094:	e0 1a ff fc 	andl	r10,0xfffc
80006098:	14 38       	cp.w	r8,r10
8000609a:	cf 93       	brcs	8000608c <_free_r+0x168>
8000609c:	72 38       	ld.w	r8,r9[0xc]
8000609e:	8d 38       	st.w	r6[0xc],r8
800060a0:	8d 29       	st.w	r6[0x8],r9
800060a2:	93 36       	st.w	r9[0xc],r6
800060a4:	91 26       	st.w	r8[0x8],r6
800060a6:	0e 9c       	mov	r12,r7
800060a8:	fe b0 e8 88 	rcall	800031b8 <__malloc_unlock>
800060ac:	d8 22       	popm	r4-r7,pc
800060ae:	d7 03       	nop

Disassembly of section .exception:

80006200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80006200:	c0 08       	rjmp	80006200 <_evba>
	...

80006204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80006204:	c0 08       	rjmp	80006204 <_handle_TLB_Multiple_Hit>
	...

80006208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80006208:	c0 08       	rjmp	80006208 <_handle_Bus_Error_Data_Fetch>
	...

8000620c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000620c:	c0 08       	rjmp	8000620c <_handle_Bus_Error_Instruction_Fetch>
	...

80006210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80006210:	c0 08       	rjmp	80006210 <_handle_NMI>
	...

80006214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80006214:	c0 08       	rjmp	80006214 <_handle_Instruction_Address>
	...

80006218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80006218:	c0 08       	rjmp	80006218 <_handle_ITLB_Protection>
	...

8000621c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000621c:	c0 08       	rjmp	8000621c <_handle_Breakpoint>
	...

80006220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80006220:	c0 08       	rjmp	80006220 <_handle_Illegal_Opcode>
	...

80006224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80006224:	c0 08       	rjmp	80006224 <_handle_Unimplemented_Instruction>
	...

80006228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80006228:	c0 08       	rjmp	80006228 <_handle_Privilege_Violation>
	...

8000622c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000622c:	c0 08       	rjmp	8000622c <_handle_Floating_Point>
	...

80006230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80006230:	c0 08       	rjmp	80006230 <_handle_Coprocessor_Absent>
	...

80006234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80006234:	c0 08       	rjmp	80006234 <_handle_Data_Address_Read>
	...

80006238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80006238:	c0 08       	rjmp	80006238 <_handle_Data_Address_Write>
	...

8000623c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000623c:	c0 08       	rjmp	8000623c <_handle_DTLB_Protection_Read>
	...

80006240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80006240:	c0 08       	rjmp	80006240 <_handle_DTLB_Protection_Write>
	...

80006244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80006244:	c0 08       	rjmp	80006244 <_handle_DTLB_Modified>
	...

80006250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80006250:	c0 08       	rjmp	80006250 <_handle_ITLB_Miss>
	...

80006260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80006260:	c0 08       	rjmp	80006260 <_handle_DTLB_Miss_Read>
	...

80006270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80006270:	c0 08       	rjmp	80006270 <_handle_DTLB_Miss_Write>
	...

80006300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80006300:	fe cf 32 9c 	sub	pc,pc,12956

80006304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80006304:	30 0c       	mov	r12,0
80006306:	fe b0 ef 6d 	rcall	800041e0 <_get_interrupt_handler>
8000630a:	58 0c       	cp.w	r12,0
8000630c:	f8 0f 17 10 	movne	pc,r12
80006310:	d6 03       	rete

80006312 <_int1>:
80006312:	30 1c       	mov	r12,1
80006314:	fe b0 ef 66 	rcall	800041e0 <_get_interrupt_handler>
80006318:	58 0c       	cp.w	r12,0
8000631a:	f8 0f 17 10 	movne	pc,r12
8000631e:	d6 03       	rete

80006320 <_int2>:
80006320:	30 2c       	mov	r12,2
80006322:	fe b0 ef 5f 	rcall	800041e0 <_get_interrupt_handler>
80006326:	58 0c       	cp.w	r12,0
80006328:	f8 0f 17 10 	movne	pc,r12
8000632c:	d6 03       	rete

8000632e <_int3>:
8000632e:	30 3c       	mov	r12,3
80006330:	fe b0 ef 58 	rcall	800041e0 <_get_interrupt_handler>
80006334:	58 0c       	cp.w	r12,0
80006336:	f8 0f 17 10 	movne	pc,r12
8000633a:	d6 03       	rete
8000633c:	d7 03       	nop
8000633e:	d7 03       	nop
80006340:	d7 03       	nop
80006342:	d7 03       	nop
80006344:	d7 03       	nop
80006346:	d7 03       	nop
80006348:	d7 03       	nop
8000634a:	d7 03       	nop
8000634c:	d7 03       	nop
8000634e:	d7 03       	nop
80006350:	d7 03       	nop
80006352:	d7 03       	nop
80006354:	d7 03       	nop
80006356:	d7 03       	nop
80006358:	d7 03       	nop
8000635a:	d7 03       	nop
8000635c:	d7 03       	nop
8000635e:	d7 03       	nop
80006360:	d7 03       	nop
80006362:	d7 03       	nop
80006364:	d7 03       	nop
80006366:	d7 03       	nop
80006368:	d7 03       	nop
8000636a:	d7 03       	nop
8000636c:	d7 03       	nop
8000636e:	d7 03       	nop
80006370:	d7 03       	nop
80006372:	d7 03       	nop
80006374:	d7 03       	nop
80006376:	d7 03       	nop
80006378:	d7 03       	nop
8000637a:	d7 03       	nop
8000637c:	d7 03       	nop
8000637e:	d7 03       	nop
80006380:	d7 03       	nop
80006382:	d7 03       	nop
80006384:	d7 03       	nop
80006386:	d7 03       	nop
80006388:	d7 03       	nop
8000638a:	d7 03       	nop
8000638c:	d7 03       	nop
8000638e:	d7 03       	nop
80006390:	d7 03       	nop
80006392:	d7 03       	nop
80006394:	d7 03       	nop
80006396:	d7 03       	nop
80006398:	d7 03       	nop
8000639a:	d7 03       	nop
8000639c:	d7 03       	nop
8000639e:	d7 03       	nop
800063a0:	d7 03       	nop
800063a2:	d7 03       	nop
800063a4:	d7 03       	nop
800063a6:	d7 03       	nop
800063a8:	d7 03       	nop
800063aa:	d7 03       	nop
800063ac:	d7 03       	nop
800063ae:	d7 03       	nop
800063b0:	d7 03       	nop
800063b2:	d7 03       	nop
800063b4:	d7 03       	nop
800063b6:	d7 03       	nop
800063b8:	d7 03       	nop
800063ba:	d7 03       	nop
800063bc:	d7 03       	nop
800063be:	d7 03       	nop
800063c0:	d7 03       	nop
800063c2:	d7 03       	nop
800063c4:	d7 03       	nop
800063c6:	d7 03       	nop
800063c8:	d7 03       	nop
800063ca:	d7 03       	nop
800063cc:	d7 03       	nop
800063ce:	d7 03       	nop
800063d0:	d7 03       	nop
800063d2:	d7 03       	nop
800063d4:	d7 03       	nop
800063d6:	d7 03       	nop
800063d8:	d7 03       	nop
800063da:	d7 03       	nop
800063dc:	d7 03       	nop
800063de:	d7 03       	nop
800063e0:	d7 03       	nop
800063e2:	d7 03       	nop
800063e4:	d7 03       	nop
800063e6:	d7 03       	nop
800063e8:	d7 03       	nop
800063ea:	d7 03       	nop
800063ec:	d7 03       	nop
800063ee:	d7 03       	nop
800063f0:	d7 03       	nop
800063f2:	d7 03       	nop
800063f4:	d7 03       	nop
800063f6:	d7 03       	nop
800063f8:	d7 03       	nop
800063fa:	d7 03       	nop
800063fc:	d7 03       	nop
800063fe:	d7 03       	nop
