
finalProject.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00007518  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80009600  80009600  00009a00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000009cc  80009800  80009800  00009c00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000a1cc  8000a1cc  0000a5cc  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000514  00000008  8000a1d0  0000a808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  0000051c  8000a6e4  0000ad1c  2**0
                  ALLOC
  9 .bss          00000ab0  00000520  00000520  00000000  2**2
                  ALLOC
 10 .heap         0000e030  00000fd0  00000fd0  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  0000ad1c  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001a30  00000000  00000000  0000ad50  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 000045aa  00000000  00000000  0000c780  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   00025b5c  00000000  00000000  00010d2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000059eb  00000000  00000000  00036886  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   00015a59  00000000  00000000  0003c271  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00004af0  00000000  00000000  00051ccc  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00008b58  00000000  00000000  000567bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000e215  00000000  00000000  0005f314  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macinfo 01d6f5f8  00000000  00000000  0006d529  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 22 .debug_ranges 00001cc8  00000000  00000000  01ddcb28  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	82 8c       	ld.uh	r12,r1[0x0]

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 9d 7c 	sub	pc,pc,-25220

Disassembly of section .text:

8000200c <et024006_SetLimits>:
8000200c:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002010:	fc 1e c0 00 	movh	lr,0xc000
80002014:	30 28       	mov	r8,2
80002016:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002018:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
8000201c:	fc 18 c0 20 	movh	r8,0xc020
80002020:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002022:	30 37       	mov	r7,3
80002024:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002026:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002028:	30 4c       	mov	r12,4
8000202a:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000202c:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80002030:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002032:	30 5c       	mov	r12,5
80002034:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002036:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002038:	30 6a       	mov	r10,6
8000203a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000203c:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80002040:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002042:	30 7a       	mov	r10,7
80002044:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002046:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002048:	30 8a       	mov	r10,8
8000204a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000204c:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80002050:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002052:	30 9a       	mov	r10,9
80002054:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002056:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80002058:	e3 cd 80 80 	ldm	sp++,r7,pc

8000205c <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000205c:	fc 19 c0 00 	movh	r9,0xc000
80002060:	30 28       	mov	r8,2
80002062:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002064:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80002068:	fc 18 c0 20 	movh	r8,0xc020
8000206c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000206e:	30 3a       	mov	r10,3
80002070:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002072:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002074:	30 6a       	mov	r10,6
80002076:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002078:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
8000207c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000207e:	30 7a       	mov	r10,7
80002080:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002082:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80002084:	5e fc       	retal	r12
80002086:	d7 03       	nop

80002088 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80002088:	eb cd 40 80 	pushm	r7,lr
8000208c:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
8000208e:	5c 7b       	castu.h	r11
80002090:	5c 7c       	castu.h	r12
80002092:	f0 1f 00 06 	mcall	800020a8 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002096:	32 29       	mov	r9,34
80002098:	fc 18 c0 00 	movh	r8,0xc000
8000209c:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000209e:	fc 18 c0 20 	movh	r8,0xc020
800020a2:	b0 07       	st.h	r8[0x0],r7
#endif

}
800020a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	20 5c       	sub	r12,5

800020ac <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
800020ac:	d4 31       	pushm	r0-r7,lr
800020ae:	20 dd       	sub	sp,52
800020b0:	18 97       	mov	r7,r12
800020b2:	50 6b       	stdsp	sp[0x18],r11
800020b4:	50 8a       	stdsp	sp[0x20],r10
800020b6:	50 29       	stdsp	sp[0x8],r9
800020b8:	10 94       	mov	r4,r8
800020ba:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
800020bc:	19 89       	ld.ub	r9,r12[0x0]
800020be:	30 08       	mov	r8,0
800020c0:	f0 09 18 00 	cp.b	r9,r8
800020c4:	e0 80 01 0c 	breq	800022dc <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800020c8:	16 98       	mov	r8,r11
800020ca:	11 3a       	ld.ub	r10,r8++
800020cc:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
800020ce:	11 89       	ld.ub	r9,r8[0x0]
800020d0:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
800020d2:	11 98       	ld.ub	r8,r8[0x1]
800020d4:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
800020d6:	5b f3       	cp.w	r3,-1
800020d8:	e0 81 00 8d 	brne	800021f2 <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800020dc:	e0 69 00 ef 	mov	r9,239
800020e0:	e0 6a 01 3f 	mov	r10,319
800020e4:	30 0b       	mov	r11,0
800020e6:	16 9c       	mov	r12,r11
800020e8:	f0 1f 00 7e 	mcall	800022e0 <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800020ec:	40 58       	lddsp	r8,sp[0x14]
800020ee:	50 c8       	stdsp	sp[0x30],r8
800020f0:	f0 08 00 18 	add	r8,r8,r8<<0x1
800020f4:	a5 78       	lsl	r8,0x5
800020f6:	40 69       	lddsp	r9,sp[0x18]
800020f8:	10 09       	add	r9,r8
800020fa:	50 b9       	stdsp	sp[0x2c],r9
800020fc:	ee c8 ff ff 	sub	r8,r7,-1
80002100:	50 98       	stdsp	sp[0x24],r8
80002102:	40 8a       	lddsp	r10,sp[0x20]
80002104:	5c 8a       	casts.h	r10
80002106:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002108:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000210a:	08 90       	mov	r0,r4
8000210c:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
8000210e:	40 99       	lddsp	r9,sp[0x24]
80002110:	f3 38 ff ff 	ld.ub	r8,r9[-1]
80002114:	30 aa       	mov	r10,10
80002116:	f4 08 18 00 	cp.b	r8,r10
8000211a:	c0 b1       	brne	80002130 <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
8000211c:	40 28       	lddsp	r8,sp[0x8]
8000211e:	40 39       	lddsp	r9,sp[0xc]
80002120:	12 08       	add	r8,r9
80002122:	5c 88       	casts.h	r8
80002124:	50 28       	stdsp	sp[0x8],r8
80002126:	40 98       	lddsp	r8,sp[0x24]
80002128:	40 8a       	lddsp	r10,sp[0x20]
8000212a:	5c 8a       	casts.h	r10
8000212c:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000212e:	c5 a8       	rjmp	800021e2 <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
80002130:	30 99       	mov	r9,9
80002132:	f2 08 18 00 	cp.b	r8,r9
80002136:	c0 81       	brne	80002146 <et024006_PrintString+0x9a>
        x += xfont;
80002138:	40 a8       	lddsp	r8,sp[0x28]
8000213a:	40 49       	lddsp	r9,sp[0x10]
8000213c:	12 08       	add	r8,r9
8000213e:	5c 88       	casts.h	r8
80002140:	50 a8       	stdsp	sp[0x28],r8
80002142:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80002144:	c4 f8       	rjmp	800021e2 <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80002146:	f0 ca 00 20 	sub	r10,r8,32
8000214a:	35 f9       	mov	r9,95
8000214c:	f2 0a 18 00 	cp.b	r10,r9
80002150:	e0 88 00 04 	brls	80002158 <et024006_PrintString+0xac>
80002154:	40 b5       	lddsp	r5,sp[0x2c]
80002156:	c0 a8       	rjmp	8000216a <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80002158:	22 08       	sub	r8,32
8000215a:	40 ca       	lddsp	r10,sp[0x30]
8000215c:	f0 0a 02 45 	mul	r5,r8,r10
80002160:	40 59       	lddsp	r9,sp[0x14]
80002162:	12 05       	add	r5,r9
80002164:	40 68       	lddsp	r8,sp[0x18]
80002166:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000216a:	40 22       	lddsp	r2,sp[0x8]
8000216c:	5c 72       	castu.h	r2
8000216e:	40 3a       	lddsp	r10,sp[0xc]
80002170:	e4 0a 00 0a 	add	r10,r2,r10
80002174:	50 1a       	stdsp	sp[0x4],r10
80002176:	04 3a       	cp.w	r10,r2
80002178:	e0 8a 00 2f 	brle	800021d6 <et024006_PrintString+0x12a>
8000217c:	40 21       	lddsp	r1,sp[0x8]
8000217e:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80002180:	40 a9       	lddsp	r9,sp[0x28]
80002182:	5c 79       	castu.h	r9
80002184:	50 09       	stdsp	sp[0x0],r9
80002186:	12 94       	mov	r4,r9
80002188:	40 48       	lddsp	r8,sp[0x10]
8000218a:	10 04       	add	r4,r8
8000218c:	40 aa       	lddsp	r10,sp[0x28]
8000218e:	5c 8a       	casts.h	r10
80002190:	50 7a       	stdsp	sp[0x1c],r10
80002192:	c1 b8       	rjmp	800021c8 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80002194:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002196:	0b 88       	ld.ub	r8,r5[0x0]
80002198:	ed e8 00 08 	and	r8,r6,r8
8000219c:	e6 08 18 00 	cp.b	r8,r3
800021a0:	c0 50       	breq	800021aa <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800021a2:	00 9a       	mov	r10,r0
800021a4:	04 9b       	mov	r11,r2
800021a6:	f0 1f 00 50 	mcall	800022e4 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021aa:	2f f7       	sub	r7,-1
800021ac:	5c 87       	casts.h	r7
800021ae:	0e 9c       	mov	r12,r7
800021b0:	5c 7c       	castu.h	r12
800021b2:	08 3c       	cp.w	r12,r4
800021b4:	cf 05       	brlt	80002194 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800021b6:	2f f1       	sub	r1,-1
800021b8:	5c 81       	casts.h	r1
800021ba:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
800021be:	40 19       	lddsp	r9,sp[0x4]
800021c0:	04 39       	cp.w	r9,r2
800021c2:	e0 8a 00 0a 	brle	800021d6 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800021c6:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021c8:	40 0c       	lddsp	r12,sp[0x0]
800021ca:	08 3c       	cp.w	r12,r4
800021cc:	cf 54       	brge	800021b6 <et024006_PrintString+0x10a>
800021ce:	40 77       	lddsp	r7,sp[0x1c]
800021d0:	e0 66 00 80 	mov	r6,128
800021d4:	ce 1b       	rjmp	80002196 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800021d6:	40 a8       	lddsp	r8,sp[0x28]
800021d8:	40 4a       	lddsp	r10,sp[0x10]
800021da:	14 08       	add	r8,r10
800021dc:	5c 88       	casts.h	r8
800021de:	50 a8       	stdsp	sp[0x28],r8
800021e0:	40 98       	lddsp	r8,sp[0x24]
800021e2:	40 99       	lddsp	r9,sp[0x24]
800021e4:	2f f9       	sub	r9,-1
800021e6:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800021e8:	11 88       	ld.ub	r8,r8[0x0]
800021ea:	e6 08 18 00 	cp.b	r8,r3
800021ee:	c9 01       	brne	8000210e <et024006_PrintString+0x62>
800021f0:	c7 68       	rjmp	800022dc <et024006_PrintString+0x230>
800021f2:	f8 c8 ff ff 	sub	r8,r12,-1
800021f6:	50 08       	stdsp	sp[0x0],r8
800021f8:	40 8c       	lddsp	r12,sp[0x20]
800021fa:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800021fc:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800021fe:	5c 83       	casts.h	r3
80002200:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80002204:	40 0a       	lddsp	r10,sp[0x0]
80002206:	f5 31 ff ff 	ld.ub	r1,r10[-1]
8000220a:	30 a8       	mov	r8,10
8000220c:	f0 01 18 00 	cp.b	r1,r8
80002210:	c0 b1       	brne	80002226 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
80002212:	40 28       	lddsp	r8,sp[0x8]
80002214:	40 39       	lddsp	r9,sp[0xc]
80002216:	12 08       	add	r8,r9
80002218:	5c 88       	casts.h	r8
8000221a:	50 28       	stdsp	sp[0x8],r8
8000221c:	14 98       	mov	r8,r10
8000221e:	40 8a       	lddsp	r10,sp[0x20]
80002220:	5c 8a       	casts.h	r10
80002222:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80002224:	c5 28       	rjmp	800022c8 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80002226:	30 98       	mov	r8,9
80002228:	f0 01 18 00 	cp.b	r1,r8
8000222c:	c0 71       	brne	8000223a <et024006_PrintString+0x18e>
        x += xfont;
8000222e:	40 49       	lddsp	r9,sp[0x10]
80002230:	12 0c       	add	r12,r9
80002232:	5c 8c       	casts.h	r12
80002234:	50 1c       	stdsp	sp[0x4],r12
80002236:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
80002238:	c4 88       	rjmp	800022c8 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000223a:	40 32       	lddsp	r2,sp[0xc]
8000223c:	40 47       	lddsp	r7,sp[0x10]
8000223e:	f8 07 00 08 	add	r8,r12,r7
80002242:	5c 88       	casts.h	r8
80002244:	50 18       	stdsp	sp[0x4],r8
80002246:	04 99       	mov	r9,r2
80002248:	20 19       	sub	r9,1
8000224a:	40 28       	lddsp	r8,sp[0x8]
8000224c:	10 09       	add	r9,r8
8000224e:	40 1a       	lddsp	r10,sp[0x4]
80002250:	20 1a       	sub	r10,1
80002252:	5c 79       	castu.h	r9
80002254:	5c 7a       	castu.h	r10
80002256:	10 9b       	mov	r11,r8
80002258:	5c 7b       	castu.h	r11
8000225a:	5c 7c       	castu.h	r12
8000225c:	f0 1f 00 21 	mcall	800022e0 <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002260:	32 29       	mov	r9,34
80002262:	fc 18 c0 00 	movh	r8,0xc000
80002266:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80002268:	40 3a       	lddsp	r10,sp[0xc]
8000226a:	58 0a       	cp.w	r10,0
8000226c:	c2 d0       	breq	800022c6 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
8000226e:	e2 ce 00 20 	sub	lr,r1,32
80002272:	40 59       	lddsp	r9,sp[0x14]
80002274:	f2 0e 02 4e 	mul	lr,r9,lr
80002278:	12 0e       	add	lr,r9
8000227a:	40 68       	lddsp	r8,sp[0x18]
8000227c:	f0 0e 00 0e 	add	lr,r8,lr
80002280:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80002282:	e0 60 00 80 	mov	r0,128
80002286:	18 91       	mov	r1,r12
80002288:	c1 98       	rjmp	800022ba <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
8000228a:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000228c:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
80002290:	ec 0a 18 00 	cp.b	r10,r6
80002294:	e8 0a 17 10 	movne	r10,r4
80002298:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000229c:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800022a0:	2f f8       	sub	r8,-1
800022a2:	5c 88       	casts.h	r8
800022a4:	f0 07 19 00 	cp.h	r7,r8
800022a8:	fe 9b ff f1 	brhi	8000228a <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800022ac:	2f fc       	sub	r12,-1
800022ae:	5c 8c       	casts.h	r12
800022b0:	f8 02 19 00 	cp.h	r2,r12
800022b4:	e0 88 00 09 	brls	800022c6 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
800022b8:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800022ba:	58 07       	cp.w	r7,0
800022bc:	cf 80       	breq	800022ac <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
800022be:	1d 8b       	ld.ub	r11,lr[0x0]
800022c0:	00 99       	mov	r9,r0
800022c2:	02 98       	mov	r8,r1
800022c4:	ce 4b       	rjmp	8000228c <et024006_PrintString+0x1e0>
800022c6:	40 08       	lddsp	r8,sp[0x0]
800022c8:	40 09       	lddsp	r9,sp[0x0]
800022ca:	2f f9       	sub	r9,-1
800022cc:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800022ce:	11 88       	ld.ub	r8,r8[0x0]
800022d0:	ec 08 18 00 	cp.b	r8,r6
800022d4:	c0 40       	breq	800022dc <et024006_PrintString+0x230>
800022d6:	40 1c       	lddsp	r12,sp[0x4]
800022d8:	5c 8c       	casts.h	r12
800022da:	c9 5b       	rjmp	80002204 <et024006_PrintString+0x158>
  }
}
800022dc:	2f 3d       	sub	sp,-52
800022de:	d8 32       	popm	r0-r7,pc
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	20 0c       	sub	r12,0
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	20 88       	sub	r8,8

800022e8 <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800022e8:	32 29       	mov	r9,34
800022ea:	fc 18 c0 00 	movh	r8,0xc000
800022ee:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800022f0:	58 7b       	cp.w	r11,7
800022f2:	e0 88 00 13 	brls	80002318 <et024006_DuplicatePixel+0x30>
800022f6:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
800022f8:	fc 18 c0 20 	movh	r8,0xc020
800022fc:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800022fe:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002300:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002302:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002304:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002306:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002308:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000230a:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
8000230c:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000230e:	58 79       	cp.w	r9,7
80002310:	fe 9b ff f6 	brhi	800022fc <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80002314:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002318:	58 0b       	cp.w	r11,0
8000231a:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
8000231c:	fc 18 c0 20 	movh	r8,0xc020
80002320:	b0 0c       	st.h	r8[0x0],r12
    --count;
80002322:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002324:	cf e1       	brne	80002320 <et024006_DuplicatePixel+0x38>
80002326:	5e fc       	retal	r12

80002328 <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80002328:	eb cd 40 e0 	pushm	r5-r7,lr
8000232c:	14 97       	mov	r7,r10
8000232e:	12 96       	mov	r6,r9
80002330:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80002332:	f6 c9 00 01 	sub	r9,r11,1
80002336:	0c 09       	add	r9,r6
80002338:	f8 ca 00 01 	sub	r10,r12,1
8000233c:	0e 0a       	add	r10,r7
8000233e:	5c 79       	castu.h	r9
80002340:	5c 7a       	castu.h	r10
80002342:	5c 7b       	castu.h	r11
80002344:	5c 7c       	castu.h	r12
80002346:	f0 1f 00 07 	mcall	80002360 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000234a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000234e:	5c 77       	castu.h	r7
80002350:	af 3b       	mul	r11,r7
80002352:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80002356:	f0 1f 00 04 	mcall	80002364 <et024006_DrawFilledRect+0x3c>
}
8000235a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	20 0c       	sub	r12,0
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	22 e8       	sub	r8,46

80002368 <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002368:	fc 19 c0 00 	movh	r9,0xc000
8000236c:	34 6a       	mov	r10,70
8000236e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002370:	fc 18 c0 20 	movh	r8,0xc020
80002374:	e0 6b 00 94 	mov	r11,148
80002378:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000237a:	34 7b       	mov	r11,71
8000237c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000237e:	34 1b       	mov	r11,65
80002380:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002382:	34 8b       	mov	r11,72
80002384:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002386:	30 0b       	mov	r11,0
80002388:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000238a:	34 9b       	mov	r11,73
8000238c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000238e:	33 3b       	mov	r11,51
80002390:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002392:	34 ab       	mov	r11,74
80002394:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002396:	32 5b       	mov	r11,37
80002398:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000239a:	34 bb       	mov	r11,75
8000239c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000239e:	34 5b       	mov	r11,69
800023a0:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023a2:	34 cb       	mov	r11,76
800023a4:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023a6:	34 4b       	mov	r11,68
800023a8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023aa:	34 db       	mov	r11,77
800023ac:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023ae:	37 7b       	mov	r11,119
800023b0:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023b2:	34 eb       	mov	r11,78
800023b4:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023b6:	31 2b       	mov	r11,18
800023b8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023ba:	34 fb       	mov	r11,79
800023bc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023be:	e0 6b 00 cc 	mov	r11,204
800023c2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023c4:	35 0b       	mov	r11,80
800023c6:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023c8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023ca:	35 1a       	mov	r10,81
800023cc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800023ce:	e0 69 00 82 	mov	r9,130
800023d2:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
800023d4:	5e fc       	retal	r12
800023d6:	d7 03       	nop

800023d8 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
800023d8:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
800023dc:	fe f7 04 80 	ld.w	r7,pc[1152]
800023e0:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
800023e2:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
800023e4:	16 9c       	mov	r12,r11
800023e6:	f0 1f 01 1f 	mcall	80002860 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
800023ea:	35 5c       	mov	r12,85
800023ec:	f0 1f 01 1e 	mcall	80002864 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
800023f0:	30 2b       	mov	r11,2
800023f2:	33 2c       	mov	r12,50
800023f4:	f0 1f 01 1d 	mcall	80002868 <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800023f8:	35 2c       	mov	r12,82
800023fa:	f0 1f 01 1d 	mcall	8000286c <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
800023fe:	35 2c       	mov	r12,82
80002400:	f0 1f 01 1c 	mcall	80002870 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002404:	6e 07       	ld.w	r7,r7[0x0]
80002406:	33 28       	mov	r8,50
80002408:	ee 08 06 46 	mulu.d	r6,r7,r8
8000240c:	ee 78 42 40 	mov	r8,1000000
80002410:	30 09       	mov	r9,0
80002412:	ee 7a 42 3f 	mov	r10,999999
80002416:	30 0b       	mov	r11,0
80002418:	ec 0a 00 0a 	add	r10,r6,r10
8000241c:	ee 0b 00 4b 	adc	r11,r7,r11
80002420:	f0 1f 01 15 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002424:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002428:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000242c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002430:	14 38       	cp.w	r8,r10
80002432:	e0 88 00 09 	brls	80002444 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002436:	12 38       	cp.w	r8,r9
80002438:	fe 98 ff fa 	brls	8000242c <et024006_Init+0x54>
8000243c:	12 3a       	cp.w	r10,r9
8000243e:	e0 83 00 a2 	brlo	80002582 <et024006_Init+0x1aa>
80002442:	cf 5b       	rjmp	8000242c <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002444:	12 38       	cp.w	r8,r9
80002446:	e0 8b 00 9e 	brhi	80002582 <et024006_Init+0x1aa>
8000244a:	12 3a       	cp.w	r10,r9
8000244c:	e0 83 00 9b 	brlo	80002582 <et024006_Init+0x1aa>
80002450:	ce eb       	rjmp	8000242c <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002452:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002456:	14 38       	cp.w	r8,r10
80002458:	e0 88 00 09 	brls	8000246a <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000245c:	12 38       	cp.w	r8,r9
8000245e:	fe 98 ff fa 	brls	80002452 <et024006_Init+0x7a>
80002462:	12 3a       	cp.w	r10,r9
80002464:	e0 83 00 a9 	brlo	800025b6 <et024006_Init+0x1de>
80002468:	cf 5b       	rjmp	80002452 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000246a:	12 38       	cp.w	r8,r9
8000246c:	e0 8b 00 a5 	brhi	800025b6 <et024006_Init+0x1de>
80002470:	12 3a       	cp.w	r10,r9
80002472:	e0 83 00 a2 	brlo	800025b6 <et024006_Init+0x1de>
80002476:	ce eb       	rjmp	80002452 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002478:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000247c:	14 38       	cp.w	r8,r10
8000247e:	e0 88 00 09 	brls	80002490 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002482:	12 38       	cp.w	r8,r9
80002484:	fe 98 ff fa 	brls	80002478 <et024006_Init+0xa0>
80002488:	12 3a       	cp.w	r10,r9
8000248a:	e0 83 01 1e 	brlo	800026c6 <et024006_Init+0x2ee>
8000248e:	cf 5b       	rjmp	80002478 <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002490:	12 38       	cp.w	r8,r9
80002492:	e0 8b 01 1a 	brhi	800026c6 <et024006_Init+0x2ee>
80002496:	12 3a       	cp.w	r10,r9
80002498:	e0 83 01 17 	brlo	800026c6 <et024006_Init+0x2ee>
8000249c:	ce eb       	rjmp	80002478 <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000249e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024a2:	14 38       	cp.w	r8,r10
800024a4:	e0 88 00 09 	brls	800024b6 <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024a8:	12 38       	cp.w	r8,r9
800024aa:	fe 98 ff fa 	brls	8000249e <et024006_Init+0xc6>
800024ae:	12 3a       	cp.w	r10,r9
800024b0:	e0 83 01 29 	brlo	80002702 <et024006_Init+0x32a>
800024b4:	cf 5b       	rjmp	8000249e <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024b6:	12 38       	cp.w	r8,r9
800024b8:	e0 8b 01 25 	brhi	80002702 <et024006_Init+0x32a>
800024bc:	12 3a       	cp.w	r10,r9
800024be:	e0 83 01 22 	brlo	80002702 <et024006_Init+0x32a>
800024c2:	ce eb       	rjmp	8000249e <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024c4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024c8:	14 38       	cp.w	r8,r10
800024ca:	e0 88 00 09 	brls	800024dc <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024ce:	12 38       	cp.w	r8,r9
800024d0:	fe 98 ff fa 	brls	800024c4 <et024006_Init+0xec>
800024d4:	12 3a       	cp.w	r10,r9
800024d6:	e0 83 01 35 	brlo	80002740 <et024006_Init+0x368>
800024da:	cf 5b       	rjmp	800024c4 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024dc:	12 38       	cp.w	r8,r9
800024de:	e0 8b 01 31 	brhi	80002740 <et024006_Init+0x368>
800024e2:	12 3a       	cp.w	r10,r9
800024e4:	e0 83 01 2e 	brlo	80002740 <et024006_Init+0x368>
800024e8:	ce eb       	rjmp	800024c4 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024ea:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024ee:	14 38       	cp.w	r8,r10
800024f0:	e0 88 00 09 	brls	80002502 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024f4:	12 38       	cp.w	r8,r9
800024f6:	fe 98 ff fa 	brls	800024ea <et024006_Init+0x112>
800024fa:	12 3a       	cp.w	r10,r9
800024fc:	e0 83 01 40 	brlo	8000277c <et024006_Init+0x3a4>
80002500:	cf 5b       	rjmp	800024ea <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002502:	12 38       	cp.w	r8,r9
80002504:	e0 8b 01 3c 	brhi	8000277c <et024006_Init+0x3a4>
80002508:	12 3a       	cp.w	r10,r9
8000250a:	e0 83 01 39 	brlo	8000277c <et024006_Init+0x3a4>
8000250e:	ce eb       	rjmp	800024ea <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002510:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002514:	14 38       	cp.w	r8,r10
80002516:	e0 88 00 09 	brls	80002528 <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000251a:	12 38       	cp.w	r8,r9
8000251c:	fe 98 ff fa 	brls	80002510 <et024006_Init+0x138>
80002520:	12 3a       	cp.w	r10,r9
80002522:	e0 83 01 4b 	brlo	800027b8 <et024006_Init+0x3e0>
80002526:	cf 5b       	rjmp	80002510 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002528:	12 38       	cp.w	r8,r9
8000252a:	e0 8b 01 47 	brhi	800027b8 <et024006_Init+0x3e0>
8000252e:	12 3a       	cp.w	r10,r9
80002530:	e0 83 01 44 	brlo	800027b8 <et024006_Init+0x3e0>
80002534:	ce eb       	rjmp	80002510 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002536:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000253a:	14 38       	cp.w	r8,r10
8000253c:	e0 88 00 09 	brls	8000254e <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002540:	12 38       	cp.w	r8,r9
80002542:	fe 98 ff fa 	brls	80002536 <et024006_Init+0x15e>
80002546:	12 3a       	cp.w	r10,r9
80002548:	e0 83 01 56 	brlo	800027f4 <et024006_Init+0x41c>
8000254c:	cf 5b       	rjmp	80002536 <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000254e:	12 38       	cp.w	r8,r9
80002550:	e0 8b 01 52 	brhi	800027f4 <et024006_Init+0x41c>
80002554:	12 3a       	cp.w	r10,r9
80002556:	e0 83 01 4f 	brlo	800027f4 <et024006_Init+0x41c>
8000255a:	ce eb       	rjmp	80002536 <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000255c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002560:	14 38       	cp.w	r8,r10
80002562:	e0 88 00 09 	brls	80002574 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002566:	12 38       	cp.w	r8,r9
80002568:	fe 98 ff fa 	brls	8000255c <et024006_Init+0x184>
8000256c:	12 3a       	cp.w	r10,r9
8000256e:	e0 83 01 64 	brlo	80002836 <et024006_Init+0x45e>
80002572:	cf 5b       	rjmp	8000255c <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002574:	12 38       	cp.w	r8,r9
80002576:	e0 8b 01 60 	brhi	80002836 <et024006_Init+0x45e>
8000257a:	12 3a       	cp.w	r10,r9
8000257c:	e0 83 01 5d 	brlo	80002836 <et024006_Init+0x45e>
80002580:	ce eb       	rjmp	8000255c <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80002582:	35 2c       	mov	r12,82
80002584:	f0 1f 00 ba 	mcall	8000286c <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002588:	fe f8 02 d4 	ld.w	r8,pc[724]
8000258c:	70 07       	ld.w	r7,r8[0x0]
8000258e:	30 58       	mov	r8,5
80002590:	ee 08 06 46 	mulu.d	r6,r7,r8
80002594:	e0 68 03 e8 	mov	r8,1000
80002598:	30 09       	mov	r9,0
8000259a:	e0 6a 03 e7 	mov	r10,999
8000259e:	30 0b       	mov	r11,0
800025a0:	ec 0a 00 0a 	add	r10,r6,r10
800025a4:	ee 0b 00 4b 	adc	r11,r7,r11
800025a8:	f0 1f 00 b3 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800025ac:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800025b0:	f0 0a 00 0a 	add	r10,r8,r10
800025b4:	c4 fb       	rjmp	80002452 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
800025b6:	f0 1f 00 b1 	mcall	80002878 <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025ba:	fc 19 c0 00 	movh	r9,0xc000
800025be:	30 1a       	mov	r10,1
800025c0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025c2:	fc 18 c0 20 	movh	r8,0xc020
800025c6:	30 6b       	mov	r11,6
800025c8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025ca:	33 ab       	mov	r11,58
800025cc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025ce:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025d0:	33 bb       	mov	r11,59
800025d2:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025d4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025d6:	33 ca       	mov	r10,60
800025d8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025da:	e0 6a 00 f0 	mov	r10,240
800025de:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025e0:	33 db       	mov	r11,61
800025e2:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025e4:	30 07       	mov	r7,0
800025e6:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025e8:	33 eb       	mov	r11,62
800025ea:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025ec:	33 8b       	mov	r11,56
800025ee:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025f0:	34 0c       	mov	r12,64
800025f2:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025f4:	30 fe       	mov	lr,15
800025f6:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025f8:	34 1e       	mov	lr,65
800025fa:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800025fc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800025fe:	32 7a       	mov	r10,39
80002600:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002602:	30 2a       	mov	r10,2
80002604:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002606:	32 8e       	mov	lr,40
80002608:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000260a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000260c:	32 9e       	mov	lr,41
8000260e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002610:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002612:	32 ae       	mov	lr,42
80002614:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002616:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002618:	32 ce       	mov	lr,44
8000261a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000261c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000261e:	32 de       	mov	lr,45
80002620:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002622:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002624:	31 9a       	mov	r10,25
80002626:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002628:	34 9a       	mov	r10,73
8000262a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000262c:	e0 6a 00 93 	mov	r10,147
80002630:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002632:	30 8a       	mov	r10,8
80002634:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002636:	31 6a       	mov	r10,22
80002638:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000263a:	36 8a       	mov	r10,104
8000263c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000263e:	32 3a       	mov	r10,35
80002640:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002642:	e0 6a 00 95 	mov	r10,149
80002646:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002648:	32 4e       	mov	lr,36
8000264a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000264c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000264e:	32 5a       	mov	r10,37
80002650:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002652:	e0 6a 00 ff 	mov	r10,255
80002656:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002658:	e0 6a 00 90 	mov	r10,144
8000265c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000265e:	37 fa       	mov	r10,127
80002660:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002662:	33 5a       	mov	r10,53
80002664:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002666:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002668:	33 6a       	mov	r10,54
8000266a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000266c:	37 8a       	mov	r10,120
8000266e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002670:	31 da       	mov	r10,29
80002672:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002674:	30 7a       	mov	r10,7
80002676:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002678:	31 ea       	mov	r10,30
8000267a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000267c:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000267e:	31 fa       	mov	r10,31
80002680:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002682:	30 4a       	mov	r10,4
80002684:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002686:	32 0a       	mov	r10,32
80002688:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000268a:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000268c:	34 4a       	mov	r10,68
8000268e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002690:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002692:	34 5a       	mov	r10,69
80002694:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002696:	31 29       	mov	r9,18
80002698:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000269a:	4f 18       	lddpc	r8,8000285c <et024006_Init+0x484>
8000269c:	70 07       	ld.w	r7,r8[0x0]
8000269e:	30 a8       	mov	r8,10
800026a0:	ee 08 06 46 	mulu.d	r6,r7,r8
800026a4:	e0 68 03 e8 	mov	r8,1000
800026a8:	30 09       	mov	r9,0
800026aa:	e0 6a 03 e7 	mov	r10,999
800026ae:	30 0b       	mov	r11,0
800026b0:	ec 0a 00 0a 	add	r10,r6,r10
800026b4:	ee 0b 00 4b 	adc	r11,r7,r11
800026b8:	f0 1f 00 6f 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800026bc:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026c0:	f0 0a 00 0a 	add	r10,r8,r10
800026c4:	cd aa       	rjmp	80002478 <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026c6:	31 c9       	mov	r9,28
800026c8:	fc 18 c0 00 	movh	r8,0xc000
800026cc:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026ce:	30 49       	mov	r9,4
800026d0:	fc 18 c0 20 	movh	r8,0xc020
800026d4:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800026d6:	4e 28       	lddpc	r8,8000285c <et024006_Init+0x484>
800026d8:	70 07       	ld.w	r7,r8[0x0]
800026da:	31 48       	mov	r8,20
800026dc:	ee 08 06 46 	mulu.d	r6,r7,r8
800026e0:	e0 68 03 e8 	mov	r8,1000
800026e4:	30 09       	mov	r9,0
800026e6:	e0 6a 03 e7 	mov	r10,999
800026ea:	30 0b       	mov	r11,0
800026ec:	ec 0a 00 0a 	add	r10,r6,r10
800026f0:	ee 0b 00 4b 	adc	r11,r7,r11
800026f4:	f0 1f 00 60 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800026f8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026fc:	f0 0a 00 0a 	add	r10,r8,r10
80002700:	cc fa       	rjmp	8000249e <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002702:	34 39       	mov	r9,67
80002704:	fc 18 c0 00 	movh	r8,0xc000
80002708:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000270a:	e0 69 00 80 	mov	r9,128
8000270e:	fc 18 c0 20 	movh	r8,0xc020
80002712:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002714:	4d 28       	lddpc	r8,8000285c <et024006_Init+0x484>
80002716:	70 07       	ld.w	r7,r8[0x0]
80002718:	30 58       	mov	r8,5
8000271a:	ee 08 06 46 	mulu.d	r6,r7,r8
8000271e:	e0 68 03 e8 	mov	r8,1000
80002722:	30 09       	mov	r9,0
80002724:	e0 6a 03 e7 	mov	r10,999
80002728:	30 0b       	mov	r11,0
8000272a:	ec 0a 00 0a 	add	r10,r6,r10
8000272e:	ee 0b 00 4b 	adc	r11,r7,r11
80002732:	f0 1f 00 51 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002736:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000273a:	f0 0a 00 0a 	add	r10,r8,r10
8000273e:	cc 3a       	rjmp	800024c4 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002740:	31 b9       	mov	r9,27
80002742:	fc 18 c0 00 	movh	r8,0xc000
80002746:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002748:	30 89       	mov	r9,8
8000274a:	fc 18 c0 20 	movh	r8,0xc020
8000274e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002750:	4c 38       	lddpc	r8,8000285c <et024006_Init+0x484>
80002752:	70 07       	ld.w	r7,r8[0x0]
80002754:	32 88       	mov	r8,40
80002756:	ee 08 06 46 	mulu.d	r6,r7,r8
8000275a:	e0 68 03 e8 	mov	r8,1000
8000275e:	30 09       	mov	r9,0
80002760:	e0 6a 03 e7 	mov	r10,999
80002764:	30 0b       	mov	r11,0
80002766:	ec 0a 00 0a 	add	r10,r6,r10
8000276a:	ee 0b 00 4b 	adc	r11,r7,r11
8000276e:	f0 1f 00 42 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002772:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002776:	f0 0a 00 0a 	add	r10,r8,r10
8000277a:	cb 8a       	rjmp	800024ea <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000277c:	31 b9       	mov	r9,27
8000277e:	fc 18 c0 00 	movh	r8,0xc000
80002782:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002784:	31 09       	mov	r9,16
80002786:	fc 18 c0 20 	movh	r8,0xc020
8000278a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000278c:	4b 48       	lddpc	r8,8000285c <et024006_Init+0x484>
8000278e:	70 07       	ld.w	r7,r8[0x0]
80002790:	32 88       	mov	r8,40
80002792:	ee 08 06 46 	mulu.d	r6,r7,r8
80002796:	e0 68 03 e8 	mov	r8,1000
8000279a:	30 09       	mov	r9,0
8000279c:	e0 6a 03 e7 	mov	r10,999
800027a0:	30 0b       	mov	r11,0
800027a2:	ec 0a 00 0a 	add	r10,r6,r10
800027a6:	ee 0b 00 4b 	adc	r11,r7,r11
800027aa:	f0 1f 00 33 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027ae:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800027b2:	f0 0a 00 0a 	add	r10,r8,r10
800027b6:	ca da       	rjmp	80002510 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027b8:	32 69       	mov	r9,38
800027ba:	fc 18 c0 00 	movh	r8,0xc000
800027be:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027c0:	30 49       	mov	r9,4
800027c2:	fc 18 c0 20 	movh	r8,0xc020
800027c6:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800027c8:	4a 58       	lddpc	r8,8000285c <et024006_Init+0x484>
800027ca:	70 07       	ld.w	r7,r8[0x0]
800027cc:	32 88       	mov	r8,40
800027ce:	ee 08 06 46 	mulu.d	r6,r7,r8
800027d2:	e0 68 03 e8 	mov	r8,1000
800027d6:	30 09       	mov	r9,0
800027d8:	e0 6a 03 e7 	mov	r10,999
800027dc:	30 0b       	mov	r11,0
800027de:	ec 0a 00 0a 	add	r10,r6,r10
800027e2:	ee 0b 00 4b 	adc	r11,r7,r11
800027e6:	f0 1f 00 24 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027ea:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800027ee:	f0 0a 00 0a 	add	r10,r8,r10
800027f2:	ca 2a       	rjmp	80002536 <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027f4:	fc 19 c0 00 	movh	r9,0xc000
800027f8:	32 6a       	mov	r10,38
800027fa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027fc:	fc 18 c0 20 	movh	r8,0xc020
80002800:	32 4b       	mov	r11,36
80002802:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002804:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002806:	32 c9       	mov	r9,44
80002808:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000280a:	49 58       	lddpc	r8,8000285c <et024006_Init+0x484>
8000280c:	70 07       	ld.w	r7,r8[0x0]
8000280e:	32 88       	mov	r8,40
80002810:	ee 08 06 46 	mulu.d	r6,r7,r8
80002814:	e0 68 03 e8 	mov	r8,1000
80002818:	30 09       	mov	r9,0
8000281a:	e0 6a 03 e7 	mov	r10,999
8000281e:	30 0b       	mov	r11,0
80002820:	ec 0a 00 0a 	add	r10,r6,r10
80002824:	ee 0b 00 4b 	adc	r11,r7,r11
80002828:	f0 1f 00 13 	mcall	80002874 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000282c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002830:	f0 0a 00 0a 	add	r10,r8,r10
80002834:	c9 4a       	rjmp	8000255c <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002836:	fc 19 c0 00 	movh	r9,0xc000
8000283a:	32 68       	mov	r8,38
8000283c:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000283e:	fc 18 c0 20 	movh	r8,0xc020
80002842:	33 ca       	mov	r10,60
80002844:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002846:	37 0a       	mov	r10,112
80002848:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
8000284a:	90 0b       	ld.sh	r11,r8[0x0]
8000284c:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000284e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002850:	16 99       	mov	r9,r11
80002852:	a3 b9       	sbr	r9,0x3
80002854:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80002856:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000285a:	00 00       	add	r0,r0
8000285c:	00 00       	add	r0,r0
8000285e:	05 20       	ld.uh	r0,r2++
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	37 08       	mov	r8,112
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	80 90       	ld.uh	r0,r0[0x2]
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	80 0c       	ld.sh	r12,r0[0x0]
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	80 d0       	ld.uh	r0,r0[0xa]
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	80 ec       	ld.uh	r12,r0[0xc]
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	8a 74       	ld.sh	r4,r5[0xe]
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	23 68       	sub	r8,54

8000287c <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
8000287c:	d4 01       	pushm	lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
8000287e:	4c 18       	lddpc	r8,80002980 <sd_mmc_spi_get_capacity+0x104>
80002880:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
80002882:	4c 18       	lddpc	r8,80002984 <sd_mmc_spi_get_capacity+0x108>
80002884:	11 8a       	ld.ub	r10,r8[0x0]
80002886:	30 38       	mov	r8,3
80002888:	f0 0a 18 00 	cp.b	r10,r8
8000288c:	c2 71       	brne	800028da <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
8000288e:	4b d8       	lddpc	r8,80002980 <sd_mmc_spi_get_capacity+0x104>
80002890:	f1 3a 00 08 	ld.ub	r10,r8[8]
80002894:	f1 39 00 09 	ld.ub	r9,r8[9]
80002898:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000289c:	11 fa       	ld.ub	r10,r8[0x7]
8000289e:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
800028a2:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
800028a6:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
800028a8:	f4 0b 16 0d 	lsr	r11,r10,0xd
800028ac:	16 99       	mov	r9,r11
800028ae:	f4 08 15 13 	lsl	r8,r10,0x13
800028b2:	4b 6a       	lddpc	r10,80002988 <sd_mmc_spi_get_capacity+0x10c>
800028b4:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
800028b8:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800028bc:	4b 48       	lddpc	r8,8000298c <sd_mmc_spi_get_capacity+0x110>
800028be:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
800028c0:	f4 ea 00 00 	ld.d	r10,r10[0]
800028c4:	90 09       	ld.sh	r9,r8[0x0]
800028c6:	f4 08 16 09 	lsr	r8,r10,0x9
800028ca:	f1 eb 11 78 	or	r8,r8,r11<<0x17
800028ce:	20 18       	sub	r8,1
800028d0:	b7 79       	lsl	r9,0x17
800028d2:	12 08       	add	r8,r9
800028d4:	4a f9       	lddpc	r9,80002990 <sd_mmc_spi_get_capacity+0x114>
800028d6:	93 08       	st.w	r9[0x0],r8
800028d8:	c4 28       	rjmp	8000295c <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
800028da:	4a a8       	lddpc	r8,80002980 <sd_mmc_spi_get_capacity+0x104>
800028dc:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
800028e0:	f1 39 00 08 	ld.ub	r9,r8[8]
800028e4:	a7 89       	lsr	r9,0x6
800028e6:	11 fe       	ld.ub	lr,r8[0x7]
800028e8:	f2 0e 00 29 	add	r9,r9,lr<<0x2
800028ec:	11 ee       	ld.ub	lr,r8[0x6]
800028ee:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
800028f2:	ab 6e       	lsl	lr,0xa
800028f4:	1c 09       	add	r9,lr
800028f6:	2f f9       	sub	r9,-1
800028f8:	f1 38 00 09 	ld.ub	r8,r8[9]
800028fc:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002900:	f8 0e 16 07 	lsr	lr,r12,0x7
80002904:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002908:	2f e8       	sub	r8,-2
8000290a:	f2 08 09 49 	lsl	r9,r9,r8
8000290e:	20 19       	sub	r9,1
80002910:	4a 08       	lddpc	r8,80002990 <sd_mmc_spi_get_capacity+0x114>
80002912:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80002914:	70 0e       	ld.w	lr,r8[0x0]
80002916:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
8000291a:	2f fe       	sub	lr,-1
8000291c:	fc 0b 09 48 	lsl	r8,lr,r11
80002920:	30 09       	mov	r9,0
80002922:	49 ae       	lddpc	lr,80002988 <sd_mmc_spi_get_capacity+0x10c>
80002924:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
80002928:	49 98       	lddpc	r8,8000298c <sd_mmc_spi_get_capacity+0x110>
8000292a:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
8000292c:	30 98       	mov	r8,9
8000292e:	f0 0b 18 00 	cp.b	r11,r8
80002932:	e0 88 00 08 	brls	80002942 <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002936:	49 78       	lddpc	r8,80002990 <sd_mmc_spi_get_capacity+0x114>
80002938:	70 09       	ld.w	r9,r8[0x0]
8000293a:	20 9b       	sub	r11,9
8000293c:	f2 0b 09 4b 	lsl	r11,r9,r11
80002940:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
80002942:	58 0a       	cp.w	r10,0
80002944:	c0 c1       	brne	8000295c <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80002946:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
8000294a:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000294e:	48 d9       	lddpc	r9,80002980 <sd_mmc_spi_get_capacity+0x104>
80002950:	f3 39 00 0b 	ld.ub	r9,r9[11]
80002954:	a3 7c       	lsl	r12,0x3
80002956:	f9 e9 12 59 	or	r9,r12,r9>>0x5
8000295a:	c0 c8       	rjmp	80002972 <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
8000295c:	48 9a       	lddpc	r10,80002980 <sd_mmc_spi_get_capacity+0x104>
8000295e:	f5 39 00 0a 	ld.ub	r9,r10[10]
80002962:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
80002966:	f5 38 00 0b 	ld.ub	r8,r10[11]
8000296a:	a7 98       	lsr	r8,0x7
8000296c:	f0 09 00 18 	add	r8,r8,r9<<0x1
80002970:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80002972:	2f f9       	sub	r9,-1
80002974:	2f f8       	sub	r8,-1
80002976:	b1 39       	mul	r9,r8
80002978:	48 78       	lddpc	r8,80002994 <sd_mmc_spi_get_capacity+0x118>
8000297a:	b0 09       	st.h	r8[0x0],r9
}
8000297c:	d8 02       	popm	pc
8000297e:	00 00       	add	r0,r0
80002980:	00 00       	add	r0,r0
80002982:	0a 54       	eor	r4,r5
80002984:	00 00       	add	r0,r0
80002986:	0a 52       	eor	r2,r5
80002988:	00 00       	add	r0,r0
8000298a:	0a 40       	or	r0,r5
8000298c:	00 00       	add	r0,r0
8000298e:	0a 48       	or	r8,r5
80002990:	00 00       	add	r0,r0
80002992:	0a 4c       	or	r12,r5
80002994:	00 00       	add	r0,r0
80002996:	0a 4a       	or	r10,r5

80002998 <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002998:	5e fc       	retal	r12
8000299a:	d7 03       	nop

8000299c <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
8000299c:	d4 01       	pushm	lr
8000299e:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800029a0:	18 9b       	mov	r11,r12
800029a2:	fe 7c 24 00 	mov	r12,-56320
800029a6:	f0 1f 00 09 	mcall	800029c8 <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800029aa:	fa cb ff fe 	sub	r11,sp,-2
800029ae:	fe 7c 24 00 	mov	r12,-56320
800029b2:	f0 1f 00 07 	mcall	800029cc <sd_mmc_spi_send_and_read+0x30>
800029b6:	58 1c       	cp.w	r12,1
800029b8:	c0 41       	brne	800029c0 <sd_mmc_spi_send_and_read+0x24>
800029ba:	e0 6c 00 ff 	mov	r12,255
800029be:	c0 28       	rjmp	800029c2 <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
800029c0:	1b bc       	ld.ub	r12,sp[0x3]
}
800029c2:	2f fd       	sub	sp,-4
800029c4:	d8 02       	popm	pc
800029c6:	00 00       	add	r0,r0
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	39 64       	mov	r4,-106
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	39 80       	mov	r0,-104

800029d0 <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
800029d0:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800029d2:	30 1b       	mov	r11,1
800029d4:	fe 7c 24 00 	mov	r12,-56320
800029d8:	f0 1f 00 10 	mcall	80002a18 <sd_mmc_spi_wait_not_busy+0x48>
800029dc:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800029de:	e0 65 00 ff 	mov	r5,255
800029e2:	48 f4       	lddpc	r4,80002a1c <sd_mmc_spi_wait_not_busy+0x4c>
800029e4:	3f f6       	mov	r6,-1
800029e6:	c0 b8       	rjmp	800029fc <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
800029e8:	2f f7       	sub	r7,-1
    if (retry == 200000)
800029ea:	e2 57 0d 40 	cp.w	r7,200000
800029ee:	c0 71       	brne	800029fc <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800029f0:	30 1b       	mov	r11,1
800029f2:	fe 7c 24 00 	mov	r12,-56320
800029f6:	f0 1f 00 0b 	mcall	80002a20 <sd_mmc_spi_wait_not_busy+0x50>
800029fa:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800029fc:	0a 9c       	mov	r12,r5
800029fe:	f0 1f 00 0a 	mcall	80002a24 <sd_mmc_spi_wait_not_busy+0x54>
80002a02:	a8 8c       	st.b	r4[0x0],r12
80002a04:	ec 0c 18 00 	cp.b	r12,r6
80002a08:	cf 01       	brne	800029e8 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002a0a:	30 1b       	mov	r11,1
80002a0c:	fe 7c 24 00 	mov	r12,-56320
80002a10:	f0 1f 00 04 	mcall	80002a20 <sd_mmc_spi_wait_not_busy+0x50>
80002a14:	da 2a       	popm	r4-r7,pc,r12=1
80002a16:	00 00       	add	r0,r0
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	3a cc       	mov	r12,-84
80002a1c:	00 00       	add	r0,r0
80002a1e:	0a 64       	and	r4,r5
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	3a 8c       	mov	r12,-88
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	29 9c       	sub	r12,-103

80002a28 <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
80002a28:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9; // gl_ptr_mem = pos * 512
80002a2a:	48 58       	lddpc	r8,80002a3c <sd_mmc_spi_write_open+0x14>
80002a2c:	f8 09 16 17 	lsr	r9,r12,0x17
80002a30:	91 09       	st.w	r8[0x0],r9
80002a32:	a9 7c       	lsl	r12,0x9
80002a34:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002a36:	f0 1f 00 03 	mcall	80002a40 <sd_mmc_spi_write_open+0x18>
}
80002a3a:	d8 02       	popm	pc
80002a3c:	00 00       	add	r0,r0
80002a3e:	05 28       	ld.uh	r8,r2++
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	29 d0       	sub	r0,-99

80002a44 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
80002a44:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
80002a46:	f0 1f 00 02 	mcall	80002a4c <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
80002a4a:	d8 02       	popm	pc
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	29 d0       	sub	r0,-99

80002a50 <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
80002a50:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9;        // gl_ptr_mem = pos * 512
80002a52:	48 58       	lddpc	r8,80002a64 <sd_mmc_spi_read_open+0x14>
80002a54:	f8 09 16 17 	lsr	r9,r12,0x17
80002a58:	91 09       	st.w	r8[0x0],r9
80002a5a:	a9 7c       	lsl	r12,0x9
80002a5c:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002a5e:	f0 1f 00 03 	mcall	80002a68 <sd_mmc_spi_read_open+0x18>
}
80002a62:	d8 02       	popm	pc
80002a64:	00 00       	add	r0,r0
80002a66:	05 28       	ld.uh	r8,r2++
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	29 d0       	sub	r0,-99

80002a6c <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80002a6c:	eb cd 40 f8 	pushm	r3-r7,lr
80002a70:	18 96       	mov	r6,r12
80002a72:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002a74:	e0 6b 00 ff 	mov	r11,255
80002a78:	fe 7c 24 00 	mov	r12,-56320
80002a7c:	f0 1f 00 2b 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80002a80:	0c 9b       	mov	r11,r6
80002a82:	a7 ab       	sbr	r11,0x6
80002a84:	5c 5b       	castu.b	r11
80002a86:	fe 7c 24 00 	mov	r12,-56320
80002a8a:	f0 1f 00 28 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80002a8e:	ee 0b 16 18 	lsr	r11,r7,0x18
80002a92:	fe 7c 24 00 	mov	r12,-56320
80002a96:	f0 1f 00 25 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
80002a9a:	ee 0b 16 10 	lsr	r11,r7,0x10
80002a9e:	fe 7c 24 00 	mov	r12,-56320
80002aa2:	f0 1f 00 22 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
80002aa6:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002aaa:	fe 7c 24 00 	mov	r12,-56320
80002aae:	f0 1f 00 1f 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
80002ab2:	0e 9b       	mov	r11,r7
80002ab4:	5c 7b       	castu.h	r11
80002ab6:	fe 7c 24 00 	mov	r12,-56320
80002aba:	f0 1f 00 1c 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
  switch(command)
80002abe:	30 08       	mov	r8,0
80002ac0:	f0 06 18 00 	cp.b	r6,r8
80002ac4:	c0 60       	breq	80002ad0 <sd_mmc_spi_command+0x64>
80002ac6:	30 88       	mov	r8,8
80002ac8:	f0 06 18 00 	cp.b	r6,r8
80002acc:	c1 01       	brne	80002aec <sd_mmc_spi_command+0x80>
80002ace:	c0 88       	rjmp	80002ade <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80002ad0:	e0 6b 00 95 	mov	r11,149
80002ad4:	fe 7c 24 00 	mov	r12,-56320
80002ad8:	f0 1f 00 14 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
         break;
80002adc:	c0 e8       	rjmp	80002af8 <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80002ade:	e0 6b 00 87 	mov	r11,135
80002ae2:	fe 7c 24 00 	mov	r12,-56320
80002ae6:	f0 1f 00 11 	mcall	80002b28 <sd_mmc_spi_command+0xbc>
         break;
80002aea:	c0 78       	rjmp	80002af8 <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002aec:	e0 6b 00 ff 	mov	r11,255
80002af0:	fe 7c 24 00 	mov	r12,-56320
80002af4:	f0 1f 00 0d 	mcall	80002b28 <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002af8:	3f f9       	mov	r9,-1
80002afa:	48 d8       	lddpc	r8,80002b2c <sd_mmc_spi_command+0xc0>
80002afc:	b0 89       	st.b	r8[0x0],r9
80002afe:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002b00:	e0 64 00 ff 	mov	r4,255
80002b04:	10 93       	mov	r3,r8
80002b06:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80002b08:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002b0a:	c0 68       	rjmp	80002b16 <sd_mmc_spi_command+0xaa>
  {
    retry++;
80002b0c:	2f f7       	sub	r7,-1
80002b0e:	5c 57       	castu.b	r7
    if(retry > 10) break;
80002b10:	ea 07 18 00 	cp.b	r7,r5
80002b14:	c0 80       	breq	80002b24 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002b16:	08 9c       	mov	r12,r4
80002b18:	f0 1f 00 06 	mcall	80002b30 <sd_mmc_spi_command+0xc4>
80002b1c:	a6 8c       	st.b	r3[0x0],r12
80002b1e:	ec 0c 18 00 	cp.b	r12,r6
80002b22:	cf 50       	breq	80002b0c <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80002b24:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	39 64       	mov	r4,-106
80002b2c:	00 00       	add	r0,r0
80002b2e:	0a 64       	and	r4,r5
80002b30:	80 00       	ld.sh	r0,r0[0x0]
80002b32:	29 9c       	sub	r12,-103

80002b34 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
80002b34:	eb cd 40 c0 	pushm	r6-r7,lr
80002b38:	18 97       	mov	r7,r12
80002b3a:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002b3c:	30 1b       	mov	r11,1
80002b3e:	fe 7c 24 00 	mov	r12,-56320
80002b42:	f0 1f 00 09 	mcall	80002b64 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
80002b46:	0c 9b       	mov	r11,r6
80002b48:	0e 9c       	mov	r12,r7
80002b4a:	f0 1f 00 08 	mcall	80002b68 <sd_mmc_spi_send_command+0x34>
80002b4e:	48 87       	lddpc	r7,80002b6c <sd_mmc_spi_send_command+0x38>
80002b50:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002b52:	30 1b       	mov	r11,1
80002b54:	fe 7c 24 00 	mov	r12,-56320
80002b58:	f0 1f 00 06 	mcall	80002b70 <sd_mmc_spi_send_command+0x3c>
  return r1;
}
80002b5c:	0f 8c       	ld.ub	r12,r7[0x0]
80002b5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b62:	00 00       	add	r0,r0
80002b64:	80 00       	ld.sh	r0,r0[0x0]
80002b66:	3a cc       	mov	r12,-84
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	2a 6c       	sub	r12,-90
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a 64       	and	r4,r5
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	3a 8c       	mov	r12,-88

80002b74 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80002b74:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80002b78:	49 a8       	lddpc	r8,80002be0 <sd_mmc_spi_check_presence+0x6c>
80002b7a:	11 89       	ld.ub	r9,r8[0x0]
80002b7c:	30 08       	mov	r8,0
80002b7e:	f0 09 18 00 	cp.b	r9,r8
80002b82:	c1 f1       	brne	80002bc0 <sd_mmc_spi_check_presence+0x4c>
80002b84:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002b86:	0e 94       	mov	r4,r7
80002b88:	49 73       	lddpc	r3,80002be4 <sd_mmc_spi_check_presence+0x70>
80002b8a:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002b8c:	e0 62 00 ff 	mov	r2,255
80002b90:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80002b94:	30 b5       	mov	r5,11
80002b96:	c0 c8       	rjmp	80002bae <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002b98:	04 9b       	mov	r11,r2
80002b9a:	02 9c       	mov	r12,r1
80002b9c:	f0 1f 00 13 	mcall	80002be8 <sd_mmc_spi_check_presence+0x74>
      retry++;
80002ba0:	2f f7       	sub	r7,-1
80002ba2:	5c 87       	casts.h	r7
      if (retry > 10)
80002ba4:	ea 07 19 00 	cp.h	r7,r5
80002ba8:	c0 31       	brne	80002bae <sd_mmc_spi_check_presence+0x3a>
80002baa:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002bae:	08 9b       	mov	r11,r4
80002bb0:	08 9c       	mov	r12,r4
80002bb2:	f0 1f 00 0f 	mcall	80002bec <sd_mmc_spi_check_presence+0x78>
80002bb6:	a6 8c       	st.b	r3[0x0],r12
80002bb8:	ec 0c 18 00 	cp.b	r12,r6
80002bbc:	ce e1       	brne	80002b98 <sd_mmc_spi_check_presence+0x24>
80002bbe:	c0 e8       	rjmp	80002bda <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80002bc0:	30 0b       	mov	r11,0
80002bc2:	33 bc       	mov	r12,59
80002bc4:	f0 1f 00 0a 	mcall	80002bec <sd_mmc_spi_check_presence+0x78>
80002bc8:	48 78       	lddpc	r8,80002be4 <sd_mmc_spi_check_presence+0x70>
80002bca:	b0 8c       	st.b	r8[0x0],r12
80002bcc:	58 0c       	cp.w	r12,0
80002bce:	c0 60       	breq	80002bda <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
80002bd0:	30 09       	mov	r9,0
80002bd2:	48 48       	lddpc	r8,80002be0 <sd_mmc_spi_check_presence+0x6c>
80002bd4:	b0 89       	st.b	r8[0x0],r9
80002bd6:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
80002bda:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
80002bde:	00 00       	add	r0,r0
80002be0:	00 00       	add	r0,r0
80002be2:	05 44       	ld.w	r4,--r2
80002be4:	00 00       	add	r0,r0
80002be6:	0a 64       	and	r4,r5
80002be8:	80 00       	ld.sh	r0,r0[0x0]
80002bea:	39 64       	mov	r4,-106
80002bec:	80 00       	ld.sh	r0,r0[0x0]
80002bee:	2b 34       	sub	r4,-77

80002bf0 <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
80002bf0:	eb cd 40 e0 	pushm	r5-r7,lr
80002bf4:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002bf6:	f0 1f 00 4e 	mcall	80002d2c <sd_mmc_spi_write_sector_from_ram+0x13c>
80002bfa:	e0 80 00 96 	breq	80002d26 <sd_mmc_spi_write_sector_from_ram+0x136>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002bfe:	30 1b       	mov	r11,1
80002c00:	fe 7c 24 00 	mov	r12,-56320
80002c04:	f0 1f 00 4b 	mcall	80002d30 <sd_mmc_spi_write_sector_from_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002c08:	4c b8       	lddpc	r8,80002d34 <sd_mmc_spi_write_sector_from_ram+0x144>
80002c0a:	11 89       	ld.ub	r9,r8[0x0]
80002c0c:	30 38       	mov	r8,3
80002c0e:	f0 09 18 00 	cp.b	r9,r8
80002c12:	c0 d1       	brne	80002c2c <sd_mmc_spi_write_sector_from_ram+0x3c>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80002c14:	4c 98       	lddpc	r8,80002d38 <sd_mmc_spi_write_sector_from_ram+0x148>
80002c16:	70 0b       	ld.w	r11,r8[0x0]
80002c18:	70 18       	ld.w	r8,r8[0x4]
80002c1a:	a9 98       	lsr	r8,0x9
80002c1c:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
80002c20:	31 8c       	mov	r12,24
80002c22:	f0 1f 00 47 	mcall	80002d3c <sd_mmc_spi_write_sector_from_ram+0x14c>
80002c26:	4c 78       	lddpc	r8,80002d40 <sd_mmc_spi_write_sector_from_ram+0x150>
80002c28:	b0 8c       	st.b	r8[0x0],r12
80002c2a:	c0 88       	rjmp	80002c3a <sd_mmc_spi_write_sector_from_ram+0x4a>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
80002c2c:	4c 38       	lddpc	r8,80002d38 <sd_mmc_spi_write_sector_from_ram+0x148>
80002c2e:	70 1b       	ld.w	r11,r8[0x4]
80002c30:	31 8c       	mov	r12,24
80002c32:	f0 1f 00 43 	mcall	80002d3c <sd_mmc_spi_write_sector_from_ram+0x14c>
80002c36:	4c 38       	lddpc	r8,80002d40 <sd_mmc_spi_write_sector_from_ram+0x150>
80002c38:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
80002c3a:	4c 28       	lddpc	r8,80002d40 <sd_mmc_spi_write_sector_from_ram+0x150>
80002c3c:	11 89       	ld.ub	r9,r8[0x0]
80002c3e:	30 08       	mov	r8,0
80002c40:	f0 09 18 00 	cp.b	r9,r8
80002c44:	c0 80       	breq	80002c54 <sd_mmc_spi_write_sector_from_ram+0x64>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002c46:	30 1b       	mov	r11,1
80002c48:	fe 7c 24 00 	mov	r12,-56320
80002c4c:	f0 1f 00 3e 	mcall	80002d44 <sd_mmc_spi_write_sector_from_ram+0x154>
80002c50:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80002c54:	e0 6b 00 ff 	mov	r11,255
80002c58:	fe 7c 24 00 	mov	r12,-56320
80002c5c:	f0 1f 00 3b 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
80002c60:	e0 6b 00 fe 	mov	r11,254
80002c64:	fe 7c 24 00 	mov	r12,-56320
80002c68:	f0 1f 00 38 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
80002c6c:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
80002c70:	fe 75 24 00 	mov	r5,-56320
80002c74:	0f 3b       	ld.ub	r11,r7++
80002c76:	0a 9c       	mov	r12,r5
80002c78:	f0 1f 00 34 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80002c7c:	0c 37       	cp.w	r7,r6
80002c7e:	cf b1       	brne	80002c74 <sd_mmc_spi_write_sector_from_ram+0x84>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
80002c80:	e0 6b 00 ff 	mov	r11,255
80002c84:	fe 7c 24 00 	mov	r12,-56320
80002c88:	f0 1f 00 30 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80002c8c:	e0 6b 00 ff 	mov	r11,255
80002c90:	fe 7c 24 00 	mov	r12,-56320
80002c94:	f0 1f 00 2d 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002c98:	e0 6c 00 ff 	mov	r12,255
80002c9c:	f0 1f 00 2c 	mcall	80002d4c <sd_mmc_spi_write_sector_from_ram+0x15c>
80002ca0:	4a 88       	lddpc	r8,80002d40 <sd_mmc_spi_write_sector_from_ram+0x150>
80002ca2:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80002ca4:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002ca8:	58 5c       	cp.w	r12,5
80002caa:	c1 40       	breq	80002cd2 <sd_mmc_spi_write_sector_from_ram+0xe2>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002cac:	e0 6b 00 ff 	mov	r11,255
80002cb0:	fe 7c 24 00 	mov	r12,-56320
80002cb4:	f0 1f 00 25 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_write(SD_MMC_SPI,0xFF);
80002cb8:	e0 6b 00 ff 	mov	r11,255
80002cbc:	fe 7c 24 00 	mov	r12,-56320
80002cc0:	f0 1f 00 22 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002cc4:	30 1b       	mov	r11,1
80002cc6:	fe 7c 24 00 	mov	r12,-56320
80002cca:	f0 1f 00 1f 	mcall	80002d44 <sd_mmc_spi_write_sector_from_ram+0x154>
80002cce:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002cd2:	e0 6b 00 ff 	mov	r11,255
80002cd6:	fe 7c 24 00 	mov	r12,-56320
80002cda:	f0 1f 00 1c 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80002cde:	e0 6b 00 ff 	mov	r11,255
80002ce2:	fe 7c 24 00 	mov	r12,-56320
80002ce6:	f0 1f 00 19 	mcall	80002d48 <sd_mmc_spi_write_sector_from_ram+0x158>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002cea:	30 1b       	mov	r11,1
80002cec:	fe 7c 24 00 	mov	r12,-56320
80002cf0:	f0 1f 00 15 	mcall	80002d44 <sd_mmc_spi_write_sector_from_ram+0x154>
  gl_ptr_mem += 512;        // Update the memory pointer.
80002cf4:	49 18       	lddpc	r8,80002d38 <sd_mmc_spi_write_sector_from_ram+0x148>
80002cf6:	f0 e6 00 00 	ld.d	r6,r8[0]
80002cfa:	e0 6a 02 00 	mov	r10,512
80002cfe:	30 0b       	mov	r11,0
80002d00:	ec 0a 00 0a 	add	r10,r6,r10
80002d04:	ee 0b 00 4b 	adc	r11,r7,r11
80002d08:	f0 eb 00 00 	st.d	r8[0],r10
80002d0c:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
80002d0e:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80002d10:	c0 68       	rjmp	80002d1c <sd_mmc_spi_write_sector_from_ram+0x12c>
  {
    i++;
80002d12:	2f f7       	sub	r7,-1
80002d14:	5c 87       	casts.h	r7
    if (i == 10)
80002d16:	ec 07 19 00 	cp.h	r7,r6
80002d1a:	c0 60       	breq	80002d26 <sd_mmc_spi_write_sector_from_ram+0x136>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80002d1c:	f0 1f 00 04 	mcall	80002d2c <sd_mmc_spi_write_sector_from_ram+0x13c>
80002d20:	cf 90       	breq	80002d12 <sd_mmc_spi_write_sector_from_ram+0x122>
80002d22:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002d26:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80002d2a:	00 00       	add	r0,r0
80002d2c:	80 00       	ld.sh	r0,r0[0x0]
80002d2e:	29 d0       	sub	r0,-99
80002d30:	80 00       	ld.sh	r0,r0[0x0]
80002d32:	3a cc       	mov	r12,-84
80002d34:	00 00       	add	r0,r0
80002d36:	0a 52       	eor	r2,r5
80002d38:	00 00       	add	r0,r0
80002d3a:	05 28       	ld.uh	r8,r2++
80002d3c:	80 00       	ld.sh	r0,r0[0x0]
80002d3e:	2a 6c       	sub	r12,-90
80002d40:	00 00       	add	r0,r0
80002d42:	0a 64       	and	r4,r5
80002d44:	80 00       	ld.sh	r0,r0[0x0]
80002d46:	3a 8c       	mov	r12,-88
80002d48:	80 00       	ld.sh	r0,r0[0x0]
80002d4a:	39 64       	mov	r4,-106
80002d4c:	80 00       	ld.sh	r0,r0[0x0]
80002d4e:	29 9c       	sub	r12,-103

80002d50 <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
80002d50:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002d54:	f0 1f 00 1c 	mcall	80002dc4 <sd_mmc_spi_check_hc+0x74>
80002d58:	c0 31       	brne	80002d5e <sd_mmc_spi_check_hc+0xe>
80002d5a:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002d5e:	30 1b       	mov	r11,1
80002d60:	fe 7c 24 00 	mov	r12,-56320
80002d64:	f0 1f 00 19 	mcall	80002dc8 <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
80002d68:	30 0b       	mov	r11,0
80002d6a:	33 ac       	mov	r12,58
80002d6c:	f0 1f 00 18 	mcall	80002dcc <sd_mmc_spi_check_hc+0x7c>
80002d70:	49 88       	lddpc	r8,80002dd0 <sd_mmc_spi_check_hc+0x80>
80002d72:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
80002d74:	58 0c       	cp.w	r12,0
80002d76:	c0 80       	breq	80002d86 <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002d78:	30 1b       	mov	r11,1
80002d7a:	fe 7c 24 00 	mov	r12,-56320
80002d7e:	f0 1f 00 16 	mcall	80002dd4 <sd_mmc_spi_check_hc+0x84>
80002d82:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80002d86:	e0 6c 00 ff 	mov	r12,255
80002d8a:	f0 1f 00 14 	mcall	80002dd8 <sd_mmc_spi_check_hc+0x88>
80002d8e:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002d90:	e0 6c 00 ff 	mov	r12,255
80002d94:	f0 1f 00 11 	mcall	80002dd8 <sd_mmc_spi_check_hc+0x88>
80002d98:	48 e7       	lddpc	r7,80002dd0 <sd_mmc_spi_check_hc+0x80>
80002d9a:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002d9c:	e0 6c 00 ff 	mov	r12,255
80002da0:	f0 1f 00 0e 	mcall	80002dd8 <sd_mmc_spi_check_hc+0x88>
80002da4:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002da6:	e0 6c 00 ff 	mov	r12,255
80002daa:	f0 1f 00 0c 	mcall	80002dd8 <sd_mmc_spi_check_hc+0x88>
80002dae:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002db0:	30 1b       	mov	r11,1
80002db2:	fe 7c 24 00 	mov	r12,-56320
80002db6:	f0 1f 00 08 	mcall	80002dd4 <sd_mmc_spi_check_hc+0x84>
80002dba:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
80002dbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002dc2:	00 00       	add	r0,r0
80002dc4:	80 00       	ld.sh	r0,r0[0x0]
80002dc6:	29 d0       	sub	r0,-99
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	3a cc       	mov	r12,-84
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	2a 6c       	sub	r12,-90
80002dd0:	00 00       	add	r0,r0
80002dd2:	0a 64       	and	r4,r5
80002dd4:	80 00       	ld.sh	r0,r0[0x0]
80002dd6:	3a 8c       	mov	r12,-88
80002dd8:	80 00       	ld.sh	r0,r0[0x0]
80002dda:	29 9c       	sub	r12,-103

80002ddc <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80002ddc:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002de0:	f0 1f 00 27 	mcall	80002e7c <sd_mmc_spi_get_if+0xa0>
80002de4:	c0 31       	brne	80002dea <sd_mmc_spi_get_if+0xe>
80002de6:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002dea:	30 1b       	mov	r11,1
80002dec:	fe 7c 24 00 	mov	r12,-56320
80002df0:	f0 1f 00 24 	mcall	80002e80 <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80002df4:	e0 6b 01 aa 	mov	r11,426
80002df8:	30 8c       	mov	r12,8
80002dfa:	f0 1f 00 23 	mcall	80002e84 <sd_mmc_spi_get_if+0xa8>
80002dfe:	4a 38       	lddpc	r8,80002e88 <sd_mmc_spi_get_if+0xac>
80002e00:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
80002e02:	e2 1c 00 04 	andl	r12,0x4,COH
80002e06:	c0 80       	breq	80002e16 <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002e08:	30 1b       	mov	r11,1
80002e0a:	fe 7c 24 00 	mov	r12,-56320
80002e0e:	f0 1f 00 20 	mcall	80002e8c <sd_mmc_spi_get_if+0xb0>
80002e12:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002e16:	e0 6c 00 ff 	mov	r12,255
80002e1a:	f0 1f 00 1e 	mcall	80002e90 <sd_mmc_spi_get_if+0xb4>
80002e1e:	49 b7       	lddpc	r7,80002e88 <sd_mmc_spi_get_if+0xac>
80002e20:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002e22:	e0 6c 00 ff 	mov	r12,255
80002e26:	f0 1f 00 1b 	mcall	80002e90 <sd_mmc_spi_get_if+0xb4>
80002e2a:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002e2c:	e0 6c 00 ff 	mov	r12,255
80002e30:	f0 1f 00 18 	mcall	80002e90 <sd_mmc_spi_get_if+0xb4>
80002e34:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
80002e36:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002e3a:	c0 81       	brne	80002e4a <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002e3c:	30 1b       	mov	r11,1
80002e3e:	fe 7c 24 00 	mov	r12,-56320
80002e42:	f0 1f 00 13 	mcall	80002e8c <sd_mmc_spi_get_if+0xb0>
80002e46:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002e4a:	e0 6c 00 ff 	mov	r12,255
80002e4e:	f0 1f 00 11 	mcall	80002e90 <sd_mmc_spi_get_if+0xb4>
80002e52:	48 e8       	lddpc	r8,80002e88 <sd_mmc_spi_get_if+0xac>
80002e54:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
80002e56:	3a a8       	mov	r8,-86
80002e58:	f0 0c 18 00 	cp.b	r12,r8
80002e5c:	c0 80       	breq	80002e6c <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002e5e:	30 1b       	mov	r11,1
80002e60:	fe 7c 24 00 	mov	r12,-56320
80002e64:	f0 1f 00 0a 	mcall	80002e8c <sd_mmc_spi_get_if+0xb0>
80002e68:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002e6c:	30 1b       	mov	r11,1
80002e6e:	fe 7c 24 00 	mov	r12,-56320
80002e72:	f0 1f 00 07 	mcall	80002e8c <sd_mmc_spi_get_if+0xb0>
80002e76:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80002e7a:	00 00       	add	r0,r0
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	29 d0       	sub	r0,-99
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	3a cc       	mov	r12,-84
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	2a 6c       	sub	r12,-90
80002e88:	00 00       	add	r0,r0
80002e8a:	0a 64       	and	r4,r5
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	3a 8c       	mov	r12,-88
80002e90:	80 00       	ld.sh	r0,r0[0x0]
80002e92:	29 9c       	sub	r12,-103

80002e94 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80002e94:	eb cd 40 f8 	pushm	r3-r7,lr
80002e98:	20 1d       	sub	sp,4
80002e9a:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002e9c:	f0 1f 00 4d 	mcall	80002fd0 <sd_mmc_spi_read_sector_to_ram+0x13c>
80002ea0:	e0 80 00 94 	breq	80002fc8 <sd_mmc_spi_read_sector_to_ram+0x134>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002ea4:	30 1b       	mov	r11,1
80002ea6:	fe 7c 24 00 	mov	r12,-56320
80002eaa:	f0 1f 00 4b 	mcall	80002fd4 <sd_mmc_spi_read_sector_to_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002eae:	4c b8       	lddpc	r8,80002fd8 <sd_mmc_spi_read_sector_to_ram+0x144>
80002eb0:	11 89       	ld.ub	r9,r8[0x0]
80002eb2:	30 38       	mov	r8,3
80002eb4:	f0 09 18 00 	cp.b	r9,r8
80002eb8:	c0 d1       	brne	80002ed2 <sd_mmc_spi_read_sector_to_ram+0x3e>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80002eba:	4c 98       	lddpc	r8,80002fdc <sd_mmc_spi_read_sector_to_ram+0x148>
80002ebc:	70 0b       	ld.w	r11,r8[0x0]
80002ebe:	70 18       	ld.w	r8,r8[0x4]
80002ec0:	a9 98       	lsr	r8,0x9
80002ec2:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
80002ec6:	31 1c       	mov	r12,17
80002ec8:	f0 1f 00 46 	mcall	80002fe0 <sd_mmc_spi_read_sector_to_ram+0x14c>
80002ecc:	4c 68       	lddpc	r8,80002fe4 <sd_mmc_spi_read_sector_to_ram+0x150>
80002ece:	b0 8c       	st.b	r8[0x0],r12
80002ed0:	c0 88       	rjmp	80002ee0 <sd_mmc_spi_read_sector_to_ram+0x4c>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80002ed2:	4c 38       	lddpc	r8,80002fdc <sd_mmc_spi_read_sector_to_ram+0x148>
80002ed4:	70 1b       	ld.w	r11,r8[0x4]
80002ed6:	31 1c       	mov	r12,17
80002ed8:	f0 1f 00 42 	mcall	80002fe0 <sd_mmc_spi_read_sector_to_ram+0x14c>
80002edc:	4c 28       	lddpc	r8,80002fe4 <sd_mmc_spi_read_sector_to_ram+0x150>
80002ede:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
80002ee0:	4c 18       	lddpc	r8,80002fe4 <sd_mmc_spi_read_sector_to_ram+0x150>
80002ee2:	11 89       	ld.ub	r9,r8[0x0]
80002ee4:	30 08       	mov	r8,0
80002ee6:	f0 09 18 00 	cp.b	r9,r8
80002eea:	c1 20       	breq	80002f0e <sd_mmc_spi_read_sector_to_ram+0x7a>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002eec:	30 1b       	mov	r11,1
80002eee:	fe 7c 24 00 	mov	r12,-56320
80002ef2:	f0 1f 00 3e 	mcall	80002fe8 <sd_mmc_spi_read_sector_to_ram+0x154>
80002ef6:	30 0c       	mov	r12,0
    return false;
80002ef8:	c6 88       	rjmp	80002fc8 <sd_mmc_spi_read_sector_to_ram+0x134>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
80002efa:	20 17       	sub	r7,1
80002efc:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
80002efe:	c0 e1       	brne	80002f1a <sd_mmc_spi_read_sector_to_ram+0x86>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
80002f00:	30 1b       	mov	r11,1
80002f02:	fe 7c 24 00 	mov	r12,-56320
80002f06:	f0 1f 00 39 	mcall	80002fe8 <sd_mmc_spi_read_sector_to_ram+0x154>
80002f0a:	30 0c       	mov	r12,0
       return false;
80002f0c:	c5 e8       	rjmp	80002fc8 <sd_mmc_spi_read_sector_to_ram+0x134>
80002f0e:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002f12:	e0 65 00 ff 	mov	r5,255
80002f16:	4b 44       	lddpc	r4,80002fe4 <sd_mmc_spi_read_sector_to_ram+0x150>
80002f18:	3f f6       	mov	r6,-1
80002f1a:	0a 9c       	mov	r12,r5
80002f1c:	f0 1f 00 34 	mcall	80002fec <sd_mmc_spi_read_sector_to_ram+0x158>
80002f20:	a8 8c       	st.b	r4[0x0],r12
80002f22:	ec 0c 18 00 	cp.b	r12,r6
80002f26:	ce a0       	breq	80002efa <sd_mmc_spi_read_sector_to_ram+0x66>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80002f28:	3f e8       	mov	r8,-2
80002f2a:	f0 0c 18 00 	cp.b	r12,r8
80002f2e:	c0 e0       	breq	80002f4a <sd_mmc_spi_read_sector_to_ram+0xb6>
  {
    spi_write(SD_MMC_SPI,0xFF);
80002f30:	e0 6b 00 ff 	mov	r11,255
80002f34:	fe 7c 24 00 	mov	r12,-56320
80002f38:	f0 1f 00 2e 	mcall	80002ff0 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002f3c:	30 1b       	mov	r11,1
80002f3e:	fe 7c 24 00 	mov	r12,-56320
80002f42:	f0 1f 00 2a 	mcall	80002fe8 <sd_mmc_spi_read_sector_to_ram+0x154>
80002f46:	30 0c       	mov	r12,0
    return false;
80002f48:	c4 08       	rjmp	80002fc8 <sd_mmc_spi_read_sector_to_ram+0x134>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
80002f4a:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
80002f4c:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
80002f50:	e0 64 00 ff 	mov	r4,255
80002f54:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
80002f58:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
80002f5c:	08 9b       	mov	r11,r4
80002f5e:	0c 9c       	mov	r12,r6
80002f60:	f0 1f 00 24 	mcall	80002ff0 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_read(SD_MMC_SPI,&data_read);
80002f64:	06 9b       	mov	r11,r3
80002f66:	0c 9c       	mov	r12,r6
80002f68:	f0 1f 00 23 	mcall	80002ff4 <sd_mmc_spi_read_sector_to_ram+0x160>
    *_ram++=data_read;
80002f6c:	9a 18       	ld.sh	r8,sp[0x2]
80002f6e:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80002f70:	0a 37       	cp.w	r7,r5
80002f72:	cf 51       	brne	80002f5c <sd_mmc_spi_read_sector_to_ram+0xc8>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
80002f74:	49 a8       	lddpc	r8,80002fdc <sd_mmc_spi_read_sector_to_ram+0x148>
80002f76:	f0 e6 00 00 	ld.d	r6,r8[0]
80002f7a:	e0 6a 02 00 	mov	r10,512
80002f7e:	30 0b       	mov	r11,0
80002f80:	ec 0a 00 0a 	add	r10,r6,r10
80002f84:	ee 0b 00 4b 	adc	r11,r7,r11
80002f88:	f0 eb 00 00 	st.d	r8[0],r10

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80002f8c:	e0 6b 00 ff 	mov	r11,255
80002f90:	fe 7c 24 00 	mov	r12,-56320
80002f94:	f0 1f 00 17 	mcall	80002ff0 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80002f98:	e0 6b 00 ff 	mov	r11,255
80002f9c:	fe 7c 24 00 	mov	r12,-56320
80002fa0:	f0 1f 00 14 	mcall	80002ff0 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80002fa4:	e0 6b 00 ff 	mov	r11,255
80002fa8:	fe 7c 24 00 	mov	r12,-56320
80002fac:	f0 1f 00 11 	mcall	80002ff0 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80002fb0:	e0 6b 00 ff 	mov	r11,255
80002fb4:	fe 7c 24 00 	mov	r12,-56320
80002fb8:	f0 1f 00 0e 	mcall	80002ff0 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002fbc:	30 1b       	mov	r11,1
80002fbe:	fe 7c 24 00 	mov	r12,-56320
80002fc2:	f0 1f 00 0a 	mcall	80002fe8 <sd_mmc_spi_read_sector_to_ram+0x154>
80002fc6:	30 1c       	mov	r12,1

  return true;   // Read done.
}
80002fc8:	2f fd       	sub	sp,-4
80002fca:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002fce:	00 00       	add	r0,r0
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	29 d0       	sub	r0,-99
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	3a cc       	mov	r12,-84
80002fd8:	00 00       	add	r0,r0
80002fda:	0a 52       	eor	r2,r5
80002fdc:	00 00       	add	r0,r0
80002fde:	05 28       	ld.uh	r8,r2++
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	2a 6c       	sub	r12,-90
80002fe4:	00 00       	add	r0,r0
80002fe6:	0a 64       	and	r4,r5
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	3a 8c       	mov	r12,-88
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	29 9c       	sub	r12,-103
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	39 64       	mov	r4,-106
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	39 80       	mov	r0,-104

80002ff8 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
80002ff8:	eb cd 40 fc 	pushm	r2-r7,lr
80002ffc:	20 1d       	sub	sp,4
80002ffe:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003000:	f0 1f 00 32 	mcall	800030c8 <sd_mmc_spi_get_csd+0xd0>
80003004:	c5 f0       	breq	800030c2 <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003006:	30 1b       	mov	r11,1
80003008:	fe 7c 24 00 	mov	r12,-56320
8000300c:	f0 1f 00 30 	mcall	800030cc <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80003010:	30 0b       	mov	r11,0
80003012:	30 9c       	mov	r12,9
80003014:	f0 1f 00 2f 	mcall	800030d0 <sd_mmc_spi_get_csd+0xd8>
80003018:	4a f8       	lddpc	r8,800030d4 <sd_mmc_spi_get_csd+0xdc>
8000301a:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
8000301c:	58 0c       	cp.w	r12,0
8000301e:	c0 81       	brne	8000302e <sd_mmc_spi_get_csd+0x36>
80003020:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003022:	e0 64 00 ff 	mov	r4,255
80003026:	10 93       	mov	r3,r8
80003028:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
8000302a:	30 95       	mov	r5,9
8000302c:	c1 78       	rjmp	8000305a <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000302e:	30 1b       	mov	r11,1
80003030:	fe 7c 24 00 	mov	r12,-56320
80003034:	f0 1f 00 29 	mcall	800030d8 <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
80003038:	30 09       	mov	r9,0
8000303a:	4a 98       	lddpc	r8,800030dc <sd_mmc_spi_get_csd+0xe4>
8000303c:	b0 89       	st.b	r8[0x0],r9
8000303e:	30 0c       	mov	r12,0
    return false;
80003040:	c4 18       	rjmp	800030c2 <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
80003042:	ea 07 18 00 	cp.b	r7,r5
80003046:	c0 81       	brne	80003056 <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003048:	30 1b       	mov	r11,1
8000304a:	fe 7c 24 00 	mov	r12,-56320
8000304e:	f0 1f 00 23 	mcall	800030d8 <sd_mmc_spi_get_csd+0xe0>
80003052:	30 0c       	mov	r12,0
      return false;
80003054:	c3 78       	rjmp	800030c2 <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
80003056:	2f f7       	sub	r7,-1
80003058:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000305a:	08 9c       	mov	r12,r4
8000305c:	f0 1f 00 21 	mcall	800030e0 <sd_mmc_spi_get_csd+0xe8>
80003060:	a6 8c       	st.b	r3[0x0],r12
80003062:	ec 0c 18 00 	cp.b	r12,r6
80003066:	ce e1       	brne	80003042 <sd_mmc_spi_get_csd+0x4a>
80003068:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000306a:	e0 65 00 ff 	mov	r5,255
8000306e:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
80003072:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003076:	0a 9b       	mov	r11,r5
80003078:	0c 9c       	mov	r12,r6
8000307a:	f0 1f 00 1b 	mcall	800030e4 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
8000307e:	08 9b       	mov	r11,r4
80003080:	0c 9c       	mov	r12,r6
80003082:	f0 1f 00 1a 	mcall	800030e8 <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
80003086:	9a 18       	ld.sh	r8,sp[0x2]
80003088:	e4 07 0b 08 	st.b	r2[r7],r8
8000308c:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
8000308e:	59 07       	cp.w	r7,16
80003090:	cf 31       	brne	80003076 <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80003092:	e0 6b 00 ff 	mov	r11,255
80003096:	fe 7c 24 00 	mov	r12,-56320
8000309a:	f0 1f 00 13 	mcall	800030e4 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
8000309e:	e0 6b 00 ff 	mov	r11,255
800030a2:	fe 7c 24 00 	mov	r12,-56320
800030a6:	f0 1f 00 10 	mcall	800030e4 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800030aa:	e0 6b 00 ff 	mov	r11,255
800030ae:	fe 7c 24 00 	mov	r12,-56320
800030b2:	f0 1f 00 0d 	mcall	800030e4 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800030b6:	30 1b       	mov	r11,1
800030b8:	fe 7c 24 00 	mov	r12,-56320
800030bc:	f0 1f 00 07 	mcall	800030d8 <sd_mmc_spi_get_csd+0xe0>
800030c0:	30 1c       	mov	r12,1
  return true;
}
800030c2:	2f fd       	sub	sp,-4
800030c4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800030c8:	80 00       	ld.sh	r0,r0[0x0]
800030ca:	29 d0       	sub	r0,-99
800030cc:	80 00       	ld.sh	r0,r0[0x0]
800030ce:	3a cc       	mov	r12,-84
800030d0:	80 00       	ld.sh	r0,r0[0x0]
800030d2:	2a 6c       	sub	r12,-90
800030d4:	00 00       	add	r0,r0
800030d6:	0a 64       	and	r4,r5
800030d8:	80 00       	ld.sh	r0,r0[0x0]
800030da:	3a 8c       	mov	r12,-88
800030dc:	00 00       	add	r0,r0
800030de:	05 44       	ld.w	r4,--r2
800030e0:	80 00       	ld.sh	r0,r0[0x0]
800030e2:	29 9c       	sub	r12,-103
800030e4:	80 00       	ld.sh	r0,r0[0x0]
800030e6:	39 64       	mov	r4,-106
800030e8:	80 00       	ld.sh	r0,r0[0x0]
800030ea:	39 80       	mov	r0,-104

800030ec <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
800030ec:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
800030ee:	fe fb 02 66 	ld.w	r11,pc[614]
800030f2:	e6 68 1a 80 	mov	r8,400000
800030f6:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800030f8:	fe f8 02 60 	ld.w	r8,pc[608]
800030fc:	70 0a       	ld.w	r10,r8[0x0]
800030fe:	fe 7c 24 00 	mov	r12,-56320
80003102:	f0 1f 00 97 	mcall	8000335c <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003106:	30 1b       	mov	r11,1
80003108:	fe 7c 24 00 	mov	r12,-56320
8000310c:	f0 1f 00 95 	mcall	80003360 <sd_mmc_spi_internal_init+0x274>
80003110:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
80003112:	e0 66 00 ff 	mov	r6,255
80003116:	fe 75 24 00 	mov	r5,-56320
8000311a:	0c 9b       	mov	r11,r6
8000311c:	0a 9c       	mov	r12,r5
8000311e:	f0 1f 00 92 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
80003122:	2f f7       	sub	r7,-1
80003124:	58 a7       	cp.w	r7,10
80003126:	cf a1       	brne	8000311a <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003128:	30 1b       	mov	r11,1
8000312a:	fe 7c 24 00 	mov	r12,-56320
8000312e:	f0 1f 00 8f 	mcall	80003368 <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
80003132:	30 08       	mov	r8,0
80003134:	fe f9 02 38 	ld.w	r9,pc[568]
80003138:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
8000313a:	fe f9 02 36 	ld.w	r9,pc[566]
8000313e:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003140:	30 0b       	mov	r11,0
80003142:	16 9c       	mov	r12,r11
80003144:	f0 1f 00 8c 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
80003148:	fe f8 02 30 	ld.w	r8,pc[560]
8000314c:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000314e:	e0 6b 00 ff 	mov	r11,255
80003152:	fe 7c 24 00 	mov	r12,-56320
80003156:	f0 1f 00 84 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
8000315a:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000315c:	fe f6 02 1c 	ld.w	r6,pc[540]
80003160:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003162:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003164:	e0 62 00 ff 	mov	r2,255
80003168:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
8000316c:	36 54       	mov	r4,101
8000316e:	c1 08       	rjmp	8000318e <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003170:	06 9b       	mov	r11,r3
80003172:	06 9c       	mov	r12,r3
80003174:	f0 1f 00 80 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
80003178:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000317a:	04 9b       	mov	r11,r2
8000317c:	02 9c       	mov	r12,r1
8000317e:	f0 1f 00 7a 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
80003182:	2f f7       	sub	r7,-1
80003184:	5c 87       	casts.h	r7
    if(retry > 100)
80003186:	e8 07 19 00 	cp.h	r7,r4
8000318a:	e0 80 00 e4 	breq	80003352 <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000318e:	0d 88       	ld.ub	r8,r6[0x0]
80003190:	ea 08 18 00 	cp.b	r8,r5
80003194:	ce e1       	brne	80003170 <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
80003196:	f0 1f 00 7a 	mcall	8000337c <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
8000319a:	5b fc       	cp.w	r12,-1
8000319c:	e0 80 00 db 	breq	80003352 <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
800031a0:	58 1c       	cp.w	r12,1
800031a2:	c0 51       	brne	800031ac <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
800031a4:	30 29       	mov	r9,2
800031a6:	4f 38       	lddpc	r8,80003370 <sd_mmc_spi_internal_init+0x284>
800031a8:	b0 89       	st.b	r8[0x0],r9
800031aa:	c4 c8       	rjmp	80003242 <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
800031ac:	30 0b       	mov	r11,0
800031ae:	33 7c       	mov	r12,55
800031b0:	f0 1f 00 71 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
800031b4:	4f 17       	lddpc	r7,80003378 <sd_mmc_spi_internal_init+0x28c>
800031b6:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800031b8:	e0 6b 00 ff 	mov	r11,255
800031bc:	fe 7c 24 00 	mov	r12,-56320
800031c0:	f0 1f 00 69 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800031c4:	30 0b       	mov	r11,0
800031c6:	32 9c       	mov	r12,41
800031c8:	f0 1f 00 6b 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
800031cc:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800031ce:	e0 6b 00 ff 	mov	r11,255
800031d2:	fe 7c 24 00 	mov	r12,-56320
800031d6:	f0 1f 00 64 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
800031da:	0f 88       	ld.ub	r8,r7[0x0]
800031dc:	e2 18 00 fe 	andl	r8,0xfe,COH
800031e0:	c0 51       	brne	800031ea <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
800031e2:	30 19       	mov	r9,1
800031e4:	4e 38       	lddpc	r8,80003370 <sd_mmc_spi_internal_init+0x284>
800031e6:	b0 89       	st.b	r8[0x0],r9
800031e8:	c2 d8       	rjmp	80003242 <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
800031ea:	30 09       	mov	r9,0
800031ec:	4e 18       	lddpc	r8,80003370 <sd_mmc_spi_internal_init+0x284>
800031ee:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800031f0:	30 0b       	mov	r11,0
800031f2:	16 9c       	mov	r12,r11
800031f4:	f0 1f 00 60 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
800031f8:	4e 08       	lddpc	r8,80003378 <sd_mmc_spi_internal_init+0x28c>
800031fa:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800031fc:	e0 6b 00 ff 	mov	r11,255
80003200:	fe 7c 24 00 	mov	r12,-56320
80003204:	f0 1f 00 58 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
80003208:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000320a:	4d c6       	lddpc	r6,80003378 <sd_mmc_spi_internal_init+0x28c>
8000320c:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000320e:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003210:	e0 62 00 ff 	mov	r2,255
80003214:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
80003218:	36 54       	mov	r4,101
8000321a:	c1 08       	rjmp	8000323a <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000321c:	06 9b       	mov	r11,r3
8000321e:	06 9c       	mov	r12,r3
80003220:	f0 1f 00 55 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
80003224:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003226:	04 9b       	mov	r11,r2
80003228:	02 9c       	mov	r12,r1
8000322a:	f0 1f 00 4f 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
8000322e:	2f f7       	sub	r7,-1
80003230:	5c 87       	casts.h	r7
        if(retry > 100)
80003232:	e8 07 19 00 	cp.h	r7,r4
80003236:	e0 80 00 8e 	breq	80003352 <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000323a:	0d 88       	ld.ub	r8,r6[0x0]
8000323c:	ea 08 18 00 	cp.b	r8,r5
80003240:	ce e1       	brne	8000321c <sd_mmc_spi_internal_init+0x130>
80003242:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003244:	4c b4       	lddpc	r4,80003370 <sd_mmc_spi_internal_init+0x284>
80003246:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80003248:	0e 93       	mov	r3,r7
8000324a:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000324c:	4c b6       	lddpc	r6,80003378 <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000324e:	e0 62 00 ff 	mov	r2,255
80003252:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003256:	09 88       	ld.ub	r8,r4[0x0]
80003258:	ea 08 18 00 	cp.b	r8,r5
8000325c:	c1 10       	breq	8000327e <sd_mmc_spi_internal_init+0x192>
8000325e:	c0 63       	brcs	8000326a <sd_mmc_spi_internal_init+0x17e>
80003260:	30 29       	mov	r9,2
80003262:	f2 08 18 00 	cp.b	r8,r9
80003266:	c2 81       	brne	800032b6 <sd_mmc_spi_internal_init+0x1ca>
80003268:	c1 98       	rjmp	8000329a <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
8000326a:	06 9b       	mov	r11,r3
8000326c:	30 1c       	mov	r12,1
8000326e:	f0 1f 00 42 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
80003272:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003274:	04 9b       	mov	r11,r2
80003276:	02 9c       	mov	r12,r1
80003278:	f0 1f 00 3b 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
      break;
8000327c:	c1 d8       	rjmp	800032b6 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000327e:	06 9b       	mov	r11,r3
80003280:	00 9c       	mov	r12,r0
80003282:	f0 1f 00 3d 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80003286:	06 9b       	mov	r11,r3
80003288:	32 9c       	mov	r12,41
8000328a:	f0 1f 00 3b 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
8000328e:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003290:	04 9b       	mov	r11,r2
80003292:	02 9c       	mov	r12,r1
80003294:	f0 1f 00 34 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
      break;
80003298:	c0 f8       	rjmp	800032b6 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000329a:	06 9b       	mov	r11,r3
8000329c:	00 9c       	mov	r12,r0
8000329e:	f0 1f 00 36 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
800032a2:	fc 1b 40 00 	movh	r11,0x4000
800032a6:	32 9c       	mov	r12,41
800032a8:	f0 1f 00 33 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
800032ac:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800032ae:	04 9b       	mov	r11,r2
800032b0:	02 9c       	mov	r12,r1
800032b2:	f0 1f 00 2d 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
800032b6:	2f f7       	sub	r7,-1
800032b8:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
800032ba:	fe 78 c3 50 	mov	r8,-15536
800032be:	f0 07 19 00 	cp.h	r7,r8
800032c2:	c4 80       	breq	80003352 <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
800032c4:	0d 89       	ld.ub	r9,r6[0x0]
800032c6:	30 08       	mov	r8,0
800032c8:	f0 09 18 00 	cp.b	r9,r8
800032cc:	cc 51       	brne	80003256 <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
800032ce:	4a 98       	lddpc	r8,80003370 <sd_mmc_spi_internal_init+0x284>
800032d0:	11 89       	ld.ub	r9,r8[0x0]
800032d2:	30 28       	mov	r8,2
800032d4:	f0 09 18 00 	cp.b	r9,r8
800032d8:	c0 a1       	brne	800032ec <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
800032da:	f0 1f 00 2a 	mcall	80003380 <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
800032de:	5b fc       	cp.w	r12,-1
800032e0:	c3 90       	breq	80003352 <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
800032e2:	58 1c       	cp.w	r12,1
800032e4:	c0 41       	brne	800032ec <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
800032e6:	30 39       	mov	r9,3
800032e8:	4a 28       	lddpc	r8,80003370 <sd_mmc_spi_internal_init+0x284>
800032ea:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
800032ec:	30 0b       	mov	r11,0
800032ee:	33 bc       	mov	r12,59
800032f0:	f0 1f 00 21 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
800032f4:	4a 17       	lddpc	r7,80003378 <sd_mmc_spi_internal_init+0x28c>
800032f6:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800032f8:	e0 6b 00 ff 	mov	r11,255
800032fc:	fe 7c 24 00 	mov	r12,-56320
80003300:	f0 1f 00 19 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80003304:	e0 6b 02 00 	mov	r11,512
80003308:	31 0c       	mov	r12,16
8000330a:	f0 1f 00 1b 	mcall	80003374 <sd_mmc_spi_internal_init+0x288>
8000330e:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003310:	e0 6b 00 ff 	mov	r11,255
80003314:	fe 7c 24 00 	mov	r12,-56320
80003318:	f0 1f 00 13 	mcall	80003364 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
8000331c:	0f 89       	ld.ub	r9,r7[0x0]
8000331e:	30 08       	mov	r8,0
80003320:	f0 09 18 00 	cp.b	r9,r8
80003324:	c1 71       	brne	80003352 <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80003326:	49 8c       	lddpc	r12,80003384 <sd_mmc_spi_internal_init+0x298>
80003328:	f0 1f 00 18 	mcall	80003388 <sd_mmc_spi_internal_init+0x29c>
8000332c:	c1 30       	breq	80003352 <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
8000332e:	f0 1f 00 18 	mcall	8000338c <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80003332:	30 19       	mov	r9,1
80003334:	48 e8       	lddpc	r8,8000336c <sd_mmc_spi_internal_init+0x280>
80003336:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80003338:	48 7b       	lddpc	r11,80003354 <sd_mmc_spi_internal_init+0x268>
8000333a:	e0 68 1b 00 	mov	r8,6912
8000333e:	ea 18 00 b7 	orh	r8,0xb7
80003342:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80003344:	48 58       	lddpc	r8,80003358 <sd_mmc_spi_internal_init+0x26c>
80003346:	70 0a       	ld.w	r10,r8[0x0]
80003348:	fe 7c 24 00 	mov	r12,-56320
8000334c:	f0 1f 00 04 	mcall	8000335c <sd_mmc_spi_internal_init+0x270>
80003350:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
80003352:	d8 3a       	popm	r0-r7,pc,r12=0
80003354:	00 00       	add	r0,r0
80003356:	05 30       	ld.ub	r0,r2++
80003358:	00 00       	add	r0,r0
8000335a:	05 40       	ld.w	r0,--r2
8000335c:	80 00       	ld.sh	r0,r0[0x0]
8000335e:	39 a0       	mov	r0,-102
80003360:	80 00       	ld.sh	r0,r0[0x0]
80003362:	3a cc       	mov	r12,-84
80003364:	80 00       	ld.sh	r0,r0[0x0]
80003366:	39 64       	mov	r4,-106
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	3a 8c       	mov	r12,-88
8000336c:	00 00       	add	r0,r0
8000336e:	05 44       	ld.w	r4,--r2
80003370:	00 00       	add	r0,r0
80003372:	0a 52       	eor	r2,r5
80003374:	80 00       	ld.sh	r0,r0[0x0]
80003376:	2b 34       	sub	r4,-77
80003378:	00 00       	add	r0,r0
8000337a:	0a 64       	and	r4,r5
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	2d dc       	sub	r12,-35
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	2d 50       	sub	r0,-43
80003384:	00 00       	add	r0,r0
80003386:	0a 54       	eor	r4,r5
80003388:	80 00       	ld.sh	r0,r0[0x0]
8000338a:	2f f8       	sub	r8,-1
8000338c:	80 00       	ld.sh	r0,r0[0x0]
8000338e:	28 7c       	sub	r12,-121

80003390 <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80003390:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
80003392:	f0 1f 00 07 	mcall	800033ac <sd_mmc_spi_mem_check+0x1c>
80003396:	c0 a0       	breq	800033aa <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
80003398:	48 68       	lddpc	r8,800033b0 <sd_mmc_spi_mem_check+0x20>
8000339a:	11 89       	ld.ub	r9,r8[0x0]
8000339c:	30 08       	mov	r8,0
8000339e:	f0 09 18 00 	cp.b	r9,r8
800033a2:	c0 20       	breq	800033a6 <sd_mmc_spi_mem_check+0x16>
800033a4:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
800033a6:	f0 1f 00 04 	mcall	800033b4 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
800033aa:	d8 02       	popm	pc
800033ac:	80 00       	ld.sh	r0,r0[0x0]
800033ae:	2b 74       	sub	r4,-73
800033b0:	00 00       	add	r0,r0
800033b2:	05 44       	ld.w	r4,--r2
800033b4:	80 00       	ld.sh	r0,r0[0x0]
800033b6:	30 ec       	mov	r12,14

800033b8 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
800033b8:	eb cd 40 10 	pushm	r4,lr
800033bc:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
800033c0:	48 88       	lddpc	r8,800033e0 <sd_mmc_spi_init+0x28>
800033c2:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
800033c4:	48 88       	lddpc	r8,800033e4 <sd_mmc_spi_init+0x2c>
800033c6:	e8 ea 00 00 	ld.d	r10,r4[0]
800033ca:	f0 eb 00 00 	st.d	r8[0],r10
800033ce:	e8 ea 00 08 	ld.d	r10,r4[8]
800033d2:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
800033d6:	f0 1f 00 05 	mcall	800033e8 <sd_mmc_spi_init+0x30>
}
800033da:	e3 cd 80 10 	ldm	sp++,r4,pc
800033de:	00 00       	add	r0,r0
800033e0:	00 00       	add	r0,r0
800033e2:	05 40       	ld.w	r0,--r2
800033e4:	00 00       	add	r0,r0
800033e6:	05 30       	ld.ub	r0,r2++
800033e8:	80 00       	ld.sh	r0,r0[0x0]
800033ea:	30 ec       	mov	r12,14

800033ec <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
800033ec:	5e fd       	retal	0

800033ee <sd_mmc_spi_removal>:
//!/
bool  sd_mmc_spi_removal(void)
{
  return false;
//  return ((sd_mmc_spi_check_presence()) ? false : true);
}
800033ee:	5e fd       	retal	0

800033f0 <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
800033f0:	d4 01       	pushm	lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
800033f2:	49 88       	lddpc	r8,80003450 <sd_mmc_spi_test_unit_ready+0x60>
800033f4:	11 88       	ld.ub	r8,r8[0x0]
800033f6:	30 19       	mov	r9,1
800033f8:	f2 08 18 00 	cp.b	r8,r9
800033fc:	c1 40       	breq	80003424 <sd_mmc_spi_test_unit_ready+0x34>
800033fe:	c0 63       	brcs	8000340a <sd_mmc_spi_test_unit_ready+0x1a>
80003400:	30 29       	mov	r9,2
80003402:	f2 08 18 00 	cp.b	r8,r9
80003406:	c2 01       	brne	80003446 <sd_mmc_spi_test_unit_ready+0x56>
80003408:	c1 a8       	rjmp	8000343c <sd_mmc_spi_test_unit_ready+0x4c>
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
8000340a:	30 09       	mov	r9,0
8000340c:	49 28       	lddpc	r8,80003454 <sd_mmc_spi_test_unit_ready+0x64>
8000340e:	b0 89       	st.b	r8[0x0],r9
      if (sd_mmc_spi_mem_check())
80003410:	f0 1f 00 12 	mcall	80003458 <sd_mmc_spi_test_unit_ready+0x68>
80003414:	c0 31       	brne	8000341a <sd_mmc_spi_test_unit_ready+0x2a>
80003416:	30 2c       	mov	r12,2
80003418:	d8 02       	popm	pc
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
8000341a:	30 19       	mov	r9,1
8000341c:	48 d8       	lddpc	r8,80003450 <sd_mmc_spi_test_unit_ready+0x60>
8000341e:	b0 89       	st.b	r8[0x0],r9
80003420:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
80003422:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
80003424:	f0 1f 00 0d 	mcall	80003458 <sd_mmc_spi_test_unit_ready+0x68>
80003428:	c0 20       	breq	8000342c <sd_mmc_spi_test_unit_ready+0x3c>
8000342a:	d8 0a       	popm	pc,r12=0
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
8000342c:	30 29       	mov	r9,2
8000342e:	48 98       	lddpc	r8,80003450 <sd_mmc_spi_test_unit_ready+0x60>
80003430:	b0 89       	st.b	r8[0x0],r9
        sd_mmc_spi_init_done = false;
80003432:	30 09       	mov	r9,0
80003434:	48 88       	lddpc	r8,80003454 <sd_mmc_spi_test_unit_ready+0x64>
80003436:	b0 89       	st.b	r8[0x0],r9
80003438:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
8000343a:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
8000343c:	30 09       	mov	r9,0
8000343e:	48 58       	lddpc	r8,80003450 <sd_mmc_spi_test_unit_ready+0x60>
80003440:	b0 89       	st.b	r8[0x0],r9
80003442:	30 2c       	mov	r12,2
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
80003444:	d8 02       	popm	pc

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80003446:	30 09       	mov	r9,0
80003448:	48 28       	lddpc	r8,80003450 <sd_mmc_spi_test_unit_ready+0x60>
8000344a:	b0 89       	st.b	r8[0x0],r9
8000344c:	30 3c       	mov	r12,3
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
8000344e:	d8 02       	popm	pc
80003450:	00 00       	add	r0,r0
80003452:	00 08       	add	r8,r0
80003454:	00 00       	add	r0,r0
80003456:	05 44       	ld.w	r4,--r2
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	33 90       	mov	r0,57

8000345c <sd_mmc_spi_mem_init>:

//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
8000345c:	d4 01       	pushm	lr
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
8000345e:	f0 1f 00 02 	mcall	80003464 <sd_mmc_spi_mem_init+0x8>
}
80003462:	d8 02       	popm	pc
80003464:	80 00       	ld.sh	r0,r0[0x0]
80003466:	30 ec       	mov	r12,14

80003468 <sd_mmc_spi_ram_2_mem>:
//! @return                Ctrl_status
//!   It is ready      ->    CTRL_GOOD
//!   An error occurs  ->    CTRL_FAIL
//!
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
80003468:	eb cd 40 c0 	pushm	r6-r7,lr
8000346c:	18 96       	mov	r6,r12
8000346e:	16 97       	mov	r7,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
80003470:	f0 1f 00 12 	mcall	800034b8 <sd_mmc_spi_ram_2_mem+0x50>

   if (!sd_mmc_spi_init_done)
80003474:	49 28       	lddpc	r8,800034bc <sd_mmc_spi_ram_2_mem+0x54>
80003476:	11 89       	ld.ub	r9,r8[0x0]
80003478:	30 08       	mov	r8,0
8000347a:	f0 09 18 00 	cp.b	r9,r8
8000347e:	c0 c1       	brne	80003496 <sd_mmc_spi_ram_2_mem+0x2e>
   {
      sd_mmc_spi_mem_init();
80003480:	f0 1f 00 10 	mcall	800034c0 <sd_mmc_spi_ram_2_mem+0x58>
   }

   if (sd_mmc_spi_init_done)
80003484:	48 e8       	lddpc	r8,800034bc <sd_mmc_spi_ram_2_mem+0x54>
80003486:	11 89       	ld.ub	r9,r8[0x0]
80003488:	30 08       	mov	r8,0
8000348a:	f0 09 18 00 	cp.b	r9,r8
8000348e:	c0 41       	brne	80003496 <sd_mmc_spi_ram_2_mem+0x2e>
80003490:	30 2c       	mov	r12,2
80003492:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   {
     sd_mmc_spi_write_open(addr);
80003496:	0c 9c       	mov	r12,r6
80003498:	f0 1f 00 0b 	mcall	800034c4 <sd_mmc_spi_ram_2_mem+0x5c>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
8000349c:	0e 9c       	mov	r12,r7
8000349e:	f0 1f 00 0b 	mcall	800034c8 <sd_mmc_spi_ram_2_mem+0x60>
800034a2:	c0 61       	brne	800034ae <sd_mmc_spi_ram_2_mem+0x46>
     {
       sd_mmc_spi_write_close();
800034a4:	f0 1f 00 0a 	mcall	800034cc <sd_mmc_spi_ram_2_mem+0x64>
800034a8:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
800034aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     }
     sd_mmc_spi_write_close();
800034ae:	f0 1f 00 08 	mcall	800034cc <sd_mmc_spi_ram_2_mem+0x64>
800034b2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800034b6:	00 00       	add	r0,r0
800034b8:	80 00       	ld.sh	r0,r0[0x0]
800034ba:	2b 74       	sub	r4,-73
800034bc:	00 00       	add	r0,r0
800034be:	05 44       	ld.w	r4,--r2
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	34 5c       	mov	r12,69
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	2a 28       	sub	r8,-94
800034c8:	80 00       	ld.sh	r0,r0[0x0]
800034ca:	2b f0       	sub	r0,-65
800034cc:	80 00       	ld.sh	r0,r0[0x0]
800034ce:	29 98       	sub	r8,-103

800034d0 <sd_mmc_spi_mem_2_ram>:
//------------ Standard functions for read/write 1 sector to 1 sector ram buffer -----------------

#if ACCESS_MEM_TO_RAM == true

Ctrl_status sd_mmc_spi_mem_2_ram(uint32_t addr, void *ram)
{
800034d0:	eb cd 40 c0 	pushm	r6-r7,lr
800034d4:	18 97       	mov	r7,r12
800034d6:	16 96       	mov	r6,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
800034d8:	f0 1f 00 12 	mcall	80003520 <sd_mmc_spi_mem_2_ram+0x50>

   if (!sd_mmc_spi_init_done)
800034dc:	49 28       	lddpc	r8,80003524 <sd_mmc_spi_mem_2_ram+0x54>
800034de:	11 89       	ld.ub	r9,r8[0x0]
800034e0:	30 08       	mov	r8,0
800034e2:	f0 09 18 00 	cp.b	r9,r8
800034e6:	c0 c1       	brne	800034fe <sd_mmc_spi_mem_2_ram+0x2e>
   {
      sd_mmc_spi_mem_init();
800034e8:	f0 1f 00 10 	mcall	80003528 <sd_mmc_spi_mem_2_ram+0x58>
   }

   if (!sd_mmc_spi_init_done)
800034ec:	48 e8       	lddpc	r8,80003524 <sd_mmc_spi_mem_2_ram+0x54>
800034ee:	11 89       	ld.ub	r9,r8[0x0]
800034f0:	30 08       	mov	r8,0
800034f2:	f0 09 18 00 	cp.b	r9,r8
800034f6:	c0 41       	brne	800034fe <sd_mmc_spi_mem_2_ram+0x2e>
800034f8:	30 2c       	mov	r12,2
800034fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
800034fe:	0e 9c       	mov	r12,r7
80003500:	f0 1f 00 0b 	mcall	8000352c <sd_mmc_spi_mem_2_ram+0x5c>
80003504:	c0 c0       	breq	8000351c <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
80003506:	0c 9c       	mov	r12,r6
80003508:	f0 1f 00 0a 	mcall	80003530 <sd_mmc_spi_mem_2_ram+0x60>
8000350c:	c0 80       	breq	8000351c <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
8000350e:	f0 1f 00 0a 	mcall	80003534 <sd_mmc_spi_mem_2_ram+0x64>
80003512:	ec 1c 00 01 	eorl	r12,0x1
80003516:	5c 5c       	castu.b	r12
80003518:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000351c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003520:	80 00       	ld.sh	r0,r0[0x0]
80003522:	2b 74       	sub	r4,-73
80003524:	00 00       	add	r0,r0
80003526:	05 44       	ld.w	r4,--r2
80003528:	80 00       	ld.sh	r0,r0[0x0]
8000352a:	34 5c       	mov	r12,69
8000352c:	80 00       	ld.sh	r0,r0[0x0]
8000352e:	2a 50       	sub	r0,-91
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	2e 94       	sub	r4,-23
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	2a 44       	sub	r4,-92

80003538 <sd_mmc_spi_read_capacity>:
}



Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector)
{
80003538:	eb cd 40 80 	pushm	r7,lr
8000353c:	18 97       	mov	r7,r12
//   sd_mmc_spi_check_presence();   // omitted because creates interferences with "sd_mmc_spi_test_unit_ready()" function
   Sd_mmc_spi_access_signal_on();

   if (!sd_mmc_spi_init_done)
8000353e:	48 c8       	lddpc	r8,8000356c <sd_mmc_spi_read_capacity+0x34>
80003540:	11 89       	ld.ub	r9,r8[0x0]
80003542:	30 08       	mov	r8,0
80003544:	f0 09 18 00 	cp.b	r9,r8
80003548:	c0 c1       	brne	80003560 <sd_mmc_spi_read_capacity+0x28>
   {
      sd_mmc_spi_mem_init();
8000354a:	f0 1f 00 0a 	mcall	80003570 <sd_mmc_spi_read_capacity+0x38>
   }

   if (sd_mmc_spi_init_done)
8000354e:	48 88       	lddpc	r8,8000356c <sd_mmc_spi_read_capacity+0x34>
80003550:	11 89       	ld.ub	r9,r8[0x0]
80003552:	30 08       	mov	r8,0
80003554:	f0 09 18 00 	cp.b	r9,r8
80003558:	c0 41       	brne	80003560 <sd_mmc_spi_read_capacity+0x28>
8000355a:	30 2c       	mov	r12,2
8000355c:	e3 cd 80 80 	ldm	sp++,r7,pc
   {
     *nb_sector = sd_mmc_spi_last_block_address+1;
80003560:	48 58       	lddpc	r8,80003574 <sd_mmc_spi_read_capacity+0x3c>
80003562:	70 08       	ld.w	r8,r8[0x0]
80003564:	2f f8       	sub	r8,-1
80003566:	8f 08       	st.w	r7[0x0],r8
80003568:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000356c:	00 00       	add	r0,r0
8000356e:	05 44       	ld.w	r4,--r2
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	34 5c       	mov	r12,69
80003574:	00 00       	add	r0,r0
80003576:	0a 4c       	or	r12,r5

80003578 <sdramc_ck_delay>:
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
80003578:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
8000357c:	f0 0c 00 0c 	add	r12,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80003580:	18 38       	cp.w	r8,r12
80003582:	e0 88 00 06 	brls	8000358e <sdramc_ck_delay+0x16>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80003586:	e1 b8 00 42 	mfsr	r8,0x108
8000358a:	10 3c       	cp.w	r12,r8
8000358c:	cf d3       	brcs	80003586 <sdramc_ck_delay+0xe>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
8000358e:	e1 b8 00 42 	mfsr	r8,0x108
80003592:	10 3c       	cp.w	r12,r8
80003594:	fe 9b ff fd 	brhi	8000358e <sdramc_ck_delay+0x16>
}
80003598:	5e fc       	retal	r12
8000359a:	d7 03       	nop

8000359c <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
8000359c:	d4 31       	pushm	r0-r7,lr
8000359e:	20 2d       	sub	sp,8
800035a0:	18 91       	mov	r1,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
800035a2:	ee 7b 42 3f 	mov	r11,999999
800035a6:	f8 0b 00 09 	add	r9,r12,r11
800035aa:	e0 60 de 83 	mov	r0,56963
800035ae:	ea 10 43 1b 	orh	r0,0x431b
800035b2:	f2 00 06 48 	mulu.d	r8,r9,r0
800035b6:	f2 06 16 12 	lsr	r6,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
800035ba:	32 7b       	mov	r11,39
800035bc:	4d 0c       	lddpc	r12,800036fc <sdramc_init+0x160>
800035be:	f0 1f 00 51 	mcall	80003700 <sdramc_init+0x164>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
800035c2:	fe 68 10 00 	mov	r8,-126976
800035c6:	f0 f9 01 24 	ld.w	r9,r8[292]
800035ca:	a1 b9       	sbr	r9,0x1
800035cc:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
800035d0:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
800035d4:	ec 09 15 04 	lsl	r9,r6,0x4
800035d8:	0c 19       	sub	r9,r6
800035da:	f2 c3 fc 19 	sub	r3,r9,-999
800035de:	e0 65 4d d3 	mov	r5,19923
800035e2:	ea 15 10 62 	orh	r5,0x1062
800035e6:	e6 05 06 42 	mulu.d	r2,r3,r5
800035ea:	a7 83       	lsr	r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
800035ec:	ec 02 15 05 	lsl	r2,r6,0x5
800035f0:	0c 02       	add	r2,r6
800035f2:	a1 72       	lsl	r2,0x1
800035f4:	e4 06 00 0b 	add	r11,r2,r6
800035f8:	f6 cb fc 19 	sub	r11,r11,-999
800035fc:	f6 05 06 4a 	mulu.d	r10,r11,r5
80003600:	a7 8b       	lsr	r11,0x6
80003602:	bd 6b       	lsl	r11,0x1c
80003604:	16 9c       	mov	r12,r11
80003606:	e8 1c 00 d9 	orl	r12,0xd9
8000360a:	ec 08 15 03 	lsl	r8,r6,0x3
8000360e:	f0 06 01 0a 	sub	r10,r8,r6
80003612:	a1 7a       	lsl	r10,0x1
80003614:	f4 c7 fc 19 	sub	r7,r10,-999
80003618:	ee 05 06 4a 	mulu.d	r10,r7,r5
8000361c:	fa eb 00 00 	st.d	sp[0],r10
80003620:	40 0a       	lddsp	r10,sp[0x0]
80003622:	a3 6a       	lsl	r10,0x2
80003624:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003628:	14 4c       	or	r12,r10
8000362a:	a3 69       	lsl	r9,0x2
8000362c:	f2 c9 fc 19 	sub	r9,r9,-999
80003630:	f2 05 06 4a 	mulu.d	r10,r9,r5
80003634:	fa eb 00 00 	st.d	sp[0],r10
80003638:	40 09       	lddsp	r9,sp[0x0]
8000363a:	a7 69       	lsl	r9,0x6
8000363c:	e2 19 f0 00 	andl	r9,0xf000,COH
80003640:	f9 e9 10 0a 	or	r10,r12,r9
80003644:	e6 09 15 10 	lsl	r9,r3,0x10
80003648:	e6 19 00 0f 	andh	r9,0xf,COH
8000364c:	12 4a       	or	r10,r9
8000364e:	e6 09 15 14 	lsl	r9,r3,0x14
80003652:	e6 19 00 f0 	andh	r9,0xf0,COH
80003656:	12 4a       	or	r10,r9
80003658:	f0 06 00 09 	add	r9,r8,r6
8000365c:	ec 09 00 29 	add	r9,r6,r9<<0x2
80003660:	f2 c9 fc 19 	sub	r9,r9,-999
80003664:	f2 05 06 48 	mulu.d	r8,r9,r5
80003668:	b3 69       	lsl	r9,0x12
8000366a:	e6 19 0f 00 	andh	r9,0xf00,COH
8000366e:	f5 e9 10 08 	or	r8,r10,r9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
80003672:	fe 67 20 00 	mov	r7,-122880
80003676:	8f 28       	st.w	r7[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
80003678:	6e 28       	ld.w	r8,r7[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
8000367a:	30 18       	mov	r8,1
8000367c:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
8000367e:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003680:	fc 14 d0 00 	movh	r4,0xd000
80003684:	88 08       	ld.sh	r8,r4[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
80003686:	ec 0c 10 64 	mul	r12,r6,100
8000368a:	f0 1f 00 1f 	mcall	80003704 <sdramc_init+0x168>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
8000368e:	30 28       	mov	r8,2
80003690:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003692:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003694:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
80003696:	06 9c       	mov	r12,r3
80003698:	f0 1f 00 1b 	mcall	80003704 <sdramc_init+0x168>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
8000369c:	30 48       	mov	r8,4
8000369e:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800036a0:	6e 08       	ld.w	r8,r7[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
800036a2:	e4 c3 fc 19 	sub	r3,r2,-999
800036a6:	e6 05 06 42 	mulu.d	r2,r3,r5
800036aa:	a7 83       	lsr	r3,0x6
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
800036ac:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
800036ae:	06 9c       	mov	r12,r3
800036b0:	f0 1f 00 15 	mcall	80003704 <sdramc_init+0x168>
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
800036b4:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
800036b6:	06 9c       	mov	r12,r3
800036b8:	f0 1f 00 13 	mcall	80003704 <sdramc_init+0x168>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
800036bc:	30 38       	mov	r8,3
800036be:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800036c0:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
800036c2:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
800036c4:	ec 09 15 01 	lsl	r9,r6,0x1
800036c8:	f2 c9 fc 19 	sub	r9,r9,-999
800036cc:	f2 05 06 48 	mulu.d	r8,r9,r5
800036d0:	f2 0c 16 06 	lsr	r12,r9,0x6
800036d4:	f0 1f 00 0c 	mcall	80003704 <sdramc_init+0x168>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
800036d8:	30 08       	mov	r8,0
800036da:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800036dc:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
800036de:	88 08       	ld.sh	r8,r4[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
800036e0:	e2 00 06 40 	mulu.d	r0,r1,r0
800036e4:	b3 81       	lsr	r1,0x12
800036e6:	e0 68 1e 84 	mov	r8,7812
800036ea:	b1 31       	mul	r1,r8
800036ec:	e2 05 06 44 	mulu.d	r4,r1,r5
800036f0:	a7 85       	lsr	r5,0x6
800036f2:	8f 15       	st.w	r7[0x4],r5
  AVR32_SDRAMC.tr;
800036f4:	6e 18       	ld.w	r8,r7[0x4]
}
800036f6:	2f ed       	sub	sp,-8
800036f8:	d8 32       	popm	r0-r7,pc
800036fa:	00 00       	add	r0,r0
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	9b 08       	st.w	sp[0x0],r8
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	80 60       	ld.sh	r0,r0[0xc]
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	35 78       	mov	r8,87

80003708 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80003708:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8000370c:	ee 78 42 3f 	mov	r8,999999
80003710:	f8 08 00 09 	add	r9,r12,r8
80003714:	e0 68 de 83 	mov	r8,56963
80003718:	ea 18 43 1b 	orh	r8,0x431b
8000371c:	f2 08 06 48 	mulu.d	r8,r9,r8
80003720:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80003724:	f0 08 00 25 	add	r5,r8,r8<<0x2
80003728:	a3 65       	lsl	r5,0x2
8000372a:	ea c5 fc 19 	sub	r5,r5,-999
8000372e:	e0 69 4d d3 	mov	r9,19923
80003732:	ea 19 10 62 	orh	r9,0x1062
80003736:	ea 09 06 44 	mulu.d	r4,r5,r9
8000373a:	a7 85       	lsr	r5,0x6
8000373c:	f0 0a 15 04 	lsl	r10,r8,0x4
80003740:	f4 08 01 07 	sub	r7,r10,r8
80003744:	a1 77       	lsl	r7,0x1
80003746:	ee c7 fc 19 	sub	r7,r7,-999
8000374a:	ee 09 06 46 	mulu.d	r6,r7,r9
8000374e:	0e 94       	mov	r4,r7
80003750:	a7 84       	lsr	r4,0x6
80003752:	f4 08 01 07 	sub	r7,r10,r8
80003756:	a3 67       	lsl	r7,0x2
80003758:	ee c7 fc 19 	sub	r7,r7,-999
8000375c:	ee 09 06 46 	mulu.d	r6,r7,r9
80003760:	a7 87       	lsr	r7,0x6
80003762:	f0 03 10 5a 	mul	r3,r8,90
80003766:	e6 c3 fc 19 	sub	r3,r3,-999
8000376a:	e6 09 06 42 	mulu.d	r2,r3,r9
8000376e:	e6 0c 16 06 	lsr	r12,r3,0x6
80003772:	e0 63 00 d2 	mov	r3,210
80003776:	f0 03 02 43 	mul	r3,r8,r3
8000377a:	e6 c3 fc 19 	sub	r3,r3,-999
8000377e:	e6 09 06 42 	mulu.d	r2,r3,r9
80003782:	e6 06 16 06 	lsr	r6,r3,0x6
80003786:	f4 08 01 0b 	sub	r11,r10,r8
8000378a:	a5 6b       	lsl	r11,0x4
8000378c:	f6 cb fc 19 	sub	r11,r11,-999
80003790:	f6 09 06 4a 	mulu.d	r10,r11,r9
80003794:	f6 0e 16 06 	lsr	lr,r11,0x6
80003798:	f0 03 10 64 	mul	r3,r8,100
8000379c:	e6 c3 fc 19 	sub	r3,r3,-999
800037a0:	e6 09 06 42 	mulu.d	r2,r3,r9
800037a4:	a7 83       	lsr	r3,0x6
800037a6:	e0 6a 01 0e 	mov	r10,270
800037aa:	b5 38       	mul	r8,r10
800037ac:	f0 c8 fc 19 	sub	r8,r8,-999
800037b0:	f0 09 06 48 	mulu.d	r8,r8,r9
800037b4:	a7 89       	lsr	r9,0x6
800037b6:	ec 04 00 0a 	add	r10,r6,r4
800037ba:	1c 3a       	cp.w	r10,lr
800037bc:	f4 0e 17 20 	movhs	lr,r10
800037c0:	ee 05 00 0b 	add	r11,r7,r5
800037c4:	18 3b       	cp.w	r11,r12
800037c6:	f6 0c 17 20 	movhs	r12,r11
800037ca:	06 3b       	cp.w	r11,r3
800037cc:	e6 0b 17 30 	movlo	r11,r3
800037d0:	12 3a       	cp.w	r10,r9
800037d2:	f4 09 17 20 	movhs	r9,r10
800037d6:	eb e4 11 05 	or	r5,r5,r4<<0x10
800037da:	fe 6a 1c 00 	mov	r10,-123904
800037de:	95 05       	st.w	r10[0x0],r5
800037e0:	ef e6 11 07 	or	r7,r7,r6<<0x10
800037e4:	ef ec 10 87 	or	r7,r7,r12<<0x8
800037e8:	ef ee 11 87 	or	r7,r7,lr<<0x18
800037ec:	95 17       	st.w	r10[0x4],r7
800037ee:	1c 39       	cp.w	r9,lr
800037f0:	f2 0e 17 20 	movhs	lr,r9
800037f4:	18 3b       	cp.w	r11,r12
800037f6:	f8 0b 17 30 	movlo	r11,r12
800037fa:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
800037fe:	95 2b       	st.w	r10[0x8],r11
80003800:	e0 68 10 03 	mov	r8,4099
80003804:	95 38       	st.w	r10[0xc],r8
80003806:	30 19       	mov	r9,1
80003808:	48 48       	lddpc	r8,80003818 <smc_init+0x110>
8000380a:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
8000380c:	31 4b       	mov	r11,20
8000380e:	48 4c       	lddpc	r12,8000381c <smc_init+0x114>
80003810:	f0 1f 00 04 	mcall	80003820 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80003814:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003818:	00 00       	add	r0,r0
8000381a:	05 48       	ld.w	r8,--r2
8000381c:	80 00       	ld.sh	r0,r0[0x0]
8000381e:	9c 40       	ld.sh	r0,lr[0x8]
80003820:	80 00       	ld.sh	r0,r0[0x0]
80003822:	80 60       	ld.sh	r0,r0[0xc]

80003824 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80003824:	58 0b       	cp.w	r11,0
80003826:	c1 90       	breq	80003858 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003828:	58 6c       	cp.w	r12,6
8000382a:	e0 8b 00 17 	brhi	80003858 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000382e:	76 0a       	ld.w	r10,r11[0x0]
80003830:	fe 78 30 00 	mov	r8,-53248
80003834:	f8 c9 ff f0 	sub	r9,r12,-16
80003838:	a5 79       	lsl	r9,0x5
8000383a:	f0 09 00 09 	add	r9,r8,r9
8000383e:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003840:	76 19       	ld.w	r9,r11[0x4]
80003842:	a5 7c       	lsl	r12,0x5
80003844:	f0 0c 00 0c 	add	r12,r8,r12
80003848:	f8 c8 fd fc 	sub	r8,r12,-516
8000384c:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
8000384e:	76 28       	ld.w	r8,r11[0x8]
80003850:	f8 cc fd f8 	sub	r12,r12,-520
80003854:	99 08       	st.w	r12[0x0],r8
80003856:	5e fd       	retal	0

  return PWM_SUCCESS;
80003858:	5e ff       	retal	1

8000385a <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
8000385a:	18 98       	mov	r8,r12
8000385c:	e0 18 ff 80 	andl	r8,0xff80
80003860:	c0 20       	breq	80003864 <pwm_start_channels+0xa>
80003862:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
80003864:	fe 78 30 00 	mov	r8,-53248
80003868:	91 1c       	st.w	r8[0x4],r12
8000386a:	5e fd       	retal	0

8000386c <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
8000386c:	58 6c       	cp.w	r12,6
8000386e:	e0 88 00 03 	brls	80003874 <pwm_async_update_channel+0x8>
80003872:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
80003874:	76 0a       	ld.w	r10,r11[0x0]
80003876:	fe 78 30 00 	mov	r8,-53248
8000387a:	f8 c9 ff f0 	sub	r9,r12,-16
8000387e:	a5 79       	lsl	r9,0x5
80003880:	f0 09 00 09 	add	r9,r8,r9
80003884:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
80003886:	76 49       	ld.w	r9,r11[0x10]
80003888:	a5 7c       	lsl	r12,0x5
8000388a:	18 08       	add	r8,r12
8000388c:	f0 c8 fd f0 	sub	r8,r8,-528
80003890:	91 09       	st.w	r8[0x0],r9
80003892:	5e fd       	retal	0

80003894 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80003894:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80003898:	58 0c       	cp.w	r12,0
8000389a:	c0 21       	brne	8000389e <pwm_init+0xa>
8000389c:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000389e:	e6 18 00 01 	andh	r8,0x1,COH
800038a2:	c0 91       	brne	800038b4 <pwm_init+0x20>
800038a4:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800038a6:	fe 78 30 00 	mov	r8,-53248
800038aa:	37 f9       	mov	r9,127
800038ac:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800038ae:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800038b0:	d5 03       	csrf	0x10
800038b2:	c0 68       	rjmp	800038be <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800038b4:	fe 78 30 00 	mov	r8,-53248
800038b8:	37 f9       	mov	r9,127
800038ba:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800038bc:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800038be:	78 08       	ld.w	r8,r12[0x0]
800038c0:	78 39       	ld.w	r9,r12[0xc]
800038c2:	a9 69       	lsl	r9,0x8
800038c4:	f3 e8 11 09 	or	r9,r9,r8<<0x10
800038c8:	78 18       	ld.w	r8,r12[0x4]
800038ca:	10 49       	or	r9,r8
800038cc:	78 28       	ld.w	r8,r12[0x8]
800038ce:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
800038d2:	fe 78 30 00 	mov	r8,-53248
800038d6:	91 09       	st.w	r8[0x0],r9
800038d8:	5e fd       	retal	0

800038da <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800038da:	f8 c8 00 01 	sub	r8,r12,1
800038de:	f0 0b 00 0b 	add	r11,r8,r11
800038e2:	f6 0c 0d 0a 	divu	r10,r11,r12
800038e6:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800038e8:	f4 c8 00 01 	sub	r8,r10,1
800038ec:	e0 48 00 fe 	cp.w	r8,254
800038f0:	e0 88 00 03 	brls	800038f6 <getBaudDiv+0x1c>
800038f4:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800038f6:	5c 8c       	casts.h	r12
}
800038f8:	5e fc       	retal	r12

800038fa <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800038fa:	f7 39 00 0d 	ld.ub	r9,r11[13]
800038fe:	30 18       	mov	r8,1
80003900:	f0 09 18 00 	cp.b	r9,r8
80003904:	e0 88 00 04 	brls	8000390c <spi_initMaster+0x12>
80003908:	30 2c       	mov	r12,2
8000390a:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000390c:	e0 68 00 80 	mov	r8,128
80003910:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003912:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80003914:	30 19       	mov	r9,1
80003916:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000391a:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000391e:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80003922:	30 09       	mov	r9,0
80003924:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80003928:	30 fa       	mov	r10,15
8000392a:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000392e:	99 18       	st.w	r12[0x4],r8
80003930:	5e f9       	retal	r9

80003932 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80003932:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003934:	30 18       	mov	r8,1
80003936:	f0 0b 18 00 	cp.b	r11,r8
8000393a:	5f be       	srhi	lr
8000393c:	f0 0a 18 00 	cp.b	r10,r8
80003940:	5f b8       	srhi	r8
80003942:	fd e8 10 08 	or	r8,lr,r8
80003946:	c0 30       	breq	8000394c <spi_selectionMode+0x1a>
80003948:	30 2c       	mov	r12,2
8000394a:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000394c:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000394e:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003952:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80003956:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000395a:	99 18       	st.w	r12[0x4],r8
8000395c:	d8 0a       	popm	pc,r12=0

8000395e <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000395e:	30 18       	mov	r8,1
80003960:	99 08       	st.w	r12[0x0],r8
}
80003962:	5e fc       	retal	r12

80003964 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80003964:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003968:	c0 58       	rjmp	80003972 <spi_write+0xe>
		if (!timeout--) {
8000396a:	58 08       	cp.w	r8,0
8000396c:	c0 21       	brne	80003970 <spi_write+0xc>
8000396e:	5e ff       	retal	1
80003970:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003972:	78 49       	ld.w	r9,r12[0x10]
80003974:	e2 19 00 02 	andl	r9,0x2,COH
80003978:	cf 90       	breq	8000396a <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000397a:	5c 7b       	castu.h	r11
8000397c:	99 3b       	st.w	r12[0xc],r11
8000397e:	5e fd       	retal	0

80003980 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003980:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003984:	c0 58       	rjmp	8000398e <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80003986:	58 08       	cp.w	r8,0
80003988:	c0 21       	brne	8000398c <spi_read+0xc>
8000398a:	5e ff       	retal	1
8000398c:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000398e:	78 49       	ld.w	r9,r12[0x10]
80003990:	e2 19 02 01 	andl	r9,0x201,COH
80003994:	e0 49 02 01 	cp.w	r9,513
80003998:	cf 71       	brne	80003986 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000399a:	78 28       	ld.w	r8,r12[0x8]
8000399c:	b6 08       	st.h	r11[0x0],r8
8000399e:	5e fd       	retal	0

800039a0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800039a0:	eb cd 40 f8 	pushm	r3-r7,lr
800039a4:	18 95       	mov	r5,r12
800039a6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800039a8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800039ac:	30 38       	mov	r8,3
800039ae:	f0 06 18 00 	cp.b	r6,r8
800039b2:	e0 8b 00 5f 	brhi	80003a70 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
800039b6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800039ba:	30 18       	mov	r8,1
800039bc:	f0 04 18 00 	cp.b	r4,r8
800039c0:	e0 8b 00 58 	brhi	80003a70 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800039c4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800039c8:	30 78       	mov	r8,7
800039ca:	f0 03 18 00 	cp.b	r3,r8
800039ce:	e0 88 00 51 	brls	80003a70 <spi_setupChipReg+0xd0>
800039d2:	31 08       	mov	r8,16
800039d4:	f0 03 18 00 	cp.b	r3,r8
800039d8:	e0 8b 00 4c 	brhi	80003a70 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800039dc:	14 9b       	mov	r11,r10
800039de:	6e 1c       	ld.w	r12,r7[0x4]
800039e0:	f0 1f 00 27 	mcall	80003a7c <spi_setupChipReg+0xdc>

	if (baudDiv < 0) {
800039e4:	c4 65       	brlt	80003a70 <spi_setupChipReg+0xd0>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800039e6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800039e8:	ec 09 16 01 	lsr	r9,r6,0x1
800039ec:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800039f0:	ec 16 00 01 	eorl	r6,0x1
800039f4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800039f8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800039fc:	20 83       	sub	r3,8
800039fe:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80003a02:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003a06:	ef 39 00 09 	ld.ub	r9,r7[9]
80003a0a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003a0e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80003a12:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80003a16:	0f 89       	ld.ub	r9,r7[0x0]
80003a18:	30 1a       	mov	r10,1
80003a1a:	f4 09 18 00 	cp.b	r9,r10
80003a1e:	c0 d0       	breq	80003a38 <spi_setupChipReg+0x98>
80003a20:	c0 a3       	brcs	80003a34 <spi_setupChipReg+0x94>
80003a22:	30 2a       	mov	r10,2
80003a24:	f4 09 18 00 	cp.b	r9,r10
80003a28:	c0 a0       	breq	80003a3c <spi_setupChipReg+0x9c>
80003a2a:	30 3a       	mov	r10,3
80003a2c:	f4 09 18 00 	cp.b	r9,r10
80003a30:	c2 01       	brne	80003a70 <spi_setupChipReg+0xd0>
80003a32:	c0 78       	rjmp	80003a40 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80003a34:	8b c8       	st.w	r5[0x30],r8
		break;
80003a36:	c0 68       	rjmp	80003a42 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80003a38:	8b d8       	st.w	r5[0x34],r8
		break;
80003a3a:	c0 48       	rjmp	80003a42 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80003a3c:	8b e8       	st.w	r5[0x38],r8
		break;
80003a3e:	c0 28       	rjmp	80003a42 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80003a40:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80003a42:	49 08       	lddpc	r8,80003a80 <spi_setupChipReg+0xe0>
80003a44:	70 08       	ld.w	r8,r8[0x0]
80003a46:	58 08       	cp.w	r8,0
80003a48:	c1 71       	brne	80003a76 <spi_setupChipReg+0xd6>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80003a4a:	30 3a       	mov	r10,3
80003a4c:	30 0b       	mov	r11,0
80003a4e:	30 1c       	mov	r12,1
80003a50:	f0 1f 00 0d 	mcall	80003a84 <spi_setupChipReg+0xe4>
80003a54:	48 b8       	lddpc	r8,80003a80 <spi_setupChipReg+0xe0>
80003a56:	91 0c       	st.w	r8[0x0],r12
80003a58:	58 0c       	cp.w	r12,0
80003a5a:	c0 a0       	breq	80003a6e <spi_setupChipReg+0xce>
80003a5c:	30 09       	mov	r9,0
80003a5e:	12 9a       	mov	r10,r9
80003a60:	12 9b       	mov	r11,r9
80003a62:	f0 1f 00 0a 	mcall	80003a88 <spi_setupChipReg+0xe8>
		if (!xSPIMutex) {
80003a66:	48 78       	lddpc	r8,80003a80 <spi_setupChipReg+0xe0>
80003a68:	70 08       	ld.w	r8,r8[0x0]
80003a6a:	58 08       	cp.w	r8,0
80003a6c:	c0 51       	brne	80003a76 <spi_setupChipReg+0xd6>
80003a6e:	c0 08       	rjmp	80003a6e <spi_setupChipReg+0xce>
80003a70:	30 2c       	mov	r12,2
80003a72:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003a76:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80003a7a:	00 00       	add	r0,r0
80003a7c:	80 00       	ld.sh	r0,r0[0x0]
80003a7e:	38 da       	mov	r10,-115
80003a80:	00 00       	add	r0,r0
80003a82:	0a 68       	and	r8,r5
80003a84:	80 00       	ld.sh	r0,r0[0x0]
80003a86:	75 8c       	ld.w	r12,r10[0x60]
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	73 f8       	ld.w	r8,r9[0x7c]

80003a8c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003a8c:	d4 01       	pushm	lr
80003a8e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003a92:	c0 58       	rjmp	80003a9c <spi_unselectChip+0x10>
		if (!timeout--) {
80003a94:	58 08       	cp.w	r8,0
80003a96:	c0 21       	brne	80003a9a <spi_unselectChip+0xe>
80003a98:	da 0a       	popm	pc,r12=1
80003a9a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003a9c:	78 49       	ld.w	r9,r12[0x10]
80003a9e:	e2 19 02 00 	andl	r9,0x200,COH
80003aa2:	cf 90       	breq	80003a94 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003aa4:	78 18       	ld.w	r8,r12[0x4]
80003aa6:	ea 18 00 0f 	orh	r8,0xf
80003aaa:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003aac:	fc 18 01 00 	movh	r8,0x100
80003ab0:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80003ab2:	30 09       	mov	r9,0
80003ab4:	12 9a       	mov	r10,r9
80003ab6:	12 9b       	mov	r11,r9
80003ab8:	48 38       	lddpc	r8,80003ac4 <spi_unselectChip+0x38>
80003aba:	70 0c       	ld.w	r12,r8[0x0]
80003abc:	f0 1f 00 03 	mcall	80003ac8 <spi_unselectChip+0x3c>
80003ac0:	d8 0a       	popm	pc,r12=0
80003ac2:	00 00       	add	r0,r0
80003ac4:	00 00       	add	r0,r0
80003ac6:	0a 68       	and	r8,r5
80003ac8:	80 00       	ld.sh	r0,r0[0x0]
80003aca:	73 f8       	ld.w	r8,r9[0x7c]

80003acc <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003acc:	d4 21       	pushm	r4-r7,lr
80003ace:	18 95       	mov	r5,r12
80003ad0:	16 94       	mov	r4,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80003ad2:	49 86       	lddpc	r6,80003b30 <spi_selectChip+0x64>
80003ad4:	31 47       	mov	r7,20
80003ad6:	0e 9b       	mov	r11,r7
80003ad8:	6c 0c       	ld.w	r12,r6[0x0]
80003ada:	f0 1f 00 17 	mcall	80003b34 <spi_selectChip+0x68>
80003ade:	cf c0       	breq	80003ad6 <spi_selectChip+0xa>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003ae0:	6a 18       	ld.w	r8,r5[0x4]
80003ae2:	ea 18 00 0f 	orh	r8,0xf
80003ae6:	8b 18       	st.w	r5[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80003ae8:	6a 18       	ld.w	r8,r5[0x4]
80003aea:	e2 18 00 04 	andl	r8,0x4,COH
80003aee:	c1 00       	breq	80003b0e <spi_selectChip+0x42>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80003af0:	30 e8       	mov	r8,14
80003af2:	f0 04 18 00 	cp.b	r4,r8
80003af6:	e0 8b 00 1a 	brhi	80003b2a <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003afa:	6a 19       	ld.w	r9,r5[0x4]
80003afc:	e8 08 15 10 	lsl	r8,r4,0x10
80003b00:	ea 18 ff f0 	orh	r8,0xfff0
80003b04:	e8 18 ff ff 	orl	r8,0xffff
80003b08:	12 68       	and	r8,r9
80003b0a:	8b 18       	st.w	r5[0x4],r8
80003b0c:	d8 2a       	popm	r4-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80003b0e:	30 38       	mov	r8,3
80003b10:	f0 04 18 00 	cp.b	r4,r8
80003b14:	e0 8b 00 0b 	brhi	80003b2a <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80003b18:	6a 19       	ld.w	r9,r5[0x4]
80003b1a:	2f 04       	sub	r4,-16
80003b1c:	30 18       	mov	r8,1
80003b1e:	f0 04 09 48 	lsl	r8,r8,r4
80003b22:	5c d8       	com	r8
80003b24:	12 68       	and	r8,r9
80003b26:	8b 18       	st.w	r5[0x4],r8
80003b28:	d8 2a       	popm	r4-r7,pc,r12=0
80003b2a:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80003b2c:	d8 22       	popm	r4-r7,pc
80003b2e:	00 00       	add	r0,r0
80003b30:	00 00       	add	r0,r0
80003b32:	0a 68       	and	r8,r5
80003b34:	80 00       	ld.sh	r0,r0[0x0]
80003b36:	72 14       	ld.w	r4,r9[0x4]

80003b38 <fat_check_open>:
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
80003b38:	48 68       	lddpc	r8,80003b50 <fat_check_open+0x18>
80003b3a:	11 89       	ld.ub	r9,r8[0x0]
80003b3c:	30 08       	mov	r8,0
80003b3e:	f0 09 18 00 	cp.b	r9,r8
80003b42:	c0 20       	breq	80003b46 <fat_check_open+0xe>
80003b44:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
80003b46:	31 79       	mov	r9,23
80003b48:	48 38       	lddpc	r8,80003b54 <fat_check_open+0x1c>
80003b4a:	b0 89       	st.b	r8[0x0],r9
80003b4c:	5e fd       	retal	0
80003b4e:	00 00       	add	r0,r0
80003b50:	00 00       	add	r0,r0
80003b52:	0a 70       	tst	r0,r5
80003b54:	00 00       	add	r0,r0
80003b56:	0d 00       	ld.w	r0,r6++

80003b58 <fat_check_select>:
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
80003b58:	48 68       	lddpc	r8,80003b70 <fat_check_select+0x18>
80003b5a:	90 19       	ld.sh	r9,r8[0x2]
80003b5c:	3f f8       	mov	r8,-1
80003b5e:	f0 09 19 00 	cp.h	r9,r8
80003b62:	c0 20       	breq	80003b66 <fat_check_select+0xe>
80003b64:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
80003b66:	30 f9       	mov	r9,15
80003b68:	48 38       	lddpc	r8,80003b74 <fat_check_select+0x1c>
80003b6a:	b0 89       	st.b	r8[0x0],r9
80003b6c:	5e fd       	retal	0
80003b6e:	00 00       	add	r0,r0
80003b70:	00 00       	add	r0,r0
80003b72:	0c fc       	st.b	--r6,r12
80003b74:	00 00       	add	r0,r0
80003b76:	0d 00       	ld.w	r0,r6++

80003b78 <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
80003b78:	48 58       	lddpc	r8,80003b8c <fat_check_is_file+0x14>
80003b7a:	11 a8       	ld.ub	r8,r8[0x2]
80003b7c:	e2 18 00 18 	andl	r8,0x18,COH
80003b80:	c0 21       	brne	80003b84 <fat_check_is_file+0xc>
80003b82:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
80003b84:	31 39       	mov	r9,19
80003b86:	48 38       	lddpc	r8,80003b90 <fat_check_is_file+0x18>
80003b88:	b0 89       	st.b	r8[0x0],r9
80003b8a:	5e fd       	retal	0
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a 70       	tst	r0,r5
80003b90:	00 00       	add	r0,r0
80003b92:	0d 00       	ld.w	r0,r6++

80003b94 <fat_checkcluster>:
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
80003b94:	49 68       	lddpc	r8,80003bec <fat_checkcluster+0x58>
80003b96:	70 18       	ld.w	r8,r8[0x4]
80003b98:	58 08       	cp.w	r8,0
80003b9a:	c0 21       	brne	80003b9e <fat_checkcluster+0xa>
80003b9c:	5e ff       	retal	1
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
80003b9e:	49 59       	lddpc	r9,80003bf0 <fat_checkcluster+0x5c>
80003ba0:	13 89       	ld.ub	r9,r9[0x0]
80003ba2:	30 3a       	mov	r10,3
80003ba4:	f4 09 18 00 	cp.b	r9,r10
80003ba8:	c0 a1       	brne	80003bbc <fat_checkcluster+0x28>
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
80003baa:	e0 69 ff f7 	mov	r9,65527
80003bae:	ea 19 0f ff 	orh	r9,0xfff
80003bb2:	12 38       	cp.w	r8,r9
80003bb4:	e0 8b 00 19 	brhi	80003be6 <fat_checkcluster+0x52>
80003bb8:	5f 0c       	sreq	r12
80003bba:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
80003bbc:	30 2a       	mov	r10,2
80003bbe:	f4 09 18 00 	cp.b	r9,r10
80003bc2:	c0 71       	brne	80003bd0 <fat_checkcluster+0x3c>
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
80003bc4:	e0 48 ff f7 	cp.w	r8,65527
80003bc8:	e0 8b 00 0f 	brhi	80003be6 <fat_checkcluster+0x52>
80003bcc:	5f 0c       	sreq	r12
80003bce:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
80003bd0:	30 1a       	mov	r10,1
80003bd2:	f4 09 18 00 	cp.b	r9,r10
80003bd6:	c0 20       	breq	80003bda <fat_checkcluster+0x46>
80003bd8:	5e fd       	retal	0
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
80003bda:	e0 48 0f f7 	cp.w	r8,4087
80003bde:	e0 8b 00 04 	brhi	80003be6 <fat_checkcluster+0x52>
80003be2:	5f 0c       	sreq	r12
80003be4:	5e fc       	retal	r12
80003be6:	30 2c       	mov	r12,2
    else if (fs_g_cluster.u32_val == 0xFF7)
      return FS_CLUS_BAD;
  }

  return FS_CLUS_OK;
}
80003be8:	5e fc       	retal	r12
80003bea:	00 00       	add	r0,r0
80003bec:	00 00       	add	r0,r0
80003bee:	0d 50       	ld.sh	r0,--r6
80003bf0:	00 00       	add	r0,r0
80003bf2:	0c fc       	st.b	--r6,r12

80003bf4 <fat_cache_clusterlist_reset>:
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
80003bf4:	30 0a       	mov	r10,0
80003bf6:	48 88       	lddpc	r8,80003c14 <fat_cache_clusterlist_reset+0x20>
80003bf8:	b0 8a       	st.b	r8[0x0],r10
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
80003bfa:	48 88       	lddpc	r8,80003c18 <fat_cache_clusterlist_reset+0x24>
80003bfc:	30 19       	mov	r9,1
80003bfe:	b0 89       	st.b	r8[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80003c00:	3f f9       	mov	r9,-1
80003c02:	b0 a9       	st.b	r8[0x2],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
80003c04:	b0 99       	st.b	r8[0x1],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
80003c06:	f1 6a 00 14 	st.b	r8[20],r10
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80003c0a:	f1 69 00 16 	st.b	r8[22],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
80003c0e:	f1 69 00 15 	st.b	r8[21],r9
   }
}
80003c12:	5e fc       	retal	r12
80003c14:	00 00       	add	r0,r0
80003c16:	0d 02       	ld.w	r2,r6++
80003c18:	00 00       	add	r0,r0
80003c1a:	0a 84       	andn	r4,r5

80003c1c <fat_cache_clusterlist_update_start>:
//! This function initializes a cache in cluster list caches
//!
//! @param     b_for_file  If true then it is a file cluster list else a directory cluster list  <br>
//!
void  fat_cache_clusterlist_update_start( bool b_for_file )
{
80003c1c:	48 ea       	lddpc	r10,80003c54 <fat_cache_clusterlist_update_start+0x38>
80003c1e:	15 88       	ld.ub	r8,r10[0x0]
80003c20:	f8 08 18 00 	cp.b	r8,r12
80003c24:	5f 18       	srne	r8
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
80003c26:	48 d9       	lddpc	r9,80003c58 <fat_cache_clusterlist_update_start+0x3c>
80003c28:	b2 88       	st.b	r9[0x0],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
80003c2a:	f0 0b 15 02 	lsl	r11,r8,0x2
80003c2e:	f6 08 00 09 	add	r9,r11,r8
80003c32:	f4 09 00 29 	add	r9,r10,r9<<0x2
80003c36:	b2 8c       	st.b	r9[0x0],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80003c38:	3f fc       	mov	r12,-1
80003c3a:	b2 ac       	st.b	r9[0x2],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
80003c3c:	f6 08 00 08 	add	r8,r11,r8
80003c40:	2f f8       	sub	r8,-1
80003c42:	48 7b       	lddpc	r11,80003c5c <fat_cache_clusterlist_update_start+0x40>
80003c44:	76 0b       	ld.w	r11,r11[0x0]
80003c46:	f4 08 09 2b 	st.w	r10[r8<<0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
80003c4a:	48 68       	lddpc	r8,80003c60 <fat_cache_clusterlist_update_start+0x44>
80003c4c:	70 18       	ld.w	r8,r8[0x4]
80003c4e:	93 28       	st.w	r9[0x8],r8
}
80003c50:	5e fc       	retal	r12
80003c52:	00 00       	add	r0,r0
80003c54:	00 00       	add	r0,r0
80003c56:	0a 84       	andn	r4,r5
80003c58:	00 00       	add	r0,r0
80003c5a:	0d 02       	ld.w	r2,r6++
80003c5c:	00 00       	add	r0,r0
80003c5e:	0d 50       	ld.sh	r0,--r6
80003c60:	00 00       	add	r0,r0
80003c62:	0d 58       	ld.sh	r8,--r6

80003c64 <fat_cache_clusterlist_update_select>:
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
80003c64:	49 88       	lddpc	r8,80003cc4 <fat_cache_clusterlist_update_select+0x60>
80003c66:	11 88       	ld.ub	r8,r8[0x0]
80003c68:	49 8a       	lddpc	r10,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003c6a:	f0 08 00 2b 	add	r11,r8,r8<<0x2
80003c6e:	f4 0b 00 2b 	add	r11,r10,r11<<0x2
80003c72:	17 89       	ld.ub	r9,r11[0x0]
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
80003c74:	17 9b       	ld.ub	r11,r11[0x1]
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
80003c76:	15 8a       	ld.ub	r10,r10[0x0]
80003c78:	f2 0a 18 00 	cp.b	r10,r9
80003c7c:	c0 a1       	brne	80003c90 <fat_cache_clusterlist_update_select+0x2c>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80003c7e:	49 3a       	lddpc	r10,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003c80:	15 9a       	ld.ub	r10,r10[0x1]
80003c82:	f4 0b 18 00 	cp.b	r11,r10
80003c86:	e0 88 00 05 	brls	80003c90 <fat_cache_clusterlist_update_select+0x2c>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80003c8a:	2f fa       	sub	r10,-1
80003c8c:	48 fc       	lddpc	r12,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003c8e:	b8 9a       	st.b	r12[0x1],r10

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
80003c90:	48 ea       	lddpc	r10,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003c92:	f5 3a 00 14 	ld.ub	r10,r10[20]
80003c96:	f2 0a 18 00 	cp.b	r10,r9
80003c9a:	c0 c1       	brne	80003cb2 <fat_cache_clusterlist_update_select+0x4e>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80003c9c:	48 b9       	lddpc	r9,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003c9e:	f3 39 00 15 	ld.ub	r9,r9[21]
80003ca2:	f2 0b 18 00 	cp.b	r11,r9
80003ca6:	e0 88 00 06 	brls	80003cb2 <fat_cache_clusterlist_update_select+0x4e>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80003caa:	2f f9       	sub	r9,-1
80003cac:	48 7a       	lddpc	r10,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003cae:	f5 69 00 15 	st.b	r10[21],r9
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
80003cb2:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003cb6:	48 59       	lddpc	r9,80003cc8 <fat_cache_clusterlist_update_select+0x64>
80003cb8:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003cbc:	30 09       	mov	r9,0
80003cbe:	b0 99       	st.b	r8[0x1],r9
}
80003cc0:	5e fc       	retal	r12
80003cc2:	00 00       	add	r0,r0
80003cc4:	00 00       	add	r0,r0
80003cc6:	0d 02       	ld.w	r2,r6++
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 84       	andn	r4,r5

80003ccc <fat_cache_clusterlist_update_finish>:


//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
80003ccc:	eb cd 40 c0 	pushm	r6-r7,lr
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
80003cd0:	49 08       	lddpc	r8,80003d10 <fat_cache_clusterlist_update_finish+0x44>
80003cd2:	11 88       	ld.ub	r8,r8[0x0]
80003cd4:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003cd8:	48 f9       	lddpc	r9,80003d14 <fat_cache_clusterlist_update_finish+0x48>
80003cda:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003cde:	f0 ca ff f8 	sub	r10,r8,-8
80003ce2:	48 eb       	lddpc	r11,80003d18 <fat_cache_clusterlist_update_finish+0x4c>
80003ce4:	17 97       	ld.ub	r7,r11[0x1]
80003ce6:	74 09       	ld.w	r9,r10[0x0]
80003ce8:	f2 07 0d 06 	divu	r6,r9,r7
80003cec:	0e 99       	mov	r9,r7
80003cee:	5c 59       	castu.b	r9
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
80003cf0:	17 8b       	ld.ub	r11,r11[0x0]
80003cf2:	b0 ab       	st.b	r8[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
80003cf4:	74 0b       	ld.w	r11,r10[0x0]
80003cf6:	12 1b       	sub	r11,r9
80003cf8:	95 0b       	st.w	r10[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
80003cfa:	48 9a       	lddpc	r10,80003d1c <fat_cache_clusterlist_update_finish+0x50>
80003cfc:	74 0b       	ld.w	r11,r10[0x0]
80003cfe:	12 1b       	sub	r11,r9
80003d00:	91 3b       	st.w	r8[0xc],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
80003d02:	74 1a       	ld.w	r10,r10[0x4]
80003d04:	14 09       	add	r9,r10
80003d06:	91 49       	st.w	r8[0x10],r9

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
80003d08:	f0 1f 00 06 	mcall	80003d20 <fat_cache_clusterlist_update_finish+0x54>
}
80003d0c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d10:	00 00       	add	r0,r0
80003d12:	0d 02       	ld.w	r2,r6++
80003d14:	00 00       	add	r0,r0
80003d16:	0a 84       	andn	r4,r5
80003d18:	00 00       	add	r0,r0
80003d1a:	0c b0       	st.h	r6++,r0
80003d1c:	00 00       	add	r0,r0
80003d1e:	0d 58       	ld.sh	r8,--r6
80003d20:	80 00       	ld.sh	r0,r0[0x0]
80003d22:	3c 64       	mov	r4,-58

80003d24 <fat_cache_clusterlist_update_read>:
//!
//! @return    true  cluster list found and global variable fs_g_seg updated
//! @return    false no found in cluster list caches
//!
bool  fat_cache_clusterlist_update_read( bool b_for_file )
{
80003d24:	eb cd 40 c0 	pushm	r6-r7,lr
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
80003d28:	4c 18       	lddpc	r8,80003e2c <fat_cache_clusterlist_update_read+0x108>
80003d2a:	11 89       	ld.ub	r9,r8[0x0]
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003d2c:	4c 18       	lddpc	r8,80003e30 <fat_cache_clusterlist_update_read+0x10c>
80003d2e:	70 0a       	ld.w	r10,r8[0x0]
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003d30:	4c 18       	lddpc	r8,80003e34 <fat_cache_clusterlist_update_read+0x110>
80003d32:	70 1b       	ld.w	r11,r8[0x4]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80003d34:	4c 18       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d36:	11 88       	ld.ub	r8,r8[0x0]
80003d38:	f8 08 18 00 	cp.b	r8,r12
80003d3c:	c1 11       	brne	80003d5e <fat_cache_clusterlist_update_read+0x3a>
80003d3e:	4b f8       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d40:	11 a8       	ld.ub	r8,r8[0x2]
80003d42:	f2 08 18 00 	cp.b	r8,r9
80003d46:	c0 c1       	brne	80003d5e <fat_cache_clusterlist_update_read+0x3a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003d48:	4b c8       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d4a:	70 18       	ld.w	r8,r8[0x4]
80003d4c:	14 38       	cp.w	r8,r10
80003d4e:	c0 81       	brne	80003d5e <fat_cache_clusterlist_update_read+0x3a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003d50:	4b a8       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d52:	70 28       	ld.w	r8,r8[0x8]
80003d54:	10 3b       	cp.w	r11,r8
80003d56:	c0 43       	brcs	80003d5e <fat_cache_clusterlist_update_read+0x3a>
80003d58:	30 0a       	mov	r10,0
80003d5a:	14 99       	mov	r9,r10
80003d5c:	c1 88       	rjmp	80003d8c <fat_cache_clusterlist_update_read+0x68>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80003d5e:	4b 78       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d60:	f1 38 00 14 	ld.ub	r8,r8[20]
80003d64:	f8 08 18 00 	cp.b	r8,r12
80003d68:	c5 e1       	brne	80003e24 <fat_cache_clusterlist_update_read+0x100>
80003d6a:	4b 48       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d6c:	f1 38 00 16 	ld.ub	r8,r8[22]
80003d70:	f2 08 18 00 	cp.b	r8,r9
80003d74:	c5 81       	brne	80003e24 <fat_cache_clusterlist_update_read+0x100>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003d76:	4b 18       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d78:	70 68       	ld.w	r8,r8[0x18]
80003d7a:	14 38       	cp.w	r8,r10
80003d7c:	c5 41       	brne	80003e24 <fat_cache_clusterlist_update_read+0x100>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003d7e:	4a f8       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d80:	70 78       	ld.w	r8,r8[0x1c]
80003d82:	16 38       	cp.w	r8,r11
80003d84:	e0 8b 00 50 	brhi	80003e24 <fat_cache_clusterlist_update_read+0x100>
80003d88:	30 1a       	mov	r10,1
80003d8a:	14 99       	mov	r9,r10
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
80003d8c:	f2 0e 15 02 	lsl	lr,r9,0x2
80003d90:	12 0e       	add	lr,r9
80003d92:	4a ac       	lddpc	r12,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003d94:	f8 0e 00 2c 	add	r12,r12,lr<<0x2
80003d98:	78 4c       	ld.w	r12,r12[0x10]
80003d9a:	f6 08 01 08 	sub	r8,r11,r8
80003d9e:	10 3c       	cp.w	r12,r8
80003da0:	e0 88 00 16 	brls	80003dcc <fat_cache_clusterlist_update_read+0xa8>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
80003da4:	4a 4b       	lddpc	r11,80003e34 <fat_cache_clusterlist_update_read+0x110>
80003da6:	f2 0e 15 02 	lsl	lr,r9,0x2
80003daa:	fc 09 00 09 	add	r9,lr,r9
80003dae:	4a 3e       	lddpc	lr,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003db0:	fc 09 00 29 	add	r9,lr,r9<<0x2
80003db4:	72 39       	ld.w	r9,r9[0xc]
80003db6:	f0 09 00 09 	add	r9,r8,r9
80003dba:	97 09       	st.w	r11[0x0],r9
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
80003dbc:	10 1c       	sub	r12,r8
80003dbe:	97 1c       	st.w	r11[0x4],r12
                  fs_g_u8_current_cache = u8_i;
80003dc0:	49 f8       	lddpc	r8,80003e3c <fat_cache_clusterlist_update_read+0x118>
80003dc2:	b0 8a       	st.b	r8[0x0],r10
                  fat_cache_clusterlist_update_select();
80003dc4:	f0 1f 00 1f 	mcall	80003e40 <fat_cache_clusterlist_update_read+0x11c>
80003dc8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
80003dcc:	49 c8       	lddpc	r8,80003e3c <fat_cache_clusterlist_update_read+0x118>
80003dce:	b0 8a       	st.b	r8[0x0],r10
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
80003dd0:	f2 08 15 02 	lsl	r8,r9,0x2
80003dd4:	f0 09 00 09 	add	r9,r8,r9
80003dd8:	49 88       	lddpc	r8,80003e38 <fat_cache_clusterlist_update_read+0x114>
80003dda:	f0 09 00 28 	add	r8,r8,r9<<0x2
80003dde:	3f f9       	mov	r9,-1
80003de0:	b0 a9       	st.b	r8[0x2],r9
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
80003de2:	70 4c       	ld.w	r12,r8[0x10]
80003de4:	49 2a       	lddpc	r10,80003e2c <fat_cache_clusterlist_update_read+0x108>
80003de6:	15 99       	ld.ub	r9,r10[0x1]
80003de8:	70 3e       	ld.w	lr,r8[0xc]
80003dea:	f8 0e 00 0e 	add	lr,r12,lr
80003dee:	20 1e       	sub	lr,1
80003df0:	74 57       	ld.w	r7,r10[0x14]
80003df2:	fc 07 01 07 	sub	r7,lr,r7
80003df6:	74 4a       	ld.w	r10,r10[0x10]
80003df8:	14 17       	sub	r7,r10
80003dfa:	ee 09 0d 06 	divu	r6,r7,r9
80003dfe:	0c 97       	mov	r7,r6
80003e00:	2f e7       	sub	r7,-2
80003e02:	48 ca       	lddpc	r10,80003e30 <fat_cache_clusterlist_update_read+0x10c>
80003e04:	95 07       	st.w	r10[0x0],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
80003e06:	2f 88       	sub	r8,-8
80003e08:	70 0a       	ld.w	r10,r8[0x0]
80003e0a:	14 0c       	add	r12,r10
80003e0c:	f8 c7 00 01 	sub	r7,r12,1
80003e10:	ee 09 0d 06 	divu	r6,r7,r9
80003e14:	ad 39       	mul	r9,r6
80003e16:	48 8a       	lddpc	r10,80003e34 <fat_cache_clusterlist_update_read+0x110>
80003e18:	f6 09 01 09 	sub	r9,r11,r9
80003e1c:	95 19       	st.w	r10[0x4],r9
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
80003e1e:	91 0b       	st.w	r8[0x0],r11
80003e20:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
         }
      }
   }
   // No found in cache then read FAT and store the result in cache
   fat_cache_clusterlist_update_start(b_for_file);
80003e24:	f0 1f 00 08 	mcall	80003e44 <fat_cache_clusterlist_update_read+0x120>
80003e28:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003e2c:	00 00       	add	r0,r0
80003e2e:	0c b0       	st.h	r6++,r0
80003e30:	00 00       	add	r0,r0
80003e32:	0d 50       	ld.sh	r0,--r6
80003e34:	00 00       	add	r0,r0
80003e36:	0d 58       	ld.sh	r8,--r6
80003e38:	00 00       	add	r0,r0
80003e3a:	0a 84       	andn	r4,r5
80003e3c:	00 00       	add	r0,r0
80003e3e:	0d 02       	ld.w	r2,r6++
80003e40:	80 00       	ld.sh	r0,r0[0x0]
80003e42:	3c 64       	mov	r4,-58
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	3c 1c       	mov	r12,-63

80003e48 <fat_entry_is_dir>:
//! @return    true,    this entry is a directory
//! @return    false,   otherwise
//!
bool  fat_entry_is_dir(void)
{
   fs_g_status = FS_ERR_NO_DIR;
80003e48:	30 d9       	mov	r9,13
80003e4a:	48 48       	lddpc	r8,80003e58 <fat_entry_is_dir+0x10>
80003e4c:	b0 89       	st.b	r8[0x0],r9
80003e4e:	48 48       	lddpc	r8,80003e5c <fat_entry_is_dir+0x14>
80003e50:	11 ac       	ld.ub	r12,r8[0x2]
   return (FS_ATTR_DIRECTORY & fs_g_nav_entry.u8_attr);
}
80003e52:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80003e56:	5e fc       	retal	r12
80003e58:	00 00       	add	r0,r0
80003e5a:	0d 00       	ld.w	r0,r6++
80003e5c:	00 00       	add	r0,r0
80003e5e:	0a 70       	tst	r0,r5

80003e60 <fat_clear_entry_info_and_ptr>:

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
80003e60:	3f f9       	mov	r9,-1
80003e62:	48 c8       	lddpc	r8,80003e90 <fat_clear_entry_info_and_ptr+0x30>
80003e64:	b0 19       	st.h	r8[0x2],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
80003e66:	48 c8       	lddpc	r8,80003e94 <fat_clear_entry_info_and_ptr+0x34>
80003e68:	f1 59 00 24 	st.h	r8[36],r9
   if( !fs_g_nav.b_mode_nav_single )
80003e6c:	f1 39 00 2d 	ld.ub	r9,r8[45]
80003e70:	30 08       	mov	r8,0
80003e72:	f0 09 18 00 	cp.b	r9,r8
80003e76:	c0 51       	brne	80003e80 <fat_clear_entry_info_and_ptr+0x20>
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
80003e78:	10 99       	mov	r9,r8
80003e7a:	48 78       	lddpc	r8,80003e94 <fat_clear_entry_info_and_ptr+0x34>
80003e7c:	f1 69 00 2c 	st.b	r8[44],r9
   }
   fs_g_nav_entry.u8_attr     = 0;
80003e80:	48 68       	lddpc	r8,80003e98 <fat_clear_entry_info_and_ptr+0x38>
80003e82:	30 09       	mov	r9,0
80003e84:	b0 a9       	st.b	r8[0x2],r9
   fs_g_nav_entry.u32_cluster = 0;
80003e86:	30 0a       	mov	r10,0
80003e88:	91 1a       	st.w	r8[0x4],r10
   fs_g_nav_entry.u32_size    = 0;
80003e8a:	91 2a       	st.w	r8[0x8],r10
   Fat_file_close();
80003e8c:	b0 89       	st.b	r8[0x0],r9
}
80003e8e:	5e fc       	retal	r12
80003e90:	00 00       	add	r0,r0
80003e92:	0c fc       	st.b	--r6,r12
80003e94:	00 00       	add	r0,r0
80003e96:	0c b0       	st.h	r6++,r0
80003e98:	00 00       	add	r0,r0
80003e9a:	0a 70       	tst	r0,r5

80003e9c <fat_check_eof_name>:
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
80003e9c:	30 08       	mov	r8,0
80003e9e:	f0 0c 19 00 	cp.h	r12,r8
80003ea2:	5f 0a       	sreq	r10
80003ea4:	35 c9       	mov	r9,92
80003ea6:	f2 0c 19 00 	cp.h	r12,r9
80003eaa:	5f 09       	sreq	r9
80003eac:	f5 e9 10 09 	or	r9,r10,r9
80003eb0:	f0 09 18 00 	cp.b	r9,r8
80003eb4:	c0 20       	breq	80003eb8 <fat_check_eof_name+0x1c>
80003eb6:	5e ff       	retal	1
80003eb8:	32 f8       	mov	r8,47
80003eba:	f0 0c 19 00 	cp.h	r12,r8
80003ebe:	5f 0c       	sreq	r12
}
80003ec0:	5e fc       	retal	r12
80003ec2:	d7 03       	nop

80003ec4 <fat_get_ptr_entry>:
//! This function returns a cache pointer on the current entry
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
80003ec4:	48 48       	lddpc	r8,80003ed4 <fat_get_ptr_entry+0x10>
80003ec6:	90 98       	ld.uh	r8,r8[0x2]
80003ec8:	a5 78       	lsl	r8,0x5
80003eca:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
}
80003ece:	48 3c       	lddpc	r12,80003ed8 <fat_get_ptr_entry+0x14>
80003ed0:	10 0c       	add	r12,r8
80003ed2:	5e fc       	retal	r12
80003ed4:	00 00       	add	r0,r0
80003ed6:	0c fc       	st.b	--r6,r12
80003ed8:	00 00       	add	r0,r0
80003eda:	0a b0       	st.h	r5++,r0

80003edc <fat_entry_longname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_longname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case )
{
80003edc:	d4 31       	pushm	r0-r7,lr
80003ede:	20 3d       	sub	sp,12
80003ee0:	18 97       	mov	r7,r12
80003ee2:	16 94       	mov	r4,r11
80003ee4:	14 96       	mov	r6,r10
80003ee6:	50 09       	stdsp	sp[0x0],r9
   uint8_t u8_pos_name;
   PTR_CACHE ptr_entry;
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();
80003ee8:	f0 1f 00 5e 	mcall	80004060 <fat_entry_longname+0x184>

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
80003eec:	19 88       	ld.ub	r8,r12[0x0]
80003eee:	30 09       	mov	r9,0
80003ef0:	f2 08 18 00 	cp.b	r8,r9
80003ef4:	5f 0b       	sreq	r11
80003ef6:	3e 5a       	mov	r10,-27
80003ef8:	f4 08 18 00 	cp.b	r8,r10
80003efc:	5f 0a       	sreq	r10
80003efe:	f7 ea 10 0a 	or	r10,r11,r10
80003f02:	f2 0a 18 00 	cp.b	r10,r9
80003f06:	c0 71       	brne	80003f14 <fat_entry_longname+0x38>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
80003f08:	f9 3a 00 0b 	ld.ub	r10,r12[11]
80003f0c:	30 f9       	mov	r9,15
80003f0e:	f2 0a 18 00 	cp.b	r10,r9
80003f12:	c0 60       	breq	80003f1e <fat_entry_longname+0x42>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
80003f14:	30 b9       	mov	r9,11
80003f16:	4d 48       	lddpc	r8,80004064 <fat_entry_longname+0x188>
80003f18:	b0 89       	st.b	r8[0x0],r9
80003f1a:	30 0c       	mov	r12,0
      return false;
80003f1c:	c9 c8       	rjmp	80004054 <fat_entry_longname+0x178>
   }

   if( g_b_string_length )
80003f1e:	4d 39       	lddpc	r9,80004068 <fat_entry_longname+0x18c>
80003f20:	13 8a       	ld.ub	r10,r9[0x0]
80003f22:	30 09       	mov	r9,0
80003f24:	f2 0a 18 00 	cp.b	r10,r9
80003f28:	c0 90       	breq	80003f3a <fat_entry_longname+0x5e>
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
80003f2a:	e2 18 00 40 	andl	r8,0x40,COH
80003f2e:	c0 61       	brne	80003f3a <fat_entry_longname+0x5e>
      {
         // no necessary -> ((FS_STR_UNICODE)sz_name)[0] = FS_SIZE_LFN_ENTRY;
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
80003f30:	31 09       	mov	r9,16
80003f32:	4c d8       	lddpc	r8,80004064 <fat_entry_longname+0x188>
80003f34:	b0 89       	st.b	r8[0x0],r9
80003f36:	30 0c       	mov	r12,0
         return false;                          // Other entry long name
80003f38:	c8 e8       	rjmp	80004054 <fat_entry_longname+0x178>
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
80003f3a:	2f fc       	sub	r12,-1
80003f3c:	30 08       	mov	r8,0

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80003f3e:	fa ca ff f6 	sub	r10,sp,-10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80003f42:	30 0b       	mov	r11,0
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
80003f44:	4c 95       	lddpc	r5,80004068 <fat_entry_longname+0x18c>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80003f46:	20 14       	sub	r4,1
80003f48:	50 14       	stdsp	sp[0x4],r4
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
80003f4a:	30 01       	mov	r1,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80003f4c:	30 44       	mov	r4,4
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80003f4e:	19 89       	ld.ub	r9,r12[0x0]
80003f50:	b4 99       	st.b	r10[0x1],r9
      MSB(u16_unicode_entry) = ptr_entry[1];
80003f52:	19 99       	ld.ub	r9,r12[0x1]
80003f54:	b4 89       	st.b	r10[0x0],r9
      if( FS_NAME_GET == b_mode )
80003f56:	58 06       	cp.w	r6,0
80003f58:	c0 f0       	breq	80003f76 <fat_entry_longname+0x9a>
      {
         if( !g_b_string_length )
80003f5a:	0b 89       	ld.ub	r9,r5[0x0]
80003f5c:	f6 09 18 00 	cp.b	r9,r11
80003f60:	c3 91       	brne	80003fd2 <fat_entry_longname+0xf6>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80003f62:	40 1e       	lddsp	lr,sp[0x4]
80003f64:	1c 38       	cp.w	r8,lr
80003f66:	c0 55       	brlt	80003f70 <fat_entry_longname+0x94>
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80003f68:	30 08       	mov	r8,0
80003f6a:	ae 88       	st.b	r7[0x0],r8
80003f6c:	30 1c       	mov	r12,1
               }
               return true;                     // the buffer is full
80003f6e:	c7 38       	rjmp	80004054 <fat_entry_longname+0x178>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
80003f70:	9a 59       	ld.sh	r9,sp[0xa]
80003f72:	ae 89       	st.b	r7[0x0],r9
80003f74:	c2 f8       	rjmp	80003fd2 <fat_entry_longname+0xf6>
      {
         if( Is_unicode )
         {
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
80003f76:	0f 89       	ld.ub	r9,r7[0x0]
         }
         // Check the name
         if( '*' == u16_unicode_szname )
80003f78:	32 a3       	mov	r3,42
80003f7a:	e6 09 19 00 	cp.h	r9,r3
80003f7e:	c6 a0       	breq	80004052 <fat_entry_longname+0x176>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80003f80:	9a 5e       	ld.sh	lr,sp[0xa]
80003f82:	58 0e       	cp.w	lr,0
80003f84:	c0 e1       	brne	80003fa0 <fat_entry_longname+0xc4>
80003f86:	35 c0       	mov	r0,92
80003f88:	e0 09 19 00 	cp.h	r9,r0
80003f8c:	5f 12       	srne	r2
80003f8e:	32 f3       	mov	r3,47
80003f90:	e6 09 19 00 	cp.h	r9,r3
80003f94:	5f 13       	srne	r3
80003f96:	e5 e3 00 03 	and	r3,r2,r3
80003f9a:	f6 03 18 00 	cp.b	r3,r11
80003f9e:	c1 e0       	breq	80003fda <fat_entry_longname+0xfe>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
80003fa0:	e7 d9 c0 10 	bfextu	r3,r9,0x0,0x10
80003fa4:	e5 de c0 10 	bfextu	r2,lr,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80003fa8:	e4 c0 ff e0 	sub	r0,r2,-32
80003fac:	00 33       	cp.w	r3,r0
80003fae:	c0 41       	brne	80003fb6 <fat_entry_longname+0xda>
80003fb0:	40 00       	lddsp	r0,sp[0x0]
80003fb2:	58 00       	cp.w	r0,0
80003fb4:	c0 f0       	breq	80003fd2 <fat_entry_longname+0xf6>
80003fb6:	22 02       	sub	r2,32
80003fb8:	04 33       	cp.w	r3,r2
80003fba:	c0 41       	brne	80003fc2 <fat_entry_longname+0xe6>
80003fbc:	40 03       	lddsp	r3,sp[0x0]
80003fbe:	58 03       	cp.w	r3,0
80003fc0:	c0 90       	breq	80003fd2 <fat_entry_longname+0xf6>
80003fc2:	fc 09 19 00 	cp.h	r9,lr
80003fc6:	c0 60       	breq	80003fd2 <fat_entry_longname+0xf6>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
80003fc8:	31 69       	mov	r9,22
80003fca:	4a 78       	lddpc	r8,80004064 <fat_entry_longname+0x188>
80003fcc:	b0 89       	st.b	r8[0x0],r9
80003fce:	30 0c       	mov	r12,0
           return false;
80003fd0:	c4 28       	rjmp	80004054 <fat_entry_longname+0x178>
         }
      }

      if( 0 == u16_unicode_entry)
80003fd2:	9a 59       	ld.sh	r9,sp[0xa]
80003fd4:	e2 09 19 00 	cp.h	r9,r1
80003fd8:	c0 b1       	brne	80003fee <fat_entry_longname+0x112>
      {
         if( g_b_string_length )
80003fda:	4a 49       	lddpc	r9,80004068 <fat_entry_longname+0x18c>
80003fdc:	13 8a       	ld.ub	r10,r9[0x0]
80003fde:	30 09       	mov	r9,0
80003fe0:	f2 0a 18 00 	cp.b	r10,r9
80003fe4:	c3 70       	breq	80004052 <fat_entry_longname+0x176>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
80003fe6:	2f f8       	sub	r8,-1
80003fe8:	ae 08       	st.h	r7[0x0],r8
80003fea:	30 1c       	mov	r12,1
80003fec:	c3 48       	rjmp	80004054 <fat_entry_longname+0x178>
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80003fee:	e8 08 18 00 	cp.b	r8,r4
80003ff2:	c0 31       	brne	80003ff8 <fat_entry_longname+0x11c>
         ptr_entry += 3;                        // Go to second character
80003ff4:	2f dc       	sub	r12,-3
80003ff6:	c2 58       	rjmp	80004040 <fat_entry_longname+0x164>

      if( 10 == u8_pos_name )
80003ff8:	30 a9       	mov	r9,10
80003ffa:	f2 08 18 00 	cp.b	r8,r9
80003ffe:	c0 31       	brne	80004004 <fat_entry_longname+0x128>
         ptr_entry += 2;                        // Go to third character
80004000:	2f ec       	sub	r12,-2
80004002:	c1 f8       	rjmp	80004040 <fat_entry_longname+0x164>

      if( 12 == u8_pos_name )
80004004:	30 c9       	mov	r9,12
80004006:	f2 08 18 00 	cp.b	r8,r9
8000400a:	c1 b1       	brne	80004040 <fat_entry_longname+0x164>
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
8000400c:	f9 38 ff e2 	ld.ub	r8,r12[-30]
80004010:	e2 18 00 40 	andl	r8,0x40,COH
80004014:	c0 61       	brne	80004020 <fat_entry_longname+0x144>
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
80004016:	31 09       	mov	r9,16
80004018:	49 38       	lddpc	r8,80004064 <fat_entry_longname+0x188>
8000401a:	b0 89       	st.b	r8[0x0],r9
8000401c:	30 0c       	mov	r12,0
            return false;                       // Other long name entry is present
8000401e:	c1 b8       	rjmp	80004054 <fat_entry_longname+0x178>
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
80004020:	58 06       	cp.w	r6,0
80004022:	c0 b0       	breq	80004038 <fat_entry_longname+0x15c>
80004024:	49 18       	lddpc	r8,80004068 <fat_entry_longname+0x18c>
80004026:	11 89       	ld.ub	r9,r8[0x0]
80004028:	30 08       	mov	r8,0
8000402a:	f0 09 18 00 	cp.b	r9,r8
8000402e:	c1 50       	breq	80004058 <fat_entry_longname+0x17c>
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
80004030:	30 e8       	mov	r8,14
80004032:	ae 08       	st.h	r7[0x0],r8
80004034:	30 1c       	mov	r12,1
               return true;
80004036:	c0 f8       	rjmp	80004054 <fat_entry_longname+0x178>
               {
                  u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
               }else{
                  u16_unicode_szname = sz_name[0];
               }
               return fat_check_eof_name(u16_unicode_szname);
80004038:	0f 9c       	ld.ub	r12,r7[0x1]
8000403a:	f0 1f 00 0d 	mcall	8000406c <fat_entry_longname+0x190>
8000403e:	c0 b8       	rjmp	80004054 <fat_entry_longname+0x178>
            }
         }
      }

      if( !g_b_string_length )
80004040:	0b 89       	ld.ub	r9,r5[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
80004042:	f6 09 18 00 	cp.b	r9,r11
80004046:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
8000404a:	2f f8       	sub	r8,-1
8000404c:	5c 58       	castu.b	r8
      ptr_entry+=2;
8000404e:	2f ec       	sub	r12,-2
   }
80004050:	c7 fb       	rjmp	80003f4e <fat_entry_longname+0x72>
80004052:	30 1c       	mov	r12,1
}
80004054:	2f dd       	sub	sp,-12
80004056:	d8 32       	popm	r0-r7,pc
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004058:	30 08       	mov	r8,0
8000405a:	ae 98       	st.b	r7[0x1],r8
8000405c:	30 1c       	mov	r12,1
               }
               return true;
8000405e:	cf bb       	rjmp	80004054 <fat_entry_longname+0x178>
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	3e c4       	mov	r4,-20
80004064:	00 00       	add	r0,r0
80004066:	0d 00       	ld.w	r0,r6++
80004068:	00 00       	add	r0,r0
8000406a:	0d 01       	ld.w	r1,r6++
8000406c:	80 00       	ld.sh	r0,r0[0x0]
8000406e:	3e 9c       	mov	r12,-23

80004070 <fat_entry_shortname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_shortname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode )
{
80004070:	d4 31       	pushm	r0-r7,lr
80004072:	20 2d       	sub	sp,8
80004074:	18 97       	mov	r7,r12
80004076:	50 1b       	stdsp	sp[0x4],r11
80004078:	14 96       	mov	r6,r10
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
8000407a:	31 69       	mov	r9,22
8000407c:	4b c8       	lddpc	r8,8000416c <fat_entry_shortname+0xfc>
8000407e:	b0 89       	st.b	r8[0x0],r9

   u8_pos_name = 0;
   u8_pos_entry = 0;
   ptr_entry = fat_get_ptr_entry();
80004080:	f0 1f 00 3c 	mcall	80004170 <fat_entry_shortname+0x100>
80004084:	30 08       	mov	r8,0
80004086:	10 9a       	mov	r10,r8
80004088:	30 1b       	mov	r11,1
8000408a:	50 0b       	stdsp	sp[0x0],r11

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
8000408c:	30 be       	mov	lr,11
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
8000408e:	10 93       	mov	r3,r8
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
80004090:	30 85       	mov	r5,8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80004092:	32 04       	mov	r4,32
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
80004094:	32 a2       	mov	r2,42
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
80004096:	fc 08 18 00 	cp.b	r8,lr
8000409a:	c1 90       	breq	800040cc <fat_entry_shortname+0x5c>
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
8000409c:	f8 08 07 09 	ld.ub	r9,r12[r8]
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800040a0:	ea 08 18 00 	cp.b	r8,r5
800040a4:	c0 41       	brne	800040ac <fat_entry_shortname+0x3c>
800040a6:	40 01       	lddsp	r1,sp[0x0]
800040a8:	58 01       	cp.w	r1,0
800040aa:	c0 81       	brne	800040ba <fat_entry_shortname+0x4a>
800040ac:	e8 09 18 00 	cp.b	r9,r4
800040b0:	c0 f1       	brne	800040ce <fat_entry_shortname+0x5e>
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
800040b2:	ea 08 18 00 	cp.b	r8,r5
800040b6:	e0 8b 00 0b 	brhi	800040cc <fat_entry_shortname+0x5c>
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800040ba:	f9 39 00 08 	ld.ub	r9,r12[8]
800040be:	e8 09 18 00 	cp.b	r9,r4
800040c2:	c0 50       	breq	800040cc <fat_entry_shortname+0x5c>
800040c4:	30 78       	mov	r8,7
800040c6:	32 e9       	mov	r9,46
800040c8:	50 03       	stdsp	sp[0x0],r3
800040ca:	c0 28       	rjmp	800040ce <fat_entry_shortname+0x5e>
800040cc:	06 99       	mov	r9,r3
               u8_entry_char = 0;                                    // end of name
            }
         }
      }

      if( FS_NAME_GET == b_mode )
800040ce:	58 06       	cp.w	r6,0
800040d0:	c1 80       	breq	80004100 <fat_entry_shortname+0x90>
      {
         if( !g_b_string_length )
800040d2:	4a 9b       	lddpc	r11,80004174 <fat_entry_shortname+0x104>
800040d4:	17 81       	ld.ub	r1,r11[0x0]
800040d6:	30 0b       	mov	r11,0
800040d8:	f6 01 18 00 	cp.b	r1,r11
800040dc:	c2 c1       	brne	80004134 <fat_entry_shortname+0xc4>
         {
            if(u8_pos_name >= (u8_size_max-1))
800040de:	40 1b       	lddsp	r11,sp[0x4]
800040e0:	20 1b       	sub	r11,1
800040e2:	16 3a       	cp.w	r10,r11
800040e4:	c0 35       	brlt	800040ea <fat_entry_shortname+0x7a>
800040e6:	06 99       	mov	r9,r3
800040e8:	c0 a8       	rjmp	800040fc <fat_entry_shortname+0x8c>
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
800040ea:	f2 c1 00 41 	sub	r1,r9,65
800040ee:	31 9b       	mov	r11,25
800040f0:	f6 01 18 00 	cp.b	r1,r11
800040f4:	e0 8b 00 04 	brhi	800040fc <fat_entry_shortname+0x8c>
               u8_entry_char += ('a'-'A');                           // display short name in down case
800040f8:	2e 09       	sub	r9,-32
800040fa:	5c 59       	castu.b	r9

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
800040fc:	ae 89       	st.b	r7[0x0],r9
800040fe:	c1 b8       	rjmp	80004134 <fat_entry_shortname+0xc4>

         if( Is_unicode )
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
80004100:	0f 8b       	ld.ub	r11,r7[0x0]
         }
         if ('*' == u8_szname_char)
80004102:	e4 0b 18 00 	cp.b	r11,r2
80004106:	c2 f0       	breq	80004164 <fat_entry_shortname+0xf4>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
80004108:	58 09       	cp.w	r9,0
8000410a:	c0 c1       	brne	80004122 <fat_entry_shortname+0xb2>
8000410c:	35 c1       	mov	r1,92
8000410e:	e2 0b 18 00 	cp.b	r11,r1
80004112:	5f 10       	srne	r0
80004114:	32 f1       	mov	r1,47
80004116:	e2 0b 18 00 	cp.b	r11,r1
8000411a:	5f 11       	srne	r1
8000411c:	e1 e1 00 01 	and	r1,r0,r1
80004120:	c0 c0       	breq	80004138 <fat_entry_shortname+0xc8>
         {
            if((u8_szname_char != u8_entry_char)
80004122:	f2 0b 18 00 	cp.b	r11,r9
80004126:	c0 70       	breq	80004134 <fat_entry_shortname+0xc4>
80004128:	f2 c1 ff e0 	sub	r1,r9,-32
8000412c:	02 3b       	cp.w	r11,r1
8000412e:	c0 30       	breq	80004134 <fat_entry_shortname+0xc4>
80004130:	30 0c       	mov	r12,0
80004132:	c1 a8       	rjmp	80004166 <fat_entry_shortname+0xf6>
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
80004134:	58 09       	cp.w	r9,0
80004136:	c0 b1       	brne	8000414c <fat_entry_shortname+0xdc>
      {
         if( g_b_string_length )
80004138:	48 f8       	lddpc	r8,80004174 <fat_entry_shortname+0x104>
8000413a:	11 89       	ld.ub	r9,r8[0x0]
8000413c:	30 08       	mov	r8,0
8000413e:	f0 09 18 00 	cp.b	r9,r8
80004142:	c1 10       	breq	80004164 <fat_entry_shortname+0xf4>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
80004144:	2f fa       	sub	r10,-1
80004146:	ae 0a       	st.h	r7[0x0],r10
80004148:	30 1c       	mov	r12,1
8000414a:	c0 e8       	rjmp	80004166 <fat_entry_shortname+0xf6>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
8000414c:	48 a9       	lddpc	r9,80004174 <fat_entry_shortname+0x104>
8000414e:	13 8b       	ld.ub	r11,r9[0x0]
80004150:	30 09       	mov	r9,0
      {
         sz_name += (Is_unicode? 2 : 1 );
80004152:	f2 0b 18 00 	cp.b	r11,r9
80004156:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
8000415a:	2f fa       	sub	r10,-1
8000415c:	5c 5a       	castu.b	r10
      u8_pos_entry++;
8000415e:	2f f8       	sub	r8,-1
80004160:	5c 58       	castu.b	r8
   }
80004162:	c9 ab       	rjmp	80004096 <fat_entry_shortname+0x26>
80004164:	30 1c       	mov	r12,1
}
80004166:	2f ed       	sub	sp,-8
80004168:	d8 32       	popm	r0-r7,pc
8000416a:	00 00       	add	r0,r0
8000416c:	00 00       	add	r0,r0
8000416e:	0d 00       	ld.w	r0,r6++
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	3e c4       	mov	r4,-20
80004174:	00 00       	add	r0,r0
80004176:	0d 01       	ld.w	r1,r6++

80004178 <fat_get_entry_info>:
//! OUT:
//!   fs_g_nav_entry. u32_cluster, u8_attr, u32_size
//! @endverbatim
//!
void  fat_get_entry_info( void )
{
80004178:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
8000417a:	f0 1f 00 10 	mcall	800041b8 <fat_get_entry_info+0x40>

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
8000417e:	49 08       	lddpc	r8,800041bc <fat_get_entry_info+0x44>
80004180:	f9 39 00 0b 	ld.ub	r9,r12[11]
80004184:	b0 a9       	st.b	r8[0x2],r9

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
80004186:	f8 ca ff ec 	sub	r10,r12,-20
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
8000418a:	f0 c9 ff fc 	sub	r9,r8,-4
8000418e:	15 8b       	ld.ub	r11,r10[0x0]
80004190:	b2 9b       	st.b	r9[0x1],r11
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
80004192:	15 9a       	ld.ub	r10,r10[0x1]
80004194:	b2 8a       	st.b	r9[0x0],r10
   ptr_entry += (26-20);
80004196:	f8 ca ff e6 	sub	r10,r12,-26
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
8000419a:	15 8b       	ld.ub	r11,r10[0x0]
8000419c:	b2 bb       	st.b	r9[0x3],r11
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
8000419e:	15 9a       	ld.ub	r10,r10[0x1]
800041a0:	b2 aa       	st.b	r9[0x2],r10

   // Get the size of file
   ptr_entry += (28-26);
800041a2:	2e 4c       	sub	r12,-28
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
800041a4:	2f 88       	sub	r8,-8
800041a6:	19 89       	ld.ub	r9,r12[0x0]
800041a8:	b0 b9       	st.b	r8[0x3],r9
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
800041aa:	19 99       	ld.ub	r9,r12[0x1]
800041ac:	b0 a9       	st.b	r8[0x2],r9
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
800041ae:	19 a9       	ld.ub	r9,r12[0x2]
800041b0:	b0 99       	st.b	r8[0x1],r9
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
800041b2:	19 b9       	ld.ub	r9,r12[0x3]
800041b4:	b0 89       	st.b	r8[0x0],r9
}
800041b6:	d8 02       	popm	pc
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	3e c4       	mov	r4,-20
800041bc:	00 00       	add	r0,r0
800041be:	0a 70       	tst	r0,r5

800041c0 <fat_entry_checkext>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_checkext( FS_STRING sz_filter )
{
800041c0:	eb cd 40 fc 	pushm	r2-r7,lr
800041c4:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();
800041c6:	f0 1f 00 26 	mcall	8000425c <fat_entry_checkext+0x9c>

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
800041ca:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
800041cc:	32 a9       	mov	r9,42
800041ce:	f2 08 18 00 	cp.b	r8,r9
800041d2:	c3 f0       	breq	80004250 <fat_entry_checkext+0x90>
800041d4:	30 0a       	mov	r10,0
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
800041d6:	30 25       	mov	r5,2
      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
800041d8:	30 0e       	mov	lr,0

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
800041da:	32 c9       	mov	r9,44
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
800041dc:	32 03       	mov	r3,32
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
800041de:	14 94       	mov	r4,r10

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
      if ('*' == u8_filter_char)
800041e0:	32 a6       	mov	r6,42
800041e2:	c0 68       	rjmp	800041ee <fat_entry_checkext+0x2e>
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
800041e4:	2f f7       	sub	r7,-1
   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
800041e6:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
800041e8:	ec 08 18 00 	cp.b	r8,r6
800041ec:	c3 20       	breq	80004250 <fat_entry_checkext+0x90>
         break; // All extension is good

      u8_entry_char = u8_ptr_entry[8+u8_i];
800041ee:	f8 0a 00 0b 	add	r11,r12,r10
800041f2:	f7 3b 00 08 	ld.ub	r11,r11[8]

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
800041f6:	f6 08 18 00 	cp.b	r8,r11
800041fa:	c2 20       	breq	8000423e <fat_entry_checkext+0x7e>
800041fc:	f6 c2 ff e0 	sub	r2,r11,-32
80004200:	04 38       	cp.w	r8,r2
80004202:	c1 e0       	breq	8000423e <fat_entry_checkext+0x7e>
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80004204:	fc 08 18 00 	cp.b	r8,lr
80004208:	5f 0a       	sreq	r10

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
8000420a:	f2 08 18 00 	cp.b	r8,r9
8000420e:	5f 02       	sreq	r2
80004210:	f5 e2 10 02 	or	r2,r10,r2
80004214:	fc 02 18 00 	cp.b	r2,lr
80004218:	c0 71       	brne	80004226 <fat_entry_checkext+0x66>
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
8000421a:	f2 08 18 00 	cp.b	r8,r9
8000421e:	c1 b0       	breq	80004254 <fat_entry_checkext+0x94>
         {
            if (0  == u8_filter_char)
80004220:	58 0a       	cp.w	r10,0
80004222:	c0 80       	breq	80004232 <fat_entry_checkext+0x72>
80004224:	c1 48       	rjmp	8000424c <fat_entry_checkext+0x8c>
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
80004226:	e6 0b 18 00 	cp.b	r11,r3
8000422a:	cf 81       	brne	8000421a <fat_entry_checkext+0x5a>
8000422c:	c1 28       	rjmp	80004250 <fat_entry_checkext+0x90>
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
         {
            if (0  == u8_filter_char)
8000422e:	58 08       	cp.w	r8,0
80004230:	c0 e0       	breq	8000424c <fat_entry_checkext+0x8c>
            {
               return false;   // it is the last filter
            }
            sz_filter++;
80004232:	2f f7       	sub	r7,-1
            u8_filter_char = *sz_filter;
80004234:	0f 88       	ld.ub	r8,r7[0x0]
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
80004236:	f2 08 18 00 	cp.b	r8,r9
8000423a:	cf a1       	brne	8000422e <fat_entry_checkext+0x6e>
8000423c:	c0 c8       	rjmp	80004254 <fat_entry_checkext+0x94>
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
8000423e:	2f fa       	sub	r10,-1
80004240:	5c 5a       	castu.b	r10
80004242:	ea 0a 18 00 	cp.b	r10,r5
80004246:	fe 98 ff cf 	brls	800041e4 <fat_entry_checkext+0x24>
8000424a:	c0 38       	rjmp	80004250 <fat_entry_checkext+0x90>
8000424c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004250:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80004254:	2f f7       	sub	r7,-1
80004256:	08 9a       	mov	r10,r4
80004258:	cc 7b       	rjmp	800041e6 <fat_entry_checkext+0x26>
8000425a:	00 00       	add	r0,r0
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	3e c4       	mov	r4,-20

80004260 <fat_entry_check>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_check( bool b_type )
{
80004260:	eb cd 40 80 	pushm	r7,lr
80004264:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_first_byte, u8_seconde_byte;
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();
80004266:	f0 1f 00 14 	mcall	800042b4 <fat_entry_check+0x54>

   u8_first_byte = u8_ptr_entry[0];
8000426a:	19 88       	ld.ub	r8,r12[0x0]
   if ( FS_ENTRY_END == u8_first_byte )
8000426c:	58 08       	cp.w	r8,0
8000426e:	c0 61       	brne	8000427a <fat_entry_check+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
80004270:	30 a9       	mov	r9,10
80004272:	49 28       	lddpc	r8,800042b8 <fat_entry_check+0x58>
80004274:	b0 89       	st.b	r8[0x0],r9
80004276:	30 07       	mov	r7,0
      return false;
80004278:	c1 a8       	rjmp	800042ac <fat_entry_check+0x4c>
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
8000427a:	30 ba       	mov	r10,11
8000427c:	48 f9       	lddpc	r9,800042b8 <fat_entry_check+0x58>
8000427e:	b2 8a       	st.b	r9[0x0],r10
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
80004280:	3e 59       	mov	r9,-27
80004282:	f2 08 18 00 	cp.b	r8,r9
80004286:	c1 20       	breq	800042aa <fat_entry_check+0x4a>
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
80004288:	32 e9       	mov	r9,46
8000428a:	f2 08 18 00 	cp.b	r8,r9
8000428e:	c0 e0       	breq	800042aa <fat_entry_check+0x4a>
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
80004290:	f9 38 00 0b 	ld.ub	r8,r12[11]
80004294:	10 99       	mov	r9,r8
80004296:	e2 19 00 08 	andl	r9,0x8,COH
8000429a:	c0 81       	brne	800042aa <fat_entry_check+0x4a>
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
8000429c:	e2 18 00 10 	andl	r8,0x10,COH
800042a0:	c0 60       	breq	800042ac <fat_entry_check+0x4c>
   {
      return (FS_DIR == b_type);
800042a2:	ec 17 00 01 	eorl	r7,0x1
800042a6:	5c 57       	castu.b	r7
800042a8:	c0 28       	rjmp	800042ac <fat_entry_check+0x4c>
800042aa:	30 07       	mov	r7,0
   }else{
      return (FS_FILE == b_type);
   }
}
800042ac:	0e 9c       	mov	r12,r7
800042ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800042b2:	00 00       	add	r0,r0
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	3e c4       	mov	r4,-20
800042b8:	00 00       	add	r0,r0
800042ba:	0d 00       	ld.w	r0,r6++

800042bc <fat_cache_reset>:

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
800042bc:	48 58       	lddpc	r8,800042d0 <fat_cache_reset+0x14>
800042be:	3f f9       	mov	r9,-1
800042c0:	b0 89       	st.b	r8[0x0],r9
   fs_g_sectorcache.u8_dirty              = false;
800042c2:	30 09       	mov	r9,0
800042c4:	f1 69 00 08 	st.b	r8[8],r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
800042c8:	3f f9       	mov	r9,-1
800042ca:	91 39       	st.w	r8[0xc],r9
}
800042cc:	5e fc       	retal	r12
800042ce:	00 00       	add	r0,r0
800042d0:	00 00       	add	r0,r0
800042d2:	0d 38       	ld.ub	r8,r6++

800042d4 <fat_cache_mark_sector_as_dirty>:

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
800042d4:	30 19       	mov	r9,1
800042d6:	48 38       	lddpc	r8,800042e0 <fat_cache_mark_sector_as_dirty+0xc>
800042d8:	f1 69 00 08 	st.b	r8[8],r9
}
800042dc:	5e fc       	retal	r12
800042de:	00 00       	add	r0,r0
800042e0:	00 00       	add	r0,r0
800042e2:	0d 38       	ld.ub	r8,r6++

800042e4 <fat_write_entry_file>:
//! OUT:
//!   fs_g_sector    Updated
//! @endverbatim
//!
void  fat_write_entry_file( void )
{
800042e4:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   fat_cache_mark_sector_as_dirty();
800042e6:	f0 1f 00 11 	mcall	80004328 <fat_write_entry_file+0x44>
   ptr_entry = fat_get_ptr_entry();
800042ea:	f0 1f 00 11 	mcall	8000432c <fat_write_entry_file+0x48>
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
800042ee:	49 18       	lddpc	r8,80004330 <fat_write_entry_file+0x4c>
800042f0:	11 a9       	ld.ub	r9,r8[0x2]
800042f2:	f9 69 00 0b 	st.b	r12[11],r9

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
800042f6:	f8 ca ff ec 	sub	r10,r12,-20
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
800042fa:	f0 c9 ff fc 	sub	r9,r8,-4
800042fe:	13 9b       	ld.ub	r11,r9[0x1]
80004300:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
80004302:	13 8b       	ld.ub	r11,r9[0x0]
80004304:	b4 9b       	st.b	r10[0x1],r11
   ptr_entry += (26-20);
80004306:	f8 ca ff e6 	sub	r10,r12,-26
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
8000430a:	13 bb       	ld.ub	r11,r9[0x3]
8000430c:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
8000430e:	13 a9       	ld.ub	r9,r9[0x2]
80004310:	b4 99       	st.b	r10[0x1],r9

   //! Write the size of file
   ptr_entry += (28-26);
80004312:	2e 4c       	sub	r12,-28
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
80004314:	2f 88       	sub	r8,-8
80004316:	11 b9       	ld.ub	r9,r8[0x3]
80004318:	b8 89       	st.b	r12[0x0],r9
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
8000431a:	11 a9       	ld.ub	r9,r8[0x2]
8000431c:	b8 99       	st.b	r12[0x1],r9
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
8000431e:	11 99       	ld.ub	r9,r8[0x1]
80004320:	b8 a9       	st.b	r12[0x2],r9
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
80004322:	11 88       	ld.ub	r8,r8[0x0]
80004324:	b8 b8       	st.b	r12[0x3],r8
}
80004326:	d8 02       	popm	pc
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	42 d4       	lddsp	r4,sp[0xb4]
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	3e c4       	mov	r4,-20
80004330:	00 00       	add	r0,r0
80004332:	0a 70       	tst	r0,r5

80004334 <fat_check_nav_access_file>:

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
80004334:	49 88       	lddpc	r8,80004394 <fat_check_nav_access_file+0x60>
80004336:	11 89       	ld.ub	r9,r8[0x0]
80004338:	30 08       	mov	r8,0
8000433a:	f0 09 18 00 	cp.b	r9,r8
8000433e:	c2 a0       	breq	80004392 <fat_check_nav_access_file+0x5e>
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004340:	49 68       	lddpc	r8,80004398 <fat_check_nav_access_file+0x64>
80004342:	11 89       	ld.ub	r9,r8[0x0]
80004344:	49 68       	lddpc	r8,8000439c <fat_check_nav_access_file+0x68>
80004346:	11 88       	ld.ub	r8,r8[0x0]
80004348:	f0 09 18 00 	cp.b	r9,r8
8000434c:	c2 31       	brne	80004392 <fat_check_nav_access_file+0x5e>
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
8000434e:	49 38       	lddpc	r8,80004398 <fat_check_nav_access_file+0x64>
80004350:	70 89       	ld.w	r9,r8[0x20]
80004352:	49 38       	lddpc	r8,8000439c <fat_check_nav_access_file+0x68>
80004354:	70 88       	ld.w	r8,r8[0x20]
80004356:	10 39       	cp.w	r9,r8
80004358:	c1 d1       	brne	80004392 <fat_check_nav_access_file+0x5e>
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
8000435a:	49 28       	lddpc	r8,800043a0 <fat_check_nav_access_file+0x6c>
8000435c:	90 19       	ld.sh	r9,r8[0x2]
8000435e:	48 e8       	lddpc	r8,80004394 <fat_check_nav_access_file+0x60>
80004360:	90 18       	ld.sh	r8,r8[0x2]
80004362:	f0 09 19 00 	cp.h	r9,r8
80004366:	c1 61       	brne	80004392 <fat_check_nav_access_file+0x5e>
      {
         if( mode )
80004368:	58 0c       	cp.w	r12,0
8000436a:	c0 b0       	breq	80004380 <fat_check_nav_access_file+0x4c>
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
8000436c:	48 e8       	lddpc	r8,800043a4 <fat_check_nav_access_file+0x70>
8000436e:	11 89       	ld.ub	r9,r8[0x0]
80004370:	30 08       	mov	r8,0
80004372:	f0 09 18 00 	cp.b	r9,r8
80004376:	c0 e0       	breq	80004392 <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN;
80004378:	32 89       	mov	r9,40
8000437a:	48 c8       	lddpc	r8,800043a8 <fat_check_nav_access_file+0x74>
8000437c:	b0 89       	st.b	r8[0x0],r9
8000437e:	5e fd       	retal	0
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
80004380:	48 98       	lddpc	r8,800043a4 <fat_check_nav_access_file+0x70>
80004382:	11 88       	ld.ub	r8,r8[0x0]
80004384:	e2 18 00 02 	andl	r8,0x2,COH
80004388:	c0 50       	breq	80004392 <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
8000438a:	32 99       	mov	r9,41
8000438c:	48 78       	lddpc	r8,800043a8 <fat_check_nav_access_file+0x74>
8000438e:	b0 89       	st.b	r8[0x0],r9
80004390:	5e fd       	retal	0
               return false;  // File opened in write mode then read access not possible
80004392:	5e ff       	retal	1
80004394:	00 00       	add	r0,r0
80004396:	0c f8       	st.b	--r6,r8
80004398:	00 00       	add	r0,r0
8000439a:	0c b0       	st.h	r6++,r0
8000439c:	00 00       	add	r0,r0
8000439e:	0d 04       	ld.w	r4,r6++
800043a0:	00 00       	add	r0,r0
800043a2:	0c fc       	st.b	--r6,r12
800043a4:	00 00       	add	r0,r0
800043a6:	0c e8       	st.h	--r6,r8
800043a8:	00 00       	add	r0,r0
800043aa:	0d 00       	ld.w	r0,r6++

800043ac <fat_invert_nav>:
//! This function inverts the current navigation with another
//!
//! @param     u8_idnav    Id navigator to invert
//!
void  fat_invert_nav( uint8_t u8_idnav )
{
800043ac:	d4 21       	pushm	r4-r7,lr
800043ae:	20 dd       	sub	sp,52
   _MEM_TYPE_SLOW_ uint8_t Temp[Max(Max(sizeof(Fs_management),sizeof(Fs_management_entry)),sizeof(Fs_management_fast))];

   if( u8_idnav == 0 )
800043b0:	58 0c       	cp.w	r12,0
800043b2:	c5 a0       	breq	80004466 <fat_invert_nav+0xba>
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
800043b4:	1a 97       	mov	r7,sp
800043b6:	4a e8       	lddpc	r8,8000446c <fat_invert_nav+0xc0>
800043b8:	f0 ea 00 00 	ld.d	r10,r8[0]
800043bc:	fa eb 00 00 	st.d	sp[0],r10
800043c0:	f0 ea 00 08 	ld.d	r10,r8[8]
800043c4:	fa eb 00 08 	st.d	sp[8],r10
800043c8:	f0 ea 00 10 	ld.d	r10,r8[16]
800043cc:	fa eb 00 10 	st.d	sp[16],r10
800043d0:	f0 ea 00 18 	ld.d	r10,r8[24]
800043d4:	fa eb 00 18 	st.d	sp[24],r10
800043d8:	f0 ea 00 20 	ld.d	r10,r8[32]
800043dc:	fa eb 00 20 	st.d	sp[32],r10
800043e0:	f0 ea 00 28 	ld.d	r10,r8[40]
800043e4:	fa eb 00 28 	st.d	sp[40],r10
800043e8:	70 c9       	ld.w	r9,r8[0x30]
800043ea:	50 c9       	stdsp	sp[0x30],r9
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
800043ec:	f8 c6 00 01 	sub	r6,r12,1
800043f0:	5c 56       	castu.b	r6
800043f2:	ec 04 10 34 	mul	r4,r6,52
800043f6:	49 f9       	lddpc	r9,80004470 <fat_invert_nav+0xc4>
800043f8:	12 04       	add	r4,r9
800043fa:	33 45       	mov	r5,52
800043fc:	0a 9a       	mov	r10,r5
800043fe:	08 9b       	mov	r11,r4
80004400:	10 9c       	mov	r12,r8
80004402:	f0 1f 00 1d 	mcall	80004474 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
80004406:	0a 9a       	mov	r10,r5
80004408:	1a 9b       	mov	r11,sp
8000440a:	08 9c       	mov	r12,r4
8000440c:	f0 1f 00 1a 	mcall	80004474 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
80004410:	49 ac       	lddpc	r12,80004478 <fat_invert_nav+0xcc>
80004412:	f8 e8 00 00 	ld.d	r8,r12[0]
80004416:	fa e9 00 00 	st.d	sp[0],r8
8000441a:	f8 e8 00 08 	ld.d	r8,r12[8]
8000441e:	fa e9 00 08 	st.d	sp[8],r8
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
80004422:	ec 04 15 04 	lsl	r4,r6,0x4
80004426:	49 68       	lddpc	r8,8000447c <fat_invert_nav+0xd0>
80004428:	10 04       	add	r4,r8
8000442a:	31 05       	mov	r5,16
8000442c:	0a 9a       	mov	r10,r5
8000442e:	08 9b       	mov	r11,r4
80004430:	f0 1f 00 11 	mcall	80004474 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
80004434:	0a 9a       	mov	r10,r5
80004436:	1a 9b       	mov	r11,sp
80004438:	08 9c       	mov	r12,r4
8000443a:	f0 1f 00 0f 	mcall	80004474 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
8000443e:	49 14       	lddpc	r4,80004480 <fat_invert_nav+0xd4>
80004440:	30 45       	mov	r5,4
80004442:	0a 9a       	mov	r10,r5
80004444:	08 9b       	mov	r11,r4
80004446:	1a 9c       	mov	r12,sp
80004448:	f0 1f 00 0b 	mcall	80004474 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
8000444c:	48 e8       	lddpc	r8,80004484 <fat_invert_nav+0xd8>
8000444e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004452:	0a 9a       	mov	r10,r5
80004454:	0c 9b       	mov	r11,r6
80004456:	08 9c       	mov	r12,r4
80004458:	f0 1f 00 07 	mcall	80004474 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
8000445c:	0a 9a       	mov	r10,r5
8000445e:	1a 9b       	mov	r11,sp
80004460:	0c 9c       	mov	r12,r6
80004462:	f0 1f 00 05 	mcall	80004474 <fat_invert_nav+0xc8>
}
80004466:	2f 3d       	sub	sp,-52
80004468:	d8 22       	popm	r4-r7,pc
8000446a:	00 00       	add	r0,r0
8000446c:	00 00       	add	r0,r0
8000446e:	0c b0       	st.h	r6++,r0
80004470:	00 00       	add	r0,r0
80004472:	0d 04       	ld.w	r4,r6++
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	91 20       	st.w	r8[0x8],r0
80004478:	00 00       	add	r0,r0
8000447a:	0a 70       	tst	r0,r5
8000447c:	00 00       	add	r0,r0
8000447e:	0c e8       	st.h	--r6,r8
80004480:	00 00       	add	r0,r0
80004482:	0c fc       	st.b	--r6,r12
80004484:	00 00       	add	r0,r0
80004486:	0c f8       	st.b	--r6,r8

80004488 <fat_cache_flush>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
80004488:	d4 01       	pushm	lr
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000448a:	49 08       	lddpc	r8,800044c8 <fat_cache_flush+0x40>
8000448c:	f1 39 00 08 	ld.ub	r9,r8[8]
80004490:	30 18       	mov	r8,1
80004492:	f0 09 18 00 	cp.b	r9,r8
80004496:	c1 81       	brne	800044c6 <fat_cache_flush+0x3e>
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
80004498:	48 c8       	lddpc	r8,800044c8 <fat_cache_flush+0x40>
8000449a:	30 09       	mov	r9,0
8000449c:	f1 69 00 08 	st.b	r8[8],r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
800044a0:	11 8c       	ld.ub	r12,r8[0x0]
800044a2:	f0 1f 00 0b 	mcall	800044cc <fat_cache_flush+0x44>
800044a6:	c0 50       	breq	800044b0 <fat_cache_flush+0x28>
      {
         fs_g_status = FS_LUN_WP;
800044a8:	31 49       	mov	r9,20
800044aa:	48 a8       	lddpc	r8,800044d0 <fat_cache_flush+0x48>
800044ac:	b0 89       	st.b	r8[0x0],r9
800044ae:	d8 0a       	popm	pc,r12=0
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
800044b0:	48 68       	lddpc	r8,800044c8 <fat_cache_flush+0x40>
800044b2:	48 9a       	lddpc	r10,800044d4 <fat_cache_flush+0x4c>
800044b4:	70 1b       	ld.w	r11,r8[0x4]
800044b6:	11 8c       	ld.ub	r12,r8[0x0]
800044b8:	f0 1f 00 08 	mcall	800044d8 <fat_cache_flush+0x50>
800044bc:	c0 50       	breq	800044c6 <fat_cache_flush+0x3e>
      {
         fs_g_status = FS_ERR_HW;
800044be:	30 19       	mov	r9,1
800044c0:	48 48       	lddpc	r8,800044d0 <fat_cache_flush+0x48>
800044c2:	b0 89       	st.b	r8[0x0],r9
800044c4:	d8 0a       	popm	pc,r12=0
         return false;
800044c6:	da 0a       	popm	pc,r12=1
800044c8:	00 00       	add	r0,r0
800044ca:	0d 38       	ld.ub	r8,r6++
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	5d 90       	*unknown*
800044d0:	00 00       	add	r0,r0
800044d2:	0d 00       	ld.w	r0,r6++
800044d4:	00 00       	add	r0,r0
800044d6:	0a b0       	st.h	r5++,r0
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	5c d0       	com	r0

800044dc <fat_cache_clear>:

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
800044dc:	d4 01       	pushm	lr
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
800044de:	e0 6a 02 00 	mov	r10,512
800044e2:	30 0b       	mov	r11,0
800044e4:	48 2c       	lddpc	r12,800044ec <fat_cache_clear+0x10>
800044e6:	f0 1f 00 03 	mcall	800044f0 <fat_cache_clear+0x14>
}
800044ea:	d8 02       	popm	pc
800044ec:	00 00       	add	r0,r0
800044ee:	0a b0       	st.h	r5++,r0
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	92 68       	ld.sh	r8,r9[0xc]

800044f4 <fat_cache_read_sector>:
//!   fs_g_nav.u8_lun      drive number to read
//!   fs_gu32_addrsector   address to read (unit sector)
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
800044f4:	eb cd 40 80 	pushm	r7,lr
800044f8:	18 97       	mov	r7,r12
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
800044fa:	49 78       	lddpc	r8,80004554 <fat_cache_read_sector+0x60>
800044fc:	11 89       	ld.ub	r9,r8[0x0]
800044fe:	49 78       	lddpc	r8,80004558 <fat_cache_read_sector+0x64>
80004500:	11 88       	ld.ub	r8,r8[0x0]
80004502:	f0 09 18 00 	cp.b	r9,r8
80004506:	c0 91       	brne	80004518 <fat_cache_read_sector+0x24>
80004508:	49 38       	lddpc	r8,80004554 <fat_cache_read_sector+0x60>
8000450a:	70 19       	ld.w	r9,r8[0x4]
8000450c:	49 48       	lddpc	r8,8000455c <fat_cache_read_sector+0x68>
8000450e:	70 08       	ld.w	r8,r8[0x0]
80004510:	10 39       	cp.w	r9,r8
80004512:	c0 31       	brne	80004518 <fat_cache_read_sector+0x24>
80004514:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      return true;
   }

   // Write previous cache before fill cache with a new sector
   if( !fat_cache_flush())
80004518:	f0 1f 00 12 	mcall	80004560 <fat_cache_read_sector+0x6c>
8000451c:	c1 90       	breq	8000454e <fat_cache_read_sector+0x5a>
      return false;

   // Delete informations about the caches
   fat_cache_reset();
8000451e:	f0 1f 00 12 	mcall	80004564 <fat_cache_read_sector+0x70>

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
80004522:	48 f8       	lddpc	r8,8000455c <fat_cache_read_sector+0x68>
80004524:	70 0b       	ld.w	r11,r8[0x0]
80004526:	48 c8       	lddpc	r8,80004554 <fat_cache_read_sector+0x60>
80004528:	91 1b       	st.w	r8[0x4],r11
   if( b_load )
8000452a:	58 07       	cp.w	r7,0
8000452c:	c0 c0       	breq	80004544 <fat_cache_read_sector+0x50>
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000452e:	48 fa       	lddpc	r10,80004568 <fat_cache_read_sector+0x74>
80004530:	48 a8       	lddpc	r8,80004558 <fat_cache_read_sector+0x64>
80004532:	11 8c       	ld.ub	r12,r8[0x0]
80004534:	f0 1f 00 0e 	mcall	8000456c <fat_cache_read_sector+0x78>
80004538:	c0 60       	breq	80004544 <fat_cache_read_sector+0x50>
      {
         fs_g_status = FS_ERR_HW;
8000453a:	30 19       	mov	r9,1
8000453c:	48 d8       	lddpc	r8,80004570 <fat_cache_read_sector+0x7c>
8000453e:	b0 89       	st.b	r8[0x0],r9
80004540:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
80004544:	48 58       	lddpc	r8,80004558 <fat_cache_read_sector+0x64>
80004546:	11 89       	ld.ub	r9,r8[0x0]
80004548:	48 38       	lddpc	r8,80004554 <fat_cache_read_sector+0x60>
8000454a:	b0 89       	st.b	r8[0x0],r9
8000454c:	30 1c       	mov	r12,1
   return true;
}
8000454e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004552:	00 00       	add	r0,r0
80004554:	00 00       	add	r0,r0
80004556:	0d 38       	ld.ub	r8,r6++
80004558:	00 00       	add	r0,r0
8000455a:	0c b0       	st.h	r6++,r0
8000455c:	00 00       	add	r0,r0
8000455e:	0a 6c       	and	r12,r5
80004560:	80 00       	ld.sh	r0,r0[0x0]
80004562:	44 88       	lddsp	r8,sp[0x120]
80004564:	80 00       	ld.sh	r0,r0[0x0]
80004566:	42 bc       	lddsp	r12,sp[0xac]
80004568:	00 00       	add	r0,r0
8000456a:	0a b0       	st.h	r5++,r0
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	5d 30       	musfr	r0
80004570:	00 00       	add	r0,r0
80004572:	0d 00       	ld.w	r0,r6++

80004574 <fat_cluster_readnext>:
//!   fs_g_u16_pos_fat        read cluster position in FAT
//!   fs_g_cluster.u32_val    value of cluster read
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
80004574:	d4 01       	pushm	lr
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
80004576:	49 f8       	lddpc	r8,800045f0 <fat_cluster_readnext+0x7c>
80004578:	11 89       	ld.ub	r9,r8[0x0]
8000457a:	30 38       	mov	r8,3
8000457c:	f0 09 18 00 	cp.b	r9,r8
80004580:	c0 61       	brne	8000458c <fat_cluster_readnext+0x18>
   {
      fs_g_u16_pos_fat += 4;
80004582:	49 d8       	lddpc	r8,800045f4 <fat_cluster_readnext+0x80>
80004584:	90 09       	ld.sh	r9,r8[0x0]
80004586:	2f c9       	sub	r9,-4
80004588:	b0 09       	st.h	r8[0x0],r9
8000458a:	c0 58       	rjmp	80004594 <fat_cluster_readnext+0x20>
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
8000458c:	49 a8       	lddpc	r8,800045f4 <fat_cluster_readnext+0x80>
8000458e:	90 09       	ld.sh	r9,r8[0x0]
80004590:	2f e9       	sub	r9,-2
80004592:	b0 09       	st.h	r8[0x0],r9
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
80004594:	49 88       	lddpc	r8,800045f4 <fat_cluster_readnext+0x80>
80004596:	90 09       	ld.sh	r9,r8[0x0]
80004598:	e0 68 02 00 	mov	r8,512
8000459c:	f0 09 19 00 	cp.h	r9,r8
800045a0:	c0 c1       	brne	800045b8 <fat_cluster_readnext+0x44>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
800045a2:	30 09       	mov	r9,0
800045a4:	49 48       	lddpc	r8,800045f4 <fat_cluster_readnext+0x80>
800045a6:	b0 09       	st.h	r8[0x0],r9
      fs_gu32_addrsector++;
800045a8:	49 48       	lddpc	r8,800045f8 <fat_cluster_readnext+0x84>
800045aa:	70 09       	ld.w	r9,r8[0x0]
800045ac:	2f f9       	sub	r9,-1
800045ae:	91 09       	st.w	r8[0x0],r9
      if( !fat_cache_read_sector( true ))
800045b0:	30 1c       	mov	r12,1
800045b2:	f0 1f 00 13 	mcall	800045fc <fat_cluster_readnext+0x88>
800045b6:	c1 b0       	breq	800045ec <fat_cluster_readnext+0x78>
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
800045b8:	49 28       	lddpc	r8,80004600 <fat_cluster_readnext+0x8c>
800045ba:	2f c8       	sub	r8,-4
800045bc:	48 e9       	lddpc	r9,800045f4 <fat_cluster_readnext+0x80>
800045be:	92 89       	ld.uh	r9,r9[0x0]
800045c0:	49 1a       	lddpc	r10,80004604 <fat_cluster_readnext+0x90>
800045c2:	f4 09 07 0b 	ld.ub	r11,r10[r9]
800045c6:	b0 bb       	st.b	r8[0x3],r11
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
800045c8:	12 0a       	add	r10,r9
800045ca:	15 9a       	ld.ub	r10,r10[0x1]
800045cc:	b0 aa       	st.b	r8[0x2],r10

   if ( Is_fat32 )
800045ce:	48 9a       	lddpc	r10,800045f0 <fat_cluster_readnext+0x7c>
800045d0:	15 8b       	ld.ub	r11,r10[0x0]
800045d2:	30 3a       	mov	r10,3
800045d4:	f4 0b 18 00 	cp.b	r11,r10
800045d8:	c0 20       	breq	800045dc <fat_cluster_readnext+0x68>
800045da:	da 0a       	popm	pc,r12=1
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
800045dc:	48 aa       	lddpc	r10,80004604 <fat_cluster_readnext+0x90>
800045de:	f4 09 00 09 	add	r9,r10,r9
800045e2:	13 aa       	ld.ub	r10,r9[0x2]
800045e4:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
800045e6:	13 b9       	ld.ub	r9,r9[0x3]
800045e8:	b0 89       	st.b	r8[0x0],r9
800045ea:	30 1c       	mov	r12,1
   }
   return true;
}
800045ec:	d8 02       	popm	pc
800045ee:	00 00       	add	r0,r0
800045f0:	00 00       	add	r0,r0
800045f2:	0c fc       	st.b	--r6,r12
800045f4:	00 00       	add	r0,r0
800045f6:	0a 80       	andn	r0,r5
800045f8:	00 00       	add	r0,r0
800045fa:	0a 6c       	and	r12,r5
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	44 f4       	lddsp	r4,sp[0x13c]
80004600:	00 00       	add	r0,r0
80004602:	0d 50       	ld.sh	r0,--r6
80004604:	00 00       	add	r0,r0
80004606:	0a b0       	st.h	r5++,r0

80004608 <fat_cluster_val>:
//!   fs_g_u16_pos_fat        position in FAT of the cluster to read or write
//!                           value init in case of the fat_cluster_readnext() routine is used after
//! @endverbatim
//!
bool  fat_cluster_val( bool b_mode )
{
80004608:	d4 31       	pushm	r0-r7,lr
8000460a:	18 95       	mov	r5,r12
   _MEM_TYPE_FAST_ uint32_t   u32_offset_fat =0;
   _MEM_TYPE_FAST_ uint8_t    u8_data1, u8_data2,u8_data3,u8_data4;
   _MEM_TYPE_FAST_ PTR_CACHE u8_ptr_cluster;

   //**** Compute the cluster position in FAT (sector address & position in sector)
   if ( Is_fat32 )
8000460c:	fe f8 02 18 	ld.w	r8,pc[536]
80004610:	11 88       	ld.ub	r8,r8[0x0]
80004612:	30 39       	mov	r9,3
80004614:	f2 08 18 00 	cp.b	r8,r9
80004618:	c0 d1       	brne	80004632 <fat_cluster_val+0x2a>
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
8000461a:	fe fa 02 0e 	ld.w	r10,pc[526]
8000461e:	74 09       	ld.w	r9,r10[0x0]
80004620:	a7 99       	lsr	r9,0x7

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
80004622:	15 bb       	ld.ub	r11,r10[0x3]
80004624:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80004628:	a3 6b       	lsl	r11,0x2
8000462a:	fe fa 02 02 	ld.w	r10,pc[514]
8000462e:	b4 0b       	st.h	r10[0x0],r11
80004630:	c2 08       	rjmp	80004670 <fat_cluster_val+0x68>
   }
   else if ( Is_fat16 )
80004632:	30 29       	mov	r9,2
80004634:	f2 08 18 00 	cp.b	r8,r9
80004638:	c0 81       	brne	80004648 <fat_cluster_val+0x40>
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
8000463a:	4f ca       	lddpc	r10,80004828 <fat_cluster_val+0x220>
8000463c:	15 a9       	ld.ub	r9,r10[0x2]
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
8000463e:	15 bb       	ld.ub	r11,r10[0x3]
80004640:	a1 7b       	lsl	r11,0x1
80004642:	4f ba       	lddpc	r10,8000482c <fat_cluster_val+0x224>
80004644:	b4 0b       	st.h	r10[0x0],r11
80004646:	c1 58       	rjmp	80004670 <fat_cluster_val+0x68>
   }
   else if ( Is_fat12 )
80004648:	30 19       	mov	r9,1
8000464a:	f2 08 18 00 	cp.b	r8,r9
8000464e:	c0 30       	breq	80004654 <fat_cluster_val+0x4c>
80004650:	30 09       	mov	r9,0
80004652:	c0 f8       	rjmp	80004670 <fat_cluster_val+0x68>
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
80004654:	4f 59       	lddpc	r9,80004828 <fat_cluster_val+0x220>
80004656:	72 09       	ld.w	r9,r9[0x0]
80004658:	4f 5a       	lddpc	r10,8000482c <fat_cluster_val+0x224>
8000465a:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
8000465e:	12 0b       	add	r11,r9
80004660:	b4 0b       	st.h	r10[0x0],r11
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
80004662:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
80004666:	f6 09 16 01 	lsr	r9,r11,0x1
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
8000466a:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
8000466e:	b4 8b       	st.b	r10[0x0],r11
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
80004670:	58 05       	cp.w	r5,0
80004672:	c2 20       	breq	800046b6 <fat_cluster_val+0xae>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
80004674:	4e fa       	lddpc	r10,80004830 <fat_cluster_val+0x228>
80004676:	74 0a       	ld.w	r10,r10[0x0]
80004678:	14 39       	cp.w	r9,r10
8000467a:	c0 32       	brcc	80004680 <fat_cluster_val+0x78>
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
8000467c:	4e da       	lddpc	r10,80004830 <fat_cluster_val+0x228>
8000467e:	95 09       	st.w	r10[0x0],r9
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
80004680:	4e da       	lddpc	r10,80004834 <fat_cluster_val+0x22c>
80004682:	74 0a       	ld.w	r10,r10[0x0]
80004684:	14 39       	cp.w	r9,r10
80004686:	e0 88 00 04 	brls	8000468e <fat_cluster_val+0x86>
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
8000468a:	4e ba       	lddpc	r10,80004834 <fat_cluster_val+0x22c>
8000468c:	95 09       	st.w	r10[0x0],r9
      }
      if ( Is_fat12 )
8000468e:	30 1a       	mov	r10,1
80004690:	f4 08 18 00 	cp.b	r8,r10
80004694:	c1 11       	brne	800046b6 <fat_cluster_val+0xae>
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80004696:	4e 68       	lddpc	r8,8000482c <fat_cluster_val+0x224>
80004698:	90 0a       	ld.sh	r10,r8[0x0]
8000469a:	e0 68 01 ff 	mov	r8,511
8000469e:	f0 0a 19 00 	cp.h	r10,r8
800046a2:	c0 a1       	brne	800046b6 <fat_cluster_val+0xae>
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
800046a4:	f2 c8 ff ff 	sub	r8,r9,-1
800046a8:	4e 3a       	lddpc	r10,80004834 <fat_cluster_val+0x22c>
800046aa:	74 0a       	ld.w	r10,r10[0x0]
800046ac:	14 38       	cp.w	r8,r10
800046ae:	e0 88 00 04 	brls	800046b6 <fat_cluster_val+0xae>
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
800046b2:	4e 1a       	lddpc	r10,80004834 <fat_cluster_val+0x22c>
800046b4:	95 08       	st.w	r10[0x0],r8
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
800046b6:	4e 18       	lddpc	r8,80004838 <fat_cluster_val+0x230>
800046b8:	70 48       	ld.w	r8,r8[0x10]
800046ba:	10 09       	add	r9,r8
800046bc:	4e 08       	lddpc	r8,8000483c <fat_cluster_val+0x234>
800046be:	91 09       	st.w	r8[0x0],r9
   if( !fat_cache_read_sector( true ))
800046c0:	30 1c       	mov	r12,1
800046c2:	f0 1f 00 60 	mcall	80004840 <fat_cluster_val+0x238>
800046c6:	e0 80 00 ad 	breq	80004820 <fat_cluster_val+0x218>
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
800046ca:	4d 98       	lddpc	r8,8000482c <fat_cluster_val+0x224>
800046cc:	90 08       	ld.sh	r8,r8[0x0]
800046ce:	ed d8 c0 10 	bfextu	r6,r8,0x0,0x10
800046d2:	4d d9       	lddpc	r9,80004844 <fat_cluster_val+0x23c>
800046d4:	12 06       	add	r6,r9
   u8_data1 = u8_ptr_cluster[0];
800046d6:	0c 97       	mov	r7,r6
800046d8:	0f 32       	ld.ub	r2,r7++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
800046da:	0f 8b       	ld.ub	r11,r7[0x0]
   u8_data3 = u8_ptr_cluster[2];
800046dc:	ec c4 ff fe 	sub	r4,r6,-2
800046e0:	09 81       	ld.ub	r1,r4[0x0]
   u8_data4 = u8_ptr_cluster[3];
800046e2:	ec c3 ff fd 	sub	r3,r6,-3
800046e6:	07 80       	ld.ub	r0,r3[0x0]

   if ( Is_fat12 )
800046e8:	4c f9       	lddpc	r9,80004824 <fat_cluster_val+0x21c>
800046ea:	13 8a       	ld.ub	r10,r9[0x0]
800046ec:	30 19       	mov	r9,1
800046ee:	f2 0a 18 00 	cp.b	r10,r9
800046f2:	c1 11       	brne	80004714 <fat_cluster_val+0x10c>
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
800046f4:	e0 69 01 ff 	mov	r9,511
800046f8:	f2 08 19 00 	cp.h	r8,r9
800046fc:	c0 c1       	brne	80004714 <fat_cluster_val+0x10c>
      {  // Go to next sector
         fs_gu32_addrsector++;
800046fe:	4d 08       	lddpc	r8,8000483c <fat_cluster_val+0x234>
80004700:	70 09       	ld.w	r9,r8[0x0]
80004702:	2f f9       	sub	r9,-1
80004704:	91 09       	st.w	r8[0x0],r9
         if( !fat_cache_read_sector( true ))
80004706:	30 1c       	mov	r12,1
80004708:	f0 1f 00 4e 	mcall	80004840 <fat_cluster_val+0x238>
8000470c:	e0 80 00 8a 	breq	80004820 <fat_cluster_val+0x218>
           return false;
         u8_data2 = fs_g_sector[0];
80004710:	4c d8       	lddpc	r8,80004844 <fat_cluster_val+0x23c>
80004712:	11 8b       	ld.ub	r11,r8[0x0]
      }
   }

   if (false == b_mode)
80004714:	58 05       	cp.w	r5,0
80004716:	c3 11       	brne	80004778 <fat_cluster_val+0x170>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
80004718:	4c 48       	lddpc	r8,80004828 <fat_cluster_val+0x220>
8000471a:	f0 c9 ff fc 	sub	r9,r8,-4
8000471e:	f0 cc ff f9 	sub	r12,r8,-7
80004722:	b8 82       	st.b	r12[0x0],r2
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
80004724:	2f a8       	sub	r8,-6
80004726:	b0 8b       	st.b	r8[0x0],r11

      if ( Is_fat32 )
80004728:	4b fa       	lddpc	r10,80004824 <fat_cluster_val+0x21c>
8000472a:	15 8a       	ld.ub	r10,r10[0x0]
8000472c:	30 3b       	mov	r11,3
8000472e:	f6 0a 18 00 	cp.b	r10,r11
80004732:	c0 61       	brne	8000473e <fat_cluster_val+0x136>
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
80004734:	b2 91       	st.b	r9[0x1],r1
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
80004736:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
8000473a:	b2 80       	st.b	r9[0x0],r0
8000473c:	da 3a       	popm	r0-r7,pc,r12=1
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
8000473e:	30 0b       	mov	r11,0
80004740:	b2 9b       	st.b	r9[0x1],r11
         LSB3( fs_g_cluster.u32_val ) = 0;
80004742:	b2 8b       	st.b	r9[0x0],r11

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
80004744:	30 19       	mov	r9,1
80004746:	f2 0a 18 00 	cp.b	r10,r9
8000474a:	c0 20       	breq	8000474e <fat_cluster_val+0x146>
8000474c:	da 3a       	popm	r0-r7,pc,r12=1
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
8000474e:	4b 79       	lddpc	r9,80004828 <fat_cluster_val+0x220>
80004750:	13 b9       	ld.ub	r9,r9[0x3]
80004752:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004756:	c0 c0       	breq	8000476e <fat_cluster_val+0x166>
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
80004758:	19 8b       	ld.ub	r11,r12[0x0]
8000475a:	a5 8b       	lsr	r11,0x4
8000475c:	11 89       	ld.ub	r9,r8[0x0]
8000475e:	f2 0a 15 04 	lsl	r10,r9,0x4
80004762:	f6 0a 00 0a 	add	r10,r11,r10
80004766:	b8 8a       	st.b	r12[0x0],r10
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
80004768:	a5 89       	lsr	r9,0x4
8000476a:	b0 89       	st.b	r8[0x0],r9
8000476c:	da 3a       	popm	r0-r7,pc,r12=1
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
8000476e:	11 89       	ld.ub	r9,r8[0x0]
80004770:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80004774:	b0 89       	st.b	r8[0x0],r9
80004776:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
80004778:	4a b8       	lddpc	r8,80004824 <fat_cluster_val+0x21c>
8000477a:	11 88       	ld.ub	r8,r8[0x0]
8000477c:	30 19       	mov	r9,1
8000477e:	f2 08 18 00 	cp.b	r8,r9
80004782:	c3 a1       	brne	800047f6 <fat_cluster_val+0x1ee>
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80004784:	4a 98       	lddpc	r8,80004828 <fat_cluster_val+0x220>
80004786:	11 b8       	ld.ub	r8,r8[0x3]
80004788:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000478c:	c1 10       	breq	800047ae <fat_cluster_val+0x1a6>
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000478e:	eb d2 c0 04 	bfextu	r5,r2,0x0,0x4
80004792:	4a 68       	lddpc	r8,80004828 <fat_cluster_val+0x220>
80004794:	2f c8       	sub	r8,-4
80004796:	11 b9       	ld.ub	r9,r8[0x3]
80004798:	f2 0a 15 04 	lsl	r10,r9,0x4
8000479c:	14 05       	add	r5,r10
8000479e:	5c 55       	castu.b	r5
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
800047a0:	a5 89       	lsr	r9,0x4
800047a2:	11 a8       	ld.ub	r8,r8[0x2]
800047a4:	a5 68       	lsl	r8,0x4
800047a6:	f2 08 00 0a 	add	r10,r9,r8
800047aa:	5c 5a       	castu.b	r10
800047ac:	c0 c8       	rjmp	800047c4 <fat_cluster_val+0x1bc>
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
800047ae:	49 f8       	lddpc	r8,80004828 <fat_cluster_val+0x220>
800047b0:	2f c8       	sub	r8,-4
800047b2:	11 b5       	ld.ub	r5,r8[0x3]
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
800047b4:	16 9a       	mov	r10,r11
800047b6:	e2 1a 00 f0 	andl	r10,0xf0,COH
800047ba:	11 a8       	ld.ub	r8,r8[0x2]
800047bc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800047c0:	10 0a       	add	r10,r8
800047c2:	5c 5a       	castu.b	r10
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
800047c4:	49 a8       	lddpc	r8,8000482c <fat_cluster_val+0x224>
800047c6:	90 09       	ld.sh	r9,r8[0x0]
800047c8:	e0 68 01 ff 	mov	r8,511
800047cc:	f0 09 19 00 	cp.h	r9,r8
800047d0:	c2 31       	brne	80004816 <fat_cluster_val+0x20e>
         {
            fs_g_sector[0] = u8_data2;
800047d2:	49 d8       	lddpc	r8,80004844 <fat_cluster_val+0x23c>
800047d4:	b0 8a       	st.b	r8[0x0],r10
            fat_cache_mark_sector_as_dirty();
800047d6:	f0 1f 00 1d 	mcall	80004848 <fat_cluster_val+0x240>
            // Go to previous sector
            fs_gu32_addrsector--;
800047da:	49 98       	lddpc	r8,8000483c <fat_cluster_val+0x234>
800047dc:	70 09       	ld.w	r9,r8[0x0]
800047de:	20 19       	sub	r9,1
800047e0:	91 09       	st.w	r8[0x0],r9
            if( !fat_cache_read_sector( true ))
800047e2:	30 1c       	mov	r12,1
800047e4:	f0 1f 00 17 	mcall	80004840 <fat_cluster_val+0x238>
800047e8:	c1 c0       	breq	80004820 <fat_cluster_val+0x218>
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
800047ea:	49 78       	lddpc	r8,80004844 <fat_cluster_val+0x23c>
800047ec:	f1 65 01 ff 	st.b	r8[511],r5
            fat_cache_mark_sector_as_dirty();
800047f0:	f0 1f 00 16 	mcall	80004848 <fat_cluster_val+0x240>
800047f4:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
800047f6:	48 d9       	lddpc	r9,80004828 <fat_cluster_val+0x220>
800047f8:	2f c9       	sub	r9,-4
800047fa:	13 b5       	ld.ub	r5,r9[0x3]
         u8_data2 = LSB1( fs_g_cluster.u32_val );
800047fc:	13 aa       	ld.ub	r10,r9[0x2]
         if ( Is_fat32 )
800047fe:	30 3b       	mov	r11,3
80004800:	f6 08 18 00 	cp.b	r8,r11
80004804:	c0 91       	brne	80004816 <fat_cluster_val+0x20e>
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
80004806:	13 98       	ld.ub	r8,r9[0x1]
80004808:	a8 88       	st.b	r4[0x0],r8
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
8000480a:	e0 10 ff f0 	andl	r0,0xfff0
8000480e:	13 88       	ld.ub	r8,r9[0x0]
80004810:	f0 00 00 00 	add	r0,r8,r0
80004814:	a6 80       	st.b	r3[0x0],r0
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
80004816:	ac 85       	st.b	r6[0x0],r5
      u8_ptr_cluster[1] = u8_data2;
80004818:	ae 8a       	st.b	r7[0x0],r10
      fat_cache_mark_sector_as_dirty();
8000481a:	f0 1f 00 0c 	mcall	80004848 <fat_cluster_val+0x240>
8000481e:	da 3a       	popm	r0-r7,pc,r12=1
80004820:	d8 3a       	popm	r0-r7,pc,r12=0
80004822:	00 00       	add	r0,r0
80004824:	00 00       	add	r0,r0
80004826:	0c fc       	st.b	--r6,r12
80004828:	00 00       	add	r0,r0
8000482a:	0d 50       	ld.sh	r0,--r6
8000482c:	00 00       	add	r0,r0
8000482e:	0a 80       	andn	r0,r5
80004830:	00 00       	add	r0,r0
80004832:	0c e4       	st.h	--r6,r4
80004834:	00 00       	add	r0,r0
80004836:	0a ac       	st.w	r5++,r12
80004838:	00 00       	add	r0,r0
8000483a:	0c b0       	st.h	r6++,r0
8000483c:	00 00       	add	r0,r0
8000483e:	0a 6c       	and	r12,r5
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	44 f4       	lddsp	r4,sp[0x13c]
80004844:	00 00       	add	r0,r0
80004846:	0a b0       	st.h	r5++,r0
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	42 d4       	lddsp	r4,sp[0xb4]

8000484c <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
8000484c:	d4 31       	pushm	r0-r7,lr
8000484e:	20 2d       	sub	sp,8
80004850:	18 93       	mov	r3,r12
80004852:	16 97       	mov	r7,r11
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
80004854:	30 89       	mov	r9,8
80004856:	fe f8 02 8e 	ld.w	r8,pc[654]
8000485a:	b0 89       	st.b	r8[0x0],r9

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
8000485c:	30 38       	mov	r8,3
8000485e:	f0 0c 18 00 	cp.b	r12,r8
80004862:	5f 0a       	sreq	r10
80004864:	50 0a       	stdsp	sp[0x0],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
80004866:	fe f9 02 82 	ld.w	r9,pc[642]
8000486a:	13 89       	ld.ub	r9,r9[0x0]
8000486c:	f0 09 18 00 	cp.b	r9,r8
80004870:	5f 08       	sreq	r8
80004872:	f5 e8 00 08 	and	r8,r10,r8
80004876:	c0 60       	breq	80004882 <fat_cluster_list+0x36>
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80004878:	3f fc       	mov	r12,-1
8000487a:	f0 1f 00 9d 	mcall	80004aec <fat_cluster_list+0x2a0>
8000487e:	e0 80 01 2f 	breq	80004adc <fat_cluster_list+0x290>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
80004882:	fe f8 02 6e 	ld.w	r8,pc[622]
80004886:	70 08       	ld.w	r8,r8[0x0]
80004888:	58 08       	cp.w	r8,0
8000488a:	c3 b1       	brne	80004900 <fat_cluster_list+0xb4>
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
8000488c:	40 09       	lddsp	r9,sp[0x0]
8000488e:	58 09       	cp.w	r9,0
80004890:	e0 81 01 26 	brne	80004adc <fat_cluster_list+0x290>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
80004894:	fe f8 02 54 	ld.w	r8,pc[596]
80004898:	11 88       	ld.ub	r8,r8[0x0]
8000489a:	f0 ca 00 01 	sub	r10,r8,1
8000489e:	30 19       	mov	r9,1
800048a0:	f2 0a 18 00 	cp.b	r10,r9
800048a4:	e0 8b 00 23 	brhi	800048ea <fat_cluster_list+0x9e>
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
800048a8:	fe f8 02 48 	ld.w	r8,pc[584]
800048ac:	70 18       	ld.w	r8,r8[0x4]
800048ae:	fe f9 02 46 	ld.w	r9,pc[582]
800048b2:	f3 19 00 1a 	ld.uh	r9,r9[26]
800048b6:	12 38       	cp.w	r8,r9
800048b8:	c1 32       	brcc	800048de <fat_cluster_list+0x92>
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
800048ba:	fe f9 02 36 	ld.w	r9,pc[566]
800048be:	fe fa 02 36 	ld.w	r10,pc[566]
800048c2:	74 4b       	ld.w	r11,r10[0x10]
800048c4:	16 08       	add	r8,r11
800048c6:	f5 1b 00 18 	ld.uh	r11,r10[24]
800048ca:	16 08       	add	r8,r11
800048cc:	93 08       	st.w	r9[0x0],r8
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
800048ce:	f5 1a 00 1a 	ld.uh	r10,r10[26]
800048d2:	72 18       	ld.w	r8,r9[0x4]
800048d4:	f4 08 01 08 	sub	r8,r10,r8
800048d8:	93 18       	st.w	r9[0x4],r8
800048da:	30 1c       	mov	r12,1
            return true;
800048dc:	c0 19       	rjmp	80004ade <fat_cluster_list+0x292>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
800048de:	31 a9       	mov	r9,26
800048e0:	fe f8 02 04 	ld.w	r8,pc[516]
800048e4:	b0 89       	st.b	r8[0x0],r9
800048e6:	30 0c       	mov	r12,0
            return false;        // Position outside the root area
800048e8:	cf b8       	rjmp	80004ade <fat_cluster_list+0x292>
         }
      }
      if ( Is_fat32 )
800048ea:	30 39       	mov	r9,3
800048ec:	f2 08 18 00 	cp.b	r8,r9
800048f0:	c0 a1       	brne	80004904 <fat_cluster_list+0xb8>
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
800048f2:	fe f8 02 02 	ld.w	r8,pc[514]
800048f6:	70 69       	ld.w	r9,r8[0x18]
800048f8:	fe f8 02 00 	ld.w	r8,pc[512]
800048fc:	91 09       	st.w	r8[0x0],r9
800048fe:	c0 38       	rjmp	80004904 <fat_cluster_list+0xb8>
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
80004900:	4f e9       	lddpc	r9,80004af8 <fat_cluster_list+0x2ac>
80004902:	93 08       	st.w	r9[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
80004904:	30 38       	mov	r8,3
80004906:	f0 03 18 00 	cp.b	r3,r8
8000490a:	c0 70       	breq	80004918 <fat_cluster_list+0xcc>
   {
      if( fat_cache_clusterlist_update_read( b_for_file ) )
8000490c:	0e 9c       	mov	r12,r7
8000490e:	f0 1f 00 7c 	mcall	80004afc <fat_cluster_list+0x2b0>
80004912:	c0 70       	breq	80004920 <fat_cluster_list+0xd4>
80004914:	30 1c       	mov	r12,1
80004916:	ce 48       	rjmp	80004ade <fat_cluster_list+0x292>
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
80004918:	f0 1f 00 7a 	mcall	80004b00 <fat_cluster_list+0x2b4>
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
8000491c:	f0 1f 00 7a 	mcall	80004b04 <fat_cluster_list+0x2b8>
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
80004920:	4f 40       	lddpc	r0,80004af0 <fat_cluster_list+0x2a4>
80004922:	3f f8       	mov	r8,-1
80004924:	a0 88       	st.b	r0[0x0],r8

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80004926:	00 96       	mov	r6,r0
80004928:	4f 35       	lddpc	r5,80004af4 <fat_cluster_list+0x2a8>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000492a:	4f 47       	lddpc	r7,80004af8 <fat_cluster_list+0x2ac>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
8000492c:	30 21       	mov	r1,2
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
8000492e:	e0 c8 ff f9 	sub	r8,r0,-7
80004932:	50 18       	stdsp	sp[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80004934:	30 12       	mov	r2,1
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80004936:	6c 19       	ld.w	r9,r6[0x4]
80004938:	0b 98       	ld.ub	r8,r5[0x1]
8000493a:	10 39       	cp.w	r9,r8
8000493c:	c4 32       	brcc	800049c2 <fat_cluster_list+0x176>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000493e:	6a 4a       	ld.w	r10,r5[0x10]
80004940:	14 09       	add	r9,r10
80004942:	6a 5a       	ld.w	r10,r5[0x14]
80004944:	14 09       	add	r9,r10
80004946:	6e 0a       	ld.w	r10,r7[0x0]
80004948:	20 2a       	sub	r10,2
8000494a:	f4 08 02 48 	mul	r8,r10,r8
8000494e:	f2 08 00 08 	add	r8,r9,r8
80004952:	8d 08       	st.w	r6[0x0],r8
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
80004954:	e2 03 18 00 	cp.b	r3,r1
80004958:	c0 d1       	brne	80004972 <fat_cluster_list+0x126>
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
8000495a:	4e 67       	lddpc	r7,80004af0 <fat_cluster_list+0x2a4>
8000495c:	4e 68       	lddpc	r8,80004af4 <fat_cluster_list+0x2a8>
8000495e:	11 99       	ld.ub	r9,r8[0x1]
80004960:	6e 18       	ld.w	r8,r7[0x4]
80004962:	f2 08 01 08 	sub	r8,r9,r8
80004966:	8f 18       	st.w	r7[0x4],r8
            fat_cache_clusterlist_update_finish();
80004968:	f0 1f 00 68 	mcall	80004b08 <fat_cluster_list+0x2bc>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
8000496c:	30 1c       	mov	r12,1
8000496e:	8f 1c       	st.w	r7[0x4],r12
            return true;
80004970:	cb 78       	rjmp	80004ade <fat_cluster_list+0x292>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
80004972:	0b 99       	ld.ub	r9,r5[0x1]
80004974:	40 1a       	lddsp	r10,sp[0x4]
80004976:	15 88       	ld.ub	r8,r10[0x0]
80004978:	f2 08 01 08 	sub	r8,r9,r8
8000497c:	8d 18       	st.w	r6[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
8000497e:	e4 03 18 00 	cp.b	r3,r2
80004982:	c2 01       	brne	800049c2 <fat_cluster_list+0x176>
80004984:	4d 99       	lddpc	r9,80004ae8 <fat_cluster_list+0x29c>
80004986:	13 88       	ld.ub	r8,r9[0x0]
80004988:	e4 08 18 00 	cp.b	r8,r2
8000498c:	c1 b0       	breq	800049c2 <fat_cluster_list+0x176>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
8000498e:	6e 04       	ld.w	r4,r7[0x0]
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80004990:	30 0c       	mov	r12,0
80004992:	f0 1f 00 5f 	mcall	80004b0c <fat_cluster_list+0x2c0>
80004996:	e0 80 00 a3 	breq	80004adc <fat_cluster_list+0x290>
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
8000499a:	6e 09       	ld.w	r9,r7[0x0]
8000499c:	f2 c8 ff ff 	sub	r8,r9,-1
800049a0:	8f 08       	st.w	r7[0x0],r8
800049a2:	6e 1a       	ld.w	r10,r7[0x4]
800049a4:	14 38       	cp.w	r8,r10
800049a6:	c0 a0       	breq	800049ba <fat_cluster_list+0x16e>
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
800049a8:	8f 09       	st.w	r7[0x0],r9
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
800049aa:	08 19       	sub	r9,r4
800049ac:	0b 98       	ld.ub	r8,r5[0x1]
800049ae:	b1 39       	mul	r9,r8
800049b0:	6c 18       	ld.w	r8,r6[0x4]
800049b2:	f2 08 00 08 	add	r8,r9,r8
800049b6:	8d 18       	st.w	r6[0x4],r8
                  break;
800049b8:	c0 58       	rjmp	800049c2 <fat_cluster_list+0x176>
               }
               if( !fat_cluster_readnext() )
800049ba:	f0 1f 00 56 	mcall	80004b10 <fat_cluster_list+0x2c4>
800049be:	ce e1       	brne	8000499a <fat_cluster_list+0x14e>
800049c0:	c8 e8       	rjmp	80004adc <fat_cluster_list+0x290>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
800049c2:	30 0c       	mov	r12,0
800049c4:	f0 1f 00 52 	mcall	80004b0c <fat_cluster_list+0x2c0>
800049c8:	e0 80 00 8a 	breq	80004adc <fat_cluster_list+0x290>
         return false;

      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
800049cc:	f0 1f 00 52 	mcall	80004b14 <fat_cluster_list+0x2c8>
800049d0:	18 94       	mov	r4,r12
      if (FS_CLUS_BAD == u8_cluster_status)
800049d2:	e4 0c 18 00 	cp.b	r12,r2
800049d6:	e0 80 00 83 	breq	80004adc <fat_cluster_list+0x290>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
800049da:	01 89       	ld.ub	r9,r0[0x0]
800049dc:	3f f8       	mov	r8,-1
800049de:	f0 09 18 00 	cp.b	r9,r8
800049e2:	c4 61       	brne	80004a6e <fat_cluster_list+0x222>
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
800049e4:	e2 0c 18 00 	cp.b	r12,r1
800049e8:	c2 b1       	brne	80004a3e <fat_cluster_list+0x1f2>
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining
800049ea:	4c 28       	lddpc	r8,80004af0 <fat_cluster_list+0x2a4>
800049ec:	70 17       	ld.w	r7,r8[0x4]

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
800049ee:	4c b9       	lddpc	r9,80004b18 <fat_cluster_list+0x2cc>
800049f0:	13 89       	ld.ub	r9,r9[0x0]
800049f2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800049f6:	4c aa       	lddpc	r10,80004b1c <fat_cluster_list+0x2d0>
800049f8:	f4 09 00 29 	add	r9,r10,r9<<0x2
800049fc:	72 2a       	ld.w	r10,r9[0x8]
800049fe:	0e 1a       	sub	r10,r7
80004a00:	93 2a       	st.w	r9[0x8],r10
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80004a02:	4b d9       	lddpc	r9,80004af4 <fat_cluster_list+0x2a8>
80004a04:	72 5b       	ld.w	r11,r9[0x14]
80004a06:	72 4a       	ld.w	r10,r9[0x10]
80004a08:	14 0b       	add	r11,r10
80004a0a:	13 99       	ld.ub	r9,r9[0x1]
80004a0c:	4b ba       	lddpc	r10,80004af8 <fat_cluster_list+0x2ac>
80004a0e:	74 0a       	ld.w	r10,r10[0x0]
80004a10:	20 2a       	sub	r10,2
80004a12:	f2 0a 02 4a 	mul	r10,r9,r10
80004a16:	f6 0a 00 0a 	add	r10,r11,r10
80004a1a:	91 0a       	st.w	r8[0x0],r10
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
80004a1c:	91 19       	st.w	r8[0x4],r9
            if (FS_CLUST_ACT_CLR != opt_action)
80004a1e:	30 38       	mov	r8,3
80004a20:	f0 03 18 00 	cp.b	r3,r8
80004a24:	c0 30       	breq	80004a2a <fat_cluster_list+0x1de>
               fat_cache_clusterlist_update_finish();
80004a26:	f0 1f 00 39 	mcall	80004b08 <fat_cluster_list+0x2bc>

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
80004a2a:	4b 28       	lddpc	r8,80004af0 <fat_cluster_list+0x2a4>
80004a2c:	4b 39       	lddpc	r9,80004af8 <fat_cluster_list+0x2ac>
80004a2e:	72 09       	ld.w	r9,r9[0x0]
80004a30:	91 09       	st.w	r8[0x0],r9
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
80004a32:	91 17       	st.w	r8[0x4],r7
            fs_g_status = FS_ERR_OUT_LIST;
80004a34:	31 a9       	mov	r9,26
80004a36:	4a c8       	lddpc	r8,80004ae4 <fat_cluster_list+0x298>
80004a38:	b0 89       	st.b	r8[0x0],r9
80004a3a:	30 0c       	mov	r12,0
            return false;
80004a3c:	c5 18       	rjmp	80004ade <fat_cluster_list+0x292>
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
80004a3e:	0b 98       	ld.ub	r8,r5[0x1]
80004a40:	6c 19       	ld.w	r9,r6[0x4]
80004a42:	f2 08 01 08 	sub	r8,r9,r8
80004a46:	8d 18       	st.w	r6[0x4],r8
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80004a48:	40 0a       	lddsp	r10,sp[0x0]
80004a4a:	58 0a       	cp.w	r10,0
80004a4c:	c4 50       	breq	80004ad6 <fat_cluster_list+0x28a>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
80004a4e:	58 08       	cp.w	r8,0
80004a50:	c4 31       	brne	80004ad6 <fat_cluster_list+0x28a>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
80004a52:	6e 18       	ld.w	r8,r7[0x4]
80004a54:	8d 08       	st.w	r6[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
80004a56:	e0 68 ff ff 	mov	r8,65535
80004a5a:	ea 18 0f ff 	orh	r8,0xfff
80004a5e:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80004a60:	30 1c       	mov	r12,1
80004a62:	f0 1f 00 2b 	mcall	80004b0c <fat_cluster_list+0x2c0>
80004a66:	c3 b0       	breq	80004adc <fat_cluster_list+0x290>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
80004a68:	6c 08       	ld.w	r8,r6[0x0]
80004a6a:	8f 18       	st.w	r7[0x4],r8
80004a6c:	c3 58       	rjmp	80004ad6 <fat_cluster_list+0x28a>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
80004a6e:	e4 03 18 00 	cp.b	r3,r2
80004a72:	c0 a1       	brne	80004a86 <fat_cluster_list+0x23a>
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
80004a74:	6e 09       	ld.w	r9,r7[0x0]
80004a76:	2f f9       	sub	r9,-1
80004a78:	6e 18       	ld.w	r8,r7[0x4]
80004a7a:	10 39       	cp.w	r9,r8
80004a7c:	c1 b0       	breq	80004ab2 <fat_cluster_list+0x266>
            {
               // The cluster is not a continue cluster or a invalid cluster
               fat_cache_clusterlist_update_finish();
80004a7e:	f0 1f 00 23 	mcall	80004b08 <fat_cluster_list+0x2bc>
80004a82:	30 1c       	mov	r12,1
               return true;                              // End of segment
80004a84:	c2 d8       	rjmp	80004ade <fat_cluster_list+0x292>
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80004a86:	40 09       	lddsp	r9,sp[0x0]
80004a88:	58 09       	cp.w	r9,0
80004a8a:	c1 40       	breq	80004ab2 <fat_cluster_list+0x266>
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
80004a8c:	6e 18       	ld.w	r8,r7[0x4]
80004a8e:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
80004a90:	30 08       	mov	r8,0
80004a92:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
80004a94:	0b 98       	ld.ub	r8,r5[0x1]
80004a96:	6c 19       	ld.w	r9,r6[0x4]
80004a98:	10 39       	cp.w	r9,r8
80004a9a:	c0 62       	brcc	80004aa6 <fat_cluster_list+0x25a>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
80004a9c:	e0 68 ff ff 	mov	r8,65535
80004aa0:	ea 18 0f ff 	orh	r8,0xfff
80004aa4:	8f 18       	st.w	r7[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80004aa6:	30 1c       	mov	r12,1
80004aa8:	f0 1f 00 19 	mcall	80004b0c <fat_cluster_list+0x2c0>
80004aac:	c1 80       	breq	80004adc <fat_cluster_list+0x290>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
80004aae:	6c 08       	ld.w	r8,r6[0x0]
80004ab0:	8f 18       	st.w	r7[0x4],r8
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
80004ab2:	e2 04 18 00 	cp.b	r4,r1
80004ab6:	c0 b1       	brne	80004acc <fat_cluster_list+0x280>
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
80004ab8:	40 0a       	lddsp	r10,sp[0x0]
80004aba:	58 0a       	cp.w	r10,0
80004abc:	c0 40       	breq	80004ac4 <fat_cluster_list+0x278>
            {
               return fat_update_fat2();
80004abe:	f0 1f 00 19 	mcall	80004b20 <fat_cluster_list+0x2d4>
80004ac2:	c0 e8       	rjmp	80004ade <fat_cluster_list+0x292>
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
80004ac4:	f0 1f 00 11 	mcall	80004b08 <fat_cluster_list+0x2bc>
80004ac8:	30 1c       	mov	r12,1
            return true; // End of segment
80004aca:	c0 a8       	rjmp	80004ade <fat_cluster_list+0x292>
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
80004acc:	0b 99       	ld.ub	r9,r5[0x1]
80004ace:	6c 18       	ld.w	r8,r6[0x4]
80004ad0:	f2 08 00 08 	add	r8,r9,r8
80004ad4:	8d 18       	st.w	r6[0x4],r8
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
80004ad6:	6e 18       	ld.w	r8,r7[0x4]
80004ad8:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
80004ada:	c2 eb       	rjmp	80004936 <fat_cluster_list+0xea>
80004adc:	30 0c       	mov	r12,0
}
80004ade:	2f ed       	sub	sp,-8
80004ae0:	d8 32       	popm	r0-r7,pc
80004ae2:	00 00       	add	r0,r0
80004ae4:	00 00       	add	r0,r0
80004ae6:	0d 00       	ld.w	r0,r6++
80004ae8:	00 00       	add	r0,r0
80004aea:	0c fc       	st.b	--r6,r12
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	4e b4       	lddpc	r4,80004c98 <fat_check_device+0x14>
80004af0:	00 00       	add	r0,r0
80004af2:	0d 58       	ld.sh	r8,--r6
80004af4:	00 00       	add	r0,r0
80004af6:	0c b0       	st.h	r6++,r0
80004af8:	00 00       	add	r0,r0
80004afa:	0d 50       	ld.sh	r0,--r6
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	3d 24       	mov	r4,-46
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	3b f4       	mov	r4,-65
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	4e 28       	lddpc	r8,80004c8c <fat_check_device+0x8>
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	3c cc       	mov	r12,-52
80004b0c:	80 00       	ld.sh	r0,r0[0x0]
80004b0e:	46 08       	lddsp	r8,sp[0x180]
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	45 74       	lddsp	r4,sp[0x15c]
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	3b 94       	mov	r4,-71
80004b18:	00 00       	add	r0,r0
80004b1a:	0d 02       	ld.w	r2,r6++
80004b1c:	00 00       	add	r0,r0
80004b1e:	0a 84       	andn	r4,r5
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	4e 40       	lddpc	r0,80004cb0 <fat_check_device+0x2c>

80004b24 <fat_read_dir>:
//!   fs_g_nav.u32_cluster_sel_dir           First cluster of current directory
//!   fs_g_nav_fast.u16_entry_pos_sel_file   Position in directory (unit entry)
//! @endverbatim
//!
bool  fat_read_dir( void )
{
80004b24:	eb cd 40 80 	pushm	r7,lr
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);
80004b28:	49 98       	lddpc	r8,80004b8c <fat_read_dir+0x68>
80004b2a:	90 97       	ld.uh	r7,r8[0x2]
80004b2c:	a5 87       	lsr	r7,0x4

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80004b2e:	49 98       	lddpc	r8,80004b90 <fat_read_dir+0x6c>
80004b30:	11 89       	ld.ub	r9,r8[0x0]
80004b32:	49 98       	lddpc	r8,80004b94 <fat_read_dir+0x70>
80004b34:	11 88       	ld.ub	r8,r8[0x0]
80004b36:	f0 09 18 00 	cp.b	r9,r8
80004b3a:	c0 d1       	brne	80004b54 <fat_read_dir+0x30>
80004b3c:	49 58       	lddpc	r8,80004b90 <fat_read_dir+0x6c>
80004b3e:	70 39       	ld.w	r9,r8[0xc]
80004b40:	49 58       	lddpc	r8,80004b94 <fat_read_dir+0x70>
80004b42:	70 88       	ld.w	r8,r8[0x20]
80004b44:	10 39       	cp.w	r9,r8
80004b46:	c0 71       	brne	80004b54 <fat_read_dir+0x30>
80004b48:	49 28       	lddpc	r8,80004b90 <fat_read_dir+0x6c>
80004b4a:	70 48       	ld.w	r8,r8[0x10]
80004b4c:	0e 38       	cp.w	r8,r7
80004b4e:	c0 31       	brne	80004b54 <fat_read_dir+0x30>
80004b50:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
         return true;      // The internal cache contains the sector asked
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
80004b54:	49 18       	lddpc	r8,80004b98 <fat_read_dir+0x74>
80004b56:	49 09       	lddpc	r9,80004b94 <fat_read_dir+0x70>
80004b58:	72 89       	ld.w	r9,r9[0x20]
80004b5a:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
80004b5c:	91 17       	st.w	r8[0x4],r7
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
80004b5e:	30 0b       	mov	r11,0
80004b60:	30 2c       	mov	r12,2
80004b62:	f0 1f 00 0f 	mcall	80004b9c <fat_read_dir+0x78>
80004b66:	c1 00       	breq	80004b86 <fat_read_dir+0x62>
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
80004b68:	48 c8       	lddpc	r8,80004b98 <fat_read_dir+0x74>
80004b6a:	70 09       	ld.w	r9,r8[0x0]
80004b6c:	48 d8       	lddpc	r8,80004ba0 <fat_read_dir+0x7c>
80004b6e:	91 09       	st.w	r8[0x0],r9
      if( fat_cache_read_sector( true ) )
80004b70:	30 1c       	mov	r12,1
80004b72:	f0 1f 00 0d 	mcall	80004ba4 <fat_read_dir+0x80>
80004b76:	c0 80       	breq	80004b86 <fat_read_dir+0x62>
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
80004b78:	48 68       	lddpc	r8,80004b90 <fat_read_dir+0x6c>
80004b7a:	48 79       	lddpc	r9,80004b94 <fat_read_dir+0x70>
80004b7c:	72 89       	ld.w	r9,r9[0x20]
80004b7e:	91 39       	st.w	r8[0xc],r9
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
80004b80:	91 47       	st.w	r8[0x10],r7
80004b82:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
         return true;
80004b86:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80004b8a:	00 00       	add	r0,r0
80004b8c:	00 00       	add	r0,r0
80004b8e:	0c fc       	st.b	--r6,r12
80004b90:	00 00       	add	r0,r0
80004b92:	0d 38       	ld.ub	r8,r6++
80004b94:	00 00       	add	r0,r0
80004b96:	0c b0       	st.h	r6++,r0
80004b98:	00 00       	add	r0,r0
80004b9a:	0d 58       	ld.sh	r8,--r6
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	48 4c       	lddpc	r12,80004bac <fat_read_file+0x4>
80004ba0:	00 00       	add	r0,r0
80004ba2:	0a 6c       	and	r12,r5
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	44 f4       	lddsp	r4,sp[0x13c]

80004ba8 <fat_read_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
{
80004ba8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bac:	18 97       	mov	r7,r12
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;
80004bae:	4a e8       	lddpc	r8,80004c64 <fat_read_file+0xbc>
80004bb0:	70 38       	ld.w	r8,r8[0xc]
80004bb2:	f0 06 16 09 	lsr	r6,r8,0x9

   if(FS_CLUST_ACT_ONE  == mode)
80004bb6:	30 29       	mov	r9,2
80004bb8:	f2 0c 18 00 	cp.b	r12,r9
80004bbc:	c1 31       	brne	80004be2 <fat_read_file+0x3a>
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80004bbe:	4a b8       	lddpc	r8,80004c68 <fat_read_file+0xc0>
80004bc0:	11 89       	ld.ub	r9,r8[0x0]
80004bc2:	4a b8       	lddpc	r8,80004c6c <fat_read_file+0xc4>
80004bc4:	11 88       	ld.ub	r8,r8[0x0]
80004bc6:	f0 09 18 00 	cp.b	r9,r8
80004bca:	c1 91       	brne	80004bfc <fat_read_file+0x54>
80004bcc:	4a 78       	lddpc	r8,80004c68 <fat_read_file+0xc0>
80004bce:	70 39       	ld.w	r9,r8[0xc]
80004bd0:	4a 58       	lddpc	r8,80004c64 <fat_read_file+0xbc>
80004bd2:	70 18       	ld.w	r8,r8[0x4]
80004bd4:	10 39       	cp.w	r9,r8
80004bd6:	c1 31       	brne	80004bfc <fat_read_file+0x54>
80004bd8:	4a 48       	lddpc	r8,80004c68 <fat_read_file+0xc0>
80004bda:	70 48       	ld.w	r8,r8[0x10]
80004bdc:	0c 38       	cp.w	r8,r6
80004bde:	c0 f1       	brne	80004bfc <fat_read_file+0x54>
80004be0:	c3 38       	rjmp	80004c46 <fat_read_file+0x9e>
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
80004be2:	30 39       	mov	r9,3
80004be4:	f2 0c 18 00 	cp.b	r12,r9
80004be8:	c3 31       	brne	80004c4e <fat_read_file+0xa6>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
80004bea:	49 f9       	lddpc	r9,80004c64 <fat_read_file+0xbc>
80004bec:	72 19       	ld.w	r9,r9[0x4]
80004bee:	58 09       	cp.w	r9,0
80004bf0:	c2 b0       	breq	80004c46 <fat_read_file+0x9e>
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
80004bf2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004bf6:	c2 c0       	breq	80004c4e <fat_read_file+0xa6>
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
80004bf8:	2f f6       	sub	r6,-1
80004bfa:	c2 a8       	rjmp	80004c4e <fat_read_file+0xa6>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80004bfc:	49 d8       	lddpc	r8,80004c70 <fat_read_file+0xc8>
80004bfe:	49 a9       	lddpc	r9,80004c64 <fat_read_file+0xbc>
80004c00:	72 19       	ld.w	r9,r9[0x4]
80004c02:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80004c04:	91 16       	st.w	r8[0x4],r6
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
80004c06:	30 1b       	mov	r11,1
80004c08:	16 9c       	mov	r12,r11
80004c0a:	f0 1f 00 1b 	mcall	80004c74 <fat_read_file+0xcc>
80004c0e:	c1 e0       	breq	80004c4a <fat_read_file+0xa2>
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
80004c10:	49 88       	lddpc	r8,80004c70 <fat_read_file+0xc8>
80004c12:	70 09       	ld.w	r9,r8[0x0]
80004c14:	49 98       	lddpc	r8,80004c78 <fat_read_file+0xd0>
80004c16:	91 09       	st.w	r8[0x0],r9
         if( fat_cache_read_sector( true ) )
80004c18:	30 1c       	mov	r12,1
80004c1a:	f0 1f 00 19 	mcall	80004c7c <fat_read_file+0xd4>
80004c1e:	c1 60       	breq	80004c4a <fat_read_file+0xa2>
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
80004c20:	49 28       	lddpc	r8,80004c68 <fat_read_file+0xc0>
80004c22:	49 19       	lddpc	r9,80004c64 <fat_read_file+0xbc>
80004c24:	72 19       	ld.w	r9,r9[0x4]
80004c26:	91 39       	st.w	r8[0xc],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
80004c28:	91 46       	st.w	r8[0x10],r6
80004c2a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
80004c2e:	30 38       	mov	r8,3
80004c30:	f0 07 18 00 	cp.b	r7,r8
80004c34:	c0 b1       	brne	80004c4a <fat_read_file+0xa2>
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
80004c36:	49 38       	lddpc	r8,80004c80 <fat_read_file+0xd8>
80004c38:	11 89       	ld.ub	r9,r8[0x0]
80004c3a:	31 a8       	mov	r8,26
80004c3c:	f0 09 18 00 	cp.b	r9,r8
80004c40:	5f 0c       	sreq	r12
80004c42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c46:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004c4a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80004c4e:	48 98       	lddpc	r8,80004c70 <fat_read_file+0xc8>
80004c50:	48 59       	lddpc	r9,80004c64 <fat_read_file+0xbc>
80004c52:	72 19       	ld.w	r9,r9[0x4]
80004c54:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80004c56:	91 16       	st.w	r8[0x4],r6
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
80004c58:	30 1b       	mov	r11,1
80004c5a:	0e 9c       	mov	r12,r7
80004c5c:	f0 1f 00 06 	mcall	80004c74 <fat_read_file+0xcc>
80004c60:	ce 70       	breq	80004c2e <fat_read_file+0x86>
80004c62:	cf 2b       	rjmp	80004c46 <fat_read_file+0x9e>
80004c64:	00 00       	add	r0,r0
80004c66:	0a 70       	tst	r0,r5
80004c68:	00 00       	add	r0,r0
80004c6a:	0d 38       	ld.ub	r8,r6++
80004c6c:	00 00       	add	r0,r0
80004c6e:	0c b0       	st.h	r6++,r0
80004c70:	00 00       	add	r0,r0
80004c72:	0d 58       	ld.sh	r8,--r6
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	48 4c       	lddpc	r12,80004c84 <fat_check_device>
80004c78:	00 00       	add	r0,r0
80004c7a:	0a 6c       	and	r12,r5
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	44 f4       	lddsp	r4,sp[0x13c]
80004c80:	00 00       	add	r0,r0
80004c82:	0d 00       	ld.w	r0,r6++

80004c84 <fat_check_device>:
//! @verbatim
//! This function updates all navigator data when the device state change.
//! @endverbatim
//!
bool  fat_check_device( void )
{
80004c84:	d4 31       	pushm	r0-r7,lr
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
80004c86:	4a 28       	lddpc	r8,80004d0c <fat_check_device+0x88>
80004c88:	11 89       	ld.ub	r9,r8[0x0]
80004c8a:	30 08       	mov	r8,0
80004c8c:	f0 09 18 00 	cp.b	r9,r8
80004c90:	c3 c1       	brne	80004d08 <fat_check_device+0x84>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
80004c92:	4a 08       	lddpc	r8,80004d10 <fat_check_device+0x8c>
80004c94:	11 89       	ld.ub	r9,r8[0x0]
80004c96:	3f f8       	mov	r8,-1
80004c98:	f0 09 18 00 	cp.b	r9,r8
80004c9c:	c0 51       	brne	80004ca6 <fat_check_device+0x22>
   {
      fs_g_status = FS_ERR_HW;
80004c9e:	30 19       	mov	r9,1
80004ca0:	49 d8       	lddpc	r8,80004d14 <fat_check_device+0x90>
80004ca2:	b0 89       	st.b	r8[0x0],r9
80004ca4:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;                                // No device selected
80004ca6:	30 02       	mov	r2,0
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80004ca8:	49 a5       	lddpc	r5,80004d10 <fat_check_device+0x8c>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80004caa:	49 c1       	lddpc	r1,80004d18 <fat_check_device+0x94>
80004cac:	30 06       	mov	r6,0
      Fat_file_close();                            // By default the file is not open
80004cae:	49 c0       	lddpc	r0,80004d1c <fat_check_device+0x98>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004cb0:	49 c4       	lddpc	r4,80004d20 <fat_check_device+0x9c>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
80004cb2:	49 d3       	lddpc	r3,80004d24 <fat_check_device+0xa0>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80004cb4:	0b 8c       	ld.ub	r12,r5[0x0]
80004cb6:	f0 1f 00 1d 	mcall	80004d28 <fat_check_device+0xa4>
80004cba:	18 97       	mov	r7,r12
      if( CTRL_GOOD       == status )
80004cbc:	c2 60       	breq	80004d08 <fat_check_device+0x84>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80004cbe:	a2 86       	st.b	r1[0x0],r6
      Fat_file_close();                            // By default the file is not open
80004cc0:	a0 86       	st.b	r0[0x0],r6
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004cc2:	0b 88       	ld.ub	r8,r5[0x0]
80004cc4:	09 89       	ld.ub	r9,r4[0x0]
80004cc6:	f0 09 18 00 	cp.b	r9,r8
80004cca:	c0 51       	brne	80004cd4 <fat_check_device+0x50>
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
80004ccc:	49 89       	lddpc	r9,80004d2c <fat_check_device+0xa8>
80004cce:	b2 86       	st.b	r9[0x0],r6
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
80004cd0:	49 89       	lddpc	r9,80004d30 <fat_check_device+0xac>
80004cd2:	b2 86       	st.b	r9[0x0],r6
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
80004cd4:	07 89       	ld.ub	r9,r3[0x0]
80004cd6:	f0 09 18 00 	cp.b	r9,r8
80004cda:	c0 31       	brne	80004ce0 <fat_check_device+0x5c>
      {
         fat_cache_reset();
80004cdc:	f0 1f 00 16 	mcall	80004d34 <fat_check_device+0xb0>
      }
      fat_cache_clusterlist_reset();
80004ce0:	f0 1f 00 16 	mcall	80004d38 <fat_check_device+0xb4>

      fs_g_status = FS_ERR_HW;                     // By default HW error
80004ce4:	30 18       	mov	r8,1
80004ce6:	48 c9       	lddpc	r9,80004d14 <fat_check_device+0x90>
80004ce8:	b2 88       	st.b	r9[0x0],r8
      if( CTRL_BUSY == status )
80004cea:	58 37       	cp.w	r7,3
80004cec:	c0 81       	brne	80004cfc <fat_check_device+0x78>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
80004cee:	10 02       	add	r2,r8
80004cf0:	5c 52       	castu.b	r2
80004cf2:	36 48       	mov	r8,100
80004cf4:	f0 02 18 00 	cp.b	r2,r8
80004cf8:	cd e1       	brne	80004cb4 <fat_check_device+0x30>
80004cfa:	c0 88       	rjmp	80004d0a <fat_check_device+0x86>

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
80004cfc:	58 27       	cp.w	r7,2
80004cfe:	c0 61       	brne	80004d0a <fat_check_device+0x86>
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
80004d00:	31 89       	mov	r9,24
80004d02:	48 58       	lddpc	r8,80004d14 <fat_check_device+0x90>
80004d04:	b0 89       	st.b	r8[0x0],r9
80004d06:	d8 3a       	popm	r0-r7,pc,r12=0
80004d08:	da 3a       	popm	r0-r7,pc,r12=1
80004d0a:	d8 3a       	popm	r0-r7,pc,r12=0
80004d0c:	00 00       	add	r0,r0
80004d0e:	0a 82       	andn	r2,r5
80004d10:	00 00       	add	r0,r0
80004d12:	0c b0       	st.h	r6++,r0
80004d14:	00 00       	add	r0,r0
80004d16:	0d 00       	ld.w	r0,r6++
80004d18:	00 00       	add	r0,r0
80004d1a:	0c fc       	st.b	--r6,r12
80004d1c:	00 00       	add	r0,r0
80004d1e:	0a 70       	tst	r0,r5
80004d20:	00 00       	add	r0,r0
80004d22:	0d 04       	ld.w	r4,r6++
80004d24:	00 00       	add	r0,r0
80004d26:	0d 38       	ld.ub	r8,r6++
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	5e 0c       	reteq	r12
80004d2c:	00 00       	add	r0,r0
80004d2e:	0c f8       	st.b	--r6,r8
80004d30:	00 00       	add	r0,r0
80004d32:	0c e8       	st.h	--r6,r8
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	42 bc       	lddsp	r12,sp[0xac]
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	3b f4       	mov	r4,-65

80004d3c <fat_check_noopen>:
//!
//! @return    true  no file opened
//! @return    false otherwise
//!
bool  fat_check_noopen( void )
{
80004d3c:	d4 01       	pushm	lr
   if( !fat_check_device() )
80004d3e:	f0 1f 00 0b 	mcall	80004d68 <fat_check_noopen+0x2c>
80004d42:	c1 10       	breq	80004d64 <fat_check_noopen+0x28>
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80004d44:	48 a8       	lddpc	r8,80004d6c <fat_check_noopen+0x30>
80004d46:	11 89       	ld.ub	r9,r8[0x0]
80004d48:	30 08       	mov	r8,0
80004d4a:	f0 09 18 00 	cp.b	r9,r8
80004d4e:	c0 b0       	breq	80004d64 <fat_check_noopen+0x28>
      return true;
   if( Fat_file_is_open() )
80004d50:	48 88       	lddpc	r8,80004d70 <fat_check_noopen+0x34>
80004d52:	11 89       	ld.ub	r9,r8[0x0]
80004d54:	30 08       	mov	r8,0
80004d56:	f0 09 18 00 	cp.b	r9,r8
80004d5a:	c0 50       	breq	80004d64 <fat_check_noopen+0x28>
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
80004d5c:	30 59       	mov	r9,5
80004d5e:	48 68       	lddpc	r8,80004d74 <fat_check_noopen+0x38>
80004d60:	b0 89       	st.b	r8[0x0],r9
80004d62:	d8 0a       	popm	pc,r12=0
      return false;
80004d64:	da 0a       	popm	pc,r12=1
80004d66:	00 00       	add	r0,r0
80004d68:	80 00       	ld.sh	r0,r0[0x0]
80004d6a:	4c 84       	lddpc	r4,80004e88 <fat_update_fat2+0x48>
80004d6c:	00 00       	add	r0,r0
80004d6e:	0c fc       	st.b	--r6,r12
80004d70:	00 00       	add	r0,r0
80004d72:	0a 70       	tst	r0,r5
80004d74:	00 00       	add	r0,r0
80004d76:	0d 00       	ld.w	r0,r6++

80004d78 <fat_check_mount>:
//!
//! @return    true  partition mounted
//! @return    false otherwise
//!
bool  fat_check_mount( void )
{
80004d78:	d4 01       	pushm	lr
   if( !fat_check_device() )
80004d7a:	f0 1f 00 0a 	mcall	80004da0 <fat_check_mount+0x28>
80004d7e:	c0 f0       	breq	80004d9c <fat_check_mount+0x24>
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80004d80:	48 98       	lddpc	r8,80004da4 <fat_check_mount+0x2c>
80004d82:	11 89       	ld.ub	r9,r8[0x0]
80004d84:	30 08       	mov	r8,0
80004d86:	f0 09 18 00 	cp.b	r9,r8
80004d8a:	c0 81       	brne	80004d9a <fat_check_mount+0x22>
   {
      if( !fat_mount() )
80004d8c:	f0 1f 00 07 	mcall	80004da8 <fat_check_mount+0x30>
80004d90:	c0 51       	brne	80004d9a <fat_check_mount+0x22>
      {
         fs_g_status = FS_ERR_NO_MOUNT;
80004d92:	30 e9       	mov	r9,14
80004d94:	48 68       	lddpc	r8,80004dac <fat_check_mount+0x34>
80004d96:	b0 89       	st.b	r8[0x0],r9
         return false;
80004d98:	d8 02       	popm	pc
80004d9a:	30 1c       	mov	r12,1
      }
   }
   return true;
}
80004d9c:	d8 02       	popm	pc
80004d9e:	00 00       	add	r0,r0
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	4c 84       	lddpc	r4,80004ec0 <fat_write_fat32_FSInfo+0xc>
80004da4:	00 00       	add	r0,r0
80004da6:	0c fc       	st.b	--r6,r12
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	4f 54       	lddpc	r4,80004f7c <fat_mount+0x28>
80004dac:	00 00       	add	r0,r0
80004dae:	0d 00       	ld.w	r0,r6++

80004db0 <fat_check_mount_select>:
//!
//! @return    true  partition mounted and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select( void )
{
80004db0:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004db2:	f0 1f 00 04 	mcall	80004dc0 <fat_check_mount_select+0x10>
80004db6:	c0 30       	breq	80004dbc <fat_check_mount_select+0xc>
      return false;
   return fat_check_select();
80004db8:	f0 1f 00 03 	mcall	80004dc4 <fat_check_mount_select+0x14>
}
80004dbc:	d8 02       	popm	pc
80004dbe:	00 00       	add	r0,r0
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	4d 78       	lddpc	r8,80004f1c <fat_write_fat32_FSInfo+0x68>
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	3b 58       	mov	r8,-75

80004dc8 <fat_check_mount_select_open>:
//!
//! @return    true  partition mounted and a file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_select_open( void )
{
80004dc8:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004dca:	f0 1f 00 06 	mcall	80004de0 <fat_check_mount_select_open+0x18>
80004dce:	c0 70       	breq	80004ddc <fat_check_mount_select_open+0x14>
      return false;
   if( !fat_check_select() )
80004dd0:	f0 1f 00 05 	mcall	80004de4 <fat_check_mount_select_open+0x1c>
80004dd4:	c0 40       	breq	80004ddc <fat_check_mount_select_open+0x14>
      return false;
   return fat_check_open();
80004dd6:	f0 1f 00 05 	mcall	80004de8 <fat_check_mount_select_open+0x20>
80004dda:	d8 02       	popm	pc
80004ddc:	d8 0a       	popm	pc,r12=0
80004dde:	00 00       	add	r0,r0
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	4d 78       	lddpc	r8,80004f3c <fat_write_fat32_FSInfo+0x88>
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	3b 58       	mov	r8,-75
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	3b 38       	mov	r8,-77

80004dec <fat_check_mount_select_noopen>:
//!
//! @return    true  partition mounted and no file is opened and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select_noopen( void )
{
80004dec:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004dee:	f0 1f 00 06 	mcall	80004e04 <fat_check_mount_select_noopen+0x18>
80004df2:	c0 70       	breq	80004e00 <fat_check_mount_select_noopen+0x14>
      return false;
   if( !fat_check_select() )
80004df4:	f0 1f 00 05 	mcall	80004e08 <fat_check_mount_select_noopen+0x1c>
80004df8:	c0 40       	breq	80004e00 <fat_check_mount_select_noopen+0x14>
      return false;
   return fat_check_noopen();
80004dfa:	f0 1f 00 05 	mcall	80004e0c <fat_check_mount_select_noopen+0x20>
80004dfe:	d8 02       	popm	pc
80004e00:	d8 0a       	popm	pc,r12=0
80004e02:	00 00       	add	r0,r0
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	4d 78       	lddpc	r8,80004f60 <fat_mount+0xc>
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	3b 58       	mov	r8,-75
80004e0c:	80 00       	ld.sh	r0,r0[0x0]
80004e0e:	4d 3c       	lddpc	r12,80004f58 <fat_mount+0x4>

80004e10 <fat_check_mount_noopen>:
//!
//! @return    true  partition mounted and no file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_noopen( void )
{
80004e10:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004e12:	f0 1f 00 04 	mcall	80004e20 <fat_check_mount_noopen+0x10>
80004e16:	c0 30       	breq	80004e1c <fat_check_mount_noopen+0xc>
      return false;
   return fat_check_noopen();
80004e18:	f0 1f 00 03 	mcall	80004e24 <fat_check_mount_noopen+0x14>
}
80004e1c:	d8 02       	popm	pc
80004e1e:	00 00       	add	r0,r0
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4d 78       	lddpc	r8,80004f7c <fat_mount+0x28>
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	4d 3c       	lddpc	r12,80004f70 <fat_mount+0x1c>

80004e28 <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
80004e28:	3f f9       	mov	r9,-1
80004e2a:	48 48       	lddpc	r8,80004e38 <fat_clear_info_fat_mod+0x10>
80004e2c:	91 09       	st.w	r8[0x0],r9
   fs_g_u32_last_mod_fat = 0;
80004e2e:	30 09       	mov	r9,0
80004e30:	48 38       	lddpc	r8,80004e3c <fat_clear_info_fat_mod+0x14>
80004e32:	91 09       	st.w	r8[0x0],r9
}
80004e34:	5e fc       	retal	r12
80004e36:	00 00       	add	r0,r0
80004e38:	00 00       	add	r0,r0
80004e3a:	0c e4       	st.h	--r6,r4
80004e3c:	00 00       	add	r0,r0
80004e3e:	0a ac       	st.w	r5++,r12

80004e40 <fat_update_fat2>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
80004e40:	eb cd 40 fc 	pushm	r2-r7,lr
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004e44:	49 68       	lddpc	r8,80004e9c <fat_update_fat2+0x5c>
80004e46:	70 08       	ld.w	r8,r8[0x0]
80004e48:	49 69       	lddpc	r9,80004ea0 <fat_update_fat2+0x60>
80004e4a:	72 09       	ld.w	r9,r9[0x0]
80004e4c:	12 38       	cp.w	r8,r9
80004e4e:	e0 8b 00 25 	brhi	80004e98 <fat_update_fat2+0x58>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
80004e52:	49 55       	lddpc	r5,80004ea4 <fat_update_fat2+0x64>
80004e54:	49 57       	lddpc	r7,80004ea8 <fat_update_fat2+0x68>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80004e56:	30 13       	mov	r3,1
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80004e58:	49 16       	lddpc	r6,80004e9c <fat_update_fat2+0x5c>
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80004e5a:	30 02       	mov	r2,0
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004e5c:	49 14       	lddpc	r4,80004ea0 <fat_update_fat2+0x60>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
80004e5e:	6e 49       	ld.w	r9,r7[0x10]
80004e60:	12 08       	add	r8,r9
80004e62:	8b 08       	st.w	r5[0x0],r8
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80004e64:	06 9c       	mov	r12,r3
80004e66:	f0 1f 00 12 	mcall	80004eac <fat_update_fat2+0x6c>
80004e6a:	c1 50       	breq	80004e94 <fat_update_fat2+0x54>
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80004e6c:	6e 19       	ld.w	r9,r7[0x4]
80004e6e:	6e 48       	ld.w	r8,r7[0x10]
80004e70:	f2 08 00 08 	add	r8,r9,r8
80004e74:	6c 09       	ld.w	r9,r6[0x0]
80004e76:	12 08       	add	r8,r9
80004e78:	8b 08       	st.w	r5[0x0],r8
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80004e7a:	04 9c       	mov	r12,r2
80004e7c:	f0 1f 00 0c 	mcall	80004eac <fat_update_fat2+0x6c>
80004e80:	c0 a0       	breq	80004e94 <fat_update_fat2+0x54>
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
80004e82:	f0 1f 00 0c 	mcall	80004eb0 <fat_update_fat2+0x70>
     fs_g_u32_first_mod_fat++;
80004e86:	6c 08       	ld.w	r8,r6[0x0]
80004e88:	2f f8       	sub	r8,-1
80004e8a:	8d 08       	st.w	r6[0x0],r8
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004e8c:	68 09       	ld.w	r9,r4[0x0]
80004e8e:	10 39       	cp.w	r9,r8
80004e90:	ce 72       	brcc	80004e5e <fat_update_fat2+0x1e>
80004e92:	c0 38       	rjmp	80004e98 <fat_update_fat2+0x58>
80004e94:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004e98:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80004e9c:	00 00       	add	r0,r0
80004e9e:	0c e4       	st.h	--r6,r4
80004ea0:	00 00       	add	r0,r0
80004ea2:	0a ac       	st.w	r5++,r12
80004ea4:	00 00       	add	r0,r0
80004ea6:	0a 6c       	and	r12,r5
80004ea8:	00 00       	add	r0,r0
80004eaa:	0c b0       	st.h	r6++,r0
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	44 f4       	lddsp	r4,sp[0x13c]
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	42 d4       	lddsp	r4,sp[0xb4]

80004eb4 <fat_write_fat32_FSInfo>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
80004eb4:	eb cd 40 c0 	pushm	r6-r7,lr
80004eb8:	20 1d       	sub	sp,4
80004eba:	50 0c       	stdsp	sp[0x0],r12
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
80004ebc:	49 c8       	lddpc	r8,80004f2c <fat_write_fat32_FSInfo+0x78>
80004ebe:	90 c9       	ld.uh	r9,r8[0x8]
80004ec0:	70 4a       	ld.w	r10,r8[0x10]
80004ec2:	49 c8       	lddpc	r8,80004f30 <fat_write_fat32_FSInfo+0x7c>
80004ec4:	12 1a       	sub	r10,r9
80004ec6:	91 0a       	st.w	r8[0x0],r10

   if( !fat_cache_read_sector( false ))
80004ec8:	30 0c       	mov	r12,0
80004eca:	f0 1f 00 1b 	mcall	80004f34 <fat_write_fat32_FSInfo+0x80>
80004ece:	c2 c0       	breq	80004f26 <fat_write_fat32_FSInfo+0x72>
      return false;
   fat_cache_mark_sector_as_dirty();
80004ed0:	f0 1f 00 1a 	mcall	80004f38 <fat_write_fat32_FSInfo+0x84>
   fat_cache_clear();
80004ed4:	f0 1f 00 1a 	mcall	80004f3c <fat_write_fat32_FSInfo+0x88>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
80004ed8:	49 a7       	lddpc	r7,80004f40 <fat_write_fat32_FSInfo+0x8c>
80004eda:	30 46       	mov	r6,4
80004edc:	0c 9a       	mov	r10,r6
80004ede:	49 ab       	lddpc	r11,80004f44 <fat_write_fat32_FSInfo+0x90>
80004ee0:	0e 9c       	mov	r12,r7
80004ee2:	f0 1f 00 1a 	mcall	80004f48 <fat_write_fat32_FSInfo+0x94>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
80004ee6:	0c 9a       	mov	r10,r6
80004ee8:	49 9b       	lddpc	r11,80004f4c <fat_write_fat32_FSInfo+0x98>
80004eea:	ee cc fe 1c 	sub	r12,r7,-484
80004eee:	f0 1f 00 17 	mcall	80004f48 <fat_write_fat32_FSInfo+0x94>
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
80004ef2:	1b b9       	ld.ub	r9,sp[0x3]
80004ef4:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
80004ef8:	1b a9       	ld.ub	r9,sp[0x2]
80004efa:	ef 69 01 e9 	st.b	r7[489],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
80004efe:	1b 99       	ld.ub	r9,sp[0x1]
80004f00:	ef 69 01 ea 	st.b	r7[490],r9
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
80004f04:	1b 88       	ld.ub	r8,sp[0x0]
80004f06:	ef 68 01 eb 	st.b	r7[491],r8
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
80004f0a:	0c 9a       	mov	r10,r6
80004f0c:	e0 6b 00 ff 	mov	r11,255
80004f10:	ee cc fe 14 	sub	r12,r7,-492
80004f14:	f0 1f 00 0f 	mcall	80004f50 <fat_write_fat32_FSInfo+0x9c>
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
80004f18:	35 58       	mov	r8,85
80004f1a:	ef 68 01 fe 	st.b	r7[510],r8
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
80004f1e:	3a a8       	mov	r8,-86
80004f20:	ef 68 01 ff 	st.b	r7[511],r8
80004f24:	30 1c       	mov	r12,1
   return true;
}
80004f26:	2f fd       	sub	sp,-4
80004f28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f2c:	00 00       	add	r0,r0
80004f2e:	0c b0       	st.h	r6++,r0
80004f30:	00 00       	add	r0,r0
80004f32:	0a 6c       	and	r12,r5
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	44 f4       	lddsp	r4,sp[0x13c]
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	42 d4       	lddsp	r4,sp[0xb4]
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	44 dc       	lddsp	r12,sp[0x134]
80004f40:	00 00       	add	r0,r0
80004f42:	0a b0       	st.h	r5++,r0
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	9c e0       	ld.uh	r0,lr[0xc]
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	91 20       	st.w	r8[0x8],r0
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	9c e4       	ld.uh	r4,lr[0xc]
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	92 68       	ld.sh	r8,r9[0xc]

80004f54 <fat_mount>:
//! If the FS_MULTI_PARTITION option is disabled
//! then the mount routine selects the first partition supported by file system. <br>
//! @endverbatim
//!
bool  fat_mount( void )
{
80004f54:	d4 31       	pushm	r0-r7,lr
80004f56:	20 3d       	sub	sp,12
   uint8_t  u8_tmp;
   uint16_t u16_tmp;
   uint32_t u32_tmp;

   // Select the root directory
   fs_g_nav.u32_cluster_sel_dir   = 0;
80004f58:	30 07       	mov	r7,0
80004f5a:	fe f8 02 d2 	ld.w	r8,pc[722]
80004f5e:	91 87       	st.w	r8[0x20],r7
   // No selected file
   fat_clear_entry_info_and_ptr();
80004f60:	f0 1f 00 b4 	mcall	80005230 <fat_mount+0x2dc>

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
80004f64:	fe f8 02 d0 	ld.w	r8,pc[720]
80004f68:	b0 87       	st.b	r8[0x0],r7
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory
80004f6a:	fe f8 02 ce 	ld.w	r8,pc[718]
80004f6e:	91 07       	st.w	r8[0x0],r7

   // Check if the drive is available
   if( !fat_check_device() )
80004f70:	f0 1f 00 b3 	mcall	8000523c <fat_mount+0x2e8>
80004f74:	e0 80 01 58 	breq	80005224 <fat_mount+0x2d0>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80004f78:	fe f5 02 c8 	ld.w	r5,pc[712]
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
80004f7c:	ea c8 fe 42 	sub	r8,r5,-446
80004f80:	50 08       	stdsp	sp[0x0],r8
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80004f82:	38 04       	mov	r4,-128
80004f84:	30 46       	mov	r6,4
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
80004f86:	30 1c       	mov	r12,1
80004f88:	f0 1f 00 af 	mcall	80005244 <fat_mount+0x2f0>
80004f8c:	e0 80 01 4c 	breq	80005224 <fat_mount+0x2d0>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80004f90:	eb 39 01 fe 	ld.ub	r9,r5[510]
80004f94:	35 58       	mov	r8,85
80004f96:	f0 09 18 00 	cp.b	r9,r8
80004f9a:	c0 d0       	breq	80004fb4 <fat_mount+0x60>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
80004f9c:	eb 39 01 ff 	ld.ub	r9,r5[511]
80004fa0:	3a a8       	mov	r8,-86
80004fa2:	f0 09 18 00 	cp.b	r9,r8
80004fa6:	c0 70       	breq	80004fb4 <fat_mount+0x60>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
80004fa8:	30 29       	mov	r9,2
80004faa:	fe f8 02 9e 	ld.w	r8,pc[670]
80004fae:	b0 89       	st.b	r8[0x0],r9
80004fb0:	30 0c       	mov	r12,0
         return false;
80004fb2:	c3 a9       	rjmp	80005226 <fat_mount+0x2d2>
      }

      if ( 0 == fs_gu32_addrsector )
80004fb4:	fe f8 02 84 	ld.w	r8,pc[644]
80004fb8:	70 08       	ld.w	r8,r8[0x0]
80004fba:	58 08       	cp.w	r8,0
80004fbc:	c5 21       	brne	80005060 <fat_mount+0x10c>
80004fbe:	40 08       	lddsp	r8,sp[0x0]
80004fc0:	30 0a       	mov	r10,0
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80004fc2:	30 1e       	mov	lr,1
80004fc4:	30 63       	mov	r3,6
80004fc6:	30 e2       	mov	r2,14
80004fc8:	30 b1       	mov	r1,11
80004fca:	30 c0       	mov	r0,12
80004fcc:	11 89       	ld.ub	r9,r8[0x0]
80004fce:	e8 09 18 00 	cp.b	r9,r4
80004fd2:	5f 0b       	sreq	r11
80004fd4:	ee 09 18 00 	cp.b	r9,r7
80004fd8:	5f 09       	sreq	r9
80004fda:	f7 e9 10 09 	or	r9,r11,r9
80004fde:	ee 09 18 00 	cp.b	r9,r7
80004fe2:	c1 90       	breq	80005014 <fat_mount+0xc0>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
80004fe4:	11 c9       	ld.ub	r9,r8[0x4]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80004fe6:	fc 09 18 00 	cp.b	r9,lr
80004fea:	5f 0c       	sreq	r12
80004fec:	ec 09 18 00 	cp.b	r9,r6
80004ff0:	5f 0b       	sreq	r11
80004ff2:	f9 eb 10 0b 	or	r11,r12,r11
80004ff6:	ee 0b 18 00 	cp.b	r11,r7
80004ffa:	c1 41       	brne	80005022 <fat_mount+0xce>
80004ffc:	e6 09 18 00 	cp.b	r9,r3
80005000:	c1 10       	breq	80005022 <fat_mount+0xce>
80005002:	e4 09 18 00 	cp.b	r9,r2
80005006:	c0 e0       	breq	80005022 <fat_mount+0xce>
80005008:	e2 09 18 00 	cp.b	r9,r1
8000500c:	c0 b0       	breq	80005022 <fat_mount+0xce>
8000500e:	e0 09 18 00 	cp.b	r9,r0
80005012:	c0 80       	breq	80005022 <fat_mount+0xce>
         //** first sector then check a MBR structure
         // Search the first partition supported
#if (FS_MULTI_PARTITION == true)
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
80005014:	2f fa       	sub	r10,-1
80005016:	5c 5a       	castu.b	r10
80005018:	2f 08       	sub	r8,-16
8000501a:	ec 0a 18 00 	cp.b	r10,r6
8000501e:	cd 71       	brne	80004fcc <fat_mount+0x78>
80005020:	c2 08       	rjmp	80005060 <fat_mount+0x10c>
#else
               break;
#endif
            }
         }
         if( u8_tmp != 4 )
80005022:	ec 0a 18 00 	cp.b	r10,r6
80005026:	c1 d0       	breq	80005060 <fat_mount+0x10c>
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
80005028:	fe f3 02 10 	ld.w	r3,pc[528]
8000502c:	a5 6a       	lsl	r10,0x4
8000502e:	f4 ca fe 42 	sub	r10,r10,-446
80005032:	ea 0a 00 0a 	add	r10,r5,r10
80005036:	f5 38 00 08 	ld.ub	r8,r10[8]
8000503a:	a6 b8       	st.b	r3[0x3],r8
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
8000503c:	f5 38 00 09 	ld.ub	r8,r10[9]
80005040:	a6 a8       	st.b	r3[0x2],r8
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
80005042:	f5 38 00 0a 	ld.ub	r8,r10[10]
80005046:	a6 98       	st.b	r3[0x1],r8
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
80005048:	f5 38 00 0b 	ld.ub	r8,r10[11]
8000504c:	a6 88       	st.b	r3[0x0],r8
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
8000504e:	4f 88       	lddpc	r8,8000522c <fat_mount+0x2d8>
80005050:	11 8c       	ld.ub	r12,r8[0x0]
80005052:	f0 1f 00 7f 	mcall	8000524c <fat_mount+0x2f8>
80005056:	66 08       	ld.w	r8,r3[0x0]
80005058:	f8 08 02 48 	mul	r8,r12,r8
8000505c:	87 08       	st.w	r3[0x0],r8
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
8000505e:	c9 4b       	rjmp	80004f86 <fat_mount+0x32>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
80005060:	4f 88       	lddpc	r8,80005240 <fat_mount+0x2ec>
80005062:	11 89       	ld.ub	r9,r8[0x0]
80005064:	3e b8       	mov	r8,-21
80005066:	f0 09 18 00 	cp.b	r9,r8
8000506a:	c0 f1       	brne	80005088 <fat_mount+0x134>
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
8000506c:	4f 58       	lddpc	r8,80005240 <fat_mount+0x2ec>
8000506e:	11 a9       	ld.ub	r9,r8[0x2]
80005070:	39 08       	mov	r8,-112
80005072:	f0 09 18 00 	cp.b	r9,r8
80005076:	c0 91       	brne	80005088 <fat_mount+0x134>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
80005078:	4f 28       	lddpc	r8,80005240 <fat_mount+0x2ec>
8000507a:	f1 38 00 15 	ld.ub	r8,r8[21]
8000507e:	e2 18 00 f0 	andl	r8,0xf0,COH
80005082:	e0 48 00 f0 	cp.w	r8,240
80005086:	c0 60       	breq	80005092 <fat_mount+0x13e>
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
80005088:	30 39       	mov	r9,3
8000508a:	4f 08       	lddpc	r8,80005248 <fat_mount+0x2f4>
8000508c:	b0 89       	st.b	r8[0x0],r9
8000508e:	30 0c       	mov	r12,0
      return false;
80005090:	cc b8       	rjmp	80005226 <fat_mount+0x2d2>
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
80005092:	30 49       	mov	r9,4
80005094:	4e d8       	lddpc	r8,80005248 <fat_mount+0x2f4>
80005096:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
80005098:	4e aa       	lddpc	r10,80005240 <fat_mount+0x2ec>
8000509a:	f5 39 00 0c 	ld.ub	r9,r10[12]
8000509e:	a1 99       	lsr	r9,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
800050a0:	f5 38 00 0d 	ld.ub	r8,r10[13]
800050a4:	b3 38       	mul	r8,r9
800050a6:	5c 58       	castu.b	r8
800050a8:	4e 1b       	lddpc	r11,8000522c <fat_mount+0x2d8>
800050aa:	b6 98       	st.b	r11[0x1],r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
800050ac:	30 0b       	mov	r11,0
800050ae:	50 1b       	stdsp	sp[0x4],r11
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
800050b0:	fa cb ff fc 	sub	r11,sp,-4
800050b4:	fa c7 ff f9 	sub	r7,sp,-7
800050b8:	f5 3c 00 16 	ld.ub	r12,r10[22]
800050bc:	ae 8c       	st.b	r7[0x0],r12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
800050be:	fa ce ff fa 	sub	lr,sp,-6
800050c2:	f5 3a 00 17 	ld.ub	r10,r10[23]
800050c6:	bc 8a       	st.b	lr[0x0],r10
   if ( 0==u32_tmp )
800050c8:	40 1a       	lddsp	r10,sp[0x4]
800050ca:	58 0a       	cp.w	r10,0
800050cc:	c0 e1       	brne	800050e8 <fat_mount+0x194>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
800050ce:	4d da       	lddpc	r10,80005240 <fat_mount+0x2ec>
800050d0:	f5 3c 00 24 	ld.ub	r12,r10[36]
800050d4:	ae 8c       	st.b	r7[0x0],r12
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
800050d6:	f5 3c 00 25 	ld.ub	r12,r10[37]
800050da:	bc 8c       	st.b	lr[0x0],r12
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
800050dc:	f5 3c 00 26 	ld.ub	r12,r10[38]
800050e0:	b6 9c       	st.b	r11[0x1],r12
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
800050e2:	f5 3a 00 27 	ld.ub	r10,r10[39]
800050e6:	b6 8a       	st.b	r11[0x0],r10
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
800050e8:	12 95       	mov	r5,r9
800050ea:	40 1c       	lddsp	r12,sp[0x4]
800050ec:	f2 0c 02 4c 	mul	r12,r9,r12
800050f0:	4c fa       	lddpc	r10,8000522c <fat_mount+0x2d8>
800050f2:	95 1c       	st.w	r10[0x4],r12

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
800050f4:	4d 3a       	lddpc	r10,80005240 <fat_mount+0x2ec>
800050f6:	f5 3a 00 13 	ld.ub	r10,r10[19]
800050fa:	58 0a       	cp.w	r10,0
800050fc:	c1 61       	brne	80005128 <fat_mount+0x1d4>
800050fe:	4d 16       	lddpc	r6,80005240 <fat_mount+0x2ec>
80005100:	ed 34 00 14 	ld.ub	r4,r6[20]
80005104:	30 06       	mov	r6,0
80005106:	ec 04 18 00 	cp.b	r4,r6
8000510a:	c0 f1       	brne	80005128 <fat_mount+0x1d4>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
8000510c:	4c da       	lddpc	r10,80005240 <fat_mount+0x2ec>
8000510e:	f5 36 00 20 	ld.ub	r6,r10[32]
80005112:	ae 86       	st.b	r7[0x0],r6
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
80005114:	f5 37 00 21 	ld.ub	r7,r10[33]
80005118:	bc 87       	st.b	lr[0x0],r7
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
8000511a:	f5 3e 00 22 	ld.ub	lr,r10[34]
8000511e:	b6 9e       	st.b	r11[0x1],lr
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
80005120:	f5 3a 00 23 	ld.ub	r10,r10[35]
80005124:	b6 8a       	st.b	r11[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80005126:	c0 98       	rjmp	80005138 <fat_mount+0x1e4>
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
80005128:	ae 8a       	st.b	r7[0x0],r10
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
8000512a:	4c 6a       	lddpc	r10,80005240 <fat_mount+0x2ec>
8000512c:	f5 3a 00 14 	ld.ub	r10,r10[20]
80005130:	bc 8a       	st.b	lr[0x0],r10
      LSB2( u32_tmp ) = 0;
80005132:	30 0a       	mov	r10,0
80005134:	b6 9a       	st.b	r11[0x1],r10
      LSB3( u32_tmp ) = 0;
80005136:	b6 8a       	st.b	r11[0x0],r10
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
80005138:	40 14       	lddsp	r4,sp[0x4]

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
8000513a:	4b da       	lddpc	r10,8000522c <fat_mount+0x2d8>
8000513c:	f8 0b 15 01 	lsl	r11,r12,0x1
80005140:	f5 5b 00 18 	st.h	r10[24],r11

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
80005144:	fa c6 ff f6 	sub	r6,sp,-10
80005148:	fa c7 ff f4 	sub	r7,sp,-12
8000514c:	4b db       	lddpc	r11,80005240 <fat_mount+0x2ec>
8000514e:	f7 3e 00 11 	ld.ub	lr,r11[17]
80005152:	0e fe       	st.b	--r7,lr
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
80005154:	f7 3e 00 12 	ld.ub	lr,r11[18]
80005158:	ac 8e       	st.b	r6[0x0],lr
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
8000515a:	f2 03 15 04 	lsl	r3,r9,0x4
8000515e:	9a de       	ld.uh	lr,sp[0xa]
80005160:	e6 0e 00 0e 	add	lr,r3,lr
80005164:	a5 7e       	lsl	lr,0x5
80005166:	20 1e       	sub	lr,1
80005168:	f2 03 15 09 	lsl	r3,r9,0x9
8000516c:	fc 03 0c 02 	divs	r2,lr,r3
80005170:	e4 09 02 4e 	mul	lr,r2,r9
80005174:	f5 5e 00 1a 	st.h	r10[26],lr

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
80005178:	f7 33 00 0e 	ld.ub	r3,r11[14]
8000517c:	ae 83       	st.b	r7[0x0],r3
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
8000517e:	f7 37 00 0f 	ld.ub	r7,r11[15]
80005182:	ac 87       	st.b	r6[0x0],r7
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
80005184:	9a 57       	ld.sh	r7,sp[0xa]
80005186:	f7 3b 00 30 	ld.ub	r11,r11[48]
8000518a:	0e 96       	mov	r6,r7
8000518c:	ee 0b 01 0b 	sub	r11,r7,r11
80005190:	b3 3b       	mul	r11,r9
80005192:	b4 4b       	st.h	r10[0x8],r11
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
80005194:	ee 09 02 49 	mul	r9,r7,r9
80005198:	5c 79       	castu.h	r9
8000519a:	4a 8b       	lddpc	r11,80005238 <fat_mount+0x2e4>
8000519c:	76 0b       	ld.w	r11,r11[0x0]
8000519e:	f2 0b 00 0b 	add	r11,r9,r11
800051a2:	95 4b       	st.w	r10[0x10],r11

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
800051a4:	5c 7e       	castu.h	lr
800051a6:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
800051aa:	95 5c       	st.w	r10[0x14],r12
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
800051ac:	58 08       	cp.w	r8,0
800051ae:	c3 b0       	breq	80005224 <fat_mount+0x2d0>

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
800051b0:	a9 35       	mul	r5,r4
800051b2:	ea 09 01 09 	sub	r9,r5,r9
800051b6:	18 19       	sub	r9,r12
800051b8:	50 19       	stdsp	sp[0x4],r9

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
800051ba:	30 1a       	mov	r10,1
800051bc:	f4 08 18 00 	cp.b	r8,r10
800051c0:	c0 70       	breq	800051ce <fat_mount+0x27a>
   {
     u32_tmp  >>= 1;   // This computation round down
800051c2:	a1 99       	lsr	r9,0x1

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
800051c4:	a1 98       	lsr	r8,0x1
800051c6:	f4 08 18 00 	cp.b	r8,r10
800051ca:	cf c1       	brne	800051c2 <fat_mount+0x26e>
800051cc:	50 19       	stdsp	sp[0x4],r9
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
800051ce:	40 18       	lddsp	r8,sp[0x4]
800051d0:	f0 ca ff fe 	sub	r10,r8,-2
800051d4:	49 69       	lddpc	r9,8000522c <fat_mount+0x2d8>
800051d6:	93 3a       	st.w	r9[0xc],r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
800051d8:	e0 48 0f f4 	cp.w	r8,4084
800051dc:	e0 8b 00 07 	brhi	800051ea <fat_mount+0x296>
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
800051e0:	30 19       	mov	r9,1
800051e2:	49 58       	lddpc	r8,80005234 <fat_mount+0x2e0>
800051e4:	b0 89       	st.b	r8[0x0],r9
800051e6:	30 1c       	mov	r12,1
800051e8:	c1 f8       	rjmp	80005226 <fat_mount+0x2d2>
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
800051ea:	e0 48 ff f4 	cp.w	r8,65524
800051ee:	e0 8b 00 07 	brhi	800051fc <fat_mount+0x2a8>
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
800051f2:	30 29       	mov	r9,2
800051f4:	49 08       	lddpc	r8,80005234 <fat_mount+0x2e0>
800051f6:	b0 89       	st.b	r8[0x0],r9
800051f8:	30 1c       	mov	r12,1
800051fa:	c1 68       	rjmp	80005226 <fat_mount+0x2d2>
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
800051fc:	30 39       	mov	r9,3
800051fe:	48 e8       	lddpc	r8,80005234 <fat_mount+0x2e0>
80005200:	b0 89       	st.b	r8[0x0],r9
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
80005202:	48 b8       	lddpc	r8,8000522c <fat_mount+0x2d8>
80005204:	2e 88       	sub	r8,-24
80005206:	48 f9       	lddpc	r9,80005240 <fat_mount+0x2ec>
80005208:	f3 3a 00 2c 	ld.ub	r10,r9[44]
8000520c:	b0 ba       	st.b	r8[0x3],r10
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
8000520e:	f3 3a 00 2d 	ld.ub	r10,r9[45]
80005212:	b0 aa       	st.b	r8[0x2],r10
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
80005214:	f3 3a 00 2e 	ld.ub	r10,r9[46]
80005218:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
8000521a:	f3 39 00 2f 	ld.ub	r9,r9[47]
8000521e:	b0 89       	st.b	r8[0x0],r9
80005220:	30 1c       	mov	r12,1
80005222:	c0 28       	rjmp	80005226 <fat_mount+0x2d2>
80005224:	30 0c       	mov	r12,0
   }
   }

   return true;
}
80005226:	2f dd       	sub	sp,-12
80005228:	d8 32       	popm	r0-r7,pc
8000522a:	00 00       	add	r0,r0
8000522c:	00 00       	add	r0,r0
8000522e:	0c b0       	st.h	r6++,r0
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	3e 60       	mov	r0,-26
80005234:	00 00       	add	r0,r0
80005236:	0c fc       	st.b	--r6,r12
80005238:	00 00       	add	r0,r0
8000523a:	0a 6c       	and	r12,r5
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	4c 84       	lddpc	r4,8000535c <file_open+0x40>
80005240:	00 00       	add	r0,r0
80005242:	0a b0       	st.h	r5++,r0
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	44 f4       	lddsp	r4,sp[0x13c]
80005248:	00 00       	add	r0,r0
8000524a:	0d 00       	ld.w	r0,r6++
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	5d d4       	*unknown*

80005250 <file_eof>:
//! @return    1     the position is at the end of file
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
80005250:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
80005252:	f0 1f 00 07 	mcall	8000526c <file_eof+0x1c>
80005256:	c0 41       	brne	8000525e <file_eof+0xe>
80005258:	e0 6c 00 ff 	mov	r12,255
8000525c:	d8 02       	popm	pc
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
8000525e:	48 58       	lddpc	r8,80005270 <file_eof+0x20>
80005260:	70 29       	ld.w	r9,r8[0x8]
80005262:	70 38       	ld.w	r8,r8[0xc]
80005264:	10 39       	cp.w	r9,r8
80005266:	5f 8c       	srls	r12
}
80005268:	d8 02       	popm	pc
8000526a:	00 00       	add	r0,r0
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	4d c8       	lddpc	r8,800053dc <nav_drive_getname+0x14>
80005270:	00 00       	add	r0,r0
80005272:	0a 70       	tst	r0,r5

80005274 <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
80005274:	d4 01       	pushm	lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
80005276:	f0 1f 00 0a 	mcall	8000529c <file_close+0x28>
8000527a:	c1 00       	breq	8000529a <file_close+0x26>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
8000527c:	48 98       	lddpc	r8,800052a0 <file_close+0x2c>
8000527e:	11 88       	ld.ub	r8,r8[0x0]
80005280:	e2 18 00 02 	andl	r8,0x2,COH
80005284:	c0 80       	breq	80005294 <file_close+0x20>
      {
         // Write file information
         if( !fat_read_dir() )
80005286:	f0 1f 00 08 	mcall	800052a4 <file_close+0x30>
8000528a:	c0 80       	breq	8000529a <file_close+0x26>
            return;           // error
         fat_write_entry_file();
8000528c:	f0 1f 00 07 	mcall	800052a8 <file_close+0x34>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
80005290:	f0 1f 00 07 	mcall	800052ac <file_close+0x38>
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
80005294:	30 09       	mov	r9,0
80005296:	48 38       	lddpc	r8,800052a0 <file_close+0x2c>
80005298:	b0 89       	st.b	r8[0x0],r9
8000529a:	d8 02       	popm	pc
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	4d c8       	lddpc	r8,8000540c <nav_file_checkext+0x1c>
800052a0:	00 00       	add	r0,r0
800052a2:	0a 70       	tst	r0,r5
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	4b 24       	lddpc	r4,8000536c <file_open+0x50>
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	42 e4       	lddsp	r4,sp[0xb8]
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	44 88       	lddsp	r8,sp[0x120]

800052b0 <file_getc>:
//!
//! @return    The byte read
//! @return    EOF, in case of error or end of file
//!
uint16_t   file_getc( void )
{
800052b0:	d4 01       	pushm	lr
   uint16_t   u16_byte;

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
800052b2:	49 78       	lddpc	r8,8000530c <file_getc+0x5c>
800052b4:	11 88       	ld.ub	r8,r8[0x0]
800052b6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800052ba:	c0 51       	brne	800052c4 <file_getc+0x14>
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
800052bc:	31 e9       	mov	r9,30
800052be:	49 58       	lddpc	r8,80005310 <file_getc+0x60>
800052c0:	b0 89       	st.b	r8[0x0],r9
800052c2:	dc 0a       	popm	pc,r12=-1
         break;
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
800052c4:	49 28       	lddpc	r8,8000530c <file_getc+0x5c>
800052c6:	70 29       	ld.w	r9,r8[0x8]
800052c8:	70 38       	ld.w	r8,r8[0xc]
800052ca:	10 39       	cp.w	r9,r8
800052cc:	e0 8b 00 06 	brhi	800052d8 <file_getc+0x28>
      {
         fs_g_status = FS_ERR_EOF;
800052d0:	32 09       	mov	r9,32
800052d2:	49 08       	lddpc	r8,80005310 <file_getc+0x60>
800052d4:	b0 89       	st.b	r8[0x0],r9
800052d6:	dc 0a       	popm	pc,r12=-1
         break;
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
800052d8:	30 2c       	mov	r12,2
800052da:	f0 1f 00 0f 	mcall	80005314 <file_getc+0x64>
800052de:	c0 c1       	brne	800052f6 <file_getc+0x46>
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
800052e0:	48 c8       	lddpc	r8,80005310 <file_getc+0x60>
800052e2:	11 89       	ld.ub	r9,r8[0x0]
800052e4:	31 a8       	mov	r8,26
800052e6:	f0 09 18 00 	cp.b	r9,r8
800052ea:	c0 20       	breq	800052ee <file_getc+0x3e>
800052ec:	dc 0a       	popm	pc,r12=-1
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
800052ee:	32 09       	mov	r9,32
800052f0:	48 88       	lddpc	r8,80005310 <file_getc+0x60>
800052f2:	b0 89       	st.b	r8[0x0],r9
800052f4:	dc 0a       	popm	pc,r12=-1
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
800052f6:	48 68       	lddpc	r8,8000530c <file_getc+0x5c>
800052f8:	70 39       	ld.w	r9,r8[0xc]
800052fa:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
800052fe:	48 7b       	lddpc	r11,80005318 <file_getc+0x68>
80005300:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
      fs_g_nav_entry.u32_pos_in_file++;
80005304:	2f f9       	sub	r9,-1
80005306:	91 39       	st.w	r8[0xc],r9
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
80005308:	d8 02       	popm	pc
8000530a:	00 00       	add	r0,r0
8000530c:	00 00       	add	r0,r0
8000530e:	0a 70       	tst	r0,r5
80005310:	00 00       	add	r0,r0
80005312:	0d 00       	ld.w	r0,r6++
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	4b a8       	lddpc	r8,800053fc <nav_file_checkext+0xc>
80005318:	00 00       	add	r0,r0
8000531a:	0a b0       	st.h	r5++,r0

8000531c <file_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
8000531c:	eb cd 40 c0 	pushm	r6-r7,lr
80005320:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_noopen())
80005322:	f0 1f 00 20 	mcall	800053a0 <file_open+0x84>
80005326:	c3 a0       	breq	8000539a <file_open+0x7e>
      return false;

   if( !fat_check_is_file())
80005328:	f0 1f 00 1f 	mcall	800053a4 <file_open+0x88>
8000532c:	c3 70       	breq	8000539a <file_open+0x7e>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
8000532e:	0e 96       	mov	r6,r7
80005330:	0e 98       	mov	r8,r7
80005332:	e2 18 00 02 	andl	r8,0x2,COH
80005336:	c1 90       	breq	80005368 <file_open+0x4c>
   {
      if( !fat_check_nav_access_file( true ) )
80005338:	30 1c       	mov	r12,1
8000533a:	f0 1f 00 1c 	mcall	800053a8 <file_open+0x8c>
8000533e:	c2 e0       	breq	8000539a <file_open+0x7e>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
80005340:	49 b8       	lddpc	r8,800053ac <file_open+0x90>
80005342:	11 a8       	ld.ub	r8,r8[0x2]
80005344:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005348:	c0 60       	breq	80005354 <file_open+0x38>
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
8000534a:	31 59       	mov	r9,21
8000534c:	49 98       	lddpc	r8,800053b0 <file_open+0x94>
8000534e:	b0 89       	st.b	r8[0x0],r9
80005350:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
80005354:	49 88       	lddpc	r8,800053b4 <file_open+0x98>
80005356:	11 8c       	ld.ub	r12,r8[0x0]
80005358:	f0 1f 00 18 	mcall	800053b8 <file_open+0x9c>
8000535c:	c0 a0       	breq	80005370 <file_open+0x54>
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
8000535e:	31 49       	mov	r9,20
80005360:	49 48       	lddpc	r8,800053b0 <file_open+0x94>
80005362:	b0 89       	st.b	r8[0x0],r9
80005364:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
80005368:	30 0c       	mov	r12,0
8000536a:	f0 1f 00 10 	mcall	800053a8 <file_open+0x8c>
8000536e:	c1 60       	breq	8000539a <file_open+0x7e>
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
80005370:	0c 98       	mov	r8,r6
80005372:	e2 18 00 04 	andl	r8,0x4,COH
80005376:	c0 40       	breq	8000537e <file_open+0x62>
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
80005378:	30 09       	mov	r9,0
8000537a:	48 d8       	lddpc	r8,800053ac <file_open+0x90>
8000537c:	91 29       	st.w	r8[0x8],r9
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
8000537e:	e2 16 00 08 	andl	r6,0x8,COH
80005382:	c0 50       	breq	8000538c <file_open+0x70>
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
80005384:	30 09       	mov	r9,0
80005386:	48 a8       	lddpc	r8,800053ac <file_open+0x90>
80005388:	91 39       	st.w	r8[0xc],r9
8000538a:	c0 48       	rjmp	80005392 <file_open+0x76>
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
8000538c:	48 88       	lddpc	r8,800053ac <file_open+0x90>
8000538e:	70 29       	ld.w	r9,r8[0x8]
80005390:	91 39       	st.w	r8[0xc],r9
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
80005392:	48 78       	lddpc	r8,800053ac <file_open+0x90>
80005394:	b0 87       	st.b	r8[0x0],r7
80005396:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   return true;
8000539a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000539e:	00 00       	add	r0,r0
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	4d ec       	lddpc	r12,80005518 <nav_file_getname+0xc>
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	3b 78       	mov	r8,-73
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	43 34       	lddsp	r4,sp[0xcc]
800053ac:	00 00       	add	r0,r0
800053ae:	0a 70       	tst	r0,r5
800053b0:	00 00       	add	r0,r0
800053b2:	0d 00       	ld.w	r0,r6++
800053b4:	00 00       	add	r0,r0
800053b6:	0c b0       	st.h	r6++,r0
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	5d 90       	*unknown*

800053bc <nav_drive_get>:
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
800053bc:	48 28       	lddpc	r8,800053c4 <nav_drive_get+0x8>
800053be:	11 8c       	ld.ub	r12,r8[0x0]
800053c0:	5e fc       	retal	r12
800053c2:	00 00       	add	r0,r0
800053c4:	00 00       	add	r0,r0
800053c6:	0c b0       	st.h	r6++,r0

800053c8 <nav_drive_getname>:
//! @return    'A','B',...
//! @return    'X', in case of no drive selected
//!
uint8_t    nav_drive_getname( void )
{
   if(0xFF == fs_g_nav.u8_lun)
800053c8:	48 68       	lddpc	r8,800053e0 <nav_drive_getname+0x18>
800053ca:	11 8c       	ld.ub	r12,r8[0x0]
800053cc:	3f f8       	mov	r8,-1
800053ce:	f0 0c 18 00 	cp.b	r12,r8
800053d2:	c0 31       	brne	800053d8 <nav_drive_getname+0x10>
800053d4:	35 8c       	mov	r12,88
800053d6:	5e fc       	retal	r12
      return 'X';
#if (FS_MULTI_PARTITION  ==  true)
   return ('A' + (fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return ('A' + fs_g_nav.u8_lun);
800053d8:	2b fc       	sub	r12,-65
800053da:	5c 5c       	castu.b	r12
#endif
}
800053dc:	5e fc       	retal	r12
800053de:	00 00       	add	r0,r0
800053e0:	00 00       	add	r0,r0
800053e2:	0c b0       	st.h	r6++,r0

800053e4 <nav_filelist_get>:
//! @return    FS_NO_SEL, in case of no file selected
//!
uint16_t   nav_filelist_get( void )
{
   return fs_g_nav.u16_pos_sel_file;
}
800053e4:	48 28       	lddpc	r8,800053ec <nav_filelist_get+0x8>
800053e6:	f1 0c 00 24 	ld.sh	r12,r8[36]
800053ea:	5e fc       	retal	r12
800053ec:	00 00       	add	r0,r0
800053ee:	0c b0       	st.h	r6++,r0

800053f0 <nav_file_checkext>:
//!
//! @return    true, the file extension match with extension filter
//! @return    false, in other case
//!
bool  nav_file_checkext( const FS_STRING sz_filterext )
{
800053f0:	eb cd 40 80 	pushm	r7,lr
800053f4:	18 97       	mov	r7,r12
   if ( fat_check_mount_select() )
800053f6:	f0 1f 00 07 	mcall	80005410 <nav_file_checkext+0x20>
800053fa:	c0 90       	breq	8000540c <nav_file_checkext+0x1c>
   {
      // Read selected entry (=short name entry) in directory
      if ( fat_read_dir())
800053fc:	f0 1f 00 06 	mcall	80005414 <nav_file_checkext+0x24>
80005400:	c0 60       	breq	8000540c <nav_file_checkext+0x1c>
      {
         // Check the extension with filter
         if ( fat_entry_checkext( (FS_STRING) sz_filterext ) )
80005402:	0e 9c       	mov	r12,r7
80005404:	f0 1f 00 05 	mcall	80005418 <nav_file_checkext+0x28>
80005408:	e3 cd 80 80 	ldm	sp++,r7,pc
8000540c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	4d b0       	lddpc	r0,8000557c <nav_filelist_set+0x60>
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	4b 24       	lddpc	r4,800054dc <nav_file_name+0xb4>
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	41 c0       	lddsp	r0,sp[0x70]

8000541c <nav_file_isdir>:
//!
//! @return    true, it is a directory
//! @return    false, in other case
//!
bool  nav_file_isdir( void )
{
8000541c:	d4 01       	pushm	lr
   return fat_entry_is_dir();
8000541e:	f0 1f 00 02 	mcall	80005424 <nav_file_isdir+0x8>
}
80005422:	d8 02       	popm	pc
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	3e 48       	mov	r8,-28

80005428 <nav_file_name>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_file_name( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case  )
{
80005428:	d4 31       	pushm	r0-r7,lr
8000542a:	20 1d       	sub	sp,4
8000542c:	18 95       	mov	r5,r12
8000542e:	16 96       	mov	r6,r11
80005430:	14 97       	mov	r7,r10
80005432:	12 93       	mov	r3,r9
   _MEM_TYPE_SLOW_   uint16_t u16_lgt;   // Only used if LENGTH string mode enabled
   uint16_t  u16_ptr_save_entry;
   bool  b_readshortname = false;

   if ( !fat_check_mount_select())
80005434:	f0 1f 00 2f 	mcall	800054f0 <nav_file_name+0xc8>
80005438:	c5 80       	breq	800054e8 <nav_file_name+0xc0>
      return false;

   // Check if the string size is not 0
   if( (FS_NAME_GET == b_mode)
8000543a:	58 07       	cp.w	r7,0
8000543c:	c0 50       	breq	80005446 <nav_file_name+0x1e>
8000543e:	58 06       	cp.w	r6,0
80005440:	c0 31       	brne	80005446 <nav_file_name+0x1e>
80005442:	30 1c       	mov	r12,1
80005444:	c5 38       	rjmp	800054ea <nav_file_name+0xc2>
   {
      return true;
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
80005446:	4a c8       	lddpc	r8,800054f4 <nav_file_name+0xcc>
80005448:	90 14       	ld.sh	r4,r8[0x2]
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000544a:	58 04       	cp.w	r4,0
8000544c:	c0 31       	brne	80005452 <nav_file_name+0x2a>
8000544e:	30 10       	mov	r0,1
80005450:	c0 68       	rjmp	8000545c <nav_file_name+0x34>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80005452:	08 99       	mov	r9,r4
80005454:	20 19       	sub	r9,1
80005456:	4a 88       	lddpc	r8,800054f4 <nav_file_name+0xcc>
80005458:	b0 19       	st.h	r8[0x2],r9
8000545a:	30 00       	mov	r0,0
8000545c:	30 09       	mov	r9,0
8000545e:	50 09       	stdsp	sp[0x0],r9
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
80005460:	31 01       	mov	r1,16
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80005462:	4a 52       	lddpc	r2,800054f4 <nav_file_name+0xcc>
80005464:	c0 28       	rjmp	80005468 <nav_file_name+0x40>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80005466:	30 10       	mov	r0,1

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
80005468:	f0 1f 00 24 	mcall	800054f8 <nav_file_name+0xd0>
8000546c:	c3 e0       	breq	800054e8 <nav_file_name+0xc0>
         break; // error

      if ( b_readshortname )
8000546e:	58 00       	cp.w	r0,0
80005470:	c0 70       	breq	8000547e <nav_file_name+0x56>
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
80005472:	0e 9a       	mov	r10,r7
80005474:	0c 9b       	mov	r11,r6
80005476:	0a 9c       	mov	r12,r5
80005478:	f0 1f 00 21 	mcall	800054fc <nav_file_name+0xd4>
8000547c:	c3 78       	rjmp	800054ea <nav_file_name+0xc2>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
8000547e:	06 99       	mov	r9,r3
80005480:	0e 9a       	mov	r10,r7
80005482:	0c 9b       	mov	r11,r6
80005484:	0a 9c       	mov	r12,r5
80005486:	f0 1f 00 1f 	mcall	80005500 <nav_file_name+0xd8>
8000548a:	c1 20       	breq	800054ae <nav_file_name+0x86>
      {
         if( g_b_string_length )
8000548c:	49 e8       	lddpc	r8,80005504 <nav_file_name+0xdc>
8000548e:	11 89       	ld.ub	r9,r8[0x0]
80005490:	30 08       	mov	r8,0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
80005492:	f0 09 18 00 	cp.b	r9,r8
80005496:	eb f8 12 00 	ld.shne	r8,r5[0x0]
8000549a:	fb f9 10 00 	ld.wne	r9,sp[0x0]
8000549e:	f1 d9 e1 08 	addne	r8,r8,r9
800054a2:	eb f8 1c 00 	st.hne	r5[0x0],r8
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
800054a6:	49 48       	lddpc	r8,800054f4 <nav_file_name+0xcc>
800054a8:	b0 14       	st.h	r8[0x2],r4
800054aa:	30 1c       	mov	r12,1
         return true;
800054ac:	c1 f8       	rjmp	800054ea <nav_file_name+0xc2>
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
800054ae:	49 79       	lddpc	r9,80005508 <nav_file_name+0xe0>
800054b0:	13 88       	ld.ub	r8,r9[0x0]
800054b2:	e2 08 18 00 	cp.b	r8,r1
800054b6:	c0 70       	breq	800054c4 <nav_file_name+0x9c>
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
800054b8:	a4 14       	st.h	r2[0x2],r4

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
800054ba:	30 b9       	mov	r9,11
800054bc:	f2 08 18 00 	cp.b	r8,r9
800054c0:	c1 41       	brne	800054e8 <nav_file_name+0xc0>
800054c2:	cd 2b       	rjmp	80005466 <nav_file_name+0x3e>
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
800054c4:	49 09       	lddpc	r9,80005504 <nav_file_name+0xdc>
800054c6:	13 88       	ld.ub	r8,r9[0x0]
800054c8:	30 09       	mov	r9,0
800054ca:	f2 08 18 00 	cp.b	r8,r9
800054ce:	c0 60       	breq	800054da <nav_file_name+0xb2>
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
800054d0:	40 08       	lddsp	r8,sp[0x0]
800054d2:	2f 38       	sub	r8,-13
800054d4:	5c 88       	casts.h	r8
800054d6:	50 08       	stdsp	sp[0x0],r8
800054d8:	c0 48       	rjmp	800054e0 <nav_file_name+0xb8>
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
800054da:	2f 35       	sub	r5,-13
         u8_size_max -= FS_SIZE_LFN_ENTRY;
800054dc:	20 d6       	sub	r6,13
800054de:	5c 56       	castu.b	r6
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
800054e0:	84 18       	ld.sh	r8,r2[0x2]
800054e2:	20 18       	sub	r8,1
800054e4:	a4 18       	st.h	r2[0x2],r8
800054e6:	cc 1b       	rjmp	80005468 <nav_file_name+0x40>
800054e8:	30 0c       	mov	r12,0

   }  // end of loop while(1)
   return false;
}
800054ea:	2f fd       	sub	sp,-4
800054ec:	d8 32       	popm	r0-r7,pc
800054ee:	00 00       	add	r0,r0
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	4d b0       	lddpc	r0,8000565c <nav_filelist_set+0x140>
800054f4:	00 00       	add	r0,r0
800054f6:	0c fc       	st.b	--r6,r12
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	4b 24       	lddpc	r4,800055c0 <nav_filelist_set+0xa4>
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	40 70       	lddsp	r0,sp[0x1c]
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	3e dc       	mov	r12,-19
80005504:	00 00       	add	r0,r0
80005506:	0d 01       	ld.w	r1,r6++
80005508:	00 00       	add	r0,r0
8000550a:	0d 00       	ld.w	r0,r6++

8000550c <nav_file_getname>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool nav_file_getname( FS_STRING sz_name, uint8_t u8_size_max )
{
8000550c:	d4 01       	pushm	lr
   return nav_file_name( sz_name, u8_size_max, FS_NAME_GET, false );
8000550e:	30 09       	mov	r9,0
80005510:	30 1a       	mov	r10,1
80005512:	f0 1f 00 02 	mcall	80005518 <nav_file_getname+0xc>
}
80005516:	d8 02       	popm	pc
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	54 28       	stdsp	sp[0x108],r8

8000551c <nav_filelist_set>:
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
8000551c:	d4 31       	pushm	r0-r7,lr
8000551e:	20 4d       	sub	sp,16
80005520:	50 0c       	stdsp	sp[0x0],r12
80005522:	16 92       	mov	r2,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
80005524:	f0 1f 00 51 	mcall	80005668 <nav_filelist_set+0x14c>
80005528:	e0 80 00 9e 	breq	80005664 <nav_filelist_set+0x148>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
8000552c:	4d 08       	lddpc	r8,8000566c <nav_filelist_set+0x150>
8000552e:	90 18       	ld.sh	r8,r8[0x2]
80005530:	50 28       	stdsp	sp[0x8],r8
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
80005532:	4d 08       	lddpc	r8,80005670 <nav_filelist_set+0x154>
80005534:	f1 0a 00 24 	ld.sh	r10,r8[36]
80005538:	50 1a       	stdsp	sp[0x4],r10
   b_save_entry_type       = fs_g_nav.b_mode_nav;
8000553a:	f1 38 00 2c 	ld.ub	r8,r8[44]
8000553e:	50 38       	stdsp	sp[0xc],r8
80005540:	30 03       	mov	r3,0
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
80005542:	4c b7       	lddpc	r7,8000566c <nav_filelist_set+0x150>
80005544:	3f f0       	mov	r0,-1
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
80005546:	4c b6       	lddpc	r6,80005670 <nav_filelist_set+0x154>
80005548:	30 04       	mov	r4,0
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000554a:	3f e1       	mov	r1,-2
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
8000554c:	4c a5       	lddpc	r5,80005674 <nav_filelist_set+0x158>
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000554e:	58 02       	cp.w	r2,0
80005550:	c0 31       	brne	80005556 <nav_filelist_set+0x3a>
80005552:	58 03       	cp.w	r3,0
80005554:	c0 c0       	breq	8000556c <nav_filelist_set+0x50>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
80005556:	8e 18       	ld.sh	r8,r7[0x2]
80005558:	e2 08 19 00 	cp.h	r8,r1
8000555c:	c0 51       	brne	80005566 <nav_filelist_set+0x4a>
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
8000555e:	30 89       	mov	r9,8
80005560:	4c 58       	lddpc	r8,80005674 <nav_filelist_set+0x158>
80005562:	b0 89       	st.b	r8[0x0],r9
            break;
80005564:	c7 38       	rjmp	8000564a <nav_filelist_set+0x12e>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
80005566:	2f f8       	sub	r8,-1
80005568:	ae 18       	st.h	r7[0x2],r8
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000556a:	c1 d8       	rjmp	800055a4 <nav_filelist_set+0x88>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
8000556c:	8e 18       	ld.sh	r8,r7[0x2]
8000556e:	e0 08 19 00 	cp.h	r8,r0
80005572:	c0 51       	brne	8000557c <nav_filelist_set+0x60>
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
80005574:	30 99       	mov	r9,9
80005576:	4c 08       	lddpc	r8,80005674 <nav_filelist_set+0x158>
80005578:	b0 89       	st.b	r8[0x0],r9
            break;
8000557a:	c6 88       	rjmp	8000564a <nav_filelist_set+0x12e>
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000557c:	58 08       	cp.w	r8,0
8000557e:	c1 11       	brne	800055a0 <nav_filelist_set+0x84>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
80005580:	ed 38 00 2c 	ld.ub	r8,r6[44]
80005584:	e8 08 18 00 	cp.b	r8,r4
80005588:	c0 80       	breq	80005598 <nav_filelist_set+0x7c>
8000558a:	ed 38 00 2d 	ld.ub	r8,r6[45]
8000558e:	e8 08 18 00 	cp.b	r8,r4
80005592:	c0 31       	brne	80005598 <nav_filelist_set+0x7c>
80005594:	30 13       	mov	r3,1
80005596:	c0 78       	rjmp	800055a4 <nav_filelist_set+0x88>
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
80005598:	30 99       	mov	r9,9
8000559a:	4b 78       	lddpc	r8,80005674 <nav_filelist_set+0x158>
8000559c:	b0 89       	st.b	r8[0x0],r9
               break;
8000559e:	c5 68       	rjmp	8000564a <nav_filelist_set+0x12e>
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
800055a0:	20 18       	sub	r8,1
800055a2:	ae 18       	st.h	r7[0x2],r8
         }
      }

      if( !fat_read_dir())
800055a4:	f0 1f 00 35 	mcall	80005678 <nav_filelist_set+0x15c>
800055a8:	c0 71       	brne	800055b6 <nav_filelist_set+0x9a>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
800055aa:	0b 89       	ld.ub	r9,r5[0x0]
800055ac:	31 a8       	mov	r8,26
800055ae:	f0 09 18 00 	cp.b	r9,r8
800055b2:	c3 20       	breq	80005616 <nav_filelist_set+0xfa>
800055b4:	c4 b8       	rjmp	8000564a <nav_filelist_set+0x12e>
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
800055b6:	ed 38 00 2c 	ld.ub	r8,r6[44]
800055ba:	e8 08 18 00 	cp.b	r8,r4
800055be:	5f 1c       	srne	r12
800055c0:	f0 1f 00 2f 	mcall	8000567c <nav_filelist_set+0x160>
800055c4:	c1 c0       	breq	800055fc <nav_filelist_set+0xe0>
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
800055c6:	58 03       	cp.w	r3,0
800055c8:	cc 31       	brne	8000554e <nav_filelist_set+0x32>
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
800055ca:	58 02       	cp.w	r2,0
800055cc:	ed f8 12 12 	ld.shne	r8,r6[0x24]
800055d0:	f7 b8 01 ff 	subne	r8,-1
800055d4:	ed f8 1c 12 	st.hne	r6[0x24],r8
           else
              fs_g_nav.u16_pos_sel_file--;
800055d8:	ed f8 02 12 	ld.sheq	r8,r6[0x24]
800055dc:	f7 b8 00 01 	subeq	r8,1
800055e0:	ed f8 0c 12 	st.heq	r6[0x24],r8

           if (0 == u16_nb)
800055e4:	40 09       	lddsp	r9,sp[0x0]
800055e6:	58 09       	cp.w	r9,0
800055e8:	c0 51       	brne	800055f2 <nav_filelist_set+0xd6>
           {
              // It is the end of move then update file information
              fat_get_entry_info();
800055ea:	f0 1f 00 26 	mcall	80005680 <nav_filelist_set+0x164>
800055ee:	30 1c       	mov	r12,1
              return true;         // NB FILE FIND
800055f0:	c3 a8       	rjmp	80005664 <nav_filelist_set+0x148>
           }
           u16_nb--;
800055f2:	40 08       	lddsp	r8,sp[0x0]
800055f4:	20 18       	sub	r8,1
800055f6:	5c 88       	casts.h	r8
800055f8:	50 08       	stdsp	sp[0x0],r8
           continue;
800055fa:	ca ab       	rjmp	8000554e <nav_filelist_set+0x32>
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
800055fc:	0b 88       	ld.ub	r8,r5[0x0]
800055fe:	30 a9       	mov	r9,10
80005600:	f2 08 18 00 	cp.b	r8,r9
80005604:	5f 09       	sreq	r9
80005606:	31 aa       	mov	r10,26
80005608:	f4 08 18 00 	cp.b	r8,r10
8000560c:	5f 08       	sreq	r8
8000560e:	10 49       	or	r9,r8
80005610:	e8 09 18 00 	cp.b	r9,r4
80005614:	c9 d0       	breq	8000554e <nav_filelist_set+0x32>
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
80005616:	58 03       	cp.w	r3,0
80005618:	c0 50       	breq	80005622 <nav_filelist_set+0x106>
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
8000561a:	ed 64 00 2c 	st.b	r6[44],r4
8000561e:	30 03       	mov	r3,0
            continue;
80005620:	c9 7b       	rjmp	8000554e <nav_filelist_set+0x32>
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
80005622:	ed 38 00 2c 	ld.ub	r8,r6[44]
80005626:	30 1a       	mov	r10,1
80005628:	f4 08 18 00 	cp.b	r8,r10
8000562c:	c0 60       	breq	80005638 <nav_filelist_set+0x11c>
8000562e:	ed 38 00 2d 	ld.ub	r8,r6[45]
80005632:	e8 08 18 00 	cp.b	r8,r4
80005636:	c0 50       	breq	80005640 <nav_filelist_set+0x124>
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
80005638:	30 99       	mov	r9,9
8000563a:	48 f8       	lddpc	r8,80005674 <nav_filelist_set+0x158>
8000563c:	b0 89       	st.b	r8[0x0],r9
            break;                        // end of search
8000563e:	c0 68       	rjmp	8000564a <nav_filelist_set+0x12e>
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
80005640:	ae 10       	st.h	r7[0x2],r0
            fs_g_nav.b_mode_nav = FS_FILE;
80005642:	30 19       	mov	r9,1
80005644:	ed 69 00 2c 	st.b	r6[44],r9
80005648:	c8 3b       	rjmp	8000554e <nav_filelist_set+0x32>
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
8000564a:	48 a8       	lddpc	r8,80005670 <nav_filelist_set+0x154>
8000564c:	40 3a       	lddsp	r10,sp[0xc]
8000564e:	58 0a       	cp.w	r10,0
80005650:	5f 19       	srne	r9
80005652:	f1 69 00 2c 	st.b	r8[44],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
80005656:	48 69       	lddpc	r9,8000566c <nav_filelist_set+0x150>
80005658:	40 2a       	lddsp	r10,sp[0x8]
8000565a:	b2 1a       	st.h	r9[0x2],r10
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
8000565c:	40 19       	lddsp	r9,sp[0x4]
8000565e:	f1 59 00 24 	st.h	r8[36],r9
80005662:	30 0c       	mov	r12,0
   return false;
}
80005664:	2f cd       	sub	sp,-16
80005666:	d8 32       	popm	r0-r7,pc
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	4e 10       	lddpc	r0,800057ec <nav_dir_name+0xb0>
8000566c:	00 00       	add	r0,r0
8000566e:	0c fc       	st.b	--r6,r12
80005670:	00 00       	add	r0,r0
80005672:	0c b0       	st.h	r6++,r0
80005674:	00 00       	add	r0,r0
80005676:	0d 00       	ld.w	r0,r6++
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	4b 24       	lddpc	r4,80005740 <nav_dir_name+0x4>
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	42 60       	lddsp	r0,sp[0x98]
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	41 78       	lddsp	r8,sp[0x5c]

80005684 <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
80005684:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
80005686:	f0 1f 00 04 	mcall	80005694 <nav_filelist_reset+0x10>
8000568a:	c0 40       	breq	80005692 <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000568c:	f0 1f 00 03 	mcall	80005698 <nav_filelist_reset+0x14>
80005690:	30 1c       	mov	r12,1
   return true;
}
80005692:	d8 02       	popm	pc
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	4e 10       	lddpc	r0,80005818 <nav_dir_name+0xdc>
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	3e 60       	mov	r0,-26

8000569c <nav_dir_gotoparent>:
//! After, the file list changes and contains the files and directories of the new directory.
//! By default, the file selected in file list is the previous (children) directory.
//! @endverbatim
//!
bool  nav_dir_gotoparent( void )
{
8000569c:	d4 21       	pushm	r4-r7,lr
   uint32_t u32_cluster_old_dir;

   if (!fat_check_mount_noopen())
8000569e:	f0 1f 00 1f 	mcall	80005718 <nav_dir_gotoparent+0x7c>
800056a2:	c3 80       	breq	80005712 <nav_dir_gotoparent+0x76>
      return false;

   if (0 == fs_g_nav.u32_cluster_sel_dir)
800056a4:	49 e8       	lddpc	r8,8000571c <nav_dir_gotoparent+0x80>
800056a6:	70 88       	ld.w	r8,r8[0x20]
800056a8:	58 08       	cp.w	r8,0
800056aa:	c0 51       	brne	800056b4 <nav_dir_gotoparent+0x18>
   {
      fs_g_status = FS_ERR_IS_ROOT;        // There aren't parent
800056ac:	31 99       	mov	r9,25
800056ae:	49 d8       	lddpc	r8,80005720 <nav_dir_gotoparent+0x84>
800056b0:	b0 89       	st.b	r8[0x0],r9
800056b2:	d8 2a       	popm	r4-r7,pc,r12=0
      return false;
   }

   // Select and read information about directory ".."
   fs_g_nav_fast.u16_entry_pos_sel_file = 1;
800056b4:	30 19       	mov	r9,1
800056b6:	49 c8       	lddpc	r8,80005724 <nav_dir_gotoparent+0x88>
800056b8:	b0 19       	st.h	r8[0x2],r9
   if ( !fat_read_dir())
800056ba:	f0 1f 00 1c 	mcall	80005728 <nav_dir_gotoparent+0x8c>
800056be:	c2 a0       	breq	80005712 <nav_dir_gotoparent+0x76>
      return false;
   fat_get_entry_info();
800056c0:	f0 1f 00 1b 	mcall	8000572c <nav_dir_gotoparent+0x90>
   // Save the children directory cluster
   u32_cluster_old_dir = fs_g_nav.u32_cluster_sel_dir;
800056c4:	49 68       	lddpc	r8,8000571c <nav_dir_gotoparent+0x80>
800056c6:	70 87       	ld.w	r7,r8[0x20]

   // Select the parent directory via information present in the current directory ".."
   fs_g_nav.u32_cluster_sel_dir = fs_g_nav_entry.u32_cluster;
800056c8:	49 a9       	lddpc	r9,80005730 <nav_dir_gotoparent+0x94>
800056ca:	72 19       	ld.w	r9,r9[0x4]
800056cc:	91 89       	st.w	r8[0x20],r9

   // Select the children directory in new directory (=parent directory)
   if( false == nav_filelist_reset())
800056ce:	f0 1f 00 1a 	mcall	80005734 <nav_dir_gotoparent+0x98>
800056d2:	c2 00       	breq	80005712 <nav_dir_gotoparent+0x76>
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
800056d4:	49 28       	lddpc	r8,8000571c <nav_dir_gotoparent+0x80>
800056d6:	f1 39 00 2d 	ld.ub	r9,r8[45]
800056da:	30 08       	mov	r8,0
800056dc:	f0 09 18 00 	cp.b	r9,r8
800056e0:	c0 d0       	breq	800056fa <nav_dir_gotoparent+0x5e>
800056e2:	48 f8       	lddpc	r8,8000571c <nav_dir_gotoparent+0x80>
800056e4:	f1 39 00 2c 	ld.ub	r9,r8[44]
800056e8:	30 08       	mov	r8,0
800056ea:	f0 09 18 00 	cp.b	r9,r8
800056ee:	c0 60       	breq	800056fa <nav_dir_gotoparent+0x5e>
800056f0:	c1 28       	rjmp	80005714 <nav_dir_gotoparent+0x78>
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
800056f2:	6c 18       	ld.w	r8,r6[0x4]
800056f4:	0e 38       	cp.w	r8,r7
800056f6:	c0 51       	brne	80005700 <nav_dir_gotoparent+0x64>
800056f8:	c0 e8       	rjmp	80005714 <nav_dir_gotoparent+0x78>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800056fa:	30 15       	mov	r5,1
800056fc:	30 04       	mov	r4,0
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
800056fe:	48 d6       	lddpc	r6,80005730 <nav_dir_gotoparent+0x94>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005700:	0a 9b       	mov	r11,r5
80005702:	08 9c       	mov	r12,r4
80005704:	f0 1f 00 0d 	mcall	80005738 <nav_dir_gotoparent+0x9c>
80005708:	cf 51       	brne	800056f2 <nav_dir_gotoparent+0x56>
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
         return true;         // It is the children directory
   }
   fs_g_status = FS_ERR_FS;
8000570a:	30 89       	mov	r9,8
8000570c:	48 58       	lddpc	r8,80005720 <nav_dir_gotoparent+0x84>
8000570e:	b0 89       	st.b	r8[0x0],r9
   return false;
80005710:	d8 22       	popm	r4-r7,pc
80005712:	d8 2a       	popm	r4-r7,pc,r12=0
80005714:	da 2a       	popm	r4-r7,pc,r12=1
80005716:	00 00       	add	r0,r0
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	4e 10       	lddpc	r0,8000589c <nav_filelist_nb+0x1c>
8000571c:	00 00       	add	r0,r0
8000571e:	0c b0       	st.h	r6++,r0
80005720:	00 00       	add	r0,r0
80005722:	0d 00       	ld.w	r0,r6++
80005724:	00 00       	add	r0,r0
80005726:	0c fc       	st.b	--r6,r12
80005728:	80 00       	ld.sh	r0,r0[0x0]
8000572a:	4b 24       	lddpc	r4,800057f0 <nav_dir_name+0xb4>
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	41 78       	lddsp	r8,sp[0x5c]
80005730:	00 00       	add	r0,r0
80005732:	0a 70       	tst	r0,r5
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	56 84       	stdsp	sp[0x1a0],r4
80005738:	80 00       	ld.sh	r0,r0[0x0]
8000573a:	55 1c       	stdsp	sp[0x144],r12

8000573c <nav_dir_name>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_dir_name( FS_STRING sz_path  , uint8_t u8_size_max  )
{
8000573c:	d4 31       	pushm	r0-r7,lr
8000573e:	20 2d       	sub	sp,8
80005740:	18 96       	mov	r6,r12
80005742:	16 95       	mov	r5,r11
   uint32_t save_u32_cluster      ;
   uint32_t save_u32_size         ;
   bool b_mode_nav_single_save;
   bool b_mode_nav_mode_save;

   if ( !fat_check_mount_noopen())
80005744:	f0 1f 00 37 	mcall	80005820 <nav_dir_name+0xe4>
80005748:	c6 a0       	breq	8000581c <nav_dir_name+0xe0>
      return false;

   if (0 != fs_g_nav.u32_cluster_sel_dir)
8000574a:	4b 78       	lddpc	r8,80005824 <nav_dir_name+0xe8>
8000574c:	70 87       	ld.w	r7,r8[0x20]
8000574e:	58 07       	cp.w	r7,0
80005750:	c3 b0       	breq	800057c6 <nav_dir_name+0x8a>
   {
      // Save context
      save_u16_entry_pos_sel_file= fs_g_nav_fast.u16_entry_pos_sel_file;
80005752:	4b 68       	lddpc	r8,80005828 <nav_dir_name+0xec>
80005754:	90 11       	ld.sh	r1,r8[0x2]
      save_u32_cluster_sel_dir   = fs_g_nav.u32_cluster_sel_dir        ;
      save_u8_attr               = fs_g_nav_entry.u8_attr              ;
80005756:	4b 68       	lddpc	r8,8000582c <nav_dir_name+0xf0>
80005758:	11 a0       	ld.ub	r0,r8[0x2]
      save_u32_cluster           = fs_g_nav_entry.u32_cluster          ;
8000575a:	70 19       	ld.w	r9,r8[0x4]
8000575c:	50 19       	stdsp	sp[0x4],r9
      save_u32_size              = fs_g_nav_entry.u32_size             ;
8000575e:	70 28       	ld.w	r8,r8[0x8]
80005760:	50 08       	stdsp	sp[0x0],r8
      b_mode_nav_single_save = fs_g_nav.b_mode_nav_single;
80005762:	4b 18       	lddpc	r8,80005824 <nav_dir_name+0xe8>
80005764:	f1 3a 00 2d 	ld.ub	r10,r8[45]
80005768:	30 09       	mov	r9,0
8000576a:	f2 0a 18 00 	cp.b	r10,r9
8000576e:	5f 14       	srne	r4
      b_mode_nav_mode_save   = fs_g_nav.b_mode_nav;
80005770:	f1 3a 00 2c 	ld.ub	r10,r8[44]
80005774:	f2 0a 18 00 	cp.b	r10,r9
80005778:	5f 13       	srne	r3
      fs_g_nav.b_mode_nav_single = true;
8000577a:	30 19       	mov	r9,1
8000577c:	f1 69 00 2d 	st.b	r8[45],r9
      fs_g_nav.b_mode_nav = FS_FILE;
80005780:	f1 69 00 2c 	st.b	r8[44],r9
      // Go to parent directory and select the children directory
      if( !nav_dir_gotoparent() )
80005784:	f0 1f 00 2b 	mcall	80005830 <nav_dir_name+0xf4>
80005788:	c0 71       	brne	80005796 <nav_dir_name+0x5a>
      {
         fs_g_nav.b_mode_nav_single = b_mode_nav_single_save;
8000578a:	4a 78       	lddpc	r8,80005824 <nav_dir_name+0xe8>
8000578c:	f1 64 00 2d 	st.b	r8[45],r4
         fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
80005790:	f1 63 00 2c 	st.b	r8[44],r3
         return false;
80005794:	c4 48       	rjmp	8000581c <nav_dir_name+0xe0>
      }
      fs_g_nav.b_mode_nav_single = b_mode_nav_single_save ;
80005796:	4a 42       	lddpc	r2,80005824 <nav_dir_name+0xe8>
80005798:	e5 64 00 2d 	st.b	r2[45],r4
      fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
8000579c:	e5 63 00 2c 	st.b	r2[44],r3
      // Go to directory name position
      fs_g_nav_fast.u16_entry_pos_sel_file = fs_g_nav.u16_entry_pos_sel_dir;
800057a0:	4a 24       	lddpc	r4,80005828 <nav_dir_name+0xec>
800057a2:	e5 08 00 1c 	ld.sh	r8,r2[28]
800057a6:	a8 18       	st.h	r4[0x2],r8
      status = nav_file_name( sz_path  , u8_size_max , FS_NAME_GET , false  );
800057a8:	30 09       	mov	r9,0
800057aa:	30 1a       	mov	r10,1
800057ac:	0a 9b       	mov	r11,r5
800057ae:	0c 9c       	mov	r12,r6
800057b0:	f0 1f 00 21 	mcall	80005834 <nav_dir_name+0xf8>
      // Restore previous context
      fs_g_nav_fast.u16_entry_pos_sel_file= save_u16_entry_pos_sel_file;
800057b4:	a8 11       	st.h	r4[0x2],r1
      fs_g_nav.u32_cluster_sel_dir        = save_u32_cluster_sel_dir   ;
800057b6:	85 87       	st.w	r2[0x20],r7
      fs_g_nav_entry.u8_attr              = save_u8_attr               ;
800057b8:	49 d8       	lddpc	r8,8000582c <nav_dir_name+0xf0>
800057ba:	b0 a0       	st.b	r8[0x2],r0
      fs_g_nav_entry.u32_cluster          = save_u32_cluster           ;
800057bc:	40 19       	lddsp	r9,sp[0x4]
800057be:	91 19       	st.w	r8[0x4],r9
      fs_g_nav_entry.u32_size             = save_u32_size              ;
800057c0:	40 09       	lddsp	r9,sp[0x0]
800057c2:	91 29       	st.w	r8[0x8],r9
800057c4:	c2 c8       	rjmp	8000581c <nav_dir_name+0xe0>
   }
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
800057c6:	49 d8       	lddpc	r8,80005838 <nav_dir_name+0xfc>
800057c8:	11 89       	ld.ub	r9,r8[0x0]
800057ca:	30 08       	mov	r8,0
800057cc:	f0 09 18 00 	cp.b	r9,r8
800057d0:	c0 50       	breq	800057da <nav_dir_name+0x9e>
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
800057d2:	30 38       	mov	r8,3
800057d4:	ac 08       	st.h	r6[0x0],r8
800057d6:	30 1c       	mov	r12,1
800057d8:	c2 28       	rjmp	8000581c <nav_dir_name+0xe0>
800057da:	2f f6       	sub	r6,-1
800057dc:	30 17       	mov	r7,1
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
800057de:	30 04       	mov	r4,0
800057e0:	30 15       	mov	r5,1
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
800057e2:	30 23       	mov	r3,2
800057e4:	c0 48       	rjmp	800057ec <nav_dir_name+0xb0>
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
800057e6:	2f f6       	sub	r6,-1
800057e8:	2f f7       	sub	r7,-1
800057ea:	5c 57       	castu.b	r7
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
800057ec:	0e 98       	mov	r8,r7
800057ee:	20 18       	sub	r8,1
800057f0:	e8 08 18 00 	cp.b	r8,r4
800057f4:	c0 e0       	breq	80005810 <nav_dir_name+0xd4>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
800057f6:	ea 08 18 00 	cp.b	r8,r5
800057fa:	f9 b8 00 3a 	moveq	r8,58
800057fe:	f9 b8 01 00 	movne	r8,0
80005802:	ed 68 ff ff 	st.b	r6[-1],r8
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
80005806:	e6 07 18 00 	cp.b	r7,r3
8000580a:	fe 98 ff ee 	brls	800057e6 <nav_dir_name+0xaa>
8000580e:	c0 68       	rjmp	8000581a <nav_dir_name+0xde>
      {
         switch( u8_i )
         {
            case 0:
            u8_character = nav_drive_getname();    // Letter
80005810:	f0 1f 00 0b 	mcall	8000583c <nav_dir_name+0x100>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
80005814:	ed 6c ff ff 	st.b	r6[-1],r12
80005818:	ce 7b       	rjmp	800057e6 <nav_dir_name+0xaa>
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
8000581a:	30 1c       	mov	r12,1
      }
      status = true;

   }
   return status;
}
8000581c:	2f ed       	sub	sp,-8
8000581e:	d8 32       	popm	r0-r7,pc
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	4e 10       	lddpc	r0,800059a4 <nav_partition_mount+0x28>
80005824:	00 00       	add	r0,r0
80005826:	0c b0       	st.h	r6++,r0
80005828:	00 00       	add	r0,r0
8000582a:	0c fc       	st.b	--r6,r12
8000582c:	00 00       	add	r0,r0
8000582e:	0a 70       	tst	r0,r5
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	56 9c       	stdsp	sp[0x1a4],r12
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	54 28       	stdsp	sp[0x108],r8
80005838:	00 00       	add	r0,r0
8000583a:	0d 01       	ld.w	r1,r6++
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	53 c8       	stdsp	sp[0xf0],r8

80005840 <nav_filelist_first>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_first( bool b_type )
{
80005840:	d4 21       	pushm	r4-r7,lr
80005842:	18 97       	mov	r7,r12
   // Reset position
   if ( !nav_filelist_reset())
80005844:	f0 1f 00 0b 	mcall	80005870 <nav_filelist_first+0x30>
80005848:	c0 71       	brne	80005856 <nav_filelist_first+0x16>
8000584a:	d8 22       	popm	r4-r7,pc
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000584c:	e9 38 00 2c 	ld.ub	r8,r4[44]
80005850:	10 37       	cp.w	r7,r8
80005852:	c0 51       	brne	8000585c <nav_filelist_first+0x1c>
80005854:	da 2a       	popm	r4-r7,pc,r12=1
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005856:	30 16       	mov	r6,1
80005858:	30 05       	mov	r5,0
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000585a:	48 74       	lddpc	r4,80005874 <nav_filelist_first+0x34>
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000585c:	0c 9b       	mov	r11,r6
8000585e:	0a 9c       	mov	r12,r5
80005860:	f0 1f 00 06 	mcall	80005878 <nav_filelist_first+0x38>
80005864:	cf 41       	brne	8000584c <nav_filelist_first+0xc>
   {
      if( b_type == fs_g_nav.b_mode_nav )
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
80005866:	30 99       	mov	r9,9
80005868:	48 58       	lddpc	r8,8000587c <nav_filelist_first+0x3c>
8000586a:	b0 89       	st.b	r8[0x0],r9
   return false;
}
8000586c:	d8 22       	popm	r4-r7,pc
8000586e:	00 00       	add	r0,r0
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	56 84       	stdsp	sp[0x1a0],r4
80005874:	00 00       	add	r0,r0
80005876:	0c b0       	st.h	r6++,r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	55 1c       	stdsp	sp[0x144],r12
8000587c:	00 00       	add	r0,r0
8000587e:	0d 00       	ld.w	r0,r6++

80005880 <nav_filelist_nb>:
//!                     FS_FILE to compute the number of files <br>
//!
//! @return    number of files or directories in file list
//!
uint16_t   nav_filelist_nb( bool b_type )
{
80005880:	d4 31       	pushm	r0-r7,lr
80005882:	18 90       	mov	r0,r12
   uint16_t   u16_save_position;
   uint16_t   u16_save_number_dir;
   uint16_t   u16_save_number_file;

   // Save current position
   u16_save_position = fs_g_nav.u16_pos_sel_file;
80005884:	49 88       	lddpc	r8,800058e4 <nav_filelist_nb+0x64>
80005886:	f1 01 00 24 	ld.sh	r1,r8[36]
   // Reset position
   if ( !nav_filelist_reset())
8000588a:	f0 1f 00 18 	mcall	800058e8 <nav_filelist_nb+0x68>
8000588e:	c0 31       	brne	80005894 <nav_filelist_nb+0x14>
80005890:	30 02       	mov	r2,0
80005892:	c2 68       	rjmp	800058de <nav_filelist_nb+0x5e>
80005894:	30 02       	mov	r2,0
80005896:	04 97       	mov	r7,r2
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005898:	30 14       	mov	r4,1
8000589a:	04 93       	mov	r3,r2
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
8000589c:	49 26       	lddpc	r6,800058e4 <nav_filelist_nb+0x64>
8000589e:	30 15       	mov	r5,1
800058a0:	c0 b8       	rjmp	800058b6 <nav_filelist_nb+0x36>
800058a2:	ed 38 00 2c 	ld.ub	r8,r6[44]
800058a6:	ea 08 18 00 	cp.b	r8,r5
800058aa:	c0 41       	brne	800058b2 <nav_filelist_nb+0x32>
         u16_save_number_file++;    // It is a file
800058ac:	2f f2       	sub	r2,-1
800058ae:	5c 82       	casts.h	r2
800058b0:	c0 38       	rjmp	800058b6 <nav_filelist_nb+0x36>
      else
         u16_save_number_dir++;     // It is a directory
800058b2:	2f f7       	sub	r7,-1
800058b4:	5c 87       	casts.h	r7
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800058b6:	08 9b       	mov	r11,r4
800058b8:	06 9c       	mov	r12,r3
800058ba:	f0 1f 00 0d 	mcall	800058ec <nav_filelist_nb+0x6c>
800058be:	cf 21       	brne	800058a2 <nav_filelist_nb+0x22>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
800058c0:	f0 1f 00 0a 	mcall	800058e8 <nav_filelist_nb+0x68>
   if ( u16_save_position != FS_NO_SEL )
800058c4:	3f f8       	mov	r8,-1
800058c6:	f0 01 19 00 	cp.h	r1,r8
800058ca:	c0 60       	breq	800058d6 <nav_filelist_nb+0x56>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
800058cc:	30 1b       	mov	r11,1
800058ce:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
800058d2:	f0 1f 00 07 	mcall	800058ec <nav_filelist_nb+0x6c>
   }
   // Return the value asked
   if( FS_FILE == b_type )
800058d6:	58 00       	cp.w	r0,0
800058d8:	c0 31       	brne	800058de <nav_filelist_nb+0x5e>
800058da:	0e 92       	mov	r2,r7
800058dc:	5c 82       	casts.h	r2
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
800058de:	04 9c       	mov	r12,r2
800058e0:	d8 32       	popm	r0-r7,pc
800058e2:	00 00       	add	r0,r0
800058e4:	00 00       	add	r0,r0
800058e6:	0c b0       	st.h	r6++,r0
800058e8:	80 00       	ld.sh	r0,r0[0x0]
800058ea:	56 84       	stdsp	sp[0x1a0],r4
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	55 1c       	stdsp	sp[0x144],r12

800058f0 <nav_filelist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filelist_goto( uint16_t u16_newpos )
{
800058f0:	eb cd 40 80 	pushm	r7,lr
800058f4:	18 97       	mov	r7,r12
   uint16_t u16_current_pos;

   if( FS_NO_SEL == u16_newpos )
800058f6:	3f f8       	mov	r8,-1
800058f8:	f0 0c 19 00 	cp.h	r12,r8
800058fc:	c0 51       	brne	80005906 <nav_filelist_goto+0x16>
      return nav_filelist_reset();
800058fe:	f0 1f 00 1d 	mcall	80005970 <nav_filelist_goto+0x80>
80005902:	e3 cd 80 80 	ldm	sp++,r7,pc

   u16_current_pos = nav_filelist_get();
80005906:	f0 1f 00 1c 	mcall	80005974 <nav_filelist_goto+0x84>
8000590a:	5c 8c       	casts.h	r12
   if( u16_newpos < (u16_current_pos/2) )
8000590c:	f1 dc c0 2f 	bfextu	r8,r12,0x1,0xf
80005910:	f0 07 19 00 	cp.h	r7,r8
80005914:	c0 62       	brcc	80005920 <nav_filelist_goto+0x30>
   {
      // Restart at the beginning of list to accelerate the search
      if( !nav_filelist_reset() )
80005916:	f0 1f 00 17 	mcall	80005970 <nav_filelist_goto+0x80>
8000591a:	c0 71       	brne	80005928 <nav_filelist_goto+0x38>
8000591c:	e3 cd 80 80 	ldm	sp++,r7,pc
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
80005920:	3f f8       	mov	r8,-1
80005922:	f0 0c 19 00 	cp.h	r12,r8
80005926:	c0 81       	brne	80005936 <nav_filelist_goto+0x46>
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
80005928:	30 1b       	mov	r11,1
8000592a:	0e 9c       	mov	r12,r7
8000592c:	5c 7c       	castu.h	r12
8000592e:	f0 1f 00 13 	mcall	80005978 <nav_filelist_goto+0x88>
80005932:	e3 cd 80 80 	ldm	sp++,r7,pc
   }
   else
   {
      if (u16_newpos < u16_current_pos)
80005936:	f8 07 19 00 	cp.h	r7,r12
8000593a:	c0 b2       	brcc	80005950 <nav_filelist_goto+0x60>
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
8000593c:	ee 07 11 ff 	rsub	r7,r7,-1
80005940:	ee 0c 00 0c 	add	r12,r7,r12
80005944:	30 0b       	mov	r11,0
80005946:	5c 7c       	castu.h	r12
80005948:	f0 1f 00 0c 	mcall	80005978 <nav_filelist_goto+0x88>
8000594c:	e3 cd 80 80 	ldm	sp++,r7,pc
      }
      if (u16_newpos > u16_current_pos)
80005950:	f8 07 19 00 	cp.h	r7,r12
80005954:	e0 8b 00 04 	brhi	8000595c <nav_filelist_goto+0x6c>
80005958:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      {
         return nav_filelist_set( u16_newpos -u16_current_pos - 1 , FS_FIND_NEXT );
8000595c:	20 17       	sub	r7,1
8000595e:	ee 0c 01 0c 	sub	r12,r7,r12
80005962:	30 1b       	mov	r11,1
80005964:	5c 7c       	castu.h	r12
80005966:	f0 1f 00 05 	mcall	80005978 <nav_filelist_goto+0x88>
      }
   }
   return true;
}
8000596a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000596e:	00 00       	add	r0,r0
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	56 84       	stdsp	sp[0x1a0],r4
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	53 e4       	stdsp	sp[0xf8],r4
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	55 1c       	stdsp	sp[0x144],r12

8000597c <nav_partition_mount>:
//! then the mount routine selects the first partition supported by file system. <br>
//! After mount, the file list contains files and directories of ROOT directory
//! @endverbatim
//!
bool  nav_partition_mount( void )
{
8000597c:	d4 01       	pushm	lr
   if ( !fat_check_noopen() )
8000597e:	f0 1f 00 0a 	mcall	800059a4 <nav_partition_mount+0x28>
80005982:	c0 f0       	breq	800059a0 <nav_partition_mount+0x24>
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
80005984:	48 98       	lddpc	r8,800059a8 <nav_partition_mount+0x2c>
80005986:	11 89       	ld.ub	r9,r8[0x0]
80005988:	30 08       	mov	r8,0
8000598a:	f0 09 18 00 	cp.b	r9,r8
8000598e:	c0 70       	breq	8000599c <nav_partition_mount+0x20>
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
80005990:	30 09       	mov	r9,0
80005992:	48 78       	lddpc	r8,800059ac <nav_partition_mount+0x30>
80005994:	91 89       	st.w	r8[0x20],r9
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
80005996:	f0 1f 00 07 	mcall	800059b0 <nav_partition_mount+0x34>
8000599a:	da 0a       	popm	pc,r12=1
      return true;
   }

   return fat_mount();
8000599c:	f0 1f 00 06 	mcall	800059b4 <nav_partition_mount+0x38>
}
800059a0:	d8 02       	popm	pc
800059a2:	00 00       	add	r0,r0
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	4d 3c       	lddpc	r12,80005af0 <nav_reset+0x5c>
800059a8:	00 00       	add	r0,r0
800059aa:	0c fc       	st.b	--r6,r12
800059ac:	00 00       	add	r0,r0
800059ae:	0c b0       	st.h	r6++,r0
800059b0:	80 00       	ld.sh	r0,r0[0x0]
800059b2:	3e 60       	mov	r0,-26
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	4f 54       	lddpc	r4,80005b88 <nav_filterlist_next+0x10>

800059b8 <nav_dir_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_dir_root( void )
{
800059b8:	d4 01       	pushm	lr
   return nav_partition_mount();
800059ba:	f0 1f 00 02 	mcall	800059c0 <nav_dir_root+0x8>
}
800059be:	d8 02       	popm	pc
800059c0:	80 00       	ld.sh	r0,r0[0x0]
800059c2:	59 7c       	cp.w	r12,23

800059c4 <nav_drive_set>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_drive_set( uint8_t u8_number )
{
800059c4:	eb cd 40 80 	pushm	r7,lr
800059c8:	18 97       	mov	r7,r12
   if ( !fat_check_noopen() )
800059ca:	f0 1f 00 0f 	mcall	80005a04 <nav_drive_set+0x40>
800059ce:	c1 90       	breq	80005a00 <nav_drive_set+0x3c>
      return false;

   if (u8_number >= get_nb_lun() )
800059d0:	f0 1f 00 0e 	mcall	80005a08 <nav_drive_set+0x44>
800059d4:	ee 0c 18 00 	cp.b	r12,r7
800059d8:	e0 8b 00 07 	brhi	800059e6 <nav_drive_set+0x22>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
800059dc:	30 69       	mov	r9,6
800059de:	48 c8       	lddpc	r8,80005a0c <nav_drive_set+0x48>
800059e0:	b0 89       	st.b	r8[0x0],r9
800059e2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
800059e6:	48 b8       	lddpc	r8,80005a10 <nav_drive_set+0x4c>
800059e8:	11 88       	ld.ub	r8,r8[0x0]
800059ea:	ee 08 18 00 	cp.b	r8,r7
800059ee:	c0 31       	brne	800059f4 <nav_drive_set+0x30>
800059f0:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
800059f4:	48 78       	lddpc	r8,80005a10 <nav_drive_set+0x4c>
800059f6:	b0 87       	st.b	r8[0x0],r7
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
800059f8:	30 09       	mov	r9,0
800059fa:	48 78       	lddpc	r8,80005a14 <nav_drive_set+0x50>
800059fc:	b0 89       	st.b	r8[0x0],r9
800059fe:	30 1c       	mov	r12,1
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
80005a00:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	4d 3c       	lddpc	r12,80005b50 <nav_filterlist_previous+0x38>
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	5c a0       	swap.h	r0
80005a0c:	00 00       	add	r0,r0
80005a0e:	0d 00       	ld.w	r0,r6++
80005a10:	00 00       	add	r0,r0
80005a12:	0c b0       	st.h	r6++,r0
80005a14:	00 00       	add	r0,r0
80005a16:	0c fc       	st.b	--r6,r12

80005a18 <nav_drive_nb>:
//! @verbatim
//! This value may be dynamic because it depends of memory drivers (e.g. Mass Storage disk on USB host mode)
//! @endverbatim
//!
uint8_t    nav_drive_nb( void )
{
80005a18:	d4 01       	pushm	lr
   return get_nb_lun(); // Number of devices = Number of lun
80005a1a:	f0 1f 00 02 	mcall	80005a20 <nav_drive_nb+0x8>
}
80005a1e:	d8 02       	popm	pc
80005a20:	80 00       	ld.sh	r0,r0[0x0]
80005a22:	5c a0       	swap.h	r0

80005a24 <nav_select>:
//!
//! @return    false if ID navigator don't exist
//! @return    true otherwise
//!
bool  nav_select( uint8_t u8_idnav )
{
80005a24:	eb cd 40 80 	pushm	r7,lr
80005a28:	18 97       	mov	r7,r12
   if( FS_NB_NAVIGATOR <= u8_idnav )
80005a2a:	30 18       	mov	r8,1
80005a2c:	f0 0c 18 00 	cp.b	r12,r8
80005a30:	e0 88 00 07 	brls	80005a3e <nav_select+0x1a>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
80005a34:	32 79       	mov	r9,39
80005a36:	48 b8       	lddpc	r8,80005a60 <nav_select+0x3c>
80005a38:	b0 89       	st.b	r8[0x0],r9
80005a3a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
80005a3e:	48 a8       	lddpc	r8,80005a64 <nav_select+0x40>
80005a40:	11 8c       	ld.ub	r12,r8[0x0]
80005a42:	ee 0c 18 00 	cp.b	r12,r7
80005a46:	c0 31       	brne	80005a4c <nav_select+0x28>
80005a48:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
80005a4c:	f0 1f 00 07 	mcall	80005a68 <nav_select+0x44>
      fat_invert_nav( u8_idnav );               // Select new navigator
80005a50:	0e 9c       	mov	r12,r7
80005a52:	f0 1f 00 06 	mcall	80005a68 <nav_select+0x44>
      fs_g_u8_nav_selected = u8_idnav;
80005a56:	48 48       	lddpc	r8,80005a64 <nav_select+0x40>
80005a58:	b0 87       	st.b	r8[0x0],r7
80005a5a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80005a5e:	00 00       	add	r0,r0
80005a60:	00 00       	add	r0,r0
80005a62:	0d 00       	ld.w	r0,r6++
80005a64:	00 00       	add	r0,r0
80005a66:	0d 78       	ld.ub	r8,--r6
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	43 ac       	lddsp	r12,sp[0xe8]

80005a6c <nav_exit>:
//! @verbatim
//! Call this at the program exit or before a USB Device session
//! @endverbatim
//!
void  nav_exit( void )
{
80005a6c:	d4 01       	pushm	lr
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
80005a6e:	30 0c       	mov	r12,0
80005a70:	f0 1f 00 06 	mcall	80005a88 <nav_exit+0x1c>
      file_close();
80005a74:	f0 1f 00 06 	mcall	80005a8c <nav_exit+0x20>
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
80005a78:	30 1c       	mov	r12,1
80005a7a:	f0 1f 00 04 	mcall	80005a88 <nav_exit+0x1c>
      file_close();
80005a7e:	f0 1f 00 04 	mcall	80005a8c <nav_exit+0x20>
#else
   nav_select(0);
   file_close();
#endif
   // Flush data eventually present in FAT cache
   fat_cache_flush();
80005a82:	f0 1f 00 04 	mcall	80005a90 <nav_exit+0x24>
}
80005a86:	d8 02       	popm	pc
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	5a 24       	cp.w	r4,-30
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	52 74       	stdsp	sp[0x9c],r4
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	44 88       	lddsp	r8,sp[0x120]

80005a94 <nav_reset>:
//! @verbatim
//! Call this at the program startup or before a new session (e.g. USB Device exit)
//! @endverbatim
//!
void  nav_reset( void )
{
80005a94:	eb cd 40 f8 	pushm	r3-r7,lr
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
80005a98:	30 07       	mov	r7,0
80005a9a:	49 18       	lddpc	r8,80005adc <nav_reset+0x48>
80005a9c:	b0 87       	st.b	r8[0x0],r7
   g_b_no_check_disk = false;
80005a9e:	49 18       	lddpc	r8,80005ae0 <nav_reset+0x4c>
80005aa0:	b0 87       	st.b	r8[0x0],r7

   fat_cache_reset();
80005aa2:	f0 1f 00 11 	mcall	80005ae4 <nav_reset+0x50>
   fat_cache_clusterlist_reset();
80005aa6:	f0 1f 00 11 	mcall	80005ae8 <nav_reset+0x54>
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80005aaa:	30 0c       	mov	r12,0
80005aac:	f0 1f 00 10 	mcall	80005aec <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005ab0:	49 03       	lddpc	r3,80005af0 <nav_reset+0x5c>
80005ab2:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80005ab4:	49 05       	lddpc	r5,80005af4 <nav_reset+0x60>
80005ab6:	3f f4       	mov	r4,-1
80005ab8:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80005aba:	49 06       	lddpc	r6,80005af8 <nav_reset+0x64>
80005abc:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
80005abe:	eb 67 00 2d 	st.b	r5[45],r7
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80005ac2:	30 1c       	mov	r12,1
80005ac4:	f0 1f 00 0a 	mcall	80005aec <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005ac8:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80005aca:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80005acc:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
80005ace:	eb 67 00 2d 	st.b	r5[45],r7
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
80005ad2:	48 b8       	lddpc	r8,80005afc <nav_reset+0x68>
80005ad4:	b0 87       	st.b	r8[0x0],r7
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
80005ad6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005ada:	00 00       	add	r0,r0
80005adc:	00 00       	add	r0,r0
80005ade:	0d 01       	ld.w	r1,r6++
80005ae0:	00 00       	add	r0,r0
80005ae2:	0a 82       	andn	r2,r5
80005ae4:	80 00       	ld.sh	r0,r0[0x0]
80005ae6:	42 bc       	lddsp	r12,sp[0xac]
80005ae8:	80 00       	ld.sh	r0,r0[0x0]
80005aea:	3b f4       	mov	r4,-65
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	5a 24       	cp.w	r4,-30
80005af0:	00 00       	add	r0,r0
80005af2:	0c fc       	st.b	--r6,r12
80005af4:	00 00       	add	r0,r0
80005af6:	0c b0       	st.h	r6++,r0
80005af8:	00 00       	add	r0,r0
80005afa:	0a 70       	tst	r0,r5
80005afc:	00 00       	add	r0,r0
80005afe:	0d 78       	ld.ub	r8,--r6

80005b00 <nav_filterlist_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_root( void )
{
80005b00:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
80005b02:	3f f9       	mov	r9,-1
80005b04:	48 38       	lddpc	r8,80005b10 <nav_filterlist_root+0x10>
80005b06:	f1 59 00 26 	st.h	r8[38],r9
   return nav_dir_root();
80005b0a:	f0 1f 00 03 	mcall	80005b14 <nav_filterlist_root+0x14>
}
80005b0e:	d8 02       	popm	pc
80005b10:	00 00       	add	r0,r0
80005b12:	0c b0       	st.h	r6++,r0
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	59 b8       	cp.w	r8,27

80005b18 <nav_filterlist_previous>:
//!
//! @return    false in case of an error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_previous( void )
{
80005b18:	eb cd 40 e0 	pushm	r5-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
80005b1c:	f0 1f 00 11 	mcall	80005b60 <nav_filterlist_previous+0x48>
80005b20:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80005b24:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
80005b26:	49 06       	lddpc	r6,80005b64 <nav_filterlist_previous+0x4c>
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80005b28:	c1 08       	rjmp	80005b48 <nav_filterlist_previous+0x30>
   {
      if( nav_file_isdir()
80005b2a:	f0 1f 00 10 	mcall	80005b68 <nav_filterlist_previous+0x50>
80005b2e:	c0 51       	brne	80005b38 <nav_filterlist_previous+0x20>
80005b30:	6c ac       	ld.w	r12,r6[0x28]
80005b32:	f0 1f 00 0f 	mcall	80005b6c <nav_filterlist_previous+0x54>
80005b36:	c0 90       	breq	80005b48 <nav_filterlist_previous+0x30>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         fs_g_nav.u16_pos_filterlist--;
80005b38:	48 b8       	lddpc	r8,80005b64 <nav_filterlist_previous+0x4c>
80005b3a:	f1 09 00 26 	ld.sh	r9,r8[38]
80005b3e:	20 19       	sub	r9,1
80005b40:	f1 59 00 26 	st.h	r8[38],r9
80005b44:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
80005b48:	0e 9b       	mov	r11,r7
80005b4a:	0e 9c       	mov	r12,r7
80005b4c:	f0 1f 00 09 	mcall	80005b70 <nav_filterlist_previous+0x58>
80005b50:	ce d1       	brne	80005b2a <nav_filterlist_previous+0x12>
      {
         fs_g_nav.u16_pos_filterlist--;
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
80005b52:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80005b56:	f0 1f 00 08 	mcall	80005b74 <nav_filterlist_previous+0x5c>
80005b5a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80005b5e:	00 00       	add	r0,r0
80005b60:	80 00       	ld.sh	r0,r0[0x0]
80005b62:	53 e4       	stdsp	sp[0xf8],r4
80005b64:	00 00       	add	r0,r0
80005b66:	0c b0       	st.h	r6++,r0
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	54 1c       	stdsp	sp[0x104],r12
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	53 f0       	stdsp	sp[0xfc],r0
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	55 1c       	stdsp	sp[0x144],r12
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	58 f0       	cp.w	r0,15

80005b78 <nav_filterlist_next>:
//!
//! @return    false in case of error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_next( void )
{
80005b78:	d4 21       	pushm	r4-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
80005b7a:	f0 1f 00 15 	mcall	80005bcc <nav_filterlist_next+0x54>
80005b7e:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80005b82:	30 16       	mov	r6,1
80005b84:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
80005b86:	49 35       	lddpc	r5,80005bd0 <nav_filterlist_next+0x58>
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80005b88:	c1 88       	rjmp	80005bb8 <nav_filterlist_next+0x40>
   {
      if( nav_file_isdir()
80005b8a:	f0 1f 00 13 	mcall	80005bd4 <nav_filterlist_next+0x5c>
80005b8e:	c0 51       	brne	80005b98 <nav_filterlist_next+0x20>
80005b90:	6a ac       	ld.w	r12,r5[0x28]
80005b92:	f0 1f 00 12 	mcall	80005bd8 <nav_filterlist_next+0x60>
80005b96:	c1 10       	breq	80005bb8 <nav_filterlist_next+0x40>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
80005b98:	3f f8       	mov	r8,-1
80005b9a:	f0 04 19 00 	cp.h	r4,r8
80005b9e:	c0 61       	brne	80005baa <nav_filterlist_next+0x32>
         {
            fs_g_nav.u16_pos_filterlist = 0;
80005ba0:	30 09       	mov	r9,0
80005ba2:	48 c8       	lddpc	r8,80005bd0 <nav_filterlist_next+0x58>
80005ba4:	f1 59 00 26 	st.h	r8[38],r9
80005ba8:	da 2a       	popm	r4-r7,pc,r12=1
         }else{
            fs_g_nav.u16_pos_filterlist++;
80005baa:	48 a8       	lddpc	r8,80005bd0 <nav_filterlist_next+0x58>
80005bac:	f1 09 00 26 	ld.sh	r9,r8[38]
80005bb0:	2f f9       	sub	r9,-1
80005bb2:	f1 59 00 26 	st.h	r8[38],r9
80005bb6:	da 2a       	popm	r4-r7,pc,r12=1
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
80005bb8:	0c 9b       	mov	r11,r6
80005bba:	0e 9c       	mov	r12,r7
80005bbc:	f0 1f 00 08 	mcall	80005bdc <nav_filterlist_next+0x64>
80005bc0:	ce 51       	brne	80005b8a <nav_filterlist_next+0x12>
            fs_g_nav.u16_pos_filterlist++;
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
80005bc2:	08 9c       	mov	r12,r4
80005bc4:	5c 7c       	castu.h	r12
80005bc6:	f0 1f 00 07 	mcall	80005be0 <nav_filterlist_next+0x68>
80005bca:	d8 2a       	popm	r4-r7,pc,r12=0
80005bcc:	80 00       	ld.sh	r0,r0[0x0]
80005bce:	53 e4       	stdsp	sp[0xf8],r4
80005bd0:	00 00       	add	r0,r0
80005bd2:	0c b0       	st.h	r6++,r0
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	54 1c       	stdsp	sp[0x104],r12
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	53 f0       	stdsp	sp[0xfc],r0
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	55 1c       	stdsp	sp[0x144],r12
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	58 f0       	cp.w	r0,15

80005be4 <nav_filterlist_reset>:
//!
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
80005be4:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
80005be6:	3f f9       	mov	r9,-1
80005be8:	48 38       	lddpc	r8,80005bf4 <nav_filterlist_reset+0x10>
80005bea:	f1 59 00 26 	st.h	r8[38],r9
   return nav_filelist_reset();
80005bee:	f0 1f 00 03 	mcall	80005bf8 <nav_filterlist_reset+0x14>
}
80005bf2:	d8 02       	popm	pc
80005bf4:	00 00       	add	r0,r0
80005bf6:	0c b0       	st.h	r6++,r0
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	56 84       	stdsp	sp[0x1a0],r4

80005bfc <nav_filterlist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_goto( uint16_t u16_newpos )
{
80005bfc:	eb cd 40 c0 	pushm	r6-r7,lr
80005c00:	18 97       	mov	r7,r12
   if (u16_newpos == FS_NO_SEL)
80005c02:	3f f8       	mov	r8,-1
80005c04:	f0 0c 19 00 	cp.h	r12,r8
80005c08:	c0 51       	brne	80005c12 <nav_filterlist_goto+0x16>
     return nav_filterlist_reset();
80005c0a:	f0 1f 00 1d 	mcall	80005c7c <nav_filterlist_goto+0x80>
80005c0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

   if( u16_newpos < (fs_g_nav.u16_pos_filterlist/2) )
80005c12:	49 c8       	lddpc	r8,80005c80 <nav_filterlist_goto+0x84>
80005c14:	f1 18 00 26 	ld.uh	r8,r8[38]
80005c18:	a1 98       	lsr	r8,0x1
80005c1a:	f0 0c 19 00 	cp.h	r12,r8
80005c1e:	c0 42       	brcc	80005c26 <nav_filterlist_goto+0x2a>
   {
      // Restart at the beginning of list to accelerate search
      if( !nav_filterlist_reset() )
80005c20:	f0 1f 00 17 	mcall	80005c7c <nav_filterlist_goto+0x80>
80005c24:	c2 a0       	breq	80005c78 <nav_filterlist_goto+0x7c>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
80005c26:	49 78       	lddpc	r8,80005c80 <nav_filterlist_goto+0x84>
80005c28:	f1 09 00 26 	ld.sh	r9,r8[38]
80005c2c:	3f f8       	mov	r8,-1
80005c2e:	f0 09 19 00 	cp.h	r9,r8
80005c32:	c0 91       	brne	80005c44 <nav_filterlist_goto+0x48>
      if( !nav_filterlist_next() )
80005c34:	f0 1f 00 14 	mcall	80005c84 <nav_filterlist_goto+0x88>
80005c38:	c0 61       	brne	80005c44 <nav_filterlist_goto+0x48>
80005c3a:	c1 f8       	rjmp	80005c78 <nav_filterlist_goto+0x7c>
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
80005c3c:	f0 1f 00 12 	mcall	80005c84 <nav_filterlist_goto+0x88>
80005c40:	c0 31       	brne	80005c46 <nav_filterlist_goto+0x4a>
80005c42:	c0 c8       	rjmp	80005c5a <nav_filterlist_goto+0x5e>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
      if( !nav_filterlist_next() )
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
80005c44:	48 f6       	lddpc	r6,80005c80 <nav_filterlist_goto+0x84>
80005c46:	ed 08 00 26 	ld.sh	r8,r6[38]
80005c4a:	ee 08 19 00 	cp.h	r8,r7
80005c4e:	cf 73       	brcs	80005c3c <nav_filterlist_goto+0x40>
80005c50:	c0 58       	rjmp	80005c5a <nav_filterlist_goto+0x5e>
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_previous() )
80005c52:	f0 1f 00 0e 	mcall	80005c88 <nav_filterlist_goto+0x8c>
80005c56:	c0 31       	brne	80005c5c <nav_filterlist_goto+0x60>
80005c58:	c0 88       	rjmp	80005c68 <nav_filterlist_goto+0x6c>
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
80005c5a:	48 a6       	lddpc	r6,80005c80 <nav_filterlist_goto+0x84>
80005c5c:	ed 08 00 26 	ld.sh	r8,r6[38]
80005c60:	ee 08 19 00 	cp.h	r8,r7
80005c64:	fe 9b ff f7 	brhi	80005c52 <nav_filterlist_goto+0x56>
   {
      if( !nav_filterlist_previous() )
         break;
   }
   return (u16_newpos == fs_g_nav.u16_pos_filterlist);
80005c68:	48 68       	lddpc	r8,80005c80 <nav_filterlist_goto+0x84>
80005c6a:	f1 08 00 26 	ld.sh	r8,r8[38]
80005c6e:	ee 08 19 00 	cp.h	r8,r7
80005c72:	5f 0c       	sreq	r12
80005c74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c78:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	5b e4       	cp.w	r4,-2
80005c80:	00 00       	add	r0,r0
80005c82:	0c b0       	st.h	r6++,r0
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	5b 78       	cp.w	r8,-9
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	5b 18       	cp.w	r8,-15

80005c8c <nav_filterlist_setfilter>:
//! This function affiliates an extension filter at current navigator
//!
//! @param     sz_filterext   extension filter (ASCII format, e.g.: "txt" or "txt,d*,wk" )
//!
void  nav_filterlist_setfilter( const FS_STRING sz_filterext  )
{
80005c8c:	d4 01       	pushm	lr
   fs_g_nav.sz_filterext = sz_filterext;
80005c8e:	48 38       	lddpc	r8,80005c98 <nav_filterlist_setfilter+0xc>
80005c90:	91 ac       	st.w	r8[0x28],r12
   nav_filterlist_reset();
80005c92:	f0 1f 00 03 	mcall	80005c9c <nav_filterlist_setfilter+0x10>
}
80005c96:	d8 02       	popm	pc
80005c98:	00 00       	add	r0,r0
80005c9a:	0c b0       	st.h	r6++,r0
80005c9c:	80 00       	ld.sh	r0,r0[0x0]
80005c9e:	5b e4       	cp.w	r4,-2

80005ca0 <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
80005ca0:	5e ff       	retal	1
80005ca2:	d7 03       	nop

80005ca4 <ctrl_access_lock>:
/*! \brief Locks accesses to LUNs.
 *
 * \return \c true if the access was successfully locked, else \c false.
 */
static bool ctrl_access_lock(void)
{
80005ca4:	eb cd 40 c0 	pushm	r6-r7,lr
  // If the semaphore could not be created, there is no backup solution.
  if (!ctrl_access_semphr) return false;
80005ca8:	48 88       	lddpc	r8,80005cc8 <ctrl_access_lock+0x24>
80005caa:	70 08       	ld.w	r8,r8[0x0]
80005cac:	58 08       	cp.w	r8,0
80005cae:	c0 31       	brne	80005cb4 <ctrl_access_lock+0x10>
80005cb0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

  // Wait for the semaphore.
  while (!xSemaphoreTake(ctrl_access_semphr, portMAX_DELAY));
80005cb4:	48 56       	lddpc	r6,80005cc8 <ctrl_access_lock+0x24>
80005cb6:	3f f7       	mov	r7,-1
80005cb8:	0e 9b       	mov	r11,r7
80005cba:	6c 0c       	ld.w	r12,r6[0x0]
80005cbc:	f0 1f 00 04 	mcall	80005ccc <ctrl_access_lock+0x28>
80005cc0:	cf c0       	breq	80005cb8 <ctrl_access_lock+0x14>
80005cc2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005cc6:	00 00       	add	r0,r0
80005cc8:	00 00       	add	r0,r0
80005cca:	05 50       	ld.sh	r0,--r2
80005ccc:	80 00       	ld.sh	r0,r0[0x0]
80005cce:	72 14       	ld.w	r4,r9[0x4]

80005cd0 <ram_2_memory>:
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
80005cd0:	eb cd 40 e0 	pushm	r5-r7,lr
80005cd4:	18 97       	mov	r7,r12
80005cd6:	16 95       	mov	r5,r11
80005cd8:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80005cda:	f0 1f 00 10 	mcall	80005d18 <ram_2_memory+0x48>
80005cde:	c0 31       	brne	80005ce4 <ram_2_memory+0x14>
80005ce0:	30 17       	mov	r7,1
80005ce2:	c1 88       	rjmp	80005d12 <ram_2_memory+0x42>

  memory_start_write_action(1);
80005ce4:	30 2c       	mov	r12,2
80005ce6:	f0 1f 00 0e 	mcall	80005d1c <ram_2_memory+0x4c>
  status =
80005cea:	58 07       	cp.w	r7,0
80005cec:	c0 30       	breq	80005cf2 <ram_2_memory+0x22>
80005cee:	30 17       	mov	r7,1
80005cf0:	c0 78       	rjmp	80005cfe <ram_2_memory+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
80005cf2:	48 c8       	lddpc	r8,80005d20 <ram_2_memory+0x50>
80005cf4:	70 68       	ld.w	r8,r8[0x18]
80005cf6:	0c 9b       	mov	r11,r6
80005cf8:	0a 9c       	mov	r12,r5
80005cfa:	5d 18       	icall	r8
80005cfc:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_ram_2_mem(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_write_action();
80005cfe:	30 2c       	mov	r12,2
80005d00:	f0 1f 00 09 	mcall	80005d24 <ram_2_memory+0x54>

  Ctrl_access_unlock();
80005d04:	30 09       	mov	r9,0
80005d06:	12 9a       	mov	r10,r9
80005d08:	12 9b       	mov	r11,r9
80005d0a:	48 88       	lddpc	r8,80005d28 <ram_2_memory+0x58>
80005d0c:	70 0c       	ld.w	r12,r8[0x0]
80005d0e:	f0 1f 00 08 	mcall	80005d2c <ram_2_memory+0x5c>

  return status;
}
80005d12:	0e 9c       	mov	r12,r7
80005d14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	5c a4       	swap.h	r4
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	7f 50       	ld.w	r0,pc[0x54]
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	9c e8       	ld.uh	r8,lr[0xc]
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	7f ac       	ld.w	r12,pc[0x68]
80005d28:	00 00       	add	r0,r0
80005d2a:	05 50       	ld.sh	r0,--r2
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	73 f8       	ld.w	r8,r9[0x7c]

80005d30 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
80005d30:	eb cd 40 e0 	pushm	r5-r7,lr
80005d34:	18 97       	mov	r7,r12
80005d36:	16 95       	mov	r5,r11
80005d38:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80005d3a:	f0 1f 00 10 	mcall	80005d78 <memory_2_ram+0x48>
80005d3e:	c0 31       	brne	80005d44 <memory_2_ram+0x14>
80005d40:	30 17       	mov	r7,1
80005d42:	c1 88       	rjmp	80005d72 <memory_2_ram+0x42>

  memory_start_read_action(1);
80005d44:	30 1c       	mov	r12,1
80005d46:	f0 1f 00 0e 	mcall	80005d7c <memory_2_ram+0x4c>
  status =
80005d4a:	58 07       	cp.w	r7,0
80005d4c:	c0 30       	breq	80005d52 <memory_2_ram+0x22>
80005d4e:	30 17       	mov	r7,1
80005d50:	c0 78       	rjmp	80005d5e <memory_2_ram+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
80005d52:	48 c8       	lddpc	r8,80005d80 <memory_2_ram+0x50>
80005d54:	70 58       	ld.w	r8,r8[0x14]
80005d56:	0c 9b       	mov	r11,r6
80005d58:	0a 9c       	mov	r12,r5
80005d5a:	5d 18       	icall	r8
80005d5c:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_mem_2_ram(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_read_action();
80005d5e:	30 1c       	mov	r12,1
80005d60:	f0 1f 00 09 	mcall	80005d84 <memory_2_ram+0x54>

  Ctrl_access_unlock();
80005d64:	30 09       	mov	r9,0
80005d66:	12 9a       	mov	r10,r9
80005d68:	12 9b       	mov	r11,r9
80005d6a:	48 88       	lddpc	r8,80005d88 <memory_2_ram+0x58>
80005d6c:	70 0c       	ld.w	r12,r8[0x0]
80005d6e:	f0 1f 00 08 	mcall	80005d8c <memory_2_ram+0x5c>

  return status;
}
80005d72:	0e 9c       	mov	r12,r7
80005d74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	5c a4       	swap.h	r4
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	7f 50       	ld.w	r0,pc[0x54]
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	9c e8       	ld.uh	r8,lr[0xc]
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	7f ac       	ld.w	r12,pc[0x68]
80005d88:	00 00       	add	r0,r0
80005d8a:	05 50       	ld.sh	r0,--r2
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	73 f8       	ld.w	r8,r9[0x7c]

80005d90 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
80005d90:	eb cd 40 80 	pushm	r7,lr
80005d94:	18 97       	mov	r7,r12
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;
80005d96:	f0 1f 00 0c 	mcall	80005dc4 <mem_wr_protect+0x34>
80005d9a:	c0 31       	brne	80005da0 <mem_wr_protect+0x10>
80005d9c:	30 17       	mov	r7,1
80005d9e:	c1 08       	rjmp	80005dbe <mem_wr_protect+0x2e>

  wr_protect =
80005da0:	58 07       	cp.w	r7,0
80005da2:	c0 30       	breq	80005da8 <mem_wr_protect+0x18>
80005da4:	30 17       	mov	r7,1
80005da6:	c0 58       	rjmp	80005db0 <mem_wr_protect+0x20>
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
80005da8:	48 88       	lddpc	r8,80005dc8 <mem_wr_protect+0x38>
80005daa:	70 3c       	ld.w	r12,r8[0xc]
80005dac:	5d 1c       	icall	r12
80005dae:	18 97       	mov	r7,r12
                                 Lun_usb_wr_protect(lun - LUN_ID_USB);
#else
                                 true;
#endif

  Ctrl_access_unlock();
80005db0:	30 09       	mov	r9,0
80005db2:	12 9a       	mov	r10,r9
80005db4:	12 9b       	mov	r11,r9
80005db6:	48 68       	lddpc	r8,80005dcc <mem_wr_protect+0x3c>
80005db8:	70 0c       	ld.w	r12,r8[0x0]
80005dba:	f0 1f 00 06 	mcall	80005dd0 <mem_wr_protect+0x40>

  return wr_protect;
}
80005dbe:	0e 9c       	mov	r12,r7
80005dc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	5c a4       	swap.h	r4
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	9c e8       	ld.uh	r8,lr[0xc]
80005dcc:	00 00       	add	r0,r0
80005dce:	05 50       	ld.sh	r0,--r2
80005dd0:	80 00       	ld.sh	r0,r0[0x0]
80005dd2:	73 f8       	ld.w	r8,r9[0x7c]

80005dd4 <mem_sector_size>:
  return status;
}


U8 mem_sector_size(U8 lun)
{
80005dd4:	eb cd 40 80 	pushm	r7,lr
80005dd8:	18 97       	mov	r7,r12
  U8 sector_size;

  if (!Ctrl_access_lock()) return 0;
80005dda:	f0 1f 00 0a 	mcall	80005e00 <mem_sector_size+0x2c>
80005dde:	c0 31       	brne	80005de4 <mem_sector_size+0x10>
80005de0:	30 07       	mov	r7,0
80005de2:	c0 c8       	rjmp	80005dfa <mem_sector_size+0x26>

  sector_size =
80005de4:	30 08       	mov	r8,0
80005de6:	f0 07 18 00 	cp.b	r7,r8
80005dea:	5f 07       	sreq	r7
                                  Lun_usb_read_sector_size(lun - LUN_ID_USB);
#else
                                  0;
#endif

  Ctrl_access_unlock();
80005dec:	30 09       	mov	r9,0
80005dee:	12 9a       	mov	r10,r9
80005df0:	12 9b       	mov	r11,r9
80005df2:	48 58       	lddpc	r8,80005e04 <mem_sector_size+0x30>
80005df4:	70 0c       	ld.w	r12,r8[0x0]
80005df6:	f0 1f 00 05 	mcall	80005e08 <mem_sector_size+0x34>

  return sector_size;
}
80005dfa:	0e 9c       	mov	r12,r7
80005dfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	5c a4       	swap.h	r4
80005e04:	00 00       	add	r0,r0
80005e06:	05 50       	ld.sh	r0,--r2
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	73 f8       	ld.w	r8,r9[0x7c]

80005e0c <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
80005e0c:	eb cd 40 80 	pushm	r7,lr
80005e10:	18 97       	mov	r7,r12
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80005e12:	f0 1f 00 0c 	mcall	80005e40 <mem_test_unit_ready+0x34>
80005e16:	c0 31       	brne	80005e1c <mem_test_unit_ready+0x10>
80005e18:	30 17       	mov	r7,1
80005e1a:	c1 08       	rjmp	80005e3a <mem_test_unit_ready+0x2e>

  status =
80005e1c:	58 07       	cp.w	r7,0
80005e1e:	c0 30       	breq	80005e24 <mem_test_unit_ready+0x18>
80005e20:	30 17       	mov	r7,1
80005e22:	c0 58       	rjmp	80005e2c <mem_test_unit_ready+0x20>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
80005e24:	48 88       	lddpc	r8,80005e44 <mem_test_unit_ready+0x38>
80005e26:	70 0c       	ld.w	r12,r8[0x0]
80005e28:	5d 1c       	icall	r12
80005e2a:	18 97       	mov	r7,r12
                             Lun_usb_test_unit_ready(lun - LUN_ID_USB);
#else
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();
80005e2c:	30 09       	mov	r9,0
80005e2e:	12 9a       	mov	r10,r9
80005e30:	12 9b       	mov	r11,r9
80005e32:	48 68       	lddpc	r8,80005e48 <mem_test_unit_ready+0x3c>
80005e34:	70 0c       	ld.w	r12,r8[0x0]
80005e36:	f0 1f 00 06 	mcall	80005e4c <mem_test_unit_ready+0x40>

  return status;
}
80005e3a:	0e 9c       	mov	r12,r7
80005e3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	5c a4       	swap.h	r4
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	9c e8       	ld.uh	r8,lr[0xc]
80005e48:	00 00       	add	r0,r0
80005e4a:	05 50       	ld.sh	r0,--r2
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	73 f8       	ld.w	r8,r9[0x7c]

80005e50 <ctrl_access_init>:


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
{
80005e50:	d4 01       	pushm	lr
  // If the handle to the protecting semaphore is not valid,
  if (!ctrl_access_semphr)
80005e52:	48 d8       	lddpc	r8,80005e84 <ctrl_access_init+0x34>
80005e54:	70 08       	ld.w	r8,r8[0x0]
80005e56:	58 08       	cp.w	r8,0
80005e58:	c0 20       	breq	80005e5c <ctrl_access_init+0xc>
80005e5a:	da 0a       	popm	pc,r12=1
  {
    // try to create the semaphore.
    vSemaphoreCreateBinary(ctrl_access_semphr);
80005e5c:	30 3a       	mov	r10,3
80005e5e:	30 0b       	mov	r11,0
80005e60:	30 1c       	mov	r12,1
80005e62:	f0 1f 00 0a 	mcall	80005e88 <ctrl_access_init+0x38>
80005e66:	48 88       	lddpc	r8,80005e84 <ctrl_access_init+0x34>
80005e68:	91 0c       	st.w	r8[0x0],r12
80005e6a:	58 0c       	cp.w	r12,0
80005e6c:	c0 a0       	breq	80005e80 <ctrl_access_init+0x30>
80005e6e:	30 09       	mov	r9,0
80005e70:	12 9a       	mov	r10,r9
80005e72:	12 9b       	mov	r11,r9
80005e74:	f0 1f 00 06 	mcall	80005e8c <ctrl_access_init+0x3c>
//! @{


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
80005e78:	48 38       	lddpc	r8,80005e84 <ctrl_access_init+0x34>
80005e7a:	70 08       	ld.w	r8,r8[0x0]
80005e7c:	58 08       	cp.w	r8,0
80005e7e:	5f 1c       	srne	r12
    // If the semaphore could not be created, there is no backup solution.
    if (!ctrl_access_semphr) return false;
  }

  return true;
}
80005e80:	d8 02       	popm	pc
80005e82:	00 00       	add	r0,r0
80005e84:	00 00       	add	r0,r0
80005e86:	05 50       	ld.sh	r0,--r2
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	75 8c       	ld.w	r12,r10[0x60]
80005e8c:	80 00       	ld.sh	r0,r0[0x0]
80005e8e:	73 f8       	ld.w	r8,r9[0x7c]

80005e90 <check_sd_card>:
	pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
	
}

void check_sd_card(void)
{
80005e90:	d4 01       	pushm	lr
	// NECESSARY: Initialize USART first.
	print_dbg("\r\nInit SD/MMC Driver");
80005e92:	49 0c       	lddpc	r12,80005ed0 <check_sd_card+0x40>
80005e94:	f0 1f 00 10 	mcall	80005ed4 <check_sd_card+0x44>
	print_dbg("\r\nInsert SD/MMC...");
80005e98:	49 0c       	lddpc	r12,80005ed8 <check_sd_card+0x48>
80005e9a:	f0 1f 00 0f 	mcall	80005ed4 <check_sd_card+0x44>
		
	while (!sd_mmc_spi_mem_check());
80005e9e:	f0 1f 00 10 	mcall	80005edc <check_sd_card+0x4c>
80005ea2:	cf e0       	breq	80005e9e <check_sd_card+0xe>
	print_dbg("\r\nCard detected!");
80005ea4:	48 fc       	lddpc	r12,80005ee0 <check_sd_card+0x50>
80005ea6:	f0 1f 00 0c 	mcall	80005ed4 <check_sd_card+0x44>
		
	// Read Card capacity
	sd_mmc_spi_get_capacity();
80005eaa:	f0 1f 00 0f 	mcall	80005ee4 <check_sd_card+0x54>
	print_dbg("Capacity = ");
80005eae:	48 fc       	lddpc	r12,80005ee8 <check_sd_card+0x58>
80005eb0:	f0 1f 00 09 	mcall	80005ed4 <check_sd_card+0x44>
	print_dbg_ulong(capacity >> 20);
80005eb4:	48 e8       	lddpc	r8,80005eec <check_sd_card+0x5c>
80005eb6:	f0 e8 00 00 	ld.d	r8,r8[0]
80005eba:	f0 0c 16 14 	lsr	r12,r8,0x14
80005ebe:	f9 e9 10 cc 	or	r12,r12,r9<<0xc
80005ec2:	f0 1f 00 0c 	mcall	80005ef0 <check_sd_card+0x60>
	print_dbg(" MBytes\r\n");
80005ec6:	48 cc       	lddpc	r12,80005ef4 <check_sd_card+0x64>
80005ec8:	f0 1f 00 03 	mcall	80005ed4 <check_sd_card+0x44>
}
80005ecc:	d8 02       	popm	pc
80005ece:	00 00       	add	r0,r0
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	9d 50       	st.w	lr[0x14],r0
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	6a 10       	ld.w	r0,r5[0x4]
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	9d 68       	st.w	lr[0x18],r8
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	33 90       	mov	r0,57
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	9d 7c       	st.w	lr[0x1c],r12
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	28 7c       	sub	r12,-121
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	9d 90       	st.w	lr[0x24],r0
80005eec:	00 00       	add	r0,r0
80005eee:	0a 40       	or	r0,r5
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	69 fc       	ld.w	r12,r4[0x7c]
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	9d 9c       	st.w	lr[0x24],r12

80005ef8 <sd_mmc_resources_init>:

#include "conf_spi_sd.h"

// SPI
void sd_mmc_resources_init(void)
{
80005ef8:	eb cd 40 80 	pushm	r7,lr
80005efc:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80005efe:	49 98       	lddpc	r8,80005f60 <sd_mmc_resources_init+0x68>
80005f00:	1a 97       	mov	r7,sp
80005f02:	f0 ea 00 00 	ld.d	r10,r8[0]
80005f06:	fa eb 00 00 	st.d	sp[0],r10
80005f0a:	f0 e8 00 08 	ld.d	r8,r8[8]
80005f0e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
80005f12:	30 4b       	mov	r11,4
80005f14:	49 4c       	lddpc	r12,80005f64 <sd_mmc_resources_init+0x6c>
80005f16:	f0 1f 00 15 	mcall	80005f68 <sd_mmc_resources_init+0x70>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80005f1a:	1a 9b       	mov	r11,sp
80005f1c:	fe 7c 24 00 	mov	r12,-56320
80005f20:	f0 1f 00 13 	mcall	80005f6c <sd_mmc_resources_init+0x74>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
80005f24:	30 09       	mov	r9,0
80005f26:	12 9a       	mov	r10,r9
80005f28:	12 9b       	mov	r11,r9
80005f2a:	fe 7c 24 00 	mov	r12,-56320
80005f2e:	f0 1f 00 11 	mcall	80005f70 <sd_mmc_resources_init+0x78>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
80005f32:	fe 7c 24 00 	mov	r12,-56320
80005f36:	f0 1f 00 10 	mcall	80005f74 <sd_mmc_resources_init+0x7c>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, PBA_HZ);
80005f3a:	20 4d       	sub	sp,16
80005f3c:	ee e8 00 00 	ld.d	r8,r7[0]
80005f40:	fa e9 00 00 	st.d	sp[0],r8
80005f44:	ee e8 00 08 	ld.d	r8,r7[8]
80005f48:	fa e9 00 08 	st.d	sp[8],r8
80005f4c:	e0 6c 76 00 	mov	r12,30208
80005f50:	ea 1c 03 b3 	orh	r12,0x3b3
80005f54:	f0 1f 00 09 	mcall	80005f78 <sd_mmc_resources_init+0x80>
80005f58:	2f cd       	sub	sp,-16
	
}
80005f5a:	2f cd       	sub	sp,-16
80005f5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	9d 20       	st.w	lr[0x8],r0
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	9d 30       	st.w	lr[0xc],r0
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	80 60       	ld.sh	r0,r0[0xc]
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	38 fa       	mov	r10,-113
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	39 32       	mov	r2,-109
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	39 5e       	mov	lr,-107
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	33 b8       	mov	r8,59

80005f7c <tpa6130_abdac_tx_pdca_int_handler>:
  .output_impedance    = TPA6130_OUTPUT_IMPEDANCE_DEFAULT,
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
80005f7c:	d4 01       	pushm	lr
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
80005f7e:	30 0c       	mov	r12,0
80005f80:	f0 1f 00 13 	mcall	80005fcc <tpa6130_abdac_tx_pdca_int_handler+0x50>
80005f84:	e2 1c 00 02 	andl	r12,0x2,COH
80005f88:	c0 d0       	breq	80005fa2 <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80005f8a:	30 0c       	mov	r12,0
80005f8c:	f0 1f 00 11 	mcall	80005fd0 <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80005f90:	49 18       	lddpc	r8,80005fd4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005f92:	70 28       	ld.w	r8,r8[0x8]
80005f94:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005f98:	c0 50       	breq	80005fa2 <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
80005f9a:	48 f8       	lddpc	r8,80005fd4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005f9c:	70 18       	ld.w	r8,r8[0x4]
80005f9e:	30 1c       	mov	r12,1
80005fa0:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
80005fa2:	30 0c       	mov	r12,0
80005fa4:	f0 1f 00 0a 	mcall	80005fcc <tpa6130_abdac_tx_pdca_int_handler+0x50>
80005fa8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005fac:	c0 d0       	breq	80005fc6 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80005fae:	30 0c       	mov	r12,0
80005fb0:	f0 1f 00 0a 	mcall	80005fd8 <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80005fb4:	48 88       	lddpc	r8,80005fd4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005fb6:	70 28       	ld.w	r8,r8[0x8]
80005fb8:	e2 18 00 02 	andl	r8,0x2,COH
80005fbc:	c0 50       	breq	80005fc6 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
80005fbe:	48 68       	lddpc	r8,80005fd4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005fc0:	70 18       	ld.w	r8,r8[0x4]
80005fc2:	30 2c       	mov	r12,2
80005fc4:	5d 18       	icall	r8
  }
}
80005fc6:	d4 02       	popm	lr
80005fc8:	d6 03       	rete
80005fca:	00 00       	add	r0,r0
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	65 94       	ld.w	r4,r2[0x64]
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	65 cc       	ld.w	r12,r2[0x70]
80005fd4:	00 00       	add	r0,r0
80005fd6:	05 54       	ld.sh	r4,--r2
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	65 a4       	ld.w	r4,r2[0x68]

80005fdc <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80005fdc:	d4 21       	pushm	r4-r7,lr
80005fde:	20 5d       	sub	sp,20
80005fe0:	18 94       	mov	r4,r12
80005fe2:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80005fe4:	f7 ec 10 88 	or	r8,r11,r12<<0x8
80005fe8:	fb 58 00 12 	st.h	sp[18],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80005fec:	30 08       	mov	r8,0
80005fee:	30 09       	mov	r9,0
80005ff0:	fa e9 00 00 	st.d	sp[0],r8
80005ff4:	36 08       	mov	r8,96
80005ff6:	ba 88       	st.b	sp[0x0],r8
80005ff8:	fa c8 ff ee 	sub	r8,sp,-18
80005ffc:	50 28       	stdsp	sp[0x8],r8
80005ffe:	30 28       	mov	r8,2
80006000:	50 38       	stdsp	sp[0xc],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
80006002:	1a 96       	mov	r6,sp
80006004:	fe 77 2c 00 	mov	r7,-54272
80006008:	1a 9b       	mov	r11,sp
8000600a:	0e 9c       	mov	r12,r7
8000600c:	f0 1f 00 05 	mcall	80006020 <tpa6130_write_data+0x44>
  }
  while( twi_status != TWI_SUCCESS );
80006010:	cf c1       	brne	80006008 <tpa6130_write_data+0x2c>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
80006012:	48 58       	lddpc	r8,80006024 <tpa6130_write_data+0x48>
80006014:	f0 04 00 04 	add	r4,r8,r4
80006018:	e9 65 ff ff 	st.b	r4[-1],r5
}
8000601c:	2f bd       	sub	sp,-20
8000601e:	d8 22       	popm	r4-r7,pc
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	67 54       	ld.w	r4,r3[0x54]
80006024:	00 00       	add	r0,r0
80006026:	00 09       	add	r9,r0

80006028 <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
80006028:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
8000602a:	33 f8       	mov	r8,63
8000602c:	f0 0c 18 00 	cp.b	r12,r8
80006030:	e0 8a 00 04 	brle	80006038 <tpa6130_set_volume+0x10>
80006034:	33 fb       	mov	r11,63
80006036:	c0 b8       	rjmp	8000604c <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
80006038:	30 08       	mov	r8,0
8000603a:	f0 0c 18 00 	cp.b	r12,r8
8000603e:	e0 89 00 05 	brgt	80006048 <tpa6130_set_volume+0x20>
80006042:	e0 6b 00 c0 	mov	r11,192
80006046:	c0 38       	rjmp	8000604c <tpa6130_set_volume+0x24>
80006048:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
8000604c:	30 2c       	mov	r12,2
8000604e:	f0 1f 00 02 	mcall	80006054 <tpa6130_set_volume+0x2c>
}
80006052:	d8 02       	popm	pc
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	5f dc       	srvc	r12

80006058 <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
80006058:	d4 01       	pushm	lr
8000605a:	20 5d       	sub	sp,20
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
8000605c:	58 0b       	cp.w	r11,0
8000605e:	c0 90       	breq	80006070 <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
80006060:	48 f8       	lddpc	r8,8000609c <tpa6130_read_data+0x44>
80006062:	f0 0c 00 0c 	add	r12,r8,r12
80006066:	f9 38 ff ff 	ld.ub	r8,r12[-1]
8000606a:	fb 68 00 13 	st.b	sp[19],r8
8000606e:	c1 38       	rjmp	80006094 <tpa6130_read_data+0x3c>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr[0] = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
80006070:	30 08       	mov	r8,0
80006072:	30 09       	mov	r9,0
80006074:	fa e9 00 00 	st.d	sp[0],r8
80006078:	36 08       	mov	r8,96
8000607a:	ba 88       	st.b	sp[0x0],r8
8000607c:	ba 9c       	st.b	sp[0x1],r12
8000607e:	30 18       	mov	r8,1
80006080:	50 18       	stdsp	sp[0x4],r8
80006082:	fa c9 ff ed 	sub	r9,sp,-19
80006086:	50 29       	stdsp	sp[0x8],r9
80006088:	50 38       	stdsp	sp[0xc],r8
    twi_master_read(TPA6130_TWI, &twi_package);
8000608a:	1a 9b       	mov	r11,sp
8000608c:	fe 7c 2c 00 	mov	r12,-54272
80006090:	f0 1f 00 04 	mcall	800060a0 <tpa6130_read_data+0x48>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80006094:	fb 3c 00 13 	ld.ub	r12,sp[19]
80006098:	2f bd       	sub	sp,-20
8000609a:	d8 02       	popm	pc
8000609c:	00 00       	add	r0,r0
8000609e:	00 09       	add	r9,r0
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	68 2c       	ld.w	r12,r4[0x8]

800060a4 <tpa6130_get_volume>:
/*! \brief Gets the current volume settings.
 *  \returns Current volume settings. Value is between 0 (-59dB) and
 *  63 (4dB).
 */
int8_t tpa6130_get_volume(void)
{
800060a4:	d4 01       	pushm	lr
  return tpa6130_read_data(TPA6130_VOLUME_AND_MUTE, TWI_READ_SR);
800060a6:	30 1b       	mov	r11,1
800060a8:	30 2c       	mov	r12,2
800060aa:	f0 1f 00 03 	mcall	800060b4 <tpa6130_get_volume+0x10>
}
800060ae:	5c 5c       	castu.b	r12
800060b0:	d8 02       	popm	pc
800060b2:	00 00       	add	r0,r0
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	60 58       	ld.w	r8,r0[0x14]

800060b8 <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
800060b8:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
800060ba:	30 0b       	mov	r11,0
800060bc:	30 1c       	mov	r12,1
800060be:	f0 1f 00 05 	mcall	800060d0 <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
800060c2:	18 9b       	mov	r11,r12
800060c4:	e2 1b 00 fe 	andl	r11,0xfe,COH
800060c8:	30 1c       	mov	r12,1
800060ca:	f0 1f 00 03 	mcall	800060d4 <tpa6130_powerup+0x1c>
}
800060ce:	d8 02       	popm	pc
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	60 58       	ld.w	r8,r0[0x14]
800060d4:	80 00       	ld.sh	r0,r0[0x0]
800060d6:	5f dc       	srvc	r12

800060d8 <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
800060d8:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
800060da:	30 0b       	mov	r11,0
800060dc:	30 1c       	mov	r12,1
800060de:	f0 1f 00 05 	mcall	800060f0 <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
800060e2:	18 9b       	mov	r11,r12
800060e4:	a1 ab       	sbr	r11,0x0
800060e6:	5c 5b       	castu.b	r11
800060e8:	30 1c       	mov	r12,1
800060ea:	f0 1f 00 03 	mcall	800060f4 <tpa6130_shutdown+0x1c>
}
800060ee:	d8 02       	popm	pc
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	60 58       	ld.w	r8,r0[0x14]
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	5f dc       	srvc	r12

800060f8 <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
800060f8:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
800060fa:	f0 1f 00 0b 	mcall	80006124 <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
800060fe:	fe 7c 40 00 	mov	r12,-49152
80006102:	f0 1f 00 0a 	mcall	80006128 <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
80006106:	30 0c       	mov	r12,0
80006108:	f0 1f 00 09 	mcall	8000612c <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
8000610c:	30 4b       	mov	r11,4
8000610e:	48 9c       	lddpc	r12,80006130 <tpa6130_dac_stop+0x38>
80006110:	f0 1f 00 09 	mcall	80006134 <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
80006114:	48 98       	lddpc	r8,80006138 <tpa6130_dac_stop+0x40>
80006116:	30 09       	mov	r9,0
80006118:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
8000611a:	30 09       	mov	r9,0
8000611c:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
8000611e:	91 29       	st.w	r8[0x8],r9
}
80006120:	d8 02       	popm	pc
80006122:	00 00       	add	r0,r0
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	60 d8       	ld.w	r8,r0[0x34]
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	62 9c       	ld.w	r12,r1[0x24]
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	65 74       	ld.w	r4,r2[0x5c]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	9d c0       	st.w	lr[0x30],r0
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	80 a8       	ld.uh	r8,r0[0x4]
80006138:	00 00       	add	r0,r0
8000613a:	05 54       	ld.sh	r4,--r2

8000613c <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
8000613c:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
8000613e:	36 0b       	mov	r11,96
80006140:	fe 7c 2c 00 	mov	r12,-54272
80006144:	f0 1f 00 0e 	mcall	8000617c <tpa6130_init+0x40>
80006148:	c0 40       	breq	80006150 <tpa6130_init+0x14>
8000614a:	e0 6c 00 fd 	mov	r12,253
8000614e:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
80006150:	30 0b       	mov	r11,0
80006152:	30 4c       	mov	r12,4
80006154:	f0 1f 00 0b 	mcall	80006180 <tpa6130_init+0x44>
80006158:	30 28       	mov	r8,2
8000615a:	f0 0c 18 00 	cp.b	r12,r8
8000615e:	c0 40       	breq	80006166 <tpa6130_init+0x2a>
80006160:	e0 6c 00 f8 	mov	r12,248
80006164:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
80006166:	48 88       	lddpc	r8,80006184 <tpa6130_init+0x48>
80006168:	11 9b       	ld.ub	r11,r8[0x1]
8000616a:	30 2c       	mov	r12,2
8000616c:	f0 1f 00 07 	mcall	80006188 <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
80006170:	e0 6b 00 c0 	mov	r11,192
80006174:	30 1c       	mov	r12,1
80006176:	f0 1f 00 05 	mcall	80006188 <tpa6130_init+0x4c>
8000617a:	d8 0a       	popm	pc,r12=0
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	68 04       	ld.w	r4,r4[0x0]
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	60 58       	ld.w	r8,r0[0x14]
80006184:	00 00       	add	r0,r0
80006186:	00 09       	add	r9,r0
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	5f dc       	srvc	r12

8000618c <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
8000618c:	eb cd 40 c0 	pushm	r6-r7,lr
80006190:	20 6d       	sub	sp,24
80006192:	18 97       	mov	r7,r12
80006194:	12 96       	mov	r6,r9
80006196:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
80006198:	49 a9       	lddpc	r9,80006200 <tpa6130_dac_setup+0x74>
8000619a:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
8000619c:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
8000619e:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
800061a0:	f0 1f 00 19 	mcall	80006204 <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
800061a4:	0e 9c       	mov	r12,r7
800061a6:	f0 1f 00 19 	mcall	80006208 <tpa6130_dac_setup+0x7c>
800061aa:	c0 a1       	brne	800061be <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
800061ac:	0e 9a       	mov	r10,r7
800061ae:	e0 6b 44 00 	mov	r11,17408
800061b2:	ea 1b 00 ac 	orh	r11,0xac
800061b6:	fe 7c 40 00 	mov	r12,-49152
800061ba:	f0 1f 00 15 	mcall	8000620c <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
800061be:	58 06       	cp.w	r6,0
800061c0:	c0 50       	breq	800061ca <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
800061c2:	fe 7c 40 00 	mov	r12,-49152
800061c6:	f0 1f 00 13 	mcall	80006210 <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
800061ca:	fe 7c 40 00 	mov	r12,-49152
800061ce:	f0 1f 00 12 	mcall	80006214 <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
800061d2:	49 28       	lddpc	r8,80006218 <tpa6130_dac_setup+0x8c>
800061d4:	1a 9b       	mov	r11,sp
800061d6:	f0 e6 00 00 	ld.d	r6,r8[0]
800061da:	fa e7 00 00 	st.d	sp[0],r6
800061de:	f0 e6 00 08 	ld.d	r6,r8[8]
800061e2:	fa e7 00 08 	st.d	sp[8],r6
800061e6:	f0 e8 00 10 	ld.d	r8,r8[16]
800061ea:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800061ee:	30 0c       	mov	r12,0
800061f0:	f0 1f 00 0b 	mcall	8000621c <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
800061f4:	30 0c       	mov	r12,0
800061f6:	f0 1f 00 0b 	mcall	80006220 <tpa6130_dac_setup+0x94>

}
800061fa:	2f ad       	sub	sp,-24
800061fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006200:	00 00       	add	r0,r0
80006202:	05 54       	ld.sh	r4,--r2
80006204:	80 00       	ld.sh	r0,r0[0x0]
80006206:	61 3c       	ld.w	r12,r0[0x4c]
80006208:	80 00       	ld.sh	r0,r0[0x0]
8000620a:	63 48       	ld.w	r8,r1[0x50]
8000620c:	80 00       	ld.sh	r0,r0[0x0]
8000620e:	62 ca       	ld.w	r10,r1[0x30]
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	62 b2       	ld.w	r2,r1[0x2c]
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	62 88       	ld.w	r8,r1[0x20]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	9d a8       	st.w	lr[0x28],r8
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	65 f4       	ld.w	r4,r2[0x7c]
80006220:	80 00       	ld.sh	r0,r0[0x0]
80006222:	65 84       	ld.w	r4,r2[0x60]

80006224 <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80006224:	eb cd 40 fe 	pushm	r1-r7,lr
80006228:	fa c4 ff e0 	sub	r4,sp,-32
8000622c:	18 92       	mov	r2,r12
8000622e:	16 93       	mov	r3,r11
80006230:	14 95       	mov	r5,r10
80006232:	12 97       	mov	r7,r9
80006234:	10 96       	mov	r6,r8
80006236:	68 01       	ld.w	r1,r4[0x0]
80006238:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
8000623a:	f0 1f 00 0d 	mcall	8000626c <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
8000623e:	30 4b       	mov	r11,4
80006240:	48 cc       	lddpc	r12,80006270 <tpa6130_dac_start+0x4c>
80006242:	f0 1f 00 0d 	mcall	80006274 <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
80006246:	1a d4       	st.w	--sp,r4
80006248:	1a d1       	st.w	--sp,r1
8000624a:	0c 98       	mov	r8,r6
8000624c:	0e 99       	mov	r9,r7
8000624e:	0a 9a       	mov	r10,r5
80006250:	06 9b       	mov	r11,r3
80006252:	04 9c       	mov	r12,r2
80006254:	f0 1f 00 09 	mcall	80006278 <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
80006258:	30 1a       	mov	r10,1
8000625a:	36 0b       	mov	r11,96
8000625c:	48 8c       	lddpc	r12,8000627c <tpa6130_dac_start+0x58>
8000625e:	f0 1f 00 09 	mcall	80006280 <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
80006262:	f0 1f 00 09 	mcall	80006284 <tpa6130_dac_start+0x60>
80006266:	2f ed       	sub	sp,-8

}
80006268:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	60 f8       	ld.w	r8,r0[0x3c]
80006270:	80 00       	ld.sh	r0,r0[0x0]
80006272:	9d c0       	st.w	lr[0x30],r0
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	80 60       	ld.sh	r0,r0[0xc]
80006278:	80 00       	ld.sh	r0,r0[0x0]
8000627a:	61 8c       	ld.w	r12,r0[0x60]
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	5f 7c       	srpl	r12
80006280:	80 00       	ld.sh	r0,r0[0x0]
80006282:	81 80       	st.w	r0[0x20],r0
80006284:	80 00       	ld.sh	r0,r0[0x0]
80006286:	60 b8       	ld.w	r8,r0[0x2c]

80006288 <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80006288:	fe 78 0c 00 	mov	r8,-62464
8000628c:	71 d9       	ld.w	r9,r8[0x74]
8000628e:	a3 a9       	sbr	r9,0x2
80006290:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80006294:	78 28       	ld.w	r8,r12[0x8]
80006296:	bf b8       	sbr	r8,0x1f
80006298:	99 28       	st.w	r12[0x8],r8
}
8000629a:	5e fc       	retal	r12

8000629c <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
8000629c:	78 28       	ld.w	r8,r12[0x8]
8000629e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800062a2:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
800062a4:	fe 78 0c 00 	mov	r8,-62464
800062a8:	71 d9       	ld.w	r9,r8[0x74]
800062aa:	a3 c9       	cbr	r9,0x2
800062ac:	f1 49 00 74 	st.w	r8[116],r9
}
800062b0:	5e fc       	retal	r12

800062b2 <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
800062b2:	78 28       	ld.w	r8,r12[0x8]
800062b4:	e6 18 40 00 	andh	r8,0x4000,COH
800062b8:	c0 50       	breq	800062c2 <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
800062ba:	78 28       	ld.w	r8,r12[0x8]
800062bc:	bf c8       	cbr	r8,0x1e
800062be:	99 28       	st.w	r12[0x8],r8
800062c0:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
800062c2:	78 28       	ld.w	r8,r12[0x8]
800062c4:	bf a8       	sbr	r8,0x1e
800062c6:	99 28       	st.w	r12[0x8],r8
800062c8:	5e fc       	retal	r12

800062ca <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800062ca:	fe 78 0c 00 	mov	r8,-62464
800062ce:	71 d9       	ld.w	r9,r8[0x74]
800062d0:	30 0c       	mov	r12,0
800062d2:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800062d6:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
800062da:	71 d9       	ld.w	r9,r8[0x74]
800062dc:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800062e0:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
800062e4:	a9 6a       	lsl	r10,0x8
800062e6:	16 3a       	cp.w	r10,r11
800062e8:	e0 88 00 09 	brls	800062fa <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
800062ec:	71 d9       	ld.w	r9,r8[0x74]
800062ee:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800062f2:	f1 49 00 74 	st.w	r8[116],r9
800062f6:	31 6c       	mov	r12,22
    return EINVAL;
800062f8:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
800062fa:	f6 0a 0d 08 	divu	r8,r11,r10
800062fe:	5c 88       	casts.h	r8

  if (div > 1) {
80006300:	30 19       	mov	r9,1
80006302:	f2 08 19 00 	cp.h	r8,r9
80006306:	e0 88 00 14 	brls	8000632e <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
8000630a:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
8000630e:	20 1c       	sub	r12,1
80006310:	5c 5c       	castu.b	r12
80006312:	fe 79 0c 00 	mov	r9,-62464
80006316:	73 da       	ld.w	r10,r9[0x74]
80006318:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
8000631c:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
80006320:	73 da       	ld.w	r10,r9[0x74]
80006322:	30 1c       	mov	r12,1
80006324:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80006328:	f3 4a 00 74 	st.w	r9[116],r10
8000632c:	c0 98       	rjmp	8000633e <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
8000632e:	fe 79 0c 00 	mov	r9,-62464
80006332:	73 da       	ld.w	r10,r9[0x74]
80006334:	30 0c       	mov	r12,0
80006336:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
8000633a:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
8000633e:	5c 78       	castu.h	r8
80006340:	a9 68       	lsl	r8,0x8
80006342:	f6 08 0d 0a 	divu	r10,r11,r8
80006346:	5e fa       	retal	r10

80006348 <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80006348:	e0 4c 56 22 	cp.w	r12,22050
8000634c:	e0 80 00 8d 	breq	80006466 <abdac_set_dac_sample_rate+0x11e>
80006350:	e0 8b 00 12 	brhi	80006374 <abdac_set_dac_sample_rate+0x2c>
80006354:	e0 4c 2b 11 	cp.w	r12,11025
80006358:	c3 b0       	breq	800063ce <abdac_set_dac_sample_rate+0x86>
8000635a:	e0 8b 00 06 	brhi	80006366 <abdac_set_dac_sample_rate+0x1e>
8000635e:	e0 4c 1f 40 	cp.w	r12,8000
80006362:	c1 b1       	brne	80006398 <abdac_set_dac_sample_rate+0x50>
80006364:	c1 b8       	rjmp	8000639a <abdac_set_dac_sample_rate+0x52>
80006366:	e0 4c 2e e0 	cp.w	r12,12000
8000636a:	c4 b0       	breq	80006400 <abdac_set_dac_sample_rate+0xb8>
8000636c:	e0 4c 3e 80 	cp.w	r12,16000
80006370:	c1 41       	brne	80006398 <abdac_set_dac_sample_rate+0x50>
80006372:	c6 18       	rjmp	80006434 <abdac_set_dac_sample_rate+0xec>
80006374:	e0 4c 7d 00 	cp.w	r12,32000
80006378:	e0 80 00 aa 	breq	800064cc <abdac_set_dac_sample_rate+0x184>
8000637c:	e0 8b 00 06 	brhi	80006388 <abdac_set_dac_sample_rate+0x40>
80006380:	e0 4c 5d c0 	cp.w	r12,24000
80006384:	c0 a1       	brne	80006398 <abdac_set_dac_sample_rate+0x50>
80006386:	c8 98       	rjmp	80006498 <abdac_set_dac_sample_rate+0x150>
80006388:	e0 4c ac 44 	cp.w	r12,44100
8000638c:	e0 80 00 b9 	breq	800064fe <abdac_set_dac_sample_rate+0x1b6>
80006390:	e0 4c bb 80 	cp.w	r12,48000
80006394:	e0 80 00 ce 	breq	80006530 <abdac_set_dac_sample_rate+0x1e8>
80006398:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
8000639a:	fe 78 0c 00 	mov	r8,-62464
8000639e:	71 d9       	ld.w	r9,r8[0x74]
800063a0:	30 ea       	mov	r10,14
800063a2:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800063a6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800063aa:	71 d9       	ld.w	r9,r8[0x74]
800063ac:	30 1c       	mov	r12,1
800063ae:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800063b2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800063b6:	71 d9       	ld.w	r9,r8[0x74]
800063b8:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800063bc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800063c0:	71 d9       	ld.w	r9,r8[0x74]
800063c2:	30 0a       	mov	r10,0
800063c4:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800063c8:	f1 49 00 74 	st.w	r8[116],r9
      break;
800063cc:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
800063ce:	fe 78 0c 00 	mov	r8,-62464
800063d2:	71 d9       	ld.w	r9,r8[0x74]
800063d4:	30 1c       	mov	r12,1
800063d6:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
800063da:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800063de:	71 d9       	ld.w	r9,r8[0x74]
800063e0:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800063e4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800063e8:	71 d9       	ld.w	r9,r8[0x74]
800063ea:	30 0a       	mov	r10,0
800063ec:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
800063f0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
800063f4:	71 d9       	ld.w	r9,r8[0x74]
800063f6:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800063fa:	f1 49 00 74 	st.w	r8[116],r9
        break;
800063fe:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
80006400:	fe 78 0c 00 	mov	r8,-62464
80006404:	71 d9       	ld.w	r9,r8[0x74]
80006406:	30 9a       	mov	r10,9
80006408:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000640c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80006410:	71 d9       	ld.w	r9,r8[0x74]
80006412:	30 1c       	mov	r12,1
80006414:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80006418:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
8000641c:	71 d9       	ld.w	r9,r8[0x74]
8000641e:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80006422:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80006426:	71 d9       	ld.w	r9,r8[0x74]
80006428:	30 0a       	mov	r10,0
8000642a:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
8000642e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80006432:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80006434:	fe 78 0c 00 	mov	r8,-62464
80006438:	71 d9       	ld.w	r9,r8[0x74]
8000643a:	30 5a       	mov	r10,5
8000643c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80006440:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80006444:	71 d9       	ld.w	r9,r8[0x74]
80006446:	30 1c       	mov	r12,1
80006448:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000644c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80006450:	71 d9       	ld.w	r9,r8[0x74]
80006452:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80006456:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
8000645a:	71 d9       	ld.w	r9,r8[0x74]
8000645c:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80006460:	f1 49 00 74 	st.w	r8[116],r9
        break;
80006464:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80006466:	fe 78 0c 00 	mov	r8,-62464
8000646a:	71 d9       	ld.w	r9,r8[0x74]
8000646c:	30 0a       	mov	r10,0
8000646e:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80006472:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80006476:	71 d9       	ld.w	r9,r8[0x74]
80006478:	30 1c       	mov	r12,1
8000647a:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000647e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80006482:	71 d9       	ld.w	r9,r8[0x74]
80006484:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80006488:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
8000648c:	71 d9       	ld.w	r9,r8[0x74]
8000648e:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80006492:	f1 49 00 74 	st.w	r8[116],r9
        break;
80006496:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80006498:	fe 78 0c 00 	mov	r8,-62464
8000649c:	71 d9       	ld.w	r9,r8[0x74]
8000649e:	30 4a       	mov	r10,4
800064a0:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800064a4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800064a8:	71 d9       	ld.w	r9,r8[0x74]
800064aa:	30 1c       	mov	r12,1
800064ac:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800064b0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800064b4:	71 d9       	ld.w	r9,r8[0x74]
800064b6:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800064ba:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800064be:	71 d9       	ld.w	r9,r8[0x74]
800064c0:	30 0a       	mov	r10,0
800064c2:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800064c6:	f1 49 00 74 	st.w	r8[116],r9
        break;
800064ca:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
800064cc:	fe 78 0c 00 	mov	r8,-62464
800064d0:	71 d9       	ld.w	r9,r8[0x74]
800064d2:	30 2a       	mov	r10,2
800064d4:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800064d8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800064dc:	71 d9       	ld.w	r9,r8[0x74]
800064de:	30 1c       	mov	r12,1
800064e0:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800064e4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800064e8:	71 d9       	ld.w	r9,r8[0x74]
800064ea:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800064ee:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
800064f2:	71 d9       	ld.w	r9,r8[0x74]
800064f4:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800064f8:	f1 49 00 74 	st.w	r8[116],r9
        break;
800064fc:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
800064fe:	fe 78 0c 00 	mov	r8,-62464
80006502:	71 da       	ld.w	r10,r8[0x74]
80006504:	30 09       	mov	r9,0
80006506:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
8000650a:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
8000650e:	71 da       	ld.w	r10,r8[0x74]
80006510:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80006514:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80006518:	71 da       	ld.w	r10,r8[0x74]
8000651a:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
8000651e:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80006522:	71 d9       	ld.w	r9,r8[0x74]
80006524:	30 1c       	mov	r12,1
80006526:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000652a:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000652e:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80006530:	fe 78 0c 00 	mov	r8,-62464
80006534:	71 d9       	ld.w	r9,r8[0x74]
80006536:	30 1c       	mov	r12,1
80006538:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
8000653c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80006540:	71 d9       	ld.w	r9,r8[0x74]
80006542:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80006546:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
8000654a:	71 d9       	ld.w	r9,r8[0x74]
8000654c:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80006550:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80006554:	71 d9       	ld.w	r9,r8[0x74]
80006556:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000655a:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
8000655e:	5e fc       	retal	r12

80006560 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80006560:	30 e8       	mov	r8,14
80006562:	f0 0c 18 00 	cp.b	r12,r8
80006566:	e0 88 00 03 	brls	8000656c <pdca_get_handler+0xc>
8000656a:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000656c:	a7 6c       	lsl	r12,0x6
8000656e:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80006572:	5e fc       	retal	r12

80006574 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80006574:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80006576:	f0 1f 00 03 	mcall	80006580 <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000657a:	30 28       	mov	r8,2
8000657c:	99 58       	st.w	r12[0x14],r8
}
8000657e:	d8 02       	popm	pc
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	65 60       	ld.w	r0,r2[0x58]

80006584 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
80006584:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80006586:	f0 1f 00 03 	mcall	80006590 <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
8000658a:	30 18       	mov	r8,1
8000658c:	99 58       	st.w	r12[0x14],r8
}
8000658e:	d8 02       	popm	pc
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	65 60       	ld.w	r0,r2[0x58]

80006594 <pdca_get_transfer_status>:

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
}

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
80006594:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80006596:	f0 1f 00 03 	mcall	800065a0 <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
8000659a:	78 bc       	ld.w	r12,r12[0x2c]
}
8000659c:	d8 02       	popm	pc
8000659e:	00 00       	add	r0,r0
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	65 60       	ld.w	r0,r2[0x58]

800065a4 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800065a4:	d4 01       	pushm	lr
800065a6:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800065a8:	f0 1f 00 08 	mcall	800065c8 <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800065ac:	e1 b8 00 00 	mfsr	r8,0x0
800065b0:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800065b2:	d3 03       	ssrf	0x10

	return flags;
800065b4:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800065b6:	30 19       	mov	r9,1
800065b8:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800065ba:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800065bc:	e6 18 00 01 	andh	r8,0x1,COH
800065c0:	c0 21       	brne	800065c4 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
800065c2:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800065c4:	2f fd       	sub	sp,-4
800065c6:	d8 02       	popm	pc
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	65 60       	ld.w	r0,r2[0x58]

800065cc <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800065cc:	d4 01       	pushm	lr
800065ce:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800065d0:	f0 1f 00 08 	mcall	800065f0 <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800065d4:	e1 b8 00 00 	mfsr	r8,0x0
800065d8:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800065da:	d3 03       	ssrf	0x10

	return flags;
800065dc:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800065de:	30 29       	mov	r9,2
800065e0:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800065e2:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800065e4:	e6 18 00 01 	andh	r8,0x1,COH
800065e8:	c0 21       	brne	800065ec <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800065ea:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800065ec:	2f fd       	sub	sp,-4
800065ee:	d8 02       	popm	pc
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	65 60       	ld.w	r0,r2[0x58]

800065f4 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
800065f4:	eb cd 40 e0 	pushm	r5-r7,lr
800065f8:	20 1d       	sub	sp,4
800065fa:	18 95       	mov	r5,r12
800065fc:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800065fe:	f0 1f 00 13 	mcall	80006648 <pdca_init_channel+0x54>
80006602:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80006604:	0a 9c       	mov	r12,r5
80006606:	f0 1f 00 12 	mcall	8000664c <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
8000660a:	0a 9c       	mov	r12,r5
8000660c:	f0 1f 00 11 	mcall	80006650 <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006610:	e1 b8 00 00 	mfsr	r8,0x0
80006614:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80006616:	d3 03       	ssrf	0x10

	return flags;
80006618:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
8000661a:	6c 09       	ld.w	r9,r6[0x0]
8000661c:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
8000661e:	6c 19       	ld.w	r9,r6[0x4]
80006620:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
80006622:	6c 49       	ld.w	r9,r6[0x10]
80006624:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
80006626:	6c 29       	ld.w	r9,r6[0x8]
80006628:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
8000662a:	6c 39       	ld.w	r9,r6[0xc]
8000662c:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
8000662e:	6c 59       	ld.w	r9,r6[0x14]
80006630:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80006632:	e0 69 01 00 	mov	r9,256
80006636:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
80006638:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000663a:	e6 18 00 01 	andh	r8,0x1,COH
8000663e:	c0 21       	brne	80006642 <pdca_init_channel+0x4e>
      cpu_irq_enable();
80006640:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80006642:	2f fd       	sub	sp,-4
80006644:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	65 60       	ld.w	r0,r2[0x58]
8000664c:	80 00       	ld.sh	r0,r0[0x0]
8000664e:	65 cc       	ld.w	r12,r2[0x70]
80006650:	80 00       	ld.sh	r0,r0[0x0]
80006652:	65 a4       	ld.w	r4,r2[0x68]

80006654 <twi_master_interrupt_handler_not_naked>:
/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80006654:	4a 78       	lddpc	r8,800066f0 <twi_master_interrupt_handler_not_naked+0x9c>
80006656:	70 08       	ld.w	r8,r8[0x0]
80006658:	70 89       	ld.w	r9,r8[0x20]
8000665a:	4a 7a       	lddpc	r10,800066f4 <twi_master_interrupt_handler_not_naked+0xa0>
8000665c:	74 0a       	ld.w	r10,r10[0x0]
8000665e:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80006662:	12 9a       	mov	r10,r9
80006664:	e2 1a 01 00 	andl	r10,0x100,COH
80006668:	c3 91       	brne	800066da <twi_master_interrupt_handler_not_naked+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
8000666a:	12 9a       	mov	r10,r9
8000666c:	e2 1a 00 02 	andl	r10,0x2,COH
80006670:	c1 70       	breq	8000669e <twi_master_interrupt_handler_not_naked+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80006672:	4a 29       	lddpc	r9,800066f8 <twi_master_interrupt_handler_not_naked+0xa4>
80006674:	72 0a       	ld.w	r10,r9[0x0]
80006676:	70 cb       	ld.w	r11,r8[0x30]
80006678:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
8000667a:	72 0a       	ld.w	r10,r9[0x0]
8000667c:	2f fa       	sub	r10,-1
8000667e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80006680:	49 f9       	lddpc	r9,800066fc <twi_master_interrupt_handler_not_naked+0xa8>
80006682:	72 0a       	ld.w	r10,r9[0x0]
80006684:	20 1a       	sub	r10,1
80006686:	93 0a       	st.w	r9[0x0],r10
80006688:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
8000668a:	58 19       	cp.w	r9,1
8000668c:	f9 b9 00 02 	moveq	r9,2
80006690:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80006694:	49 a9       	lddpc	r9,800066fc <twi_master_interrupt_handler_not_naked+0xa8>
80006696:	72 09       	ld.w	r9,r9[0x0]
80006698:	58 09       	cp.w	r9,0
8000669a:	c2 30       	breq	800066e0 <twi_master_interrupt_handler_not_naked+0x8c>
8000669c:	5e fc       	retal	r12
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
8000669e:	12 9a       	mov	r10,r9
800066a0:	e2 1a 00 04 	andl	r10,0x4,COH
800066a4:	c1 70       	breq	800066d2 <twi_master_interrupt_handler_not_naked+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800066a6:	49 79       	lddpc	r9,80006700 <twi_master_interrupt_handler_not_naked+0xac>
800066a8:	72 0a       	ld.w	r10,r9[0x0]
800066aa:	20 1a       	sub	r10,1
800066ac:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800066ae:	72 09       	ld.w	r9,r9[0x0]
800066b0:	58 09       	cp.w	r9,0
800066b2:	e0 89 00 0a 	brgt	800066c6 <twi_master_interrupt_handler_not_naked+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800066b6:	49 09       	lddpc	r9,800066f4 <twi_master_interrupt_handler_not_naked+0xa0>
800066b8:	30 1a       	mov	r10,1
800066ba:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
800066bc:	3f fa       	mov	r10,-1
800066be:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
800066c0:	72 09       	ld.w	r9,r9[0x0]
800066c2:	91 99       	st.w	r8[0x24],r9
800066c4:	5e fc       	retal	r12
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
800066c6:	49 0a       	lddpc	r10,80006704 <twi_master_interrupt_handler_not_naked+0xb0>
800066c8:	74 09       	ld.w	r9,r10[0x0]
800066ca:	13 3b       	ld.ub	r11,r9++
800066cc:	91 db       	st.w	r8[0x34],r11
800066ce:	95 09       	st.w	r10[0x0],r9
800066d0:	5e fc       	retal	r12
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
800066d2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800066d6:	c0 51       	brne	800066e0 <twi_master_interrupt_handler_not_naked+0x8c>
800066d8:	5e fc       	retal	r12
	}

	return;

nack:
	twi_nack = true;
800066da:	30 1a       	mov	r10,1
800066dc:	48 b9       	lddpc	r9,80006708 <twi_master_interrupt_handler_not_naked+0xb4>
800066de:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
800066e0:	3f f9       	mov	r9,-1
800066e2:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
800066e4:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
800066e6:	30 09       	mov	r9,0
800066e8:	48 98       	lddpc	r8,8000670c <twi_master_interrupt_handler_not_naked+0xb8>
800066ea:	b0 89       	st.b	r8[0x0],r9

	return;
}
800066ec:	5e fc       	retal	r12
800066ee:	00 00       	add	r0,r0
800066f0:	00 00       	add	r0,r0
800066f2:	05 6c       	ld.uh	r12,--r2
800066f4:	00 00       	add	r0,r0
800066f6:	05 68       	ld.uh	r8,--r2
800066f8:	00 00       	add	r0,r0
800066fa:	05 78       	ld.ub	r8,--r2
800066fc:	00 00       	add	r0,r0
800066fe:	05 74       	ld.ub	r4,--r2
80006700:	00 00       	add	r0,r0
80006702:	05 64       	ld.uh	r4,--r2
80006704:	00 00       	add	r0,r0
80006706:	05 70       	ld.ub	r0,--r2
80006708:	00 00       	add	r0,r0
8000670a:	05 61       	ld.uh	r1,--r2
8000670c:	00 00       	add	r0,r0
8000670e:	05 60       	ld.uh	r0,--r2

80006710 <twi_master_interrupt_handler>:
#define CONF_TWI_IRQ_GROUP         AVR32_TWI_IRQ_GROUP


/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
80006710:	eb cd 00 ff 	pushm	r0-r7
80006714:	f0 1f 00 03 	mcall	80006720 <twi_master_interrupt_handler+0x10>
80006718:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000671c:	d6 03       	rete
8000671e:	00 00       	add	r0,r0
80006720:	80 00       	ld.sh	r0,r0[0x0]
80006722:	66 54       	ld.w	r4,r3[0x14]

80006724 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
80006724:	18 98       	mov	r8,r12
	uint32_t val;

	if (len == 0)
80006726:	58 0b       	cp.w	r11,0
80006728:	c0 21       	brne	8000672c <twi_mk_addr+0x8>
8000672a:	5e fd       	retal	0
		return 0;

	val = addr[0];
8000672c:	19 8c       	ld.ub	r12,r12[0x0]
	if (len > 1) {
8000672e:	58 1b       	cp.w	r11,1
80006730:	e0 8a 00 05 	brle	8000673a <twi_mk_addr+0x16>
		val <<= 8;
		val |= addr[1];
80006734:	11 99       	ld.ub	r9,r8[0x1]
80006736:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
	}
	if (len > 2) {
8000673a:	58 2b       	cp.w	r11,2
8000673c:	5e ac       	retle	r12
		val <<= 8;
		val |= addr[2];
8000673e:	11 a8       	ld.ub	r8,r8[0x2]
80006740:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	}
	return val;
}
80006744:	5e fc       	retal	r12
80006746:	d7 03       	nop

80006748 <twi_is_busy>:
}


bool twi_is_busy(void)
{
	if (twi_busy) {
80006748:	48 28       	lddpc	r8,80006750 <twi_is_busy+0x8>
8000674a:	11 8c       	ld.ub	r12,r8[0x0]
		return true;          // Still receiving/transmitting...
	} else {
		return false;
	}
}
8000674c:	5e fc       	retal	r12
8000674e:	00 00       	add	r0,r0
80006750:	00 00       	add	r0,r0
80006752:	05 60       	ld.uh	r0,--r2

80006754 <twi_master_write>:
	return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80006754:	eb cd 40 c0 	pushm	r6-r7,lr
80006758:	18 96       	mov	r6,r12
8000675a:	16 97       	mov	r7,r11
	// No data to send
	if (package->length == 0) {
8000675c:	76 38       	ld.w	r8,r11[0xc]
8000675e:	58 08       	cp.w	r8,0
80006760:	c0 51       	brne	8000676a <twi_master_write+0x16>
80006762:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
80006766:	fe cf ff fc 	sub	pc,pc,-4
	// No data to send
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
8000676a:	f0 1f 00 1f 	mcall	800067e4 <twi_master_write+0x90>
8000676e:	cf c1       	brne	80006766 <twi_master_write+0x12>
		cpu_relax();
	};

	twi_nack = false;
80006770:	30 09       	mov	r9,0
80006772:	49 e8       	lddpc	r8,800067e8 <twi_master_write+0x94>
80006774:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
80006776:	30 19       	mov	r9,1
80006778:	49 d8       	lddpc	r8,800067ec <twi_master_write+0x98>
8000677a:	b0 89       	st.b	r8[0x0],r9

	// Enable master transfer, disable slave
	twi->cr =   AVR32_TWI_CR_MSEN_MASK
8000677c:	32 48       	mov	r8,36
8000677e:	8d 08       	st.w	r6[0x0],r8
			| AVR32_TWI_CR_SVDIS_MASK
#endif
			;

	// set write mode, slave address and 3 internal address byte length
	twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
80006780:	6e 18       	ld.w	r8,r7[0x4]
80006782:	a9 68       	lsl	r8,0x8
80006784:	e2 18 03 00 	andl	r8,0x300,COH
80006788:	0f 89       	ld.ub	r9,r7[0x0]
8000678a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000678e:	8d 18       	st.w	r6[0x4],r8
			(package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

	// Set pointer to TWI instance for IT
	twi_inst = twi;
80006790:	49 88       	lddpc	r8,800067f0 <twi_master_write+0x9c>
80006792:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
80006794:	6e 1b       	ld.w	r11,r7[0x4]
80006796:	ee cc ff ff 	sub	r12,r7,-1
8000679a:	f0 1f 00 17 	mcall	800067f4 <twi_master_write+0xa0>
8000679e:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_tx_data = package->buffer;
800067a0:	6e 29       	ld.w	r9,r7[0x8]
800067a2:	49 68       	lddpc	r8,800067f8 <twi_master_write+0xa4>
800067a4:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to write
	twi_tx_nb_bytes = package->length;
800067a6:	6e 3a       	ld.w	r10,r7[0xc]
800067a8:	49 59       	lddpc	r9,800067fc <twi_master_write+0xa8>
800067aa:	93 0a       	st.w	r9[0x0],r10

	// put the first byte in the Transmit Holding Register
	twi->thr = *twi_tx_data++;
800067ac:	70 09       	ld.w	r9,r8[0x0]
800067ae:	13 3a       	ld.ub	r10,r9++
800067b0:	8d da       	st.w	r6[0x34],r10
800067b2:	91 09       	st.w	r8[0x0],r9

	// mask NACK and TXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
800067b4:	49 38       	lddpc	r8,80006800 <twi_master_write+0xac>
800067b6:	e0 69 01 04 	mov	r9,260
800067ba:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
800067bc:	70 08       	ld.w	r8,r8[0x0]
800067be:	8d 98       	st.w	r6[0x24],r8

	// send data
	while (twi_is_busy()) {
800067c0:	c0 38       	rjmp	800067c6 <twi_master_write+0x72>
		cpu_relax();
800067c2:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// send data
	while (twi_is_busy()) {
800067c6:	f0 1f 00 08 	mcall	800067e4 <twi_master_write+0x90>
800067ca:	cf c1       	brne	800067c2 <twi_master_write+0x6e>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
800067cc:	30 88       	mov	r8,8
800067ce:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
800067d0:	48 68       	lddpc	r8,800067e8 <twi_master_write+0x94>
800067d2:	11 8c       	ld.ub	r12,r8[0x0]
800067d4:	58 0c       	cp.w	r12,0
800067d6:	f9 bc 01 fb 	movne	r12,-5
800067da:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
800067de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067e2:	00 00       	add	r0,r0
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	67 48       	ld.w	r8,r3[0x50]
800067e8:	00 00       	add	r0,r0
800067ea:	05 61       	ld.uh	r1,--r2
800067ec:	00 00       	add	r0,r0
800067ee:	05 60       	ld.uh	r0,--r2
800067f0:	00 00       	add	r0,r0
800067f2:	05 6c       	ld.uh	r12,--r2
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	67 24       	ld.w	r4,r3[0x48]
800067f8:	00 00       	add	r0,r0
800067fa:	05 70       	ld.ub	r0,--r2
800067fc:	00 00       	add	r0,r0
800067fe:	05 64       	ld.uh	r4,--r2
80006800:	00 00       	add	r0,r0
80006802:	05 68       	ld.uh	r8,--r2

80006804 <twi_probe>:
	cpu_irq_restore(flags);
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80006804:	d4 01       	pushm	lr
80006806:	20 5d       	sub	sp,20
	twi_package_t package;
	char data[1] = {0};
80006808:	30 08       	mov	r8,0
8000680a:	ba 88       	st.b	sp[0x0],r8

	// data to send
	package.buffer = data;
8000680c:	50 3d       	stdsp	sp[0xc],sp
	// chip address
	package.chip = chip_addr;
8000680e:	ba cb       	st.b	sp[0x4],r11
	// frame length
	package.length = 1;
80006810:	30 19       	mov	r9,1
80006812:	50 49       	stdsp	sp[0x10],r9
	// address length
	package.addr_length = 0;
80006814:	30 09       	mov	r9,0
80006816:	50 29       	stdsp	sp[0x8],r9
	// internal chip address
	package.addr[0] = 0;
80006818:	ba d8       	st.b	sp[0x5],r8
	// perform a master write access
	return (twi_master_write(twi, &package));
8000681a:	fa cb ff fc 	sub	r11,sp,-4
8000681e:	f0 1f 00 03 	mcall	80006828 <twi_probe+0x24>
}
80006822:	2f bd       	sub	sp,-20
80006824:	d8 02       	popm	pc
80006826:	00 00       	add	r0,r0
80006828:	80 00       	ld.sh	r0,r0[0x0]
8000682a:	67 54       	ld.w	r4,r3[0x54]

8000682c <twi_master_read>:
	}
	return val;
}

int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
8000682c:	eb cd 40 c0 	pushm	r6-r7,lr
80006830:	18 96       	mov	r6,r12
80006832:	16 97       	mov	r7,r11
	// check argument
	if (package->length == 0) {
80006834:	76 38       	ld.w	r8,r11[0xc]
80006836:	58 08       	cp.w	r8,0
80006838:	c0 51       	brne	80006842 <twi_master_read+0x16>
8000683a:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
8000683e:	fe cf ff fc 	sub	pc,pc,-4
	// check argument
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
80006842:	f0 1f 00 21 	mcall	800068c4 <twi_master_read+0x98>
80006846:	cf c1       	brne	8000683e <twi_master_read+0x12>
		cpu_relax();
	};

	twi_nack = false;
80006848:	30 09       	mov	r9,0
8000684a:	4a 08       	lddpc	r8,800068c8 <twi_master_read+0x9c>
8000684c:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
8000684e:	30 19       	mov	r9,1
80006850:	49 f8       	lddpc	r8,800068cc <twi_master_read+0xa0>
80006852:	b0 89       	st.b	r8[0x0],r9

	// set read mode, slave address and 3 internal address byte length
	twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
80006854:	0f 89       	ld.ub	r9,r7[0x0]
80006856:	6e 18       	ld.w	r8,r7[0x4]
80006858:	a9 68       	lsl	r8,0x8
8000685a:	e2 18 03 00 	andl	r8,0x300,COH
8000685e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80006862:	ad a8       	sbr	r8,0xc
80006864:	8d 18       	st.w	r6[0x4],r8
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
			(1 << AVR32_TWI_MMR_MREAD_OFFSET);

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80006866:	49 b8       	lddpc	r8,800068d0 <twi_master_read+0xa4>
80006868:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
8000686a:	6e 1b       	ld.w	r11,r7[0x4]
8000686c:	ee cc ff ff 	sub	r12,r7,-1
80006870:	f0 1f 00 19 	mcall	800068d4 <twi_master_read+0xa8>
80006874:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_rx_data = package->buffer;
80006876:	6e 29       	ld.w	r9,r7[0x8]
80006878:	49 88       	lddpc	r8,800068d8 <twi_master_read+0xac>
8000687a:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to read
	twi_rx_nb_bytes = package->length;
8000687c:	6e 39       	ld.w	r9,r7[0xc]
8000687e:	49 88       	lddpc	r8,800068dc <twi_master_read+0xb0>
80006880:	91 09       	st.w	r8[0x0],r9

	// Enable master transfer
	twi->cr =  AVR32_TWI_CR_MSEN_MASK;
80006882:	30 49       	mov	r9,4
80006884:	8d 09       	st.w	r6[0x0],r9

	// Send start condition
	twi->cr = AVR32_TWI_START_MASK;
80006886:	30 19       	mov	r9,1
80006888:	8d 09       	st.w	r6[0x0],r9

	// only one byte to receive
	if (twi_rx_nb_bytes == 1) {
8000688a:	70 08       	ld.w	r8,r8[0x0]
		// set stop bit
		twi->cr = AVR32_TWI_STOP_MASK;
8000688c:	12 38       	cp.w	r8,r9
8000688e:	f9 b8 00 02 	moveq	r8,2
80006892:	ed f8 0a 00 	st.weq	r6[0x0],r8
	}

	// mask NACK and RXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
80006896:	49 38       	lddpc	r8,800068e0 <twi_master_read+0xb4>
80006898:	e0 69 01 02 	mov	r9,258
8000689c:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
8000689e:	70 08       	ld.w	r8,r8[0x0]
800068a0:	8d 98       	st.w	r6[0x24],r8

	// get data
	while (twi_is_busy()) {
800068a2:	c0 38       	rjmp	800068a8 <twi_master_read+0x7c>
		cpu_relax();
800068a4:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// get data
	while (twi_is_busy()) {
800068a8:	f0 1f 00 07 	mcall	800068c4 <twi_master_read+0x98>
800068ac:	cf c1       	brne	800068a4 <twi_master_read+0x78>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
800068ae:	30 88       	mov	r8,8
800068b0:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
800068b2:	48 68       	lddpc	r8,800068c8 <twi_master_read+0x9c>
800068b4:	11 8c       	ld.ub	r12,r8[0x0]
800068b6:	58 0c       	cp.w	r12,0
800068b8:	f9 bc 01 fb 	movne	r12,-5
800068bc:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
800068c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	67 48       	ld.w	r8,r3[0x50]
800068c8:	00 00       	add	r0,r0
800068ca:	05 61       	ld.uh	r1,--r2
800068cc:	00 00       	add	r0,r0
800068ce:	05 60       	ld.uh	r0,--r2
800068d0:	00 00       	add	r0,r0
800068d2:	05 6c       	ld.uh	r12,--r2
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	67 24       	ld.w	r4,r3[0x48]
800068d8:	00 00       	add	r0,r0
800068da:	05 78       	ld.ub	r8,--r2
800068dc:	00 00       	add	r0,r0
800068de:	05 74       	ld.ub	r4,--r2
800068e0:	00 00       	add	r0,r0
800068e2:	05 68       	ld.uh	r8,--r2

800068e4 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
800068e4:	eb cd 40 e0 	pushm	r5-r7,lr
800068e8:	20 1d       	sub	sp,4
800068ea:	18 97       	mov	r7,r12
800068ec:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
800068ee:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800068f2:	4a 29       	lddpc	r9,80006978 <twi_master_init+0x94>
800068f4:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
800068f6:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
800068f8:	3f f9       	mov	r9,-1
800068fa:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
800068fc:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
800068fe:	e0 69 00 80 	mov	r9,128
80006902:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006904:	e6 18 00 01 	andh	r8,0x1,COH
80006908:	c0 21       	brne	8000690c <twi_master_init+0x28>
      cpu_irq_enable();
8000690a:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
8000690c:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000690e:	e1 b8 00 00 	mfsr	r8,0x0
80006912:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80006914:	d3 03       	ssrf	0x10

	return flags;
80006916:	40 06       	lddsp	r6,sp[0x0]

	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();
	INTC_init_interrupts(); /**/
80006918:	f0 1f 00 19 	mcall	8000697c <twi_master_init+0x98>
	INTC_register_interrupt(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL); /**/
8000691c:	30 3a       	mov	r10,3
8000691e:	e0 6b 01 60 	mov	r11,352
80006922:	49 8c       	lddpc	r12,80006980 <twi_master_init+0x9c>
80006924:	f0 1f 00 18 	mcall	80006984 <twi_master_init+0xa0>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006928:	e6 16 00 01 	andh	r6,0x1,COH
8000692c:	c0 21       	brne	80006930 <twi_master_init+0x4c>
      cpu_irq_enable();
8000692e:	d5 03       	csrf	0x10
	//irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE,
	//CONF_TWI_IRQ_LEVEL);
	cpu_irq_restore(flags);
	cpu_irq_enable(); /**/
80006930:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80006932:	6a 19       	ld.w	r9,r5[0x4]
80006934:	a1 79       	lsl	r9,0x1
80006936:	6a 08       	ld.w	r8,r5[0x0]
80006938:	f0 09 0d 08 	divu	r8,r8,r9
8000693c:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000693e:	e0 48 00 ff 	cp.w	r8,255
80006942:	e0 8b 00 04 	brhi	8000694a <twi_master_init+0x66>
80006946:	30 09       	mov	r9,0
80006948:	c0 f8       	rjmp	80006966 <twi_master_init+0x82>
8000694a:	30 09       	mov	r9,0
8000694c:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
8000694e:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80006950:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80006952:	e0 48 00 ff 	cp.w	r8,255
80006956:	5f bb       	srhi	r11
80006958:	58 69       	cp.w	r9,6
8000695a:	5f 8a       	srls	r10
8000695c:	f7 ea 00 0a 	and	r10,r11,r10
80006960:	f8 0a 18 00 	cp.b	r10,r12
80006964:	cf 51       	brne	8000694e <twi_master_init+0x6a>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80006966:	b1 69       	lsl	r9,0x10
80006968:	f3 e8 10 89 	or	r9,r9,r8<<0x8
8000696c:	f3 e8 10 08 	or	r8,r9,r8
80006970:	8f 48       	st.w	r7[0x10],r8

	// Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80006972:	2f fd       	sub	sp,-4
80006974:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80006978:	00 00       	add	r0,r0
8000697a:	05 6c       	ld.uh	r12,--r2
8000697c:	80 00       	ld.sh	r0,r0[0x0]
8000697e:	82 00       	ld.sh	r0,r1[0x0]
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	67 10       	ld.w	r0,r3[0x44]
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	81 80       	st.w	r0[0x20],r0

80006988 <print_char>:
  usart_write_line(usart, str);
}


void print_char(volatile avr32_usart_t *usart, int c)
{
80006988:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input character with the given USART.
  usart_putchar(usart, c);
8000698a:	f0 1f 00 02 	mcall	80006990 <print_char+0x8>
}
8000698e:	d8 02       	popm	pc
80006990:	80 00       	ld.sh	r0,r0[0x0]
80006992:	6c d0       	ld.w	r0,r6[0x34]

80006994 <print_dbg_char>:
  print(DBG_USART, str);
}


void print_dbg_char(int c)
{
80006994:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_char(DBG_USART, c);
80006996:	18 9b       	mov	r11,r12
80006998:	fe 7c 14 00 	mov	r12,-60416
8000699c:	f0 1f 00 02 	mcall	800069a4 <print_dbg_char+0x10>
}
800069a0:	d8 02       	popm	pc
800069a2:	00 00       	add	r0,r0
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	69 88       	ld.w	r8,r4[0x60]

800069a8 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
800069a8:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
800069aa:	f0 1f 00 02 	mcall	800069b0 <print+0x8>
}
800069ae:	d8 02       	popm	pc
800069b0:	80 00       	ld.sh	r0,r0[0x0]
800069b2:	6c fc       	ld.w	r12,r6[0x3c]

800069b4 <print_ulong>:
  usart_putchar(usart, c);
}


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
800069b4:	eb cd 40 e0 	pushm	r5-r7,lr
800069b8:	20 3d       	sub	sp,12
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
800069ba:	30 08       	mov	r8,0
800069bc:	fb 68 00 0a 	st.b	sp[10],r8
800069c0:	30 a9       	mov	r9,10
  do
  {
    tmp[--i] = '0' + n % 10;
800069c2:	1a 95       	mov	r5,sp
800069c4:	e0 6e cc cd 	mov	lr,52429
800069c8:	ea 1e cc cc 	orh	lr,0xcccc
800069cc:	20 19       	sub	r9,1
800069ce:	f6 0e 06 46 	mulu.d	r6,r11,lr
800069d2:	0e 98       	mov	r8,r7
800069d4:	a3 98       	lsr	r8,0x3
800069d6:	f0 08 00 2a 	add	r10,r8,r8<<0x2
800069da:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
800069de:	2d 0b       	sub	r11,-48
800069e0:	ea 09 0b 0b 	st.b	r5[r9],r11
    n /= 10;
800069e4:	10 9b       	mov	r11,r8
  } while (n);
800069e6:	58 08       	cp.w	r8,0
800069e8:	cf 21       	brne	800069cc <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
800069ea:	1a 9b       	mov	r11,sp
800069ec:	12 0b       	add	r11,r9
800069ee:	f0 1f 00 03 	mcall	800069f8 <print_ulong+0x44>
}
800069f2:	2f dd       	sub	sp,-12
800069f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	69 a8       	ld.w	r8,r4[0x68]

800069fc <print_dbg_ulong>:
  print_char(DBG_USART, c);
}


void print_dbg_ulong(unsigned long n)
{
800069fc:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
800069fe:	18 9b       	mov	r11,r12
80006a00:	fe 7c 14 00 	mov	r12,-60416
80006a04:	f0 1f 00 02 	mcall	80006a0c <print_dbg_ulong+0x10>
}
80006a08:	d8 02       	popm	pc
80006a0a:	00 00       	add	r0,r0
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	69 b4       	ld.w	r4,r4[0x6c]

80006a10 <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
80006a10:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
80006a12:	18 9b       	mov	r11,r12
80006a14:	fe 7c 14 00 	mov	r12,-60416
80006a18:	f0 1f 00 02 	mcall	80006a20 <print_dbg+0x10>
}
80006a1c:	d8 02       	popm	pc
80006a1e:	00 00       	add	r0,r0
80006a20:	80 00       	ld.sh	r0,r0[0x0]
80006a22:	69 a8       	ld.w	r8,r4[0x68]

80006a24 <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
80006a24:	eb cd 40 80 	pushm	r7,lr
80006a28:	20 3d       	sub	sp,12
80006a2a:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
80006a2c:	50 0c       	stdsp	sp[0x0],r12
80006a2e:	30 88       	mov	r8,8
80006a30:	ba c8       	st.b	sp[0x4],r8
80006a32:	30 48       	mov	r8,4
80006a34:	ba d8       	st.b	sp[0x5],r8
80006a36:	30 08       	mov	r8,0
80006a38:	ba 38       	st.h	sp[0x6],r8
80006a3a:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
80006a3e:	30 2b       	mov	r11,2
80006a40:	48 6c       	lddpc	r12,80006a58 <init_dbg_rs232_ex+0x34>
80006a42:	f0 1f 00 07 	mcall	80006a5c <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
80006a46:	0e 9a       	mov	r10,r7
80006a48:	1a 9b       	mov	r11,sp
80006a4a:	fe 7c 14 00 	mov	r12,-60416
80006a4e:	f0 1f 00 05 	mcall	80006a60 <init_dbg_rs232_ex+0x3c>
}
80006a52:	2f dd       	sub	sp,-12
80006a54:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	9d e0       	st.w	lr[0x38],r0
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	80 60       	ld.sh	r0,r0[0xc]
80006a60:	80 00       	ld.sh	r0,r0[0x0]
80006a62:	6d 4c       	ld.w	r12,r6[0x50]

80006a64 <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80006a64:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
80006a66:	18 9b       	mov	r11,r12
80006a68:	e0 6c e1 00 	mov	r12,57600
80006a6c:	f0 1f 00 02 	mcall	80006a74 <init_dbg_rs232+0x10>
}
80006a70:	d8 02       	popm	pc
80006a72:	00 00       	add	r0,r0
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	6a 24       	ld.w	r4,r5[0x8]

80006a78 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006a78:	fe 68 14 00 	mov	r8,-125952
80006a7c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80006a7e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006a82:	91 09       	st.w	r8[0x0],r9
}
80006a84:	5e fc       	retal	r12

80006a86 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006a86:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80006a88:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006a8c:	99 a8       	st.w	r12[0x28],r8
}
80006a8e:	5e fc       	retal	r12

80006a90 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80006a90:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80006a92:	ec 5b bb 9f 	cp.w	r11,899999
80006a96:	e0 8b 00 04 	brhi	80006a9e <pm_enable_osc0_crystal+0xe>
80006a9a:	30 4b       	mov	r11,4
80006a9c:	c1 38       	rjmp	80006ac2 <pm_enable_osc0_crystal+0x32>
80006a9e:	e0 68 c6 bf 	mov	r8,50879
80006aa2:	ea 18 00 2d 	orh	r8,0x2d
80006aa6:	10 3b       	cp.w	r11,r8
80006aa8:	e0 8b 00 04 	brhi	80006ab0 <pm_enable_osc0_crystal+0x20>
80006aac:	30 5b       	mov	r11,5
80006aae:	c0 a8       	rjmp	80006ac2 <pm_enable_osc0_crystal+0x32>
80006ab0:	e0 68 12 00 	mov	r8,4608
80006ab4:	ea 18 00 7a 	orh	r8,0x7a
80006ab8:	10 3b       	cp.w	r11,r8
80006aba:	f9 bb 03 06 	movlo	r11,6
80006abe:	f9 bb 02 07 	movhs	r11,7
80006ac2:	f0 1f 00 02 	mcall	80006ac8 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80006ac6:	d8 02       	popm	pc
80006ac8:	80 00       	ld.sh	r0,r0[0x0]
80006aca:	6a 86       	ld.w	r6,r5[0x20]

80006acc <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006acc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006ace:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006ad2:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80006ad4:	78 08       	ld.w	r8,r12[0x0]
80006ad6:	a3 a8       	sbr	r8,0x2
80006ad8:	99 08       	st.w	r12[0x0],r8
}
80006ada:	5e fc       	retal	r12

80006adc <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006adc:	79 58       	ld.w	r8,r12[0x54]
80006ade:	e2 18 00 80 	andl	r8,0x80,COH
80006ae2:	cf d0       	breq	80006adc <pm_wait_for_clk0_ready>
}
80006ae4:	5e fc       	retal	r12
80006ae6:	d7 03       	nop

80006ae8 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80006ae8:	eb cd 40 80 	pushm	r7,lr
80006aec:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006aee:	f0 1f 00 04 	mcall	80006afc <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80006af2:	0e 9c       	mov	r12,r7
80006af4:	f0 1f 00 03 	mcall	80006b00 <pm_enable_clk0+0x18>
}
80006af8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006afc:	80 00       	ld.sh	r0,r0[0x0]
80006afe:	6a cc       	ld.w	r12,r5[0x30]
80006b00:	80 00       	ld.sh	r0,r0[0x0]
80006b02:	6a dc       	ld.w	r12,r5[0x34]

80006b04 <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80006b04:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
80006b06:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80006b0a:	99 b8       	st.w	r12[0x2c],r8
}
80006b0c:	5e fc       	retal	r12
80006b0e:	d7 03       	nop

80006b10 <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
80006b10:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
80006b12:	ec 5b bb 9f 	cp.w	r11,899999
80006b16:	e0 8b 00 04 	brhi	80006b1e <pm_enable_osc1_crystal+0xe>
80006b1a:	30 4b       	mov	r11,4
80006b1c:	c1 38       	rjmp	80006b42 <pm_enable_osc1_crystal+0x32>
80006b1e:	e0 68 c6 bf 	mov	r8,50879
80006b22:	ea 18 00 2d 	orh	r8,0x2d
80006b26:	10 3b       	cp.w	r11,r8
80006b28:	e0 8b 00 04 	brhi	80006b30 <pm_enable_osc1_crystal+0x20>
80006b2c:	30 5b       	mov	r11,5
80006b2e:	c0 a8       	rjmp	80006b42 <pm_enable_osc1_crystal+0x32>
80006b30:	e0 68 12 00 	mov	r8,4608
80006b34:	ea 18 00 7a 	orh	r8,0x7a
80006b38:	10 3b       	cp.w	r11,r8
80006b3a:	f9 bb 03 06 	movlo	r11,6
80006b3e:	f9 bb 02 07 	movhs	r11,7
80006b42:	f0 1f 00 02 	mcall	80006b48 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80006b46:	d8 02       	popm	pc
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	6b 04       	ld.w	r4,r5[0x40]

80006b4c <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80006b4c:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
80006b4e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80006b52:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80006b54:	78 08       	ld.w	r8,r12[0x0]
80006b56:	a3 b8       	sbr	r8,0x3
80006b58:	99 08       	st.w	r12[0x0],r8
}
80006b5a:	5e fc       	retal	r12

80006b5c <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80006b5c:	79 58       	ld.w	r8,r12[0x54]
80006b5e:	e2 18 01 00 	andl	r8,0x100,COH
80006b62:	cf d0       	breq	80006b5c <pm_wait_for_clk1_ready>
}
80006b64:	5e fc       	retal	r12
80006b66:	d7 03       	nop

80006b68 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80006b68:	eb cd 40 80 	pushm	r7,lr
80006b6c:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
80006b6e:	f0 1f 00 04 	mcall	80006b7c <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
80006b72:	0e 9c       	mov	r12,r7
80006b74:	f0 1f 00 03 	mcall	80006b80 <pm_enable_clk1+0x18>
}
80006b78:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	6b 4c       	ld.w	r12,r5[0x50]
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	6b 5c       	ld.w	r12,r5[0x54]

80006b84 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80006b84:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80006b88:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80006b8c:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80006b8e:	09 f7       	ld.ub	r7,r4[0x7]
80006b90:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80006b94:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80006b98:	09 b4       	ld.ub	r4,r4[0x3]
80006b9a:	08 96       	mov	r6,r4
80006b9c:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80006ba0:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80006ba4:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80006ba8:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80006bac:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80006bb0:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80006bb4:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80006bb8:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80006bbc:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80006bbe:	79 58       	ld.w	r8,r12[0x54]
80006bc0:	e2 18 00 20 	andl	r8,0x20,COH
80006bc4:	cf d0       	breq	80006bbe <pm_cksel+0x3a>
}
80006bc6:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80006bca <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80006bca:	eb cd 40 80 	pushm	r7,lr
80006bce:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80006bd0:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80006bd2:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80006bd6:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006bda:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80006bde:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80006be2:	2f 8b       	sub	r11,-8
80006be4:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006be8:	e3 cd 80 80 	ldm	sp++,r7,pc

80006bec <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006bec:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006bee:	2f 8b       	sub	r11,-8
80006bf0:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80006bf4:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006bf8:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006bfc:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80006c00:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006c04:	d8 02       	popm	pc

80006c06 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80006c06:	2f 8b       	sub	r11,-8
80006c08:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006c0c:	a1 a8       	sbr	r8,0x0
80006c0e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80006c12:	5e fc       	retal	r12

80006c14 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80006c14:	79 58       	ld.w	r8,r12[0x54]
80006c16:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006c1a:	cf d0       	breq	80006c14 <pm_wait_for_pll0_locked>
}
80006c1c:	5e fc       	retal	r12

80006c1e <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
80006c1e:	79 58       	ld.w	r8,r12[0x54]
80006c20:	e2 18 00 02 	andl	r8,0x2,COH
80006c24:	cf d0       	breq	80006c1e <pm_wait_for_pll1_locked>
}
80006c26:	5e fc       	retal	r12

80006c28 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80006c28:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80006c2a:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80006c2e:	99 08       	st.w	r12[0x0],r8
}
80006c30:	5e fc       	retal	r12
80006c32:	d7 03       	nop

80006c34 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006c34:	eb cd 40 c0 	pushm	r6-r7,lr
80006c38:	18 97       	mov	r7,r12
80006c3a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80006c3c:	f0 1f 00 06 	mcall	80006c54 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80006c40:	0c 9b       	mov	r11,r6
80006c42:	0e 9c       	mov	r12,r7
80006c44:	f0 1f 00 05 	mcall	80006c58 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006c48:	30 1b       	mov	r11,1
80006c4a:	0e 9c       	mov	r12,r7
80006c4c:	f0 1f 00 04 	mcall	80006c5c <pm_switch_to_osc0+0x28>
}
80006c50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	6a 90       	ld.w	r0,r5[0x24]
80006c58:	80 00       	ld.sh	r0,r0[0x0]
80006c5a:	6a e8       	ld.w	r8,r5[0x38]
80006c5c:	80 00       	ld.sh	r0,r0[0x0]
80006c5e:	6c 28       	ld.w	r8,r6[0x8]

80006c60 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006c60:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006c62:	f6 08 15 04 	lsl	r8,r11,0x4
80006c66:	14 38       	cp.w	r8,r10
80006c68:	f9 b8 08 10 	movls	r8,16
80006c6c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006c70:	f0 0b 02 4b 	mul	r11,r8,r11
80006c74:	f6 09 16 01 	lsr	r9,r11,0x1
80006c78:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006c7c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006c80:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006c84:	f2 cb 00 01 	sub	r11,r9,1
80006c88:	e0 4b ff fe 	cp.w	r11,65534
80006c8c:	e0 88 00 03 	brls	80006c92 <usart_set_async_baudrate+0x32>
80006c90:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006c92:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006c94:	e8 6e 00 00 	mov	lr,524288
80006c98:	59 08       	cp.w	r8,16
80006c9a:	fc 08 17 10 	movne	r8,lr
80006c9e:	f9 b8 00 00 	moveq	r8,0
80006ca2:	e4 1b ff f7 	andh	r11,0xfff7
80006ca6:	e0 1b fe cf 	andl	r11,0xfecf
80006caa:	16 48       	or	r8,r11
80006cac:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006cae:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006cb2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006cb6:	99 89       	st.w	r12[0x20],r9
80006cb8:	d8 0a       	popm	pc,r12=0

80006cba <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006cba:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006cbc:	e2 18 00 02 	andl	r8,0x2,COH
80006cc0:	c0 31       	brne	80006cc6 <usart_write_char+0xc>
80006cc2:	30 2c       	mov	r12,2
80006cc4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006cc6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006cca:	99 7b       	st.w	r12[0x1c],r11
80006ccc:	5e fd       	retal	0
80006cce:	d7 03       	nop

80006cd0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006cd0:	eb cd 40 e0 	pushm	r5-r7,lr
80006cd4:	18 96       	mov	r6,r12
80006cd6:	16 95       	mov	r5,r11
80006cd8:	e0 67 27 0f 	mov	r7,9999
80006cdc:	c0 68       	rjmp	80006ce8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006cde:	58 07       	cp.w	r7,0
80006ce0:	c0 31       	brne	80006ce6 <usart_putchar+0x16>
80006ce2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006ce6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006ce8:	0a 9b       	mov	r11,r5
80006cea:	0c 9c       	mov	r12,r6
80006cec:	f0 1f 00 03 	mcall	80006cf8 <usart_putchar+0x28>
80006cf0:	cf 71       	brne	80006cde <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006cf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006cf6:	00 00       	add	r0,r0
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	6c ba       	ld.w	r10,r6[0x2c]

80006cfc <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006cfc:	eb cd 40 c0 	pushm	r6-r7,lr
80006d00:	18 96       	mov	r6,r12
80006d02:	16 97       	mov	r7,r11
  while (*string != '\0')
80006d04:	17 8b       	ld.ub	r11,r11[0x0]
80006d06:	58 0b       	cp.w	r11,0
80006d08:	c0 80       	breq	80006d18 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006d0a:	2f f7       	sub	r7,-1
80006d0c:	0c 9c       	mov	r12,r6
80006d0e:	f0 1f 00 04 	mcall	80006d1c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006d12:	0f 8b       	ld.ub	r11,r7[0x0]
80006d14:	58 0b       	cp.w	r11,0
80006d16:	cf a1       	brne	80006d0a <usart_write_line+0xe>
80006d18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	6c d0       	ld.w	r0,r6[0x34]

80006d20 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006d20:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006d24:	e6 18 00 01 	andh	r8,0x1,COH
80006d28:	c0 71       	brne	80006d36 <usart_reset+0x16>
80006d2a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006d2c:	3f f8       	mov	r8,-1
80006d2e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006d30:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006d32:	d5 03       	csrf	0x10
80006d34:	c0 48       	rjmp	80006d3c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006d36:	3f f8       	mov	r8,-1
80006d38:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006d3a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006d3c:	30 08       	mov	r8,0
80006d3e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006d40:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006d42:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006d44:	ea 68 61 0c 	mov	r8,680204
80006d48:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006d4a:	5e fc       	retal	r12

80006d4c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006d4c:	eb cd 40 e0 	pushm	r5-r7,lr
80006d50:	18 96       	mov	r6,r12
80006d52:	16 97       	mov	r7,r11
80006d54:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006d56:	f0 1f 00 2f 	mcall	80006e10 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006d5a:	58 07       	cp.w	r7,0
80006d5c:	c5 80       	breq	80006e0c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006d5e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006d60:	30 49       	mov	r9,4
80006d62:	f2 08 18 00 	cp.b	r8,r9
80006d66:	e0 88 00 53 	brls	80006e0c <usart_init_rs232+0xc0>
80006d6a:	30 99       	mov	r9,9
80006d6c:	f2 08 18 00 	cp.b	r8,r9
80006d70:	e0 8b 00 4e 	brhi	80006e0c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006d74:	0f d9       	ld.ub	r9,r7[0x5]
80006d76:	30 78       	mov	r8,7
80006d78:	f0 09 18 00 	cp.b	r9,r8
80006d7c:	e0 8b 00 48 	brhi	80006e0c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006d80:	8e 39       	ld.sh	r9,r7[0x6]
80006d82:	e0 68 01 01 	mov	r8,257
80006d86:	f0 09 19 00 	cp.h	r9,r8
80006d8a:	e0 8b 00 41 	brhi	80006e0c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006d8e:	ef 39 00 08 	ld.ub	r9,r7[8]
80006d92:	30 38       	mov	r8,3
80006d94:	f0 09 18 00 	cp.b	r9,r8
80006d98:	e0 8b 00 3a 	brhi	80006e0c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006d9c:	0a 9a       	mov	r10,r5
80006d9e:	6e 0b       	ld.w	r11,r7[0x0]
80006da0:	0c 9c       	mov	r12,r6
80006da2:	f0 1f 00 1d 	mcall	80006e14 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006da6:	58 1c       	cp.w	r12,1
80006da8:	c3 20       	breq	80006e0c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006daa:	0f c8       	ld.ub	r8,r7[0x4]
80006dac:	30 99       	mov	r9,9
80006dae:	f2 08 18 00 	cp.b	r8,r9
80006db2:	c0 51       	brne	80006dbc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006db4:	6c 18       	ld.w	r8,r6[0x4]
80006db6:	b1 b8       	sbr	r8,0x11
80006db8:	8d 18       	st.w	r6[0x4],r8
80006dba:	c0 68       	rjmp	80006dc6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006dbc:	6c 19       	ld.w	r9,r6[0x4]
80006dbe:	20 58       	sub	r8,5
80006dc0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006dc4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006dc6:	6c 19       	ld.w	r9,r6[0x4]
80006dc8:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006dcc:	0f d8       	ld.ub	r8,r7[0x5]
80006dce:	a9 78       	lsl	r8,0x9
80006dd0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006dd4:	12 48       	or	r8,r9
80006dd6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006dd8:	8e 38       	ld.sh	r8,r7[0x6]
80006dda:	30 29       	mov	r9,2
80006ddc:	f2 08 19 00 	cp.h	r8,r9
80006de0:	e0 88 00 09 	brls	80006df2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006de4:	6c 18       	ld.w	r8,r6[0x4]
80006de6:	ad b8       	sbr	r8,0xd
80006de8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006dea:	8e b8       	ld.uh	r8,r7[0x6]
80006dec:	20 28       	sub	r8,2
80006dee:	8d a8       	st.w	r6[0x28],r8
80006df0:	c0 68       	rjmp	80006dfc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006df2:	6c 19       	ld.w	r9,r6[0x4]
80006df4:	5c 78       	castu.h	r8
80006df6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006dfa:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006dfc:	6c 18       	ld.w	r8,r6[0x4]
80006dfe:	e0 18 ff f0 	andl	r8,0xfff0
80006e02:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006e04:	35 08       	mov	r8,80
80006e06:	8d 08       	st.w	r6[0x0],r8
80006e08:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006e0c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	6d 20       	ld.w	r0,r6[0x48]
80006e14:	80 00       	ld.sh	r0,r0[0x0]
80006e16:	6c 60       	ld.w	r0,r6[0x18]

80006e18 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006e18:	f8 c8 ff f8 	sub	r8,r12,-8
80006e1c:	99 18       	st.w	r12[0x4],r8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
80006e1e:	3f f9       	mov	r9,-1
80006e20:	99 29       	st.w	r12[0x8],r9

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006e22:	99 38       	st.w	r12[0xc],r8
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006e24:	99 48       	st.w	r12[0x10],r8

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
80006e26:	30 08       	mov	r8,0
80006e28:	99 08       	st.w	r12[0x0],r8

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80006e2a:	5e fc       	retal	r12

80006e2c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
80006e2c:	30 08       	mov	r8,0
80006e2e:	99 48       	st.w	r12[0x10],r8

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
80006e30:	5e fc       	retal	r12

80006e32 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
80006e32:	78 18       	ld.w	r8,r12[0x4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
80006e34:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80006e36:	70 29       	ld.w	r9,r8[0x8]
80006e38:	97 29       	st.w	r11[0x8],r9

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
80006e3a:	70 29       	ld.w	r9,r8[0x8]
80006e3c:	93 1b       	st.w	r9[0x4],r11
    pxIndex->pxPrevious = pxNewListItem;
80006e3e:	91 2b       	st.w	r8[0x8],r11

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
80006e40:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80006e42:	78 08       	ld.w	r8,r12[0x0]
80006e44:	2f f8       	sub	r8,-1
80006e46:	99 08       	st.w	r12[0x0],r8
}
80006e48:	5e fc       	retal	r12

80006e4a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
80006e4a:	d4 01       	pushm	lr
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80006e4c:	76 0e       	ld.w	lr,r11[0x0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
80006e4e:	5b fe       	cp.w	lr,-1
80006e50:	c0 31       	brne	80006e56 <vListInsert+0xc>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
80006e52:	78 49       	ld.w	r9,r12[0x10]
80006e54:	c0 98       	rjmp	80006e66 <vListInsert+0x1c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
80006e56:	f8 c9 ff f8 	sub	r9,r12,-8
80006e5a:	72 18       	ld.w	r8,r9[0x4]
80006e5c:	70 0a       	ld.w	r10,r8[0x0]
80006e5e:	14 3e       	cp.w	lr,r10
80006e60:	c0 33       	brcs	80006e66 <vListInsert+0x1c>
80006e62:	10 99       	mov	r9,r8
80006e64:	cf bb       	rjmp	80006e5a <vListInsert+0x10>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
80006e66:	72 18       	ld.w	r8,r9[0x4]
80006e68:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80006e6a:	91 2b       	st.w	r8[0x8],r11
    pxNewListItem->pxPrevious = pxIterator;
80006e6c:	97 29       	st.w	r11[0x8],r9
    pxIterator->pxNext = pxNewListItem;
80006e6e:	93 1b       	st.w	r9[0x4],r11

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
80006e70:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80006e72:	78 08       	ld.w	r8,r12[0x0]
80006e74:	2f f8       	sub	r8,-1
80006e76:	99 08       	st.w	r12[0x0],r8
}
80006e78:	d8 02       	popm	pc

80006e7a <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
80006e7a:	78 48       	ld.w	r8,r12[0x10]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006e7c:	78 19       	ld.w	r9,r12[0x4]
80006e7e:	78 2a       	ld.w	r10,r12[0x8]
80006e80:	93 2a       	st.w	r9[0x8],r10
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006e82:	78 29       	ld.w	r9,r12[0x8]
80006e84:	78 1a       	ld.w	r10,r12[0x4]
80006e86:	93 1a       	st.w	r9[0x4],r10

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
80006e88:	70 19       	ld.w	r9,r8[0x4]
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
80006e8a:	18 39       	cp.w	r9,r12
80006e8c:	f3 f9 00 02 	ld.weq	r9,r9[0x8]
80006e90:	f1 f9 0a 01 	st.weq	r8[0x4],r9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
80006e94:	30 09       	mov	r9,0
80006e96:	99 49       	st.w	r12[0x10],r9
    ( pxList->uxNumberOfItems )--;
80006e98:	70 09       	ld.w	r9,r8[0x0]
80006e9a:	20 19       	sub	r9,1
80006e9c:	91 09       	st.w	r8[0x0],r9

    return pxList->uxNumberOfItems;
80006e9e:	70 0c       	ld.w	r12,r8[0x0]
}
80006ea0:	5e fc       	retal	r12

80006ea2 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( StackType_t ) 0x08080808;					/* R8 */
80006ea2:	e0 68 08 08 	mov	r8,2056
80006ea6:	ea 18 08 08 	orh	r8,0x808
80006eaa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x09090909;					/* R9 */
80006eac:	e0 68 09 09 	mov	r8,2313
80006eb0:	ea 18 09 09 	orh	r8,0x909
80006eb4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;					/* R10 */
80006eb6:	e0 68 0a 0a 	mov	r8,2570
80006eba:	ea 18 0a 0a 	orh	r8,0xa0a
80006ebe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;					/* R11 */
80006ec0:	e0 68 0b 0b 	mov	r8,2827
80006ec4:	ea 18 0b 0b 	orh	r8,0xb0b
80006ec8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pvParameters;					/* R12 */
80006eca:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;					/* R14/LR */
80006ecc:	e0 68 be ef 	mov	r8,48879
80006ed0:	ea 18 de ad 	orh	r8,0xdead
80006ed4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006ed6:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;				/* SR */
80006ed8:	fc 18 00 40 	movh	r8,0x40
80006edc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;					/* R0 */
80006ede:	e0 68 00 ff 	mov	r8,255
80006ee2:	ea 18 ff 00 	orh	r8,0xff00
80006ee6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x01010101;					/* R1 */
80006ee8:	e0 68 01 01 	mov	r8,257
80006eec:	ea 18 01 01 	orh	r8,0x101
80006ef0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x02020202;					/* R2 */
80006ef2:	e0 68 02 02 	mov	r8,514
80006ef6:	ea 18 02 02 	orh	r8,0x202
80006efa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x03030303;					/* R3 */
80006efc:	e0 68 03 03 	mov	r8,771
80006f00:	ea 18 03 03 	orh	r8,0x303
80006f04:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x04040404;					/* R4 */
80006f06:	e0 68 04 04 	mov	r8,1028
80006f0a:	ea 18 04 04 	orh	r8,0x404
80006f0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x05050505;					/* R5 */
80006f10:	e0 68 05 05 	mov	r8,1285
80006f14:	ea 18 05 05 	orh	r8,0x505
80006f18:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x06060606;					/* R6 */
80006f1a:	e0 68 06 06 	mov	r8,1542
80006f1e:	ea 18 06 06 	orh	r8,0x606
80006f22:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x07070707;					/* R7 */
80006f24:	e0 68 07 07 	mov	r8,1799
80006f28:	ea 18 07 07 	orh	r8,0x707
80006f2c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006f2e:	30 08       	mov	r8,0
80006f30:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006f32:	5e fc       	retal	r12

80006f34 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006f34:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006f36:	48 38       	lddpc	r8,80006f40 <vPortEnterCritical+0xc>
80006f38:	70 09       	ld.w	r9,r8[0x0]
80006f3a:	2f f9       	sub	r9,-1
80006f3c:	91 09       	st.w	r8[0x0],r9
}
80006f3e:	5e fc       	retal	r12
80006f40:	00 00       	add	r0,r0
80006f42:	00 10       	sub	r0,r0

80006f44 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
80006f44:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006f46:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006f48:	30 0a       	mov	r10,0
80006f4a:	14 9b       	mov	r11,r10
80006f4c:	49 2c       	lddpc	r12,80006f94 <xPortStartScheduler+0x50>
80006f4e:	f0 1f 00 13 	mcall	80006f98 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80006f52:	e0 68 f2 8c 	mov	r8,62092
80006f56:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006f5a:	30 08       	mov	r8,0
80006f5c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006f60:	e0 68 06 38 	mov	r8,1592
80006f64:	ea 18 00 00 	orh	r8,0x0
80006f68:	70 00       	ld.w	r0,r8[0x0]
80006f6a:	60 0d       	ld.w	sp,r0[0x0]
80006f6c:	1b 00       	ld.w	r0,sp++
80006f6e:	e0 68 00 10 	mov	r8,16
80006f72:	ea 18 00 00 	orh	r8,0x0
80006f76:	91 00       	st.w	r8[0x0],r0
80006f78:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006f7c:	2f ed       	sub	sp,-8
80006f7e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006f82:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006f86:	e3 b0 00 00 	mtsr	0x0,r0
80006f8a:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006f8e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006f92:	d8 0a       	popm	pc,r12=0
80006f94:	80 00       	ld.sh	r0,r0[0x0]
80006f96:	70 60       	ld.w	r0,r8[0x18]
80006f98:	80 00       	ld.sh	r0,r0[0x0]
80006f9a:	81 80       	st.w	r0[0x20],r0

80006f9c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006f9c:	20 6d       	sub	sp,24
80006f9e:	eb cd 00 ff 	pushm	r0-r7
80006fa2:	fa c7 ff c0 	sub	r7,sp,-64
80006fa6:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006faa:	ef 40 ff e0 	st.w	r7[-32],r0
80006fae:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006fb2:	ef 40 ff e4 	st.w	r7[-28],r0
80006fb6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006fba:	e0 68 00 10 	mov	r8,16
80006fbe:	ea 18 00 00 	orh	r8,0x0
80006fc2:	70 00       	ld.w	r0,r8[0x0]
80006fc4:	1a d0       	st.w	--sp,r0
80006fc6:	f0 1f 00 1a 	mcall	8000702c <LABEL_RET_SCALL_243+0x14>
80006fca:	e0 68 06 38 	mov	r8,1592
80006fce:	ea 18 00 00 	orh	r8,0x0
80006fd2:	70 00       	ld.w	r0,r8[0x0]
80006fd4:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006fd6:	f0 1f 00 17 	mcall	80007030 <LABEL_RET_SCALL_243+0x18>
	portRESTORE_CONTEXT_SCALL();
80006fda:	e0 68 06 38 	mov	r8,1592
80006fde:	ea 18 00 00 	orh	r8,0x0
80006fe2:	70 00       	ld.w	r0,r8[0x0]
80006fe4:	60 0d       	ld.w	sp,r0[0x0]
80006fe6:	1b 00       	ld.w	r0,sp++
80006fe8:	e0 68 00 10 	mov	r8,16
80006fec:	ea 18 00 00 	orh	r8,0x0
80006ff0:	91 00       	st.w	r8[0x0],r0
80006ff2:	fa c7 ff d8 	sub	r7,sp,-40
80006ff6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006ffa:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006ffe:	e0 61 00 10 	mov	r1,16
80007002:	ea 11 00 00 	orh	r1,0x0
80007006:	62 02       	ld.w	r2,r1[0x0]
80007008:	58 02       	cp.w	r2,0
8000700a:	c0 70       	breq	80007018 <LABEL_RET_SCALL_243>
8000700c:	e4 c2 00 01 	sub	r2,r2,1
80007010:	83 02       	st.w	r1[0x0],r2
80007012:	58 02       	cp.w	r2,0
80007014:	c0 21       	brne	80007018 <LABEL_RET_SCALL_243>
80007016:	b1 c0       	cbr	r0,0x10

80007018 <LABEL_RET_SCALL_243>:
80007018:	ef 40 ff f8 	st.w	r7[-8],r0
8000701c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80007020:	ef 40 ff fc 	st.w	r7[-4],r0
80007024:	e3 cd 00 ff 	ldm	sp++,r0-r7
80007028:	2f ad       	sub	sp,-24
8000702a:	d6 13       	rets
8000702c:	80 00       	ld.sh	r0,r0[0x0]
8000702e:	6f 34       	ld.w	r4,r7[0x4c]
80007030:	80 00       	ld.sh	r0,r0[0x0]
80007032:	75 fc       	ld.w	r12,r10[0x7c]

80007034 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80007034:	e1 b8 00 43 	mfsr	r8,0x10c
80007038:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000703c:	5e fc       	retal	r12
8000703e:	d7 03       	nop

80007040 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80007040:	48 78       	lddpc	r8,8000705c <vPortExitCritical+0x1c>
80007042:	70 08       	ld.w	r8,r8[0x0]
80007044:	58 08       	cp.w	r8,0
80007046:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80007048:	48 58       	lddpc	r8,8000705c <vPortExitCritical+0x1c>
8000704a:	70 09       	ld.w	r9,r8[0x0]
8000704c:	20 19       	sub	r9,1
8000704e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80007050:	70 08       	ld.w	r8,r8[0x0]
80007052:	58 08       	cp.w	r8,0
80007054:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80007056:	d5 03       	csrf	0x10
80007058:	5e fc       	retal	r12
8000705a:	00 00       	add	r0,r0
8000705c:	00 00       	add	r0,r0
8000705e:	00 10       	sub	r0,r0

80007060 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80007060:	eb cd 00 ff 	pushm	r0-r7
80007064:	e0 68 00 10 	mov	r8,16
80007068:	ea 18 00 00 	orh	r8,0x0
8000706c:	70 00       	ld.w	r0,r8[0x0]
8000706e:	1a d0       	st.w	--sp,r0
80007070:	7a 90       	ld.w	r0,sp[0x24]
80007072:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80007076:	58 10       	cp.w	r0,1
80007078:	e0 8b 00 08 	brhi	80007088 <LABEL_INT_SKIP_SAVE_CONTEXT_216>
8000707c:	e0 68 06 38 	mov	r8,1592
80007080:	ea 18 00 00 	orh	r8,0x0
80007084:	70 00       	ld.w	r0,r8[0x0]
80007086:	81 0d       	st.w	r0[0x0],sp

80007088 <LABEL_INT_SKIP_SAVE_CONTEXT_216>:
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
		clock cycles from now. */
		prvClearCcInt();
80007088:	f0 1f 00 12 	mcall	800070d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
8000708c:	f0 1f 00 12 	mcall	800070d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
		xTaskIncrementTick();
80007090:	f0 1f 00 12 	mcall	800070d8 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x1c>
	portEXIT_CRITICAL();
80007094:	f0 1f 00 12 	mcall	800070dc <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80007098:	7a 90       	ld.w	r0,sp[0x24]
8000709a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000709e:	58 10       	cp.w	r0,1
800070a0:	e0 8b 00 0e 	brhi	800070bc <LABEL_INT_SKIP_RESTORE_CONTEXT_234>
800070a4:	f0 1f 00 0c 	mcall	800070d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
800070a8:	f0 1f 00 0e 	mcall	800070e0 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x24>
800070ac:	f0 1f 00 0c 	mcall	800070dc <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>
800070b0:	e0 68 06 38 	mov	r8,1592
800070b4:	ea 18 00 00 	orh	r8,0x0
800070b8:	70 00       	ld.w	r0,r8[0x0]
800070ba:	60 0d       	ld.w	sp,r0[0x0]

800070bc <LABEL_INT_SKIP_RESTORE_CONTEXT_234>:
800070bc:	1b 00       	ld.w	r0,sp++
800070be:	e0 68 00 10 	mov	r8,16
800070c2:	ea 18 00 00 	orh	r8,0x0
800070c6:	91 00       	st.w	r8[0x0],r0
800070c8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800070cc:	d6 03       	rete
800070ce:	00 00       	add	r0,r0
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	70 34       	ld.w	r4,r8[0xc]
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	6f 34       	ld.w	r4,r7[0x4c]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	79 5c       	ld.w	r12,r12[0x54]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	70 40       	ld.w	r0,r8[0x10]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	75 fc       	ld.w	r12,r10[0x7c]

800070e4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800070e4:	d4 01       	pushm	lr
	vTaskSuspendAll();
800070e6:	f0 1f 00 02 	mcall	800070ec <__malloc_lock+0x8>
}
800070ea:	d8 02       	popm	pc
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	75 ec       	ld.w	r12,r10[0x78]

800070f0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800070f0:	d4 01       	pushm	lr
	xTaskResumeAll();
800070f2:	f0 1f 00 02 	mcall	800070f8 <__malloc_unlock+0x8>
}
800070f6:	d8 02       	popm	pc
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	7a 64       	ld.w	r4,sp[0x18]

800070fc <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
800070fc:	eb cd 40 80 	pushm	r7,lr
80007100:	18 97       	mov	r7,r12
    if( pv )
80007102:	58 0c       	cp.w	r12,0
80007104:	c0 80       	breq	80007114 <vPortFree+0x18>
    {
        vTaskSuspendAll();
80007106:	f0 1f 00 05 	mcall	80007118 <vPortFree+0x1c>
        {
            free( pv );
8000710a:	0e 9c       	mov	r12,r7
8000710c:	f0 1f 00 04 	mcall	8000711c <vPortFree+0x20>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
80007110:	f0 1f 00 04 	mcall	80007120 <vPortFree+0x24>
80007114:	e3 cd 80 80 	ldm	sp++,r7,pc
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	75 ec       	ld.w	r12,r10[0x78]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	8c d8       	ld.uh	r8,r6[0xa]
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	7a 64       	ld.w	r4,sp[0x18]

80007124 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
80007124:	eb cd 40 80 	pushm	r7,lr
80007128:	18 97       	mov	r7,r12
    void * pvReturn;

    vTaskSuspendAll();
8000712a:	f0 1f 00 06 	mcall	80007140 <pvPortMalloc+0x1c>
    {
        pvReturn = malloc( xWantedSize );
8000712e:	0e 9c       	mov	r12,r7
80007130:	f0 1f 00 05 	mcall	80007144 <pvPortMalloc+0x20>
80007134:	18 97       	mov	r7,r12
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
80007136:	f0 1f 00 05 	mcall	80007148 <pvPortMalloc+0x24>
            }
        }
    #endif

    return pvReturn;
}
8000713a:	0e 9c       	mov	r12,r7
8000713c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	75 ec       	ld.w	r12,r10[0x78]
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	8c e8       	ld.uh	r8,r6[0xc]
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	7a 64       	ld.w	r4,sp[0x18]

8000714c <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
8000714c:	eb cd 40 80 	pushm	r7,lr
80007150:	18 97       	mov	r7,r12
    BaseType_t xReturn;

    taskENTER_CRITICAL();
80007152:	f0 1f 00 05 	mcall	80007164 <prvIsQueueEmpty+0x18>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
80007156:	6e e7       	ld.w	r7,r7[0x38]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
80007158:	f0 1f 00 04 	mcall	80007168 <prvIsQueueEmpty+0x1c>
8000715c:	58 07       	cp.w	r7,0

    return xReturn;
}
8000715e:	5f 0c       	sreq	r12
80007160:	e3 cd 80 80 	ldm	sp++,r7,pc
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	6f 34       	ld.w	r4,r7[0x4c]
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	70 40       	ld.w	r0,r8[0x10]

8000716c <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
8000716c:	d4 21       	pushm	r4-r7,lr
8000716e:	18 96       	mov	r6,r12

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
80007170:	f0 1f 00 25 	mcall	80007204 <prvUnlockQueue+0x98>
    {
        int8_t cTxLock = pxQueue->cTxLock;
80007174:	ed 37 00 45 	ld.ub	r7,r6[69]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80007178:	30 08       	mov	r8,0
8000717a:	f0 07 18 00 	cp.b	r7,r8
8000717e:	e0 8a 00 18 	brle	800071ae <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007182:	6c 98       	ld.w	r8,r6[0x24]
80007184:	58 08       	cp.w	r8,0
80007186:	c1 40       	breq	800071ae <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007188:	ec c4 ff dc 	sub	r4,r6,-36
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
8000718c:	30 05       	mov	r5,0
8000718e:	c0 48       	rjmp	80007196 <prvUnlockQueue+0x2a>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007190:	6c 98       	ld.w	r8,r6[0x24]
80007192:	58 08       	cp.w	r8,0
80007194:	c0 d0       	breq	800071ae <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007196:	08 9c       	mov	r12,r4
80007198:	f0 1f 00 1c 	mcall	80007208 <prvUnlockQueue+0x9c>
8000719c:	c0 30       	breq	800071a2 <prvUnlockQueue+0x36>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
8000719e:	f0 1f 00 1c 	mcall	8000720c <prvUnlockQueue+0xa0>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
800071a2:	20 17       	sub	r7,1
800071a4:	5c 57       	castu.b	r7
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
800071a6:	ea 07 18 00 	cp.b	r7,r5
800071aa:	fe 99 ff f3 	brgt	80007190 <prvUnlockQueue+0x24>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
800071ae:	3f f8       	mov	r8,-1
800071b0:	ed 68 00 45 	st.b	r6[69],r8
    }
    taskEXIT_CRITICAL();
800071b4:	f0 1f 00 17 	mcall	80007210 <prvUnlockQueue+0xa4>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
800071b8:	f0 1f 00 13 	mcall	80007204 <prvUnlockQueue+0x98>
    {
        int8_t cRxLock = pxQueue->cRxLock;
800071bc:	ed 37 00 44 	ld.ub	r7,r6[68]

        while( cRxLock > queueLOCKED_UNMODIFIED )
800071c0:	30 08       	mov	r8,0
800071c2:	f0 07 18 00 	cp.b	r7,r8
800071c6:	e0 8a 00 18 	brle	800071f6 <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800071ca:	6c 48       	ld.w	r8,r6[0x10]
800071cc:	58 08       	cp.w	r8,0
800071ce:	c1 40       	breq	800071f6 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800071d0:	ec c4 ff f0 	sub	r4,r6,-16
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
800071d4:	30 05       	mov	r5,0
800071d6:	c0 48       	rjmp	800071de <prvUnlockQueue+0x72>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800071d8:	6c 48       	ld.w	r8,r6[0x10]
800071da:	58 08       	cp.w	r8,0
800071dc:	c0 d0       	breq	800071f6 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800071de:	08 9c       	mov	r12,r4
800071e0:	f0 1f 00 0a 	mcall	80007208 <prvUnlockQueue+0x9c>
800071e4:	c0 30       	breq	800071ea <prvUnlockQueue+0x7e>
                {
                    vTaskMissedYield();
800071e6:	f0 1f 00 0a 	mcall	8000720c <prvUnlockQueue+0xa0>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
800071ea:	20 17       	sub	r7,1
800071ec:	5c 57       	castu.b	r7
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
800071ee:	ea 07 18 00 	cp.b	r7,r5
800071f2:	fe 99 ff f3 	brgt	800071d8 <prvUnlockQueue+0x6c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
800071f6:	3f f8       	mov	r8,-1
800071f8:	ed 68 00 44 	st.b	r6[68],r8
    }
    taskEXIT_CRITICAL();
800071fc:	f0 1f 00 05 	mcall	80007210 <prvUnlockQueue+0xa4>
}
80007200:	d8 22       	popm	r4-r7,pc
80007202:	00 00       	add	r0,r0
80007204:	80 00       	ld.sh	r0,r0[0x0]
80007206:	6f 34       	ld.w	r4,r7[0x4c]
80007208:	80 00       	ld.sh	r0,r0[0x0]
8000720a:	78 d0       	ld.w	r0,r12[0x34]
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	76 88       	ld.w	r8,r11[0x20]
80007210:	80 00       	ld.sh	r0,r0[0x0]
80007212:	70 40       	ld.w	r0,r8[0x10]

80007214 <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
80007214:	d4 31       	pushm	r0-r7,lr
80007216:	20 4d       	sub	sp,16
80007218:	18 97       	mov	r7,r12
8000721a:	50 1b       	stdsp	sp[0x4],r11
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000721c:	f8 c1 ff dc 	sub	r1,r12,-36
80007220:	30 08       	mov	r8,0
80007222:	50 08       	stdsp	sp[0x0],r8
80007224:	10 95       	mov	r5,r8
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007226:	fa c4 ff f8 	sub	r4,sp,-8
8000722a:	30 10       	mov	r0,1

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
8000722c:	3f f6       	mov	r6,-1
8000722e:	30 02       	mov	r2,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007230:	fa c3 ff fc 	sub	r3,sp,-4
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80007234:	f0 1f 00 42 	mcall	8000733c <xQueueSemaphoreTake+0x128>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
80007238:	6e e8       	ld.w	r8,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
8000723a:	58 08       	cp.w	r8,0
8000723c:	c1 60       	breq	80007268 <xQueueSemaphoreTake+0x54>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
8000723e:	20 18       	sub	r8,1
80007240:	8f e8       	st.w	r7[0x38],r8

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007242:	6e 08       	ld.w	r8,r7[0x0]
80007244:	58 08       	cp.w	r8,0
80007246:	c0 41       	brne	8000724e <xQueueSemaphoreTake+0x3a>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
80007248:	f0 1f 00 3e 	mcall	80007340 <xQueueSemaphoreTake+0x12c>
8000724c:	8f 2c       	st.w	r7[0x8],r12
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000724e:	6e 48       	ld.w	r8,r7[0x10]
80007250:	58 08       	cp.w	r8,0
80007252:	c0 70       	breq	80007260 <xQueueSemaphoreTake+0x4c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007254:	ee cc ff f0 	sub	r12,r7,-16
80007258:	f0 1f 00 3b 	mcall	80007344 <xQueueSemaphoreTake+0x130>
8000725c:	c0 20       	breq	80007260 <xQueueSemaphoreTake+0x4c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
8000725e:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
80007260:	f0 1f 00 3a 	mcall	80007348 <xQueueSemaphoreTake+0x134>
80007264:	30 1c       	mov	r12,1
                return pdPASS;
80007266:	c6 88       	rjmp	80007336 <xQueueSemaphoreTake+0x122>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007268:	40 18       	lddsp	r8,sp[0x4]
8000726a:	58 08       	cp.w	r8,0
8000726c:	c0 51       	brne	80007276 <xQueueSemaphoreTake+0x62>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
8000726e:	f0 1f 00 37 	mcall	80007348 <xQueueSemaphoreTake+0x134>
80007272:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80007274:	c6 18       	rjmp	80007336 <xQueueSemaphoreTake+0x122>
                }
                else if( xEntryTimeSet == pdFALSE )
80007276:	58 05       	cp.w	r5,0
80007278:	c0 51       	brne	80007282 <xQueueSemaphoreTake+0x6e>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000727a:	08 9c       	mov	r12,r4
8000727c:	f0 1f 00 34 	mcall	8000734c <xQueueSemaphoreTake+0x138>
80007280:	00 95       	mov	r5,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80007282:	f0 1f 00 32 	mcall	80007348 <xQueueSemaphoreTake+0x134>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
80007286:	f0 1f 00 33 	mcall	80007350 <xQueueSemaphoreTake+0x13c>
        prvLockQueue( pxQueue );
8000728a:	f0 1f 00 2d 	mcall	8000733c <xQueueSemaphoreTake+0x128>
8000728e:	ef 38 00 44 	ld.ub	r8,r7[68]
80007292:	ec 08 18 00 	cp.b	r8,r6
80007296:	ef f2 0e 44 	st.beq	r7[0x44],r2
8000729a:	ef 38 00 45 	ld.ub	r8,r7[69]
8000729e:	ec 08 18 00 	cp.b	r8,r6
800072a2:	ef f2 0e 45 	st.beq	r7[0x45],r2
800072a6:	f0 1f 00 29 	mcall	80007348 <xQueueSemaphoreTake+0x134>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800072aa:	06 9b       	mov	r11,r3
800072ac:	08 9c       	mov	r12,r4
800072ae:	f0 1f 00 2a 	mcall	80007354 <xQueueSemaphoreTake+0x140>
800072b2:	c2 21       	brne	800072f6 <xQueueSemaphoreTake+0xe2>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800072b4:	0e 9c       	mov	r12,r7
800072b6:	f0 1f 00 29 	mcall	80007358 <xQueueSemaphoreTake+0x144>
800072ba:	c1 80       	breq	800072ea <xQueueSemaphoreTake+0xd6>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800072bc:	6e 08       	ld.w	r8,r7[0x0]
800072be:	58 08       	cp.w	r8,0
800072c0:	c0 91       	brne	800072d2 <xQueueSemaphoreTake+0xbe>
                        {
                            taskENTER_CRITICAL();
800072c2:	f0 1f 00 1f 	mcall	8000733c <xQueueSemaphoreTake+0x128>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
800072c6:	6e 2c       	ld.w	r12,r7[0x8]
800072c8:	f0 1f 00 25 	mcall	8000735c <xQueueSemaphoreTake+0x148>
800072cc:	50 0c       	stdsp	sp[0x0],r12
                            }
                            taskEXIT_CRITICAL();
800072ce:	f0 1f 00 1f 	mcall	80007348 <xQueueSemaphoreTake+0x134>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800072d2:	40 1b       	lddsp	r11,sp[0x4]
800072d4:	02 9c       	mov	r12,r1
800072d6:	f0 1f 00 23 	mcall	80007360 <xQueueSemaphoreTake+0x14c>
                prvUnlockQueue( pxQueue );
800072da:	0e 9c       	mov	r12,r7
800072dc:	f0 1f 00 22 	mcall	80007364 <xQueueSemaphoreTake+0x150>

                if( xTaskResumeAll() == pdFALSE )
800072e0:	f0 1f 00 22 	mcall	80007368 <xQueueSemaphoreTake+0x154>
800072e4:	ca 81       	brne	80007234 <xQueueSemaphoreTake+0x20>
                {
                    portYIELD_WITHIN_API();
800072e6:	d7 33       	scall
800072e8:	ca 6b       	rjmp	80007234 <xQueueSemaphoreTake+0x20>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
800072ea:	0e 9c       	mov	r12,r7
800072ec:	f0 1f 00 1e 	mcall	80007364 <xQueueSemaphoreTake+0x150>
                ( void ) xTaskResumeAll();
800072f0:	f0 1f 00 1e 	mcall	80007368 <xQueueSemaphoreTake+0x154>
800072f4:	ca 0b       	rjmp	80007234 <xQueueSemaphoreTake+0x20>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
800072f6:	0e 9c       	mov	r12,r7
800072f8:	f0 1f 00 1b 	mcall	80007364 <xQueueSemaphoreTake+0x150>
            ( void ) xTaskResumeAll();
800072fc:	f0 1f 00 1b 	mcall	80007368 <xQueueSemaphoreTake+0x154>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80007300:	0e 9c       	mov	r12,r7
80007302:	f0 1f 00 16 	mcall	80007358 <xQueueSemaphoreTake+0x144>
80007306:	c9 70       	breq	80007234 <xQueueSemaphoreTake+0x20>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
80007308:	40 08       	lddsp	r8,sp[0x0]
8000730a:	58 08       	cp.w	r8,0
8000730c:	c0 31       	brne	80007312 <xQueueSemaphoreTake+0xfe>
8000730e:	30 0c       	mov	r12,0
80007310:	c1 38       	rjmp	80007336 <xQueueSemaphoreTake+0x122>
                        {
                            taskENTER_CRITICAL();
80007312:	f0 1f 00 0b 	mcall	8000733c <xQueueSemaphoreTake+0x128>
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
80007316:	6e 98       	ld.w	r8,r7[0x24]
80007318:	58 08       	cp.w	r8,0
8000731a:	f9 bb 00 00 	moveq	r11,0
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
8000731e:	ef f8 10 0c 	ld.wne	r8,r7[0x30]
80007322:	f1 fb 10 00 	ld.wne	r11,r8[0x0]
80007326:	fb bb 01 08 	rsubne	r11,8
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
8000732a:	6e 2c       	ld.w	r12,r7[0x8]
8000732c:	f0 1f 00 10 	mcall	8000736c <xQueueSemaphoreTake+0x158>
                            }
                            taskEXIT_CRITICAL();
80007330:	f0 1f 00 06 	mcall	80007348 <xQueueSemaphoreTake+0x134>
80007334:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
80007336:	2f cd       	sub	sp,-16
80007338:	d8 32       	popm	r0-r7,pc
8000733a:	00 00       	add	r0,r0
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	6f 34       	ld.w	r4,r7[0x4c]
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	76 bc       	ld.w	r12,r11[0x2c]
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	78 d0       	ld.w	r0,r12[0x34]
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	70 40       	ld.w	r0,r8[0x10]
8000734c:	80 00       	ld.sh	r0,r0[0x0]
8000734e:	76 70       	ld.w	r0,r11[0x1c]
80007350:	80 00       	ld.sh	r0,r0[0x0]
80007352:	75 ec       	ld.w	r12,r10[0x78]
80007354:	80 00       	ld.sh	r0,r0[0x0]
80007356:	76 dc       	ld.w	r12,r11[0x34]
80007358:	80 00       	ld.sh	r0,r0[0x0]
8000735a:	71 4c       	ld.w	r12,r8[0x50]
8000735c:	80 00       	ld.sh	r0,r0[0x0]
8000735e:	78 2c       	ld.w	r12,r12[0x8]
80007360:	80 00       	ld.sh	r0,r0[0x0]
80007362:	7c 60       	ld.w	r0,lr[0x18]
80007364:	80 00       	ld.sh	r0,r0[0x0]
80007366:	71 6c       	ld.w	r12,r8[0x58]
80007368:	80 00       	ld.sh	r0,r0[0x0]
8000736a:	7a 64       	ld.w	r4,sp[0x18]
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	77 48       	ld.w	r8,r11[0x50]

80007370 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
80007370:	eb cd 40 e0 	pushm	r5-r7,lr
80007374:	18 97       	mov	r7,r12
80007376:	14 96       	mov	r6,r10
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80007378:	78 e5       	ld.w	r5,r12[0x38]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
8000737a:	79 0a       	ld.w	r10,r12[0x40]
8000737c:	58 0a       	cp.w	r10,0
8000737e:	c0 a1       	brne	80007392 <prvCopyDataToQueue+0x22>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007380:	78 08       	ld.w	r8,r12[0x0]
80007382:	58 08       	cp.w	r8,0
80007384:	c3 11       	brne	800073e6 <prvCopyDataToQueue+0x76>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
80007386:	78 2c       	ld.w	r12,r12[0x8]
80007388:	f0 1f 00 1a 	mcall	800073f0 <prvCopyDataToQueue+0x80>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
8000738c:	30 08       	mov	r8,0
8000738e:	8f 28       	st.w	r7[0x8],r8
80007390:	c2 c8       	rjmp	800073e8 <prvCopyDataToQueue+0x78>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
80007392:	58 06       	cp.w	r6,0
80007394:	c1 01       	brne	800073b4 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
80007396:	78 1c       	ld.w	r12,r12[0x4]
80007398:	f0 1f 00 17 	mcall	800073f4 <prvCopyDataToQueue+0x84>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
8000739c:	6e 19       	ld.w	r9,r7[0x4]
8000739e:	6f 08       	ld.w	r8,r7[0x40]
800073a0:	f2 08 00 08 	add	r8,r9,r8
800073a4:	8f 18       	st.w	r7[0x4],r8

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
800073a6:	6e 29       	ld.w	r9,r7[0x8]
800073a8:	12 38       	cp.w	r8,r9
800073aa:	c1 e3       	brcs	800073e6 <prvCopyDataToQueue+0x76>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
800073ac:	6e 08       	ld.w	r8,r7[0x0]
800073ae:	8f 18       	st.w	r7[0x4],r8
800073b0:	30 0c       	mov	r12,0
800073b2:	c1 b8       	rjmp	800073e8 <prvCopyDataToQueue+0x78>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
800073b4:	78 3c       	ld.w	r12,r12[0xc]
800073b6:	f0 1f 00 10 	mcall	800073f4 <prvCopyDataToQueue+0x84>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
800073ba:	6f 08       	ld.w	r8,r7[0x40]
800073bc:	6e 39       	ld.w	r9,r7[0xc]
800073be:	f2 08 01 08 	sub	r8,r9,r8
800073c2:	8f 38       	st.w	r7[0xc],r8

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
800073c4:	6e 09       	ld.w	r9,r7[0x0]
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
800073c6:	12 38       	cp.w	r8,r9
800073c8:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800073cc:	ef f9 30 02 	ld.wcs	r9,r7[0x8]
800073d0:	f3 d8 e3 19 	subcs	r9,r9,r8
800073d4:	ef f9 3a 03 	st.wcs	r7[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
800073d8:	58 26       	cp.w	r6,2
800073da:	c0 61       	brne	800073e6 <prvCopyDataToQueue+0x76>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
800073dc:	58 05       	cp.w	r5,0
800073de:	c0 40       	breq	800073e6 <prvCopyDataToQueue+0x76>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
800073e0:	20 15       	sub	r5,1
800073e2:	30 0c       	mov	r12,0
800073e4:	c0 28       	rjmp	800073e8 <prvCopyDataToQueue+0x78>
800073e6:	30 0c       	mov	r12,0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
800073e8:	2f f5       	sub	r5,-1
800073ea:	8f e5       	st.w	r7[0x38],r5

    return xReturn;
}
800073ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	77 c4       	ld.w	r4,r11[0x70]
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	91 20       	st.w	r8[0x8],r0

800073f8 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
800073f8:	d4 31       	pushm	r0-r7,lr
800073fa:	20 5d       	sub	sp,20
800073fc:	18 97       	mov	r7,r12
800073fe:	50 1b       	stdsp	sp[0x4],r11
80007400:	50 2a       	stdsp	sp[0x8],r10
80007402:	12 91       	mov	r1,r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007404:	f8 c8 ff f0 	sub	r8,r12,-16
80007408:	50 08       	stdsp	sp[0x0],r8
8000740a:	30 03       	mov	r3,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000740c:	fa c2 ff f4 	sub	r2,sp,-12

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
80007410:	3f f5       	mov	r5,-1

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007412:	fa c0 ff f8 	sub	r0,sp,-8
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80007416:	f0 1f 00 36 	mcall	800074ec <xQueueGenericSend+0xf4>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
8000741a:	6e e9       	ld.w	r9,r7[0x38]
8000741c:	6e f8       	ld.w	r8,r7[0x3c]
8000741e:	10 39       	cp.w	r9,r8
80007420:	c0 33       	brcs	80007426 <xQueueGenericSend+0x2e>
80007422:	58 21       	cp.w	r1,2
80007424:	c1 71       	brne	80007452 <xQueueGenericSend+0x5a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007426:	02 9a       	mov	r10,r1
80007428:	40 1b       	lddsp	r11,sp[0x4]
8000742a:	0e 9c       	mov	r12,r7
8000742c:	f0 1f 00 31 	mcall	800074f0 <xQueueGenericSend+0xf8>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007430:	6e 98       	ld.w	r8,r7[0x24]
80007432:	58 08       	cp.w	r8,0
80007434:	c0 80       	breq	80007444 <xQueueGenericSend+0x4c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007436:	ee cc ff dc 	sub	r12,r7,-36
8000743a:	f0 1f 00 2f 	mcall	800074f4 <xQueueGenericSend+0xfc>
8000743e:	c0 60       	breq	8000744a <xQueueGenericSend+0x52>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
80007440:	d7 33       	scall
80007442:	c0 48       	rjmp	8000744a <xQueueGenericSend+0x52>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
80007444:	58 0c       	cp.w	r12,0
80007446:	c0 20       	breq	8000744a <xQueueGenericSend+0x52>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
80007448:	d7 33       	scall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
8000744a:	f0 1f 00 2c 	mcall	800074f8 <xQueueGenericSend+0x100>
8000744e:	30 1c       	mov	r12,1
                return pdPASS;
80007450:	c4 b8       	rjmp	800074e6 <xQueueGenericSend+0xee>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007452:	40 28       	lddsp	r8,sp[0x8]
80007454:	58 08       	cp.w	r8,0
80007456:	c0 51       	brne	80007460 <xQueueGenericSend+0x68>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
80007458:	f0 1f 00 28 	mcall	800074f8 <xQueueGenericSend+0x100>
8000745c:	30 0c       	mov	r12,0

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
8000745e:	c4 48       	rjmp	800074e6 <xQueueGenericSend+0xee>
                }
                else if( xEntryTimeSet == pdFALSE )
80007460:	58 03       	cp.w	r3,0
80007462:	c0 51       	brne	8000746c <xQueueGenericSend+0x74>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007464:	04 9c       	mov	r12,r2
80007466:	f0 1f 00 26 	mcall	800074fc <xQueueGenericSend+0x104>
8000746a:	30 13       	mov	r3,1
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
8000746c:	f0 1f 00 23 	mcall	800074f8 <xQueueGenericSend+0x100>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
80007470:	f0 1f 00 24 	mcall	80007500 <xQueueGenericSend+0x108>
        prvLockQueue( pxQueue );
80007474:	f0 1f 00 1e 	mcall	800074ec <xQueueGenericSend+0xf4>
80007478:	ef 38 00 44 	ld.ub	r8,r7[68]
8000747c:	ea 08 18 00 	cp.b	r8,r5
80007480:	f9 b8 00 00 	moveq	r8,0
80007484:	ef f8 0e 44 	st.beq	r7[0x44],r8
80007488:	ef 38 00 45 	ld.ub	r8,r7[69]
8000748c:	ea 08 18 00 	cp.b	r8,r5
80007490:	f9 b8 00 00 	moveq	r8,0
80007494:	ef f8 0e 45 	st.beq	r7[0x45],r8
80007498:	f0 1f 00 18 	mcall	800074f8 <xQueueGenericSend+0x100>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000749c:	00 9b       	mov	r11,r0
8000749e:	04 9c       	mov	r12,r2
800074a0:	f0 1f 00 19 	mcall	80007504 <xQueueGenericSend+0x10c>
800074a4:	c1 b1       	brne	800074da <xQueueGenericSend+0xe2>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
800074a6:	f0 1f 00 12 	mcall	800074ec <xQueueGenericSend+0xf4>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
800074aa:	6e e4       	ld.w	r4,r7[0x38]
800074ac:	6e f6       	ld.w	r6,r7[0x3c]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
800074ae:	f0 1f 00 13 	mcall	800074f8 <xQueueGenericSend+0x100>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
800074b2:	0c 34       	cp.w	r4,r6
800074b4:	c0 d1       	brne	800074ce <xQueueGenericSend+0xd6>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800074b6:	40 2b       	lddsp	r11,sp[0x8]
800074b8:	40 0c       	lddsp	r12,sp[0x0]
800074ba:	f0 1f 00 14 	mcall	80007508 <xQueueGenericSend+0x110>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
800074be:	0e 9c       	mov	r12,r7
800074c0:	f0 1f 00 13 	mcall	8000750c <xQueueGenericSend+0x114>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
800074c4:	f0 1f 00 13 	mcall	80007510 <xQueueGenericSend+0x118>
800074c8:	ca 71       	brne	80007416 <xQueueGenericSend+0x1e>
                {
                    portYIELD_WITHIN_API();
800074ca:	d7 33       	scall
800074cc:	ca 5b       	rjmp	80007416 <xQueueGenericSend+0x1e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
800074ce:	0e 9c       	mov	r12,r7
800074d0:	f0 1f 00 0f 	mcall	8000750c <xQueueGenericSend+0x114>
                ( void ) xTaskResumeAll();
800074d4:	f0 1f 00 0f 	mcall	80007510 <xQueueGenericSend+0x118>
800074d8:	c9 fb       	rjmp	80007416 <xQueueGenericSend+0x1e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
800074da:	0e 9c       	mov	r12,r7
800074dc:	f0 1f 00 0c 	mcall	8000750c <xQueueGenericSend+0x114>
            ( void ) xTaskResumeAll();
800074e0:	f0 1f 00 0c 	mcall	80007510 <xQueueGenericSend+0x118>
800074e4:	30 0c       	mov	r12,0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
800074e6:	2f bd       	sub	sp,-20
800074e8:	d8 32       	popm	r0-r7,pc
800074ea:	00 00       	add	r0,r0
800074ec:	80 00       	ld.sh	r0,r0[0x0]
800074ee:	6f 34       	ld.w	r4,r7[0x4c]
800074f0:	80 00       	ld.sh	r0,r0[0x0]
800074f2:	73 70       	ld.w	r0,r9[0x5c]
800074f4:	80 00       	ld.sh	r0,r0[0x0]
800074f6:	78 d0       	ld.w	r0,r12[0x34]
800074f8:	80 00       	ld.sh	r0,r0[0x0]
800074fa:	70 40       	ld.w	r0,r8[0x10]
800074fc:	80 00       	ld.sh	r0,r0[0x0]
800074fe:	76 70       	ld.w	r0,r11[0x1c]
80007500:	80 00       	ld.sh	r0,r0[0x0]
80007502:	75 ec       	ld.w	r12,r10[0x78]
80007504:	80 00       	ld.sh	r0,r0[0x0]
80007506:	76 dc       	ld.w	r12,r11[0x34]
80007508:	80 00       	ld.sh	r0,r0[0x0]
8000750a:	7c 60       	ld.w	r0,lr[0x18]
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	71 6c       	ld.w	r12,r8[0x58]
80007510:	80 00       	ld.sh	r0,r0[0x0]
80007512:	7a 64       	ld.w	r4,sp[0x18]

80007514 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
80007514:	eb cd 40 c0 	pushm	r6-r7,lr
80007518:	18 97       	mov	r7,r12
8000751a:	16 96       	mov	r6,r11
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
8000751c:	f0 1f 00 18 	mcall	8000757c <xQueueGenericReset+0x68>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
80007520:	6f 09       	ld.w	r9,r7[0x40]
80007522:	6e fa       	ld.w	r10,r7[0x3c]
80007524:	f2 0a 02 4b 	mul	r11,r9,r10
80007528:	6e 08       	ld.w	r8,r7[0x0]
8000752a:	f0 0b 00 0b 	add	r11,r8,r11
8000752e:	8f 2b       	st.w	r7[0x8],r11
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80007530:	30 0b       	mov	r11,0
80007532:	8f eb       	st.w	r7[0x38],r11
        pxQueue->pcWriteTo = pxQueue->pcHead;
80007534:	8f 18       	st.w	r7[0x4],r8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
80007536:	20 1a       	sub	r10,1
80007538:	f4 09 02 49 	mul	r9,r10,r9
8000753c:	12 08       	add	r8,r9
8000753e:	8f 38       	st.w	r7[0xc],r8
        pxQueue->cRxLock = queueUNLOCKED;
80007540:	3f f8       	mov	r8,-1
80007542:	ef 68 00 44 	st.b	r7[68],r8
        pxQueue->cTxLock = queueUNLOCKED;
80007546:	ef 68 00 45 	st.b	r7[69],r8

        if( xNewQueue == pdFALSE )
8000754a:	58 06       	cp.w	r6,0
8000754c:	c0 b1       	brne	80007562 <xQueueGenericReset+0x4e>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000754e:	6e 48       	ld.w	r8,r7[0x10]
80007550:	58 08       	cp.w	r8,0
80007552:	c1 00       	breq	80007572 <xQueueGenericReset+0x5e>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007554:	ee cc ff f0 	sub	r12,r7,-16
80007558:	f0 1f 00 0a 	mcall	80007580 <xQueueGenericReset+0x6c>
8000755c:	c0 b0       	breq	80007572 <xQueueGenericReset+0x5e>
                {
                    queueYIELD_IF_USING_PREEMPTION();
8000755e:	d7 33       	scall
80007560:	c0 98       	rjmp	80007572 <xQueueGenericReset+0x5e>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80007562:	ee cc ff f0 	sub	r12,r7,-16
80007566:	f0 1f 00 08 	mcall	80007584 <xQueueGenericReset+0x70>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
8000756a:	ee cc ff dc 	sub	r12,r7,-36
8000756e:	f0 1f 00 06 	mcall	80007584 <xQueueGenericReset+0x70>
        }
    }
    taskEXIT_CRITICAL();
80007572:	f0 1f 00 06 	mcall	80007588 <xQueueGenericReset+0x74>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
80007576:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000757a:	00 00       	add	r0,r0
8000757c:	80 00       	ld.sh	r0,r0[0x0]
8000757e:	6f 34       	ld.w	r4,r7[0x4c]
80007580:	80 00       	ld.sh	r0,r0[0x0]
80007582:	78 d0       	ld.w	r0,r12[0x34]
80007584:	80 00       	ld.sh	r0,r0[0x0]
80007586:	6e 18       	ld.w	r8,r7[0x4]
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	70 40       	ld.w	r0,r8[0x10]

8000758c <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
8000758c:	eb cd 40 e0 	pushm	r5-r7,lr
80007590:	18 95       	mov	r5,r12
80007592:	16 96       	mov	r6,r11
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
80007594:	f6 0c 02 4c 	mul	r12,r11,r12
80007598:	2b 8c       	sub	r12,-72
8000759a:	f0 1f 00 0b 	mcall	800075c4 <xQueueGenericCreate+0x38>
8000759e:	18 97       	mov	r7,r12

        if( pxNewQueue != NULL )
800075a0:	c0 f0       	breq	800075be <xQueueGenericCreate+0x32>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
800075a2:	58 06       	cp.w	r6,0
800075a4:	c0 31       	brne	800075aa <xQueueGenericCreate+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
800075a6:	8f 0c       	st.w	r7[0x0],r12
800075a8:	c0 48       	rjmp	800075b0 <xQueueGenericCreate+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
800075aa:	f8 c8 ff b8 	sub	r8,r12,-72
800075ae:	99 08       	st.w	r12[0x0],r8
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
800075b0:	8f f5       	st.w	r7[0x3c],r5
    pxNewQueue->uxItemSize = uxItemSize;
800075b2:	ef 46 00 40 	st.w	r7[64],r6
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
800075b6:	30 1b       	mov	r11,1
800075b8:	0e 9c       	mov	r12,r7
800075ba:	f0 1f 00 04 	mcall	800075c8 <xQueueGenericCreate+0x3c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
800075be:	0e 9c       	mov	r12,r7
800075c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800075c4:	80 00       	ld.sh	r0,r0[0x0]
800075c6:	71 24       	ld.w	r4,r8[0x48]
800075c8:	80 00       	ld.sh	r0,r0[0x0]
800075ca:	75 14       	ld.w	r4,r10[0x44]

800075cc <prvTaskIsTaskSuspended>:

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
800075cc:	78 59       	ld.w	r9,r12[0x14]
800075ce:	48 68       	lddpc	r8,800075e4 <prvTaskIsTaskSuspended+0x18>
800075d0:	10 39       	cp.w	r9,r8
800075d2:	c0 81       	brne	800075e2 <prvTaskIsTaskSuspended+0x16>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
800075d4:	78 a8       	ld.w	r8,r12[0x28]
800075d6:	48 59       	lddpc	r9,800075e8 <prvTaskIsTaskSuspended+0x1c>
800075d8:	12 38       	cp.w	r8,r9
800075da:	c0 40       	breq	800075e2 <prvTaskIsTaskSuspended+0x16>
800075dc:	58 08       	cp.w	r8,0
800075de:	5f 0c       	sreq	r12
800075e0:	5e fc       	retal	r12
800075e2:	5e fd       	retal	0
800075e4:	00 00       	add	r0,r0
800075e6:	06 a0       	st.w	r3++,r0
800075e8:	00 00       	add	r0,r0
800075ea:	06 3c       	cp.w	r12,r3

800075ec <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
800075ec:	48 38       	lddpc	r8,800075f8 <vTaskSuspendAll+0xc>
800075ee:	70 09       	ld.w	r9,r8[0x0]
800075f0:	2f f9       	sub	r9,-1
800075f2:	91 09       	st.w	r8[0x0],r9

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
800075f4:	5e fc       	retal	r12
800075f6:	00 00       	add	r0,r0
800075f8:	00 00       	add	r0,r0
800075fa:	06 68       	and	r8,r3

800075fc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
800075fc:	49 88       	lddpc	r8,8000765c <vTaskSwitchContext+0x60>
800075fe:	70 08       	ld.w	r8,r8[0x0]
80007600:	58 08       	cp.w	r8,0
80007602:	c0 50       	breq	8000760c <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
80007604:	30 19       	mov	r9,1
80007606:	49 78       	lddpc	r8,80007660 <vTaskSwitchContext+0x64>
80007608:	91 09       	st.w	r8[0x0],r9
8000760a:	5e fc       	retal	r12
    }
    else
    {
        xYieldPending = pdFALSE;
8000760c:	30 09       	mov	r9,0
8000760e:	49 58       	lddpc	r8,80007660 <vTaskSwitchContext+0x64>
80007610:	91 09       	st.w	r8[0x0],r9
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007612:	49 58       	lddpc	r8,80007664 <vTaskSwitchContext+0x68>
80007614:	70 09       	ld.w	r9,r8[0x0]
80007616:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000761a:	a3 68       	lsl	r8,0x2
8000761c:	49 3b       	lddpc	r11,80007668 <vTaskSwitchContext+0x6c>
8000761e:	10 0b       	add	r11,r8
80007620:	76 0a       	ld.w	r10,r11[0x0]
80007622:	58 0a       	cp.w	r10,0
80007624:	c0 b1       	brne	8000763a <vTaskSwitchContext+0x3e>
80007626:	21 48       	sub	r8,20
80007628:	49 0a       	lddpc	r10,80007668 <vTaskSwitchContext+0x6c>
8000762a:	f4 08 00 08 	add	r8,r10,r8
8000762e:	20 19       	sub	r9,1
80007630:	10 9b       	mov	r11,r8
80007632:	70 0a       	ld.w	r10,r8[0x0]
80007634:	21 48       	sub	r8,20
80007636:	58 0a       	cp.w	r10,0
80007638:	cf b0       	breq	8000762e <vTaskSwitchContext+0x32>
8000763a:	76 18       	ld.w	r8,r11[0x4]
8000763c:	70 18       	ld.w	r8,r8[0x4]
8000763e:	97 18       	st.w	r11[0x4],r8
80007640:	f6 ca ff f8 	sub	r10,r11,-8
80007644:	14 38       	cp.w	r8,r10
80007646:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
8000764a:	f7 f8 0a 01 	st.weq	r11[0x4],r8
8000764e:	76 18       	ld.w	r8,r11[0x4]
80007650:	70 3a       	ld.w	r10,r8[0xc]
80007652:	48 78       	lddpc	r8,8000766c <vTaskSwitchContext+0x70>
80007654:	91 0a       	st.w	r8[0x0],r10
80007656:	48 48       	lddpc	r8,80007664 <vTaskSwitchContext+0x68>
80007658:	91 09       	st.w	r8[0x0],r9
8000765a:	5e fc       	retal	r12
8000765c:	00 00       	add	r0,r0
8000765e:	06 68       	and	r8,r3
80007660:	00 00       	add	r0,r0
80007662:	06 b8       	st.h	r3++,r8
80007664:	00 00       	add	r0,r0
80007666:	06 b4       	st.h	r3++,r4
80007668:	00 00       	add	r0,r0
8000766a:	05 94       	ld.ub	r4,r2[0x1]
8000766c:	00 00       	add	r0,r0
8000766e:	06 38       	cp.w	r8,r3

80007670 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
80007670:	48 48       	lddpc	r8,80007680 <vTaskInternalSetTimeOutState+0x10>
80007672:	70 08       	ld.w	r8,r8[0x0]
80007674:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
80007676:	48 48       	lddpc	r8,80007684 <vTaskInternalSetTimeOutState+0x14>
80007678:	70 08       	ld.w	r8,r8[0x0]
8000767a:	99 18       	st.w	r12[0x4],r8
}
8000767c:	5e fc       	retal	r12
8000767e:	00 00       	add	r0,r0
80007680:	00 00       	add	r0,r0
80007682:	05 88       	ld.ub	r8,r2[0x0]
80007684:	00 00       	add	r0,r0
80007686:	06 64       	and	r4,r3

80007688 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
80007688:	30 19       	mov	r9,1
8000768a:	48 28       	lddpc	r8,80007690 <vTaskMissedYield+0x8>
8000768c:	91 09       	st.w	r8[0x0],r9
}
8000768e:	5e fc       	retal	r12
80007690:	00 00       	add	r0,r0
80007692:	06 b8       	st.h	r3++,r8

80007694 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007694:	48 88       	lddpc	r8,800076b4 <prvResetNextTaskUnblockTime+0x20>
80007696:	70 08       	ld.w	r8,r8[0x0]
80007698:	70 08       	ld.w	r8,r8[0x0]
8000769a:	58 08       	cp.w	r8,0
8000769c:	c0 51       	brne	800076a6 <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
8000769e:	3f f9       	mov	r9,-1
800076a0:	48 68       	lddpc	r8,800076b8 <prvResetNextTaskUnblockTime+0x24>
800076a2:	91 09       	st.w	r8[0x0],r9
800076a4:	5e fc       	retal	r12
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
800076a6:	48 48       	lddpc	r8,800076b4 <prvResetNextTaskUnblockTime+0x20>
800076a8:	70 08       	ld.w	r8,r8[0x0]
800076aa:	70 38       	ld.w	r8,r8[0xc]
800076ac:	70 09       	ld.w	r9,r8[0x0]
800076ae:	48 38       	lddpc	r8,800076b8 <prvResetNextTaskUnblockTime+0x24>
800076b0:	91 09       	st.w	r8[0x0],r9
800076b2:	5e fc       	retal	r12
800076b4:	00 00       	add	r0,r0
800076b6:	05 80       	ld.ub	r0,r2[0x0]
800076b8:	00 00       	add	r0,r0
800076ba:	05 7c       	ld.ub	r12,--r2

800076bc <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
800076bc:	48 78       	lddpc	r8,800076d8 <pvTaskIncrementMutexHeldCount+0x1c>
800076be:	70 08       	ld.w	r8,r8[0x0]
800076c0:	58 08       	cp.w	r8,0
800076c2:	c0 70       	breq	800076d0 <pvTaskIncrementMutexHeldCount+0x14>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
800076c4:	48 58       	lddpc	r8,800076d8 <pvTaskIncrementMutexHeldCount+0x1c>
800076c6:	70 08       	ld.w	r8,r8[0x0]
800076c8:	71 29       	ld.w	r9,r8[0x48]
800076ca:	2f f9       	sub	r9,-1
800076cc:	f1 49 00 48 	st.w	r8[72],r9
        }

        return pxCurrentTCB;
800076d0:	48 28       	lddpc	r8,800076d8 <pvTaskIncrementMutexHeldCount+0x1c>
800076d2:	70 0c       	ld.w	r12,r8[0x0]
    }
800076d4:	5e fc       	retal	r12
800076d6:	00 00       	add	r0,r0
800076d8:	00 00       	add	r0,r0
800076da:	06 38       	cp.w	r8,r3

800076dc <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
800076dc:	eb cd 40 c0 	pushm	r6-r7,lr
800076e0:	18 97       	mov	r7,r12
800076e2:	16 96       	mov	r6,r11
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
800076e4:	f0 1f 00 14 	mcall	80007734 <xTaskCheckForTimeOut+0x58>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
800076e8:	49 48       	lddpc	r8,80007738 <xTaskCheckForTimeOut+0x5c>
800076ea:	70 0a       	ld.w	r10,r8[0x0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
800076ec:	6e 19       	ld.w	r9,r7[0x4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
800076ee:	6c 08       	ld.w	r8,r6[0x0]
800076f0:	5b f8       	cp.w	r8,-1
800076f2:	c0 31       	brne	800076f8 <xTaskCheckForTimeOut+0x1c>
800076f4:	30 07       	mov	r7,0
800076f6:	c1 a8       	rjmp	8000772a <xTaskCheckForTimeOut+0x4e>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
800076f8:	49 1b       	lddpc	r11,8000773c <xTaskCheckForTimeOut+0x60>
800076fa:	76 0b       	ld.w	r11,r11[0x0]
800076fc:	6e 0c       	ld.w	r12,r7[0x0]
800076fe:	16 3c       	cp.w	r12,r11
80007700:	c0 70       	breq	8000770e <xTaskCheckForTimeOut+0x32>
80007702:	12 3a       	cp.w	r10,r9
80007704:	c0 53       	brcs	8000770e <xTaskCheckForTimeOut+0x32>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
80007706:	30 08       	mov	r8,0
80007708:	8d 08       	st.w	r6[0x0],r8
8000770a:	30 17       	mov	r7,1
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
8000770c:	c0 f8       	rjmp	8000772a <xTaskCheckForTimeOut+0x4e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
8000770e:	f4 09 01 09 	sub	r9,r10,r9
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
80007712:	10 39       	cp.w	r9,r8
80007714:	c0 82       	brcc	80007724 <xTaskCheckForTimeOut+0x48>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
80007716:	12 18       	sub	r8,r9
80007718:	8d 08       	st.w	r6[0x0],r8
            vTaskInternalSetTimeOutState( pxTimeOut );
8000771a:	0e 9c       	mov	r12,r7
8000771c:	f0 1f 00 09 	mcall	80007740 <xTaskCheckForTimeOut+0x64>
80007720:	30 07       	mov	r7,0
80007722:	c0 48       	rjmp	8000772a <xTaskCheckForTimeOut+0x4e>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
80007724:	30 08       	mov	r8,0
80007726:	8d 08       	st.w	r6[0x0],r8
80007728:	30 17       	mov	r7,1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
8000772a:	f0 1f 00 07 	mcall	80007744 <xTaskCheckForTimeOut+0x68>

    return xReturn;
}
8000772e:	0e 9c       	mov	r12,r7
80007730:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007734:	80 00       	ld.sh	r0,r0[0x0]
80007736:	6f 34       	ld.w	r4,r7[0x4c]
80007738:	00 00       	add	r0,r0
8000773a:	06 64       	and	r4,r3
8000773c:	00 00       	add	r0,r0
8000773e:	05 88       	ld.ub	r8,r2[0x0]
80007740:	80 00       	ld.sh	r0,r0[0x0]
80007742:	76 70       	ld.w	r0,r11[0x1c]
80007744:	80 00       	ld.sh	r0,r0[0x0]
80007746:	70 40       	ld.w	r0,r8[0x10]

80007748 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
80007748:	eb cd 40 c0 	pushm	r6-r7,lr
8000774c:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
8000774e:	58 0c       	cp.w	r12,0
80007750:	c2 f0       	breq	800077ae <vTaskPriorityDisinheritAfterTimeout+0x66>
80007752:	79 18       	ld.w	r8,r12[0x44]
80007754:	10 3b       	cp.w	r11,r8
80007756:	f0 0b 17 30 	movlo	r11,r8
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
8000775a:	78 b9       	ld.w	r9,r12[0x2c]
8000775c:	16 39       	cp.w	r9,r11
8000775e:	c2 80       	breq	800077ae <vTaskPriorityDisinheritAfterTimeout+0x66>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
80007760:	79 28       	ld.w	r8,r12[0x48]
80007762:	58 18       	cp.w	r8,1
80007764:	c2 51       	brne	800077ae <vTaskPriorityDisinheritAfterTimeout+0x66>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
80007766:	99 bb       	st.w	r12[0x2c],r11

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007768:	78 68       	ld.w	r8,r12[0x18]
8000776a:	58 08       	cp.w	r8,0
8000776c:	c0 45       	brlt	80007774 <vTaskPriorityDisinheritAfterTimeout+0x2c>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000776e:	f6 0b 11 08 	rsub	r11,r11,8
80007772:	99 6b       	st.w	r12[0x18],r11
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80007774:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007778:	48 f8       	lddpc	r8,800077b4 <vTaskPriorityDisinheritAfterTimeout+0x6c>
8000777a:	f0 09 00 29 	add	r9,r8,r9<<0x2
8000777e:	6e 58       	ld.w	r8,r7[0x14]
80007780:	12 38       	cp.w	r8,r9
80007782:	c1 61       	brne	800077ae <vTaskPriorityDisinheritAfterTimeout+0x66>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007784:	ee c6 ff fc 	sub	r6,r7,-4
80007788:	0c 9c       	mov	r12,r6
8000778a:	f0 1f 00 0c 	mcall	800077b8 <vTaskPriorityDisinheritAfterTimeout+0x70>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
8000778e:	6e bc       	ld.w	r12,r7[0x2c]
80007790:	48 b8       	lddpc	r8,800077bc <vTaskPriorityDisinheritAfterTimeout+0x74>
80007792:	70 08       	ld.w	r8,r8[0x0]
80007794:	10 3c       	cp.w	r12,r8
80007796:	e0 88 00 04 	brls	8000779e <vTaskPriorityDisinheritAfterTimeout+0x56>
8000779a:	48 98       	lddpc	r8,800077bc <vTaskPriorityDisinheritAfterTimeout+0x74>
8000779c:	91 0c       	st.w	r8[0x0],r12
8000779e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800077a2:	0c 9b       	mov	r11,r6
800077a4:	48 48       	lddpc	r8,800077b4 <vTaskPriorityDisinheritAfterTimeout+0x6c>
800077a6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800077aa:	f0 1f 00 06 	mcall	800077c0 <vTaskPriorityDisinheritAfterTimeout+0x78>
800077ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800077b2:	00 00       	add	r0,r0
800077b4:	00 00       	add	r0,r0
800077b6:	05 94       	ld.ub	r4,r2[0x1]
800077b8:	80 00       	ld.sh	r0,r0[0x0]
800077ba:	6e 7a       	ld.w	r10,r7[0x1c]
800077bc:	00 00       	add	r0,r0
800077be:	06 b4       	st.h	r3++,r4
800077c0:	80 00       	ld.sh	r0,r0[0x0]
800077c2:	6e 32       	ld.w	r2,r7[0xc]

800077c4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
800077c4:	eb cd 40 c0 	pushm	r6-r7,lr
800077c8:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
800077ca:	58 0c       	cp.w	r12,0
800077cc:	c2 60       	breq	80007818 <xTaskPriorityDisinherit+0x54>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
800077ce:	79 28       	ld.w	r8,r12[0x48]
800077d0:	20 18       	sub	r8,1
800077d2:	f9 48 00 48 	st.w	r12[72],r8

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800077d6:	78 ba       	ld.w	r10,r12[0x2c]
800077d8:	79 19       	ld.w	r9,r12[0x44]
800077da:	12 3a       	cp.w	r10,r9
800077dc:	c1 e0       	breq	80007818 <xTaskPriorityDisinherit+0x54>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
800077de:	58 08       	cp.w	r8,0
800077e0:	c1 c1       	brne	80007818 <xTaskPriorityDisinherit+0x54>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
800077e2:	f8 c6 ff fc 	sub	r6,r12,-4
800077e6:	0c 9c       	mov	r12,r6
800077e8:	f0 1f 00 0d 	mcall	8000781c <xTaskPriorityDisinherit+0x58>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
800077ec:	6f 1c       	ld.w	r12,r7[0x44]
800077ee:	8f bc       	st.w	r7[0x2c],r12

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800077f0:	f8 08 11 08 	rsub	r8,r12,8
800077f4:	8f 68       	st.w	r7[0x18],r8
                    prvAddTaskToReadyList( pxTCB );
800077f6:	48 b8       	lddpc	r8,80007820 <xTaskPriorityDisinherit+0x5c>
800077f8:	70 08       	ld.w	r8,r8[0x0]
800077fa:	10 3c       	cp.w	r12,r8
800077fc:	e0 88 00 04 	brls	80007804 <xTaskPriorityDisinherit+0x40>
80007800:	48 88       	lddpc	r8,80007820 <xTaskPriorityDisinherit+0x5c>
80007802:	91 0c       	st.w	r8[0x0],r12
80007804:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007808:	0c 9b       	mov	r11,r6
8000780a:	48 78       	lddpc	r8,80007824 <xTaskPriorityDisinherit+0x60>
8000780c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007810:	f0 1f 00 06 	mcall	80007828 <xTaskPriorityDisinherit+0x64>
80007814:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007818:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000781c:	80 00       	ld.sh	r0,r0[0x0]
8000781e:	6e 7a       	ld.w	r10,r7[0x1c]
80007820:	00 00       	add	r0,r0
80007822:	06 b4       	st.h	r3++,r4
80007824:	00 00       	add	r0,r0
80007826:	05 94       	ld.ub	r4,r2[0x1]
80007828:	80 00       	ld.sh	r0,r0[0x0]
8000782a:	6e 32       	ld.w	r2,r7[0xc]

8000782c <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
8000782c:	eb cd 40 c0 	pushm	r6-r7,lr
80007830:	18 97       	mov	r7,r12
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
80007832:	58 0c       	cp.w	r12,0
80007834:	c0 31       	brne	8000783a <xTaskPriorityInherit+0xe>
80007836:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
8000783a:	4a 18       	lddpc	r8,800078bc <xTaskPriorityInherit+0x90>
8000783c:	70 08       	ld.w	r8,r8[0x0]
8000783e:	78 b9       	ld.w	r9,r12[0x2c]
80007840:	70 b8       	ld.w	r8,r8[0x2c]
80007842:	10 39       	cp.w	r9,r8
80007844:	c3 32       	brcc	800078aa <xTaskPriorityInherit+0x7e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007846:	78 68       	ld.w	r8,r12[0x18]
80007848:	58 08       	cp.w	r8,0
8000784a:	c0 75       	brlt	80007858 <xTaskPriorityInherit+0x2c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000784c:	49 c8       	lddpc	r8,800078bc <xTaskPriorityInherit+0x90>
8000784e:	70 08       	ld.w	r8,r8[0x0]
80007850:	70 b8       	ld.w	r8,r8[0x2c]
80007852:	f0 08 11 08 	rsub	r8,r8,8
80007856:	99 68       	st.w	r12[0x18],r8
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
80007858:	6e b8       	ld.w	r8,r7[0x2c]
8000785a:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000785e:	49 99       	lddpc	r9,800078c0 <xTaskPriorityInherit+0x94>
80007860:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007864:	6e 59       	ld.w	r9,r7[0x14]
80007866:	10 39       	cp.w	r9,r8
80007868:	c1 b1       	brne	8000789e <xTaskPriorityInherit+0x72>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8000786a:	ee c6 ff fc 	sub	r6,r7,-4
8000786e:	0c 9c       	mov	r12,r6
80007870:	f0 1f 00 15 	mcall	800078c4 <xTaskPriorityInherit+0x98>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
80007874:	49 28       	lddpc	r8,800078bc <xTaskPriorityInherit+0x90>
80007876:	70 08       	ld.w	r8,r8[0x0]
80007878:	70 bc       	ld.w	r12,r8[0x2c]
8000787a:	8f bc       	st.w	r7[0x2c],r12
                    prvAddTaskToReadyList( pxMutexHolderTCB );
8000787c:	49 38       	lddpc	r8,800078c8 <xTaskPriorityInherit+0x9c>
8000787e:	70 08       	ld.w	r8,r8[0x0]
80007880:	10 3c       	cp.w	r12,r8
80007882:	e0 88 00 04 	brls	8000788a <xTaskPriorityInherit+0x5e>
80007886:	49 18       	lddpc	r8,800078c8 <xTaskPriorityInherit+0x9c>
80007888:	91 0c       	st.w	r8[0x0],r12
8000788a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000788e:	0c 9b       	mov	r11,r6
80007890:	48 c8       	lddpc	r8,800078c0 <xTaskPriorityInherit+0x94>
80007892:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007896:	f0 1f 00 0e 	mcall	800078cc <xTaskPriorityInherit+0xa0>
8000789a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
8000789e:	48 88       	lddpc	r8,800078bc <xTaskPriorityInherit+0x90>
800078a0:	70 08       	ld.w	r8,r8[0x0]
800078a2:	70 b8       	ld.w	r8,r8[0x2c]
800078a4:	8f b8       	st.w	r7[0x2c],r8
800078a6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
800078aa:	48 58       	lddpc	r8,800078bc <xTaskPriorityInherit+0x90>
800078ac:	70 08       	ld.w	r8,r8[0x0]
800078ae:	79 19       	ld.w	r9,r12[0x44]
800078b0:	70 b8       	ld.w	r8,r8[0x2c]
800078b2:	10 39       	cp.w	r9,r8
800078b4:	5f 3c       	srlo	r12
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
800078b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800078ba:	00 00       	add	r0,r0
800078bc:	00 00       	add	r0,r0
800078be:	06 38       	cp.w	r8,r3
800078c0:	00 00       	add	r0,r0
800078c2:	05 94       	ld.ub	r4,r2[0x1]
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	6e 7a       	ld.w	r10,r7[0x1c]
800078c8:	00 00       	add	r0,r0
800078ca:	06 b4       	st.h	r3++,r4
800078cc:	80 00       	ld.sh	r0,r0[0x0]
800078ce:	6e 32       	ld.w	r2,r7[0xc]

800078d0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
800078d0:	eb cd 40 c0 	pushm	r6-r7,lr
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800078d4:	78 38       	ld.w	r8,r12[0xc]
800078d6:	70 37       	ld.w	r7,r8[0xc]
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
800078d8:	ee c6 ff e8 	sub	r6,r7,-24
800078dc:	0c 9c       	mov	r12,r6
800078de:	f0 1f 00 18 	mcall	8000793c <xTaskRemoveFromEventList+0x6c>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
800078e2:	49 88       	lddpc	r8,80007940 <xTaskRemoveFromEventList+0x70>
800078e4:	70 08       	ld.w	r8,r8[0x0]
800078e6:	58 08       	cp.w	r8,0
800078e8:	c1 71       	brne	80007916 <xTaskRemoveFromEventList+0x46>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
800078ea:	ee c6 ff fc 	sub	r6,r7,-4
800078ee:	0c 9c       	mov	r12,r6
800078f0:	f0 1f 00 13 	mcall	8000793c <xTaskRemoveFromEventList+0x6c>
        prvAddTaskToReadyList( pxUnblockedTCB );
800078f4:	6e bc       	ld.w	r12,r7[0x2c]
800078f6:	49 48       	lddpc	r8,80007944 <xTaskRemoveFromEventList+0x74>
800078f8:	70 08       	ld.w	r8,r8[0x0]
800078fa:	10 3c       	cp.w	r12,r8
800078fc:	e0 88 00 04 	brls	80007904 <xTaskRemoveFromEventList+0x34>
80007900:	49 18       	lddpc	r8,80007944 <xTaskRemoveFromEventList+0x74>
80007902:	91 0c       	st.w	r8[0x0],r12
80007904:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007908:	0c 9b       	mov	r11,r6
8000790a:	49 08       	lddpc	r8,80007948 <xTaskRemoveFromEventList+0x78>
8000790c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007910:	f0 1f 00 0f 	mcall	8000794c <xTaskRemoveFromEventList+0x7c>
80007914:	c0 58       	rjmp	8000791e <xTaskRemoveFromEventList+0x4e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80007916:	0c 9b       	mov	r11,r6
80007918:	48 ec       	lddpc	r12,80007950 <xTaskRemoveFromEventList+0x80>
8000791a:	f0 1f 00 0d 	mcall	8000794c <xTaskRemoveFromEventList+0x7c>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
8000791e:	48 e8       	lddpc	r8,80007954 <xTaskRemoveFromEventList+0x84>
80007920:	70 08       	ld.w	r8,r8[0x0]
80007922:	6e b9       	ld.w	r9,r7[0x2c]
80007924:	70 b8       	ld.w	r8,r8[0x2c]
80007926:	10 39       	cp.w	r9,r8
80007928:	e0 8b 00 04 	brhi	80007930 <xTaskRemoveFromEventList+0x60>
8000792c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
80007930:	30 1c       	mov	r12,1
80007932:	48 a8       	lddpc	r8,80007958 <xTaskRemoveFromEventList+0x88>
80007934:	91 0c       	st.w	r8[0x0],r12
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
80007936:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000793a:	00 00       	add	r0,r0
8000793c:	80 00       	ld.sh	r0,r0[0x0]
8000793e:	6e 7a       	ld.w	r10,r7[0x1c]
80007940:	00 00       	add	r0,r0
80007942:	06 68       	and	r8,r3
80007944:	00 00       	add	r0,r0
80007946:	06 b4       	st.h	r3++,r4
80007948:	00 00       	add	r0,r0
8000794a:	05 94       	ld.ub	r4,r2[0x1]
8000794c:	80 00       	ld.sh	r0,r0[0x0]
8000794e:	6e 32       	ld.w	r2,r7[0xc]
80007950:	00 00       	add	r0,r0
80007952:	06 3c       	cp.w	r12,r3
80007954:	00 00       	add	r0,r0
80007956:	06 38       	cp.w	r8,r3
80007958:	00 00       	add	r0,r0
8000795a:	06 b8       	st.h	r3++,r8

8000795c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
8000795c:	d4 31       	pushm	r0-r7,lr
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
8000795e:	4b 48       	lddpc	r8,80007a2c <xTaskIncrementTick+0xd0>
80007960:	70 08       	ld.w	r8,r8[0x0]
80007962:	58 08       	cp.w	r8,0
80007964:	c5 d1       	brne	80007a1e <xTaskIncrementTick+0xc2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
80007966:	4b 38       	lddpc	r8,80007a30 <xTaskIncrementTick+0xd4>
80007968:	70 02       	ld.w	r2,r8[0x0]
8000796a:	2f f2       	sub	r2,-1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
8000796c:	91 02       	st.w	r8[0x0],r2

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
8000796e:	c0 d1       	brne	80007988 <xTaskIncrementTick+0x2c>
        {
            taskSWITCH_DELAYED_LISTS();
80007970:	4b 19       	lddpc	r9,80007a34 <xTaskIncrementTick+0xd8>
80007972:	72 0a       	ld.w	r10,r9[0x0]
80007974:	4b 18       	lddpc	r8,80007a38 <xTaskIncrementTick+0xdc>
80007976:	70 0b       	ld.w	r11,r8[0x0]
80007978:	93 0b       	st.w	r9[0x0],r11
8000797a:	91 0a       	st.w	r8[0x0],r10
8000797c:	4b 08       	lddpc	r8,80007a3c <xTaskIncrementTick+0xe0>
8000797e:	70 09       	ld.w	r9,r8[0x0]
80007980:	2f f9       	sub	r9,-1
80007982:	91 09       	st.w	r8[0x0],r9
80007984:	f0 1f 00 2f 	mcall	80007a40 <xTaskIncrementTick+0xe4>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
80007988:	4a f8       	lddpc	r8,80007a44 <xTaskIncrementTick+0xe8>
8000798a:	70 08       	ld.w	r8,r8[0x0]
8000798c:	10 32       	cp.w	r2,r8
8000798e:	c3 63       	brcs	800079fa <xTaskIncrementTick+0x9e>
80007990:	30 06       	mov	r6,0
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007992:	4a 94       	lddpc	r4,80007a34 <xTaskIncrementTick+0xd8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007994:	4a d3       	lddpc	r3,80007a48 <xTaskIncrementTick+0xec>
80007996:	4a e1       	lddpc	r1,80007a4c <xTaskIncrementTick+0xf0>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007998:	4a e0       	lddpc	r0,80007a50 <xTaskIncrementTick+0xf4>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000799a:	68 08       	ld.w	r8,r4[0x0]
8000799c:	70 08       	ld.w	r8,r8[0x0]
8000799e:	58 08       	cp.w	r8,0
800079a0:	c0 51       	brne	800079aa <xTaskIncrementTick+0x4e>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800079a2:	3f f9       	mov	r9,-1
800079a4:	4a 88       	lddpc	r8,80007a44 <xTaskIncrementTick+0xe8>
800079a6:	91 09       	st.w	r8[0x0],r9
                    break;
800079a8:	c2 a8       	rjmp	800079fc <xTaskIncrementTick+0xa0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800079aa:	68 08       	ld.w	r8,r4[0x0]
800079ac:	70 38       	ld.w	r8,r8[0xc]
800079ae:	70 37       	ld.w	r7,r8[0xc]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
800079b0:	6e 18       	ld.w	r8,r7[0x4]

                    if( xConstTickCount < xItemValue )
800079b2:	10 32       	cp.w	r2,r8
800079b4:	c0 42       	brcc	800079bc <xTaskIncrementTick+0x60>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
800079b6:	4a 49       	lddpc	r9,80007a44 <xTaskIncrementTick+0xe8>
800079b8:	93 08       	st.w	r9[0x0],r8
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
800079ba:	c2 18       	rjmp	800079fc <xTaskIncrementTick+0xa0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
800079bc:	ee c5 ff fc 	sub	r5,r7,-4
800079c0:	0a 9c       	mov	r12,r5
800079c2:	f0 1f 00 25 	mcall	80007a54 <xTaskIncrementTick+0xf8>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
800079c6:	6e a8       	ld.w	r8,r7[0x28]
800079c8:	58 08       	cp.w	r8,0
800079ca:	c0 50       	breq	800079d4 <xTaskIncrementTick+0x78>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
800079cc:	ee cc ff e8 	sub	r12,r7,-24
800079d0:	f0 1f 00 21 	mcall	80007a54 <xTaskIncrementTick+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
800079d4:	6e bc       	ld.w	r12,r7[0x2c]
800079d6:	66 08       	ld.w	r8,r3[0x0]
800079d8:	10 3c       	cp.w	r12,r8
800079da:	e7 fc ba 00 	st.whi	r3[0x0],r12
800079de:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800079e2:	0a 9b       	mov	r11,r5
800079e4:	e2 0c 00 2c 	add	r12,r1,r12<<0x2
800079e8:	f0 1f 00 1c 	mcall	80007a58 <xTaskIncrementTick+0xfc>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800079ec:	60 08       	ld.w	r8,r0[0x0]
800079ee:	6e b9       	ld.w	r9,r7[0x2c]
800079f0:	70 b8       	ld.w	r8,r8[0x2c]
800079f2:	10 39       	cp.w	r9,r8
800079f4:	f9 b6 02 01 	movhs	r6,1
800079f8:	cd 1b       	rjmp	8000799a <xTaskIncrementTick+0x3e>
800079fa:	30 06       	mov	r6,0
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
800079fc:	49 58       	lddpc	r8,80007a50 <xTaskIncrementTick+0xf4>
800079fe:	70 08       	ld.w	r8,r8[0x0]
80007a00:	70 b8       	ld.w	r8,r8[0x2c]
80007a02:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007a06:	49 29       	lddpc	r9,80007a4c <xTaskIncrementTick+0xf0>
80007a08:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80007a0c:	58 28       	cp.w	r8,2
80007a0e:	f9 b6 02 01 	movhs	r6,1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
80007a12:	49 38       	lddpc	r8,80007a5c <xTaskIncrementTick+0x100>
80007a14:	70 08       	ld.w	r8,r8[0x0]
80007a16:	58 08       	cp.w	r8,0
80007a18:	f9 b6 01 01 	movne	r6,1
80007a1c:	c0 68       	rjmp	80007a28 <xTaskIncrementTick+0xcc>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
80007a1e:	49 18       	lddpc	r8,80007a60 <xTaskIncrementTick+0x104>
80007a20:	70 09       	ld.w	r9,r8[0x0]
80007a22:	2f f9       	sub	r9,-1
80007a24:	91 09       	st.w	r8[0x0],r9
80007a26:	30 06       	mov	r6,0
            }
        #endif
    }

    return xSwitchRequired;
}
80007a28:	0c 9c       	mov	r12,r6
80007a2a:	d8 32       	popm	r0-r7,pc
80007a2c:	00 00       	add	r0,r0
80007a2e:	06 68       	and	r8,r3
80007a30:	00 00       	add	r0,r0
80007a32:	06 64       	and	r4,r3
80007a34:	00 00       	add	r0,r0
80007a36:	05 80       	ld.ub	r0,r2[0x0]
80007a38:	00 00       	add	r0,r0
80007a3a:	05 8c       	ld.ub	r12,r2[0x0]
80007a3c:	00 00       	add	r0,r0
80007a3e:	05 88       	ld.ub	r8,r2[0x0]
80007a40:	80 00       	ld.sh	r0,r0[0x0]
80007a42:	76 94       	ld.w	r4,r11[0x24]
80007a44:	00 00       	add	r0,r0
80007a46:	05 7c       	ld.ub	r12,--r2
80007a48:	00 00       	add	r0,r0
80007a4a:	06 b4       	st.h	r3++,r4
80007a4c:	00 00       	add	r0,r0
80007a4e:	05 94       	ld.ub	r4,r2[0x1]
80007a50:	00 00       	add	r0,r0
80007a52:	06 38       	cp.w	r8,r3
80007a54:	80 00       	ld.sh	r0,r0[0x0]
80007a56:	6e 7a       	ld.w	r10,r7[0x1c]
80007a58:	80 00       	ld.sh	r0,r0[0x0]
80007a5a:	6e 32       	ld.w	r2,r7[0xc]
80007a5c:	00 00       	add	r0,r0
80007a5e:	06 b8       	st.h	r3++,r8
80007a60:	00 00       	add	r0,r0
80007a62:	05 90       	ld.ub	r0,r2[0x1]

80007a64 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
80007a64:	d4 31       	pushm	r0-r7,lr
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
80007a66:	f0 1f 00 2b 	mcall	80007b10 <xTaskResumeAll+0xac>
    {
        --uxSchedulerSuspended;
80007a6a:	4a b8       	lddpc	r8,80007b14 <xTaskResumeAll+0xb0>
80007a6c:	70 09       	ld.w	r9,r8[0x0]
80007a6e:	20 19       	sub	r9,1
80007a70:	91 09       	st.w	r8[0x0],r9

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007a72:	70 08       	ld.w	r8,r8[0x0]
80007a74:	58 08       	cp.w	r8,0
80007a76:	c4 71       	brne	80007b04 <xTaskResumeAll+0xa0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80007a78:	4a 88       	lddpc	r8,80007b18 <xTaskResumeAll+0xb4>
80007a7a:	70 08       	ld.w	r8,r8[0x0]
80007a7c:	58 08       	cp.w	r8,0
80007a7e:	c4 30       	breq	80007b04 <xTaskResumeAll+0xa0>
80007a80:	30 07       	mov	r7,0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80007a82:	4a 76       	lddpc	r6,80007b1c <xTaskResumeAll+0xb8>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
80007a84:	4a 74       	lddpc	r4,80007b20 <xTaskResumeAll+0xbc>
80007a86:	4a 83       	lddpc	r3,80007b24 <xTaskResumeAll+0xc0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007a88:	4a 82       	lddpc	r2,80007b28 <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
80007a8a:	4a 91       	lddpc	r1,80007b2c <xTaskResumeAll+0xc8>
80007a8c:	30 10       	mov	r0,1
80007a8e:	c1 e8       	rjmp	80007aca <xTaskResumeAll+0x66>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007a90:	6c 38       	ld.w	r8,r6[0xc]
80007a92:	70 37       	ld.w	r7,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007a94:	ee cc ff e8 	sub	r12,r7,-24
80007a98:	f0 1f 00 26 	mcall	80007b30 <xTaskResumeAll+0xcc>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007a9c:	ee c5 ff fc 	sub	r5,r7,-4
80007aa0:	0a 9c       	mov	r12,r5
80007aa2:	f0 1f 00 24 	mcall	80007b30 <xTaskResumeAll+0xcc>
                    prvAddTaskToReadyList( pxTCB );
80007aa6:	6e bc       	ld.w	r12,r7[0x2c]
80007aa8:	68 08       	ld.w	r8,r4[0x0]
80007aaa:	10 3c       	cp.w	r12,r8
80007aac:	e9 fc ba 00 	st.whi	r4[0x0],r12
80007ab0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007ab4:	0a 9b       	mov	r11,r5
80007ab6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80007aba:	f0 1f 00 1f 	mcall	80007b34 <xTaskResumeAll+0xd0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007abe:	64 08       	ld.w	r8,r2[0x0]
80007ac0:	6e b9       	ld.w	r9,r7[0x2c]
80007ac2:	70 b8       	ld.w	r8,r8[0x2c]
                    {
                        xYieldPending = pdTRUE;
80007ac4:	10 39       	cp.w	r9,r8
80007ac6:	e3 f0 2a 00 	st.wcc	r1[0x0],r0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80007aca:	6c 08       	ld.w	r8,r6[0x0]
80007acc:	58 08       	cp.w	r8,0
80007ace:	ce 11       	brne	80007a90 <xTaskResumeAll+0x2c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
80007ad0:	58 07       	cp.w	r7,0
80007ad2:	c0 30       	breq	80007ad8 <xTaskResumeAll+0x74>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
80007ad4:	f0 1f 00 19 	mcall	80007b38 <xTaskResumeAll+0xd4>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
80007ad8:	49 98       	lddpc	r8,80007b3c <xTaskResumeAll+0xd8>
80007ada:	70 07       	ld.w	r7,r8[0x0]

                    if( xPendedCounts > ( TickType_t ) 0U )
80007adc:	58 07       	cp.w	r7,0
80007ade:	c0 c0       	breq	80007af6 <xTaskResumeAll+0x92>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
80007ae0:	49 36       	lddpc	r6,80007b2c <xTaskResumeAll+0xc8>
80007ae2:	30 15       	mov	r5,1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
80007ae4:	f0 1f 00 17 	mcall	80007b40 <xTaskResumeAll+0xdc>
                            {
                                xYieldPending = pdTRUE;
80007ae8:	ed f5 1a 00 	st.wne	r6[0x0],r5
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
80007aec:	20 17       	sub	r7,1
                        } while( xPendedCounts > ( TickType_t ) 0U );
80007aee:	cf b1       	brne	80007ae4 <xTaskResumeAll+0x80>

                        xPendedTicks = 0;
80007af0:	30 09       	mov	r9,0
80007af2:	49 38       	lddpc	r8,80007b3c <xTaskResumeAll+0xd8>
80007af4:	91 09       	st.w	r8[0x0],r9
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
80007af6:	48 e8       	lddpc	r8,80007b2c <xTaskResumeAll+0xc8>
80007af8:	70 08       	ld.w	r8,r8[0x0]
80007afa:	58 08       	cp.w	r8,0
80007afc:	c0 40       	breq	80007b04 <xTaskResumeAll+0xa0>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
80007afe:	d7 33       	scall
80007b00:	30 17       	mov	r7,1
80007b02:	c0 28       	rjmp	80007b06 <xTaskResumeAll+0xa2>
80007b04:	30 07       	mov	r7,0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
80007b06:	f0 1f 00 10 	mcall	80007b44 <xTaskResumeAll+0xe0>

    return xAlreadyYielded;
}
80007b0a:	0e 9c       	mov	r12,r7
80007b0c:	d8 32       	popm	r0-r7,pc
80007b0e:	00 00       	add	r0,r0
80007b10:	80 00       	ld.sh	r0,r0[0x0]
80007b12:	6f 34       	ld.w	r4,r7[0x4c]
80007b14:	00 00       	add	r0,r0
80007b16:	06 68       	and	r8,r3
80007b18:	00 00       	add	r0,r0
80007b1a:	06 84       	andn	r4,r3
80007b1c:	00 00       	add	r0,r0
80007b1e:	06 3c       	cp.w	r12,r3
80007b20:	00 00       	add	r0,r0
80007b22:	06 b4       	st.h	r3++,r4
80007b24:	00 00       	add	r0,r0
80007b26:	05 94       	ld.ub	r4,r2[0x1]
80007b28:	00 00       	add	r0,r0
80007b2a:	06 38       	cp.w	r8,r3
80007b2c:	00 00       	add	r0,r0
80007b2e:	06 b8       	st.h	r3++,r8
80007b30:	80 00       	ld.sh	r0,r0[0x0]
80007b32:	6e 7a       	ld.w	r10,r7[0x1c]
80007b34:	80 00       	ld.sh	r0,r0[0x0]
80007b36:	6e 32       	ld.w	r2,r7[0xc]
80007b38:	80 00       	ld.sh	r0,r0[0x0]
80007b3a:	76 94       	ld.w	r4,r11[0x24]
80007b3c:	00 00       	add	r0,r0
80007b3e:	05 90       	ld.ub	r0,r2[0x1]
80007b40:	80 00       	ld.sh	r0,r0[0x0]
80007b42:	79 5c       	ld.w	r12,r12[0x54]
80007b44:	80 00       	ld.sh	r0,r0[0x0]
80007b46:	70 40       	ld.w	r0,r8[0x10]

80007b48 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
80007b48:	d4 21       	pushm	r4-r7,lr
80007b4a:	18 97       	mov	r7,r12
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80007b4c:	f0 1f 00 17 	mcall	80007ba8 <xTaskResumeFromISR+0x60>
80007b50:	c0 31       	brne	80007b56 <xTaskResumeFromISR+0xe>
80007b52:	30 07       	mov	r7,0
80007b54:	c2 78       	rjmp	80007ba2 <xTaskResumeFromISR+0x5a>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007b56:	49 68       	lddpc	r8,80007bac <xTaskResumeFromISR+0x64>
80007b58:	70 08       	ld.w	r8,r8[0x0]
80007b5a:	58 08       	cp.w	r8,0
80007b5c:	c1 d1       	brne	80007b96 <xTaskResumeFromISR+0x4e>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007b5e:	6e b5       	ld.w	r5,r7[0x2c]
80007b60:	49 48       	lddpc	r8,80007bb0 <xTaskResumeFromISR+0x68>
80007b62:	70 08       	ld.w	r8,r8[0x0]
80007b64:	70 b4       	ld.w	r4,r8[0x2c]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007b66:	ee c6 ff fc 	sub	r6,r7,-4
80007b6a:	0c 9c       	mov	r12,r6
80007b6c:	f0 1f 00 12 	mcall	80007bb4 <xTaskResumeFromISR+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80007b70:	6e bc       	ld.w	r12,r7[0x2c]
80007b72:	49 28       	lddpc	r8,80007bb8 <xTaskResumeFromISR+0x70>
80007b74:	70 08       	ld.w	r8,r8[0x0]
80007b76:	10 3c       	cp.w	r12,r8
80007b78:	e0 88 00 04 	brls	80007b80 <xTaskResumeFromISR+0x38>
80007b7c:	48 f8       	lddpc	r8,80007bb8 <xTaskResumeFromISR+0x70>
80007b7e:	91 0c       	st.w	r8[0x0],r12
80007b80:	08 35       	cp.w	r5,r4
80007b82:	5f 27       	srhs	r7
80007b84:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007b88:	0c 9b       	mov	r11,r6
80007b8a:	48 d8       	lddpc	r8,80007bbc <xTaskResumeFromISR+0x74>
80007b8c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007b90:	f0 1f 00 0c 	mcall	80007bc0 <xTaskResumeFromISR+0x78>
80007b94:	c0 78       	rjmp	80007ba2 <xTaskResumeFromISR+0x5a>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80007b96:	ee cb ff e8 	sub	r11,r7,-24
80007b9a:	48 bc       	lddpc	r12,80007bc4 <xTaskResumeFromISR+0x7c>
80007b9c:	f0 1f 00 09 	mcall	80007bc0 <xTaskResumeFromISR+0x78>
80007ba0:	30 07       	mov	r7,0
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
80007ba2:	0e 9c       	mov	r12,r7
80007ba4:	d8 22       	popm	r4-r7,pc
80007ba6:	00 00       	add	r0,r0
80007ba8:	80 00       	ld.sh	r0,r0[0x0]
80007baa:	75 cc       	ld.w	r12,r10[0x70]
80007bac:	00 00       	add	r0,r0
80007bae:	06 68       	and	r8,r3
80007bb0:	00 00       	add	r0,r0
80007bb2:	06 38       	cp.w	r8,r3
80007bb4:	80 00       	ld.sh	r0,r0[0x0]
80007bb6:	6e 7a       	ld.w	r10,r7[0x1c]
80007bb8:	00 00       	add	r0,r0
80007bba:	06 b4       	st.h	r3++,r4
80007bbc:	00 00       	add	r0,r0
80007bbe:	05 94       	ld.ub	r4,r2[0x1]
80007bc0:	80 00       	ld.sh	r0,r0[0x0]
80007bc2:	6e 32       	ld.w	r2,r7[0xc]
80007bc4:	00 00       	add	r0,r0
80007bc6:	06 3c       	cp.w	r12,r3

80007bc8 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
80007bc8:	eb cd 40 e0 	pushm	r5-r7,lr
80007bcc:	18 97       	mov	r7,r12
80007bce:	16 95       	mov	r5,r11
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
80007bd0:	49 b8       	lddpc	r8,80007c3c <prvAddCurrentTaskToDelayedList+0x74>
80007bd2:	70 06       	ld.w	r6,r8[0x0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007bd4:	49 b8       	lddpc	r8,80007c40 <prvAddCurrentTaskToDelayedList+0x78>
80007bd6:	70 0c       	ld.w	r12,r8[0x0]
80007bd8:	2f cc       	sub	r12,-4
80007bda:	f0 1f 00 1b 	mcall	80007c44 <prvAddCurrentTaskToDelayedList+0x7c>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80007bde:	5b f7       	cp.w	r7,-1
80007be0:	5f 09       	sreq	r9
80007be2:	58 05       	cp.w	r5,0
80007be4:	5f 18       	srne	r8
80007be6:	f3 e8 00 08 	and	r8,r9,r8
80007bea:	c0 90       	breq	80007bfc <prvAddCurrentTaskToDelayedList+0x34>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007bec:	49 58       	lddpc	r8,80007c40 <prvAddCurrentTaskToDelayedList+0x78>
80007bee:	70 0b       	ld.w	r11,r8[0x0]
80007bf0:	2f cb       	sub	r11,-4
80007bf2:	49 6c       	lddpc	r12,80007c48 <prvAddCurrentTaskToDelayedList+0x80>
80007bf4:	f0 1f 00 16 	mcall	80007c4c <prvAddCurrentTaskToDelayedList+0x84>
80007bf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
80007bfc:	0c 07       	add	r7,r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80007bfe:	49 18       	lddpc	r8,80007c40 <prvAddCurrentTaskToDelayedList+0x78>
80007c00:	70 08       	ld.w	r8,r8[0x0]
80007c02:	91 17       	st.w	r8[0x4],r7

                if( xTimeToWake < xConstTickCount )
80007c04:	0e 36       	cp.w	r6,r7
80007c06:	e0 88 00 0b 	brls	80007c1c <prvAddCurrentTaskToDelayedList+0x54>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007c0a:	48 e8       	lddpc	r8,80007c40 <prvAddCurrentTaskToDelayedList+0x78>
80007c0c:	70 0b       	ld.w	r11,r8[0x0]
80007c0e:	49 18       	lddpc	r8,80007c50 <prvAddCurrentTaskToDelayedList+0x88>
80007c10:	70 0c       	ld.w	r12,r8[0x0]
80007c12:	2f cb       	sub	r11,-4
80007c14:	f0 1f 00 10 	mcall	80007c54 <prvAddCurrentTaskToDelayedList+0x8c>
80007c18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007c1c:	48 98       	lddpc	r8,80007c40 <prvAddCurrentTaskToDelayedList+0x78>
80007c1e:	70 0b       	ld.w	r11,r8[0x0]
80007c20:	48 e8       	lddpc	r8,80007c58 <prvAddCurrentTaskToDelayedList+0x90>
80007c22:	70 0c       	ld.w	r12,r8[0x0]
80007c24:	2f cb       	sub	r11,-4
80007c26:	f0 1f 00 0c 	mcall	80007c54 <prvAddCurrentTaskToDelayedList+0x8c>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
80007c2a:	48 d8       	lddpc	r8,80007c5c <prvAddCurrentTaskToDelayedList+0x94>
80007c2c:	70 08       	ld.w	r8,r8[0x0]
80007c2e:	10 37       	cp.w	r7,r8
80007c30:	c0 32       	brcc	80007c36 <prvAddCurrentTaskToDelayedList+0x6e>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
80007c32:	48 b8       	lddpc	r8,80007c5c <prvAddCurrentTaskToDelayedList+0x94>
80007c34:	91 07       	st.w	r8[0x0],r7
80007c36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007c3a:	00 00       	add	r0,r0
80007c3c:	00 00       	add	r0,r0
80007c3e:	06 64       	and	r4,r3
80007c40:	00 00       	add	r0,r0
80007c42:	06 38       	cp.w	r8,r3
80007c44:	80 00       	ld.sh	r0,r0[0x0]
80007c46:	6e 7a       	ld.w	r10,r7[0x1c]
80007c48:	00 00       	add	r0,r0
80007c4a:	06 a0       	st.w	r3++,r0
80007c4c:	80 00       	ld.sh	r0,r0[0x0]
80007c4e:	6e 32       	ld.w	r2,r7[0xc]
80007c50:	00 00       	add	r0,r0
80007c52:	05 8c       	ld.ub	r12,r2[0x0]
80007c54:	80 00       	ld.sh	r0,r0[0x0]
80007c56:	6e 4a       	ld.w	r10,r7[0x10]
80007c58:	00 00       	add	r0,r0
80007c5a:	05 80       	ld.ub	r0,r2[0x0]
80007c5c:	00 00       	add	r0,r0
80007c5e:	05 7c       	ld.ub	r12,--r2

80007c60 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
80007c60:	eb cd 40 80 	pushm	r7,lr
80007c64:	16 97       	mov	r7,r11

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80007c66:	48 68       	lddpc	r8,80007c7c <vTaskPlaceOnEventList+0x1c>
80007c68:	70 0b       	ld.w	r11,r8[0x0]
80007c6a:	2e 8b       	sub	r11,-24
80007c6c:	f0 1f 00 05 	mcall	80007c80 <vTaskPlaceOnEventList+0x20>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80007c70:	30 1b       	mov	r11,1
80007c72:	0e 9c       	mov	r12,r7
80007c74:	f0 1f 00 04 	mcall	80007c84 <vTaskPlaceOnEventList+0x24>
}
80007c78:	e3 cd 80 80 	ldm	sp++,r7,pc
80007c7c:	00 00       	add	r0,r0
80007c7e:	06 38       	cp.w	r8,r3
80007c80:	80 00       	ld.sh	r0,r0[0x0]
80007c82:	6e 4a       	ld.w	r10,r7[0x10]
80007c84:	80 00       	ld.sh	r0,r0[0x0]
80007c86:	7b c8       	ld.w	r8,sp[0x70]

80007c88 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
80007c88:	eb cd 40 80 	pushm	r7,lr
80007c8c:	18 97       	mov	r7,r12

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
80007c8e:	78 cc       	ld.w	r12,r12[0x30]
80007c90:	f0 1f 00 04 	mcall	80007ca0 <prvDeleteTCB+0x18>
                vPortFree( pxTCB );
80007c94:	0e 9c       	mov	r12,r7
80007c96:	f0 1f 00 03 	mcall	80007ca0 <prvDeleteTCB+0x18>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
80007c9a:	e3 cd 80 80 	ldm	sp++,r7,pc
80007c9e:	00 00       	add	r0,r0
80007ca0:	80 00       	ld.sh	r0,r0[0x0]
80007ca2:	70 fc       	ld.w	r12,r8[0x3c]

80007ca4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007ca4:	eb cd 40 f8 	pushm	r3-r7,lr
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80007ca8:	49 17       	lddpc	r7,80007cec <prvIdleTask+0x48>
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007caa:	49 25       	lddpc	r5,80007cf0 <prvIdleTask+0x4c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
80007cac:	49 24       	lddpc	r4,80007cf4 <prvIdleTask+0x50>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80007cae:	49 33       	lddpc	r3,80007cf8 <prvIdleTask+0x54>
80007cb0:	c1 48       	rjmp	80007cd8 <prvIdleTask+0x34>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
80007cb2:	f0 1f 00 13 	mcall	80007cfc <prvIdleTask+0x58>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007cb6:	6a 38       	ld.w	r8,r5[0xc]
80007cb8:	70 36       	ld.w	r6,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007cba:	ec cc ff fc 	sub	r12,r6,-4
80007cbe:	f0 1f 00 11 	mcall	80007d00 <prvIdleTask+0x5c>
                    --uxCurrentNumberOfTasks;
80007cc2:	68 08       	ld.w	r8,r4[0x0]
80007cc4:	20 18       	sub	r8,1
80007cc6:	89 08       	st.w	r4[0x0],r8
                    --uxDeletedTasksWaitingCleanUp;
80007cc8:	6e 08       	ld.w	r8,r7[0x0]
80007cca:	20 18       	sub	r8,1
80007ccc:	8f 08       	st.w	r7[0x0],r8
                }
                taskEXIT_CRITICAL();
80007cce:	f0 1f 00 0e 	mcall	80007d04 <prvIdleTask+0x60>

                prvDeleteTCB( pxTCB );
80007cd2:	0c 9c       	mov	r12,r6
80007cd4:	f0 1f 00 0d 	mcall	80007d08 <prvIdleTask+0x64>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80007cd8:	6e 08       	ld.w	r8,r7[0x0]
80007cda:	58 08       	cp.w	r8,0
80007cdc:	ce b1       	brne	80007cb2 <prvIdleTask+0xe>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80007cde:	66 08       	ld.w	r8,r3[0x0]
80007ce0:	58 18       	cp.w	r8,1
80007ce2:	fe 98 ff fb 	brls	80007cd8 <prvIdleTask+0x34>
                {
                    taskYIELD();
80007ce6:	d7 33       	scall
80007ce8:	cf 8b       	rjmp	80007cd8 <prvIdleTask+0x34>
80007cea:	00 00       	add	r0,r0
80007cec:	00 00       	add	r0,r0
80007cee:	06 34       	cp.w	r4,r3
80007cf0:	00 00       	add	r0,r0
80007cf2:	06 88       	andn	r8,r3
80007cf4:	00 00       	add	r0,r0
80007cf6:	06 84       	andn	r4,r3
80007cf8:	00 00       	add	r0,r0
80007cfa:	05 94       	ld.ub	r4,r2[0x1]
80007cfc:	80 00       	ld.sh	r0,r0[0x0]
80007cfe:	6f 34       	ld.w	r4,r7[0x4c]
80007d00:	80 00       	ld.sh	r0,r0[0x0]
80007d02:	6e 7a       	ld.w	r10,r7[0x1c]
80007d04:	80 00       	ld.sh	r0,r0[0x0]
80007d06:	70 40       	ld.w	r0,r8[0x10]
80007d08:	80 00       	ld.sh	r0,r0[0x0]
80007d0a:	7c 88       	ld.w	r8,lr[0x20]

80007d0c <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
80007d0c:	d4 31       	pushm	r0-r7,lr
80007d0e:	20 1d       	sub	sp,4
80007d10:	50 0c       	stdsp	sp[0x0],r12
80007d12:	16 97       	mov	r7,r11
80007d14:	12 90       	mov	r0,r9
80007d16:	10 94       	mov	r4,r8
80007d18:	40 a2       	lddsp	r2,sp[0x28]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
80007d1a:	e7 da c0 10 	bfextu	r3,r10,0x0,0x10
80007d1e:	e6 0c 15 02 	lsl	r12,r3,0x2
80007d22:	f0 1f 00 61 	mcall	80007ea4 <xTaskCreate+0x198>
80007d26:	18 96       	mov	r6,r12

                if( pxStack != NULL )
80007d28:	c0 31       	brne	80007d2e <xTaskCreate+0x22>
80007d2a:	3f fc       	mov	r12,-1
80007d2c:	cb a8       	rjmp	80007ea0 <xTaskCreate+0x194>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
80007d2e:	35 4c       	mov	r12,84
80007d30:	f0 1f 00 5d 	mcall	80007ea4 <xTaskCreate+0x198>
80007d34:	18 95       	mov	r5,r12

                    if( pxNewTCB != NULL )
80007d36:	c0 50       	breq	80007d40 <xTaskCreate+0x34>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
80007d38:	99 c6       	st.w	r12[0x30],r6
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
80007d3a:	58 07       	cp.w	r7,0
80007d3c:	c0 71       	brne	80007d4a <xTaskCreate+0x3e>
80007d3e:	c2 28       	rjmp	80007d82 <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
80007d40:	0c 9c       	mov	r12,r6
80007d42:	f0 1f 00 5a 	mcall	80007ea8 <xTaskCreate+0x19c>
80007d46:	3f fc       	mov	r12,-1
80007d48:	ca c8       	rjmp	80007ea0 <xTaskCreate+0x194>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80007d4a:	0f 88       	ld.ub	r8,r7[0x0]
80007d4c:	f9 68 00 34 	st.b	r12[52],r8

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80007d50:	0f 89       	ld.ub	r9,r7[0x0]
80007d52:	30 08       	mov	r8,0
80007d54:	f0 09 18 00 	cp.b	r9,r8
80007d58:	c1 10       	breq	80007d7a <xTaskCreate+0x6e>
80007d5a:	2f f7       	sub	r7,-1
80007d5c:	f8 c8 ff cb 	sub	r8,r12,-53
80007d60:	30 19       	mov	r9,1
80007d62:	30 0b       	mov	r11,0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80007d64:	0f 8a       	ld.ub	r10,r7[0x0]
80007d66:	b0 8a       	st.b	r8[0x0],r10

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80007d68:	0f 8a       	ld.ub	r10,r7[0x0]
80007d6a:	f6 0a 18 00 	cp.b	r10,r11
80007d6e:	c0 60       	breq	80007d7a <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80007d70:	2f f9       	sub	r9,-1
80007d72:	2f f7       	sub	r7,-1
80007d74:	2f f8       	sub	r8,-1
80007d76:	59 09       	cp.w	r9,16
80007d78:	cf 61       	brne	80007d64 <xTaskCreate+0x58>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80007d7a:	30 08       	mov	r8,0
80007d7c:	eb 68 00 43 	st.b	r5[67],r8
80007d80:	c0 48       	rjmp	80007d88 <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
80007d82:	30 08       	mov	r8,0
80007d84:	f9 68 00 34 	st.b	r12[52],r8
80007d88:	58 74       	cp.w	r4,7
80007d8a:	f9 b4 0b 07 	movhi	r4,7
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
80007d8e:	8b b4       	st.w	r5[0x2c],r4
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
80007d90:	eb 44 00 44 	st.w	r5[68],r4
            pxNewTCB->uxMutexesHeld = 0;
80007d94:	30 07       	mov	r7,0
80007d96:	eb 47 00 48 	st.w	r5[72],r7
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80007d9a:	ea c1 ff fc 	sub	r1,r5,-4
80007d9e:	02 9c       	mov	r12,r1
80007da0:	f0 1f 00 43 	mcall	80007eac <xTaskCreate+0x1a0>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80007da4:	ea cc ff e8 	sub	r12,r5,-24
80007da8:	f0 1f 00 41 	mcall	80007eac <xTaskCreate+0x1a0>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80007dac:	8b 45       	st.w	r5[0x10],r5

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007dae:	e8 04 11 08 	rsub	r4,r4,8
80007db2:	8b 64       	st.w	r5[0x18],r4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80007db4:	8b 95       	st.w	r5[0x24],r5
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
80007db6:	ea c8 ff b4 	sub	r8,r5,-76
80007dba:	91 07       	st.w	r8[0x0],r7
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
80007dbc:	ea c8 ff b0 	sub	r8,r5,-80
80007dc0:	b0 87       	st.b	r8[0x0],r7
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
80007dc2:	20 13       	sub	r3,1
80007dc4:	ec 03 00 26 	add	r6,r6,r3<<0x2
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007dc8:	00 9a       	mov	r10,r0
80007dca:	40 0b       	lddsp	r11,sp[0x0]
80007dcc:	0c 9c       	mov	r12,r6
80007dce:	e0 1c ff fc 	andl	r12,0xfffc
80007dd2:	f0 1f 00 38 	mcall	80007eb0 <xTaskCreate+0x1a4>
80007dd6:	8b 0c       	st.w	r5[0x0],r12

    if( pxCreatedTask != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80007dd8:	58 02       	cp.w	r2,0
80007dda:	e5 f5 1a 00 	st.wne	r2[0x0],r5

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
80007dde:	f0 1f 00 36 	mcall	80007eb4 <xTaskCreate+0x1a8>
    {
        uxCurrentNumberOfTasks++;
80007de2:	4b 68       	lddpc	r8,80007eb8 <xTaskCreate+0x1ac>
80007de4:	70 09       	ld.w	r9,r8[0x0]
80007de6:	2f f9       	sub	r9,-1
80007de8:	91 09       	st.w	r8[0x0],r9

        if( pxCurrentTCB == NULL )
80007dea:	4b 58       	lddpc	r8,80007ebc <xTaskCreate+0x1b0>
80007dec:	70 08       	ld.w	r8,r8[0x0]
80007dee:	58 08       	cp.w	r8,0
80007df0:	c2 61       	brne	80007e3c <xTaskCreate+0x130>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
80007df2:	4b 38       	lddpc	r8,80007ebc <xTaskCreate+0x1b0>
80007df4:	91 05       	st.w	r8[0x0],r5

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80007df6:	4b 18       	lddpc	r8,80007eb8 <xTaskCreate+0x1ac>
80007df8:	70 08       	ld.w	r8,r8[0x0]
80007dfa:	58 18       	cp.w	r8,1
80007dfc:	c2 d1       	brne	80007e56 <xTaskCreate+0x14a>
80007dfe:	4b 17       	lddpc	r7,80007ec0 <xTaskCreate+0x1b4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
80007e00:	ee c6 ff 60 	sub	r6,r7,-160
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
80007e04:	0e 9c       	mov	r12,r7
80007e06:	f0 1f 00 30 	mcall	80007ec4 <xTaskCreate+0x1b8>
80007e0a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80007e0c:	0c 37       	cp.w	r7,r6
80007e0e:	cf b1       	brne	80007e04 <xTaskCreate+0xf8>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
80007e10:	4a e7       	lddpc	r7,80007ec8 <xTaskCreate+0x1bc>
80007e12:	0e 9c       	mov	r12,r7
80007e14:	f0 1f 00 2c 	mcall	80007ec4 <xTaskCreate+0x1b8>
    vListInitialise( &xDelayedTaskList2 );
80007e18:	4a d6       	lddpc	r6,80007ecc <xTaskCreate+0x1c0>
80007e1a:	0c 9c       	mov	r12,r6
80007e1c:	f0 1f 00 2a 	mcall	80007ec4 <xTaskCreate+0x1b8>
    vListInitialise( &xPendingReadyList );
80007e20:	4a cc       	lddpc	r12,80007ed0 <xTaskCreate+0x1c4>
80007e22:	f0 1f 00 29 	mcall	80007ec4 <xTaskCreate+0x1b8>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
80007e26:	4a cc       	lddpc	r12,80007ed4 <xTaskCreate+0x1c8>
80007e28:	f0 1f 00 27 	mcall	80007ec4 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
80007e2c:	4a bc       	lddpc	r12,80007ed8 <xTaskCreate+0x1cc>
80007e2e:	f0 1f 00 26 	mcall	80007ec4 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
80007e32:	4a b8       	lddpc	r8,80007edc <xTaskCreate+0x1d0>
80007e34:	91 07       	st.w	r8[0x0],r7
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007e36:	4a b8       	lddpc	r8,80007ee0 <xTaskCreate+0x1d4>
80007e38:	91 06       	st.w	r8[0x0],r6
80007e3a:	c0 e8       	rjmp	80007e56 <xTaskCreate+0x14a>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
80007e3c:	4a a8       	lddpc	r8,80007ee4 <xTaskCreate+0x1d8>
80007e3e:	70 08       	ld.w	r8,r8[0x0]
80007e40:	58 08       	cp.w	r8,0
80007e42:	c0 a1       	brne	80007e56 <xTaskCreate+0x14a>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80007e44:	49 e8       	lddpc	r8,80007ebc <xTaskCreate+0x1b0>
80007e46:	70 08       	ld.w	r8,r8[0x0]
80007e48:	70 b9       	ld.w	r9,r8[0x2c]
80007e4a:	6a b8       	ld.w	r8,r5[0x2c]
80007e4c:	10 39       	cp.w	r9,r8
80007e4e:	e0 8b 00 04 	brhi	80007e56 <xTaskCreate+0x14a>
                {
                    pxCurrentTCB = pxNewTCB;
80007e52:	49 b8       	lddpc	r8,80007ebc <xTaskCreate+0x1b0>
80007e54:	91 05       	st.w	r8[0x0],r5
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
80007e56:	4a 58       	lddpc	r8,80007ee8 <xTaskCreate+0x1dc>
80007e58:	70 09       	ld.w	r9,r8[0x0]
80007e5a:	2f f9       	sub	r9,-1
80007e5c:	91 09       	st.w	r8[0x0],r9
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
80007e5e:	6a b8       	ld.w	r8,r5[0x2c]
80007e60:	4a 39       	lddpc	r9,80007eec <xTaskCreate+0x1e0>
80007e62:	72 09       	ld.w	r9,r9[0x0]
80007e64:	12 38       	cp.w	r8,r9
80007e66:	e0 88 00 04 	brls	80007e6e <xTaskCreate+0x162>
80007e6a:	4a 19       	lddpc	r9,80007eec <xTaskCreate+0x1e0>
80007e6c:	93 08       	st.w	r9[0x0],r8
80007e6e:	6a bc       	ld.w	r12,r5[0x2c]
80007e70:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007e74:	02 9b       	mov	r11,r1
80007e76:	49 38       	lddpc	r8,80007ec0 <xTaskCreate+0x1b4>
80007e78:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007e7c:	f0 1f 00 1d 	mcall	80007ef0 <xTaskCreate+0x1e4>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
80007e80:	f0 1f 00 1d 	mcall	80007ef4 <xTaskCreate+0x1e8>

    if( xSchedulerRunning != pdFALSE )
80007e84:	49 88       	lddpc	r8,80007ee4 <xTaskCreate+0x1d8>
80007e86:	70 08       	ld.w	r8,r8[0x0]
80007e88:	58 08       	cp.w	r8,0
80007e8a:	c0 a0       	breq	80007e9e <xTaskCreate+0x192>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80007e8c:	48 c8       	lddpc	r8,80007ebc <xTaskCreate+0x1b0>
80007e8e:	70 08       	ld.w	r8,r8[0x0]
80007e90:	70 b9       	ld.w	r9,r8[0x2c]
80007e92:	6a b8       	ld.w	r8,r5[0x2c]
80007e94:	10 39       	cp.w	r9,r8
80007e96:	c0 42       	brcc	80007e9e <xTaskCreate+0x192>
        {
            taskYIELD_IF_USING_PREEMPTION();
80007e98:	d7 33       	scall
80007e9a:	30 1c       	mov	r12,1
80007e9c:	c0 28       	rjmp	80007ea0 <xTaskCreate+0x194>
80007e9e:	30 1c       	mov	r12,1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
80007ea0:	2f fd       	sub	sp,-4
80007ea2:	d8 32       	popm	r0-r7,pc
80007ea4:	80 00       	ld.sh	r0,r0[0x0]
80007ea6:	71 24       	ld.w	r4,r8[0x48]
80007ea8:	80 00       	ld.sh	r0,r0[0x0]
80007eaa:	70 fc       	ld.w	r12,r8[0x3c]
80007eac:	80 00       	ld.sh	r0,r0[0x0]
80007eae:	6e 2c       	ld.w	r12,r7[0x8]
80007eb0:	80 00       	ld.sh	r0,r0[0x0]
80007eb2:	6e a2       	ld.w	r2,r7[0x28]
80007eb4:	80 00       	ld.sh	r0,r0[0x0]
80007eb6:	6f 34       	ld.w	r4,r7[0x4c]
80007eb8:	00 00       	add	r0,r0
80007eba:	06 84       	andn	r4,r3
80007ebc:	00 00       	add	r0,r0
80007ebe:	06 38       	cp.w	r8,r3
80007ec0:	00 00       	add	r0,r0
80007ec2:	05 94       	ld.ub	r4,r2[0x1]
80007ec4:	80 00       	ld.sh	r0,r0[0x0]
80007ec6:	6e 18       	ld.w	r8,r7[0x4]
80007ec8:	00 00       	add	r0,r0
80007eca:	06 50       	eor	r0,r3
80007ecc:	00 00       	add	r0,r0
80007ece:	06 6c       	and	r12,r3
80007ed0:	00 00       	add	r0,r0
80007ed2:	06 3c       	cp.w	r12,r3
80007ed4:	00 00       	add	r0,r0
80007ed6:	06 88       	andn	r8,r3
80007ed8:	00 00       	add	r0,r0
80007eda:	06 a0       	st.w	r3++,r0
80007edc:	00 00       	add	r0,r0
80007ede:	05 80       	ld.ub	r0,r2[0x0]
80007ee0:	00 00       	add	r0,r0
80007ee2:	05 8c       	ld.ub	r12,r2[0x0]
80007ee4:	00 00       	add	r0,r0
80007ee6:	05 84       	ld.ub	r4,r2[0x0]
80007ee8:	00 00       	add	r0,r0
80007eea:	06 80       	andn	r0,r3
80007eec:	00 00       	add	r0,r0
80007eee:	06 b4       	st.h	r3++,r4
80007ef0:	80 00       	ld.sh	r0,r0[0x0]
80007ef2:	6e 32       	ld.w	r2,r7[0xc]
80007ef4:	80 00       	ld.sh	r0,r0[0x0]
80007ef6:	70 40       	ld.w	r0,r8[0x10]

80007ef8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
80007ef8:	d4 01       	pushm	lr
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
80007efa:	48 e8       	lddpc	r8,80007f30 <vTaskStartScheduler+0x38>
80007efc:	1a d8       	st.w	--sp,r8
80007efe:	30 08       	mov	r8,0
80007f00:	10 99       	mov	r9,r8
80007f02:	e0 6a 01 00 	mov	r10,256
80007f06:	48 cb       	lddpc	r11,80007f34 <vTaskStartScheduler+0x3c>
80007f08:	48 cc       	lddpc	r12,80007f38 <vTaskStartScheduler+0x40>
80007f0a:	f0 1f 00 0d 	mcall	80007f3c <vTaskStartScheduler+0x44>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
80007f0e:	2f fd       	sub	sp,-4
80007f10:	58 1c       	cp.w	r12,1
80007f12:	c0 d1       	brne	80007f2c <vTaskStartScheduler+0x34>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
80007f14:	d3 03       	ssrf	0x10
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
80007f16:	3f f9       	mov	r9,-1
80007f18:	48 a8       	lddpc	r8,80007f40 <vTaskStartScheduler+0x48>
80007f1a:	91 09       	st.w	r8[0x0],r9
        xSchedulerRunning = pdTRUE;
80007f1c:	30 19       	mov	r9,1
80007f1e:	48 a8       	lddpc	r8,80007f44 <vTaskStartScheduler+0x4c>
80007f20:	91 09       	st.w	r8[0x0],r9
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
80007f22:	30 09       	mov	r9,0
80007f24:	48 98       	lddpc	r8,80007f48 <vTaskStartScheduler+0x50>
80007f26:	91 09       	st.w	r8[0x0],r9

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
80007f28:	f0 1f 00 09 	mcall	80007f4c <vTaskStartScheduler+0x54>
80007f2c:	d8 02       	popm	pc
80007f2e:	00 00       	add	r0,r0
80007f30:	00 00       	add	r0,r0
80007f32:	06 9c       	mov	r12,r3
80007f34:	80 00       	ld.sh	r0,r0[0x0]
80007f36:	9d f0       	st.w	lr[0x3c],r0
80007f38:	80 00       	ld.sh	r0,r0[0x0]
80007f3a:	7c a4       	ld.w	r4,lr[0x28]
80007f3c:	80 00       	ld.sh	r0,r0[0x0]
80007f3e:	7d 0c       	ld.w	r12,lr[0x40]
80007f40:	00 00       	add	r0,r0
80007f42:	05 7c       	ld.ub	r12,--r2
80007f44:	00 00       	add	r0,r0
80007f46:	05 84       	ld.ub	r4,r2[0x0]
80007f48:	00 00       	add	r0,r0
80007f4a:	06 64       	and	r4,r3
80007f4c:	80 00       	ld.sh	r0,r0[0x0]
80007f4e:	6f 44       	ld.w	r4,r7[0x50]

80007f50 <LED_On>:
  }
}


void LED_On(uint32_t leds)
{
80007f50:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80007f52:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);
80007f56:	49 48       	lddpc	r8,80007fa4 <LED_On+0x54>
80007f58:	70 09       	ld.w	r9,r8[0x0]
80007f5a:	f9 e9 10 09 	or	r9,r12,r9
80007f5e:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80007f60:	58 0c       	cp.w	r12,0
80007f62:	c1 f0       	breq	80007fa0 <LED_On+0x50>
80007f64:	49 18       	lddpc	r8,80007fa8 <LED_On+0x58>
80007f66:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it on.
    led_shift = 1 + ctz(leds);
80007f68:	32 1e       	mov	lr,33
80007f6a:	58 0c       	cp.w	r12,0
80007f6c:	c0 31       	brne	80007f72 <LED_On+0x22>
80007f6e:	1c 9a       	mov	r10,lr
80007f70:	c0 68       	rjmp	80007f7c <LED_On+0x2c>
80007f72:	18 9a       	mov	r10,r12
80007f74:	5c 9a       	brev	r10
80007f76:	f4 0a 12 00 	clz	r10,r10
80007f7a:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80007f7c:	f4 09 15 04 	lsl	r9,r10,0x4
80007f80:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80007f82:	70 09       	ld.w	r9,r8[0x0]
80007f84:	a9 69       	lsl	r9,0x8
80007f86:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrc  = led_descriptor->GPIO.PIN_MASK;
80007f8a:	70 1b       	ld.w	r11,r8[0x4]
80007f8c:	f3 4b 00 58 	st.w	r9[88],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80007f90:	70 1b       	ld.w	r11,r8[0x4]
80007f92:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80007f96:	70 1b       	ld.w	r11,r8[0x4]
80007f98:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80007f9a:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80007f9e:	ce 61       	brne	80007f6a <LED_On+0x1a>
80007fa0:	d8 02       	popm	pc
80007fa2:	00 00       	add	r0,r0
80007fa4:	00 00       	add	r0,r0
80007fa6:	00 14       	sub	r4,r0
80007fa8:	80 00       	ld.sh	r0,r0[0x0]
80007faa:	9d f8       	st.w	lr[0x3c],r8

80007fac <LED_Off>:
  return Tst_bits(LED_State, leds);
}


void LED_Off(uint32_t leds)
{
80007fac:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80007fae:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);
80007fb2:	49 58       	lddpc	r8,80008004 <LED_Off+0x58>
80007fb4:	70 09       	ld.w	r9,r8[0x0]
80007fb6:	f8 0a 11 ff 	rsub	r10,r12,-1
80007fba:	f5 e9 00 09 	and	r9,r10,r9
80007fbe:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80007fc0:	58 0c       	cp.w	r12,0
80007fc2:	c1 f0       	breq	80008000 <LED_Off+0x54>
80007fc4:	49 18       	lddpc	r8,80008008 <LED_Off+0x5c>
80007fc6:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it off.
    led_shift = 1 + ctz(leds);
80007fc8:	32 1e       	mov	lr,33
80007fca:	58 0c       	cp.w	r12,0
80007fcc:	c0 31       	brne	80007fd2 <LED_Off+0x26>
80007fce:	1c 9a       	mov	r10,lr
80007fd0:	c0 68       	rjmp	80007fdc <LED_Off+0x30>
80007fd2:	18 9a       	mov	r10,r12
80007fd4:	5c 9a       	brev	r10
80007fd6:	f4 0a 12 00 	clz	r10,r10
80007fda:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80007fdc:	f4 09 15 04 	lsl	r9,r10,0x4
80007fe0:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80007fe2:	70 09       	ld.w	r9,r8[0x0]
80007fe4:	a9 69       	lsl	r9,0x8
80007fe6:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
80007fea:	70 1b       	ld.w	r11,r8[0x4]
80007fec:	f3 4b 00 54 	st.w	r9[84],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80007ff0:	70 1b       	ld.w	r11,r8[0x4]
80007ff2:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80007ff6:	70 1b       	ld.w	r11,r8[0x4]
80007ff8:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80007ffa:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80007ffe:	ce 61       	brne	80007fca <LED_Off+0x1e>
80008000:	d8 02       	popm	pc
80008002:	00 00       	add	r0,r0
80008004:	00 00       	add	r0,r0
80008006:	00 14       	sub	r4,r0
80008008:	80 00       	ld.sh	r0,r0[0x0]
8000800a:	9d f8       	st.w	lr[0x3c],r8

8000800c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000800c:	f8 08 16 05 	lsr	r8,r12,0x5
80008010:	a9 68       	lsl	r8,0x8
80008012:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80008016:	58 1b       	cp.w	r11,1
80008018:	c0 d0       	breq	80008032 <gpio_enable_module_pin+0x26>
8000801a:	c0 63       	brcs	80008026 <gpio_enable_module_pin+0x1a>
8000801c:	58 2b       	cp.w	r11,2
8000801e:	c1 00       	breq	8000803e <gpio_enable_module_pin+0x32>
80008020:	58 3b       	cp.w	r11,3
80008022:	c1 40       	breq	8000804a <gpio_enable_module_pin+0x3e>
80008024:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80008026:	30 19       	mov	r9,1
80008028:	f2 0c 09 49 	lsl	r9,r9,r12
8000802c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000802e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80008030:	c1 28       	rjmp	80008054 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80008032:	30 19       	mov	r9,1
80008034:	f2 0c 09 49 	lsl	r9,r9,r12
80008038:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000803a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000803c:	c0 c8       	rjmp	80008054 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000803e:	30 19       	mov	r9,1
80008040:	f2 0c 09 49 	lsl	r9,r9,r12
80008044:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008046:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80008048:	c0 68       	rjmp	80008054 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000804a:	30 19       	mov	r9,1
8000804c:	f2 0c 09 49 	lsl	r9,r9,r12
80008050:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008052:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008054:	30 19       	mov	r9,1
80008056:	f2 0c 09 4c 	lsl	r12,r9,r12
8000805a:	91 2c       	st.w	r8[0x8],r12
8000805c:	5e fd       	retal	0
8000805e:	d7 03       	nop

80008060 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80008060:	d4 21       	pushm	r4-r7,lr
80008062:	18 97       	mov	r7,r12
80008064:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008066:	58 0b       	cp.w	r11,0
80008068:	c0 31       	brne	8000806e <gpio_enable_module+0xe>
8000806a:	30 05       	mov	r5,0
8000806c:	c0 d8       	rjmp	80008086 <gpio_enable_module+0x26>
8000806e:	30 06       	mov	r6,0
80008070:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80008072:	6e 1b       	ld.w	r11,r7[0x4]
80008074:	6e 0c       	ld.w	r12,r7[0x0]
80008076:	f0 1f 00 06 	mcall	8000808c <gpio_enable_module+0x2c>
8000807a:	18 45       	or	r5,r12
		gpiomap++;
8000807c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000807e:	2f f6       	sub	r6,-1
80008080:	0c 34       	cp.w	r4,r6
80008082:	fe 9b ff f8 	brhi	80008072 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80008086:	0a 9c       	mov	r12,r5
80008088:	d8 22       	popm	r4-r7,pc
8000808a:	00 00       	add	r0,r0
8000808c:	80 00       	ld.sh	r0,r0[0x0]
8000808e:	80 0c       	ld.sh	r12,r0[0x0]

80008090 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008090:	f8 08 16 05 	lsr	r8,r12,0x5
80008094:	a9 68       	lsl	r8,0x8
80008096:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000809a:	30 19       	mov	r9,1
8000809c:	f2 0c 09 4c 	lsl	r12,r9,r12
800080a0:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800080a4:	91 1c       	st.w	r8[0x4],r12
}
800080a6:	5e fc       	retal	r12

800080a8 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
800080a8:	eb cd 40 e0 	pushm	r5-r7,lr
800080ac:	18 97       	mov	r7,r12
800080ae:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
800080b0:	58 0b       	cp.w	r11,0
800080b2:	c0 a0       	breq	800080c6 <gpio_enable_gpio+0x1e>
800080b4:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
800080b6:	6e 0c       	ld.w	r12,r7[0x0]
800080b8:	f0 1f 00 05 	mcall	800080cc <gpio_enable_gpio+0x24>
		gpiomap++;
800080bc:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
800080be:	2f f5       	sub	r5,-1
800080c0:	0a 36       	cp.w	r6,r5
800080c2:	fe 9b ff fa 	brhi	800080b6 <gpio_enable_gpio+0xe>
800080c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800080ca:	00 00       	add	r0,r0
800080cc:	80 00       	ld.sh	r0,r0[0x0]
800080ce:	80 90       	ld.uh	r0,r0[0x2]

800080d0 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800080d0:	f8 08 16 05 	lsr	r8,r12,0x5
800080d4:	a9 68       	lsl	r8,0x8
800080d6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800080da:	30 19       	mov	r9,1
800080dc:	f2 0c 09 4c 	lsl	r12,r9,r12
800080e0:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800080e4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800080e8:	91 1c       	st.w	r8[0x4],r12
}
800080ea:	5e fc       	retal	r12

800080ec <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800080ec:	f8 08 16 05 	lsr	r8,r12,0x5
800080f0:	a9 68       	lsl	r8,0x8
800080f2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800080f6:	30 19       	mov	r9,1
800080f8:	f2 0c 09 4c 	lsl	r12,r9,r12
800080fc:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80008100:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80008104:	91 1c       	st.w	r8[0x4],r12
}
80008106:	5e fc       	retal	r12

80008108 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008108:	f8 08 16 05 	lsr	r8,r12,0x5
8000810c:	a9 68       	lsl	r8,0x8
8000810e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80008112:	30 19       	mov	r9,1
80008114:	f2 0c 09 4c 	lsl	r12,r9,r12
80008118:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8000811c:	12 3b       	cp.w	r11,r9
8000811e:	c0 a0       	breq	80008132 <gpio_enable_pin_interrupt+0x2a>
80008120:	c0 43       	brcs	80008128 <gpio_enable_pin_interrupt+0x20>
80008122:	58 2b       	cp.w	r11,2
80008124:	c1 11       	brne	80008146 <gpio_enable_pin_interrupt+0x3e>
80008126:	c0 b8       	rjmp	8000813c <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80008128:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
8000812c:	f1 4c 00 b8 	st.w	r8[184],r12
80008130:	c0 c8       	rjmp	80008148 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80008132:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80008136:	f1 4c 00 b8 	st.w	r8[184],r12
8000813a:	c0 78       	rjmp	80008148 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
8000813c:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
80008140:	f1 4c 00 b4 	st.w	r8[180],r12
80008144:	c0 28       	rjmp	80008148 <gpio_enable_pin_interrupt+0x40>
80008146:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80008148:	f1 4c 00 94 	st.w	r8[148],r12
8000814c:	5e fd       	retal	0

8000814e <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000814e:	f8 08 16 05 	lsr	r8,r12,0x5
80008152:	a9 68       	lsl	r8,0x8
80008154:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80008158:	f0 f8 00 d0 	ld.w	r8,r8[208]
8000815c:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80008160:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80008164:	5e fc       	retal	r12

80008166 <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008166:	f8 08 16 05 	lsr	r8,r12,0x5
8000816a:	a9 68       	lsl	r8,0x8
8000816c:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80008170:	30 19       	mov	r9,1
80008172:	f2 0c 09 4c 	lsl	r12,r9,r12
80008176:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
8000817a:	5e fc       	retal	r12

8000817c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000817c:	c0 08       	rjmp	8000817c <_unhandled_interrupt>
8000817e:	d7 03       	nop

80008180 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80008180:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80008184:	49 99       	lddpc	r9,800081e8 <INTC_register_interrupt+0x68>
80008186:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000818a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000818e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80008190:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80008194:	58 0a       	cp.w	r10,0
80008196:	c0 91       	brne	800081a8 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008198:	49 59       	lddpc	r9,800081ec <INTC_register_interrupt+0x6c>
8000819a:	49 6a       	lddpc	r10,800081f0 <INTC_register_interrupt+0x70>
8000819c:	12 1a       	sub	r10,r9
8000819e:	fe 79 08 00 	mov	r9,-63488
800081a2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800081a6:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800081a8:	58 1a       	cp.w	r10,1
800081aa:	c0 a1       	brne	800081be <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800081ac:	49 09       	lddpc	r9,800081ec <INTC_register_interrupt+0x6c>
800081ae:	49 2a       	lddpc	r10,800081f4 <INTC_register_interrupt+0x74>
800081b0:	12 1a       	sub	r10,r9
800081b2:	bf aa       	sbr	r10,0x1e
800081b4:	fe 79 08 00 	mov	r9,-63488
800081b8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800081bc:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800081be:	58 2a       	cp.w	r10,2
800081c0:	c0 a1       	brne	800081d4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800081c2:	48 b9       	lddpc	r9,800081ec <INTC_register_interrupt+0x6c>
800081c4:	48 da       	lddpc	r10,800081f8 <INTC_register_interrupt+0x78>
800081c6:	12 1a       	sub	r10,r9
800081c8:	bf ba       	sbr	r10,0x1f
800081ca:	fe 79 08 00 	mov	r9,-63488
800081ce:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800081d2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800081d4:	48 69       	lddpc	r9,800081ec <INTC_register_interrupt+0x6c>
800081d6:	48 aa       	lddpc	r10,800081fc <INTC_register_interrupt+0x7c>
800081d8:	12 1a       	sub	r10,r9
800081da:	ea 1a c0 00 	orh	r10,0xc000
800081de:	fe 79 08 00 	mov	r9,-63488
800081e2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800081e6:	5e fc       	retal	r12
800081e8:	80 00       	ld.sh	r0,r0[0x0]
800081ea:	9e 38       	ld.sh	r8,pc[0x6]
800081ec:	80 00       	ld.sh	r0,r0[0x0]
800081ee:	96 00       	ld.sh	r0,r11[0x0]
800081f0:	80 00       	ld.sh	r0,r0[0x0]
800081f2:	97 04       	st.w	r11[0x0],r4
800081f4:	80 00       	ld.sh	r0,r0[0x0]
800081f6:	97 12       	st.w	r11[0x4],r2
800081f8:	80 00       	ld.sh	r0,r0[0x0]
800081fa:	97 20       	st.w	r11[0x8],r0
800081fc:	80 00       	ld.sh	r0,r0[0x0]
800081fe:	97 2e       	st.w	r11[0x8],lr

80008200 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80008200:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80008202:	49 18       	lddpc	r8,80008244 <INTC_init_interrupts+0x44>
80008204:	e3 b8 00 01 	mtsr	0x4,r8
80008208:	49 0e       	lddpc	lr,80008248 <INTC_init_interrupts+0x48>
8000820a:	30 07       	mov	r7,0
8000820c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000820e:	49 0c       	lddpc	r12,8000824c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008210:	49 05       	lddpc	r5,80008250 <INTC_init_interrupts+0x50>
80008212:	10 15       	sub	r5,r8
80008214:	fe 76 08 00 	mov	r6,-63488
80008218:	c1 08       	rjmp	80008238 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000821a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000821c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000821e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80008220:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80008224:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80008226:	10 3a       	cp.w	r10,r8
80008228:	fe 9b ff fc 	brhi	80008220 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000822c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80008230:	2f f7       	sub	r7,-1
80008232:	2f 8e       	sub	lr,-8
80008234:	59 47       	cp.w	r7,20
80008236:	c0 50       	breq	80008240 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80008238:	7c 08       	ld.w	r8,lr[0x0]
8000823a:	58 08       	cp.w	r8,0
8000823c:	ce f1       	brne	8000821a <INTC_init_interrupts+0x1a>
8000823e:	cf 7b       	rjmp	8000822c <INTC_init_interrupts+0x2c>
80008240:	d8 22       	popm	r4-r7,pc
80008242:	00 00       	add	r0,r0
80008244:	80 00       	ld.sh	r0,r0[0x0]
80008246:	96 00       	ld.sh	r0,r11[0x0]
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	9e 38       	ld.sh	r8,pc[0x6]
8000824c:	80 00       	ld.sh	r0,r0[0x0]
8000824e:	81 7c       	st.w	r0[0x1c],r12
80008250:	80 00       	ld.sh	r0,r0[0x0]
80008252:	97 04       	st.w	r11[0x0],r4

80008254 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80008254:	fe 78 08 00 	mov	r8,-63488
80008258:	e0 69 00 83 	mov	r9,131
8000825c:	f2 0c 01 0c 	sub	r12,r9,r12
80008260:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80008264:	f2 ca ff c0 	sub	r10,r9,-64
80008268:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000826c:	58 08       	cp.w	r8,0
8000826e:	c0 21       	brne	80008272 <_get_interrupt_handler+0x1e>
80008270:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
80008272:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80008276:	48 5a       	lddpc	r10,80008288 <_get_interrupt_handler+0x34>
80008278:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000827c:	f0 08 11 1f 	rsub	r8,r8,31
80008280:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008282:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80008286:	5e fc       	retal	r12
80008288:	80 00       	ld.sh	r0,r0[0x0]
8000828a:	9e 38       	ld.sh	r8,pc[0x6]

8000828c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000828c:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80008290:	fe c0 ec 90 	sub	r0,pc,-4976

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80008294:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80008298:	d5 53       	csrf	0x15
  cp      r0, r1
8000829a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000829c:	e0 61 05 20 	mov	r1,1312
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800082a0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800082a2:	c0 72       	brcc	800082b0 <idata_load_loop_end>
  cp      r0, r1
800082a4:	fe c2 e0 d4 	sub	r2,pc,-7980

800082a8 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800082a8:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
800082aa:	a1 24       	st.d	r0++,r4
  cp      r0, r1
800082ac:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
800082ae:	cf d3       	brcs	800082a8 <idata_load_loop>

800082b0 <idata_load_loop_end>:
  mov     r2, 0
800082b0:	e0 60 05 20 	mov	r0,1312
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800082b4:	e0 61 0f d0 	mov	r1,4048
  cp      r0, r1
  brlo    udata_clear_loop
800082b8:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800082ba:	c0 62       	brcc	800082c6 <udata_clear_loop_end>
800082bc:	30 02       	mov	r2,0
800082be:	30 03       	mov	r3,0

800082c0 <udata_clear_loop>:
800082c0:	a1 22       	st.d	r0++,r2
800082c2:	02 30       	cp.w	r0,r1
800082c4:	cf e3       	brcs	800082c0 <udata_clear_loop>

800082c6 <udata_clear_loop_end>:
800082c6:	fe cf fe 3a 	sub	pc,pc,-454
800082ca:	d7 03       	nop

800082cc <master_callback>:

	else if( arg == AUDIO_ADC_RELOAD_CB )
	{
		adc_reload_callback();;
	}
}
800082cc:	5e fc       	retal	r12

800082ce <fsTask>:
}

// fsHandle
portTASK_FUNCTION_PROTO( fsTask, p );
portTASK_FUNCTION( fsTask, p )
{
800082ce:	c0 08       	rjmp	800082ce <fsTask>

800082d0 <RT_ISR_gpio_qt_71_not_naked>:
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
{
800082d0:	d4 01       	pushm	lr
	// ENTER, LEFT, RIGHT
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER))
800082d2:	33 ac       	mov	r12,58
800082d4:	f0 1f 00 17 	mcall	80008330 <RT_ISR_gpio_qt_71_not_naked+0x60>
800082d8:	c0 b0       	breq	800082ee <RT_ISR_gpio_qt_71_not_naked+0x1e>
	{
		INTC_QT_FLAG._enter = true;
800082da:	49 78       	lddpc	r8,80008334 <RT_ISR_gpio_qt_71_not_naked+0x64>
800082dc:	11 89       	ld.ub	r9,r8[0x0]
800082de:	30 1a       	mov	r10,1
800082e0:	f3 da d0 e1 	bfins	r9,r10,0x7,0x1
800082e4:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER);
800082e6:	33 ac       	mov	r12,58
800082e8:	f0 1f 00 14 	mcall	80008338 <RT_ISR_gpio_qt_71_not_naked+0x68>
800082ec:	c1 c8       	rjmp	80008324 <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT))
800082ee:	33 9c       	mov	r12,57
800082f0:	f0 1f 00 10 	mcall	80008330 <RT_ISR_gpio_qt_71_not_naked+0x60>
800082f4:	c0 b0       	breq	8000830a <RT_ISR_gpio_qt_71_not_naked+0x3a>
	{
		INTC_QT_FLAG._left = true;
800082f6:	49 08       	lddpc	r8,80008334 <RT_ISR_gpio_qt_71_not_naked+0x64>
800082f8:	11 89       	ld.ub	r9,r8[0x0]
800082fa:	30 1a       	mov	r10,1
800082fc:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
80008300:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT);
80008302:	33 9c       	mov	r12,57
80008304:	f0 1f 00 0d 	mcall	80008338 <RT_ISR_gpio_qt_71_not_naked+0x68>
80008308:	c0 e8       	rjmp	80008324 <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT))
8000830a:	33 8c       	mov	r12,56
8000830c:	f0 1f 00 09 	mcall	80008330 <RT_ISR_gpio_qt_71_not_naked+0x60>
80008310:	c0 a0       	breq	80008324 <RT_ISR_gpio_qt_71_not_naked+0x54>
	{
		INTC_QT_FLAG._right = true;
80008312:	48 98       	lddpc	r8,80008334 <RT_ISR_gpio_qt_71_not_naked+0x64>
80008314:	11 89       	ld.ub	r9,r8[0x0]
80008316:	30 1a       	mov	r10,1
80008318:	f3 da d0 a1 	bfins	r9,r10,0x5,0x1
8000831c:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT);
8000831e:	33 8c       	mov	r12,56
80008320:	f0 1f 00 06 	mcall	80008338 <RT_ISR_gpio_qt_71_not_naked+0x68>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
80008324:	48 68       	lddpc	r8,8000833c <RT_ISR_gpio_qt_71_not_naked+0x6c>
80008326:	70 0c       	ld.w	r12,r8[0x0]
80008328:	f0 1f 00 06 	mcall	80008340 <RT_ISR_gpio_qt_71_not_naked+0x70>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
8000832c:	5f 1c       	srne	r12
8000832e:	d8 02       	popm	pc
80008330:	80 00       	ld.sh	r0,r0[0x0]
80008332:	81 4e       	st.w	r0[0x10],lr
80008334:	00 00       	add	r0,r0
80008336:	0d a8       	ld.ub	r8,r6[0x2]
80008338:	80 00       	ld.sh	r0,r0[0x0]
8000833a:	81 66       	st.w	r0[0x18],r6
8000833c:	00 00       	add	r0,r0
8000833e:	07 b0       	ld.ub	r0,r3[0x3]
80008340:	80 00       	ld.sh	r0,r0[0x0]
80008342:	7b 48       	ld.w	r8,sp[0x50]

80008344 <RT_ISR_gpio_qt_71>:

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
80008344:	eb cd 00 ff 	pushm	r0-r7
80008348:	e0 68 00 10 	mov	r8,16
8000834c:	ea 18 00 00 	orh	r8,0x0
80008350:	70 00       	ld.w	r0,r8[0x0]
80008352:	1a d0       	st.w	--sp,r0
80008354:	7a 90       	ld.w	r0,sp[0x24]
80008356:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000835a:	58 10       	cp.w	r0,1
8000835c:	e0 8b 00 08 	brhi	8000836c <LABEL_ISR_SKIP_SAVE_CONTEXT_629>
80008360:	e0 68 06 38 	mov	r8,1592
80008364:	ea 18 00 00 	orh	r8,0x0
80008368:	70 00       	ld.w	r0,r8[0x0]
8000836a:	81 0d       	st.w	r0[0x0],sp

8000836c <LABEL_ISR_SKIP_SAVE_CONTEXT_629>:
8000836c:	f0 1f 00 10 	mcall	800083ac <LABEL_ISR_SKIP_RESTORE_CONTEXT_629+0x14>
80008370:	7a 90       	ld.w	r0,sp[0x24]
80008372:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008376:	58 10       	cp.w	r0,1
80008378:	e0 8b 00 10 	brhi	80008398 <LABEL_ISR_SKIP_RESTORE_CONTEXT_629>
8000837c:	58 1c       	cp.w	r12,1
8000837e:	c0 71       	brne	8000838c <LABEL_ISR_RESTORE_CONTEXT_629>
80008380:	f0 1f 00 0c 	mcall	800083b0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_629+0x18>
80008384:	f0 1f 00 0c 	mcall	800083b4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_629+0x1c>
80008388:	f0 1f 00 0c 	mcall	800083b8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_629+0x20>

8000838c <LABEL_ISR_RESTORE_CONTEXT_629>:
8000838c:	e0 68 06 38 	mov	r8,1592
80008390:	ea 18 00 00 	orh	r8,0x0
80008394:	70 00       	ld.w	r0,r8[0x0]
80008396:	60 0d       	ld.w	sp,r0[0x0]

80008398 <LABEL_ISR_SKIP_RESTORE_CONTEXT_629>:
80008398:	1b 00       	ld.w	r0,sp++
8000839a:	e0 68 00 10 	mov	r8,16
8000839e:	ea 18 00 00 	orh	r8,0x0
800083a2:	91 00       	st.w	r8[0x0],r0
800083a4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800083a8:	d6 03       	rete
800083aa:	00 00       	add	r0,r0
800083ac:	80 00       	ld.sh	r0,r0[0x0]
800083ae:	82 d0       	ld.uh	r0,r1[0xa]
800083b0:	80 00       	ld.sh	r0,r0[0x0]
800083b2:	6f 34       	ld.w	r4,r7[0x4c]
800083b4:	80 00       	ld.sh	r0,r0[0x0]
800083b6:	75 fc       	ld.w	r12,r10[0x7c]
800083b8:	80 00       	ld.sh	r0,r0[0x0]
800083ba:	70 40       	ld.w	r0,r8[0x10]

800083bc <RT_ISR_gpio_qt_70_not_naked>:
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
{
800083bc:	d4 01       	pushm	lr
	// UP, DOWN
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP))
800083be:	33 6c       	mov	r12,54
800083c0:	f0 1f 00 10 	mcall	80008400 <RT_ISR_gpio_qt_70_not_naked+0x44>
800083c4:	c0 b0       	breq	800083da <RT_ISR_gpio_qt_70_not_naked+0x1e>
	{
		INTC_QT_FLAG._up = true;
800083c6:	49 08       	lddpc	r8,80008404 <RT_ISR_gpio_qt_70_not_naked+0x48>
800083c8:	11 89       	ld.ub	r9,r8[0x0]
800083ca:	30 1a       	mov	r10,1
800083cc:	f3 da d0 81 	bfins	r9,r10,0x4,0x1
800083d0:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP);
800083d2:	33 6c       	mov	r12,54
800083d4:	f0 1f 00 0d 	mcall	80008408 <RT_ISR_gpio_qt_70_not_naked+0x4c>
800083d8:	c0 e8       	rjmp	800083f4 <RT_ISR_gpio_qt_70_not_naked+0x38>

	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN))
800083da:	33 7c       	mov	r12,55
800083dc:	f0 1f 00 09 	mcall	80008400 <RT_ISR_gpio_qt_70_not_naked+0x44>
800083e0:	c0 a0       	breq	800083f4 <RT_ISR_gpio_qt_70_not_naked+0x38>
	{
		INTC_QT_FLAG._down = true;
800083e2:	48 98       	lddpc	r8,80008404 <RT_ISR_gpio_qt_70_not_naked+0x48>
800083e4:	11 89       	ld.ub	r9,r8[0x0]
800083e6:	30 1a       	mov	r10,1
800083e8:	f3 da d0 61 	bfins	r9,r10,0x3,0x1
800083ec:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN);
800083ee:	33 7c       	mov	r12,55
800083f0:	f0 1f 00 06 	mcall	80008408 <RT_ISR_gpio_qt_70_not_naked+0x4c>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
800083f4:	48 68       	lddpc	r8,8000840c <RT_ISR_gpio_qt_70_not_naked+0x50>
800083f6:	70 0c       	ld.w	r12,r8[0x0]
800083f8:	f0 1f 00 06 	mcall	80008410 <RT_ISR_gpio_qt_70_not_naked+0x54>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
800083fc:	5f 1c       	srne	r12
800083fe:	d8 02       	popm	pc
80008400:	80 00       	ld.sh	r0,r0[0x0]
80008402:	81 4e       	st.w	r0[0x10],lr
80008404:	00 00       	add	r0,r0
80008406:	0d a8       	ld.ub	r8,r6[0x2]
80008408:	80 00       	ld.sh	r0,r0[0x0]
8000840a:	81 66       	st.w	r0[0x18],r6
8000840c:	00 00       	add	r0,r0
8000840e:	07 b0       	ld.ub	r0,r3[0x3]
80008410:	80 00       	ld.sh	r0,r0[0x0]
80008412:	7b 48       	ld.w	r8,sp[0x50]

80008414 <RT_ISR_gpio_qt_70>:
		}
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
80008414:	eb cd 00 ff 	pushm	r0-r7
80008418:	e0 68 00 10 	mov	r8,16
8000841c:	ea 18 00 00 	orh	r8,0x0
80008420:	70 00       	ld.w	r0,r8[0x0]
80008422:	1a d0       	st.w	--sp,r0
80008424:	7a 90       	ld.w	r0,sp[0x24]
80008426:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000842a:	58 10       	cp.w	r0,1
8000842c:	e0 8b 00 08 	brhi	8000843c <LABEL_ISR_SKIP_SAVE_CONTEXT_608>
80008430:	e0 68 06 38 	mov	r8,1592
80008434:	ea 18 00 00 	orh	r8,0x0
80008438:	70 00       	ld.w	r0,r8[0x0]
8000843a:	81 0d       	st.w	r0[0x0],sp

8000843c <LABEL_ISR_SKIP_SAVE_CONTEXT_608>:
8000843c:	f0 1f 00 10 	mcall	8000847c <LABEL_ISR_SKIP_RESTORE_CONTEXT_608+0x14>
80008440:	7a 90       	ld.w	r0,sp[0x24]
80008442:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008446:	58 10       	cp.w	r0,1
80008448:	e0 8b 00 10 	brhi	80008468 <LABEL_ISR_SKIP_RESTORE_CONTEXT_608>
8000844c:	58 1c       	cp.w	r12,1
8000844e:	c0 71       	brne	8000845c <LABEL_ISR_RESTORE_CONTEXT_608>
80008450:	f0 1f 00 0c 	mcall	80008480 <LABEL_ISR_SKIP_RESTORE_CONTEXT_608+0x18>
80008454:	f0 1f 00 0c 	mcall	80008484 <LABEL_ISR_SKIP_RESTORE_CONTEXT_608+0x1c>
80008458:	f0 1f 00 0c 	mcall	80008488 <LABEL_ISR_SKIP_RESTORE_CONTEXT_608+0x20>

8000845c <LABEL_ISR_RESTORE_CONTEXT_608>:
8000845c:	e0 68 06 38 	mov	r8,1592
80008460:	ea 18 00 00 	orh	r8,0x0
80008464:	70 00       	ld.w	r0,r8[0x0]
80008466:	60 0d       	ld.w	sp,r0[0x0]

80008468 <LABEL_ISR_SKIP_RESTORE_CONTEXT_608>:
80008468:	1b 00       	ld.w	r0,sp++
8000846a:	e0 68 00 10 	mov	r8,16
8000846e:	ea 18 00 00 	orh	r8,0x0
80008472:	91 00       	st.w	r8[0x0],r0
80008474:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008478:	d6 03       	rete
8000847a:	00 00       	add	r0,r0
8000847c:	80 00       	ld.sh	r0,r0[0x0]
8000847e:	83 bc       	st.w	r1[0x2c],r12
80008480:	80 00       	ld.sh	r0,r0[0x0]
80008482:	6f 34       	ld.w	r4,r7[0x4c]
80008484:	80 00       	ld.sh	r0,r0[0x0]
80008486:	75 fc       	ld.w	r12,r10[0x7c]
80008488:	80 00       	ld.sh	r0,r0[0x0]
8000848a:	70 40       	ld.w	r0,r8[0x10]

8000848c <main>:
	print_dbg("DONE");
	nav_exit();										// Cerramos sistemas de archivos
}

int main (void)
{
8000848c:	d4 31       	pushm	r0-r7,lr
8000848e:	21 1d       	sub	sp,68
/*! \brief Static function definitions
 */
static void init_sys_clocks(void)
{
  // Switch to OSC0 to speed up the booting
  pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80008490:	30 3a       	mov	r10,3
80008492:	e0 6b 1b 00 	mov	r11,6912
80008496:	ea 1b 00 b7 	orh	r11,0xb7
8000849a:	fe 7c 0c 00 	mov	r12,-62464
8000849e:	f0 1f 01 23 	mcall	80008928 <main+0x49c>

  // Start oscillator1
  pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
800084a2:	e0 6b 44 00 	mov	r11,17408
800084a6:	ea 1b 00 ac 	orh	r11,0xac
800084aa:	fe 7c 0c 00 	mov	r12,-62464
800084ae:	f0 1f 01 20 	mcall	8000892c <main+0x4a0>
  pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
800084b2:	30 3b       	mov	r11,3
800084b4:	fe 7c 0c 00 	mov	r12,-62464
800084b8:	f0 1f 01 1e 	mcall	80008930 <main+0x4a4>

  // Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
  // We use OSC1 since we need a correct master clock for the SSC module to generate
  //
  pm_pll_setup(&AVR32_PM, 0,  // pll.
800084bc:	31 06       	mov	r6,16
800084be:	1a d6       	st.w	--sp,r6
800084c0:	30 18       	mov	r8,1
800084c2:	10 99       	mov	r9,r8
800084c4:	30 aa       	mov	r10,10
800084c6:	30 0b       	mov	r11,0
800084c8:	fe 7c 0c 00 	mov	r12,-62464
800084cc:	f0 1f 01 1a 	mcall	80008934 <main+0x4a8>
    1,   // osc.
    16); // lockcount.

  // Set PLL operating range and divider (fpll = fvco/2)
  // -> PLL0 output = 62.0928 MHz
  pm_pll_set_option(&AVR32_PM, 0, // pll.
800084d0:	30 08       	mov	r8,0
800084d2:	30 19       	mov	r9,1
800084d4:	12 9a       	mov	r10,r9
800084d6:	10 9b       	mov	r11,r8
800084d8:	fe 7c 0c 00 	mov	r12,-62464
800084dc:	f0 1f 01 17 	mcall	80008938 <main+0x4ac>
    1,  // pll_freq.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL0 and wait for the lock
  pm_pll_enable(&AVR32_PM, 0);
800084e0:	30 0b       	mov	r11,0
800084e2:	fe 7c 0c 00 	mov	r12,-62464
800084e6:	f0 1f 01 16 	mcall	8000893c <main+0x4b0>
  pm_wait_for_pll0_locked(&AVR32_PM);
800084ea:	fe 7c 0c 00 	mov	r12,-62464
800084ee:	f0 1f 01 15 	mcall	80008940 <main+0x4b4>
  // Set all peripheral clocks torun at master clock rate
  pm_cksel(&AVR32_PM,
800084f2:	30 07       	mov	r7,0
800084f4:	1a d7       	st.w	--sp,r7
800084f6:	1a d7       	st.w	--sp,r7
800084f8:	0e 98       	mov	r8,r7
800084fa:	0e 99       	mov	r9,r7
800084fc:	0e 9a       	mov	r10,r7
800084fe:	0e 9b       	mov	r11,r7
80008500:	fe 7c 0c 00 	mov	r12,-62464
80008504:	f0 1f 01 10 	mcall	80008944 <main+0x4b8>
    0,   // pbbsel.
    0,   // hsbdiv.
    0);  // hsbsel.

  // Set one waitstate for the flash
  flashc_set_wait_state(1);
80008508:	30 1c       	mov	r12,1
8000850a:	f0 1f 01 10 	mcall	80008948 <main+0x4bc>

  // Switch to PLL0 as the master clock
  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
8000850e:	30 2b       	mov	r11,2
80008510:	fe 7c 0c 00 	mov	r12,-62464
80008514:	f0 1f 01 0e 	mcall	8000894c <main+0x4c0>

  // Use 12MHz from OSC0 and generate 96 MHz
  pm_pll_setup(&AVR32_PM, 1,  // pll.
80008518:	1a d6       	st.w	--sp,r6
8000851a:	0e 98       	mov	r8,r7
8000851c:	30 19       	mov	r9,1
8000851e:	30 7a       	mov	r10,7
80008520:	12 9b       	mov	r11,r9
80008522:	fe 7c 0c 00 	mov	r12,-62464
80008526:	f0 1f 01 04 	mcall	80008934 <main+0x4a8>
    7,   // mul.
    1,   // div.
    0,   // osc.
    16); // lockcount.

  pm_pll_set_option(&AVR32_PM, 1, // pll.
8000852a:	0e 98       	mov	r8,r7
8000852c:	30 19       	mov	r9,1
8000852e:	12 9a       	mov	r10,r9
80008530:	12 9b       	mov	r11,r9
80008532:	fe 7c 0c 00 	mov	r12,-62464
80008536:	f0 1f 01 01 	mcall	80008938 <main+0x4ac>
    1,  // pll_freq: choose the range 80-180MHz.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL1 and wait forl lock
  pm_pll_enable(&AVR32_PM, 1);
8000853a:	30 1b       	mov	r11,1
8000853c:	fe 7c 0c 00 	mov	r12,-62464
80008540:	f0 1f 00 ff 	mcall	8000893c <main+0x4b0>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(&AVR32_PM);
80008544:	fe 7c 0c 00 	mov	r12,-62464
80008548:	f0 1f 01 02 	mcall	80008950 <main+0x4c4>
{
	/* Insert system clock initialization code here (sysclk_init()). */
	init_sys_clocks();

	/* Initialize RS232 debug text output. */
	init_dbg_rs232(PBA_HZ); /**/
8000854c:	e0 6c 76 00 	mov	r12,30208
80008550:	ea 1c 03 b3 	orh	r12,0x3b3
80008554:	f0 1f 01 00 	mcall	80008954 <main+0x4c8>
}

static void init_tft_bl(void)
{
	avr32_pwm_channel_t pwm_channel6;
	pwm_channel6.cdty = 0;
80008558:	50 57       	stdsp	sp[0x14],r7
	pwm_channel6.cprd = 100;
8000855a:	36 48       	mov	r8,100
8000855c:	50 68       	stdsp	sp[0x18],r8

	et024006_Init(PBA_HZ, PBA_HZ);
8000855e:	e0 6b 76 00 	mov	r11,30208
80008562:	ea 1b 03 b3 	orh	r11,0x3b3
80008566:	16 9c       	mov	r12,r11
80008568:	f0 1f 00 fc 	mcall	80008958 <main+0x4cc>

	pwm_opt_t opt;
	opt.diva = 0;
8000856c:	51 17       	stdsp	sp[0x44],r7
	opt.divb = 0;
8000856e:	51 07       	stdsp	sp[0x40],r7
	opt.prea = 0;
80008570:	51 37       	stdsp	sp[0x4c],r7
	opt.preb = 0;
80008572:	51 27       	stdsp	sp[0x48],r7

	pwm_init(&opt);
80008574:	fa cc ff c0 	sub	r12,sp,-64
80008578:	f0 1f 00 f9 	mcall	8000895c <main+0x4d0>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
8000857c:	40 48       	lddsp	r8,sp[0x10]
8000857e:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
80008582:	a9 b8       	sbr	r8,0x9
80008584:	30 19       	mov	r9,1
80008586:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
8000858a:	50 48       	stdsp	sp[0x10],r8

	pwm_channel_init(6, &pwm_channel6);
8000858c:	fa 06 00 0b 	add	r11,sp,r6
80008590:	30 6c       	mov	r12,6
80008592:	f0 1f 00 f4 	mcall	80008960 <main+0x4d4>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
80008596:	34 0c       	mov	r12,64
80008598:	f0 1f 00 f3 	mcall	80008964 <main+0x4d8>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
8000859c:	e0 68 ff ff 	mov	r8,65535
800085a0:	e0 69 00 f0 	mov	r9,240
800085a4:	e0 6a 01 40 	mov	r10,320
800085a8:	0e 9b       	mov	r11,r7
800085aa:	0e 9c       	mov	r12,r7
800085ac:	f0 1f 00 ef 	mcall	80008968 <main+0x4dc>
800085b0:	0c 0d       	add	sp,r6
	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
800085b2:	30 67       	mov	r7,6
800085b4:	c1 e8       	rjmp	800085f0 <main+0x164>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
800085b6:	2f f8       	sub	r8,-1
800085b8:	50 18       	stdsp	sp[0x4],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
800085ba:	50 48       	stdsp	sp[0x10],r8
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
800085bc:	1a 9b       	mov	r11,sp
800085be:	0e 9c       	mov	r12,r7
800085c0:	f0 1f 00 eb 	mcall	8000896c <main+0x4e0>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800085c4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800085c8:	e0 79 d4 c0 	mov	r9,120000
800085cc:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800085d0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800085d4:	14 38       	cp.w	r8,r10
800085d6:	e0 88 00 08 	brls	800085e6 <main+0x15a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800085da:	12 38       	cp.w	r8,r9
800085dc:	fe 98 ff fa 	brls	800085d0 <main+0x144>
800085e0:	12 3a       	cp.w	r10,r9
800085e2:	c0 73       	brcs	800085f0 <main+0x164>
800085e4:	cf 6b       	rjmp	800085d0 <main+0x144>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800085e6:	12 38       	cp.w	r8,r9
800085e8:	e0 8b 00 04 	brhi	800085f0 <main+0x164>
800085ec:	12 3a       	cp.w	r10,r9
800085ee:	cf 12       	brcc	800085d0 <main+0x144>
	pwm_channel_init(6, &pwm_channel6);
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
800085f0:	40 18       	lddsp	r8,sp[0x4]
800085f2:	40 29       	lddsp	r9,sp[0x8]
800085f4:	12 38       	cp.w	r8,r9
800085f6:	ce 03       	brcs	800085b6 <main+0x12a>
	/* TWI */
	const gpio_map_t TPA6130_TWI_GPIO_MAP =
	{
		{TPA6130_TWI_SCL_PIN, TPA6130_TWI_SCL_FUNCTION},
		{TPA6130_TWI_SDA_PIN, TPA6130_TWI_SDA_FUNCTION}
	};
800085f8:	fe f8 03 78 	ld.w	r8,pc[888]
800085fc:	fa cc ff e0 	sub	r12,sp,-32
80008600:	f0 ea 00 00 	ld.d	r10,r8[0]
80008604:	f8 eb 00 00 	st.d	r12[0],r10
80008608:	f0 e8 00 08 	ld.d	r8,r8[8]
8000860c:	f8 e9 00 08 	st.d	r12[8],r8
	const twi_options_t TPA6130_TWI_OPTIONS =
	{
		.pba_hz = PBA_HZ,
		.speed  = TPA6130_TWI_MASTER_SPEED,
		.chip   = TPA6130_TWI_ADDRESS
	};
80008610:	fe f8 03 64 	ld.w	r8,pc[868]
80008614:	fa c7 ff d0 	sub	r7,sp,-48
80008618:	f0 ea 00 00 	ld.d	r10,r8[0]
8000861c:	ee eb 00 00 	st.d	r7[0],r10
80008620:	70 28       	ld.w	r8,r8[0x8]
80008622:	8f 28       	st.w	r7[0x8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(TPA6130_TWI_GPIO_MAP,
80008624:	30 2b       	mov	r11,2
80008626:	f0 1f 00 d5 	mcall	80008978 <main+0x4ec>
	sizeof(TPA6130_TWI_GPIO_MAP) / sizeof(TPA6130_TWI_GPIO_MAP[0]));

	// Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
8000862a:	0e 9b       	mov	r11,r7
8000862c:	fe 7c 2c 00 	mov	r12,-54272
80008630:	f0 1f 00 d3 	mcall	8000897c <main+0x4f0>

	/* TWA */
	tpa6130_init();
80008634:	f0 1f 00 d3 	mcall	80008980 <main+0x4f4>

	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,
80008638:	e0 68 76 00 	mov	r8,30208
8000863c:	ea 18 03 b3 	orh	r8,0x3b3
80008640:	1a d8       	st.w	--sp,r8
80008642:	30 38       	mov	r8,3
80008644:	1a d8       	st.w	--sp,r8
80008646:	fe f8 03 3e 	ld.w	r8,pc[830]
8000864a:	30 09       	mov	r9,0
8000864c:	31 0a       	mov	r10,16
8000864e:	30 2b       	mov	r11,2
80008650:	e0 6c 2b 11 	mov	r12,11025
80008654:	f0 1f 00 cd 	mcall	80008988 <main+0x4fc>
						master_callback,
						AUDIO_DAC_OUT_OF_SAMPLE_CB
						| AUDIO_DAC_RELOAD_CB,
						PBA_HZ); /**/

	tpa6130_set_volume(0x35); // 2F
80008658:	33 5c       	mov	r12,53
8000865a:	f0 1f 00 cd 	mcall	8000898c <main+0x500>
	tpa6130_get_volume();
8000865e:	f0 1f 00 cd 	mcall	80008990 <main+0x504>

	init_tft_bl();

	init_twi_tpa();

	sd_mmc_resources_init();
80008662:	f0 1f 00 cd 	mcall	80008994 <main+0x508>
	check_sd_card();
80008666:	f0 1f 00 cd 	mcall	80008998 <main+0x50c>
	et024006_PrintString("****** INIT SD/MMC ******",(const unsigned char*)&FONT8x8,10,10,BLUE,-1);
8000866a:	3f f8       	mov	r8,-1
8000866c:	1a d8       	st.w	--sp,r8
8000866e:	31 f8       	mov	r8,31
80008670:	30 a9       	mov	r9,10
80008672:	12 9a       	mov	r10,r9
80008674:	fe fb 03 28 	ld.w	r11,pc[808]
80008678:	fe fc 03 28 	ld.w	r12,pc[808]
8000867c:	f0 1f 00 ca 	mcall	800089a4 <main+0x518>
}

static void init_qt_interrupt(void)
{
	/* INTC */
	Disable_global_interrupt();
80008680:	d3 03       	ssrf	0x10
	//INTC_init_interrupts();
	// QT
	INTC_register_interrupt(&RT_ISR_gpio_qt_70, 70, AVR32_INTC_INT0);
80008682:	30 0a       	mov	r10,0
80008684:	34 6b       	mov	r11,70
80008686:	fe fc 03 22 	ld.w	r12,pc[802]
8000868a:	f0 1f 00 c9 	mcall	800089ac <main+0x520>
	INTC_register_interrupt(&RT_ISR_gpio_qt_71, 71, AVR32_INTC_INT0);
8000868e:	30 0a       	mov	r10,0
80008690:	34 7b       	mov	r11,71
80008692:	fe fc 03 1e 	ld.w	r12,pc[798]
80008696:	f0 1f 00 c6 	mcall	800089ac <main+0x520>
	Enable_global_interrupt();
8000869a:	d5 03       	csrf	0x10

	/* GPIO */
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_UP,    GPIO_RISING_EDGE);
8000869c:	30 1b       	mov	r11,1
8000869e:	33 6c       	mov	r12,54
800086a0:	f0 1f 00 c5 	mcall	800089b4 <main+0x528>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_DOWN,  GPIO_RISING_EDGE);
800086a4:	30 1b       	mov	r11,1
800086a6:	33 7c       	mov	r12,55
800086a8:	f0 1f 00 c3 	mcall	800089b4 <main+0x528>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_LEFT,  GPIO_RISING_EDGE);
800086ac:	30 1b       	mov	r11,1
800086ae:	33 9c       	mov	r12,57
800086b0:	f0 1f 00 c1 	mcall	800089b4 <main+0x528>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_RIGHT, GPIO_RISING_EDGE);
800086b4:	30 1b       	mov	r11,1
800086b6:	33 8c       	mov	r12,56
800086b8:	f0 1f 00 bf 	mcall	800089b4 <main+0x528>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_ENTER, GPIO_RISING_EDGE);
800086bc:	30 1b       	mov	r11,1
800086be:	33 ac       	mov	r12,58
800086c0:	f0 1f 00 bd 	mcall	800089b4 <main+0x528>

	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
800086c4:	30 09       	mov	r9,0
800086c6:	fe f8 02 f2 	ld.w	r8,pc[754]
800086ca:	b0 89       	st.b	r8[0x0],r9
{
	/*Inicialiazamos los archivos de la SD manejada por SPI, para lograr que funcionara tuvo que habilitarla mediante el
	conf_access.h y conf_explorer.h, debido a que por default viene habilitada la memoria incluida en la EVK*/
	
#ifdef FREERTOS_USED
	if (ctrl_access_init())
800086cc:	f0 1f 00 bc 	mcall	800089bc <main+0x530>
800086d0:	2f dd       	sub	sp,-12
800086d2:	58 0c       	cp.w	r12,0
800086d4:	c0 50       	breq	800086de <main+0x252>
	{
		print_dbg("Access to SD granted.\r\n");
800086d6:	fe fc 02 ea 	ld.w	r12,pc[746]
800086da:	f0 1f 00 bb 	mcall	800089c4 <main+0x538>
	}
#endif

	first_ls = true;
800086de:	30 19       	mov	r9,1
800086e0:	fe f8 02 e8 	ld.w	r8,pc[744]
800086e4:	b0 89       	st.b	r8[0x0],r9
	if (nav_drive_get() >= nav_drive_nb() || first_ls)
800086e6:	f0 1f 00 ba 	mcall	800089cc <main+0x540>
800086ea:	18 97       	mov	r7,r12
800086ec:	f0 1f 00 b9 	mcall	800089d0 <main+0x544>
800086f0:	f8 07 18 00 	cp.b	r7,r12
800086f4:	c0 82       	brcc	80008704 <main+0x278>
800086f6:	fe f8 02 d2 	ld.w	r8,pc[722]
800086fa:	11 89       	ld.ub	r9,r8[0x0]
800086fc:	30 08       	mov	r8,0
800086fe:	f0 09 18 00 	cp.b	r9,r8
80008702:	c0 f0       	breq	80008720 <main+0x294>
	{
		first_ls = false;
80008704:	30 09       	mov	r9,0
80008706:	fe f8 02 c2 	ld.w	r8,pc[706]
8000870a:	b0 89       	st.b	r8[0x0],r9
		// Reset navigators .
		nav_reset();
8000870c:	f0 1f 00 b2 	mcall	800089d4 <main+0x548>
		// Use the last drive available as default.
		nav_drive_set(nav_drive_nb() - 1); // Or sd.drive_number
80008710:	f0 1f 00 b0 	mcall	800089d0 <main+0x544>
80008714:	20 1c       	sub	r12,1
80008716:	5c 5c       	castu.b	r12
80008718:	f0 1f 00 b0 	mcall	800089d8 <main+0x54c>
		//nav_drive_set(nav_drive_nb() - 1);
		// Mount it.
		nav_partition_mount();
8000871c:	f0 1f 00 b0 	mcall	800089dc <main+0x550>
	}
	nav_dir_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH);
80008720:	31 eb       	mov	r11,30
80008722:	fe fc 02 be 	ld.w	r12,pc[702]
80008726:	f0 1f 00 b0 	mcall	800089e4 <main+0x558>
	// Try to sort items by folders
	if (!nav_filelist_first(FS_DIR))
8000872a:	30 0c       	mov	r12,0
8000872c:	f0 1f 00 af 	mcall	800089e8 <main+0x55c>
80008730:	c0 41       	brne	80008738 <main+0x2ac>
	{
		// Sort items by files
		nav_filelist_first(FS_FILE);
80008732:	30 1c       	mov	r12,1
80008734:	f0 1f 00 ad 	mcall	800089e8 <main+0x55c>
	}
	nav_filelist_reset();
80008738:	f0 1f 00 ad 	mcall	800089ec <main+0x560>
	// Get data
	sd.lun				 = get_nb_lun();				// Read actual LUN
8000873c:	f0 1f 00 ad 	mcall	800089f0 <main+0x564>
80008740:	fe f7 02 b4 	ld.w	r7,pc[692]
80008744:	ae 8c       	st.b	r7[0x0],r12
	sd.drive_name		 = nav_drive_getname();			// Read drive assigned letter
80008746:	f0 1f 00 ad 	mcall	800089f8 <main+0x56c>
8000874a:	ae 9c       	st.b	r7[0x1],r12
	sd.devices_available = nav_drive_nb();				// Read available devices. Equal to LUN
8000874c:	f0 1f 00 a1 	mcall	800089d0 <main+0x544>
80008750:	ae ac       	st.b	r7[0x2],r12
	sd.drive_number		 = nav_drive_get();				// Returns nav_drive_nb()-1
80008752:	f0 1f 00 9f 	mcall	800089cc <main+0x540>
80008756:	ae bc       	st.b	r7[0x3],r12
	sd.number_of_files	 = nav_filelist_nb(FS_FILE);	// Get the number of available files
80008758:	30 1c       	mov	r12,1
8000875a:	f0 1f 00 a9 	mcall	800089fc <main+0x570>
8000875e:	5c 5c       	castu.b	r12
80008760:	ae cc       	st.b	r7[0x4],r12
	print_dbg_ulong(sd.number_of_files);
80008762:	f0 1f 00 a8 	mcall	80008a00 <main+0x574>
}

static void init_sdram(void)
{
	// Initialize the external SDRAM chip.
	sdramc_init(PBA_HZ);
80008766:	e0 6c 76 00 	mov	r12,30208
8000876a:	ea 1c 03 b3 	orh	r12,0x3b3
8000876e:	f0 1f 00 a6 	mcall	80008a04 <main+0x578>
	print_dbg("SDRAM initialized\r\n");
80008772:	fe fc 02 96 	ld.w	r12,pc[662]
80008776:	f0 1f 00 94 	mcall	800089c4 <main+0x538>
	init_fs();
	
	init_sdram();

	// Enable LED0 and LED1
	gpio_enable_gpio_pin(LED0_GPIO);
8000877a:	33 bc       	mov	r12,59
8000877c:	f0 1f 00 a4 	mcall	80008a0c <main+0x580>
	gpio_enable_gpio_pin(LED1_GPIO);
80008780:	33 cc       	mov	r12,60
80008782:	f0 1f 00 a3 	mcall	80008a0c <main+0x580>

	print_dbg(MSG_WELCOME);
80008786:	fe fc 02 8a 	ld.w	r12,pc[650]
8000878a:	f0 1f 00 8f 	mcall	800089c4 <main+0x538>
}

static void get_files(void)
{
	
	nav_filelist_reset();
8000878e:	f0 1f 00 98 	mcall	800089ec <main+0x560>
	nav_filelist_goto( 0 );
80008792:	30 0c       	mov	r12,0
80008794:	f0 1f 00 a0 	mcall	80008a14 <main+0x588>
	uint8_t files = 0;
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
80008798:	0f c9       	ld.ub	r9,r7[0x4]
8000879a:	30 08       	mov	r8,0
8000879c:	f0 09 18 00 	cp.b	r9,r8
800087a0:	c2 20       	breq	800087e4 <main+0x358>
800087a2:	0e 96       	mov	r6,r7
800087a4:	2f 86       	sub	r6,-8
800087a6:	30 07       	mov	r7,0
	{
		nav_filelist_set(sd.drive_number, FS_FIND_NEXT);
800087a8:	fe f5 02 4c 	ld.w	r5,pc[588]
800087ac:	30 14       	mov	r4,1
		nav_file_getname(sd.name_of_files[i], 30);
800087ae:	31 e3       	mov	r3,30
		print_dbg(sd.name_of_files[i]);
		print_dbg("\r\n");
800087b0:	fe f2 02 68 	ld.w	r2,pc[616]
	nav_filelist_goto( 0 );
	uint8_t files = 0;
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
	{
		nav_filelist_set(sd.drive_number, FS_FIND_NEXT);
800087b4:	08 9b       	mov	r11,r4
800087b6:	0b bc       	ld.ub	r12,r5[0x3]
800087b8:	f0 1f 00 99 	mcall	80008a1c <main+0x590>
		nav_file_getname(sd.name_of_files[i], 30);
800087bc:	06 9b       	mov	r11,r3
800087be:	6c 0c       	ld.w	r12,r6[0x0]
800087c0:	f0 1f 00 98 	mcall	80008a20 <main+0x594>
		print_dbg(sd.name_of_files[i]);
800087c4:	0d 0c       	ld.w	r12,r6++
800087c6:	f0 1f 00 80 	mcall	800089c4 <main+0x538>
		print_dbg("\r\n");
800087ca:	04 9c       	mov	r12,r2
800087cc:	f0 1f 00 7e 	mcall	800089c4 <main+0x538>
800087d0:	0e 99       	mov	r9,r7
800087d2:	2f f9       	sub	r9,-1
800087d4:	5c 59       	castu.b	r9
	
	nav_filelist_reset();
	nav_filelist_goto( 0 );
	uint8_t files = 0;
	//while (nav_filelist_set(sd.drive_number, FS_FIND_NEXT))
	for(size_t i = 0; i < sd.number_of_files; i++)
800087d6:	2f f7       	sub	r7,-1
800087d8:	0b c8       	ld.ub	r8,r5[0x4]
800087da:	10 37       	cp.w	r7,r8
800087dc:	ce c3       	brcs	800087b4 <main+0x328>
		print_dbg(sd.name_of_files[i]);
		print_dbg("\r\n");
		files++;
		//vTaskDelay(pdMS_TO_TICKS(100));
	}
	if (files == sd.number_of_files)
800087de:	f0 09 18 00 	cp.b	r9,r8
800087e2:	c0 51       	brne	800087ec <main+0x360>
	{
		print_dbg("Number of files coincide.\r\n");
800087e4:	fe fc 02 40 	ld.w	r12,pc[576]
800087e8:	f0 1f 00 77 	mcall	800089c4 <main+0x538>
	
	
	uint8_t audio_files_collected = 0;
	uint32_t size_in_bytes = 0;
	bool size_ready = false;
	nav_filelist_reset();
800087ec:	f0 1f 00 80 	mcall	800089ec <main+0x560>
	nav_filterlist_setfilter("h");
800087f0:	fe fc 02 38 	ld.w	r12,pc[568]
800087f4:	f0 1f 00 8e 	mcall	80008a2c <main+0x5a0>
	nav_filterlist_root();
800087f8:	f0 1f 00 8e 	mcall	80008a30 <main+0x5a4>
	nav_filterlist_goto( 0 );
800087fc:	30 0c       	mov	r12,0
800087fe:	f0 1f 00 8e 	mcall	80008a34 <main+0x5a8>
				char size_of_song[9] = "";
				current_char = file_getc();
				//char* size_of_song = "";
				print_dbg_char(current_char);
				while( current_char != ']' ){
					strncat(size_of_song, &current_char, 1);
80008802:	fa c0 ff d0 	sub	r0,sp,-48
80008806:	fa c3 ff bd 	sub	r3,sp,-67
8000880a:	00 96       	mov	r6,r0
					print_dbg_char('\t');
					
					current_char = file_getc();
					print_dbg_char(current_char);
					
					print_dbg("\r\n");
8000880c:	fe f2 02 0c 	ld.w	r2,pc[524]
80008810:	c7 28       	rjmp	800088f4 <main+0x468>
	nav_filterlist_setfilter("h");
	nav_filterlist_root();
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
	{
		print_dbg("\r\n Archivo Encontrado\r");
80008812:	fe fc 02 26 	ld.w	r12,pc[550]
80008816:	f0 1f 00 6c 	mcall	800089c4 <main+0x538>
		file_open(FOPEN_MODE_R);
8000881a:	30 9c       	mov	r12,9
8000881c:	f0 1f 00 88 	mcall	80008a3c <main+0x5b0>
		while (!file_eof())							//Hasta encontrar el fin del archivo
		{
			char current_char = file_getc();
			// Search for size fist, by looking for '[' and ']'
			print_dbg_char(current_char);
			if (current_char == '[')
80008820:	35 b1       	mov	r1,91
			{
				char size_of_song[9] = "";
				current_char = file_getc();
				//char* size_of_song = "";
				print_dbg_char(current_char);
				while( current_char != ']' ){
80008822:	35 d5       	mov	r5,93
80008824:	c6 08       	rjmp	800088e4 <main+0x458>
	{
		print_dbg("\r\n Archivo Encontrado\r");
		file_open(FOPEN_MODE_R);
		while (!file_eof())							//Hasta encontrar el fin del archivo
		{
			char current_char = file_getc();
80008826:	f0 1f 00 87 	mcall	80008a40 <main+0x5b4>
8000882a:	5c 5c       	castu.b	r12
8000882c:	fb 6c 00 43 	st.b	sp[67],r12
			// Search for size fist, by looking for '[' and ']'
			print_dbg_char(current_char);
80008830:	f0 1f 00 85 	mcall	80008a44 <main+0x5b8>
			if (current_char == '[')
80008834:	fb 38 00 43 	ld.ub	r8,sp[67]
80008838:	e2 08 18 00 	cp.b	r8,r1
8000883c:	c5 41       	brne	800088e4 <main+0x458>
			{
				char size_of_song[9] = "";
8000883e:	30 08       	mov	r8,0
80008840:	30 09       	mov	r9,0
80008842:	fa e9 00 30 	st.d	sp[48],r8
80008846:	30 08       	mov	r8,0
80008848:	fb 68 00 38 	st.b	sp[56],r8
				current_char = file_getc();
8000884c:	f0 1f 00 7d 	mcall	80008a40 <main+0x5b4>
80008850:	5c 5c       	castu.b	r12
80008852:	fb 6c 00 43 	st.b	sp[67],r12
				//char* size_of_song = "";
				print_dbg_char(current_char);
80008856:	f0 1f 00 7c 	mcall	80008a44 <main+0x5b8>
				while( current_char != ']' ){
8000885a:	fb 38 00 43 	ld.ub	r8,sp[67]
8000885e:	ea 08 18 00 	cp.b	r8,r5
80008862:	c1 d0       	breq	8000889c <main+0x410>
					strncat(size_of_song, &current_char, 1);
80008864:	30 17       	mov	r7,1
					print_dbg(size_of_song);
					print_dbg_char('\t');
80008866:	30 94       	mov	r4,9
				char size_of_song[9] = "";
				current_char = file_getc();
				//char* size_of_song = "";
				print_dbg_char(current_char);
				while( current_char != ']' ){
					strncat(size_of_song, &current_char, 1);
80008868:	0e 9a       	mov	r10,r7
8000886a:	06 9b       	mov	r11,r3
8000886c:	0c 9c       	mov	r12,r6
8000886e:	f0 1f 00 77 	mcall	80008a48 <main+0x5bc>
					print_dbg(size_of_song);
80008872:	0c 9c       	mov	r12,r6
80008874:	f0 1f 00 54 	mcall	800089c4 <main+0x538>
					print_dbg_char('\t');
80008878:	08 9c       	mov	r12,r4
8000887a:	f0 1f 00 73 	mcall	80008a44 <main+0x5b8>
					
					current_char = file_getc();
8000887e:	f0 1f 00 71 	mcall	80008a40 <main+0x5b4>
80008882:	5c 5c       	castu.b	r12
80008884:	fb 6c 00 43 	st.b	sp[67],r12
					print_dbg_char(current_char);
80008888:	f0 1f 00 6f 	mcall	80008a44 <main+0x5b8>
					
					print_dbg("\r\n");
8000888c:	04 9c       	mov	r12,r2
8000888e:	f0 1f 00 4e 	mcall	800089c4 <main+0x538>
			{
				char size_of_song[9] = "";
				current_char = file_getc();
				//char* size_of_song = "";
				print_dbg_char(current_char);
				while( current_char != ']' ){
80008892:	fb 38 00 43 	ld.ub	r8,sp[67]
80008896:	ea 08 18 00 	cp.b	r8,r5
8000889a:	ce 71       	brne	80008868 <main+0x3dc>
	//return x;
	
	unsigned long result = 0;
	const char *c = s;

	while ('0' <= *c && *c <= '9') {
8000889c:	fb 38 00 30 	ld.ub	r8,sp[48]
800088a0:	f0 ca 00 30 	sub	r10,r8,48
800088a4:	30 99       	mov	r9,9
800088a6:	f2 0a 18 00 	cp.b	r10,r9
800088aa:	e0 88 00 04 	brls	800088b2 <main+0x426>
800088ae:	30 07       	mov	r7,0
800088b0:	c1 18       	rjmp	800088d2 <main+0x446>
800088b2:	00 99       	mov	r9,r0
800088b4:	30 07       	mov	r7,0
800088b6:	30 9b       	mov	r11,9
		result = result * 10 + (*(c++) - '0');
800088b8:	ee 07 00 27 	add	r7,r7,r7<<0x2
800088bc:	f0 07 00 17 	add	r7,r8,r7<<0x1
800088c0:	23 07       	sub	r7,48
800088c2:	2f f9       	sub	r9,-1
	//return x;
	
	unsigned long result = 0;
	const char *c = s;

	while ('0' <= *c && *c <= '9') {
800088c4:	13 88       	ld.ub	r8,r9[0x0]
800088c6:	f0 ca 00 30 	sub	r10,r8,48
800088ca:	f6 0a 18 00 	cp.b	r10,r11
800088ce:	fe 98 ff f5 	brls	800088b8 <main+0x42c>
					
					print_dbg("\r\n");
				}
				//sscanf(size_of_song, "%lu", &size_in_bytes);
				size_in_bytes = a2ul(size_of_song);
				print_dbg("HERE\r\n");
800088d2:	4d fc       	lddpc	r12,80008a4c <main+0x5c0>
800088d4:	f0 1f 00 3c 	mcall	800089c4 <main+0x538>
				print_dbg(size_of_song);
800088d8:	0c 9c       	mov	r12,r6
800088da:	f0 1f 00 3b 	mcall	800089c4 <main+0x538>
				print_dbg_ulong(size_in_bytes);
800088de:	0e 9c       	mov	r12,r7
800088e0:	f0 1f 00 48 	mcall	80008a00 <main+0x574>
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
	{
		print_dbg("\r\n Archivo Encontrado\r");
		file_open(FOPEN_MODE_R);
		while (!file_eof())							//Hasta encontrar el fin del archivo
800088e4:	f0 1f 00 5b 	mcall	80008a50 <main+0x5c4>
800088e8:	c9 f0       	breq	80008826 <main+0x39a>
			
			//print_dbg_char(file_getc());				// Display next char from file.
			//vTaskDelay(pdMS_TO_TICKS(200));
		}
		// Close the file.
		file_close();
800088ea:	f0 1f 00 5b 	mcall	80008a54 <main+0x5c8>
		print_dbg("\r\n");
800088ee:	4c bc       	lddpc	r12,80008a18 <main+0x58c>
800088f0:	f0 1f 00 35 	mcall	800089c4 <main+0x538>
	bool size_ready = false;
	nav_filelist_reset();
	nav_filterlist_setfilter("h");
	nav_filterlist_root();
	nav_filterlist_goto( 0 );
	while (nav_filelist_set( sd.drive_number, FS_FIND_NEXT ))					//nav_filterlist_next()
800088f4:	30 1b       	mov	r11,1
800088f6:	4c 08       	lddpc	r8,800089f4 <main+0x568>
800088f8:	11 bc       	ld.ub	r12,r8[0x3]
800088fa:	f0 1f 00 49 	mcall	80008a1c <main+0x590>
800088fe:	c8 a1       	brne	80008812 <main+0x386>
		
		
	}

	
	print_dbg("DONE");
80008900:	4d 6c       	lddpc	r12,80008a58 <main+0x5cc>
80008902:	f0 1f 00 31 	mcall	800089c4 <main+0x538>
	nav_exit();										// Cerramos sistemas de archivos
80008906:	f0 1f 00 56 	mcall	80008a5c <main+0x5d0>

	//uint16_t pass = 25;
	//xTaskCreate(myTask1, "taks1", 256, (void *)pass, mainLED_TASK_PRIORITY, &myTask1Handle);
	//xTaskCreate(qtButtonTask,  "tQT",        256,  (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
	//xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
	xTaskCreate(fsTask,		   "tFS",		 1024,  (void *) 0, mainLED_TASK_PRIORITY, &fsHandle);
8000890a:	4d 68       	lddpc	r8,80008a60 <main+0x5d4>
8000890c:	1a d8       	st.w	--sp,r8
8000890e:	30 18       	mov	r8,1
80008910:	30 09       	mov	r9,0
80008912:	e0 6a 04 00 	mov	r10,1024
80008916:	4d 4b       	lddpc	r11,80008a64 <main+0x5d8>
80008918:	4d 4c       	lddpc	r12,80008a68 <main+0x5dc>
8000891a:	f0 1f 00 55 	mcall	80008a6c <main+0x5e0>
	//xTaskCreate(etTask,		   "tET",		 512,  (void *) 0, mainLED_TASK_PRIORITY, &etHandle);
	//xTaskCreate(sdramTask,     "tSDRAM",	 256,  (void *) 0, mainLED_TASK_PRIORITY, &sdramHandle);
	
	vTaskStartScheduler();
8000891e:	f0 1f 00 55 	mcall	80008a70 <main+0x5e4>
80008922:	2f fd       	sub	sp,-4
80008924:	c0 08       	rjmp	80008924 <main+0x498>
80008926:	00 00       	add	r0,r0
80008928:	80 00       	ld.sh	r0,r0[0x0]
8000892a:	6c 34       	ld.w	r4,r6[0xc]
8000892c:	80 00       	ld.sh	r0,r0[0x0]
8000892e:	6b 10       	ld.w	r0,r5[0x44]
80008930:	80 00       	ld.sh	r0,r0[0x0]
80008932:	6b 68       	ld.w	r8,r5[0x58]
80008934:	80 00       	ld.sh	r0,r0[0x0]
80008936:	6b ca       	ld.w	r10,r5[0x70]
80008938:	80 00       	ld.sh	r0,r0[0x0]
8000893a:	6b ec       	ld.w	r12,r5[0x78]
8000893c:	80 00       	ld.sh	r0,r0[0x0]
8000893e:	6c 06       	ld.w	r6,r6[0x0]
80008940:	80 00       	ld.sh	r0,r0[0x0]
80008942:	6c 14       	ld.w	r4,r6[0x4]
80008944:	80 00       	ld.sh	r0,r0[0x0]
80008946:	6b 84       	ld.w	r4,r5[0x60]
80008948:	80 00       	ld.sh	r0,r0[0x0]
8000894a:	6a 78       	ld.w	r8,r5[0x1c]
8000894c:	80 00       	ld.sh	r0,r0[0x0]
8000894e:	6c 28       	ld.w	r8,r6[0x8]
80008950:	80 00       	ld.sh	r0,r0[0x0]
80008952:	6c 1e       	ld.w	lr,r6[0x4]
80008954:	80 00       	ld.sh	r0,r0[0x0]
80008956:	6a 64       	ld.w	r4,r5[0x18]
80008958:	80 00       	ld.sh	r0,r0[0x0]
8000895a:	23 d8       	sub	r8,61
8000895c:	80 00       	ld.sh	r0,r0[0x0]
8000895e:	38 94       	mov	r4,-119
80008960:	80 00       	ld.sh	r0,r0[0x0]
80008962:	38 24       	mov	r4,-126
80008964:	80 00       	ld.sh	r0,r0[0x0]
80008966:	38 5a       	mov	r10,-123
80008968:	80 00       	ld.sh	r0,r0[0x0]
8000896a:	23 28       	sub	r8,50
8000896c:	80 00       	ld.sh	r0,r0[0x0]
8000896e:	38 6c       	mov	r12,-122
80008970:	80 00       	ld.sh	r0,r0[0x0]
80008972:	9e d8       	ld.uh	r8,pc[0xa]
80008974:	80 00       	ld.sh	r0,r0[0x0]
80008976:	9e e8       	ld.uh	r8,pc[0xc]
80008978:	80 00       	ld.sh	r0,r0[0x0]
8000897a:	80 60       	ld.sh	r0,r0[0xc]
8000897c:	80 00       	ld.sh	r0,r0[0x0]
8000897e:	68 e4       	ld.w	r4,r4[0x38]
80008980:	80 00       	ld.sh	r0,r0[0x0]
80008982:	61 3c       	ld.w	r12,r0[0x4c]
80008984:	80 00       	ld.sh	r0,r0[0x0]
80008986:	82 cc       	ld.uh	r12,r1[0x8]
80008988:	80 00       	ld.sh	r0,r0[0x0]
8000898a:	62 24       	ld.w	r4,r1[0x8]
8000898c:	80 00       	ld.sh	r0,r0[0x0]
8000898e:	60 28       	ld.w	r8,r0[0x8]
80008990:	80 00       	ld.sh	r0,r0[0x0]
80008992:	60 a4       	ld.w	r4,r0[0x28]
80008994:	80 00       	ld.sh	r0,r0[0x0]
80008996:	5e f8       	retal	r8
80008998:	80 00       	ld.sh	r0,r0[0x0]
8000899a:	5e 90       	retgt	r0
8000899c:	80 00       	ld.sh	r0,r0[0x0]
8000899e:	98 00       	ld.sh	r0,r12[0x0]
800089a0:	80 00       	ld.sh	r0,r0[0x0]
800089a2:	9e f4       	ld.uh	r4,pc[0xe]
800089a4:	80 00       	ld.sh	r0,r0[0x0]
800089a6:	20 ac       	sub	r12,10
800089a8:	80 00       	ld.sh	r0,r0[0x0]
800089aa:	84 14       	ld.sh	r4,r2[0x2]
800089ac:	80 00       	ld.sh	r0,r0[0x0]
800089ae:	81 80       	st.w	r0[0x20],r0
800089b0:	80 00       	ld.sh	r0,r0[0x0]
800089b2:	83 44       	st.w	r1[0x10],r4
800089b4:	80 00       	ld.sh	r0,r0[0x0]
800089b6:	81 08       	st.w	r0[0x0],r8
800089b8:	00 00       	add	r0,r0
800089ba:	0d a8       	ld.ub	r8,r6[0x2]
800089bc:	80 00       	ld.sh	r0,r0[0x0]
800089be:	5e 50       	retlt	r0
800089c0:	80 00       	ld.sh	r0,r0[0x0]
800089c2:	9f 10       	st.w	pc[0x4],r0
800089c4:	80 00       	ld.sh	r0,r0[0x0]
800089c6:	6a 10       	ld.w	r0,r5[0x4]
800089c8:	00 00       	add	r0,r0
800089ca:	07 ac       	ld.ub	r12,r3[0x2]
800089cc:	80 00       	ld.sh	r0,r0[0x0]
800089ce:	53 bc       	stdsp	sp[0xec],r12
800089d0:	80 00       	ld.sh	r0,r0[0x0]
800089d2:	5a 18       	cp.w	r8,-31
800089d4:	80 00       	ld.sh	r0,r0[0x0]
800089d6:	5a 94       	cp.w	r4,-23
800089d8:	80 00       	ld.sh	r0,r0[0x0]
800089da:	59 c4       	cp.w	r4,28
800089dc:	80 00       	ld.sh	r0,r0[0x0]
800089de:	59 7c       	cp.w	r12,23
800089e0:	00 00       	add	r0,r0
800089e2:	07 b4       	ld.ub	r4,r3[0x3]
800089e4:	80 00       	ld.sh	r0,r0[0x0]
800089e6:	57 3c       	stdsp	sp[0x1cc],r12
800089e8:	80 00       	ld.sh	r0,r0[0x0]
800089ea:	58 40       	cp.w	r0,4
800089ec:	80 00       	ld.sh	r0,r0[0x0]
800089ee:	56 84       	stdsp	sp[0x1a0],r4
800089f0:	80 00       	ld.sh	r0,r0[0x0]
800089f2:	5c a0       	swap.h	r0
800089f4:	00 00       	add	r0,r0
800089f6:	07 d4       	ld.ub	r4,r3[0x5]
800089f8:	80 00       	ld.sh	r0,r0[0x0]
800089fa:	53 c8       	stdsp	sp[0xf0],r8
800089fc:	80 00       	ld.sh	r0,r0[0x0]
800089fe:	58 80       	cp.w	r0,8
80008a00:	80 00       	ld.sh	r0,r0[0x0]
80008a02:	69 fc       	ld.w	r12,r4[0x7c]
80008a04:	80 00       	ld.sh	r0,r0[0x0]
80008a06:	35 9c       	mov	r12,89
80008a08:	80 00       	ld.sh	r0,r0[0x0]
80008a0a:	9f 28       	st.w	pc[0x8],r8
80008a0c:	80 00       	ld.sh	r0,r0[0x0]
80008a0e:	80 90       	ld.uh	r0,r0[0x2]
80008a10:	80 00       	ld.sh	r0,r0[0x0]
80008a12:	9f 3c       	st.w	pc[0xc],r12
80008a14:	80 00       	ld.sh	r0,r0[0x0]
80008a16:	58 f0       	cp.w	r0,15
80008a18:	80 00       	ld.sh	r0,r0[0x0]
80008a1a:	9f b4       	st.w	pc[0x2c],r4
80008a1c:	80 00       	ld.sh	r0,r0[0x0]
80008a1e:	55 1c       	stdsp	sp[0x144],r12
80008a20:	80 00       	ld.sh	r0,r0[0x0]
80008a22:	55 0c       	stdsp	sp[0x140],r12
80008a24:	80 00       	ld.sh	r0,r0[0x0]
80008a26:	9f 78       	st.w	pc[0x1c],r8
80008a28:	80 00       	ld.sh	r0,r0[0x0]
80008a2a:	9f 94       	st.w	pc[0x24],r4
80008a2c:	80 00       	ld.sh	r0,r0[0x0]
80008a2e:	5c 8c       	casts.h	r12
80008a30:	80 00       	ld.sh	r0,r0[0x0]
80008a32:	5b 00       	cp.w	r0,-16
80008a34:	80 00       	ld.sh	r0,r0[0x0]
80008a36:	5b fc       	cp.w	r12,-1
80008a38:	80 00       	ld.sh	r0,r0[0x0]
80008a3a:	9f 98       	st.w	pc[0x24],r8
80008a3c:	80 00       	ld.sh	r0,r0[0x0]
80008a3e:	53 1c       	stdsp	sp[0xc4],r12
80008a40:	80 00       	ld.sh	r0,r0[0x0]
80008a42:	52 b0       	stdsp	sp[0xac],r0
80008a44:	80 00       	ld.sh	r0,r0[0x0]
80008a46:	69 94       	ld.w	r4,r4[0x64]
80008a48:	80 00       	ld.sh	r0,r0[0x0]
80008a4a:	92 98       	ld.uh	r8,r9[0x2]
80008a4c:	80 00       	ld.sh	r0,r0[0x0]
80008a4e:	9f b0       	st.w	pc[0x2c],r0
80008a50:	80 00       	ld.sh	r0,r0[0x0]
80008a52:	52 50       	stdsp	sp[0x94],r0
80008a54:	80 00       	ld.sh	r0,r0[0x0]
80008a56:	52 74       	stdsp	sp[0x9c],r4
80008a58:	80 00       	ld.sh	r0,r0[0x0]
80008a5a:	9f b8       	st.w	pc[0x2c],r8
80008a5c:	80 00       	ld.sh	r0,r0[0x0]
80008a5e:	5a 6c       	cp.w	r12,-26
80008a60:	00 00       	add	r0,r0
80008a62:	07 a8       	ld.ub	r8,r3[0x2]
80008a64:	80 00       	ld.sh	r0,r0[0x0]
80008a66:	9f c0       	st.w	pc[0x30],r0
80008a68:	80 00       	ld.sh	r0,r0[0x0]
80008a6a:	82 ce       	ld.uh	lr,r1[0x8]
80008a6c:	80 00       	ld.sh	r0,r0[0x0]
80008a6e:	7d 0c       	ld.w	r12,lr[0x40]
80008a70:	80 00       	ld.sh	r0,r0[0x0]
80008a72:	7e f8       	ld.w	r8,pc[0x3c]

80008a74 <__avr32_udiv64>:
80008a74:	d4 31       	pushm	r0-r7,lr
80008a76:	1a 97       	mov	r7,sp
80008a78:	20 3d       	sub	sp,12
80008a7a:	10 9c       	mov	r12,r8
80008a7c:	12 9e       	mov	lr,r9
80008a7e:	14 93       	mov	r3,r10
80008a80:	58 09       	cp.w	r9,0
80008a82:	e0 81 00 bd 	brne	80008bfc <__avr32_udiv64+0x188>
80008a86:	16 38       	cp.w	r8,r11
80008a88:	e0 88 00 40 	brls	80008b08 <__avr32_udiv64+0x94>
80008a8c:	f0 08 12 00 	clz	r8,r8
80008a90:	c0 d0       	breq	80008aaa <__avr32_udiv64+0x36>
80008a92:	f6 08 09 4b 	lsl	r11,r11,r8
80008a96:	f0 09 11 20 	rsub	r9,r8,32
80008a9a:	f8 08 09 4c 	lsl	r12,r12,r8
80008a9e:	f4 09 0a 49 	lsr	r9,r10,r9
80008aa2:	f4 08 09 43 	lsl	r3,r10,r8
80008aa6:	f3 eb 10 0b 	or	r11,r9,r11
80008aaa:	f8 0e 16 10 	lsr	lr,r12,0x10
80008aae:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008ab2:	f6 0e 0d 00 	divu	r0,r11,lr
80008ab6:	e6 0b 16 10 	lsr	r11,r3,0x10
80008aba:	00 99       	mov	r9,r0
80008abc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80008ac0:	e0 0a 02 48 	mul	r8,r0,r10
80008ac4:	10 3b       	cp.w	r11,r8
80008ac6:	c0 a2       	brcc	80008ada <__avr32_udiv64+0x66>
80008ac8:	20 19       	sub	r9,1
80008aca:	18 0b       	add	r11,r12
80008acc:	18 3b       	cp.w	r11,r12
80008ace:	c0 63       	brcs	80008ada <__avr32_udiv64+0x66>
80008ad0:	10 3b       	cp.w	r11,r8
80008ad2:	f7 b9 03 01 	sublo	r9,1
80008ad6:	f7 dc e3 0b 	addcs	r11,r11,r12
80008ada:	f6 08 01 01 	sub	r1,r11,r8
80008ade:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80008ae2:	e2 0e 0d 00 	divu	r0,r1,lr
80008ae6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80008aea:	00 98       	mov	r8,r0
80008aec:	e0 0a 02 4a 	mul	r10,r0,r10
80008af0:	14 33       	cp.w	r3,r10
80008af2:	c0 82       	brcc	80008b02 <__avr32_udiv64+0x8e>
80008af4:	20 18       	sub	r8,1
80008af6:	18 03       	add	r3,r12
80008af8:	18 33       	cp.w	r3,r12
80008afa:	c0 43       	brcs	80008b02 <__avr32_udiv64+0x8e>
80008afc:	14 33       	cp.w	r3,r10
80008afe:	f7 b8 03 01 	sublo	r8,1
80008b02:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80008b06:	cd f8       	rjmp	80008cc4 <__avr32_udiv64+0x250>
80008b08:	58 08       	cp.w	r8,0
80008b0a:	c0 51       	brne	80008b14 <__avr32_udiv64+0xa0>
80008b0c:	30 19       	mov	r9,1
80008b0e:	f2 08 0d 08 	divu	r8,r9,r8
80008b12:	10 9c       	mov	r12,r8
80008b14:	f8 06 12 00 	clz	r6,r12
80008b18:	c0 41       	brne	80008b20 <__avr32_udiv64+0xac>
80008b1a:	18 1b       	sub	r11,r12
80008b1c:	30 19       	mov	r9,1
80008b1e:	c4 08       	rjmp	80008b9e <__avr32_udiv64+0x12a>
80008b20:	ec 01 11 20 	rsub	r1,r6,32
80008b24:	f4 01 0a 49 	lsr	r9,r10,r1
80008b28:	f8 06 09 4c 	lsl	r12,r12,r6
80008b2c:	f6 06 09 48 	lsl	r8,r11,r6
80008b30:	f6 01 0a 41 	lsr	r1,r11,r1
80008b34:	f3 e8 10 08 	or	r8,r9,r8
80008b38:	f8 03 16 10 	lsr	r3,r12,0x10
80008b3c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80008b40:	e2 03 0d 00 	divu	r0,r1,r3
80008b44:	f0 0b 16 10 	lsr	r11,r8,0x10
80008b48:	00 9e       	mov	lr,r0
80008b4a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80008b4e:	e0 05 02 49 	mul	r9,r0,r5
80008b52:	12 3b       	cp.w	r11,r9
80008b54:	c0 a2       	brcc	80008b68 <__avr32_udiv64+0xf4>
80008b56:	20 1e       	sub	lr,1
80008b58:	18 0b       	add	r11,r12
80008b5a:	18 3b       	cp.w	r11,r12
80008b5c:	c0 63       	brcs	80008b68 <__avr32_udiv64+0xf4>
80008b5e:	12 3b       	cp.w	r11,r9
80008b60:	f7 be 03 01 	sublo	lr,1
80008b64:	f7 dc e3 0b 	addcs	r11,r11,r12
80008b68:	12 1b       	sub	r11,r9
80008b6a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80008b6e:	f6 03 0d 02 	divu	r2,r11,r3
80008b72:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80008b76:	04 99       	mov	r9,r2
80008b78:	e4 05 02 4b 	mul	r11,r2,r5
80008b7c:	16 38       	cp.w	r8,r11
80008b7e:	c0 a2       	brcc	80008b92 <__avr32_udiv64+0x11e>
80008b80:	20 19       	sub	r9,1
80008b82:	18 08       	add	r8,r12
80008b84:	18 38       	cp.w	r8,r12
80008b86:	c0 63       	brcs	80008b92 <__avr32_udiv64+0x11e>
80008b88:	16 38       	cp.w	r8,r11
80008b8a:	f7 b9 03 01 	sublo	r9,1
80008b8e:	f1 dc e3 08 	addcs	r8,r8,r12
80008b92:	f4 06 09 43 	lsl	r3,r10,r6
80008b96:	f0 0b 01 0b 	sub	r11,r8,r11
80008b9a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80008b9e:	f8 06 16 10 	lsr	r6,r12,0x10
80008ba2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80008ba6:	f6 06 0d 00 	divu	r0,r11,r6
80008baa:	e6 0b 16 10 	lsr	r11,r3,0x10
80008bae:	00 9a       	mov	r10,r0
80008bb0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80008bb4:	e0 0e 02 48 	mul	r8,r0,lr
80008bb8:	10 3b       	cp.w	r11,r8
80008bba:	c0 a2       	brcc	80008bce <__avr32_udiv64+0x15a>
80008bbc:	20 1a       	sub	r10,1
80008bbe:	18 0b       	add	r11,r12
80008bc0:	18 3b       	cp.w	r11,r12
80008bc2:	c0 63       	brcs	80008bce <__avr32_udiv64+0x15a>
80008bc4:	10 3b       	cp.w	r11,r8
80008bc6:	f7 ba 03 01 	sublo	r10,1
80008bca:	f7 dc e3 0b 	addcs	r11,r11,r12
80008bce:	f6 08 01 01 	sub	r1,r11,r8
80008bd2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80008bd6:	e2 06 0d 00 	divu	r0,r1,r6
80008bda:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80008bde:	00 98       	mov	r8,r0
80008be0:	e0 0e 02 4b 	mul	r11,r0,lr
80008be4:	16 33       	cp.w	r3,r11
80008be6:	c0 82       	brcc	80008bf6 <__avr32_udiv64+0x182>
80008be8:	20 18       	sub	r8,1
80008bea:	18 03       	add	r3,r12
80008bec:	18 33       	cp.w	r3,r12
80008bee:	c0 43       	brcs	80008bf6 <__avr32_udiv64+0x182>
80008bf0:	16 33       	cp.w	r3,r11
80008bf2:	f7 b8 03 01 	sublo	r8,1
80008bf6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80008bfa:	c6 98       	rjmp	80008ccc <__avr32_udiv64+0x258>
80008bfc:	16 39       	cp.w	r9,r11
80008bfe:	e0 8b 00 65 	brhi	80008cc8 <__avr32_udiv64+0x254>
80008c02:	f2 09 12 00 	clz	r9,r9
80008c06:	c0 b1       	brne	80008c1c <__avr32_udiv64+0x1a8>
80008c08:	10 3a       	cp.w	r10,r8
80008c0a:	5f 2a       	srhs	r10
80008c0c:	1c 3b       	cp.w	r11,lr
80008c0e:	5f b8       	srhi	r8
80008c10:	10 4a       	or	r10,r8
80008c12:	f2 0a 18 00 	cp.b	r10,r9
80008c16:	c5 90       	breq	80008cc8 <__avr32_udiv64+0x254>
80008c18:	30 18       	mov	r8,1
80008c1a:	c5 98       	rjmp	80008ccc <__avr32_udiv64+0x258>
80008c1c:	f0 09 09 46 	lsl	r6,r8,r9
80008c20:	f2 03 11 20 	rsub	r3,r9,32
80008c24:	fc 09 09 4e 	lsl	lr,lr,r9
80008c28:	f0 03 0a 48 	lsr	r8,r8,r3
80008c2c:	f6 09 09 4c 	lsl	r12,r11,r9
80008c30:	f4 03 0a 42 	lsr	r2,r10,r3
80008c34:	ef 46 ff f4 	st.w	r7[-12],r6
80008c38:	f6 03 0a 43 	lsr	r3,r11,r3
80008c3c:	18 42       	or	r2,r12
80008c3e:	f1 ee 10 0c 	or	r12,r8,lr
80008c42:	f8 01 16 10 	lsr	r1,r12,0x10
80008c46:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80008c4a:	e6 01 0d 04 	divu	r4,r3,r1
80008c4e:	e4 03 16 10 	lsr	r3,r2,0x10
80008c52:	08 9e       	mov	lr,r4
80008c54:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80008c58:	e8 06 02 48 	mul	r8,r4,r6
80008c5c:	10 33       	cp.w	r3,r8
80008c5e:	c0 a2       	brcc	80008c72 <__avr32_udiv64+0x1fe>
80008c60:	20 1e       	sub	lr,1
80008c62:	18 03       	add	r3,r12
80008c64:	18 33       	cp.w	r3,r12
80008c66:	c0 63       	brcs	80008c72 <__avr32_udiv64+0x1fe>
80008c68:	10 33       	cp.w	r3,r8
80008c6a:	f7 be 03 01 	sublo	lr,1
80008c6e:	e7 dc e3 03 	addcs	r3,r3,r12
80008c72:	10 13       	sub	r3,r8
80008c74:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80008c78:	e6 01 0d 00 	divu	r0,r3,r1
80008c7c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80008c80:	00 98       	mov	r8,r0
80008c82:	e0 06 02 46 	mul	r6,r0,r6
80008c86:	0c 3b       	cp.w	r11,r6
80008c88:	c0 a2       	brcc	80008c9c <__avr32_udiv64+0x228>
80008c8a:	20 18       	sub	r8,1
80008c8c:	18 0b       	add	r11,r12
80008c8e:	18 3b       	cp.w	r11,r12
80008c90:	c0 63       	brcs	80008c9c <__avr32_udiv64+0x228>
80008c92:	0c 3b       	cp.w	r11,r6
80008c94:	f7 dc e3 0b 	addcs	r11,r11,r12
80008c98:	f7 b8 03 01 	sublo	r8,1
80008c9c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80008ca0:	ee f4 ff f4 	ld.w	r4,r7[-12]
80008ca4:	0c 1b       	sub	r11,r6
80008ca6:	f0 04 06 42 	mulu.d	r2,r8,r4
80008caa:	06 95       	mov	r5,r3
80008cac:	16 35       	cp.w	r5,r11
80008cae:	e0 8b 00 0a 	brhi	80008cc2 <__avr32_udiv64+0x24e>
80008cb2:	5f 0b       	sreq	r11
80008cb4:	f4 09 09 49 	lsl	r9,r10,r9
80008cb8:	12 32       	cp.w	r2,r9
80008cba:	5f b9       	srhi	r9
80008cbc:	f7 e9 00 09 	and	r9,r11,r9
80008cc0:	c0 60       	breq	80008ccc <__avr32_udiv64+0x258>
80008cc2:	20 18       	sub	r8,1
80008cc4:	30 09       	mov	r9,0
80008cc6:	c0 38       	rjmp	80008ccc <__avr32_udiv64+0x258>
80008cc8:	30 09       	mov	r9,0
80008cca:	12 98       	mov	r8,r9
80008ccc:	10 9a       	mov	r10,r8
80008cce:	12 93       	mov	r3,r9
80008cd0:	10 92       	mov	r2,r8
80008cd2:	12 9b       	mov	r11,r9
80008cd4:	2f dd       	sub	sp,-12
80008cd6:	d8 32       	popm	r0-r7,pc

80008cd8 <free>:
80008cd8:	d4 01       	pushm	lr
80008cda:	e0 68 05 18 	mov	r8,1304
80008cde:	18 9b       	mov	r11,r12
80008ce0:	70 0c       	ld.w	r12,r8[0x0]
80008ce2:	e0 a0 03 5d 	rcall	8000939c <_free_r>
80008ce6:	d8 02       	popm	pc

80008ce8 <malloc>:
80008ce8:	d4 01       	pushm	lr
80008cea:	e0 68 05 18 	mov	r8,1304
80008cee:	18 9b       	mov	r11,r12
80008cf0:	70 0c       	ld.w	r12,r8[0x0]
80008cf2:	c0 3c       	rcall	80008cf8 <_malloc_r>
80008cf4:	d8 02       	popm	pc
80008cf6:	d7 03       	nop

80008cf8 <_malloc_r>:
80008cf8:	d4 31       	pushm	r0-r7,lr
80008cfa:	f6 c8 ff f5 	sub	r8,r11,-11
80008cfe:	18 95       	mov	r5,r12
80008d00:	10 97       	mov	r7,r8
80008d02:	e0 17 ff f8 	andl	r7,0xfff8
80008d06:	59 68       	cp.w	r8,22
80008d08:	f9 b7 08 10 	movls	r7,16
80008d0c:	16 37       	cp.w	r7,r11
80008d0e:	5f 38       	srlo	r8
80008d10:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80008d14:	c0 50       	breq	80008d1e <_malloc_r+0x26>
80008d16:	30 c8       	mov	r8,12
80008d18:	99 38       	st.w	r12[0xc],r8
80008d1a:	e0 8f 01 f1 	bral	800090fc <_malloc_r+0x404>
80008d1e:	fe b0 f1 e3 	rcall	800070e4 <__malloc_lock>
80008d22:	e0 47 01 f7 	cp.w	r7,503
80008d26:	e0 8b 00 1c 	brhi	80008d5e <_malloc_r+0x66>
80008d2a:	ee 03 16 03 	lsr	r3,r7,0x3
80008d2e:	31 88       	mov	r8,24
80008d30:	f0 03 00 38 	add	r8,r8,r3<<0x3
80008d34:	70 36       	ld.w	r6,r8[0xc]
80008d36:	10 36       	cp.w	r6,r8
80008d38:	c0 61       	brne	80008d44 <_malloc_r+0x4c>
80008d3a:	ec c8 ff f8 	sub	r8,r6,-8
80008d3e:	70 36       	ld.w	r6,r8[0xc]
80008d40:	10 36       	cp.w	r6,r8
80008d42:	c0 c0       	breq	80008d5a <_malloc_r+0x62>
80008d44:	6c 18       	ld.w	r8,r6[0x4]
80008d46:	e0 18 ff fc 	andl	r8,0xfffc
80008d4a:	6c 3a       	ld.w	r10,r6[0xc]
80008d4c:	ec 08 00 09 	add	r9,r6,r8
80008d50:	0a 9c       	mov	r12,r5
80008d52:	6c 28       	ld.w	r8,r6[0x8]
80008d54:	95 28       	st.w	r10[0x8],r8
80008d56:	91 3a       	st.w	r8[0xc],r10
80008d58:	c4 68       	rjmp	80008de4 <_malloc_r+0xec>
80008d5a:	2f e3       	sub	r3,-2
80008d5c:	c4 c8       	rjmp	80008df4 <_malloc_r+0xfc>
80008d5e:	ee 03 16 09 	lsr	r3,r7,0x9
80008d62:	c0 41       	brne	80008d6a <_malloc_r+0x72>
80008d64:	ee 03 16 03 	lsr	r3,r7,0x3
80008d68:	c2 68       	rjmp	80008db4 <_malloc_r+0xbc>
80008d6a:	58 43       	cp.w	r3,4
80008d6c:	e0 8b 00 06 	brhi	80008d78 <_malloc_r+0x80>
80008d70:	ee 03 16 06 	lsr	r3,r7,0x6
80008d74:	2c 83       	sub	r3,-56
80008d76:	c1 f8       	rjmp	80008db4 <_malloc_r+0xbc>
80008d78:	59 43       	cp.w	r3,20
80008d7a:	e0 8b 00 04 	brhi	80008d82 <_malloc_r+0x8a>
80008d7e:	2a 53       	sub	r3,-91
80008d80:	c1 a8       	rjmp	80008db4 <_malloc_r+0xbc>
80008d82:	e0 43 00 54 	cp.w	r3,84
80008d86:	e0 8b 00 06 	brhi	80008d92 <_malloc_r+0x9a>
80008d8a:	ee 03 16 0c 	lsr	r3,r7,0xc
80008d8e:	29 23       	sub	r3,-110
80008d90:	c1 28       	rjmp	80008db4 <_malloc_r+0xbc>
80008d92:	e0 43 01 54 	cp.w	r3,340
80008d96:	e0 8b 00 06 	brhi	80008da2 <_malloc_r+0xaa>
80008d9a:	ee 03 16 0f 	lsr	r3,r7,0xf
80008d9e:	28 93       	sub	r3,-119
80008da0:	c0 a8       	rjmp	80008db4 <_malloc_r+0xbc>
80008da2:	e0 43 05 54 	cp.w	r3,1364
80008da6:	e0 88 00 04 	brls	80008dae <_malloc_r+0xb6>
80008daa:	37 e3       	mov	r3,126
80008dac:	c0 48       	rjmp	80008db4 <_malloc_r+0xbc>
80008dae:	ee 03 16 12 	lsr	r3,r7,0x12
80008db2:	28 43       	sub	r3,-124
80008db4:	31 8a       	mov	r10,24
80008db6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80008dba:	74 36       	ld.w	r6,r10[0xc]
80008dbc:	c1 98       	rjmp	80008dee <_malloc_r+0xf6>
80008dbe:	6c 19       	ld.w	r9,r6[0x4]
80008dc0:	e0 19 ff fc 	andl	r9,0xfffc
80008dc4:	f2 07 01 0b 	sub	r11,r9,r7
80008dc8:	58 fb       	cp.w	r11,15
80008dca:	e0 8a 00 04 	brle	80008dd2 <_malloc_r+0xda>
80008dce:	20 13       	sub	r3,1
80008dd0:	c1 18       	rjmp	80008df2 <_malloc_r+0xfa>
80008dd2:	6c 38       	ld.w	r8,r6[0xc]
80008dd4:	58 0b       	cp.w	r11,0
80008dd6:	c0 b5       	brlt	80008dec <_malloc_r+0xf4>
80008dd8:	6c 2a       	ld.w	r10,r6[0x8]
80008dda:	ec 09 00 09 	add	r9,r6,r9
80008dde:	0a 9c       	mov	r12,r5
80008de0:	91 2a       	st.w	r8[0x8],r10
80008de2:	95 38       	st.w	r10[0xc],r8
80008de4:	72 18       	ld.w	r8,r9[0x4]
80008de6:	a1 a8       	sbr	r8,0x0
80008de8:	93 18       	st.w	r9[0x4],r8
80008dea:	cb 88       	rjmp	80008f5a <_malloc_r+0x262>
80008dec:	10 96       	mov	r6,r8
80008dee:	14 36       	cp.w	r6,r10
80008df0:	ce 71       	brne	80008dbe <_malloc_r+0xc6>
80008df2:	2f f3       	sub	r3,-1
80008df4:	31 8a       	mov	r10,24
80008df6:	f4 cc ff f8 	sub	r12,r10,-8
80008dfa:	78 26       	ld.w	r6,r12[0x8]
80008dfc:	18 36       	cp.w	r6,r12
80008dfe:	c6 a0       	breq	80008ed2 <_malloc_r+0x1da>
80008e00:	6c 19       	ld.w	r9,r6[0x4]
80008e02:	e0 19 ff fc 	andl	r9,0xfffc
80008e06:	f2 07 01 08 	sub	r8,r9,r7
80008e0a:	58 f8       	cp.w	r8,15
80008e0c:	e0 89 00 8c 	brgt	80008f24 <_malloc_r+0x22c>
80008e10:	99 3c       	st.w	r12[0xc],r12
80008e12:	99 2c       	st.w	r12[0x8],r12
80008e14:	58 08       	cp.w	r8,0
80008e16:	c0 55       	brlt	80008e20 <_malloc_r+0x128>
80008e18:	ec 09 00 09 	add	r9,r6,r9
80008e1c:	0a 9c       	mov	r12,r5
80008e1e:	ce 3b       	rjmp	80008de4 <_malloc_r+0xec>
80008e20:	e0 49 01 ff 	cp.w	r9,511
80008e24:	e0 8b 00 13 	brhi	80008e4a <_malloc_r+0x152>
80008e28:	a3 99       	lsr	r9,0x3
80008e2a:	f4 09 00 38 	add	r8,r10,r9<<0x3
80008e2e:	70 2b       	ld.w	r11,r8[0x8]
80008e30:	8d 38       	st.w	r6[0xc],r8
80008e32:	8d 2b       	st.w	r6[0x8],r11
80008e34:	97 36       	st.w	r11[0xc],r6
80008e36:	91 26       	st.w	r8[0x8],r6
80008e38:	a3 49       	asr	r9,0x2
80008e3a:	74 18       	ld.w	r8,r10[0x4]
80008e3c:	30 1b       	mov	r11,1
80008e3e:	f6 09 09 49 	lsl	r9,r11,r9
80008e42:	f1 e9 10 09 	or	r9,r8,r9
80008e46:	95 19       	st.w	r10[0x4],r9
80008e48:	c4 58       	rjmp	80008ed2 <_malloc_r+0x1da>
80008e4a:	f2 0a 16 09 	lsr	r10,r9,0x9
80008e4e:	58 4a       	cp.w	r10,4
80008e50:	e0 8b 00 06 	brhi	80008e5c <_malloc_r+0x164>
80008e54:	f2 0a 16 06 	lsr	r10,r9,0x6
80008e58:	2c 8a       	sub	r10,-56
80008e5a:	c1 f8       	rjmp	80008e98 <_malloc_r+0x1a0>
80008e5c:	59 4a       	cp.w	r10,20
80008e5e:	e0 8b 00 04 	brhi	80008e66 <_malloc_r+0x16e>
80008e62:	2a 5a       	sub	r10,-91
80008e64:	c1 a8       	rjmp	80008e98 <_malloc_r+0x1a0>
80008e66:	e0 4a 00 54 	cp.w	r10,84
80008e6a:	e0 8b 00 06 	brhi	80008e76 <_malloc_r+0x17e>
80008e6e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80008e72:	29 2a       	sub	r10,-110
80008e74:	c1 28       	rjmp	80008e98 <_malloc_r+0x1a0>
80008e76:	e0 4a 01 54 	cp.w	r10,340
80008e7a:	e0 8b 00 06 	brhi	80008e86 <_malloc_r+0x18e>
80008e7e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80008e82:	28 9a       	sub	r10,-119
80008e84:	c0 a8       	rjmp	80008e98 <_malloc_r+0x1a0>
80008e86:	e0 4a 05 54 	cp.w	r10,1364
80008e8a:	e0 88 00 04 	brls	80008e92 <_malloc_r+0x19a>
80008e8e:	37 ea       	mov	r10,126
80008e90:	c0 48       	rjmp	80008e98 <_malloc_r+0x1a0>
80008e92:	f2 0a 16 12 	lsr	r10,r9,0x12
80008e96:	28 4a       	sub	r10,-124
80008e98:	31 8b       	mov	r11,24
80008e9a:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80008e9e:	68 28       	ld.w	r8,r4[0x8]
80008ea0:	08 38       	cp.w	r8,r4
80008ea2:	c0 e1       	brne	80008ebe <_malloc_r+0x1c6>
80008ea4:	76 19       	ld.w	r9,r11[0x4]
80008ea6:	a3 4a       	asr	r10,0x2
80008ea8:	30 1e       	mov	lr,1
80008eaa:	fc 0a 09 4a 	lsl	r10,lr,r10
80008eae:	f3 ea 10 0a 	or	r10,r9,r10
80008eb2:	10 99       	mov	r9,r8
80008eb4:	97 1a       	st.w	r11[0x4],r10
80008eb6:	c0 a8       	rjmp	80008eca <_malloc_r+0x1d2>
80008eb8:	70 28       	ld.w	r8,r8[0x8]
80008eba:	08 38       	cp.w	r8,r4
80008ebc:	c0 60       	breq	80008ec8 <_malloc_r+0x1d0>
80008ebe:	70 1a       	ld.w	r10,r8[0x4]
80008ec0:	e0 1a ff fc 	andl	r10,0xfffc
80008ec4:	14 39       	cp.w	r9,r10
80008ec6:	cf 93       	brcs	80008eb8 <_malloc_r+0x1c0>
80008ec8:	70 39       	ld.w	r9,r8[0xc]
80008eca:	8d 39       	st.w	r6[0xc],r9
80008ecc:	8d 28       	st.w	r6[0x8],r8
80008ece:	91 36       	st.w	r8[0xc],r6
80008ed0:	93 26       	st.w	r9[0x8],r6
80008ed2:	e6 08 14 02 	asr	r8,r3,0x2
80008ed6:	30 1b       	mov	r11,1
80008ed8:	31 84       	mov	r4,24
80008eda:	f6 08 09 4b 	lsl	r11,r11,r8
80008ede:	68 18       	ld.w	r8,r4[0x4]
80008ee0:	10 3b       	cp.w	r11,r8
80008ee2:	e0 8b 00 6b 	brhi	80008fb8 <_malloc_r+0x2c0>
80008ee6:	f7 e8 00 09 	and	r9,r11,r8
80008eea:	c0 b1       	brne	80008f00 <_malloc_r+0x208>
80008eec:	e0 13 ff fc 	andl	r3,0xfffc
80008ef0:	a1 7b       	lsl	r11,0x1
80008ef2:	2f c3       	sub	r3,-4
80008ef4:	c0 38       	rjmp	80008efa <_malloc_r+0x202>
80008ef6:	2f c3       	sub	r3,-4
80008ef8:	a1 7b       	lsl	r11,0x1
80008efa:	f7 e8 00 09 	and	r9,r11,r8
80008efe:	cf c0       	breq	80008ef6 <_malloc_r+0x1fe>
80008f00:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80008f04:	06 92       	mov	r2,r3
80008f06:	1c 91       	mov	r1,lr
80008f08:	62 36       	ld.w	r6,r1[0xc]
80008f0a:	c2 e8       	rjmp	80008f66 <_malloc_r+0x26e>
80008f0c:	6c 1a       	ld.w	r10,r6[0x4]
80008f0e:	e0 1a ff fc 	andl	r10,0xfffc
80008f12:	f4 07 01 08 	sub	r8,r10,r7
80008f16:	58 f8       	cp.w	r8,15
80008f18:	e0 8a 00 15 	brle	80008f42 <_malloc_r+0x24a>
80008f1c:	6c 3a       	ld.w	r10,r6[0xc]
80008f1e:	6c 29       	ld.w	r9,r6[0x8]
80008f20:	95 29       	st.w	r10[0x8],r9
80008f22:	93 3a       	st.w	r9[0xc],r10
80008f24:	0e 99       	mov	r9,r7
80008f26:	ec 07 00 07 	add	r7,r6,r7
80008f2a:	a1 a9       	sbr	r9,0x0
80008f2c:	99 37       	st.w	r12[0xc],r7
80008f2e:	99 27       	st.w	r12[0x8],r7
80008f30:	8d 19       	st.w	r6[0x4],r9
80008f32:	ee 08 09 08 	st.w	r7[r8],r8
80008f36:	8f 2c       	st.w	r7[0x8],r12
80008f38:	8f 3c       	st.w	r7[0xc],r12
80008f3a:	a1 a8       	sbr	r8,0x0
80008f3c:	0a 9c       	mov	r12,r5
80008f3e:	8f 18       	st.w	r7[0x4],r8
80008f40:	c0 d8       	rjmp	80008f5a <_malloc_r+0x262>
80008f42:	6c 39       	ld.w	r9,r6[0xc]
80008f44:	58 08       	cp.w	r8,0
80008f46:	c0 f5       	brlt	80008f64 <_malloc_r+0x26c>
80008f48:	ec 0a 00 0a 	add	r10,r6,r10
80008f4c:	74 18       	ld.w	r8,r10[0x4]
80008f4e:	a1 a8       	sbr	r8,0x0
80008f50:	0a 9c       	mov	r12,r5
80008f52:	95 18       	st.w	r10[0x4],r8
80008f54:	6c 28       	ld.w	r8,r6[0x8]
80008f56:	93 28       	st.w	r9[0x8],r8
80008f58:	91 39       	st.w	r8[0xc],r9
80008f5a:	fe b0 f0 cb 	rcall	800070f0 <__malloc_unlock>
80008f5e:	ec cc ff f8 	sub	r12,r6,-8
80008f62:	d8 32       	popm	r0-r7,pc
80008f64:	12 96       	mov	r6,r9
80008f66:	02 36       	cp.w	r6,r1
80008f68:	cd 21       	brne	80008f0c <_malloc_r+0x214>
80008f6a:	2f f2       	sub	r2,-1
80008f6c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80008f70:	c0 30       	breq	80008f76 <_malloc_r+0x27e>
80008f72:	2f 81       	sub	r1,-8
80008f74:	cc ab       	rjmp	80008f08 <_malloc_r+0x210>
80008f76:	1c 98       	mov	r8,lr
80008f78:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80008f7c:	c0 81       	brne	80008f8c <_malloc_r+0x294>
80008f7e:	68 19       	ld.w	r9,r4[0x4]
80008f80:	f6 08 11 ff 	rsub	r8,r11,-1
80008f84:	f3 e8 00 08 	and	r8,r9,r8
80008f88:	89 18       	st.w	r4[0x4],r8
80008f8a:	c0 78       	rjmp	80008f98 <_malloc_r+0x2a0>
80008f8c:	f0 c9 00 08 	sub	r9,r8,8
80008f90:	20 13       	sub	r3,1
80008f92:	70 08       	ld.w	r8,r8[0x0]
80008f94:	12 38       	cp.w	r8,r9
80008f96:	cf 10       	breq	80008f78 <_malloc_r+0x280>
80008f98:	a1 7b       	lsl	r11,0x1
80008f9a:	68 18       	ld.w	r8,r4[0x4]
80008f9c:	10 3b       	cp.w	r11,r8
80008f9e:	e0 8b 00 0d 	brhi	80008fb8 <_malloc_r+0x2c0>
80008fa2:	58 0b       	cp.w	r11,0
80008fa4:	c0 a0       	breq	80008fb8 <_malloc_r+0x2c0>
80008fa6:	04 93       	mov	r3,r2
80008fa8:	c0 38       	rjmp	80008fae <_malloc_r+0x2b6>
80008faa:	2f c3       	sub	r3,-4
80008fac:	a1 7b       	lsl	r11,0x1
80008fae:	f7 e8 00 09 	and	r9,r11,r8
80008fb2:	ca 71       	brne	80008f00 <_malloc_r+0x208>
80008fb4:	cf bb       	rjmp	80008faa <_malloc_r+0x2b2>
80008fb6:	d7 03       	nop
80008fb8:	68 23       	ld.w	r3,r4[0x8]
80008fba:	66 12       	ld.w	r2,r3[0x4]
80008fbc:	e0 12 ff fc 	andl	r2,0xfffc
80008fc0:	0e 32       	cp.w	r2,r7
80008fc2:	5f 39       	srlo	r9
80008fc4:	e4 07 01 08 	sub	r8,r2,r7
80008fc8:	58 f8       	cp.w	r8,15
80008fca:	5f aa       	srle	r10
80008fcc:	f5 e9 10 09 	or	r9,r10,r9
80008fd0:	e0 80 00 98 	breq	80009100 <_malloc_r+0x408>
80008fd4:	e0 68 08 0c 	mov	r8,2060
80008fd8:	70 01       	ld.w	r1,r8[0x0]
80008fda:	e0 68 04 24 	mov	r8,1060
80008fde:	2f 01       	sub	r1,-16
80008fe0:	70 08       	ld.w	r8,r8[0x0]
80008fe2:	0e 01       	add	r1,r7
80008fe4:	5b f8       	cp.w	r8,-1
80008fe6:	c0 40       	breq	80008fee <_malloc_r+0x2f6>
80008fe8:	28 11       	sub	r1,-127
80008fea:	e0 11 ff 80 	andl	r1,0xff80
80008fee:	02 9b       	mov	r11,r1
80008ff0:	0a 9c       	mov	r12,r5
80008ff2:	c4 3d       	rcall	80009278 <_sbrk_r>
80008ff4:	18 96       	mov	r6,r12
80008ff6:	5b fc       	cp.w	r12,-1
80008ff8:	c7 30       	breq	800090de <_malloc_r+0x3e6>
80008ffa:	e6 02 00 08 	add	r8,r3,r2
80008ffe:	10 3c       	cp.w	r12,r8
80009000:	c0 32       	brcc	80009006 <_malloc_r+0x30e>
80009002:	08 33       	cp.w	r3,r4
80009004:	c6 d1       	brne	800090de <_malloc_r+0x3e6>
80009006:	e0 6a 08 10 	mov	r10,2064
8000900a:	74 09       	ld.w	r9,r10[0x0]
8000900c:	e2 09 00 09 	add	r9,r1,r9
80009010:	95 09       	st.w	r10[0x0],r9
80009012:	10 36       	cp.w	r6,r8
80009014:	c0 a1       	brne	80009028 <_malloc_r+0x330>
80009016:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000901a:	c0 71       	brne	80009028 <_malloc_r+0x330>
8000901c:	e2 02 00 02 	add	r2,r1,r2
80009020:	68 28       	ld.w	r8,r4[0x8]
80009022:	a1 a2       	sbr	r2,0x0
80009024:	91 12       	st.w	r8[0x4],r2
80009026:	c4 d8       	rjmp	800090c0 <_malloc_r+0x3c8>
80009028:	e0 6a 04 24 	mov	r10,1060
8000902c:	74 0b       	ld.w	r11,r10[0x0]
8000902e:	5b fb       	cp.w	r11,-1
80009030:	c0 31       	brne	80009036 <_malloc_r+0x33e>
80009032:	95 06       	st.w	r10[0x0],r6
80009034:	c0 78       	rjmp	80009042 <_malloc_r+0x34a>
80009036:	ec 09 00 09 	add	r9,r6,r9
8000903a:	e0 6a 08 10 	mov	r10,2064
8000903e:	10 19       	sub	r9,r8
80009040:	95 09       	st.w	r10[0x0],r9
80009042:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80009046:	f0 09 11 08 	rsub	r9,r8,8
8000904a:	58 08       	cp.w	r8,0
8000904c:	f2 08 17 10 	movne	r8,r9
80009050:	ed d8 e1 06 	addne	r6,r6,r8
80009054:	28 08       	sub	r8,-128
80009056:	ec 01 00 01 	add	r1,r6,r1
8000905a:	0a 9c       	mov	r12,r5
8000905c:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80009060:	f0 01 01 01 	sub	r1,r8,r1
80009064:	02 9b       	mov	r11,r1
80009066:	c0 9d       	rcall	80009278 <_sbrk_r>
80009068:	e0 68 08 10 	mov	r8,2064
8000906c:	5b fc       	cp.w	r12,-1
8000906e:	ec 0c 17 00 	moveq	r12,r6
80009072:	f9 b1 00 00 	moveq	r1,0
80009076:	70 09       	ld.w	r9,r8[0x0]
80009078:	0c 1c       	sub	r12,r6
8000907a:	89 26       	st.w	r4[0x8],r6
8000907c:	02 0c       	add	r12,r1
8000907e:	12 01       	add	r1,r9
80009080:	a1 ac       	sbr	r12,0x0
80009082:	91 01       	st.w	r8[0x0],r1
80009084:	8d 1c       	st.w	r6[0x4],r12
80009086:	08 33       	cp.w	r3,r4
80009088:	c1 c0       	breq	800090c0 <_malloc_r+0x3c8>
8000908a:	58 f2       	cp.w	r2,15
8000908c:	e0 8b 00 05 	brhi	80009096 <_malloc_r+0x39e>
80009090:	30 18       	mov	r8,1
80009092:	8d 18       	st.w	r6[0x4],r8
80009094:	c2 58       	rjmp	800090de <_malloc_r+0x3e6>
80009096:	30 59       	mov	r9,5
80009098:	20 c2       	sub	r2,12
8000909a:	e0 12 ff f8 	andl	r2,0xfff8
8000909e:	e6 02 00 08 	add	r8,r3,r2
800090a2:	91 29       	st.w	r8[0x8],r9
800090a4:	91 19       	st.w	r8[0x4],r9
800090a6:	66 18       	ld.w	r8,r3[0x4]
800090a8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800090ac:	e5 e8 10 08 	or	r8,r2,r8
800090b0:	87 18       	st.w	r3[0x4],r8
800090b2:	58 f2       	cp.w	r2,15
800090b4:	e0 88 00 06 	brls	800090c0 <_malloc_r+0x3c8>
800090b8:	e6 cb ff f8 	sub	r11,r3,-8
800090bc:	0a 9c       	mov	r12,r5
800090be:	c6 fd       	rcall	8000939c <_free_r>
800090c0:	e0 69 08 08 	mov	r9,2056
800090c4:	72 0a       	ld.w	r10,r9[0x0]
800090c6:	e0 68 08 10 	mov	r8,2064
800090ca:	70 08       	ld.w	r8,r8[0x0]
800090cc:	14 38       	cp.w	r8,r10
800090ce:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800090d2:	e0 69 08 04 	mov	r9,2052
800090d6:	72 0a       	ld.w	r10,r9[0x0]
800090d8:	14 38       	cp.w	r8,r10
800090da:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800090de:	68 28       	ld.w	r8,r4[0x8]
800090e0:	70 18       	ld.w	r8,r8[0x4]
800090e2:	e0 18 ff fc 	andl	r8,0xfffc
800090e6:	0e 38       	cp.w	r8,r7
800090e8:	5f 39       	srlo	r9
800090ea:	0e 18       	sub	r8,r7
800090ec:	58 f8       	cp.w	r8,15
800090ee:	5f aa       	srle	r10
800090f0:	f5 e9 10 09 	or	r9,r10,r9
800090f4:	c0 60       	breq	80009100 <_malloc_r+0x408>
800090f6:	0a 9c       	mov	r12,r5
800090f8:	fe b0 ef fc 	rcall	800070f0 <__malloc_unlock>
800090fc:	d8 3a       	popm	r0-r7,pc,r12=0
800090fe:	d7 03       	nop
80009100:	68 26       	ld.w	r6,r4[0x8]
80009102:	a1 a8       	sbr	r8,0x0
80009104:	0e 99       	mov	r9,r7
80009106:	a1 a9       	sbr	r9,0x0
80009108:	8d 19       	st.w	r6[0x4],r9
8000910a:	ec 07 00 07 	add	r7,r6,r7
8000910e:	0a 9c       	mov	r12,r5
80009110:	89 27       	st.w	r4[0x8],r7
80009112:	8f 18       	st.w	r7[0x4],r8
80009114:	fe b0 ef ee 	rcall	800070f0 <__malloc_unlock>
80009118:	ec cc ff f8 	sub	r12,r6,-8
8000911c:	d8 32       	popm	r0-r7,pc
8000911e:	d7 03       	nop

80009120 <memcpy>:
80009120:	58 8a       	cp.w	r10,8
80009122:	c2 f5       	brlt	80009180 <memcpy+0x60>
80009124:	f9 eb 10 09 	or	r9,r12,r11
80009128:	e2 19 00 03 	andl	r9,0x3,COH
8000912c:	e0 81 00 97 	brne	8000925a <memcpy+0x13a>
80009130:	e0 4a 00 20 	cp.w	r10,32
80009134:	c3 b4       	brge	800091aa <memcpy+0x8a>
80009136:	f4 08 14 02 	asr	r8,r10,0x2
8000913a:	f0 09 11 08 	rsub	r9,r8,8
8000913e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80009142:	76 69       	ld.w	r9,r11[0x18]
80009144:	99 69       	st.w	r12[0x18],r9
80009146:	76 59       	ld.w	r9,r11[0x14]
80009148:	99 59       	st.w	r12[0x14],r9
8000914a:	76 49       	ld.w	r9,r11[0x10]
8000914c:	99 49       	st.w	r12[0x10],r9
8000914e:	76 39       	ld.w	r9,r11[0xc]
80009150:	99 39       	st.w	r12[0xc],r9
80009152:	76 29       	ld.w	r9,r11[0x8]
80009154:	99 29       	st.w	r12[0x8],r9
80009156:	76 19       	ld.w	r9,r11[0x4]
80009158:	99 19       	st.w	r12[0x4],r9
8000915a:	76 09       	ld.w	r9,r11[0x0]
8000915c:	99 09       	st.w	r12[0x0],r9
8000915e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80009162:	f8 08 00 28 	add	r8,r12,r8<<0x2
80009166:	e0 1a 00 03 	andl	r10,0x3
8000916a:	f4 0a 11 04 	rsub	r10,r10,4
8000916e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80009172:	17 a9       	ld.ub	r9,r11[0x2]
80009174:	b0 a9       	st.b	r8[0x2],r9
80009176:	17 99       	ld.ub	r9,r11[0x1]
80009178:	b0 99       	st.b	r8[0x1],r9
8000917a:	17 89       	ld.ub	r9,r11[0x0]
8000917c:	b0 89       	st.b	r8[0x0],r9
8000917e:	5e fc       	retal	r12
80009180:	f4 0a 11 09 	rsub	r10,r10,9
80009184:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80009188:	17 f9       	ld.ub	r9,r11[0x7]
8000918a:	b8 f9       	st.b	r12[0x7],r9
8000918c:	17 e9       	ld.ub	r9,r11[0x6]
8000918e:	b8 e9       	st.b	r12[0x6],r9
80009190:	17 d9       	ld.ub	r9,r11[0x5]
80009192:	b8 d9       	st.b	r12[0x5],r9
80009194:	17 c9       	ld.ub	r9,r11[0x4]
80009196:	b8 c9       	st.b	r12[0x4],r9
80009198:	17 b9       	ld.ub	r9,r11[0x3]
8000919a:	b8 b9       	st.b	r12[0x3],r9
8000919c:	17 a9       	ld.ub	r9,r11[0x2]
8000919e:	b8 a9       	st.b	r12[0x2],r9
800091a0:	17 99       	ld.ub	r9,r11[0x1]
800091a2:	b8 99       	st.b	r12[0x1],r9
800091a4:	17 89       	ld.ub	r9,r11[0x0]
800091a6:	b8 89       	st.b	r12[0x0],r9
800091a8:	5e fc       	retal	r12
800091aa:	eb cd 40 c0 	pushm	r6-r7,lr
800091ae:	18 99       	mov	r9,r12
800091b0:	22 0a       	sub	r10,32
800091b2:	b7 07       	ld.d	r6,r11++
800091b4:	b3 26       	st.d	r9++,r6
800091b6:	b7 07       	ld.d	r6,r11++
800091b8:	b3 26       	st.d	r9++,r6
800091ba:	b7 07       	ld.d	r6,r11++
800091bc:	b3 26       	st.d	r9++,r6
800091be:	b7 07       	ld.d	r6,r11++
800091c0:	b3 26       	st.d	r9++,r6
800091c2:	22 0a       	sub	r10,32
800091c4:	cf 74       	brge	800091b2 <memcpy+0x92>
800091c6:	2f 0a       	sub	r10,-16
800091c8:	c0 65       	brlt	800091d4 <memcpy+0xb4>
800091ca:	b7 07       	ld.d	r6,r11++
800091cc:	b3 26       	st.d	r9++,r6
800091ce:	b7 07       	ld.d	r6,r11++
800091d0:	b3 26       	st.d	r9++,r6
800091d2:	21 0a       	sub	r10,16
800091d4:	5c 3a       	neg	r10
800091d6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800091da:	d7 03       	nop
800091dc:	d7 03       	nop
800091de:	f7 36 00 0e 	ld.ub	r6,r11[14]
800091e2:	f3 66 00 0e 	st.b	r9[14],r6
800091e6:	f7 36 00 0d 	ld.ub	r6,r11[13]
800091ea:	f3 66 00 0d 	st.b	r9[13],r6
800091ee:	f7 36 00 0c 	ld.ub	r6,r11[12]
800091f2:	f3 66 00 0c 	st.b	r9[12],r6
800091f6:	f7 36 00 0b 	ld.ub	r6,r11[11]
800091fa:	f3 66 00 0b 	st.b	r9[11],r6
800091fe:	f7 36 00 0a 	ld.ub	r6,r11[10]
80009202:	f3 66 00 0a 	st.b	r9[10],r6
80009206:	f7 36 00 09 	ld.ub	r6,r11[9]
8000920a:	f3 66 00 09 	st.b	r9[9],r6
8000920e:	f7 36 00 08 	ld.ub	r6,r11[8]
80009212:	f3 66 00 08 	st.b	r9[8],r6
80009216:	f7 36 00 07 	ld.ub	r6,r11[7]
8000921a:	f3 66 00 07 	st.b	r9[7],r6
8000921e:	f7 36 00 06 	ld.ub	r6,r11[6]
80009222:	f3 66 00 06 	st.b	r9[6],r6
80009226:	f7 36 00 05 	ld.ub	r6,r11[5]
8000922a:	f3 66 00 05 	st.b	r9[5],r6
8000922e:	f7 36 00 04 	ld.ub	r6,r11[4]
80009232:	f3 66 00 04 	st.b	r9[4],r6
80009236:	f7 36 00 03 	ld.ub	r6,r11[3]
8000923a:	f3 66 00 03 	st.b	r9[3],r6
8000923e:	f7 36 00 02 	ld.ub	r6,r11[2]
80009242:	f3 66 00 02 	st.b	r9[2],r6
80009246:	f7 36 00 01 	ld.ub	r6,r11[1]
8000924a:	f3 66 00 01 	st.b	r9[1],r6
8000924e:	f7 36 00 00 	ld.ub	r6,r11[0]
80009252:	f3 66 00 00 	st.b	r9[0],r6
80009256:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000925a:	20 1a       	sub	r10,1
8000925c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80009260:	f8 0a 0b 09 	st.b	r12[r10],r9
80009264:	cf b1       	brne	8000925a <memcpy+0x13a>
80009266:	5e fc       	retal	r12

80009268 <memset>:
80009268:	18 98       	mov	r8,r12
8000926a:	c0 38       	rjmp	80009270 <memset+0x8>
8000926c:	10 cb       	st.b	r8++,r11
8000926e:	20 1a       	sub	r10,1
80009270:	58 0a       	cp.w	r10,0
80009272:	cf d1       	brne	8000926c <memset+0x4>
80009274:	5e fc       	retal	r12
80009276:	d7 03       	nop

80009278 <_sbrk_r>:
80009278:	d4 21       	pushm	r4-r7,lr
8000927a:	30 08       	mov	r8,0
8000927c:	18 97       	mov	r7,r12
8000927e:	e0 66 0f c8 	mov	r6,4040
80009282:	16 9c       	mov	r12,r11
80009284:	8d 08       	st.w	r6[0x0],r8
80009286:	c2 1c       	rcall	800092c8 <_sbrk>
80009288:	5b fc       	cp.w	r12,-1
8000928a:	c0 51       	brne	80009294 <_sbrk_r+0x1c>
8000928c:	6c 08       	ld.w	r8,r6[0x0]
8000928e:	58 08       	cp.w	r8,0
80009290:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009294:	d8 22       	popm	r4-r7,pc
80009296:	d7 03       	nop

80009298 <strncat>:
80009298:	d4 01       	pushm	lr
8000929a:	30 09       	mov	r9,0
8000929c:	18 98       	mov	r8,r12
8000929e:	c0 28       	rjmp	800092a2 <strncat+0xa>
800092a0:	2f f8       	sub	r8,-1
800092a2:	11 8e       	ld.ub	lr,r8[0x0]
800092a4:	f2 0e 18 00 	cp.b	lr,r9
800092a8:	cf c1       	brne	800092a0 <strncat+0x8>
800092aa:	c0 78       	rjmp	800092b8 <strncat+0x20>
800092ac:	20 1a       	sub	r10,1
800092ae:	2f f8       	sub	r8,-1
800092b0:	2f fb       	sub	r11,-1
800092b2:	58 0a       	cp.w	r10,0
800092b4:	f1 fa 0e 00 	st.beq	r8[0x0],r10
800092b8:	58 0a       	cp.w	r10,0
800092ba:	c0 50       	breq	800092c4 <strncat+0x2c>
800092bc:	17 89       	ld.ub	r9,r11[0x0]
800092be:	b0 89       	st.b	r8[0x0],r9
800092c0:	58 09       	cp.w	r9,0
800092c2:	cf 51       	brne	800092ac <strncat+0x14>
800092c4:	d8 02       	popm	pc
800092c6:	d7 03       	nop

800092c8 <_sbrk>:
800092c8:	d4 01       	pushm	lr
800092ca:	e0 68 08 38 	mov	r8,2104
800092ce:	70 09       	ld.w	r9,r8[0x0]
800092d0:	58 09       	cp.w	r9,0
800092d2:	c0 41       	brne	800092da <_sbrk+0x12>
800092d4:	e0 69 0f d0 	mov	r9,4048
800092d8:	91 09       	st.w	r8[0x0],r9
800092da:	e0 69 08 38 	mov	r9,2104
800092de:	e0 6a f0 00 	mov	r10,61440
800092e2:	72 08       	ld.w	r8,r9[0x0]
800092e4:	f0 0c 00 0c 	add	r12,r8,r12
800092e8:	14 3c       	cp.w	r12,r10
800092ea:	e0 8b 00 04 	brhi	800092f2 <_sbrk+0x2a>
800092ee:	93 0c       	st.w	r9[0x0],r12
800092f0:	c0 58       	rjmp	800092fa <_sbrk+0x32>
800092f2:	c0 7c       	rcall	80009300 <__errno>
800092f4:	30 c8       	mov	r8,12
800092f6:	99 08       	st.w	r12[0x0],r8
800092f8:	3f f8       	mov	r8,-1
800092fa:	10 9c       	mov	r12,r8
800092fc:	d8 02       	popm	pc
800092fe:	d7 03       	nop

80009300 <__errno>:
80009300:	e0 68 05 18 	mov	r8,1304
80009304:	70 0c       	ld.w	r12,r8[0x0]
80009306:	2f 4c       	sub	r12,-12
80009308:	5e fc       	retal	r12
8000930a:	d7 03       	nop

8000930c <_malloc_trim_r>:
8000930c:	d4 21       	pushm	r4-r7,lr
8000930e:	16 95       	mov	r5,r11
80009310:	18 97       	mov	r7,r12
80009312:	fe b0 ee e9 	rcall	800070e4 <__malloc_lock>
80009316:	31 84       	mov	r4,24
80009318:	68 28       	ld.w	r8,r4[0x8]
8000931a:	70 16       	ld.w	r6,r8[0x4]
8000931c:	e0 16 ff fc 	andl	r6,0xfffc
80009320:	ec c8 ff 91 	sub	r8,r6,-111
80009324:	f0 05 01 05 	sub	r5,r8,r5
80009328:	e0 15 ff 80 	andl	r5,0xff80
8000932c:	ea c5 00 80 	sub	r5,r5,128
80009330:	e0 45 00 7f 	cp.w	r5,127
80009334:	e0 8a 00 22 	brle	80009378 <_malloc_trim_r+0x6c>
80009338:	30 0b       	mov	r11,0
8000933a:	0e 9c       	mov	r12,r7
8000933c:	c9 ef       	rcall	80009278 <_sbrk_r>
8000933e:	68 28       	ld.w	r8,r4[0x8]
80009340:	0c 08       	add	r8,r6
80009342:	10 3c       	cp.w	r12,r8
80009344:	c1 a1       	brne	80009378 <_malloc_trim_r+0x6c>
80009346:	ea 0b 11 00 	rsub	r11,r5,0
8000934a:	0e 9c       	mov	r12,r7
8000934c:	c9 6f       	rcall	80009278 <_sbrk_r>
8000934e:	5b fc       	cp.w	r12,-1
80009350:	c1 81       	brne	80009380 <_malloc_trim_r+0x74>
80009352:	30 0b       	mov	r11,0
80009354:	0e 9c       	mov	r12,r7
80009356:	c9 1f       	rcall	80009278 <_sbrk_r>
80009358:	68 28       	ld.w	r8,r4[0x8]
8000935a:	f8 08 01 09 	sub	r9,r12,r8
8000935e:	58 f9       	cp.w	r9,15
80009360:	e0 8a 00 0c 	brle	80009378 <_malloc_trim_r+0x6c>
80009364:	a1 a9       	sbr	r9,0x0
80009366:	91 19       	st.w	r8[0x4],r9
80009368:	e0 68 04 24 	mov	r8,1060
8000936c:	70 09       	ld.w	r9,r8[0x0]
8000936e:	e0 68 08 10 	mov	r8,2064
80009372:	f8 09 01 09 	sub	r9,r12,r9
80009376:	91 09       	st.w	r8[0x0],r9
80009378:	0e 9c       	mov	r12,r7
8000937a:	fe b0 ee bb 	rcall	800070f0 <__malloc_unlock>
8000937e:	d8 2a       	popm	r4-r7,pc,r12=0
80009380:	68 28       	ld.w	r8,r4[0x8]
80009382:	0a 16       	sub	r6,r5
80009384:	a1 a6       	sbr	r6,0x0
80009386:	91 16       	st.w	r8[0x4],r6
80009388:	e0 68 08 10 	mov	r8,2064
8000938c:	70 09       	ld.w	r9,r8[0x0]
8000938e:	0a 19       	sub	r9,r5
80009390:	0e 9c       	mov	r12,r7
80009392:	91 09       	st.w	r8[0x0],r9
80009394:	fe b0 ee ae 	rcall	800070f0 <__malloc_unlock>
80009398:	da 2a       	popm	r4-r7,pc,r12=1
8000939a:	d7 03       	nop

8000939c <_free_r>:
8000939c:	d4 21       	pushm	r4-r7,lr
8000939e:	16 96       	mov	r6,r11
800093a0:	18 97       	mov	r7,r12
800093a2:	58 0b       	cp.w	r11,0
800093a4:	e0 80 00 be 	breq	80009520 <_free_r+0x184>
800093a8:	fe b0 ee 9e 	rcall	800070e4 <__malloc_lock>
800093ac:	20 86       	sub	r6,8
800093ae:	31 8a       	mov	r10,24
800093b0:	6c 18       	ld.w	r8,r6[0x4]
800093b2:	74 2e       	ld.w	lr,r10[0x8]
800093b4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800093b8:	a1 c8       	cbr	r8,0x0
800093ba:	ec 08 00 09 	add	r9,r6,r8
800093be:	72 1b       	ld.w	r11,r9[0x4]
800093c0:	e0 1b ff fc 	andl	r11,0xfffc
800093c4:	1c 39       	cp.w	r9,lr
800093c6:	c1 e1       	brne	80009402 <_free_r+0x66>
800093c8:	f6 08 00 08 	add	r8,r11,r8
800093cc:	58 0c       	cp.w	r12,0
800093ce:	c0 81       	brne	800093de <_free_r+0x42>
800093d0:	6c 09       	ld.w	r9,r6[0x0]
800093d2:	12 16       	sub	r6,r9
800093d4:	12 08       	add	r8,r9
800093d6:	6c 3b       	ld.w	r11,r6[0xc]
800093d8:	6c 29       	ld.w	r9,r6[0x8]
800093da:	97 29       	st.w	r11[0x8],r9
800093dc:	93 3b       	st.w	r9[0xc],r11
800093de:	10 99       	mov	r9,r8
800093e0:	95 26       	st.w	r10[0x8],r6
800093e2:	a1 a9       	sbr	r9,0x0
800093e4:	8d 19       	st.w	r6[0x4],r9
800093e6:	e0 69 04 20 	mov	r9,1056
800093ea:	72 09       	ld.w	r9,r9[0x0]
800093ec:	12 38       	cp.w	r8,r9
800093ee:	c0 63       	brcs	800093fa <_free_r+0x5e>
800093f0:	e0 68 08 0c 	mov	r8,2060
800093f4:	0e 9c       	mov	r12,r7
800093f6:	70 0b       	ld.w	r11,r8[0x0]
800093f8:	c8 af       	rcall	8000930c <_malloc_trim_r>
800093fa:	0e 9c       	mov	r12,r7
800093fc:	fe b0 ee 7a 	rcall	800070f0 <__malloc_unlock>
80009400:	d8 22       	popm	r4-r7,pc
80009402:	93 1b       	st.w	r9[0x4],r11
80009404:	58 0c       	cp.w	r12,0
80009406:	c0 30       	breq	8000940c <_free_r+0x70>
80009408:	30 0c       	mov	r12,0
8000940a:	c1 08       	rjmp	8000942a <_free_r+0x8e>
8000940c:	6c 0e       	ld.w	lr,r6[0x0]
8000940e:	f4 c5 ff f8 	sub	r5,r10,-8
80009412:	1c 16       	sub	r6,lr
80009414:	1c 08       	add	r8,lr
80009416:	6c 2e       	ld.w	lr,r6[0x8]
80009418:	0a 3e       	cp.w	lr,r5
8000941a:	f9 bc 00 01 	moveq	r12,1
8000941e:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009422:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009426:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000942a:	f2 0b 00 0e 	add	lr,r9,r11
8000942e:	7c 1e       	ld.w	lr,lr[0x4]
80009430:	ed be 00 00 	bld	lr,0x0
80009434:	c1 30       	breq	8000945a <_free_r+0xbe>
80009436:	16 08       	add	r8,r11
80009438:	58 0c       	cp.w	r12,0
8000943a:	c0 c1       	brne	80009452 <_free_r+0xb6>
8000943c:	31 8e       	mov	lr,24
8000943e:	72 2b       	ld.w	r11,r9[0x8]
80009440:	2f 8e       	sub	lr,-8
80009442:	1c 3b       	cp.w	r11,lr
80009444:	c0 71       	brne	80009452 <_free_r+0xb6>
80009446:	97 36       	st.w	r11[0xc],r6
80009448:	97 26       	st.w	r11[0x8],r6
8000944a:	8d 2b       	st.w	r6[0x8],r11
8000944c:	8d 3b       	st.w	r6[0xc],r11
8000944e:	30 1c       	mov	r12,1
80009450:	c0 58       	rjmp	8000945a <_free_r+0xbe>
80009452:	72 2b       	ld.w	r11,r9[0x8]
80009454:	72 39       	ld.w	r9,r9[0xc]
80009456:	93 2b       	st.w	r9[0x8],r11
80009458:	97 39       	st.w	r11[0xc],r9
8000945a:	10 99       	mov	r9,r8
8000945c:	ec 08 09 08 	st.w	r6[r8],r8
80009460:	a1 a9       	sbr	r9,0x0
80009462:	8d 19       	st.w	r6[0x4],r9
80009464:	58 0c       	cp.w	r12,0
80009466:	c5 a1       	brne	8000951a <_free_r+0x17e>
80009468:	e0 48 01 ff 	cp.w	r8,511
8000946c:	e0 8b 00 13 	brhi	80009492 <_free_r+0xf6>
80009470:	a3 98       	lsr	r8,0x3
80009472:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009476:	72 2b       	ld.w	r11,r9[0x8]
80009478:	8d 39       	st.w	r6[0xc],r9
8000947a:	8d 2b       	st.w	r6[0x8],r11
8000947c:	97 36       	st.w	r11[0xc],r6
8000947e:	93 26       	st.w	r9[0x8],r6
80009480:	a3 48       	asr	r8,0x2
80009482:	74 19       	ld.w	r9,r10[0x4]
80009484:	30 1b       	mov	r11,1
80009486:	f6 08 09 48 	lsl	r8,r11,r8
8000948a:	f3 e8 10 08 	or	r8,r9,r8
8000948e:	95 18       	st.w	r10[0x4],r8
80009490:	c4 58       	rjmp	8000951a <_free_r+0x17e>
80009492:	f0 0b 16 09 	lsr	r11,r8,0x9
80009496:	58 4b       	cp.w	r11,4
80009498:	e0 8b 00 06 	brhi	800094a4 <_free_r+0x108>
8000949c:	f0 0b 16 06 	lsr	r11,r8,0x6
800094a0:	2c 8b       	sub	r11,-56
800094a2:	c2 08       	rjmp	800094e2 <_free_r+0x146>
800094a4:	59 4b       	cp.w	r11,20
800094a6:	e0 8b 00 04 	brhi	800094ae <_free_r+0x112>
800094aa:	2a 5b       	sub	r11,-91
800094ac:	c1 b8       	rjmp	800094e2 <_free_r+0x146>
800094ae:	e0 4b 00 54 	cp.w	r11,84
800094b2:	e0 8b 00 06 	brhi	800094be <_free_r+0x122>
800094b6:	f0 0b 16 0c 	lsr	r11,r8,0xc
800094ba:	29 2b       	sub	r11,-110
800094bc:	c1 38       	rjmp	800094e2 <_free_r+0x146>
800094be:	e0 4b 01 54 	cp.w	r11,340
800094c2:	e0 8b 00 06 	brhi	800094ce <_free_r+0x132>
800094c6:	f0 0b 16 0f 	lsr	r11,r8,0xf
800094ca:	28 9b       	sub	r11,-119
800094cc:	c0 b8       	rjmp	800094e2 <_free_r+0x146>
800094ce:	e0 4b 05 54 	cp.w	r11,1364
800094d2:	e0 88 00 05 	brls	800094dc <_free_r+0x140>
800094d6:	37 eb       	mov	r11,126
800094d8:	c0 58       	rjmp	800094e2 <_free_r+0x146>
800094da:	d7 03       	nop
800094dc:	f0 0b 16 12 	lsr	r11,r8,0x12
800094e0:	28 4b       	sub	r11,-124
800094e2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
800094e6:	78 29       	ld.w	r9,r12[0x8]
800094e8:	18 39       	cp.w	r9,r12
800094ea:	c0 e1       	brne	80009506 <_free_r+0x16a>
800094ec:	74 18       	ld.w	r8,r10[0x4]
800094ee:	a3 4b       	asr	r11,0x2
800094f0:	30 1c       	mov	r12,1
800094f2:	f8 0b 09 4b 	lsl	r11,r12,r11
800094f6:	f1 eb 10 0b 	or	r11,r8,r11
800094fa:	12 98       	mov	r8,r9
800094fc:	95 1b       	st.w	r10[0x4],r11
800094fe:	c0 a8       	rjmp	80009512 <_free_r+0x176>
80009500:	72 29       	ld.w	r9,r9[0x8]
80009502:	18 39       	cp.w	r9,r12
80009504:	c0 60       	breq	80009510 <_free_r+0x174>
80009506:	72 1a       	ld.w	r10,r9[0x4]
80009508:	e0 1a ff fc 	andl	r10,0xfffc
8000950c:	14 38       	cp.w	r8,r10
8000950e:	cf 93       	brcs	80009500 <_free_r+0x164>
80009510:	72 38       	ld.w	r8,r9[0xc]
80009512:	8d 38       	st.w	r6[0xc],r8
80009514:	8d 29       	st.w	r6[0x8],r9
80009516:	93 36       	st.w	r9[0xc],r6
80009518:	91 26       	st.w	r8[0x8],r6
8000951a:	0e 9c       	mov	r12,r7
8000951c:	fe b0 ed ea 	rcall	800070f0 <__malloc_unlock>
80009520:	d8 22       	popm	r4-r7,pc
80009522:	d7 03       	nop

Disassembly of section .exception:

80009600 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80009600:	c0 08       	rjmp	80009600 <_evba>
	...

80009604 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80009604:	c0 08       	rjmp	80009604 <_handle_TLB_Multiple_Hit>
	...

80009608 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80009608:	c0 08       	rjmp	80009608 <_handle_Bus_Error_Data_Fetch>
	...

8000960c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000960c:	c0 08       	rjmp	8000960c <_handle_Bus_Error_Instruction_Fetch>
	...

80009610 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80009610:	c0 08       	rjmp	80009610 <_handle_NMI>
	...

80009614 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80009614:	c0 08       	rjmp	80009614 <_handle_Instruction_Address>
	...

80009618 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80009618:	c0 08       	rjmp	80009618 <_handle_ITLB_Protection>
	...

8000961c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000961c:	c0 08       	rjmp	8000961c <_handle_Breakpoint>
	...

80009620 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80009620:	c0 08       	rjmp	80009620 <_handle_Illegal_Opcode>
	...

80009624 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80009624:	c0 08       	rjmp	80009624 <_handle_Unimplemented_Instruction>
	...

80009628 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80009628:	c0 08       	rjmp	80009628 <_handle_Privilege_Violation>
	...

8000962c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000962c:	c0 08       	rjmp	8000962c <_handle_Floating_Point>
	...

80009630 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80009630:	c0 08       	rjmp	80009630 <_handle_Coprocessor_Absent>
	...

80009634 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80009634:	c0 08       	rjmp	80009634 <_handle_Data_Address_Read>
	...

80009638 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80009638:	c0 08       	rjmp	80009638 <_handle_Data_Address_Write>
	...

8000963c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000963c:	c0 08       	rjmp	8000963c <_handle_DTLB_Protection_Read>
	...

80009640 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80009640:	c0 08       	rjmp	80009640 <_handle_DTLB_Protection_Write>
	...

80009644 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80009644:	c0 08       	rjmp	80009644 <_handle_DTLB_Modified>
	...

80009650 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80009650:	c0 08       	rjmp	80009650 <_handle_ITLB_Miss>
	...

80009660 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80009660:	c0 08       	rjmp	80009660 <_handle_DTLB_Miss_Read>
	...

80009670 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80009670:	c0 08       	rjmp	80009670 <_handle_DTLB_Miss_Write>
	...

80009700 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80009700:	fe cf 27 64 	sub	pc,pc,10084

80009704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80009704:	30 0c       	mov	r12,0
80009706:	fe b0 f5 a7 	rcall	80008254 <_get_interrupt_handler>
8000970a:	58 0c       	cp.w	r12,0
8000970c:	f8 0f 17 10 	movne	pc,r12
80009710:	d6 03       	rete

80009712 <_int1>:
80009712:	30 1c       	mov	r12,1
80009714:	fe b0 f5 a0 	rcall	80008254 <_get_interrupt_handler>
80009718:	58 0c       	cp.w	r12,0
8000971a:	f8 0f 17 10 	movne	pc,r12
8000971e:	d6 03       	rete

80009720 <_int2>:
80009720:	30 2c       	mov	r12,2
80009722:	fe b0 f5 99 	rcall	80008254 <_get_interrupt_handler>
80009726:	58 0c       	cp.w	r12,0
80009728:	f8 0f 17 10 	movne	pc,r12
8000972c:	d6 03       	rete

8000972e <_int3>:
8000972e:	30 3c       	mov	r12,3
80009730:	fe b0 f5 92 	rcall	80008254 <_get_interrupt_handler>
80009734:	58 0c       	cp.w	r12,0
80009736:	f8 0f 17 10 	movne	pc,r12
8000973a:	d6 03       	rete
8000973c:	d7 03       	nop
8000973e:	d7 03       	nop
80009740:	d7 03       	nop
80009742:	d7 03       	nop
80009744:	d7 03       	nop
80009746:	d7 03       	nop
80009748:	d7 03       	nop
8000974a:	d7 03       	nop
8000974c:	d7 03       	nop
8000974e:	d7 03       	nop
80009750:	d7 03       	nop
80009752:	d7 03       	nop
80009754:	d7 03       	nop
80009756:	d7 03       	nop
80009758:	d7 03       	nop
8000975a:	d7 03       	nop
8000975c:	d7 03       	nop
8000975e:	d7 03       	nop
80009760:	d7 03       	nop
80009762:	d7 03       	nop
80009764:	d7 03       	nop
80009766:	d7 03       	nop
80009768:	d7 03       	nop
8000976a:	d7 03       	nop
8000976c:	d7 03       	nop
8000976e:	d7 03       	nop
80009770:	d7 03       	nop
80009772:	d7 03       	nop
80009774:	d7 03       	nop
80009776:	d7 03       	nop
80009778:	d7 03       	nop
8000977a:	d7 03       	nop
8000977c:	d7 03       	nop
8000977e:	d7 03       	nop
80009780:	d7 03       	nop
80009782:	d7 03       	nop
80009784:	d7 03       	nop
80009786:	d7 03       	nop
80009788:	d7 03       	nop
8000978a:	d7 03       	nop
8000978c:	d7 03       	nop
8000978e:	d7 03       	nop
80009790:	d7 03       	nop
80009792:	d7 03       	nop
80009794:	d7 03       	nop
80009796:	d7 03       	nop
80009798:	d7 03       	nop
8000979a:	d7 03       	nop
8000979c:	d7 03       	nop
8000979e:	d7 03       	nop
800097a0:	d7 03       	nop
800097a2:	d7 03       	nop
800097a4:	d7 03       	nop
800097a6:	d7 03       	nop
800097a8:	d7 03       	nop
800097aa:	d7 03       	nop
800097ac:	d7 03       	nop
800097ae:	d7 03       	nop
800097b0:	d7 03       	nop
800097b2:	d7 03       	nop
800097b4:	d7 03       	nop
800097b6:	d7 03       	nop
800097b8:	d7 03       	nop
800097ba:	d7 03       	nop
800097bc:	d7 03       	nop
800097be:	d7 03       	nop
800097c0:	d7 03       	nop
800097c2:	d7 03       	nop
800097c4:	d7 03       	nop
800097c6:	d7 03       	nop
800097c8:	d7 03       	nop
800097ca:	d7 03       	nop
800097cc:	d7 03       	nop
800097ce:	d7 03       	nop
800097d0:	d7 03       	nop
800097d2:	d7 03       	nop
800097d4:	d7 03       	nop
800097d6:	d7 03       	nop
800097d8:	d7 03       	nop
800097da:	d7 03       	nop
800097dc:	d7 03       	nop
800097de:	d7 03       	nop
800097e0:	d7 03       	nop
800097e2:	d7 03       	nop
800097e4:	d7 03       	nop
800097e6:	d7 03       	nop
800097e8:	d7 03       	nop
800097ea:	d7 03       	nop
800097ec:	d7 03       	nop
800097ee:	d7 03       	nop
800097f0:	d7 03       	nop
800097f2:	d7 03       	nop
800097f4:	d7 03       	nop
800097f6:	d7 03       	nop
800097f8:	d7 03       	nop
800097fa:	d7 03       	nop
800097fc:	d7 03       	nop
800097fe:	d7 03       	nop
