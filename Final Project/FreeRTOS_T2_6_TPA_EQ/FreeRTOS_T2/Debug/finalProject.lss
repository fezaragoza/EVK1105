
finalProject.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00008378  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000a400  8000a400  0000a800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00010b64  8000a600  8000a600  0000aa00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8001b164  8001b164  0001b564  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00007490  00000008  8001b168  0001b808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000aa8  00007498  00007498  00000000  2**2
                  ALLOC
  9 .heap         000070c0  00007f40  00007f40  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00022c98  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001980  00000000  00000000  00022cc8  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000452f  00000000  00000000  00024648  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   000256a1  00000000  00000000  00028b77  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000059ea  00000000  00000000  0004e218  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0001515c  00000000  00000000  00053c02  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000491c  00000000  00000000  00068d60  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008974  00000000  00000000  0006d67c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000ddb8  00000000  00000000  00075ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 01c83d59  00000000  00000000  00083da8  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001bf0  00000000  00000000  01d07b08  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	86 48       	ld.sh	r8,r3[0x8]

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 99 c0 	sub	pc,pc,-26176

Disassembly of section .text:

8000200c <et024006_SetLimits>:
8000200c:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002010:	fc 1e c0 00 	movh	lr,0xc000
80002014:	30 28       	mov	r8,2
80002016:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002018:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
8000201c:	fc 18 c0 20 	movh	r8,0xc020
80002020:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002022:	30 37       	mov	r7,3
80002024:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002026:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002028:	30 4c       	mov	r12,4
8000202a:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000202c:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80002030:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002032:	30 5c       	mov	r12,5
80002034:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002036:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002038:	30 6a       	mov	r10,6
8000203a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000203c:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80002040:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002042:	30 7a       	mov	r10,7
80002044:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002046:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002048:	30 8a       	mov	r10,8
8000204a:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000204c:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80002050:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002052:	30 9a       	mov	r10,9
80002054:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002056:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80002058:	e3 cd 80 80 	ldm	sp++,r7,pc

8000205c <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000205c:	fc 19 c0 00 	movh	r9,0xc000
80002060:	30 28       	mov	r8,2
80002062:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002064:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80002068:	fc 18 c0 20 	movh	r8,0xc020
8000206c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000206e:	30 3a       	mov	r10,3
80002070:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002072:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002074:	30 6a       	mov	r10,6
80002076:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002078:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
8000207c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000207e:	30 7a       	mov	r10,7
80002080:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002082:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80002084:	5e fc       	retal	r12
80002086:	d7 03       	nop

80002088 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80002088:	eb cd 40 80 	pushm	r7,lr
8000208c:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
8000208e:	5c 7b       	castu.h	r11
80002090:	5c 7c       	castu.h	r12
80002092:	f0 1f 00 06 	mcall	800020a8 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002096:	32 29       	mov	r9,34
80002098:	fc 18 c0 00 	movh	r8,0xc000
8000209c:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000209e:	fc 18 c0 20 	movh	r8,0xc020
800020a2:	b0 07       	st.h	r8[0x0],r7
#endif

}
800020a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	20 5c       	sub	r12,5

800020ac <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
800020ac:	d4 31       	pushm	r0-r7,lr
800020ae:	20 dd       	sub	sp,52
800020b0:	18 97       	mov	r7,r12
800020b2:	50 6b       	stdsp	sp[0x18],r11
800020b4:	50 8a       	stdsp	sp[0x20],r10
800020b6:	50 29       	stdsp	sp[0x8],r9
800020b8:	10 94       	mov	r4,r8
800020ba:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
800020bc:	19 89       	ld.ub	r9,r12[0x0]
800020be:	30 08       	mov	r8,0
800020c0:	f0 09 18 00 	cp.b	r9,r8
800020c4:	e0 80 01 0c 	breq	800022dc <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800020c8:	16 98       	mov	r8,r11
800020ca:	11 3a       	ld.ub	r10,r8++
800020cc:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
800020ce:	11 89       	ld.ub	r9,r8[0x0]
800020d0:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
800020d2:	11 98       	ld.ub	r8,r8[0x1]
800020d4:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
800020d6:	5b f3       	cp.w	r3,-1
800020d8:	e0 81 00 8d 	brne	800021f2 <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800020dc:	e0 69 00 ef 	mov	r9,239
800020e0:	e0 6a 01 3f 	mov	r10,319
800020e4:	30 0b       	mov	r11,0
800020e6:	16 9c       	mov	r12,r11
800020e8:	f0 1f 00 7e 	mcall	800022e0 <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800020ec:	40 58       	lddsp	r8,sp[0x14]
800020ee:	50 c8       	stdsp	sp[0x30],r8
800020f0:	f0 08 00 18 	add	r8,r8,r8<<0x1
800020f4:	a5 78       	lsl	r8,0x5
800020f6:	40 69       	lddsp	r9,sp[0x18]
800020f8:	10 09       	add	r9,r8
800020fa:	50 b9       	stdsp	sp[0x2c],r9
800020fc:	ee c8 ff ff 	sub	r8,r7,-1
80002100:	50 98       	stdsp	sp[0x24],r8
80002102:	40 8a       	lddsp	r10,sp[0x20]
80002104:	5c 8a       	casts.h	r10
80002106:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002108:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000210a:	08 90       	mov	r0,r4
8000210c:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
8000210e:	40 99       	lddsp	r9,sp[0x24]
80002110:	f3 38 ff ff 	ld.ub	r8,r9[-1]
80002114:	30 aa       	mov	r10,10
80002116:	f4 08 18 00 	cp.b	r8,r10
8000211a:	c0 b1       	brne	80002130 <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
8000211c:	40 28       	lddsp	r8,sp[0x8]
8000211e:	40 39       	lddsp	r9,sp[0xc]
80002120:	12 08       	add	r8,r9
80002122:	5c 88       	casts.h	r8
80002124:	50 28       	stdsp	sp[0x8],r8
80002126:	40 98       	lddsp	r8,sp[0x24]
80002128:	40 8a       	lddsp	r10,sp[0x20]
8000212a:	5c 8a       	casts.h	r10
8000212c:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000212e:	c5 a8       	rjmp	800021e2 <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
80002130:	30 99       	mov	r9,9
80002132:	f2 08 18 00 	cp.b	r8,r9
80002136:	c0 81       	brne	80002146 <et024006_PrintString+0x9a>
        x += xfont;
80002138:	40 a8       	lddsp	r8,sp[0x28]
8000213a:	40 49       	lddsp	r9,sp[0x10]
8000213c:	12 08       	add	r8,r9
8000213e:	5c 88       	casts.h	r8
80002140:	50 a8       	stdsp	sp[0x28],r8
80002142:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80002144:	c4 f8       	rjmp	800021e2 <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80002146:	f0 ca 00 20 	sub	r10,r8,32
8000214a:	35 f9       	mov	r9,95
8000214c:	f2 0a 18 00 	cp.b	r10,r9
80002150:	e0 88 00 04 	brls	80002158 <et024006_PrintString+0xac>
80002154:	40 b5       	lddsp	r5,sp[0x2c]
80002156:	c0 a8       	rjmp	8000216a <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80002158:	22 08       	sub	r8,32
8000215a:	40 ca       	lddsp	r10,sp[0x30]
8000215c:	f0 0a 02 45 	mul	r5,r8,r10
80002160:	40 59       	lddsp	r9,sp[0x14]
80002162:	12 05       	add	r5,r9
80002164:	40 68       	lddsp	r8,sp[0x18]
80002166:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000216a:	40 22       	lddsp	r2,sp[0x8]
8000216c:	5c 72       	castu.h	r2
8000216e:	40 3a       	lddsp	r10,sp[0xc]
80002170:	e4 0a 00 0a 	add	r10,r2,r10
80002174:	50 1a       	stdsp	sp[0x4],r10
80002176:	04 3a       	cp.w	r10,r2
80002178:	e0 8a 00 2f 	brle	800021d6 <et024006_PrintString+0x12a>
8000217c:	40 21       	lddsp	r1,sp[0x8]
8000217e:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80002180:	40 a9       	lddsp	r9,sp[0x28]
80002182:	5c 79       	castu.h	r9
80002184:	50 09       	stdsp	sp[0x0],r9
80002186:	12 94       	mov	r4,r9
80002188:	40 48       	lddsp	r8,sp[0x10]
8000218a:	10 04       	add	r4,r8
8000218c:	40 aa       	lddsp	r10,sp[0x28]
8000218e:	5c 8a       	casts.h	r10
80002190:	50 7a       	stdsp	sp[0x1c],r10
80002192:	c1 b8       	rjmp	800021c8 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80002194:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002196:	0b 88       	ld.ub	r8,r5[0x0]
80002198:	ed e8 00 08 	and	r8,r6,r8
8000219c:	e6 08 18 00 	cp.b	r8,r3
800021a0:	c0 50       	breq	800021aa <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800021a2:	00 9a       	mov	r10,r0
800021a4:	04 9b       	mov	r11,r2
800021a6:	f0 1f 00 50 	mcall	800022e4 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021aa:	2f f7       	sub	r7,-1
800021ac:	5c 87       	casts.h	r7
800021ae:	0e 9c       	mov	r12,r7
800021b0:	5c 7c       	castu.h	r12
800021b2:	08 3c       	cp.w	r12,r4
800021b4:	cf 05       	brlt	80002194 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800021b6:	2f f1       	sub	r1,-1
800021b8:	5c 81       	casts.h	r1
800021ba:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
800021be:	40 19       	lddsp	r9,sp[0x4]
800021c0:	04 39       	cp.w	r9,r2
800021c2:	e0 8a 00 0a 	brle	800021d6 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800021c6:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021c8:	40 0c       	lddsp	r12,sp[0x0]
800021ca:	08 3c       	cp.w	r12,r4
800021cc:	cf 54       	brge	800021b6 <et024006_PrintString+0x10a>
800021ce:	40 77       	lddsp	r7,sp[0x1c]
800021d0:	e0 66 00 80 	mov	r6,128
800021d4:	ce 1b       	rjmp	80002196 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800021d6:	40 a8       	lddsp	r8,sp[0x28]
800021d8:	40 4a       	lddsp	r10,sp[0x10]
800021da:	14 08       	add	r8,r10
800021dc:	5c 88       	casts.h	r8
800021de:	50 a8       	stdsp	sp[0x28],r8
800021e0:	40 98       	lddsp	r8,sp[0x24]
800021e2:	40 99       	lddsp	r9,sp[0x24]
800021e4:	2f f9       	sub	r9,-1
800021e6:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800021e8:	11 88       	ld.ub	r8,r8[0x0]
800021ea:	e6 08 18 00 	cp.b	r8,r3
800021ee:	c9 01       	brne	8000210e <et024006_PrintString+0x62>
800021f0:	c7 68       	rjmp	800022dc <et024006_PrintString+0x230>
800021f2:	f8 c8 ff ff 	sub	r8,r12,-1
800021f6:	50 08       	stdsp	sp[0x0],r8
800021f8:	40 8c       	lddsp	r12,sp[0x20]
800021fa:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800021fc:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800021fe:	5c 83       	casts.h	r3
80002200:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80002204:	40 0a       	lddsp	r10,sp[0x0]
80002206:	f5 31 ff ff 	ld.ub	r1,r10[-1]
8000220a:	30 a8       	mov	r8,10
8000220c:	f0 01 18 00 	cp.b	r1,r8
80002210:	c0 b1       	brne	80002226 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
80002212:	40 28       	lddsp	r8,sp[0x8]
80002214:	40 39       	lddsp	r9,sp[0xc]
80002216:	12 08       	add	r8,r9
80002218:	5c 88       	casts.h	r8
8000221a:	50 28       	stdsp	sp[0x8],r8
8000221c:	14 98       	mov	r8,r10
8000221e:	40 8a       	lddsp	r10,sp[0x20]
80002220:	5c 8a       	casts.h	r10
80002222:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80002224:	c5 28       	rjmp	800022c8 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80002226:	30 98       	mov	r8,9
80002228:	f0 01 18 00 	cp.b	r1,r8
8000222c:	c0 71       	brne	8000223a <et024006_PrintString+0x18e>
        x += xfont;
8000222e:	40 49       	lddsp	r9,sp[0x10]
80002230:	12 0c       	add	r12,r9
80002232:	5c 8c       	casts.h	r12
80002234:	50 1c       	stdsp	sp[0x4],r12
80002236:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
80002238:	c4 88       	rjmp	800022c8 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000223a:	40 32       	lddsp	r2,sp[0xc]
8000223c:	40 47       	lddsp	r7,sp[0x10]
8000223e:	f8 07 00 08 	add	r8,r12,r7
80002242:	5c 88       	casts.h	r8
80002244:	50 18       	stdsp	sp[0x4],r8
80002246:	04 99       	mov	r9,r2
80002248:	20 19       	sub	r9,1
8000224a:	40 28       	lddsp	r8,sp[0x8]
8000224c:	10 09       	add	r9,r8
8000224e:	40 1a       	lddsp	r10,sp[0x4]
80002250:	20 1a       	sub	r10,1
80002252:	5c 79       	castu.h	r9
80002254:	5c 7a       	castu.h	r10
80002256:	10 9b       	mov	r11,r8
80002258:	5c 7b       	castu.h	r11
8000225a:	5c 7c       	castu.h	r12
8000225c:	f0 1f 00 21 	mcall	800022e0 <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002260:	32 29       	mov	r9,34
80002262:	fc 18 c0 00 	movh	r8,0xc000
80002266:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80002268:	40 3a       	lddsp	r10,sp[0xc]
8000226a:	58 0a       	cp.w	r10,0
8000226c:	c2 d0       	breq	800022c6 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
8000226e:	e2 ce 00 20 	sub	lr,r1,32
80002272:	40 59       	lddsp	r9,sp[0x14]
80002274:	f2 0e 02 4e 	mul	lr,r9,lr
80002278:	12 0e       	add	lr,r9
8000227a:	40 68       	lddsp	r8,sp[0x18]
8000227c:	f0 0e 00 0e 	add	lr,r8,lr
80002280:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80002282:	e0 60 00 80 	mov	r0,128
80002286:	18 91       	mov	r1,r12
80002288:	c1 98       	rjmp	800022ba <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
8000228a:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000228c:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
80002290:	ec 0a 18 00 	cp.b	r10,r6
80002294:	e8 0a 17 10 	movne	r10,r4
80002298:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000229c:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800022a0:	2f f8       	sub	r8,-1
800022a2:	5c 88       	casts.h	r8
800022a4:	f0 07 19 00 	cp.h	r7,r8
800022a8:	fe 9b ff f1 	brhi	8000228a <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800022ac:	2f fc       	sub	r12,-1
800022ae:	5c 8c       	casts.h	r12
800022b0:	f8 02 19 00 	cp.h	r2,r12
800022b4:	e0 88 00 09 	brls	800022c6 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
800022b8:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800022ba:	58 07       	cp.w	r7,0
800022bc:	cf 80       	breq	800022ac <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
800022be:	1d 8b       	ld.ub	r11,lr[0x0]
800022c0:	00 99       	mov	r9,r0
800022c2:	02 98       	mov	r8,r1
800022c4:	ce 4b       	rjmp	8000228c <et024006_PrintString+0x1e0>
800022c6:	40 08       	lddsp	r8,sp[0x0]
800022c8:	40 09       	lddsp	r9,sp[0x0]
800022ca:	2f f9       	sub	r9,-1
800022cc:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800022ce:	11 88       	ld.ub	r8,r8[0x0]
800022d0:	ec 08 18 00 	cp.b	r8,r6
800022d4:	c0 40       	breq	800022dc <et024006_PrintString+0x230>
800022d6:	40 1c       	lddsp	r12,sp[0x4]
800022d8:	5c 8c       	casts.h	r12
800022da:	c9 5b       	rjmp	80002204 <et024006_PrintString+0x158>
  }
}
800022dc:	2f 3d       	sub	sp,-52
800022de:	d8 32       	popm	r0-r7,pc
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	20 0c       	sub	r12,0
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	20 88       	sub	r8,8

800022e8 <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800022e8:	32 29       	mov	r9,34
800022ea:	fc 18 c0 00 	movh	r8,0xc000
800022ee:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800022f0:	58 7b       	cp.w	r11,7
800022f2:	e0 88 00 13 	brls	80002318 <et024006_DuplicatePixel+0x30>
800022f6:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
800022f8:	fc 18 c0 20 	movh	r8,0xc020
800022fc:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800022fe:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002300:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002302:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002304:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002306:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002308:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000230a:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
8000230c:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000230e:	58 79       	cp.w	r9,7
80002310:	fe 9b ff f6 	brhi	800022fc <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80002314:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002318:	58 0b       	cp.w	r11,0
8000231a:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
8000231c:	fc 18 c0 20 	movh	r8,0xc020
80002320:	b0 0c       	st.h	r8[0x0],r12
    --count;
80002322:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002324:	cf e1       	brne	80002320 <et024006_DuplicatePixel+0x38>
80002326:	5e fc       	retal	r12

80002328 <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80002328:	eb cd 40 e0 	pushm	r5-r7,lr
8000232c:	14 97       	mov	r7,r10
8000232e:	12 96       	mov	r6,r9
80002330:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80002332:	f6 c9 00 01 	sub	r9,r11,1
80002336:	0c 09       	add	r9,r6
80002338:	f8 ca 00 01 	sub	r10,r12,1
8000233c:	0e 0a       	add	r10,r7
8000233e:	5c 79       	castu.h	r9
80002340:	5c 7a       	castu.h	r10
80002342:	5c 7b       	castu.h	r11
80002344:	5c 7c       	castu.h	r12
80002346:	f0 1f 00 07 	mcall	80002360 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000234a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000234e:	5c 77       	castu.h	r7
80002350:	af 3b       	mul	r11,r7
80002352:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80002356:	f0 1f 00 04 	mcall	80002364 <et024006_DrawFilledRect+0x3c>
}
8000235a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	20 0c       	sub	r12,0
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	22 e8       	sub	r8,46

80002368 <et024006_DrawVertLine>:
  et024006_DrawFilledRect( x, y, length, 1, color );
}


void et024006_DrawVertLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
80002368:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, 1, length, color );
8000236a:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
8000236e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80002372:	30 1a       	mov	r10,1
80002374:	5c 7b       	castu.h	r11
80002376:	5c 7c       	castu.h	r12
80002378:	f0 1f 00 02 	mcall	80002380 <et024006_DrawVertLine+0x18>
}
8000237c:	d8 02       	popm	pc
8000237e:	00 00       	add	r0,r0
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	23 28       	sub	r8,50

80002384 <et024006_DrawHorizLine>:
  return color;
}


void et024006_DrawHorizLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
80002384:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, length, 1, color );
80002386:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
8000238a:	30 19       	mov	r9,1
8000238c:	5c 7a       	castu.h	r10
8000238e:	5c 7b       	castu.h	r11
80002390:	5c 7c       	castu.h	r12
80002392:	f0 1f 00 02 	mcall	80002398 <et024006_DrawHorizLine+0x14>
}
80002396:	d8 02       	popm	pc
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	23 28       	sub	r8,50

8000239c <et024006_CopyPixelsToScreen>:
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
{
8000239c:	eb cd 40 80 	pushm	r7,lr
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800023a0:	32 29       	mov	r9,34
800023a2:	fc 18 c0 00 	movh	r8,0xc000
800023a6:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
800023a8:	58 7b       	cp.w	r11,7
800023aa:	e0 88 00 23 	brls	800023f0 <et024006_CopyPixelsToScreen+0x54>
800023ae:	16 9a       	mov	r10,r11
800023b0:	18 98       	mov	r8,r12
  {
    *ET024006_PARAM_ADDR = *pixels++;
800023b2:	fc 19 c0 20 	movh	r9,0xc020
800023b6:	90 0e       	ld.sh	lr,r8[0x0]
800023b8:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023ba:	90 1e       	ld.sh	lr,r8[0x2]
800023bc:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023be:	90 2e       	ld.sh	lr,r8[0x4]
800023c0:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023c2:	90 3e       	ld.sh	lr,r8[0x6]
800023c4:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023c6:	90 4e       	ld.sh	lr,r8[0x8]
800023c8:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023ca:	90 5e       	ld.sh	lr,r8[0xa]
800023cc:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023ce:	90 6e       	ld.sh	lr,r8[0xc]
800023d0:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800023d2:	90 7e       	ld.sh	lr,r8[0xe]
800023d4:	b2 0e       	st.h	r9[0x0],lr
    }
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
800023d6:	2f 08       	sub	r8,-16
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
800023d8:	20 8a       	sub	r10,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
800023da:	58 7a       	cp.w	r10,7
800023dc:	fe 9b ff ed 	brhi	800023b6 <et024006_CopyPixelsToScreen+0x1a>
    }
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
800023e0:	20 8b       	sub	r11,8
800023e2:	f6 08 16 03 	lsr	r8,r11,0x3
800023e6:	2f f8       	sub	r8,-1
800023e8:	a5 68       	lsl	r8,0x4
800023ea:	10 0c       	add	r12,r8
800023ec:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
800023f0:	58 0b       	cp.w	r11,0
800023f2:	c0 70       	breq	80002400 <et024006_CopyPixelsToScreen+0x64>
  {
    *ET024006_PARAM_ADDR = *pixels;
800023f4:	fc 18 c0 20 	movh	r8,0xc020
800023f8:	19 19       	ld.sh	r9,r12++
800023fa:	b0 09       	st.h	r8[0x0],r9
    pixels++;
    count--;
800023fc:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
800023fe:	cf d1       	brne	800023f8 <et024006_CopyPixelsToScreen+0x5c>
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc

80002404 <et024006_PutPixmap>:
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
80002404:	eb cd 40 fe 	pushm	r1-r7,lr
80002408:	fa c4 ff e0 	sub	r4,sp,-32
8000240c:	18 97       	mov	r7,r12
8000240e:	16 95       	mov	r5,r11
80002410:	14 92       	mov	r2,r10
80002412:	12 91       	mov	r1,r9
80002414:	68 0b       	ld.w	r11,r4[0x0]
80002416:	68 13       	ld.w	r3,r4[0x4]
80002418:	68 26       	ld.w	r6,r4[0x8]
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits( x, y, x2, y2 );
8000241a:	f6 c9 00 01 	sub	r9,r11,1
8000241e:	0c 09       	add	r9,r6
80002420:	f0 ca 00 01 	sub	r10,r8,1
80002424:	06 0a       	add	r10,r3
80002426:	5c 79       	castu.h	r9
80002428:	5c 7a       	castu.h	r10
8000242a:	5c 7b       	castu.h	r11
8000242c:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80002430:	f0 1f 00 1d 	mcall	800024a4 <et024006_PutPixmap+0xa0>

  // Offset into pixmap.
  pixmap += map_x;
80002434:	f1 d2 c0 10 	bfextu	r8,r2,0x0,0x10
80002438:	ee 08 00 17 	add	r7,r7,r8<<0x1
  if (map_y > 0) {
8000243c:	58 01       	cp.w	r1,0
8000243e:	c0 70       	breq	8000244c <et024006_PutPixmap+0x48>
    pixmap += (uint32_t) map_y * map_width;
80002440:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002444:	a1 78       	lsl	r8,0x1
80002446:	5c 71       	castu.h	r1
80002448:	f0 01 03 47 	mac	r7,r8,r1
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000244c:	32 29       	mov	r9,34
8000244e:	fc 18 c0 00 	movh	r8,0xc000
80002452:	b0 09       	st.h	r8[0x0],r9
  }
  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
80002454:	e6 05 19 00 	cp.h	r5,r3
80002458:	5f 0a       	sreq	r10
8000245a:	30 08       	mov	r8,0
8000245c:	f0 02 19 00 	cp.h	r2,r8
80002460:	5f 09       	sreq	r9
80002462:	f5 e9 00 09 	and	r9,r10,r9
80002466:	f0 09 18 00 	cp.b	r9,r8
8000246a:	c0 51       	brne	80002474 <et024006_PutPixmap+0x70>
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
8000246c:	58 06       	cp.w	r6,0
8000246e:	c0 c1       	brne	80002486 <et024006_PutPixmap+0x82>
80002470:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
80002474:	5c 76       	castu.h	r6
80002476:	5c 73       	castu.h	r3
80002478:	ec 03 02 4b 	mul	r11,r6,r3
8000247c:	0e 9c       	mov	r12,r7
8000247e:	f0 1f 00 0b 	mcall	800024a8 <et024006_PutPixmap+0xa4>
80002482:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
80002486:	5c 75       	castu.h	r5
80002488:	a1 75       	lsl	r5,0x1
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
8000248a:	e9 d3 c0 10 	bfextu	r4,r3,0x0,0x10
8000248e:	08 9b       	mov	r11,r4
80002490:	0e 9c       	mov	r12,r7
80002492:	f0 1f 00 06 	mcall	800024a8 <et024006_PutPixmap+0xa4>
      pixmap += map_width;
80002496:	0a 07       	add	r7,r5
      --lines_left;
80002498:	20 16       	sub	r6,1
8000249a:	5c 86       	casts.h	r6
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
8000249c:	cf 91       	brne	8000248e <et024006_PutPixmap+0x8a>
8000249e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800024a2:	00 00       	add	r0,r0
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	20 0c       	sub	r12,0
800024a8:	80 00       	ld.sh	r0,r0[0x0]
800024aa:	23 9c       	sub	r12,57

800024ac <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024ac:	fc 19 c0 00 	movh	r9,0xc000
800024b0:	34 6a       	mov	r10,70
800024b2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024b4:	fc 18 c0 20 	movh	r8,0xc020
800024b8:	e0 6b 00 94 	mov	r11,148
800024bc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024be:	34 7b       	mov	r11,71
800024c0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024c2:	34 1b       	mov	r11,65
800024c4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024c6:	34 8b       	mov	r11,72
800024c8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024ca:	30 0b       	mov	r11,0
800024cc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024ce:	34 9b       	mov	r11,73
800024d0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024d2:	33 3b       	mov	r11,51
800024d4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024d6:	34 ab       	mov	r11,74
800024d8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024da:	32 5b       	mov	r11,37
800024dc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024de:	34 bb       	mov	r11,75
800024e0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024e2:	34 5b       	mov	r11,69
800024e4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024e6:	34 cb       	mov	r11,76
800024e8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024ea:	34 4b       	mov	r11,68
800024ec:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024ee:	34 db       	mov	r11,77
800024f0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024f2:	37 7b       	mov	r11,119
800024f4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024f6:	34 eb       	mov	r11,78
800024f8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024fa:	31 2b       	mov	r11,18
800024fc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024fe:	34 fb       	mov	r11,79
80002500:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002502:	e0 6b 00 cc 	mov	r11,204
80002506:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002508:	35 0b       	mov	r11,80
8000250a:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000250c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000250e:	35 1a       	mov	r10,81
80002510:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002512:	e0 69 00 82 	mov	r9,130
80002516:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
80002518:	5e fc       	retal	r12
8000251a:	d7 03       	nop

8000251c <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
8000251c:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
80002520:	fe f7 04 80 	ld.w	r7,pc[1152]
80002524:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
80002526:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80002528:	16 9c       	mov	r12,r11
8000252a:	f0 1f 01 1f 	mcall	800029a4 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
8000252e:	35 5c       	mov	r12,85
80002530:	f0 1f 01 1e 	mcall	800029a8 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
80002534:	30 2b       	mov	r11,2
80002536:	33 2c       	mov	r12,50
80002538:	f0 1f 01 1d 	mcall	800029ac <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
8000253c:	35 2c       	mov	r12,82
8000253e:	f0 1f 01 1d 	mcall	800029b0 <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
80002542:	35 2c       	mov	r12,82
80002544:	f0 1f 01 1c 	mcall	800029b4 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002548:	6e 07       	ld.w	r7,r7[0x0]
8000254a:	33 28       	mov	r8,50
8000254c:	ee 08 06 46 	mulu.d	r6,r7,r8
80002550:	ee 78 42 40 	mov	r8,1000000
80002554:	30 09       	mov	r9,0
80002556:	ee 7a 42 3f 	mov	r10,999999
8000255a:	30 0b       	mov	r11,0
8000255c:	ec 0a 00 0a 	add	r10,r6,r10
80002560:	ee 0b 00 4b 	adc	r11,r7,r11
80002564:	f0 1f 01 15 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002568:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000256c:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002570:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002574:	14 38       	cp.w	r8,r10
80002576:	e0 88 00 09 	brls	80002588 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000257a:	12 38       	cp.w	r8,r9
8000257c:	fe 98 ff fa 	brls	80002570 <et024006_Init+0x54>
80002580:	12 3a       	cp.w	r10,r9
80002582:	e0 83 00 a2 	brlo	800026c6 <et024006_Init+0x1aa>
80002586:	cf 5b       	rjmp	80002570 <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002588:	12 38       	cp.w	r8,r9
8000258a:	e0 8b 00 9e 	brhi	800026c6 <et024006_Init+0x1aa>
8000258e:	12 3a       	cp.w	r10,r9
80002590:	e0 83 00 9b 	brlo	800026c6 <et024006_Init+0x1aa>
80002594:	ce eb       	rjmp	80002570 <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002596:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000259a:	14 38       	cp.w	r8,r10
8000259c:	e0 88 00 09 	brls	800025ae <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025a0:	12 38       	cp.w	r8,r9
800025a2:	fe 98 ff fa 	brls	80002596 <et024006_Init+0x7a>
800025a6:	12 3a       	cp.w	r10,r9
800025a8:	e0 83 00 a9 	brlo	800026fa <et024006_Init+0x1de>
800025ac:	cf 5b       	rjmp	80002596 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025ae:	12 38       	cp.w	r8,r9
800025b0:	e0 8b 00 a5 	brhi	800026fa <et024006_Init+0x1de>
800025b4:	12 3a       	cp.w	r10,r9
800025b6:	e0 83 00 a2 	brlo	800026fa <et024006_Init+0x1de>
800025ba:	ce eb       	rjmp	80002596 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800025bc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025c0:	14 38       	cp.w	r8,r10
800025c2:	e0 88 00 09 	brls	800025d4 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025c6:	12 38       	cp.w	r8,r9
800025c8:	fe 98 ff fa 	brls	800025bc <et024006_Init+0xa0>
800025cc:	12 3a       	cp.w	r10,r9
800025ce:	e0 83 01 1e 	brlo	8000280a <et024006_Init+0x2ee>
800025d2:	cf 5b       	rjmp	800025bc <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025d4:	12 38       	cp.w	r8,r9
800025d6:	e0 8b 01 1a 	brhi	8000280a <et024006_Init+0x2ee>
800025da:	12 3a       	cp.w	r10,r9
800025dc:	e0 83 01 17 	brlo	8000280a <et024006_Init+0x2ee>
800025e0:	ce eb       	rjmp	800025bc <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800025e2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025e6:	14 38       	cp.w	r8,r10
800025e8:	e0 88 00 09 	brls	800025fa <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025ec:	12 38       	cp.w	r8,r9
800025ee:	fe 98 ff fa 	brls	800025e2 <et024006_Init+0xc6>
800025f2:	12 3a       	cp.w	r10,r9
800025f4:	e0 83 01 29 	brlo	80002846 <et024006_Init+0x32a>
800025f8:	cf 5b       	rjmp	800025e2 <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025fa:	12 38       	cp.w	r8,r9
800025fc:	e0 8b 01 25 	brhi	80002846 <et024006_Init+0x32a>
80002600:	12 3a       	cp.w	r10,r9
80002602:	e0 83 01 22 	brlo	80002846 <et024006_Init+0x32a>
80002606:	ce eb       	rjmp	800025e2 <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002608:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000260c:	14 38       	cp.w	r8,r10
8000260e:	e0 88 00 09 	brls	80002620 <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002612:	12 38       	cp.w	r8,r9
80002614:	fe 98 ff fa 	brls	80002608 <et024006_Init+0xec>
80002618:	12 3a       	cp.w	r10,r9
8000261a:	e0 83 01 35 	brlo	80002884 <et024006_Init+0x368>
8000261e:	cf 5b       	rjmp	80002608 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002620:	12 38       	cp.w	r8,r9
80002622:	e0 8b 01 31 	brhi	80002884 <et024006_Init+0x368>
80002626:	12 3a       	cp.w	r10,r9
80002628:	e0 83 01 2e 	brlo	80002884 <et024006_Init+0x368>
8000262c:	ce eb       	rjmp	80002608 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000262e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002632:	14 38       	cp.w	r8,r10
80002634:	e0 88 00 09 	brls	80002646 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002638:	12 38       	cp.w	r8,r9
8000263a:	fe 98 ff fa 	brls	8000262e <et024006_Init+0x112>
8000263e:	12 3a       	cp.w	r10,r9
80002640:	e0 83 01 40 	brlo	800028c0 <et024006_Init+0x3a4>
80002644:	cf 5b       	rjmp	8000262e <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002646:	12 38       	cp.w	r8,r9
80002648:	e0 8b 01 3c 	brhi	800028c0 <et024006_Init+0x3a4>
8000264c:	12 3a       	cp.w	r10,r9
8000264e:	e0 83 01 39 	brlo	800028c0 <et024006_Init+0x3a4>
80002652:	ce eb       	rjmp	8000262e <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002654:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002658:	14 38       	cp.w	r8,r10
8000265a:	e0 88 00 09 	brls	8000266c <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000265e:	12 38       	cp.w	r8,r9
80002660:	fe 98 ff fa 	brls	80002654 <et024006_Init+0x138>
80002664:	12 3a       	cp.w	r10,r9
80002666:	e0 83 01 4b 	brlo	800028fc <et024006_Init+0x3e0>
8000266a:	cf 5b       	rjmp	80002654 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000266c:	12 38       	cp.w	r8,r9
8000266e:	e0 8b 01 47 	brhi	800028fc <et024006_Init+0x3e0>
80002672:	12 3a       	cp.w	r10,r9
80002674:	e0 83 01 44 	brlo	800028fc <et024006_Init+0x3e0>
80002678:	ce eb       	rjmp	80002654 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000267a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000267e:	14 38       	cp.w	r8,r10
80002680:	e0 88 00 09 	brls	80002692 <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002684:	12 38       	cp.w	r8,r9
80002686:	fe 98 ff fa 	brls	8000267a <et024006_Init+0x15e>
8000268a:	12 3a       	cp.w	r10,r9
8000268c:	e0 83 01 56 	brlo	80002938 <et024006_Init+0x41c>
80002690:	cf 5b       	rjmp	8000267a <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002692:	12 38       	cp.w	r8,r9
80002694:	e0 8b 01 52 	brhi	80002938 <et024006_Init+0x41c>
80002698:	12 3a       	cp.w	r10,r9
8000269a:	e0 83 01 4f 	brlo	80002938 <et024006_Init+0x41c>
8000269e:	ce eb       	rjmp	8000267a <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026a0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026a4:	14 38       	cp.w	r8,r10
800026a6:	e0 88 00 09 	brls	800026b8 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800026aa:	12 38       	cp.w	r8,r9
800026ac:	fe 98 ff fa 	brls	800026a0 <et024006_Init+0x184>
800026b0:	12 3a       	cp.w	r10,r9
800026b2:	e0 83 01 64 	brlo	8000297a <et024006_Init+0x45e>
800026b6:	cf 5b       	rjmp	800026a0 <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800026b8:	12 38       	cp.w	r8,r9
800026ba:	e0 8b 01 60 	brhi	8000297a <et024006_Init+0x45e>
800026be:	12 3a       	cp.w	r10,r9
800026c0:	e0 83 01 5d 	brlo	8000297a <et024006_Init+0x45e>
800026c4:	ce eb       	rjmp	800026a0 <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800026c6:	35 2c       	mov	r12,82
800026c8:	f0 1f 00 ba 	mcall	800029b0 <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800026cc:	fe f8 02 d4 	ld.w	r8,pc[724]
800026d0:	70 07       	ld.w	r7,r8[0x0]
800026d2:	30 58       	mov	r8,5
800026d4:	ee 08 06 46 	mulu.d	r6,r7,r8
800026d8:	e0 68 03 e8 	mov	r8,1000
800026dc:	30 09       	mov	r9,0
800026de:	e0 6a 03 e7 	mov	r10,999
800026e2:	30 0b       	mov	r11,0
800026e4:	ec 0a 00 0a 	add	r10,r6,r10
800026e8:	ee 0b 00 4b 	adc	r11,r7,r11
800026ec:	f0 1f 00 b3 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800026f0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026f4:	f0 0a 00 0a 	add	r10,r8,r10
800026f8:	c4 fb       	rjmp	80002596 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
800026fa:	f0 1f 00 b1 	mcall	800029bc <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026fe:	fc 19 c0 00 	movh	r9,0xc000
80002702:	30 1a       	mov	r10,1
80002704:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002706:	fc 18 c0 20 	movh	r8,0xc020
8000270a:	30 6b       	mov	r11,6
8000270c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000270e:	33 ab       	mov	r11,58
80002710:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002712:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002714:	33 bb       	mov	r11,59
80002716:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002718:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000271a:	33 ca       	mov	r10,60
8000271c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000271e:	e0 6a 00 f0 	mov	r10,240
80002722:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002724:	33 db       	mov	r11,61
80002726:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002728:	30 07       	mov	r7,0
8000272a:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000272c:	33 eb       	mov	r11,62
8000272e:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002730:	33 8b       	mov	r11,56
80002732:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002734:	34 0c       	mov	r12,64
80002736:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002738:	30 fe       	mov	lr,15
8000273a:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000273c:	34 1e       	mov	lr,65
8000273e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002740:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002742:	32 7a       	mov	r10,39
80002744:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002746:	30 2a       	mov	r10,2
80002748:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000274a:	32 8e       	mov	lr,40
8000274c:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000274e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002750:	32 9e       	mov	lr,41
80002752:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002754:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002756:	32 ae       	mov	lr,42
80002758:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000275a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000275c:	32 ce       	mov	lr,44
8000275e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002760:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002762:	32 de       	mov	lr,45
80002764:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002766:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002768:	31 9a       	mov	r10,25
8000276a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000276c:	34 9a       	mov	r10,73
8000276e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002770:	e0 6a 00 93 	mov	r10,147
80002774:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002776:	30 8a       	mov	r10,8
80002778:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000277a:	31 6a       	mov	r10,22
8000277c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000277e:	36 8a       	mov	r10,104
80002780:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002782:	32 3a       	mov	r10,35
80002784:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002786:	e0 6a 00 95 	mov	r10,149
8000278a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000278c:	32 4e       	mov	lr,36
8000278e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002790:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002792:	32 5a       	mov	r10,37
80002794:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002796:	e0 6a 00 ff 	mov	r10,255
8000279a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000279c:	e0 6a 00 90 	mov	r10,144
800027a0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027a2:	37 fa       	mov	r10,127
800027a4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027a6:	33 5a       	mov	r10,53
800027a8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027aa:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027ac:	33 6a       	mov	r10,54
800027ae:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027b0:	37 8a       	mov	r10,120
800027b2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027b4:	31 da       	mov	r10,29
800027b6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027b8:	30 7a       	mov	r10,7
800027ba:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027bc:	31 ea       	mov	r10,30
800027be:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027c0:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027c2:	31 fa       	mov	r10,31
800027c4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027c6:	30 4a       	mov	r10,4
800027c8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027ca:	32 0a       	mov	r10,32
800027cc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027ce:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027d0:	34 4a       	mov	r10,68
800027d2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027d4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027d6:	34 5a       	mov	r10,69
800027d8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027da:	31 29       	mov	r9,18
800027dc:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800027de:	4f 18       	lddpc	r8,800029a0 <et024006_Init+0x484>
800027e0:	70 07       	ld.w	r7,r8[0x0]
800027e2:	30 a8       	mov	r8,10
800027e4:	ee 08 06 46 	mulu.d	r6,r7,r8
800027e8:	e0 68 03 e8 	mov	r8,1000
800027ec:	30 09       	mov	r9,0
800027ee:	e0 6a 03 e7 	mov	r10,999
800027f2:	30 0b       	mov	r11,0
800027f4:	ec 0a 00 0a 	add	r10,r6,r10
800027f8:	ee 0b 00 4b 	adc	r11,r7,r11
800027fc:	f0 1f 00 6f 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002800:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002804:	f0 0a 00 0a 	add	r10,r8,r10
80002808:	cd aa       	rjmp	800025bc <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000280a:	31 c9       	mov	r9,28
8000280c:	fc 18 c0 00 	movh	r8,0xc000
80002810:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002812:	30 49       	mov	r9,4
80002814:	fc 18 c0 20 	movh	r8,0xc020
80002818:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000281a:	4e 28       	lddpc	r8,800029a0 <et024006_Init+0x484>
8000281c:	70 07       	ld.w	r7,r8[0x0]
8000281e:	31 48       	mov	r8,20
80002820:	ee 08 06 46 	mulu.d	r6,r7,r8
80002824:	e0 68 03 e8 	mov	r8,1000
80002828:	30 09       	mov	r9,0
8000282a:	e0 6a 03 e7 	mov	r10,999
8000282e:	30 0b       	mov	r11,0
80002830:	ec 0a 00 0a 	add	r10,r6,r10
80002834:	ee 0b 00 4b 	adc	r11,r7,r11
80002838:	f0 1f 00 60 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000283c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002840:	f0 0a 00 0a 	add	r10,r8,r10
80002844:	cc fa       	rjmp	800025e2 <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002846:	34 39       	mov	r9,67
80002848:	fc 18 c0 00 	movh	r8,0xc000
8000284c:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000284e:	e0 69 00 80 	mov	r9,128
80002852:	fc 18 c0 20 	movh	r8,0xc020
80002856:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002858:	4d 28       	lddpc	r8,800029a0 <et024006_Init+0x484>
8000285a:	70 07       	ld.w	r7,r8[0x0]
8000285c:	30 58       	mov	r8,5
8000285e:	ee 08 06 46 	mulu.d	r6,r7,r8
80002862:	e0 68 03 e8 	mov	r8,1000
80002866:	30 09       	mov	r9,0
80002868:	e0 6a 03 e7 	mov	r10,999
8000286c:	30 0b       	mov	r11,0
8000286e:	ec 0a 00 0a 	add	r10,r6,r10
80002872:	ee 0b 00 4b 	adc	r11,r7,r11
80002876:	f0 1f 00 51 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000287a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000287e:	f0 0a 00 0a 	add	r10,r8,r10
80002882:	cc 3a       	rjmp	80002608 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002884:	31 b9       	mov	r9,27
80002886:	fc 18 c0 00 	movh	r8,0xc000
8000288a:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000288c:	30 89       	mov	r9,8
8000288e:	fc 18 c0 20 	movh	r8,0xc020
80002892:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002894:	4c 38       	lddpc	r8,800029a0 <et024006_Init+0x484>
80002896:	70 07       	ld.w	r7,r8[0x0]
80002898:	32 88       	mov	r8,40
8000289a:	ee 08 06 46 	mulu.d	r6,r7,r8
8000289e:	e0 68 03 e8 	mov	r8,1000
800028a2:	30 09       	mov	r9,0
800028a4:	e0 6a 03 e7 	mov	r10,999
800028a8:	30 0b       	mov	r11,0
800028aa:	ec 0a 00 0a 	add	r10,r6,r10
800028ae:	ee 0b 00 4b 	adc	r11,r7,r11
800028b2:	f0 1f 00 42 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800028b6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800028ba:	f0 0a 00 0a 	add	r10,r8,r10
800028be:	cb 8a       	rjmp	8000262e <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028c0:	31 b9       	mov	r9,27
800028c2:	fc 18 c0 00 	movh	r8,0xc000
800028c6:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800028c8:	31 09       	mov	r9,16
800028ca:	fc 18 c0 20 	movh	r8,0xc020
800028ce:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028d0:	4b 48       	lddpc	r8,800029a0 <et024006_Init+0x484>
800028d2:	70 07       	ld.w	r7,r8[0x0]
800028d4:	32 88       	mov	r8,40
800028d6:	ee 08 06 46 	mulu.d	r6,r7,r8
800028da:	e0 68 03 e8 	mov	r8,1000
800028de:	30 09       	mov	r9,0
800028e0:	e0 6a 03 e7 	mov	r10,999
800028e4:	30 0b       	mov	r11,0
800028e6:	ec 0a 00 0a 	add	r10,r6,r10
800028ea:	ee 0b 00 4b 	adc	r11,r7,r11
800028ee:	f0 1f 00 33 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800028f2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800028f6:	f0 0a 00 0a 	add	r10,r8,r10
800028fa:	ca da       	rjmp	80002654 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028fc:	32 69       	mov	r9,38
800028fe:	fc 18 c0 00 	movh	r8,0xc000
80002902:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002904:	30 49       	mov	r9,4
80002906:	fc 18 c0 20 	movh	r8,0xc020
8000290a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000290c:	4a 58       	lddpc	r8,800029a0 <et024006_Init+0x484>
8000290e:	70 07       	ld.w	r7,r8[0x0]
80002910:	32 88       	mov	r8,40
80002912:	ee 08 06 46 	mulu.d	r6,r7,r8
80002916:	e0 68 03 e8 	mov	r8,1000
8000291a:	30 09       	mov	r9,0
8000291c:	e0 6a 03 e7 	mov	r10,999
80002920:	30 0b       	mov	r11,0
80002922:	ec 0a 00 0a 	add	r10,r6,r10
80002926:	ee 0b 00 4b 	adc	r11,r7,r11
8000292a:	f0 1f 00 24 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000292e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002932:	f0 0a 00 0a 	add	r10,r8,r10
80002936:	ca 2a       	rjmp	8000267a <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002938:	fc 19 c0 00 	movh	r9,0xc000
8000293c:	32 6a       	mov	r10,38
8000293e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002940:	fc 18 c0 20 	movh	r8,0xc020
80002944:	32 4b       	mov	r11,36
80002946:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002948:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000294a:	32 c9       	mov	r9,44
8000294c:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000294e:	49 58       	lddpc	r8,800029a0 <et024006_Init+0x484>
80002950:	70 07       	ld.w	r7,r8[0x0]
80002952:	32 88       	mov	r8,40
80002954:	ee 08 06 46 	mulu.d	r6,r7,r8
80002958:	e0 68 03 e8 	mov	r8,1000
8000295c:	30 09       	mov	r9,0
8000295e:	e0 6a 03 e7 	mov	r10,999
80002962:	30 0b       	mov	r11,0
80002964:	ec 0a 00 0a 	add	r10,r6,r10
80002968:	ee 0b 00 4b 	adc	r11,r7,r11
8000296c:	f0 1f 00 13 	mcall	800029b8 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002970:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002974:	f0 0a 00 0a 	add	r10,r8,r10
80002978:	c9 4a       	rjmp	800026a0 <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000297a:	fc 19 c0 00 	movh	r9,0xc000
8000297e:	32 68       	mov	r8,38
80002980:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002982:	fc 18 c0 20 	movh	r8,0xc020
80002986:	33 ca       	mov	r10,60
80002988:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000298a:	37 0a       	mov	r10,112
8000298c:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
8000298e:	90 0b       	ld.sh	r11,r8[0x0]
80002990:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002992:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002994:	16 99       	mov	r9,r11
80002996:	a3 b9       	sbr	r9,0x3
80002998:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
8000299a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000299e:	00 00       	add	r0,r0
800029a0:	00 00       	add	r0,r0
800029a2:	74 98       	ld.w	r8,r10[0x24]
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	38 4c       	mov	r12,-124
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	84 4c       	ld.sh	r12,r2[0x8]
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	83 c8       	st.w	r1[0x30],r8
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	84 8c       	ld.uh	r12,r2[0x0]
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	84 a8       	ld.uh	r8,r2[0x4]
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	98 f4       	ld.uh	r4,r12[0xe]
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	24 ac       	sub	r12,74

800029c0 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
800029c0:	d4 01       	pushm	lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
800029c2:	4c 18       	lddpc	r8,80002ac4 <sd_mmc_spi_get_capacity+0x104>
800029c4:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
800029c6:	4c 18       	lddpc	r8,80002ac8 <sd_mmc_spi_get_capacity+0x108>
800029c8:	11 8a       	ld.ub	r10,r8[0x0]
800029ca:	30 38       	mov	r8,3
800029cc:	f0 0a 18 00 	cp.b	r10,r8
800029d0:	c2 71       	brne	80002a1e <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
800029d2:	4b d8       	lddpc	r8,80002ac4 <sd_mmc_spi_get_capacity+0x104>
800029d4:	f1 3a 00 08 	ld.ub	r10,r8[8]
800029d8:	f1 39 00 09 	ld.ub	r9,r8[9]
800029dc:	f3 ea 10 89 	or	r9,r9,r10<<0x8
800029e0:	11 fa       	ld.ub	r10,r8[0x7]
800029e2:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
800029e6:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
800029ea:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
800029ec:	f4 0b 16 0d 	lsr	r11,r10,0xd
800029f0:	16 99       	mov	r9,r11
800029f2:	f4 08 15 13 	lsl	r8,r10,0x13
800029f6:	4b 6a       	lddpc	r10,80002acc <sd_mmc_spi_get_capacity+0x10c>
800029f8:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
800029fc:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002a00:	4b 48       	lddpc	r8,80002ad0 <sd_mmc_spi_get_capacity+0x110>
80002a02:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002a04:	f4 ea 00 00 	ld.d	r10,r10[0]
80002a08:	90 09       	ld.sh	r9,r8[0x0]
80002a0a:	f4 08 16 09 	lsr	r8,r10,0x9
80002a0e:	f1 eb 11 78 	or	r8,r8,r11<<0x17
80002a12:	20 18       	sub	r8,1
80002a14:	b7 79       	lsl	r9,0x17
80002a16:	12 08       	add	r8,r9
80002a18:	4a f9       	lddpc	r9,80002ad4 <sd_mmc_spi_get_capacity+0x114>
80002a1a:	93 08       	st.w	r9[0x0],r8
80002a1c:	c4 28       	rjmp	80002aa0 <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002a1e:	4a a8       	lddpc	r8,80002ac4 <sd_mmc_spi_get_capacity+0x104>
80002a20:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002a24:	f1 39 00 08 	ld.ub	r9,r8[8]
80002a28:	a7 89       	lsr	r9,0x6
80002a2a:	11 fe       	ld.ub	lr,r8[0x7]
80002a2c:	f2 0e 00 29 	add	r9,r9,lr<<0x2
80002a30:	11 ee       	ld.ub	lr,r8[0x6]
80002a32:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80002a36:	ab 6e       	lsl	lr,0xa
80002a38:	1c 09       	add	r9,lr
80002a3a:	2f f9       	sub	r9,-1
80002a3c:	f1 38 00 09 	ld.ub	r8,r8[9]
80002a40:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002a44:	f8 0e 16 07 	lsr	lr,r12,0x7
80002a48:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002a4c:	2f e8       	sub	r8,-2
80002a4e:	f2 08 09 49 	lsl	r9,r9,r8
80002a52:	20 19       	sub	r9,1
80002a54:	4a 08       	lddpc	r8,80002ad4 <sd_mmc_spi_get_capacity+0x114>
80002a56:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80002a58:	70 0e       	ld.w	lr,r8[0x0]
80002a5a:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
80002a5e:	2f fe       	sub	lr,-1
80002a60:	fc 0b 09 48 	lsl	r8,lr,r11
80002a64:	30 09       	mov	r9,0
80002a66:	49 ae       	lddpc	lr,80002acc <sd_mmc_spi_get_capacity+0x10c>
80002a68:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
80002a6c:	49 98       	lddpc	r8,80002ad0 <sd_mmc_spi_get_capacity+0x110>
80002a6e:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80002a70:	30 98       	mov	r8,9
80002a72:	f0 0b 18 00 	cp.b	r11,r8
80002a76:	e0 88 00 08 	brls	80002a86 <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002a7a:	49 78       	lddpc	r8,80002ad4 <sd_mmc_spi_get_capacity+0x114>
80002a7c:	70 09       	ld.w	r9,r8[0x0]
80002a7e:	20 9b       	sub	r11,9
80002a80:	f2 0b 09 4b 	lsl	r11,r9,r11
80002a84:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
80002a86:	58 0a       	cp.w	r10,0
80002a88:	c0 c1       	brne	80002aa0 <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80002a8a:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
80002a8e:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80002a92:	48 d9       	lddpc	r9,80002ac4 <sd_mmc_spi_get_capacity+0x104>
80002a94:	f3 39 00 0b 	ld.ub	r9,r9[11]
80002a98:	a3 7c       	lsl	r12,0x3
80002a9a:	f9 e9 12 59 	or	r9,r12,r9>>0x5
80002a9e:	c0 c8       	rjmp	80002ab6 <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80002aa0:	48 9a       	lddpc	r10,80002ac4 <sd_mmc_spi_get_capacity+0x104>
80002aa2:	f5 39 00 0a 	ld.ub	r9,r10[10]
80002aa6:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
80002aaa:	f5 38 00 0b 	ld.ub	r8,r10[11]
80002aae:	a7 98       	lsr	r8,0x7
80002ab0:	f0 09 00 18 	add	r8,r8,r9<<0x1
80002ab4:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80002ab6:	2f f9       	sub	r9,-1
80002ab8:	2f f8       	sub	r8,-1
80002aba:	b1 39       	mul	r9,r8
80002abc:	48 78       	lddpc	r8,80002ad8 <sd_mmc_spi_get_capacity+0x118>
80002abe:	b0 09       	st.h	r8[0x0],r9
}
80002ac0:	d8 02       	popm	pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	00 00       	add	r0,r0
80002ac6:	79 c8       	ld.w	r8,r12[0x70]
80002ac8:	00 00       	add	r0,r0
80002aca:	79 c6       	ld.w	r6,r12[0x70]
80002acc:	00 00       	add	r0,r0
80002ace:	79 b4       	ld.w	r4,r12[0x6c]
80002ad0:	00 00       	add	r0,r0
80002ad2:	79 bc       	ld.w	r12,r12[0x6c]
80002ad4:	00 00       	add	r0,r0
80002ad6:	79 c0       	ld.w	r0,r12[0x70]
80002ad8:	00 00       	add	r0,r0
80002ada:	79 be       	ld.w	lr,r12[0x6c]

80002adc <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002adc:	5e fc       	retal	r12
80002ade:	d7 03       	nop

80002ae0 <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
80002ae0:	d4 01       	pushm	lr
80002ae2:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002ae4:	18 9b       	mov	r11,r12
80002ae6:	fe 7c 24 00 	mov	r12,-56320
80002aea:	f0 1f 00 09 	mcall	80002b0c <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002aee:	fa cb ff fe 	sub	r11,sp,-2
80002af2:	fe 7c 24 00 	mov	r12,-56320
80002af6:	f0 1f 00 07 	mcall	80002b10 <sd_mmc_spi_send_and_read+0x30>
80002afa:	58 1c       	cp.w	r12,1
80002afc:	c0 41       	brne	80002b04 <sd_mmc_spi_send_and_read+0x24>
80002afe:	e0 6c 00 ff 	mov	r12,255
80002b02:	c0 28       	rjmp	80002b06 <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
80002b04:	1b bc       	ld.ub	r12,sp[0x3]
}
80002b06:	2f fd       	sub	sp,-4
80002b08:	d8 02       	popm	pc
80002b0a:	00 00       	add	r0,r0
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	3a a8       	mov	r8,-86
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	3a c4       	mov	r4,-84

80002b14 <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
80002b14:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002b16:	30 1b       	mov	r11,1
80002b18:	fe 7c 24 00 	mov	r12,-56320
80002b1c:	f0 1f 00 10 	mcall	80002b5c <sd_mmc_spi_wait_not_busy+0x48>
80002b20:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002b22:	e0 65 00 ff 	mov	r5,255
80002b26:	48 f4       	lddpc	r4,80002b60 <sd_mmc_spi_wait_not_busy+0x4c>
80002b28:	3f f6       	mov	r6,-1
80002b2a:	c0 b8       	rjmp	80002b40 <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80002b2c:	2f f7       	sub	r7,-1
    if (retry == 200000)
80002b2e:	e2 57 0d 40 	cp.w	r7,200000
80002b32:	c0 71       	brne	80002b40 <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002b34:	30 1b       	mov	r11,1
80002b36:	fe 7c 24 00 	mov	r12,-56320
80002b3a:	f0 1f 00 0b 	mcall	80002b64 <sd_mmc_spi_wait_not_busy+0x50>
80002b3e:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002b40:	0a 9c       	mov	r12,r5
80002b42:	f0 1f 00 0a 	mcall	80002b68 <sd_mmc_spi_wait_not_busy+0x54>
80002b46:	a8 8c       	st.b	r4[0x0],r12
80002b48:	ec 0c 18 00 	cp.b	r12,r6
80002b4c:	cf 01       	brne	80002b2c <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002b4e:	30 1b       	mov	r11,1
80002b50:	fe 7c 24 00 	mov	r12,-56320
80002b54:	f0 1f 00 04 	mcall	80002b64 <sd_mmc_spi_wait_not_busy+0x50>
80002b58:	da 2a       	popm	r4-r7,pc,r12=1
80002b5a:	00 00       	add	r0,r0
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	3c 10       	mov	r0,-63
80002b60:	00 00       	add	r0,r0
80002b62:	79 d8       	ld.w	r8,r12[0x74]
80002b64:	80 00       	ld.sh	r0,r0[0x0]
80002b66:	3b d0       	mov	r0,-67
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	2a e0       	sub	r0,-82

80002b6c <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
80002b6c:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9; // gl_ptr_mem = pos * 512
80002b6e:	48 58       	lddpc	r8,80002b80 <sd_mmc_spi_write_open+0x14>
80002b70:	f8 09 16 17 	lsr	r9,r12,0x17
80002b74:	91 09       	st.w	r8[0x0],r9
80002b76:	a9 7c       	lsl	r12,0x9
80002b78:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002b7a:	f0 1f 00 03 	mcall	80002b84 <sd_mmc_spi_write_open+0x18>
}
80002b7e:	d8 02       	popm	pc
80002b80:	00 00       	add	r0,r0
80002b82:	74 a0       	ld.w	r0,r10[0x28]
80002b84:	80 00       	ld.sh	r0,r0[0x0]
80002b86:	2b 14       	sub	r4,-79

80002b88 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
80002b88:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
80002b8a:	f0 1f 00 02 	mcall	80002b90 <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
80002b8e:	d8 02       	popm	pc
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	2b 14       	sub	r4,-79

80002b94 <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
80002b94:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9;        // gl_ptr_mem = pos * 512
80002b96:	48 58       	lddpc	r8,80002ba8 <sd_mmc_spi_read_open+0x14>
80002b98:	f8 09 16 17 	lsr	r9,r12,0x17
80002b9c:	91 09       	st.w	r8[0x0],r9
80002b9e:	a9 7c       	lsl	r12,0x9
80002ba0:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80002ba2:	f0 1f 00 03 	mcall	80002bac <sd_mmc_spi_read_open+0x18>
}
80002ba6:	d8 02       	popm	pc
80002ba8:	00 00       	add	r0,r0
80002baa:	74 a0       	ld.w	r0,r10[0x28]
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	2b 14       	sub	r4,-79

80002bb0 <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80002bb0:	eb cd 40 f8 	pushm	r3-r7,lr
80002bb4:	18 96       	mov	r6,r12
80002bb6:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002bb8:	e0 6b 00 ff 	mov	r11,255
80002bbc:	fe 7c 24 00 	mov	r12,-56320
80002bc0:	f0 1f 00 2b 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80002bc4:	0c 9b       	mov	r11,r6
80002bc6:	a7 ab       	sbr	r11,0x6
80002bc8:	5c 5b       	castu.b	r11
80002bca:	fe 7c 24 00 	mov	r12,-56320
80002bce:	f0 1f 00 28 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80002bd2:	ee 0b 16 18 	lsr	r11,r7,0x18
80002bd6:	fe 7c 24 00 	mov	r12,-56320
80002bda:	f0 1f 00 25 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
80002bde:	ee 0b 16 10 	lsr	r11,r7,0x10
80002be2:	fe 7c 24 00 	mov	r12,-56320
80002be6:	f0 1f 00 22 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
80002bea:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002bee:	fe 7c 24 00 	mov	r12,-56320
80002bf2:	f0 1f 00 1f 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
80002bf6:	0e 9b       	mov	r11,r7
80002bf8:	5c 7b       	castu.h	r11
80002bfa:	fe 7c 24 00 	mov	r12,-56320
80002bfe:	f0 1f 00 1c 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
  switch(command)
80002c02:	30 08       	mov	r8,0
80002c04:	f0 06 18 00 	cp.b	r6,r8
80002c08:	c0 60       	breq	80002c14 <sd_mmc_spi_command+0x64>
80002c0a:	30 88       	mov	r8,8
80002c0c:	f0 06 18 00 	cp.b	r6,r8
80002c10:	c1 01       	brne	80002c30 <sd_mmc_spi_command+0x80>
80002c12:	c0 88       	rjmp	80002c22 <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80002c14:	e0 6b 00 95 	mov	r11,149
80002c18:	fe 7c 24 00 	mov	r12,-56320
80002c1c:	f0 1f 00 14 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
         break;
80002c20:	c0 e8       	rjmp	80002c3c <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80002c22:	e0 6b 00 87 	mov	r11,135
80002c26:	fe 7c 24 00 	mov	r12,-56320
80002c2a:	f0 1f 00 11 	mcall	80002c6c <sd_mmc_spi_command+0xbc>
         break;
80002c2e:	c0 78       	rjmp	80002c3c <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002c30:	e0 6b 00 ff 	mov	r11,255
80002c34:	fe 7c 24 00 	mov	r12,-56320
80002c38:	f0 1f 00 0d 	mcall	80002c6c <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002c3c:	3f f9       	mov	r9,-1
80002c3e:	48 d8       	lddpc	r8,80002c70 <sd_mmc_spi_command+0xc0>
80002c40:	b0 89       	st.b	r8[0x0],r9
80002c42:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002c44:	e0 64 00 ff 	mov	r4,255
80002c48:	10 93       	mov	r3,r8
80002c4a:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80002c4c:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002c4e:	c0 68       	rjmp	80002c5a <sd_mmc_spi_command+0xaa>
  {
    retry++;
80002c50:	2f f7       	sub	r7,-1
80002c52:	5c 57       	castu.b	r7
    if(retry > 10) break;
80002c54:	ea 07 18 00 	cp.b	r7,r5
80002c58:	c0 80       	breq	80002c68 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002c5a:	08 9c       	mov	r12,r4
80002c5c:	f0 1f 00 06 	mcall	80002c74 <sd_mmc_spi_command+0xc4>
80002c60:	a6 8c       	st.b	r3[0x0],r12
80002c62:	ec 0c 18 00 	cp.b	r12,r6
80002c66:	cf 50       	breq	80002c50 <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80002c68:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	3a a8       	mov	r8,-86
80002c70:	00 00       	add	r0,r0
80002c72:	79 d8       	ld.w	r8,r12[0x74]
80002c74:	80 00       	ld.sh	r0,r0[0x0]
80002c76:	2a e0       	sub	r0,-82

80002c78 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
80002c78:	eb cd 40 c0 	pushm	r6-r7,lr
80002c7c:	18 97       	mov	r7,r12
80002c7e:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002c80:	30 1b       	mov	r11,1
80002c82:	fe 7c 24 00 	mov	r12,-56320
80002c86:	f0 1f 00 09 	mcall	80002ca8 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
80002c8a:	0c 9b       	mov	r11,r6
80002c8c:	0e 9c       	mov	r12,r7
80002c8e:	f0 1f 00 08 	mcall	80002cac <sd_mmc_spi_send_command+0x34>
80002c92:	48 87       	lddpc	r7,80002cb0 <sd_mmc_spi_send_command+0x38>
80002c94:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002c96:	30 1b       	mov	r11,1
80002c98:	fe 7c 24 00 	mov	r12,-56320
80002c9c:	f0 1f 00 06 	mcall	80002cb4 <sd_mmc_spi_send_command+0x3c>
  return r1;
}
80002ca0:	0f 8c       	ld.ub	r12,r7[0x0]
80002ca2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ca6:	00 00       	add	r0,r0
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	3c 10       	mov	r0,-63
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	2b b0       	sub	r0,-69
80002cb0:	00 00       	add	r0,r0
80002cb2:	79 d8       	ld.w	r8,r12[0x74]
80002cb4:	80 00       	ld.sh	r0,r0[0x0]
80002cb6:	3b d0       	mov	r0,-67

80002cb8 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80002cb8:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80002cbc:	49 a8       	lddpc	r8,80002d24 <sd_mmc_spi_check_presence+0x6c>
80002cbe:	11 89       	ld.ub	r9,r8[0x0]
80002cc0:	30 08       	mov	r8,0
80002cc2:	f0 09 18 00 	cp.b	r9,r8
80002cc6:	c1 f1       	brne	80002d04 <sd_mmc_spi_check_presence+0x4c>
80002cc8:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002cca:	0e 94       	mov	r4,r7
80002ccc:	49 73       	lddpc	r3,80002d28 <sd_mmc_spi_check_presence+0x70>
80002cce:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002cd0:	e0 62 00 ff 	mov	r2,255
80002cd4:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80002cd8:	30 b5       	mov	r5,11
80002cda:	c0 c8       	rjmp	80002cf2 <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002cdc:	04 9b       	mov	r11,r2
80002cde:	02 9c       	mov	r12,r1
80002ce0:	f0 1f 00 13 	mcall	80002d2c <sd_mmc_spi_check_presence+0x74>
      retry++;
80002ce4:	2f f7       	sub	r7,-1
80002ce6:	5c 87       	casts.h	r7
      if (retry > 10)
80002ce8:	ea 07 19 00 	cp.h	r7,r5
80002cec:	c0 31       	brne	80002cf2 <sd_mmc_spi_check_presence+0x3a>
80002cee:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002cf2:	08 9b       	mov	r11,r4
80002cf4:	08 9c       	mov	r12,r4
80002cf6:	f0 1f 00 0f 	mcall	80002d30 <sd_mmc_spi_check_presence+0x78>
80002cfa:	a6 8c       	st.b	r3[0x0],r12
80002cfc:	ec 0c 18 00 	cp.b	r12,r6
80002d00:	ce e1       	brne	80002cdc <sd_mmc_spi_check_presence+0x24>
80002d02:	c0 e8       	rjmp	80002d1e <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80002d04:	30 0b       	mov	r11,0
80002d06:	33 bc       	mov	r12,59
80002d08:	f0 1f 00 0a 	mcall	80002d30 <sd_mmc_spi_check_presence+0x78>
80002d0c:	48 78       	lddpc	r8,80002d28 <sd_mmc_spi_check_presence+0x70>
80002d0e:	b0 8c       	st.b	r8[0x0],r12
80002d10:	58 0c       	cp.w	r12,0
80002d12:	c0 60       	breq	80002d1e <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
80002d14:	30 09       	mov	r9,0
80002d16:	48 48       	lddpc	r8,80002d24 <sd_mmc_spi_check_presence+0x6c>
80002d18:	b0 89       	st.b	r8[0x0],r9
80002d1a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
80002d1e:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
80002d22:	00 00       	add	r0,r0
80002d24:	00 00       	add	r0,r0
80002d26:	74 bc       	ld.w	r12,r10[0x2c]
80002d28:	00 00       	add	r0,r0
80002d2a:	79 d8       	ld.w	r8,r12[0x74]
80002d2c:	80 00       	ld.sh	r0,r0[0x0]
80002d2e:	3a a8       	mov	r8,-86
80002d30:	80 00       	ld.sh	r0,r0[0x0]
80002d32:	2c 78       	sub	r8,-57

80002d34 <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
80002d34:	eb cd 40 e0 	pushm	r5-r7,lr
80002d38:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002d3a:	f0 1f 00 4e 	mcall	80002e70 <sd_mmc_spi_write_sector_from_ram+0x13c>
80002d3e:	e0 80 00 96 	breq	80002e6a <sd_mmc_spi_write_sector_from_ram+0x136>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002d42:	30 1b       	mov	r11,1
80002d44:	fe 7c 24 00 	mov	r12,-56320
80002d48:	f0 1f 00 4b 	mcall	80002e74 <sd_mmc_spi_write_sector_from_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002d4c:	4c b8       	lddpc	r8,80002e78 <sd_mmc_spi_write_sector_from_ram+0x144>
80002d4e:	11 89       	ld.ub	r9,r8[0x0]
80002d50:	30 38       	mov	r8,3
80002d52:	f0 09 18 00 	cp.b	r9,r8
80002d56:	c0 d1       	brne	80002d70 <sd_mmc_spi_write_sector_from_ram+0x3c>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80002d58:	4c 98       	lddpc	r8,80002e7c <sd_mmc_spi_write_sector_from_ram+0x148>
80002d5a:	70 0b       	ld.w	r11,r8[0x0]
80002d5c:	70 18       	ld.w	r8,r8[0x4]
80002d5e:	a9 98       	lsr	r8,0x9
80002d60:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
80002d64:	31 8c       	mov	r12,24
80002d66:	f0 1f 00 47 	mcall	80002e80 <sd_mmc_spi_write_sector_from_ram+0x14c>
80002d6a:	4c 78       	lddpc	r8,80002e84 <sd_mmc_spi_write_sector_from_ram+0x150>
80002d6c:	b0 8c       	st.b	r8[0x0],r12
80002d6e:	c0 88       	rjmp	80002d7e <sd_mmc_spi_write_sector_from_ram+0x4a>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
80002d70:	4c 38       	lddpc	r8,80002e7c <sd_mmc_spi_write_sector_from_ram+0x148>
80002d72:	70 1b       	ld.w	r11,r8[0x4]
80002d74:	31 8c       	mov	r12,24
80002d76:	f0 1f 00 43 	mcall	80002e80 <sd_mmc_spi_write_sector_from_ram+0x14c>
80002d7a:	4c 38       	lddpc	r8,80002e84 <sd_mmc_spi_write_sector_from_ram+0x150>
80002d7c:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
80002d7e:	4c 28       	lddpc	r8,80002e84 <sd_mmc_spi_write_sector_from_ram+0x150>
80002d80:	11 89       	ld.ub	r9,r8[0x0]
80002d82:	30 08       	mov	r8,0
80002d84:	f0 09 18 00 	cp.b	r9,r8
80002d88:	c0 80       	breq	80002d98 <sd_mmc_spi_write_sector_from_ram+0x64>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002d8a:	30 1b       	mov	r11,1
80002d8c:	fe 7c 24 00 	mov	r12,-56320
80002d90:	f0 1f 00 3e 	mcall	80002e88 <sd_mmc_spi_write_sector_from_ram+0x154>
80002d94:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80002d98:	e0 6b 00 ff 	mov	r11,255
80002d9c:	fe 7c 24 00 	mov	r12,-56320
80002da0:	f0 1f 00 3b 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
80002da4:	e0 6b 00 fe 	mov	r11,254
80002da8:	fe 7c 24 00 	mov	r12,-56320
80002dac:	f0 1f 00 38 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
80002db0:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
80002db4:	fe 75 24 00 	mov	r5,-56320
80002db8:	0f 3b       	ld.ub	r11,r7++
80002dba:	0a 9c       	mov	r12,r5
80002dbc:	f0 1f 00 34 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80002dc0:	0c 37       	cp.w	r7,r6
80002dc2:	cf b1       	brne	80002db8 <sd_mmc_spi_write_sector_from_ram+0x84>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
80002dc4:	e0 6b 00 ff 	mov	r11,255
80002dc8:	fe 7c 24 00 	mov	r12,-56320
80002dcc:	f0 1f 00 30 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80002dd0:	e0 6b 00 ff 	mov	r11,255
80002dd4:	fe 7c 24 00 	mov	r12,-56320
80002dd8:	f0 1f 00 2d 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002ddc:	e0 6c 00 ff 	mov	r12,255
80002de0:	f0 1f 00 2c 	mcall	80002e90 <sd_mmc_spi_write_sector_from_ram+0x15c>
80002de4:	4a 88       	lddpc	r8,80002e84 <sd_mmc_spi_write_sector_from_ram+0x150>
80002de6:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80002de8:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002dec:	58 5c       	cp.w	r12,5
80002dee:	c1 40       	breq	80002e16 <sd_mmc_spi_write_sector_from_ram+0xe2>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002df0:	e0 6b 00 ff 	mov	r11,255
80002df4:	fe 7c 24 00 	mov	r12,-56320
80002df8:	f0 1f 00 25 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_write(SD_MMC_SPI,0xFF);
80002dfc:	e0 6b 00 ff 	mov	r11,255
80002e00:	fe 7c 24 00 	mov	r12,-56320
80002e04:	f0 1f 00 22 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002e08:	30 1b       	mov	r11,1
80002e0a:	fe 7c 24 00 	mov	r12,-56320
80002e0e:	f0 1f 00 1f 	mcall	80002e88 <sd_mmc_spi_write_sector_from_ram+0x154>
80002e12:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002e16:	e0 6b 00 ff 	mov	r11,255
80002e1a:	fe 7c 24 00 	mov	r12,-56320
80002e1e:	f0 1f 00 1c 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80002e22:	e0 6b 00 ff 	mov	r11,255
80002e26:	fe 7c 24 00 	mov	r12,-56320
80002e2a:	f0 1f 00 19 	mcall	80002e8c <sd_mmc_spi_write_sector_from_ram+0x158>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002e2e:	30 1b       	mov	r11,1
80002e30:	fe 7c 24 00 	mov	r12,-56320
80002e34:	f0 1f 00 15 	mcall	80002e88 <sd_mmc_spi_write_sector_from_ram+0x154>
  gl_ptr_mem += 512;        // Update the memory pointer.
80002e38:	49 18       	lddpc	r8,80002e7c <sd_mmc_spi_write_sector_from_ram+0x148>
80002e3a:	f0 e6 00 00 	ld.d	r6,r8[0]
80002e3e:	e0 6a 02 00 	mov	r10,512
80002e42:	30 0b       	mov	r11,0
80002e44:	ec 0a 00 0a 	add	r10,r6,r10
80002e48:	ee 0b 00 4b 	adc	r11,r7,r11
80002e4c:	f0 eb 00 00 	st.d	r8[0],r10
80002e50:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
80002e52:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80002e54:	c0 68       	rjmp	80002e60 <sd_mmc_spi_write_sector_from_ram+0x12c>
  {
    i++;
80002e56:	2f f7       	sub	r7,-1
80002e58:	5c 87       	casts.h	r7
    if (i == 10)
80002e5a:	ec 07 19 00 	cp.h	r7,r6
80002e5e:	c0 60       	breq	80002e6a <sd_mmc_spi_write_sector_from_ram+0x136>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80002e60:	f0 1f 00 04 	mcall	80002e70 <sd_mmc_spi_write_sector_from_ram+0x13c>
80002e64:	cf 90       	breq	80002e56 <sd_mmc_spi_write_sector_from_ram+0x122>
80002e66:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002e6a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80002e6e:	00 00       	add	r0,r0
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	2b 14       	sub	r4,-79
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	3c 10       	mov	r0,-63
80002e78:	00 00       	add	r0,r0
80002e7a:	79 c6       	ld.w	r6,r12[0x70]
80002e7c:	00 00       	add	r0,r0
80002e7e:	74 a0       	ld.w	r0,r10[0x28]
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	2b b0       	sub	r0,-69
80002e84:	00 00       	add	r0,r0
80002e86:	79 d8       	ld.w	r8,r12[0x74]
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	3b d0       	mov	r0,-67
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	3a a8       	mov	r8,-86
80002e90:	80 00       	ld.sh	r0,r0[0x0]
80002e92:	2a e0       	sub	r0,-82

80002e94 <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
80002e94:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002e98:	f0 1f 00 1c 	mcall	80002f08 <sd_mmc_spi_check_hc+0x74>
80002e9c:	c0 31       	brne	80002ea2 <sd_mmc_spi_check_hc+0xe>
80002e9e:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002ea2:	30 1b       	mov	r11,1
80002ea4:	fe 7c 24 00 	mov	r12,-56320
80002ea8:	f0 1f 00 19 	mcall	80002f0c <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
80002eac:	30 0b       	mov	r11,0
80002eae:	33 ac       	mov	r12,58
80002eb0:	f0 1f 00 18 	mcall	80002f10 <sd_mmc_spi_check_hc+0x7c>
80002eb4:	49 88       	lddpc	r8,80002f14 <sd_mmc_spi_check_hc+0x80>
80002eb6:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
80002eb8:	58 0c       	cp.w	r12,0
80002eba:	c0 80       	breq	80002eca <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002ebc:	30 1b       	mov	r11,1
80002ebe:	fe 7c 24 00 	mov	r12,-56320
80002ec2:	f0 1f 00 16 	mcall	80002f18 <sd_mmc_spi_check_hc+0x84>
80002ec6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80002eca:	e0 6c 00 ff 	mov	r12,255
80002ece:	f0 1f 00 14 	mcall	80002f1c <sd_mmc_spi_check_hc+0x88>
80002ed2:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002ed4:	e0 6c 00 ff 	mov	r12,255
80002ed8:	f0 1f 00 11 	mcall	80002f1c <sd_mmc_spi_check_hc+0x88>
80002edc:	48 e7       	lddpc	r7,80002f14 <sd_mmc_spi_check_hc+0x80>
80002ede:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002ee0:	e0 6c 00 ff 	mov	r12,255
80002ee4:	f0 1f 00 0e 	mcall	80002f1c <sd_mmc_spi_check_hc+0x88>
80002ee8:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002eea:	e0 6c 00 ff 	mov	r12,255
80002eee:	f0 1f 00 0c 	mcall	80002f1c <sd_mmc_spi_check_hc+0x88>
80002ef2:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002ef4:	30 1b       	mov	r11,1
80002ef6:	fe 7c 24 00 	mov	r12,-56320
80002efa:	f0 1f 00 08 	mcall	80002f18 <sd_mmc_spi_check_hc+0x84>
80002efe:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
80002f02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f06:	00 00       	add	r0,r0
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	2b 14       	sub	r4,-79
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	3c 10       	mov	r0,-63
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	2b b0       	sub	r0,-69
80002f14:	00 00       	add	r0,r0
80002f16:	79 d8       	ld.w	r8,r12[0x74]
80002f18:	80 00       	ld.sh	r0,r0[0x0]
80002f1a:	3b d0       	mov	r0,-67
80002f1c:	80 00       	ld.sh	r0,r0[0x0]
80002f1e:	2a e0       	sub	r0,-82

80002f20 <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80002f20:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002f24:	f0 1f 00 27 	mcall	80002fc0 <sd_mmc_spi_get_if+0xa0>
80002f28:	c0 31       	brne	80002f2e <sd_mmc_spi_get_if+0xe>
80002f2a:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002f2e:	30 1b       	mov	r11,1
80002f30:	fe 7c 24 00 	mov	r12,-56320
80002f34:	f0 1f 00 24 	mcall	80002fc4 <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80002f38:	e0 6b 01 aa 	mov	r11,426
80002f3c:	30 8c       	mov	r12,8
80002f3e:	f0 1f 00 23 	mcall	80002fc8 <sd_mmc_spi_get_if+0xa8>
80002f42:	4a 38       	lddpc	r8,80002fcc <sd_mmc_spi_get_if+0xac>
80002f44:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
80002f46:	e2 1c 00 04 	andl	r12,0x4,COH
80002f4a:	c0 80       	breq	80002f5a <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002f4c:	30 1b       	mov	r11,1
80002f4e:	fe 7c 24 00 	mov	r12,-56320
80002f52:	f0 1f 00 20 	mcall	80002fd0 <sd_mmc_spi_get_if+0xb0>
80002f56:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002f5a:	e0 6c 00 ff 	mov	r12,255
80002f5e:	f0 1f 00 1e 	mcall	80002fd4 <sd_mmc_spi_get_if+0xb4>
80002f62:	49 b7       	lddpc	r7,80002fcc <sd_mmc_spi_get_if+0xac>
80002f64:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002f66:	e0 6c 00 ff 	mov	r12,255
80002f6a:	f0 1f 00 1b 	mcall	80002fd4 <sd_mmc_spi_get_if+0xb4>
80002f6e:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002f70:	e0 6c 00 ff 	mov	r12,255
80002f74:	f0 1f 00 18 	mcall	80002fd4 <sd_mmc_spi_get_if+0xb4>
80002f78:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
80002f7a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002f7e:	c0 81       	brne	80002f8e <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002f80:	30 1b       	mov	r11,1
80002f82:	fe 7c 24 00 	mov	r12,-56320
80002f86:	f0 1f 00 13 	mcall	80002fd0 <sd_mmc_spi_get_if+0xb0>
80002f8a:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002f8e:	e0 6c 00 ff 	mov	r12,255
80002f92:	f0 1f 00 11 	mcall	80002fd4 <sd_mmc_spi_get_if+0xb4>
80002f96:	48 e8       	lddpc	r8,80002fcc <sd_mmc_spi_get_if+0xac>
80002f98:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
80002f9a:	3a a8       	mov	r8,-86
80002f9c:	f0 0c 18 00 	cp.b	r12,r8
80002fa0:	c0 80       	breq	80002fb0 <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002fa2:	30 1b       	mov	r11,1
80002fa4:	fe 7c 24 00 	mov	r12,-56320
80002fa8:	f0 1f 00 0a 	mcall	80002fd0 <sd_mmc_spi_get_if+0xb0>
80002fac:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002fb0:	30 1b       	mov	r11,1
80002fb2:	fe 7c 24 00 	mov	r12,-56320
80002fb6:	f0 1f 00 07 	mcall	80002fd0 <sd_mmc_spi_get_if+0xb0>
80002fba:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80002fbe:	00 00       	add	r0,r0
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	2b 14       	sub	r4,-79
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	3c 10       	mov	r0,-63
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	2b b0       	sub	r0,-69
80002fcc:	00 00       	add	r0,r0
80002fce:	79 d8       	ld.w	r8,r12[0x74]
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	3b d0       	mov	r0,-67
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	2a e0       	sub	r0,-82

80002fd8 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80002fd8:	eb cd 40 f8 	pushm	r3-r7,lr
80002fdc:	20 1d       	sub	sp,4
80002fde:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002fe0:	f0 1f 00 4d 	mcall	80003114 <sd_mmc_spi_read_sector_to_ram+0x13c>
80002fe4:	e0 80 00 94 	breq	8000310c <sd_mmc_spi_read_sector_to_ram+0x134>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002fe8:	30 1b       	mov	r11,1
80002fea:	fe 7c 24 00 	mov	r12,-56320
80002fee:	f0 1f 00 4b 	mcall	80003118 <sd_mmc_spi_read_sector_to_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002ff2:	4c b8       	lddpc	r8,8000311c <sd_mmc_spi_read_sector_to_ram+0x144>
80002ff4:	11 89       	ld.ub	r9,r8[0x0]
80002ff6:	30 38       	mov	r8,3
80002ff8:	f0 09 18 00 	cp.b	r9,r8
80002ffc:	c0 d1       	brne	80003016 <sd_mmc_spi_read_sector_to_ram+0x3e>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80002ffe:	4c 98       	lddpc	r8,80003120 <sd_mmc_spi_read_sector_to_ram+0x148>
80003000:	70 0b       	ld.w	r11,r8[0x0]
80003002:	70 18       	ld.w	r8,r8[0x4]
80003004:	a9 98       	lsr	r8,0x9
80003006:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
8000300a:	31 1c       	mov	r12,17
8000300c:	f0 1f 00 46 	mcall	80003124 <sd_mmc_spi_read_sector_to_ram+0x14c>
80003010:	4c 68       	lddpc	r8,80003128 <sd_mmc_spi_read_sector_to_ram+0x150>
80003012:	b0 8c       	st.b	r8[0x0],r12
80003014:	c0 88       	rjmp	80003024 <sd_mmc_spi_read_sector_to_ram+0x4c>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80003016:	4c 38       	lddpc	r8,80003120 <sd_mmc_spi_read_sector_to_ram+0x148>
80003018:	70 1b       	ld.w	r11,r8[0x4]
8000301a:	31 1c       	mov	r12,17
8000301c:	f0 1f 00 42 	mcall	80003124 <sd_mmc_spi_read_sector_to_ram+0x14c>
80003020:	4c 28       	lddpc	r8,80003128 <sd_mmc_spi_read_sector_to_ram+0x150>
80003022:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
80003024:	4c 18       	lddpc	r8,80003128 <sd_mmc_spi_read_sector_to_ram+0x150>
80003026:	11 89       	ld.ub	r9,r8[0x0]
80003028:	30 08       	mov	r8,0
8000302a:	f0 09 18 00 	cp.b	r9,r8
8000302e:	c1 20       	breq	80003052 <sd_mmc_spi_read_sector_to_ram+0x7a>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003030:	30 1b       	mov	r11,1
80003032:	fe 7c 24 00 	mov	r12,-56320
80003036:	f0 1f 00 3e 	mcall	8000312c <sd_mmc_spi_read_sector_to_ram+0x154>
8000303a:	30 0c       	mov	r12,0
    return false;
8000303c:	c6 88       	rjmp	8000310c <sd_mmc_spi_read_sector_to_ram+0x134>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
8000303e:	20 17       	sub	r7,1
80003040:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
80003042:	c0 e1       	brne	8000305e <sd_mmc_spi_read_sector_to_ram+0x86>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
80003044:	30 1b       	mov	r11,1
80003046:	fe 7c 24 00 	mov	r12,-56320
8000304a:	f0 1f 00 39 	mcall	8000312c <sd_mmc_spi_read_sector_to_ram+0x154>
8000304e:	30 0c       	mov	r12,0
       return false;
80003050:	c5 e8       	rjmp	8000310c <sd_mmc_spi_read_sector_to_ram+0x134>
80003052:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80003056:	e0 65 00 ff 	mov	r5,255
8000305a:	4b 44       	lddpc	r4,80003128 <sd_mmc_spi_read_sector_to_ram+0x150>
8000305c:	3f f6       	mov	r6,-1
8000305e:	0a 9c       	mov	r12,r5
80003060:	f0 1f 00 34 	mcall	80003130 <sd_mmc_spi_read_sector_to_ram+0x158>
80003064:	a8 8c       	st.b	r4[0x0],r12
80003066:	ec 0c 18 00 	cp.b	r12,r6
8000306a:	ce a0       	breq	8000303e <sd_mmc_spi_read_sector_to_ram+0x66>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
8000306c:	3f e8       	mov	r8,-2
8000306e:	f0 0c 18 00 	cp.b	r12,r8
80003072:	c0 e0       	breq	8000308e <sd_mmc_spi_read_sector_to_ram+0xb6>
  {
    spi_write(SD_MMC_SPI,0xFF);
80003074:	e0 6b 00 ff 	mov	r11,255
80003078:	fe 7c 24 00 	mov	r12,-56320
8000307c:	f0 1f 00 2e 	mcall	80003134 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003080:	30 1b       	mov	r11,1
80003082:	fe 7c 24 00 	mov	r12,-56320
80003086:	f0 1f 00 2a 	mcall	8000312c <sd_mmc_spi_read_sector_to_ram+0x154>
8000308a:	30 0c       	mov	r12,0
    return false;
8000308c:	c4 08       	rjmp	8000310c <sd_mmc_spi_read_sector_to_ram+0x134>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
8000308e:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
80003090:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
80003094:	e0 64 00 ff 	mov	r4,255
80003098:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
8000309c:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800030a0:	08 9b       	mov	r11,r4
800030a2:	0c 9c       	mov	r12,r6
800030a4:	f0 1f 00 24 	mcall	80003134 <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_read(SD_MMC_SPI,&data_read);
800030a8:	06 9b       	mov	r11,r3
800030aa:	0c 9c       	mov	r12,r6
800030ac:	f0 1f 00 23 	mcall	80003138 <sd_mmc_spi_read_sector_to_ram+0x160>
    *_ram++=data_read;
800030b0:	9a 18       	ld.sh	r8,sp[0x2]
800030b2:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800030b4:	0a 37       	cp.w	r7,r5
800030b6:	cf 51       	brne	800030a0 <sd_mmc_spi_read_sector_to_ram+0xc8>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
800030b8:	49 a8       	lddpc	r8,80003120 <sd_mmc_spi_read_sector_to_ram+0x148>
800030ba:	f0 e6 00 00 	ld.d	r6,r8[0]
800030be:	e0 6a 02 00 	mov	r10,512
800030c2:	30 0b       	mov	r11,0
800030c4:	ec 0a 00 0a 	add	r10,r6,r10
800030c8:	ee 0b 00 4b 	adc	r11,r7,r11
800030cc:	f0 eb 00 00 	st.d	r8[0],r10

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
800030d0:	e0 6b 00 ff 	mov	r11,255
800030d4:	fe 7c 24 00 	mov	r12,-56320
800030d8:	f0 1f 00 17 	mcall	80003134 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
800030dc:	e0 6b 00 ff 	mov	r11,255
800030e0:	fe 7c 24 00 	mov	r12,-56320
800030e4:	f0 1f 00 14 	mcall	80003134 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
800030e8:	e0 6b 00 ff 	mov	r11,255
800030ec:	fe 7c 24 00 	mov	r12,-56320
800030f0:	f0 1f 00 11 	mcall	80003134 <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
800030f4:	e0 6b 00 ff 	mov	r11,255
800030f8:	fe 7c 24 00 	mov	r12,-56320
800030fc:	f0 1f 00 0e 	mcall	80003134 <sd_mmc_spi_read_sector_to_ram+0x15c>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003100:	30 1b       	mov	r11,1
80003102:	fe 7c 24 00 	mov	r12,-56320
80003106:	f0 1f 00 0a 	mcall	8000312c <sd_mmc_spi_read_sector_to_ram+0x154>
8000310a:	30 1c       	mov	r12,1

  return true;   // Read done.
}
8000310c:	2f fd       	sub	sp,-4
8000310e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003112:	00 00       	add	r0,r0
80003114:	80 00       	ld.sh	r0,r0[0x0]
80003116:	2b 14       	sub	r4,-79
80003118:	80 00       	ld.sh	r0,r0[0x0]
8000311a:	3c 10       	mov	r0,-63
8000311c:	00 00       	add	r0,r0
8000311e:	79 c6       	ld.w	r6,r12[0x70]
80003120:	00 00       	add	r0,r0
80003122:	74 a0       	ld.w	r0,r10[0x28]
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	2b b0       	sub	r0,-69
80003128:	00 00       	add	r0,r0
8000312a:	79 d8       	ld.w	r8,r12[0x74]
8000312c:	80 00       	ld.sh	r0,r0[0x0]
8000312e:	3b d0       	mov	r0,-67
80003130:	80 00       	ld.sh	r0,r0[0x0]
80003132:	2a e0       	sub	r0,-82
80003134:	80 00       	ld.sh	r0,r0[0x0]
80003136:	3a a8       	mov	r8,-86
80003138:	80 00       	ld.sh	r0,r0[0x0]
8000313a:	3a c4       	mov	r4,-84

8000313c <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
8000313c:	eb cd 40 fc 	pushm	r2-r7,lr
80003140:	20 1d       	sub	sp,4
80003142:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003144:	f0 1f 00 32 	mcall	8000320c <sd_mmc_spi_get_csd+0xd0>
80003148:	c5 f0       	breq	80003206 <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000314a:	30 1b       	mov	r11,1
8000314c:	fe 7c 24 00 	mov	r12,-56320
80003150:	f0 1f 00 30 	mcall	80003210 <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80003154:	30 0b       	mov	r11,0
80003156:	30 9c       	mov	r12,9
80003158:	f0 1f 00 2f 	mcall	80003214 <sd_mmc_spi_get_csd+0xd8>
8000315c:	4a f8       	lddpc	r8,80003218 <sd_mmc_spi_get_csd+0xdc>
8000315e:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
80003160:	58 0c       	cp.w	r12,0
80003162:	c0 81       	brne	80003172 <sd_mmc_spi_get_csd+0x36>
80003164:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003166:	e0 64 00 ff 	mov	r4,255
8000316a:	10 93       	mov	r3,r8
8000316c:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
8000316e:	30 95       	mov	r5,9
80003170:	c1 78       	rjmp	8000319e <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003172:	30 1b       	mov	r11,1
80003174:	fe 7c 24 00 	mov	r12,-56320
80003178:	f0 1f 00 29 	mcall	8000321c <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
8000317c:	30 09       	mov	r9,0
8000317e:	4a 98       	lddpc	r8,80003220 <sd_mmc_spi_get_csd+0xe4>
80003180:	b0 89       	st.b	r8[0x0],r9
80003182:	30 0c       	mov	r12,0
    return false;
80003184:	c4 18       	rjmp	80003206 <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
80003186:	ea 07 18 00 	cp.b	r7,r5
8000318a:	c0 81       	brne	8000319a <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000318c:	30 1b       	mov	r11,1
8000318e:	fe 7c 24 00 	mov	r12,-56320
80003192:	f0 1f 00 23 	mcall	8000321c <sd_mmc_spi_get_csd+0xe0>
80003196:	30 0c       	mov	r12,0
      return false;
80003198:	c3 78       	rjmp	80003206 <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
8000319a:	2f f7       	sub	r7,-1
8000319c:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000319e:	08 9c       	mov	r12,r4
800031a0:	f0 1f 00 21 	mcall	80003224 <sd_mmc_spi_get_csd+0xe8>
800031a4:	a6 8c       	st.b	r3[0x0],r12
800031a6:	ec 0c 18 00 	cp.b	r12,r6
800031aa:	ce e1       	brne	80003186 <sd_mmc_spi_get_csd+0x4a>
800031ac:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800031ae:	e0 65 00 ff 	mov	r5,255
800031b2:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
800031b6:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800031ba:	0a 9b       	mov	r11,r5
800031bc:	0c 9c       	mov	r12,r6
800031be:	f0 1f 00 1b 	mcall	80003228 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
800031c2:	08 9b       	mov	r11,r4
800031c4:	0c 9c       	mov	r12,r6
800031c6:	f0 1f 00 1a 	mcall	8000322c <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
800031ca:	9a 18       	ld.sh	r8,sp[0x2]
800031cc:	e4 07 0b 08 	st.b	r2[r7],r8
800031d0:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
800031d2:	59 07       	cp.w	r7,16
800031d4:	cf 31       	brne	800031ba <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
800031d6:	e0 6b 00 ff 	mov	r11,255
800031da:	fe 7c 24 00 	mov	r12,-56320
800031de:	f0 1f 00 13 	mcall	80003228 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
800031e2:	e0 6b 00 ff 	mov	r11,255
800031e6:	fe 7c 24 00 	mov	r12,-56320
800031ea:	f0 1f 00 10 	mcall	80003228 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800031ee:	e0 6b 00 ff 	mov	r11,255
800031f2:	fe 7c 24 00 	mov	r12,-56320
800031f6:	f0 1f 00 0d 	mcall	80003228 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800031fa:	30 1b       	mov	r11,1
800031fc:	fe 7c 24 00 	mov	r12,-56320
80003200:	f0 1f 00 07 	mcall	8000321c <sd_mmc_spi_get_csd+0xe0>
80003204:	30 1c       	mov	r12,1
  return true;
}
80003206:	2f fd       	sub	sp,-4
80003208:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000320c:	80 00       	ld.sh	r0,r0[0x0]
8000320e:	2b 14       	sub	r4,-79
80003210:	80 00       	ld.sh	r0,r0[0x0]
80003212:	3c 10       	mov	r0,-63
80003214:	80 00       	ld.sh	r0,r0[0x0]
80003216:	2b b0       	sub	r0,-69
80003218:	00 00       	add	r0,r0
8000321a:	79 d8       	ld.w	r8,r12[0x74]
8000321c:	80 00       	ld.sh	r0,r0[0x0]
8000321e:	3b d0       	mov	r0,-67
80003220:	00 00       	add	r0,r0
80003222:	74 bc       	ld.w	r12,r10[0x2c]
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	2a e0       	sub	r0,-82
80003228:	80 00       	ld.sh	r0,r0[0x0]
8000322a:	3a a8       	mov	r8,-86
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	3a c4       	mov	r4,-84

80003230 <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
80003230:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
80003232:	fe fb 02 66 	ld.w	r11,pc[614]
80003236:	e6 68 1a 80 	mov	r8,400000
8000323a:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000323c:	fe f8 02 60 	ld.w	r8,pc[608]
80003240:	70 0a       	ld.w	r10,r8[0x0]
80003242:	fe 7c 24 00 	mov	r12,-56320
80003246:	f0 1f 00 97 	mcall	800034a0 <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000324a:	30 1b       	mov	r11,1
8000324c:	fe 7c 24 00 	mov	r12,-56320
80003250:	f0 1f 00 95 	mcall	800034a4 <sd_mmc_spi_internal_init+0x274>
80003254:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
80003256:	e0 66 00 ff 	mov	r6,255
8000325a:	fe 75 24 00 	mov	r5,-56320
8000325e:	0c 9b       	mov	r11,r6
80003260:	0a 9c       	mov	r12,r5
80003262:	f0 1f 00 92 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
80003266:	2f f7       	sub	r7,-1
80003268:	58 a7       	cp.w	r7,10
8000326a:	cf a1       	brne	8000325e <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000326c:	30 1b       	mov	r11,1
8000326e:	fe 7c 24 00 	mov	r12,-56320
80003272:	f0 1f 00 8f 	mcall	800034ac <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
80003276:	30 08       	mov	r8,0
80003278:	fe f9 02 38 	ld.w	r9,pc[568]
8000327c:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
8000327e:	fe f9 02 36 	ld.w	r9,pc[566]
80003282:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003284:	30 0b       	mov	r11,0
80003286:	16 9c       	mov	r12,r11
80003288:	f0 1f 00 8c 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
8000328c:	fe f8 02 30 	ld.w	r8,pc[560]
80003290:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003292:	e0 6b 00 ff 	mov	r11,255
80003296:	fe 7c 24 00 	mov	r12,-56320
8000329a:	f0 1f 00 84 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
8000329e:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800032a0:	fe f6 02 1c 	ld.w	r6,pc[540]
800032a4:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800032a6:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800032a8:	e0 62 00 ff 	mov	r2,255
800032ac:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
800032b0:	36 54       	mov	r4,101
800032b2:	c1 08       	rjmp	800032d2 <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800032b4:	06 9b       	mov	r11,r3
800032b6:	06 9c       	mov	r12,r3
800032b8:	f0 1f 00 80 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
800032bc:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800032be:	04 9b       	mov	r11,r2
800032c0:	02 9c       	mov	r12,r1
800032c2:	f0 1f 00 7a 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
800032c6:	2f f7       	sub	r7,-1
800032c8:	5c 87       	casts.h	r7
    if(retry > 100)
800032ca:	e8 07 19 00 	cp.h	r7,r4
800032ce:	e0 80 00 e4 	breq	80003496 <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800032d2:	0d 88       	ld.ub	r8,r6[0x0]
800032d4:	ea 08 18 00 	cp.b	r8,r5
800032d8:	ce e1       	brne	800032b4 <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
800032da:	f0 1f 00 7a 	mcall	800034c0 <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
800032de:	5b fc       	cp.w	r12,-1
800032e0:	e0 80 00 db 	breq	80003496 <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
800032e4:	58 1c       	cp.w	r12,1
800032e6:	c0 51       	brne	800032f0 <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
800032e8:	30 29       	mov	r9,2
800032ea:	4f 38       	lddpc	r8,800034b4 <sd_mmc_spi_internal_init+0x284>
800032ec:	b0 89       	st.b	r8[0x0],r9
800032ee:	c4 c8       	rjmp	80003386 <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
800032f0:	30 0b       	mov	r11,0
800032f2:	33 7c       	mov	r12,55
800032f4:	f0 1f 00 71 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
800032f8:	4f 17       	lddpc	r7,800034bc <sd_mmc_spi_internal_init+0x28c>
800032fa:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800032fc:	e0 6b 00 ff 	mov	r11,255
80003300:	fe 7c 24 00 	mov	r12,-56320
80003304:	f0 1f 00 69 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80003308:	30 0b       	mov	r11,0
8000330a:	32 9c       	mov	r12,41
8000330c:	f0 1f 00 6b 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
80003310:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80003312:	e0 6b 00 ff 	mov	r11,255
80003316:	fe 7c 24 00 	mov	r12,-56320
8000331a:	f0 1f 00 64 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
8000331e:	0f 88       	ld.ub	r8,r7[0x0]
80003320:	e2 18 00 fe 	andl	r8,0xfe,COH
80003324:	c0 51       	brne	8000332e <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
80003326:	30 19       	mov	r9,1
80003328:	4e 38       	lddpc	r8,800034b4 <sd_mmc_spi_internal_init+0x284>
8000332a:	b0 89       	st.b	r8[0x0],r9
8000332c:	c2 d8       	rjmp	80003386 <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
8000332e:	30 09       	mov	r9,0
80003330:	4e 18       	lddpc	r8,800034b4 <sd_mmc_spi_internal_init+0x284>
80003332:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003334:	30 0b       	mov	r11,0
80003336:	16 9c       	mov	r12,r11
80003338:	f0 1f 00 60 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
8000333c:	4e 08       	lddpc	r8,800034bc <sd_mmc_spi_internal_init+0x28c>
8000333e:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003340:	e0 6b 00 ff 	mov	r11,255
80003344:	fe 7c 24 00 	mov	r12,-56320
80003348:	f0 1f 00 58 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
8000334c:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000334e:	4d c6       	lddpc	r6,800034bc <sd_mmc_spi_internal_init+0x28c>
80003350:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003352:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003354:	e0 62 00 ff 	mov	r2,255
80003358:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
8000335c:	36 54       	mov	r4,101
8000335e:	c1 08       	rjmp	8000337e <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003360:	06 9b       	mov	r11,r3
80003362:	06 9c       	mov	r12,r3
80003364:	f0 1f 00 55 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
80003368:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000336a:	04 9b       	mov	r11,r2
8000336c:	02 9c       	mov	r12,r1
8000336e:	f0 1f 00 4f 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
80003372:	2f f7       	sub	r7,-1
80003374:	5c 87       	casts.h	r7
        if(retry > 100)
80003376:	e8 07 19 00 	cp.h	r7,r4
8000337a:	e0 80 00 8e 	breq	80003496 <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000337e:	0d 88       	ld.ub	r8,r6[0x0]
80003380:	ea 08 18 00 	cp.b	r8,r5
80003384:	ce e1       	brne	80003360 <sd_mmc_spi_internal_init+0x130>
80003386:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003388:	4c b4       	lddpc	r4,800034b4 <sd_mmc_spi_internal_init+0x284>
8000338a:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000338c:	0e 93       	mov	r3,r7
8000338e:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80003390:	4c b6       	lddpc	r6,800034bc <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003392:	e0 62 00 ff 	mov	r2,255
80003396:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
8000339a:	09 88       	ld.ub	r8,r4[0x0]
8000339c:	ea 08 18 00 	cp.b	r8,r5
800033a0:	c1 10       	breq	800033c2 <sd_mmc_spi_internal_init+0x192>
800033a2:	c0 63       	brcs	800033ae <sd_mmc_spi_internal_init+0x17e>
800033a4:	30 29       	mov	r9,2
800033a6:	f2 08 18 00 	cp.b	r8,r9
800033aa:	c2 81       	brne	800033fa <sd_mmc_spi_internal_init+0x1ca>
800033ac:	c1 98       	rjmp	800033de <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
800033ae:	06 9b       	mov	r11,r3
800033b0:	30 1c       	mov	r12,1
800033b2:	f0 1f 00 42 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
800033b6:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800033b8:	04 9b       	mov	r11,r2
800033ba:	02 9c       	mov	r12,r1
800033bc:	f0 1f 00 3b 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
      break;
800033c0:	c1 d8       	rjmp	800033fa <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800033c2:	06 9b       	mov	r11,r3
800033c4:	00 9c       	mov	r12,r0
800033c6:	f0 1f 00 3d 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800033ca:	06 9b       	mov	r11,r3
800033cc:	32 9c       	mov	r12,41
800033ce:	f0 1f 00 3b 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
800033d2:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800033d4:	04 9b       	mov	r11,r2
800033d6:	02 9c       	mov	r12,r1
800033d8:	f0 1f 00 34 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
      break;
800033dc:	c0 f8       	rjmp	800033fa <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800033de:	06 9b       	mov	r11,r3
800033e0:	00 9c       	mov	r12,r0
800033e2:	f0 1f 00 36 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
800033e6:	fc 1b 40 00 	movh	r11,0x4000
800033ea:	32 9c       	mov	r12,41
800033ec:	f0 1f 00 33 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
800033f0:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800033f2:	04 9b       	mov	r11,r2
800033f4:	02 9c       	mov	r12,r1
800033f6:	f0 1f 00 2d 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
800033fa:	2f f7       	sub	r7,-1
800033fc:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
800033fe:	fe 78 c3 50 	mov	r8,-15536
80003402:	f0 07 19 00 	cp.h	r7,r8
80003406:	c4 80       	breq	80003496 <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
80003408:	0d 89       	ld.ub	r9,r6[0x0]
8000340a:	30 08       	mov	r8,0
8000340c:	f0 09 18 00 	cp.b	r9,r8
80003410:	cc 51       	brne	8000339a <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80003412:	4a 98       	lddpc	r8,800034b4 <sd_mmc_spi_internal_init+0x284>
80003414:	11 89       	ld.ub	r9,r8[0x0]
80003416:	30 28       	mov	r8,2
80003418:	f0 09 18 00 	cp.b	r9,r8
8000341c:	c0 a1       	brne	80003430 <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
8000341e:	f0 1f 00 2a 	mcall	800034c4 <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
80003422:	5b fc       	cp.w	r12,-1
80003424:	c3 90       	breq	80003496 <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
80003426:	58 1c       	cp.w	r12,1
80003428:	c0 41       	brne	80003430 <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
8000342a:	30 39       	mov	r9,3
8000342c:	4a 28       	lddpc	r8,800034b4 <sd_mmc_spi_internal_init+0x284>
8000342e:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80003430:	30 0b       	mov	r11,0
80003432:	33 bc       	mov	r12,59
80003434:	f0 1f 00 21 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
80003438:	4a 17       	lddpc	r7,800034bc <sd_mmc_spi_internal_init+0x28c>
8000343a:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000343c:	e0 6b 00 ff 	mov	r11,255
80003440:	fe 7c 24 00 	mov	r12,-56320
80003444:	f0 1f 00 19 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80003448:	e0 6b 02 00 	mov	r11,512
8000344c:	31 0c       	mov	r12,16
8000344e:	f0 1f 00 1b 	mcall	800034b8 <sd_mmc_spi_internal_init+0x288>
80003452:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003454:	e0 6b 00 ff 	mov	r11,255
80003458:	fe 7c 24 00 	mov	r12,-56320
8000345c:	f0 1f 00 13 	mcall	800034a8 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
80003460:	0f 89       	ld.ub	r9,r7[0x0]
80003462:	30 08       	mov	r8,0
80003464:	f0 09 18 00 	cp.b	r9,r8
80003468:	c1 71       	brne	80003496 <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
8000346a:	49 8c       	lddpc	r12,800034c8 <sd_mmc_spi_internal_init+0x298>
8000346c:	f0 1f 00 18 	mcall	800034cc <sd_mmc_spi_internal_init+0x29c>
80003470:	c1 30       	breq	80003496 <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
80003472:	f0 1f 00 18 	mcall	800034d0 <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80003476:	30 19       	mov	r9,1
80003478:	48 e8       	lddpc	r8,800034b0 <sd_mmc_spi_internal_init+0x280>
8000347a:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
8000347c:	48 7b       	lddpc	r11,80003498 <sd_mmc_spi_internal_init+0x268>
8000347e:	e0 68 1b 00 	mov	r8,6912
80003482:	ea 18 00 b7 	orh	r8,0xb7
80003486:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80003488:	48 58       	lddpc	r8,8000349c <sd_mmc_spi_internal_init+0x26c>
8000348a:	70 0a       	ld.w	r10,r8[0x0]
8000348c:	fe 7c 24 00 	mov	r12,-56320
80003490:	f0 1f 00 04 	mcall	800034a0 <sd_mmc_spi_internal_init+0x270>
80003494:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
80003496:	d8 3a       	popm	r0-r7,pc,r12=0
80003498:	00 00       	add	r0,r0
8000349a:	74 a8       	ld.w	r8,r10[0x28]
8000349c:	00 00       	add	r0,r0
8000349e:	74 b8       	ld.w	r8,r10[0x2c]
800034a0:	80 00       	ld.sh	r0,r0[0x0]
800034a2:	3a e4       	mov	r4,-82
800034a4:	80 00       	ld.sh	r0,r0[0x0]
800034a6:	3c 10       	mov	r0,-63
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	3a a8       	mov	r8,-86
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	3b d0       	mov	r0,-67
800034b0:	00 00       	add	r0,r0
800034b2:	74 bc       	ld.w	r12,r10[0x2c]
800034b4:	00 00       	add	r0,r0
800034b6:	79 c6       	ld.w	r6,r12[0x70]
800034b8:	80 00       	ld.sh	r0,r0[0x0]
800034ba:	2c 78       	sub	r8,-57
800034bc:	00 00       	add	r0,r0
800034be:	79 d8       	ld.w	r8,r12[0x74]
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	2f 20       	sub	r0,-14
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	2e 94       	sub	r4,-23
800034c8:	00 00       	add	r0,r0
800034ca:	79 c8       	ld.w	r8,r12[0x70]
800034cc:	80 00       	ld.sh	r0,r0[0x0]
800034ce:	31 3c       	mov	r12,19
800034d0:	80 00       	ld.sh	r0,r0[0x0]
800034d2:	29 c0       	sub	r0,-100

800034d4 <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
800034d4:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
800034d6:	f0 1f 00 07 	mcall	800034f0 <sd_mmc_spi_mem_check+0x1c>
800034da:	c0 a0       	breq	800034ee <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
800034dc:	48 68       	lddpc	r8,800034f4 <sd_mmc_spi_mem_check+0x20>
800034de:	11 89       	ld.ub	r9,r8[0x0]
800034e0:	30 08       	mov	r8,0
800034e2:	f0 09 18 00 	cp.b	r9,r8
800034e6:	c0 20       	breq	800034ea <sd_mmc_spi_mem_check+0x16>
800034e8:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
800034ea:	f0 1f 00 04 	mcall	800034f8 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
800034ee:	d8 02       	popm	pc
800034f0:	80 00       	ld.sh	r0,r0[0x0]
800034f2:	2c b8       	sub	r8,-53
800034f4:	00 00       	add	r0,r0
800034f6:	74 bc       	ld.w	r12,r10[0x2c]
800034f8:	80 00       	ld.sh	r0,r0[0x0]
800034fa:	32 30       	mov	r0,35

800034fc <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
800034fc:	eb cd 40 10 	pushm	r4,lr
80003500:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
80003504:	48 88       	lddpc	r8,80003524 <sd_mmc_spi_init+0x28>
80003506:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
80003508:	48 88       	lddpc	r8,80003528 <sd_mmc_spi_init+0x2c>
8000350a:	e8 ea 00 00 	ld.d	r10,r4[0]
8000350e:	f0 eb 00 00 	st.d	r8[0],r10
80003512:	e8 ea 00 08 	ld.d	r10,r4[8]
80003516:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
8000351a:	f0 1f 00 05 	mcall	8000352c <sd_mmc_spi_init+0x30>
}
8000351e:	e3 cd 80 10 	ldm	sp++,r4,pc
80003522:	00 00       	add	r0,r0
80003524:	00 00       	add	r0,r0
80003526:	74 b8       	ld.w	r8,r10[0x2c]
80003528:	00 00       	add	r0,r0
8000352a:	74 a8       	ld.w	r8,r10[0x28]
8000352c:	80 00       	ld.sh	r0,r0[0x0]
8000352e:	32 30       	mov	r0,35

80003530 <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
80003530:	5e fd       	retal	0

80003532 <sd_mmc_spi_removal>:
//!/
bool  sd_mmc_spi_removal(void)
{
  return false;
//  return ((sd_mmc_spi_check_presence()) ? false : true);
}
80003532:	5e fd       	retal	0

80003534 <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
80003534:	d4 01       	pushm	lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
80003536:	49 88       	lddpc	r8,80003594 <sd_mmc_spi_test_unit_ready+0x60>
80003538:	11 88       	ld.ub	r8,r8[0x0]
8000353a:	30 19       	mov	r9,1
8000353c:	f2 08 18 00 	cp.b	r8,r9
80003540:	c1 40       	breq	80003568 <sd_mmc_spi_test_unit_ready+0x34>
80003542:	c0 63       	brcs	8000354e <sd_mmc_spi_test_unit_ready+0x1a>
80003544:	30 29       	mov	r9,2
80003546:	f2 08 18 00 	cp.b	r8,r9
8000354a:	c2 01       	brne	8000358a <sd_mmc_spi_test_unit_ready+0x56>
8000354c:	c1 a8       	rjmp	80003580 <sd_mmc_spi_test_unit_ready+0x4c>
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
8000354e:	30 09       	mov	r9,0
80003550:	49 28       	lddpc	r8,80003598 <sd_mmc_spi_test_unit_ready+0x64>
80003552:	b0 89       	st.b	r8[0x0],r9
      if (sd_mmc_spi_mem_check())
80003554:	f0 1f 00 12 	mcall	8000359c <sd_mmc_spi_test_unit_ready+0x68>
80003558:	c0 31       	brne	8000355e <sd_mmc_spi_test_unit_ready+0x2a>
8000355a:	30 2c       	mov	r12,2
8000355c:	d8 02       	popm	pc
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
8000355e:	30 19       	mov	r9,1
80003560:	48 d8       	lddpc	r8,80003594 <sd_mmc_spi_test_unit_ready+0x60>
80003562:	b0 89       	st.b	r8[0x0],r9
80003564:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
80003566:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
80003568:	f0 1f 00 0d 	mcall	8000359c <sd_mmc_spi_test_unit_ready+0x68>
8000356c:	c0 20       	breq	80003570 <sd_mmc_spi_test_unit_ready+0x3c>
8000356e:	d8 0a       	popm	pc,r12=0
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
80003570:	30 29       	mov	r9,2
80003572:	48 98       	lddpc	r8,80003594 <sd_mmc_spi_test_unit_ready+0x60>
80003574:	b0 89       	st.b	r8[0x0],r9
        sd_mmc_spi_init_done = false;
80003576:	30 09       	mov	r9,0
80003578:	48 88       	lddpc	r8,80003598 <sd_mmc_spi_test_unit_ready+0x64>
8000357a:	b0 89       	st.b	r8[0x0],r9
8000357c:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
8000357e:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80003580:	30 09       	mov	r9,0
80003582:	48 58       	lddpc	r8,80003594 <sd_mmc_spi_test_unit_ready+0x60>
80003584:	b0 89       	st.b	r8[0x0],r9
80003586:	30 2c       	mov	r12,2
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
80003588:	d8 02       	popm	pc

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
8000358a:	30 09       	mov	r9,0
8000358c:	48 28       	lddpc	r8,80003594 <sd_mmc_spi_test_unit_ready+0x60>
8000358e:	b0 89       	st.b	r8[0x0],r9
80003590:	30 3c       	mov	r12,3
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
80003592:	d8 02       	popm	pc
80003594:	00 00       	add	r0,r0
80003596:	00 08       	add	r8,r0
80003598:	00 00       	add	r0,r0
8000359a:	74 bc       	ld.w	r12,r10[0x2c]
8000359c:	80 00       	ld.sh	r0,r0[0x0]
8000359e:	34 d4       	mov	r4,77

800035a0 <sd_mmc_spi_mem_init>:

//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
800035a0:	d4 01       	pushm	lr
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
800035a2:	f0 1f 00 02 	mcall	800035a8 <sd_mmc_spi_mem_init+0x8>
}
800035a6:	d8 02       	popm	pc
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	32 30       	mov	r0,35

800035ac <sd_mmc_spi_ram_2_mem>:
//! @return                Ctrl_status
//!   It is ready      ->    CTRL_GOOD
//!   An error occurs  ->    CTRL_FAIL
//!
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
800035ac:	eb cd 40 c0 	pushm	r6-r7,lr
800035b0:	18 96       	mov	r6,r12
800035b2:	16 97       	mov	r7,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
800035b4:	f0 1f 00 12 	mcall	800035fc <sd_mmc_spi_ram_2_mem+0x50>

   if (!sd_mmc_spi_init_done)
800035b8:	49 28       	lddpc	r8,80003600 <sd_mmc_spi_ram_2_mem+0x54>
800035ba:	11 89       	ld.ub	r9,r8[0x0]
800035bc:	30 08       	mov	r8,0
800035be:	f0 09 18 00 	cp.b	r9,r8
800035c2:	c0 c1       	brne	800035da <sd_mmc_spi_ram_2_mem+0x2e>
   {
      sd_mmc_spi_mem_init();
800035c4:	f0 1f 00 10 	mcall	80003604 <sd_mmc_spi_ram_2_mem+0x58>
   }

   if (sd_mmc_spi_init_done)
800035c8:	48 e8       	lddpc	r8,80003600 <sd_mmc_spi_ram_2_mem+0x54>
800035ca:	11 89       	ld.ub	r9,r8[0x0]
800035cc:	30 08       	mov	r8,0
800035ce:	f0 09 18 00 	cp.b	r9,r8
800035d2:	c0 41       	brne	800035da <sd_mmc_spi_ram_2_mem+0x2e>
800035d4:	30 2c       	mov	r12,2
800035d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   {
     sd_mmc_spi_write_open(addr);
800035da:	0c 9c       	mov	r12,r6
800035dc:	f0 1f 00 0b 	mcall	80003608 <sd_mmc_spi_ram_2_mem+0x5c>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
800035e0:	0e 9c       	mov	r12,r7
800035e2:	f0 1f 00 0b 	mcall	8000360c <sd_mmc_spi_ram_2_mem+0x60>
800035e6:	c0 61       	brne	800035f2 <sd_mmc_spi_ram_2_mem+0x46>
     {
       sd_mmc_spi_write_close();
800035e8:	f0 1f 00 0a 	mcall	80003610 <sd_mmc_spi_ram_2_mem+0x64>
800035ec:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
800035ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     }
     sd_mmc_spi_write_close();
800035f2:	f0 1f 00 08 	mcall	80003610 <sd_mmc_spi_ram_2_mem+0x64>
800035f6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800035fa:	00 00       	add	r0,r0
800035fc:	80 00       	ld.sh	r0,r0[0x0]
800035fe:	2c b8       	sub	r8,-53
80003600:	00 00       	add	r0,r0
80003602:	74 bc       	ld.w	r12,r10[0x2c]
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	35 a0       	mov	r0,90
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	2b 6c       	sub	r12,-74
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	2d 34       	sub	r4,-45
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	2a dc       	sub	r12,-83

80003614 <sd_mmc_spi_mem_2_ram>:
//------------ Standard functions for read/write 1 sector to 1 sector ram buffer -----------------

#if ACCESS_MEM_TO_RAM == true

Ctrl_status sd_mmc_spi_mem_2_ram(uint32_t addr, void *ram)
{
80003614:	eb cd 40 c0 	pushm	r6-r7,lr
80003618:	18 97       	mov	r7,r12
8000361a:	16 96       	mov	r6,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
8000361c:	f0 1f 00 12 	mcall	80003664 <sd_mmc_spi_mem_2_ram+0x50>

   if (!sd_mmc_spi_init_done)
80003620:	49 28       	lddpc	r8,80003668 <sd_mmc_spi_mem_2_ram+0x54>
80003622:	11 89       	ld.ub	r9,r8[0x0]
80003624:	30 08       	mov	r8,0
80003626:	f0 09 18 00 	cp.b	r9,r8
8000362a:	c0 c1       	brne	80003642 <sd_mmc_spi_mem_2_ram+0x2e>
   {
      sd_mmc_spi_mem_init();
8000362c:	f0 1f 00 10 	mcall	8000366c <sd_mmc_spi_mem_2_ram+0x58>
   }

   if (!sd_mmc_spi_init_done)
80003630:	48 e8       	lddpc	r8,80003668 <sd_mmc_spi_mem_2_ram+0x54>
80003632:	11 89       	ld.ub	r9,r8[0x0]
80003634:	30 08       	mov	r8,0
80003636:	f0 09 18 00 	cp.b	r9,r8
8000363a:	c0 41       	brne	80003642 <sd_mmc_spi_mem_2_ram+0x2e>
8000363c:	30 2c       	mov	r12,2
8000363e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
80003642:	0e 9c       	mov	r12,r7
80003644:	f0 1f 00 0b 	mcall	80003670 <sd_mmc_spi_mem_2_ram+0x5c>
80003648:	c0 c0       	breq	80003660 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
8000364a:	0c 9c       	mov	r12,r6
8000364c:	f0 1f 00 0a 	mcall	80003674 <sd_mmc_spi_mem_2_ram+0x60>
80003650:	c0 80       	breq	80003660 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
80003652:	f0 1f 00 0a 	mcall	80003678 <sd_mmc_spi_mem_2_ram+0x64>
80003656:	ec 1c 00 01 	eorl	r12,0x1
8000365a:	5c 5c       	castu.b	r12
8000365c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003660:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	2c b8       	sub	r8,-53
80003668:	00 00       	add	r0,r0
8000366a:	74 bc       	ld.w	r12,r10[0x2c]
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	35 a0       	mov	r0,90
80003670:	80 00       	ld.sh	r0,r0[0x0]
80003672:	2b 94       	sub	r4,-71
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	2f d8       	sub	r8,-3
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	2b 88       	sub	r8,-72

8000367c <sd_mmc_spi_read_capacity>:
}



Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector)
{
8000367c:	eb cd 40 80 	pushm	r7,lr
80003680:	18 97       	mov	r7,r12
//   sd_mmc_spi_check_presence();   // omitted because creates interferences with "sd_mmc_spi_test_unit_ready()" function
   Sd_mmc_spi_access_signal_on();

   if (!sd_mmc_spi_init_done)
80003682:	48 c8       	lddpc	r8,800036b0 <sd_mmc_spi_read_capacity+0x34>
80003684:	11 89       	ld.ub	r9,r8[0x0]
80003686:	30 08       	mov	r8,0
80003688:	f0 09 18 00 	cp.b	r9,r8
8000368c:	c0 c1       	brne	800036a4 <sd_mmc_spi_read_capacity+0x28>
   {
      sd_mmc_spi_mem_init();
8000368e:	f0 1f 00 0a 	mcall	800036b4 <sd_mmc_spi_read_capacity+0x38>
   }

   if (sd_mmc_spi_init_done)
80003692:	48 88       	lddpc	r8,800036b0 <sd_mmc_spi_read_capacity+0x34>
80003694:	11 89       	ld.ub	r9,r8[0x0]
80003696:	30 08       	mov	r8,0
80003698:	f0 09 18 00 	cp.b	r9,r8
8000369c:	c0 41       	brne	800036a4 <sd_mmc_spi_read_capacity+0x28>
8000369e:	30 2c       	mov	r12,2
800036a0:	e3 cd 80 80 	ldm	sp++,r7,pc
   {
     *nb_sector = sd_mmc_spi_last_block_address+1;
800036a4:	48 58       	lddpc	r8,800036b8 <sd_mmc_spi_read_capacity+0x3c>
800036a6:	70 08       	ld.w	r8,r8[0x0]
800036a8:	2f f8       	sub	r8,-1
800036aa:	8f 08       	st.w	r7[0x0],r8
800036ac:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
800036b0:	00 00       	add	r0,r0
800036b2:	74 bc       	ld.w	r12,r10[0x2c]
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	35 a0       	mov	r0,90
800036b8:	00 00       	add	r0,r0
800036ba:	79 c0       	ld.w	r0,r12[0x70]

800036bc <sdramc_ck_delay>:
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
800036bc:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
800036c0:	f0 0c 00 0c 	add	r12,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
800036c4:	18 38       	cp.w	r8,r12
800036c6:	e0 88 00 06 	brls	800036d2 <sdramc_ck_delay+0x16>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
800036ca:	e1 b8 00 42 	mfsr	r8,0x108
800036ce:	10 3c       	cp.w	r12,r8
800036d0:	cf d3       	brcs	800036ca <sdramc_ck_delay+0xe>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
800036d2:	e1 b8 00 42 	mfsr	r8,0x108
800036d6:	10 3c       	cp.w	r12,r8
800036d8:	fe 9b ff fd 	brhi	800036d2 <sdramc_ck_delay+0x16>
}
800036dc:	5e fc       	retal	r12
800036de:	d7 03       	nop

800036e0 <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
800036e0:	d4 31       	pushm	r0-r7,lr
800036e2:	20 2d       	sub	sp,8
800036e4:	18 91       	mov	r1,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
800036e6:	ee 7b 42 3f 	mov	r11,999999
800036ea:	f8 0b 00 09 	add	r9,r12,r11
800036ee:	e0 60 de 83 	mov	r0,56963
800036f2:	ea 10 43 1b 	orh	r0,0x431b
800036f6:	f2 00 06 48 	mulu.d	r8,r9,r0
800036fa:	f2 06 16 12 	lsr	r6,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
800036fe:	32 7b       	mov	r11,39
80003700:	4d 0c       	lddpc	r12,80003840 <sdramc_init+0x160>
80003702:	f0 1f 00 51 	mcall	80003844 <sdramc_init+0x164>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80003706:	fe 68 10 00 	mov	r8,-126976
8000370a:	f0 f9 01 24 	ld.w	r9,r8[292]
8000370e:	a1 b9       	sbr	r9,0x1
80003710:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80003714:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80003718:	ec 09 15 04 	lsl	r9,r6,0x4
8000371c:	0c 19       	sub	r9,r6
8000371e:	f2 c3 fc 19 	sub	r3,r9,-999
80003722:	e0 65 4d d3 	mov	r5,19923
80003726:	ea 15 10 62 	orh	r5,0x1062
8000372a:	e6 05 06 42 	mulu.d	r2,r3,r5
8000372e:	a7 83       	lsr	r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80003730:	ec 02 15 05 	lsl	r2,r6,0x5
80003734:	0c 02       	add	r2,r6
80003736:	a1 72       	lsl	r2,0x1
80003738:	e4 06 00 0b 	add	r11,r2,r6
8000373c:	f6 cb fc 19 	sub	r11,r11,-999
80003740:	f6 05 06 4a 	mulu.d	r10,r11,r5
80003744:	a7 8b       	lsr	r11,0x6
80003746:	bd 6b       	lsl	r11,0x1c
80003748:	16 9c       	mov	r12,r11
8000374a:	e8 1c 00 d9 	orl	r12,0xd9
8000374e:	ec 08 15 03 	lsl	r8,r6,0x3
80003752:	f0 06 01 0a 	sub	r10,r8,r6
80003756:	a1 7a       	lsl	r10,0x1
80003758:	f4 c7 fc 19 	sub	r7,r10,-999
8000375c:	ee 05 06 4a 	mulu.d	r10,r7,r5
80003760:	fa eb 00 00 	st.d	sp[0],r10
80003764:	40 0a       	lddsp	r10,sp[0x0]
80003766:	a3 6a       	lsl	r10,0x2
80003768:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000376c:	14 4c       	or	r12,r10
8000376e:	a3 69       	lsl	r9,0x2
80003770:	f2 c9 fc 19 	sub	r9,r9,-999
80003774:	f2 05 06 4a 	mulu.d	r10,r9,r5
80003778:	fa eb 00 00 	st.d	sp[0],r10
8000377c:	40 09       	lddsp	r9,sp[0x0]
8000377e:	a7 69       	lsl	r9,0x6
80003780:	e2 19 f0 00 	andl	r9,0xf000,COH
80003784:	f9 e9 10 0a 	or	r10,r12,r9
80003788:	e6 09 15 10 	lsl	r9,r3,0x10
8000378c:	e6 19 00 0f 	andh	r9,0xf,COH
80003790:	12 4a       	or	r10,r9
80003792:	e6 09 15 14 	lsl	r9,r3,0x14
80003796:	e6 19 00 f0 	andh	r9,0xf0,COH
8000379a:	12 4a       	or	r10,r9
8000379c:	f0 06 00 09 	add	r9,r8,r6
800037a0:	ec 09 00 29 	add	r9,r6,r9<<0x2
800037a4:	f2 c9 fc 19 	sub	r9,r9,-999
800037a8:	f2 05 06 48 	mulu.d	r8,r9,r5
800037ac:	b3 69       	lsl	r9,0x12
800037ae:	e6 19 0f 00 	andh	r9,0xf00,COH
800037b2:	f5 e9 10 08 	or	r8,r10,r9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
800037b6:	fe 67 20 00 	mov	r7,-122880
800037ba:	8f 28       	st.w	r7[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
800037bc:	6e 28       	ld.w	r8,r7[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
800037be:	30 18       	mov	r8,1
800037c0:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800037c2:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
800037c4:	fc 14 d0 00 	movh	r4,0xd000
800037c8:	88 08       	ld.sh	r8,r4[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
800037ca:	ec 0c 10 64 	mul	r12,r6,100
800037ce:	f0 1f 00 1f 	mcall	80003848 <sdramc_init+0x168>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
800037d2:	30 28       	mov	r8,2
800037d4:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800037d6:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
800037d8:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
800037da:	06 9c       	mov	r12,r3
800037dc:	f0 1f 00 1b 	mcall	80003848 <sdramc_init+0x168>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
800037e0:	30 48       	mov	r8,4
800037e2:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800037e4:	6e 08       	ld.w	r8,r7[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
800037e6:	e4 c3 fc 19 	sub	r3,r2,-999
800037ea:	e6 05 06 42 	mulu.d	r2,r3,r5
800037ee:	a7 83       	lsr	r3,0x6
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
800037f0:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
800037f2:	06 9c       	mov	r12,r3
800037f4:	f0 1f 00 15 	mcall	80003848 <sdramc_init+0x168>
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
800037f8:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
800037fa:	06 9c       	mov	r12,r3
800037fc:	f0 1f 00 13 	mcall	80003848 <sdramc_init+0x168>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
80003800:	30 38       	mov	r8,3
80003802:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003804:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003806:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
80003808:	ec 09 15 01 	lsl	r9,r6,0x1
8000380c:	f2 c9 fc 19 	sub	r9,r9,-999
80003810:	f2 05 06 48 	mulu.d	r8,r9,r5
80003814:	f2 0c 16 06 	lsr	r12,r9,0x6
80003818:	f0 1f 00 0c 	mcall	80003848 <sdramc_init+0x168>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
8000381c:	30 08       	mov	r8,0
8000381e:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80003820:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80003822:	88 08       	ld.sh	r8,r4[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
80003824:	e2 00 06 40 	mulu.d	r0,r1,r0
80003828:	b3 81       	lsr	r1,0x12
8000382a:	e0 68 1e 84 	mov	r8,7812
8000382e:	b1 31       	mul	r1,r8
80003830:	e2 05 06 44 	mulu.d	r4,r1,r5
80003834:	a7 85       	lsr	r5,0x6
80003836:	8f 15       	st.w	r7[0x4],r5
  AVR32_SDRAMC.tr;
80003838:	6e 18       	ld.w	r8,r7[0x4]
}
8000383a:	2f ed       	sub	sp,-8
8000383c:	d8 32       	popm	r0-r7,pc
8000383e:	00 00       	add	r0,r0
80003840:	80 00       	ld.sh	r0,r0[0x0]
80003842:	af 18       	ld.d	r8,--r7
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	84 1c       	ld.sh	r12,r2[0x2]
80003848:	80 00       	ld.sh	r0,r0[0x0]
8000384a:	36 bc       	mov	r12,107

8000384c <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
8000384c:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003850:	ee 78 42 3f 	mov	r8,999999
80003854:	f8 08 00 09 	add	r9,r12,r8
80003858:	e0 68 de 83 	mov	r8,56963
8000385c:	ea 18 43 1b 	orh	r8,0x431b
80003860:	f2 08 06 48 	mulu.d	r8,r9,r8
80003864:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80003868:	f0 08 00 25 	add	r5,r8,r8<<0x2
8000386c:	a3 65       	lsl	r5,0x2
8000386e:	ea c5 fc 19 	sub	r5,r5,-999
80003872:	e0 69 4d d3 	mov	r9,19923
80003876:	ea 19 10 62 	orh	r9,0x1062
8000387a:	ea 09 06 44 	mulu.d	r4,r5,r9
8000387e:	a7 85       	lsr	r5,0x6
80003880:	f0 0a 15 04 	lsl	r10,r8,0x4
80003884:	f4 08 01 07 	sub	r7,r10,r8
80003888:	a1 77       	lsl	r7,0x1
8000388a:	ee c7 fc 19 	sub	r7,r7,-999
8000388e:	ee 09 06 46 	mulu.d	r6,r7,r9
80003892:	0e 94       	mov	r4,r7
80003894:	a7 84       	lsr	r4,0x6
80003896:	f4 08 01 07 	sub	r7,r10,r8
8000389a:	a3 67       	lsl	r7,0x2
8000389c:	ee c7 fc 19 	sub	r7,r7,-999
800038a0:	ee 09 06 46 	mulu.d	r6,r7,r9
800038a4:	a7 87       	lsr	r7,0x6
800038a6:	f0 03 10 5a 	mul	r3,r8,90
800038aa:	e6 c3 fc 19 	sub	r3,r3,-999
800038ae:	e6 09 06 42 	mulu.d	r2,r3,r9
800038b2:	e6 0c 16 06 	lsr	r12,r3,0x6
800038b6:	e0 63 00 d2 	mov	r3,210
800038ba:	f0 03 02 43 	mul	r3,r8,r3
800038be:	e6 c3 fc 19 	sub	r3,r3,-999
800038c2:	e6 09 06 42 	mulu.d	r2,r3,r9
800038c6:	e6 06 16 06 	lsr	r6,r3,0x6
800038ca:	f4 08 01 0b 	sub	r11,r10,r8
800038ce:	a5 6b       	lsl	r11,0x4
800038d0:	f6 cb fc 19 	sub	r11,r11,-999
800038d4:	f6 09 06 4a 	mulu.d	r10,r11,r9
800038d8:	f6 0e 16 06 	lsr	lr,r11,0x6
800038dc:	f0 03 10 64 	mul	r3,r8,100
800038e0:	e6 c3 fc 19 	sub	r3,r3,-999
800038e4:	e6 09 06 42 	mulu.d	r2,r3,r9
800038e8:	a7 83       	lsr	r3,0x6
800038ea:	e0 6a 01 0e 	mov	r10,270
800038ee:	b5 38       	mul	r8,r10
800038f0:	f0 c8 fc 19 	sub	r8,r8,-999
800038f4:	f0 09 06 48 	mulu.d	r8,r8,r9
800038f8:	a7 89       	lsr	r9,0x6
800038fa:	ec 04 00 0a 	add	r10,r6,r4
800038fe:	1c 3a       	cp.w	r10,lr
80003900:	f4 0e 17 20 	movhs	lr,r10
80003904:	ee 05 00 0b 	add	r11,r7,r5
80003908:	18 3b       	cp.w	r11,r12
8000390a:	f6 0c 17 20 	movhs	r12,r11
8000390e:	06 3b       	cp.w	r11,r3
80003910:	e6 0b 17 30 	movlo	r11,r3
80003914:	12 3a       	cp.w	r10,r9
80003916:	f4 09 17 20 	movhs	r9,r10
8000391a:	eb e4 11 05 	or	r5,r5,r4<<0x10
8000391e:	fe 6a 1c 00 	mov	r10,-123904
80003922:	95 05       	st.w	r10[0x0],r5
80003924:	ef e6 11 07 	or	r7,r7,r6<<0x10
80003928:	ef ec 10 87 	or	r7,r7,r12<<0x8
8000392c:	ef ee 11 87 	or	r7,r7,lr<<0x18
80003930:	95 17       	st.w	r10[0x4],r7
80003932:	1c 39       	cp.w	r9,lr
80003934:	f2 0e 17 20 	movhs	lr,r9
80003938:	18 3b       	cp.w	r11,r12
8000393a:	f8 0b 17 30 	movlo	r11,r12
8000393e:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
80003942:	95 2b       	st.w	r10[0x8],r11
80003944:	e0 68 10 03 	mov	r8,4099
80003948:	95 38       	st.w	r10[0xc],r8
8000394a:	30 19       	mov	r9,1
8000394c:	48 48       	lddpc	r8,8000395c <smc_init+0x110>
8000394e:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80003950:	31 4b       	mov	r11,20
80003952:	48 4c       	lddpc	r12,80003960 <smc_init+0x114>
80003954:	f0 1f 00 04 	mcall	80003964 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80003958:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000395c:	00 00       	add	r0,r0
8000395e:	74 c0       	ld.w	r0,r10[0x30]
80003960:	80 00       	ld.sh	r0,r0[0x0]
80003962:	b0 50       	st.h	r8[0xa],r0
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	84 1c       	ld.sh	r12,r2[0x2]

80003968 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80003968:	58 0b       	cp.w	r11,0
8000396a:	c1 90       	breq	8000399c <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
8000396c:	58 6c       	cp.w	r12,6
8000396e:	e0 8b 00 17 	brhi	8000399c <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80003972:	76 0a       	ld.w	r10,r11[0x0]
80003974:	fe 78 30 00 	mov	r8,-53248
80003978:	f8 c9 ff f0 	sub	r9,r12,-16
8000397c:	a5 79       	lsl	r9,0x5
8000397e:	f0 09 00 09 	add	r9,r8,r9
80003982:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003984:	76 19       	ld.w	r9,r11[0x4]
80003986:	a5 7c       	lsl	r12,0x5
80003988:	f0 0c 00 0c 	add	r12,r8,r12
8000398c:	f8 c8 fd fc 	sub	r8,r12,-516
80003990:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80003992:	76 28       	ld.w	r8,r11[0x8]
80003994:	f8 cc fd f8 	sub	r12,r12,-520
80003998:	99 08       	st.w	r12[0x0],r8
8000399a:	5e fd       	retal	0

  return PWM_SUCCESS;
8000399c:	5e ff       	retal	1

8000399e <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
8000399e:	18 98       	mov	r8,r12
800039a0:	e0 18 ff 80 	andl	r8,0xff80
800039a4:	c0 20       	breq	800039a8 <pwm_start_channels+0xa>
800039a6:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800039a8:	fe 78 30 00 	mov	r8,-53248
800039ac:	91 1c       	st.w	r8[0x4],r12
800039ae:	5e fd       	retal	0

800039b0 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
800039b0:	58 6c       	cp.w	r12,6
800039b2:	e0 88 00 03 	brls	800039b8 <pwm_async_update_channel+0x8>
800039b6:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
800039b8:	76 0a       	ld.w	r10,r11[0x0]
800039ba:	fe 78 30 00 	mov	r8,-53248
800039be:	f8 c9 ff f0 	sub	r9,r12,-16
800039c2:	a5 79       	lsl	r9,0x5
800039c4:	f0 09 00 09 	add	r9,r8,r9
800039c8:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
800039ca:	76 49       	ld.w	r9,r11[0x10]
800039cc:	a5 7c       	lsl	r12,0x5
800039ce:	18 08       	add	r8,r12
800039d0:	f0 c8 fd f0 	sub	r8,r8,-528
800039d4:	91 09       	st.w	r8[0x0],r9
800039d6:	5e fd       	retal	0

800039d8 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800039d8:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
800039dc:	58 0c       	cp.w	r12,0
800039de:	c0 21       	brne	800039e2 <pwm_init+0xa>
800039e0:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800039e2:	e6 18 00 01 	andh	r8,0x1,COH
800039e6:	c0 91       	brne	800039f8 <pwm_init+0x20>
800039e8:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800039ea:	fe 78 30 00 	mov	r8,-53248
800039ee:	37 f9       	mov	r9,127
800039f0:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800039f2:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800039f4:	d5 03       	csrf	0x10
800039f6:	c0 68       	rjmp	80003a02 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800039f8:	fe 78 30 00 	mov	r8,-53248
800039fc:	37 f9       	mov	r9,127
800039fe:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80003a00:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003a02:	78 08       	ld.w	r8,r12[0x0]
80003a04:	78 39       	ld.w	r9,r12[0xc]
80003a06:	a9 69       	lsl	r9,0x8
80003a08:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80003a0c:	78 18       	ld.w	r8,r12[0x4]
80003a0e:	10 49       	or	r9,r8
80003a10:	78 28       	ld.w	r8,r12[0x8]
80003a12:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80003a16:	fe 78 30 00 	mov	r8,-53248
80003a1a:	91 09       	st.w	r8[0x0],r9
80003a1c:	5e fd       	retal	0

80003a1e <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80003a1e:	f8 c8 00 01 	sub	r8,r12,1
80003a22:	f0 0b 00 0b 	add	r11,r8,r11
80003a26:	f6 0c 0d 0a 	divu	r10,r11,r12
80003a2a:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80003a2c:	f4 c8 00 01 	sub	r8,r10,1
80003a30:	e0 48 00 fe 	cp.w	r8,254
80003a34:	e0 88 00 03 	brls	80003a3a <getBaudDiv+0x1c>
80003a38:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80003a3a:	5c 8c       	casts.h	r12
}
80003a3c:	5e fc       	retal	r12

80003a3e <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003a3e:	f7 39 00 0d 	ld.ub	r9,r11[13]
80003a42:	30 18       	mov	r8,1
80003a44:	f0 09 18 00 	cp.b	r9,r8
80003a48:	e0 88 00 04 	brls	80003a50 <spi_initMaster+0x12>
80003a4c:	30 2c       	mov	r12,2
80003a4e:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003a50:	e0 68 00 80 	mov	r8,128
80003a54:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003a56:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80003a58:	30 19       	mov	r9,1
80003a5a:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80003a5e:	f7 39 00 0d 	ld.ub	r9,r11[13]
80003a62:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80003a66:	30 09       	mov	r9,0
80003a68:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80003a6c:	30 fa       	mov	r10,15
80003a6e:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80003a72:	99 18       	st.w	r12[0x4],r8
80003a74:	5e f9       	retal	r9

80003a76 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80003a76:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003a78:	30 18       	mov	r8,1
80003a7a:	f0 0b 18 00 	cp.b	r11,r8
80003a7e:	5f be       	srhi	lr
80003a80:	f0 0a 18 00 	cp.b	r10,r8
80003a84:	5f b8       	srhi	r8
80003a86:	fd e8 10 08 	or	r8,lr,r8
80003a8a:	c0 30       	breq	80003a90 <spi_selectionMode+0x1a>
80003a8c:	30 2c       	mov	r12,2
80003a8e:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80003a90:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80003a92:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003a96:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80003a9a:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80003a9e:	99 18       	st.w	r12[0x4],r8
80003aa0:	d8 0a       	popm	pc,r12=0

80003aa2 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80003aa2:	30 18       	mov	r8,1
80003aa4:	99 08       	st.w	r12[0x0],r8
}
80003aa6:	5e fc       	retal	r12

80003aa8 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80003aa8:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003aac:	c0 58       	rjmp	80003ab6 <spi_write+0xe>
		if (!timeout--) {
80003aae:	58 08       	cp.w	r8,0
80003ab0:	c0 21       	brne	80003ab4 <spi_write+0xc>
80003ab2:	5e ff       	retal	1
80003ab4:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003ab6:	78 49       	ld.w	r9,r12[0x10]
80003ab8:	e2 19 00 02 	andl	r9,0x2,COH
80003abc:	cf 90       	breq	80003aae <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80003abe:	5c 7b       	castu.h	r11
80003ac0:	99 3b       	st.w	r12[0xc],r11
80003ac2:	5e fd       	retal	0

80003ac4 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003ac4:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003ac8:	c0 58       	rjmp	80003ad2 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80003aca:	58 08       	cp.w	r8,0
80003acc:	c0 21       	brne	80003ad0 <spi_read+0xc>
80003ace:	5e ff       	retal	1
80003ad0:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003ad2:	78 49       	ld.w	r9,r12[0x10]
80003ad4:	e2 19 02 01 	andl	r9,0x201,COH
80003ad8:	e0 49 02 01 	cp.w	r9,513
80003adc:	cf 71       	brne	80003aca <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80003ade:	78 28       	ld.w	r8,r12[0x8]
80003ae0:	b6 08       	st.h	r11[0x0],r8
80003ae2:	5e fd       	retal	0

80003ae4 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80003ae4:	eb cd 40 f8 	pushm	r3-r7,lr
80003ae8:	18 95       	mov	r5,r12
80003aea:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003aec:	f7 36 00 0c 	ld.ub	r6,r11[12]
80003af0:	30 38       	mov	r8,3
80003af2:	f0 06 18 00 	cp.b	r6,r8
80003af6:	e0 8b 00 5f 	brhi	80003bb4 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
80003afa:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003afe:	30 18       	mov	r8,1
80003b00:	f0 04 18 00 	cp.b	r4,r8
80003b04:	e0 8b 00 58 	brhi	80003bb4 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003b08:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003b0c:	30 78       	mov	r8,7
80003b0e:	f0 03 18 00 	cp.b	r3,r8
80003b12:	e0 88 00 51 	brls	80003bb4 <spi_setupChipReg+0xd0>
80003b16:	31 08       	mov	r8,16
80003b18:	f0 03 18 00 	cp.b	r3,r8
80003b1c:	e0 8b 00 4c 	brhi	80003bb4 <spi_setupChipReg+0xd0>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80003b20:	14 9b       	mov	r11,r10
80003b22:	6e 1c       	ld.w	r12,r7[0x4]
80003b24:	f0 1f 00 27 	mcall	80003bc0 <spi_setupChipReg+0xdc>

	if (baudDiv < 0) {
80003b28:	c4 65       	brlt	80003bb4 <spi_setupChipReg+0xd0>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80003b2a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003b2c:	ec 09 16 01 	lsr	r9,r6,0x1
80003b30:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80003b34:	ec 16 00 01 	eorl	r6,0x1
80003b38:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003b3c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80003b40:	20 83       	sub	r3,8
80003b42:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80003b46:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003b4a:	ef 39 00 09 	ld.ub	r9,r7[9]
80003b4e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003b52:	ef 39 00 0a 	ld.ub	r9,r7[10]
80003b56:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80003b5a:	0f 89       	ld.ub	r9,r7[0x0]
80003b5c:	30 1a       	mov	r10,1
80003b5e:	f4 09 18 00 	cp.b	r9,r10
80003b62:	c0 d0       	breq	80003b7c <spi_setupChipReg+0x98>
80003b64:	c0 a3       	brcs	80003b78 <spi_setupChipReg+0x94>
80003b66:	30 2a       	mov	r10,2
80003b68:	f4 09 18 00 	cp.b	r9,r10
80003b6c:	c0 a0       	breq	80003b80 <spi_setupChipReg+0x9c>
80003b6e:	30 3a       	mov	r10,3
80003b70:	f4 09 18 00 	cp.b	r9,r10
80003b74:	c2 01       	brne	80003bb4 <spi_setupChipReg+0xd0>
80003b76:	c0 78       	rjmp	80003b84 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80003b78:	8b c8       	st.w	r5[0x30],r8
		break;
80003b7a:	c0 68       	rjmp	80003b86 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80003b7c:	8b d8       	st.w	r5[0x34],r8
		break;
80003b7e:	c0 48       	rjmp	80003b86 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80003b80:	8b e8       	st.w	r5[0x38],r8
		break;
80003b82:	c0 28       	rjmp	80003b86 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80003b84:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80003b86:	49 08       	lddpc	r8,80003bc4 <spi_setupChipReg+0xe0>
80003b88:	70 08       	ld.w	r8,r8[0x0]
80003b8a:	58 08       	cp.w	r8,0
80003b8c:	c1 71       	brne	80003bba <spi_setupChipReg+0xd6>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80003b8e:	30 3a       	mov	r10,3
80003b90:	30 0b       	mov	r11,0
80003b92:	30 1c       	mov	r12,1
80003b94:	f0 1f 00 0d 	mcall	80003bc8 <spi_setupChipReg+0xe4>
80003b98:	48 b8       	lddpc	r8,80003bc4 <spi_setupChipReg+0xe0>
80003b9a:	91 0c       	st.w	r8[0x0],r12
80003b9c:	58 0c       	cp.w	r12,0
80003b9e:	c0 a0       	breq	80003bb2 <spi_setupChipReg+0xce>
80003ba0:	30 09       	mov	r9,0
80003ba2:	12 9a       	mov	r10,r9
80003ba4:	12 9b       	mov	r11,r9
80003ba6:	f0 1f 00 0a 	mcall	80003bcc <spi_setupChipReg+0xe8>
		if (!xSPIMutex) {
80003baa:	48 78       	lddpc	r8,80003bc4 <spi_setupChipReg+0xe0>
80003bac:	70 08       	ld.w	r8,r8[0x0]
80003bae:	58 08       	cp.w	r8,0
80003bb0:	c0 51       	brne	80003bba <spi_setupChipReg+0xd6>
80003bb2:	c0 08       	rjmp	80003bb2 <spi_setupChipReg+0xce>
80003bb4:	30 2c       	mov	r12,2
80003bb6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003bba:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80003bbe:	00 00       	add	r0,r0
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	3a 1e       	mov	lr,-95
80003bc4:	00 00       	add	r0,r0
80003bc6:	79 dc       	ld.w	r12,r12[0x74]
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	76 5c       	ld.w	r12,r11[0x14]
80003bcc:	80 00       	ld.sh	r0,r0[0x0]
80003bce:	74 c8       	ld.w	r8,r10[0x30]

80003bd0 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003bd0:	d4 01       	pushm	lr
80003bd2:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003bd6:	c0 58       	rjmp	80003be0 <spi_unselectChip+0x10>
		if (!timeout--) {
80003bd8:	58 08       	cp.w	r8,0
80003bda:	c0 21       	brne	80003bde <spi_unselectChip+0xe>
80003bdc:	da 0a       	popm	pc,r12=1
80003bde:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003be0:	78 49       	ld.w	r9,r12[0x10]
80003be2:	e2 19 02 00 	andl	r9,0x200,COH
80003be6:	cf 90       	breq	80003bd8 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003be8:	78 18       	ld.w	r8,r12[0x4]
80003bea:	ea 18 00 0f 	orh	r8,0xf
80003bee:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003bf0:	fc 18 01 00 	movh	r8,0x100
80003bf4:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80003bf6:	30 09       	mov	r9,0
80003bf8:	12 9a       	mov	r10,r9
80003bfa:	12 9b       	mov	r11,r9
80003bfc:	48 38       	lddpc	r8,80003c08 <spi_unselectChip+0x38>
80003bfe:	70 0c       	ld.w	r12,r8[0x0]
80003c00:	f0 1f 00 03 	mcall	80003c0c <spi_unselectChip+0x3c>
80003c04:	d8 0a       	popm	pc,r12=0
80003c06:	00 00       	add	r0,r0
80003c08:	00 00       	add	r0,r0
80003c0a:	79 dc       	ld.w	r12,r12[0x74]
80003c0c:	80 00       	ld.sh	r0,r0[0x0]
80003c0e:	74 c8       	ld.w	r8,r10[0x30]

80003c10 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003c10:	d4 21       	pushm	r4-r7,lr
80003c12:	18 95       	mov	r5,r12
80003c14:	16 94       	mov	r4,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80003c16:	49 86       	lddpc	r6,80003c74 <spi_selectChip+0x64>
80003c18:	31 47       	mov	r7,20
80003c1a:	0e 9b       	mov	r11,r7
80003c1c:	6c 0c       	ld.w	r12,r6[0x0]
80003c1e:	f0 1f 00 17 	mcall	80003c78 <spi_selectChip+0x68>
80003c22:	cf c0       	breq	80003c1a <spi_selectChip+0xa>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003c24:	6a 18       	ld.w	r8,r5[0x4]
80003c26:	ea 18 00 0f 	orh	r8,0xf
80003c2a:	8b 18       	st.w	r5[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80003c2c:	6a 18       	ld.w	r8,r5[0x4]
80003c2e:	e2 18 00 04 	andl	r8,0x4,COH
80003c32:	c1 00       	breq	80003c52 <spi_selectChip+0x42>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80003c34:	30 e8       	mov	r8,14
80003c36:	f0 04 18 00 	cp.b	r4,r8
80003c3a:	e0 8b 00 1a 	brhi	80003c6e <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003c3e:	6a 19       	ld.w	r9,r5[0x4]
80003c40:	e8 08 15 10 	lsl	r8,r4,0x10
80003c44:	ea 18 ff f0 	orh	r8,0xfff0
80003c48:	e8 18 ff ff 	orl	r8,0xffff
80003c4c:	12 68       	and	r8,r9
80003c4e:	8b 18       	st.w	r5[0x4],r8
80003c50:	d8 2a       	popm	r4-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80003c52:	30 38       	mov	r8,3
80003c54:	f0 04 18 00 	cp.b	r4,r8
80003c58:	e0 8b 00 0b 	brhi	80003c6e <spi_selectChip+0x5e>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80003c5c:	6a 19       	ld.w	r9,r5[0x4]
80003c5e:	2f 04       	sub	r4,-16
80003c60:	30 18       	mov	r8,1
80003c62:	f0 04 09 48 	lsl	r8,r8,r4
80003c66:	5c d8       	com	r8
80003c68:	12 68       	and	r8,r9
80003c6a:	8b 18       	st.w	r5[0x4],r8
80003c6c:	d8 2a       	popm	r4-r7,pc,r12=0
80003c6e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80003c70:	d8 22       	popm	r4-r7,pc
80003c72:	00 00       	add	r0,r0
80003c74:	00 00       	add	r0,r0
80003c76:	79 dc       	ld.w	r12,r12[0x74]
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	72 e4       	ld.w	r4,r9[0x38]

80003c7c <fat_check_open>:
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
80003c7c:	48 68       	lddpc	r8,80003c94 <fat_check_open+0x18>
80003c7e:	11 89       	ld.ub	r9,r8[0x0]
80003c80:	30 08       	mov	r8,0
80003c82:	f0 09 18 00 	cp.b	r9,r8
80003c86:	c0 20       	breq	80003c8a <fat_check_open+0xe>
80003c88:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
80003c8a:	31 79       	mov	r9,23
80003c8c:	48 38       	lddpc	r8,80003c98 <fat_check_open+0x1c>
80003c8e:	b0 89       	st.b	r8[0x0],r9
80003c90:	5e fd       	retal	0
80003c92:	00 00       	add	r0,r0
80003c94:	00 00       	add	r0,r0
80003c96:	79 e4       	ld.w	r4,r12[0x78]
80003c98:	00 00       	add	r0,r0
80003c9a:	7c 74       	ld.w	r4,lr[0x1c]

80003c9c <fat_check_select>:
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
80003c9c:	48 68       	lddpc	r8,80003cb4 <fat_check_select+0x18>
80003c9e:	90 19       	ld.sh	r9,r8[0x2]
80003ca0:	3f f8       	mov	r8,-1
80003ca2:	f0 09 19 00 	cp.h	r9,r8
80003ca6:	c0 20       	breq	80003caa <fat_check_select+0xe>
80003ca8:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
80003caa:	30 f9       	mov	r9,15
80003cac:	48 38       	lddpc	r8,80003cb8 <fat_check_select+0x1c>
80003cae:	b0 89       	st.b	r8[0x0],r9
80003cb0:	5e fd       	retal	0
80003cb2:	00 00       	add	r0,r0
80003cb4:	00 00       	add	r0,r0
80003cb6:	7c 70       	ld.w	r0,lr[0x1c]
80003cb8:	00 00       	add	r0,r0
80003cba:	7c 74       	ld.w	r4,lr[0x1c]

80003cbc <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
80003cbc:	48 58       	lddpc	r8,80003cd0 <fat_check_is_file+0x14>
80003cbe:	11 a8       	ld.ub	r8,r8[0x2]
80003cc0:	e2 18 00 18 	andl	r8,0x18,COH
80003cc4:	c0 21       	brne	80003cc8 <fat_check_is_file+0xc>
80003cc6:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
80003cc8:	31 39       	mov	r9,19
80003cca:	48 38       	lddpc	r8,80003cd4 <fat_check_is_file+0x18>
80003ccc:	b0 89       	st.b	r8[0x0],r9
80003cce:	5e fd       	retal	0
80003cd0:	00 00       	add	r0,r0
80003cd2:	79 e4       	ld.w	r4,r12[0x78]
80003cd4:	00 00       	add	r0,r0
80003cd6:	7c 74       	ld.w	r4,lr[0x1c]

80003cd8 <fat_checkcluster>:
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
80003cd8:	49 68       	lddpc	r8,80003d30 <fat_checkcluster+0x58>
80003cda:	70 18       	ld.w	r8,r8[0x4]
80003cdc:	58 08       	cp.w	r8,0
80003cde:	c0 21       	brne	80003ce2 <fat_checkcluster+0xa>
80003ce0:	5e ff       	retal	1
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
80003ce2:	49 59       	lddpc	r9,80003d34 <fat_checkcluster+0x5c>
80003ce4:	13 89       	ld.ub	r9,r9[0x0]
80003ce6:	30 3a       	mov	r10,3
80003ce8:	f4 09 18 00 	cp.b	r9,r10
80003cec:	c0 a1       	brne	80003d00 <fat_checkcluster+0x28>
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
80003cee:	e0 69 ff f7 	mov	r9,65527
80003cf2:	ea 19 0f ff 	orh	r9,0xfff
80003cf6:	12 38       	cp.w	r8,r9
80003cf8:	e0 8b 00 19 	brhi	80003d2a <fat_checkcluster+0x52>
80003cfc:	5f 0c       	sreq	r12
80003cfe:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
80003d00:	30 2a       	mov	r10,2
80003d02:	f4 09 18 00 	cp.b	r9,r10
80003d06:	c0 71       	brne	80003d14 <fat_checkcluster+0x3c>
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
80003d08:	e0 48 ff f7 	cp.w	r8,65527
80003d0c:	e0 8b 00 0f 	brhi	80003d2a <fat_checkcluster+0x52>
80003d10:	5f 0c       	sreq	r12
80003d12:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
80003d14:	30 1a       	mov	r10,1
80003d16:	f4 09 18 00 	cp.b	r9,r10
80003d1a:	c0 20       	breq	80003d1e <fat_checkcluster+0x46>
80003d1c:	5e fd       	retal	0
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
80003d1e:	e0 48 0f f7 	cp.w	r8,4087
80003d22:	e0 8b 00 04 	brhi	80003d2a <fat_checkcluster+0x52>
80003d26:	5f 0c       	sreq	r12
80003d28:	5e fc       	retal	r12
80003d2a:	30 2c       	mov	r12,2
    else if (fs_g_cluster.u32_val == 0xFF7)
      return FS_CLUS_BAD;
  }

  return FS_CLUS_OK;
}
80003d2c:	5e fc       	retal	r12
80003d2e:	00 00       	add	r0,r0
80003d30:	00 00       	add	r0,r0
80003d32:	7c c4       	ld.w	r4,lr[0x30]
80003d34:	00 00       	add	r0,r0
80003d36:	7c 70       	ld.w	r0,lr[0x1c]

80003d38 <fat_cache_clusterlist_reset>:
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
80003d38:	30 0a       	mov	r10,0
80003d3a:	48 88       	lddpc	r8,80003d58 <fat_cache_clusterlist_reset+0x20>
80003d3c:	b0 8a       	st.b	r8[0x0],r10
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
80003d3e:	48 88       	lddpc	r8,80003d5c <fat_cache_clusterlist_reset+0x24>
80003d40:	30 19       	mov	r9,1
80003d42:	b0 89       	st.b	r8[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80003d44:	3f f9       	mov	r9,-1
80003d46:	b0 a9       	st.b	r8[0x2],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
80003d48:	b0 99       	st.b	r8[0x1],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
80003d4a:	f1 6a 00 14 	st.b	r8[20],r10
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80003d4e:	f1 69 00 16 	st.b	r8[22],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
80003d52:	f1 69 00 15 	st.b	r8[21],r9
   }
}
80003d56:	5e fc       	retal	r12
80003d58:	00 00       	add	r0,r0
80003d5a:	7c 76       	ld.w	r6,lr[0x1c]
80003d5c:	00 00       	add	r0,r0
80003d5e:	79 f8       	ld.w	r8,r12[0x7c]

80003d60 <fat_cache_clusterlist_update_start>:
//! This function initializes a cache in cluster list caches
//!
//! @param     b_for_file  If true then it is a file cluster list else a directory cluster list  <br>
//!
void  fat_cache_clusterlist_update_start( bool b_for_file )
{
80003d60:	48 ea       	lddpc	r10,80003d98 <fat_cache_clusterlist_update_start+0x38>
80003d62:	15 88       	ld.ub	r8,r10[0x0]
80003d64:	f8 08 18 00 	cp.b	r8,r12
80003d68:	5f 18       	srne	r8
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
80003d6a:	48 d9       	lddpc	r9,80003d9c <fat_cache_clusterlist_update_start+0x3c>
80003d6c:	b2 88       	st.b	r9[0x0],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
80003d6e:	f0 0b 15 02 	lsl	r11,r8,0x2
80003d72:	f6 08 00 09 	add	r9,r11,r8
80003d76:	f4 09 00 29 	add	r9,r10,r9<<0x2
80003d7a:	b2 8c       	st.b	r9[0x0],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80003d7c:	3f fc       	mov	r12,-1
80003d7e:	b2 ac       	st.b	r9[0x2],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
80003d80:	f6 08 00 08 	add	r8,r11,r8
80003d84:	2f f8       	sub	r8,-1
80003d86:	48 7b       	lddpc	r11,80003da0 <fat_cache_clusterlist_update_start+0x40>
80003d88:	76 0b       	ld.w	r11,r11[0x0]
80003d8a:	f4 08 09 2b 	st.w	r10[r8<<0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
80003d8e:	48 68       	lddpc	r8,80003da4 <fat_cache_clusterlist_update_start+0x44>
80003d90:	70 18       	ld.w	r8,r8[0x4]
80003d92:	93 28       	st.w	r9[0x8],r8
}
80003d94:	5e fc       	retal	r12
80003d96:	00 00       	add	r0,r0
80003d98:	00 00       	add	r0,r0
80003d9a:	79 f8       	ld.w	r8,r12[0x7c]
80003d9c:	00 00       	add	r0,r0
80003d9e:	7c 76       	ld.w	r6,lr[0x1c]
80003da0:	00 00       	add	r0,r0
80003da2:	7c c4       	ld.w	r4,lr[0x30]
80003da4:	00 00       	add	r0,r0
80003da6:	7c cc       	ld.w	r12,lr[0x30]

80003da8 <fat_cache_clusterlist_update_select>:
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
80003da8:	49 88       	lddpc	r8,80003e08 <fat_cache_clusterlist_update_select+0x60>
80003daa:	11 88       	ld.ub	r8,r8[0x0]
80003dac:	49 8a       	lddpc	r10,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003dae:	f0 08 00 2b 	add	r11,r8,r8<<0x2
80003db2:	f4 0b 00 2b 	add	r11,r10,r11<<0x2
80003db6:	17 89       	ld.ub	r9,r11[0x0]
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
80003db8:	17 9b       	ld.ub	r11,r11[0x1]
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
80003dba:	15 8a       	ld.ub	r10,r10[0x0]
80003dbc:	f2 0a 18 00 	cp.b	r10,r9
80003dc0:	c0 a1       	brne	80003dd4 <fat_cache_clusterlist_update_select+0x2c>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80003dc2:	49 3a       	lddpc	r10,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003dc4:	15 9a       	ld.ub	r10,r10[0x1]
80003dc6:	f4 0b 18 00 	cp.b	r11,r10
80003dca:	e0 88 00 05 	brls	80003dd4 <fat_cache_clusterlist_update_select+0x2c>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80003dce:	2f fa       	sub	r10,-1
80003dd0:	48 fc       	lddpc	r12,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003dd2:	b8 9a       	st.b	r12[0x1],r10

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
80003dd4:	48 ea       	lddpc	r10,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003dd6:	f5 3a 00 14 	ld.ub	r10,r10[20]
80003dda:	f2 0a 18 00 	cp.b	r10,r9
80003dde:	c0 c1       	brne	80003df6 <fat_cache_clusterlist_update_select+0x4e>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
80003de0:	48 b9       	lddpc	r9,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003de2:	f3 39 00 15 	ld.ub	r9,r9[21]
80003de6:	f2 0b 18 00 	cp.b	r11,r9
80003dea:	e0 88 00 06 	brls	80003df6 <fat_cache_clusterlist_update_select+0x4e>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
80003dee:	2f f9       	sub	r9,-1
80003df0:	48 7a       	lddpc	r10,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003df2:	f5 69 00 15 	st.b	r10[21],r9
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
80003df6:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003dfa:	48 59       	lddpc	r9,80003e0c <fat_cache_clusterlist_update_select+0x64>
80003dfc:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003e00:	30 09       	mov	r9,0
80003e02:	b0 99       	st.b	r8[0x1],r9
}
80003e04:	5e fc       	retal	r12
80003e06:	00 00       	add	r0,r0
80003e08:	00 00       	add	r0,r0
80003e0a:	7c 76       	ld.w	r6,lr[0x1c]
80003e0c:	00 00       	add	r0,r0
80003e0e:	79 f8       	ld.w	r8,r12[0x7c]

80003e10 <fat_cache_clusterlist_update_finish>:


//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
80003e10:	eb cd 40 c0 	pushm	r6-r7,lr
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
80003e14:	49 08       	lddpc	r8,80003e54 <fat_cache_clusterlist_update_finish+0x44>
80003e16:	11 88       	ld.ub	r8,r8[0x0]
80003e18:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003e1c:	48 f9       	lddpc	r9,80003e58 <fat_cache_clusterlist_update_finish+0x48>
80003e1e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003e22:	f0 ca ff f8 	sub	r10,r8,-8
80003e26:	48 eb       	lddpc	r11,80003e5c <fat_cache_clusterlist_update_finish+0x4c>
80003e28:	17 97       	ld.ub	r7,r11[0x1]
80003e2a:	74 09       	ld.w	r9,r10[0x0]
80003e2c:	f2 07 0d 06 	divu	r6,r9,r7
80003e30:	0e 99       	mov	r9,r7
80003e32:	5c 59       	castu.b	r9
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
80003e34:	17 8b       	ld.ub	r11,r11[0x0]
80003e36:	b0 ab       	st.b	r8[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
80003e38:	74 0b       	ld.w	r11,r10[0x0]
80003e3a:	12 1b       	sub	r11,r9
80003e3c:	95 0b       	st.w	r10[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
80003e3e:	48 9a       	lddpc	r10,80003e60 <fat_cache_clusterlist_update_finish+0x50>
80003e40:	74 0b       	ld.w	r11,r10[0x0]
80003e42:	12 1b       	sub	r11,r9
80003e44:	91 3b       	st.w	r8[0xc],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
80003e46:	74 1a       	ld.w	r10,r10[0x4]
80003e48:	14 09       	add	r9,r10
80003e4a:	91 49       	st.w	r8[0x10],r9

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
80003e4c:	f0 1f 00 06 	mcall	80003e64 <fat_cache_clusterlist_update_finish+0x54>
}
80003e50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003e54:	00 00       	add	r0,r0
80003e56:	7c 76       	ld.w	r6,lr[0x1c]
80003e58:	00 00       	add	r0,r0
80003e5a:	79 f8       	ld.w	r8,r12[0x7c]
80003e5c:	00 00       	add	r0,r0
80003e5e:	7c 24       	ld.w	r4,lr[0x8]
80003e60:	00 00       	add	r0,r0
80003e62:	7c cc       	ld.w	r12,lr[0x30]
80003e64:	80 00       	ld.sh	r0,r0[0x0]
80003e66:	3d a8       	mov	r8,-38

80003e68 <fat_cache_clusterlist_update_read>:
//!
//! @return    true  cluster list found and global variable fs_g_seg updated
//! @return    false no found in cluster list caches
//!
bool  fat_cache_clusterlist_update_read( bool b_for_file )
{
80003e68:	eb cd 40 c0 	pushm	r6-r7,lr
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
80003e6c:	4c 18       	lddpc	r8,80003f70 <fat_cache_clusterlist_update_read+0x108>
80003e6e:	11 89       	ld.ub	r9,r8[0x0]
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003e70:	4c 18       	lddpc	r8,80003f74 <fat_cache_clusterlist_update_read+0x10c>
80003e72:	70 0a       	ld.w	r10,r8[0x0]
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003e74:	4c 18       	lddpc	r8,80003f78 <fat_cache_clusterlist_update_read+0x110>
80003e76:	70 1b       	ld.w	r11,r8[0x4]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80003e78:	4c 18       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003e7a:	11 88       	ld.ub	r8,r8[0x0]
80003e7c:	f8 08 18 00 	cp.b	r8,r12
80003e80:	c1 11       	brne	80003ea2 <fat_cache_clusterlist_update_read+0x3a>
80003e82:	4b f8       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003e84:	11 a8       	ld.ub	r8,r8[0x2]
80003e86:	f2 08 18 00 	cp.b	r8,r9
80003e8a:	c0 c1       	brne	80003ea2 <fat_cache_clusterlist_update_read+0x3a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003e8c:	4b c8       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003e8e:	70 18       	ld.w	r8,r8[0x4]
80003e90:	14 38       	cp.w	r8,r10
80003e92:	c0 81       	brne	80003ea2 <fat_cache_clusterlist_update_read+0x3a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003e94:	4b a8       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003e96:	70 28       	ld.w	r8,r8[0x8]
80003e98:	10 3b       	cp.w	r11,r8
80003e9a:	c0 43       	brcs	80003ea2 <fat_cache_clusterlist_update_read+0x3a>
80003e9c:	30 0a       	mov	r10,0
80003e9e:	14 99       	mov	r9,r10
80003ea0:	c1 88       	rjmp	80003ed0 <fat_cache_clusterlist_update_read+0x68>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80003ea2:	4b 78       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003ea4:	f1 38 00 14 	ld.ub	r8,r8[20]
80003ea8:	f8 08 18 00 	cp.b	r8,r12
80003eac:	c5 e1       	brne	80003f68 <fat_cache_clusterlist_update_read+0x100>
80003eae:	4b 48       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003eb0:	f1 38 00 16 	ld.ub	r8,r8[22]
80003eb4:	f2 08 18 00 	cp.b	r8,r9
80003eb8:	c5 81       	brne	80003f68 <fat_cache_clusterlist_update_read+0x100>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003eba:	4b 18       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003ebc:	70 68       	ld.w	r8,r8[0x18]
80003ebe:	14 38       	cp.w	r8,r10
80003ec0:	c5 41       	brne	80003f68 <fat_cache_clusterlist_update_read+0x100>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003ec2:	4a f8       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003ec4:	70 78       	ld.w	r8,r8[0x1c]
80003ec6:	16 38       	cp.w	r8,r11
80003ec8:	e0 8b 00 50 	brhi	80003f68 <fat_cache_clusterlist_update_read+0x100>
80003ecc:	30 1a       	mov	r10,1
80003ece:	14 99       	mov	r9,r10
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
80003ed0:	f2 0e 15 02 	lsl	lr,r9,0x2
80003ed4:	12 0e       	add	lr,r9
80003ed6:	4a ac       	lddpc	r12,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003ed8:	f8 0e 00 2c 	add	r12,r12,lr<<0x2
80003edc:	78 4c       	ld.w	r12,r12[0x10]
80003ede:	f6 08 01 08 	sub	r8,r11,r8
80003ee2:	10 3c       	cp.w	r12,r8
80003ee4:	e0 88 00 16 	brls	80003f10 <fat_cache_clusterlist_update_read+0xa8>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
80003ee8:	4a 4b       	lddpc	r11,80003f78 <fat_cache_clusterlist_update_read+0x110>
80003eea:	f2 0e 15 02 	lsl	lr,r9,0x2
80003eee:	fc 09 00 09 	add	r9,lr,r9
80003ef2:	4a 3e       	lddpc	lr,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003ef4:	fc 09 00 29 	add	r9,lr,r9<<0x2
80003ef8:	72 39       	ld.w	r9,r9[0xc]
80003efa:	f0 09 00 09 	add	r9,r8,r9
80003efe:	97 09       	st.w	r11[0x0],r9
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
80003f00:	10 1c       	sub	r12,r8
80003f02:	97 1c       	st.w	r11[0x4],r12
                  fs_g_u8_current_cache = u8_i;
80003f04:	49 f8       	lddpc	r8,80003f80 <fat_cache_clusterlist_update_read+0x118>
80003f06:	b0 8a       	st.b	r8[0x0],r10
                  fat_cache_clusterlist_update_select();
80003f08:	f0 1f 00 1f 	mcall	80003f84 <fat_cache_clusterlist_update_read+0x11c>
80003f0c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
80003f10:	49 c8       	lddpc	r8,80003f80 <fat_cache_clusterlist_update_read+0x118>
80003f12:	b0 8a       	st.b	r8[0x0],r10
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
80003f14:	f2 08 15 02 	lsl	r8,r9,0x2
80003f18:	f0 09 00 09 	add	r9,r8,r9
80003f1c:	49 88       	lddpc	r8,80003f7c <fat_cache_clusterlist_update_read+0x114>
80003f1e:	f0 09 00 28 	add	r8,r8,r9<<0x2
80003f22:	3f f9       	mov	r9,-1
80003f24:	b0 a9       	st.b	r8[0x2],r9
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
80003f26:	70 4c       	ld.w	r12,r8[0x10]
80003f28:	49 2a       	lddpc	r10,80003f70 <fat_cache_clusterlist_update_read+0x108>
80003f2a:	15 99       	ld.ub	r9,r10[0x1]
80003f2c:	70 3e       	ld.w	lr,r8[0xc]
80003f2e:	f8 0e 00 0e 	add	lr,r12,lr
80003f32:	20 1e       	sub	lr,1
80003f34:	74 57       	ld.w	r7,r10[0x14]
80003f36:	fc 07 01 07 	sub	r7,lr,r7
80003f3a:	74 4a       	ld.w	r10,r10[0x10]
80003f3c:	14 17       	sub	r7,r10
80003f3e:	ee 09 0d 06 	divu	r6,r7,r9
80003f42:	0c 97       	mov	r7,r6
80003f44:	2f e7       	sub	r7,-2
80003f46:	48 ca       	lddpc	r10,80003f74 <fat_cache_clusterlist_update_read+0x10c>
80003f48:	95 07       	st.w	r10[0x0],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
80003f4a:	2f 88       	sub	r8,-8
80003f4c:	70 0a       	ld.w	r10,r8[0x0]
80003f4e:	14 0c       	add	r12,r10
80003f50:	f8 c7 00 01 	sub	r7,r12,1
80003f54:	ee 09 0d 06 	divu	r6,r7,r9
80003f58:	ad 39       	mul	r9,r6
80003f5a:	48 8a       	lddpc	r10,80003f78 <fat_cache_clusterlist_update_read+0x110>
80003f5c:	f6 09 01 09 	sub	r9,r11,r9
80003f60:	95 19       	st.w	r10[0x4],r9
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
80003f62:	91 0b       	st.w	r8[0x0],r11
80003f64:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
         }
      }
   }
   // No found in cache then read FAT and store the result in cache
   fat_cache_clusterlist_update_start(b_for_file);
80003f68:	f0 1f 00 08 	mcall	80003f88 <fat_cache_clusterlist_update_read+0x120>
80003f6c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003f70:	00 00       	add	r0,r0
80003f72:	7c 24       	ld.w	r4,lr[0x8]
80003f74:	00 00       	add	r0,r0
80003f76:	7c c4       	ld.w	r4,lr[0x30]
80003f78:	00 00       	add	r0,r0
80003f7a:	7c cc       	ld.w	r12,lr[0x30]
80003f7c:	00 00       	add	r0,r0
80003f7e:	79 f8       	ld.w	r8,r12[0x7c]
80003f80:	00 00       	add	r0,r0
80003f82:	7c 76       	ld.w	r6,lr[0x1c]
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	3d a8       	mov	r8,-38
80003f88:	80 00       	ld.sh	r0,r0[0x0]
80003f8a:	3d 60       	mov	r0,-42

80003f8c <fat_clear_entry_info_and_ptr>:

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
80003f8c:	3f f9       	mov	r9,-1
80003f8e:	48 c8       	lddpc	r8,80003fbc <fat_clear_entry_info_and_ptr+0x30>
80003f90:	b0 19       	st.h	r8[0x2],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
80003f92:	48 c8       	lddpc	r8,80003fc0 <fat_clear_entry_info_and_ptr+0x34>
80003f94:	f1 59 00 24 	st.h	r8[36],r9
   if( !fs_g_nav.b_mode_nav_single )
80003f98:	f1 39 00 2d 	ld.ub	r9,r8[45]
80003f9c:	30 08       	mov	r8,0
80003f9e:	f0 09 18 00 	cp.b	r9,r8
80003fa2:	c0 51       	brne	80003fac <fat_clear_entry_info_and_ptr+0x20>
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
80003fa4:	10 99       	mov	r9,r8
80003fa6:	48 78       	lddpc	r8,80003fc0 <fat_clear_entry_info_and_ptr+0x34>
80003fa8:	f1 69 00 2c 	st.b	r8[44],r9
   }
   fs_g_nav_entry.u8_attr     = 0;
80003fac:	48 68       	lddpc	r8,80003fc4 <fat_clear_entry_info_and_ptr+0x38>
80003fae:	30 09       	mov	r9,0
80003fb0:	b0 a9       	st.b	r8[0x2],r9
   fs_g_nav_entry.u32_cluster = 0;
80003fb2:	30 0a       	mov	r10,0
80003fb4:	91 1a       	st.w	r8[0x4],r10
   fs_g_nav_entry.u32_size    = 0;
80003fb6:	91 2a       	st.w	r8[0x8],r10
   Fat_file_close();
80003fb8:	b0 89       	st.b	r8[0x0],r9
}
80003fba:	5e fc       	retal	r12
80003fbc:	00 00       	add	r0,r0
80003fbe:	7c 70       	ld.w	r0,lr[0x1c]
80003fc0:	00 00       	add	r0,r0
80003fc2:	7c 24       	ld.w	r4,lr[0x8]
80003fc4:	00 00       	add	r0,r0
80003fc6:	79 e4       	ld.w	r4,r12[0x78]

80003fc8 <fat_check_eof_name>:
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
80003fc8:	30 08       	mov	r8,0
80003fca:	f0 0c 19 00 	cp.h	r12,r8
80003fce:	5f 0a       	sreq	r10
80003fd0:	35 c9       	mov	r9,92
80003fd2:	f2 0c 19 00 	cp.h	r12,r9
80003fd6:	5f 09       	sreq	r9
80003fd8:	f5 e9 10 09 	or	r9,r10,r9
80003fdc:	f0 09 18 00 	cp.b	r9,r8
80003fe0:	c0 20       	breq	80003fe4 <fat_check_eof_name+0x1c>
80003fe2:	5e ff       	retal	1
80003fe4:	32 f8       	mov	r8,47
80003fe6:	f0 0c 19 00 	cp.h	r12,r8
80003fea:	5f 0c       	sreq	r12
}
80003fec:	5e fc       	retal	r12
80003fee:	d7 03       	nop

80003ff0 <fat_get_ptr_entry>:
//! This function returns a cache pointer on the current entry
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
80003ff0:	48 48       	lddpc	r8,80004000 <fat_get_ptr_entry+0x10>
80003ff2:	90 98       	ld.uh	r8,r8[0x2]
80003ff4:	a5 78       	lsl	r8,0x5
80003ff6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
}
80003ffa:	48 3c       	lddpc	r12,80004004 <fat_get_ptr_entry+0x14>
80003ffc:	10 0c       	add	r12,r8
80003ffe:	5e fc       	retal	r12
80004000:	00 00       	add	r0,r0
80004002:	7c 70       	ld.w	r0,lr[0x1c]
80004004:	00 00       	add	r0,r0
80004006:	7a 24       	ld.w	r4,sp[0x8]

80004008 <fat_entry_longname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_longname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case )
{
80004008:	d4 31       	pushm	r0-r7,lr
8000400a:	20 3d       	sub	sp,12
8000400c:	18 97       	mov	r7,r12
8000400e:	16 94       	mov	r4,r11
80004010:	14 96       	mov	r6,r10
80004012:	50 09       	stdsp	sp[0x0],r9
   uint8_t u8_pos_name;
   PTR_CACHE ptr_entry;
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();
80004014:	f0 1f 00 5e 	mcall	8000418c <fat_entry_longname+0x184>

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
80004018:	19 88       	ld.ub	r8,r12[0x0]
8000401a:	30 09       	mov	r9,0
8000401c:	f2 08 18 00 	cp.b	r8,r9
80004020:	5f 0b       	sreq	r11
80004022:	3e 5a       	mov	r10,-27
80004024:	f4 08 18 00 	cp.b	r8,r10
80004028:	5f 0a       	sreq	r10
8000402a:	f7 ea 10 0a 	or	r10,r11,r10
8000402e:	f2 0a 18 00 	cp.b	r10,r9
80004032:	c0 71       	brne	80004040 <fat_entry_longname+0x38>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
80004034:	f9 3a 00 0b 	ld.ub	r10,r12[11]
80004038:	30 f9       	mov	r9,15
8000403a:	f2 0a 18 00 	cp.b	r10,r9
8000403e:	c0 60       	breq	8000404a <fat_entry_longname+0x42>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
80004040:	30 b9       	mov	r9,11
80004042:	4d 48       	lddpc	r8,80004190 <fat_entry_longname+0x188>
80004044:	b0 89       	st.b	r8[0x0],r9
80004046:	30 0c       	mov	r12,0
      return false;
80004048:	c9 c8       	rjmp	80004180 <fat_entry_longname+0x178>
   }

   if( g_b_string_length )
8000404a:	4d 39       	lddpc	r9,80004194 <fat_entry_longname+0x18c>
8000404c:	13 8a       	ld.ub	r10,r9[0x0]
8000404e:	30 09       	mov	r9,0
80004050:	f2 0a 18 00 	cp.b	r10,r9
80004054:	c0 90       	breq	80004066 <fat_entry_longname+0x5e>
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
80004056:	e2 18 00 40 	andl	r8,0x40,COH
8000405a:	c0 61       	brne	80004066 <fat_entry_longname+0x5e>
      {
         // no necessary -> ((FS_STR_UNICODE)sz_name)[0] = FS_SIZE_LFN_ENTRY;
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
8000405c:	31 09       	mov	r9,16
8000405e:	4c d8       	lddpc	r8,80004190 <fat_entry_longname+0x188>
80004060:	b0 89       	st.b	r8[0x0],r9
80004062:	30 0c       	mov	r12,0
         return false;                          // Other entry long name
80004064:	c8 e8       	rjmp	80004180 <fat_entry_longname+0x178>
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
80004066:	2f fc       	sub	r12,-1
80004068:	30 08       	mov	r8,0

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000406a:	fa ca ff f6 	sub	r10,sp,-10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
8000406e:	30 0b       	mov	r11,0
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
80004070:	4c 95       	lddpc	r5,80004194 <fat_entry_longname+0x18c>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80004072:	20 14       	sub	r4,1
80004074:	50 14       	stdsp	sp[0x4],r4
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
80004076:	30 01       	mov	r1,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80004078:	30 44       	mov	r4,4
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000407a:	19 89       	ld.ub	r9,r12[0x0]
8000407c:	b4 99       	st.b	r10[0x1],r9
      MSB(u16_unicode_entry) = ptr_entry[1];
8000407e:	19 99       	ld.ub	r9,r12[0x1]
80004080:	b4 89       	st.b	r10[0x0],r9
      if( FS_NAME_GET == b_mode )
80004082:	58 06       	cp.w	r6,0
80004084:	c0 f0       	breq	800040a2 <fat_entry_longname+0x9a>
      {
         if( !g_b_string_length )
80004086:	0b 89       	ld.ub	r9,r5[0x0]
80004088:	f6 09 18 00 	cp.b	r9,r11
8000408c:	c3 91       	brne	800040fe <fat_entry_longname+0xf6>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
8000408e:	40 1e       	lddsp	lr,sp[0x4]
80004090:	1c 38       	cp.w	r8,lr
80004092:	c0 55       	brlt	8000409c <fat_entry_longname+0x94>
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004094:	30 08       	mov	r8,0
80004096:	ae 88       	st.b	r7[0x0],r8
80004098:	30 1c       	mov	r12,1
               }
               return true;                     // the buffer is full
8000409a:	c7 38       	rjmp	80004180 <fat_entry_longname+0x178>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
8000409c:	9a 59       	ld.sh	r9,sp[0xa]
8000409e:	ae 89       	st.b	r7[0x0],r9
800040a0:	c2 f8       	rjmp	800040fe <fat_entry_longname+0xf6>
      {
         if( Is_unicode )
         {
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
800040a2:	0f 89       	ld.ub	r9,r7[0x0]
         }
         // Check the name
         if( '*' == u16_unicode_szname )
800040a4:	32 a3       	mov	r3,42
800040a6:	e6 09 19 00 	cp.h	r9,r3
800040aa:	c6 a0       	breq	8000417e <fat_entry_longname+0x176>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
800040ac:	9a 5e       	ld.sh	lr,sp[0xa]
800040ae:	58 0e       	cp.w	lr,0
800040b0:	c0 e1       	brne	800040cc <fat_entry_longname+0xc4>
800040b2:	35 c0       	mov	r0,92
800040b4:	e0 09 19 00 	cp.h	r9,r0
800040b8:	5f 12       	srne	r2
800040ba:	32 f3       	mov	r3,47
800040bc:	e6 09 19 00 	cp.h	r9,r3
800040c0:	5f 13       	srne	r3
800040c2:	e5 e3 00 03 	and	r3,r2,r3
800040c6:	f6 03 18 00 	cp.b	r3,r11
800040ca:	c1 e0       	breq	80004106 <fat_entry_longname+0xfe>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
800040cc:	e7 d9 c0 10 	bfextu	r3,r9,0x0,0x10
800040d0:	e5 de c0 10 	bfextu	r2,lr,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
800040d4:	e4 c0 ff e0 	sub	r0,r2,-32
800040d8:	00 33       	cp.w	r3,r0
800040da:	c0 41       	brne	800040e2 <fat_entry_longname+0xda>
800040dc:	40 00       	lddsp	r0,sp[0x0]
800040de:	58 00       	cp.w	r0,0
800040e0:	c0 f0       	breq	800040fe <fat_entry_longname+0xf6>
800040e2:	22 02       	sub	r2,32
800040e4:	04 33       	cp.w	r3,r2
800040e6:	c0 41       	brne	800040ee <fat_entry_longname+0xe6>
800040e8:	40 03       	lddsp	r3,sp[0x0]
800040ea:	58 03       	cp.w	r3,0
800040ec:	c0 90       	breq	800040fe <fat_entry_longname+0xf6>
800040ee:	fc 09 19 00 	cp.h	r9,lr
800040f2:	c0 60       	breq	800040fe <fat_entry_longname+0xf6>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
800040f4:	31 69       	mov	r9,22
800040f6:	4a 78       	lddpc	r8,80004190 <fat_entry_longname+0x188>
800040f8:	b0 89       	st.b	r8[0x0],r9
800040fa:	30 0c       	mov	r12,0
           return false;
800040fc:	c4 28       	rjmp	80004180 <fat_entry_longname+0x178>
         }
      }

      if( 0 == u16_unicode_entry)
800040fe:	9a 59       	ld.sh	r9,sp[0xa]
80004100:	e2 09 19 00 	cp.h	r9,r1
80004104:	c0 b1       	brne	8000411a <fat_entry_longname+0x112>
      {
         if( g_b_string_length )
80004106:	4a 49       	lddpc	r9,80004194 <fat_entry_longname+0x18c>
80004108:	13 8a       	ld.ub	r10,r9[0x0]
8000410a:	30 09       	mov	r9,0
8000410c:	f2 0a 18 00 	cp.b	r10,r9
80004110:	c3 70       	breq	8000417e <fat_entry_longname+0x176>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
80004112:	2f f8       	sub	r8,-1
80004114:	ae 08       	st.h	r7[0x0],r8
80004116:	30 1c       	mov	r12,1
80004118:	c3 48       	rjmp	80004180 <fat_entry_longname+0x178>
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000411a:	e8 08 18 00 	cp.b	r8,r4
8000411e:	c0 31       	brne	80004124 <fat_entry_longname+0x11c>
         ptr_entry += 3;                        // Go to second character
80004120:	2f dc       	sub	r12,-3
80004122:	c2 58       	rjmp	8000416c <fat_entry_longname+0x164>

      if( 10 == u8_pos_name )
80004124:	30 a9       	mov	r9,10
80004126:	f2 08 18 00 	cp.b	r8,r9
8000412a:	c0 31       	brne	80004130 <fat_entry_longname+0x128>
         ptr_entry += 2;                        // Go to third character
8000412c:	2f ec       	sub	r12,-2
8000412e:	c1 f8       	rjmp	8000416c <fat_entry_longname+0x164>

      if( 12 == u8_pos_name )
80004130:	30 c9       	mov	r9,12
80004132:	f2 08 18 00 	cp.b	r8,r9
80004136:	c1 b1       	brne	8000416c <fat_entry_longname+0x164>
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
80004138:	f9 38 ff e2 	ld.ub	r8,r12[-30]
8000413c:	e2 18 00 40 	andl	r8,0x40,COH
80004140:	c0 61       	brne	8000414c <fat_entry_longname+0x144>
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
80004142:	31 09       	mov	r9,16
80004144:	49 38       	lddpc	r8,80004190 <fat_entry_longname+0x188>
80004146:	b0 89       	st.b	r8[0x0],r9
80004148:	30 0c       	mov	r12,0
            return false;                       // Other long name entry is present
8000414a:	c1 b8       	rjmp	80004180 <fat_entry_longname+0x178>
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
8000414c:	58 06       	cp.w	r6,0
8000414e:	c0 b0       	breq	80004164 <fat_entry_longname+0x15c>
80004150:	49 18       	lddpc	r8,80004194 <fat_entry_longname+0x18c>
80004152:	11 89       	ld.ub	r9,r8[0x0]
80004154:	30 08       	mov	r8,0
80004156:	f0 09 18 00 	cp.b	r9,r8
8000415a:	c1 50       	breq	80004184 <fat_entry_longname+0x17c>
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
8000415c:	30 e8       	mov	r8,14
8000415e:	ae 08       	st.h	r7[0x0],r8
80004160:	30 1c       	mov	r12,1
               return true;
80004162:	c0 f8       	rjmp	80004180 <fat_entry_longname+0x178>
               {
                  u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
               }else{
                  u16_unicode_szname = sz_name[0];
               }
               return fat_check_eof_name(u16_unicode_szname);
80004164:	0f 9c       	ld.ub	r12,r7[0x1]
80004166:	f0 1f 00 0d 	mcall	80004198 <fat_entry_longname+0x190>
8000416a:	c0 b8       	rjmp	80004180 <fat_entry_longname+0x178>
            }
         }
      }

      if( !g_b_string_length )
8000416c:	0b 89       	ld.ub	r9,r5[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
8000416e:	f6 09 18 00 	cp.b	r9,r11
80004172:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80004176:	2f f8       	sub	r8,-1
80004178:	5c 58       	castu.b	r8
      ptr_entry+=2;
8000417a:	2f ec       	sub	r12,-2
   }
8000417c:	c7 fb       	rjmp	8000407a <fat_entry_longname+0x72>
8000417e:	30 1c       	mov	r12,1
}
80004180:	2f dd       	sub	sp,-12
80004182:	d8 32       	popm	r0-r7,pc
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80004184:	30 08       	mov	r8,0
80004186:	ae 98       	st.b	r7[0x1],r8
80004188:	30 1c       	mov	r12,1
               }
               return true;
8000418a:	cf bb       	rjmp	80004180 <fat_entry_longname+0x178>
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	3f f0       	mov	r0,-1
80004190:	00 00       	add	r0,r0
80004192:	7c 74       	ld.w	r4,lr[0x1c]
80004194:	00 00       	add	r0,r0
80004196:	7c 75       	ld.w	r5,lr[0x1c]
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	3f c8       	mov	r8,-4

8000419c <fat_entry_shortname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_shortname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode )
{
8000419c:	d4 31       	pushm	r0-r7,lr
8000419e:	20 2d       	sub	sp,8
800041a0:	18 97       	mov	r7,r12
800041a2:	50 1b       	stdsp	sp[0x4],r11
800041a4:	14 96       	mov	r6,r10
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
800041a6:	31 69       	mov	r9,22
800041a8:	4b c8       	lddpc	r8,80004298 <fat_entry_shortname+0xfc>
800041aa:	b0 89       	st.b	r8[0x0],r9

   u8_pos_name = 0;
   u8_pos_entry = 0;
   ptr_entry = fat_get_ptr_entry();
800041ac:	f0 1f 00 3c 	mcall	8000429c <fat_entry_shortname+0x100>
800041b0:	30 08       	mov	r8,0
800041b2:	10 9a       	mov	r10,r8
800041b4:	30 1b       	mov	r11,1
800041b6:	50 0b       	stdsp	sp[0x0],r11

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
800041b8:	30 be       	mov	lr,11
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800041ba:	10 93       	mov	r3,r8
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800041bc:	30 85       	mov	r5,8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800041be:	32 04       	mov	r4,32
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
800041c0:	32 a2       	mov	r2,42
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
800041c2:	fc 08 18 00 	cp.b	r8,lr
800041c6:	c1 90       	breq	800041f8 <fat_entry_shortname+0x5c>
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
800041c8:	f8 08 07 09 	ld.ub	r9,r12[r8]
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800041cc:	ea 08 18 00 	cp.b	r8,r5
800041d0:	c0 41       	brne	800041d8 <fat_entry_shortname+0x3c>
800041d2:	40 01       	lddsp	r1,sp[0x0]
800041d4:	58 01       	cp.w	r1,0
800041d6:	c0 81       	brne	800041e6 <fat_entry_shortname+0x4a>
800041d8:	e8 09 18 00 	cp.b	r9,r4
800041dc:	c0 f1       	brne	800041fa <fat_entry_shortname+0x5e>
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
800041de:	ea 08 18 00 	cp.b	r8,r5
800041e2:	e0 8b 00 0b 	brhi	800041f8 <fat_entry_shortname+0x5c>
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800041e6:	f9 39 00 08 	ld.ub	r9,r12[8]
800041ea:	e8 09 18 00 	cp.b	r9,r4
800041ee:	c0 50       	breq	800041f8 <fat_entry_shortname+0x5c>
800041f0:	30 78       	mov	r8,7
800041f2:	32 e9       	mov	r9,46
800041f4:	50 03       	stdsp	sp[0x0],r3
800041f6:	c0 28       	rjmp	800041fa <fat_entry_shortname+0x5e>
800041f8:	06 99       	mov	r9,r3
               u8_entry_char = 0;                                    // end of name
            }
         }
      }

      if( FS_NAME_GET == b_mode )
800041fa:	58 06       	cp.w	r6,0
800041fc:	c1 80       	breq	8000422c <fat_entry_shortname+0x90>
      {
         if( !g_b_string_length )
800041fe:	4a 9b       	lddpc	r11,800042a0 <fat_entry_shortname+0x104>
80004200:	17 81       	ld.ub	r1,r11[0x0]
80004202:	30 0b       	mov	r11,0
80004204:	f6 01 18 00 	cp.b	r1,r11
80004208:	c2 c1       	brne	80004260 <fat_entry_shortname+0xc4>
         {
            if(u8_pos_name >= (u8_size_max-1))
8000420a:	40 1b       	lddsp	r11,sp[0x4]
8000420c:	20 1b       	sub	r11,1
8000420e:	16 3a       	cp.w	r10,r11
80004210:	c0 35       	brlt	80004216 <fat_entry_shortname+0x7a>
80004212:	06 99       	mov	r9,r3
80004214:	c0 a8       	rjmp	80004228 <fat_entry_shortname+0x8c>
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
80004216:	f2 c1 00 41 	sub	r1,r9,65
8000421a:	31 9b       	mov	r11,25
8000421c:	f6 01 18 00 	cp.b	r1,r11
80004220:	e0 8b 00 04 	brhi	80004228 <fat_entry_shortname+0x8c>
               u8_entry_char += ('a'-'A');                           // display short name in down case
80004224:	2e 09       	sub	r9,-32
80004226:	5c 59       	castu.b	r9

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
80004228:	ae 89       	st.b	r7[0x0],r9
8000422a:	c1 b8       	rjmp	80004260 <fat_entry_shortname+0xc4>

         if( Is_unicode )
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
8000422c:	0f 8b       	ld.ub	r11,r7[0x0]
         }
         if ('*' == u8_szname_char)
8000422e:	e4 0b 18 00 	cp.b	r11,r2
80004232:	c2 f0       	breq	80004290 <fat_entry_shortname+0xf4>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
80004234:	58 09       	cp.w	r9,0
80004236:	c0 c1       	brne	8000424e <fat_entry_shortname+0xb2>
80004238:	35 c1       	mov	r1,92
8000423a:	e2 0b 18 00 	cp.b	r11,r1
8000423e:	5f 10       	srne	r0
80004240:	32 f1       	mov	r1,47
80004242:	e2 0b 18 00 	cp.b	r11,r1
80004246:	5f 11       	srne	r1
80004248:	e1 e1 00 01 	and	r1,r0,r1
8000424c:	c0 c0       	breq	80004264 <fat_entry_shortname+0xc8>
         {
            if((u8_szname_char != u8_entry_char)
8000424e:	f2 0b 18 00 	cp.b	r11,r9
80004252:	c0 70       	breq	80004260 <fat_entry_shortname+0xc4>
80004254:	f2 c1 ff e0 	sub	r1,r9,-32
80004258:	02 3b       	cp.w	r11,r1
8000425a:	c0 30       	breq	80004260 <fat_entry_shortname+0xc4>
8000425c:	30 0c       	mov	r12,0
8000425e:	c1 a8       	rjmp	80004292 <fat_entry_shortname+0xf6>
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
80004260:	58 09       	cp.w	r9,0
80004262:	c0 b1       	brne	80004278 <fat_entry_shortname+0xdc>
      {
         if( g_b_string_length )
80004264:	48 f8       	lddpc	r8,800042a0 <fat_entry_shortname+0x104>
80004266:	11 89       	ld.ub	r9,r8[0x0]
80004268:	30 08       	mov	r8,0
8000426a:	f0 09 18 00 	cp.b	r9,r8
8000426e:	c1 10       	breq	80004290 <fat_entry_shortname+0xf4>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
80004270:	2f fa       	sub	r10,-1
80004272:	ae 0a       	st.h	r7[0x0],r10
80004274:	30 1c       	mov	r12,1
80004276:	c0 e8       	rjmp	80004292 <fat_entry_shortname+0xf6>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
80004278:	48 a9       	lddpc	r9,800042a0 <fat_entry_shortname+0x104>
8000427a:	13 8b       	ld.ub	r11,r9[0x0]
8000427c:	30 09       	mov	r9,0
      {
         sz_name += (Is_unicode? 2 : 1 );
8000427e:	f2 0b 18 00 	cp.b	r11,r9
80004282:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80004286:	2f fa       	sub	r10,-1
80004288:	5c 5a       	castu.b	r10
      u8_pos_entry++;
8000428a:	2f f8       	sub	r8,-1
8000428c:	5c 58       	castu.b	r8
   }
8000428e:	c9 ab       	rjmp	800041c2 <fat_entry_shortname+0x26>
80004290:	30 1c       	mov	r12,1
}
80004292:	2f ed       	sub	sp,-8
80004294:	d8 32       	popm	r0-r7,pc
80004296:	00 00       	add	r0,r0
80004298:	00 00       	add	r0,r0
8000429a:	7c 74       	ld.w	r4,lr[0x1c]
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	3f f0       	mov	r0,-1
800042a0:	00 00       	add	r0,r0
800042a2:	7c 75       	ld.w	r5,lr[0x1c]

800042a4 <fat_get_entry_info>:
//! OUT:
//!   fs_g_nav_entry. u32_cluster, u8_attr, u32_size
//! @endverbatim
//!
void  fat_get_entry_info( void )
{
800042a4:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
800042a6:	f0 1f 00 10 	mcall	800042e4 <fat_get_entry_info+0x40>

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
800042aa:	49 08       	lddpc	r8,800042e8 <fat_get_entry_info+0x44>
800042ac:	f9 39 00 0b 	ld.ub	r9,r12[11]
800042b0:	b0 a9       	st.b	r8[0x2],r9

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
800042b2:	f8 ca ff ec 	sub	r10,r12,-20
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
800042b6:	f0 c9 ff fc 	sub	r9,r8,-4
800042ba:	15 8b       	ld.ub	r11,r10[0x0]
800042bc:	b2 9b       	st.b	r9[0x1],r11
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
800042be:	15 9a       	ld.ub	r10,r10[0x1]
800042c0:	b2 8a       	st.b	r9[0x0],r10
   ptr_entry += (26-20);
800042c2:	f8 ca ff e6 	sub	r10,r12,-26
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
800042c6:	15 8b       	ld.ub	r11,r10[0x0]
800042c8:	b2 bb       	st.b	r9[0x3],r11
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
800042ca:	15 9a       	ld.ub	r10,r10[0x1]
800042cc:	b2 aa       	st.b	r9[0x2],r10

   // Get the size of file
   ptr_entry += (28-26);
800042ce:	2e 4c       	sub	r12,-28
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
800042d0:	2f 88       	sub	r8,-8
800042d2:	19 89       	ld.ub	r9,r12[0x0]
800042d4:	b0 b9       	st.b	r8[0x3],r9
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
800042d6:	19 99       	ld.ub	r9,r12[0x1]
800042d8:	b0 a9       	st.b	r8[0x2],r9
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
800042da:	19 a9       	ld.ub	r9,r12[0x2]
800042dc:	b0 99       	st.b	r8[0x1],r9
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
800042de:	19 b9       	ld.ub	r9,r12[0x3]
800042e0:	b0 89       	st.b	r8[0x0],r9
}
800042e2:	d8 02       	popm	pc
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	3f f0       	mov	r0,-1
800042e8:	00 00       	add	r0,r0
800042ea:	79 e4       	ld.w	r4,r12[0x78]

800042ec <fat_entry_check>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_check( bool b_type )
{
800042ec:	eb cd 40 80 	pushm	r7,lr
800042f0:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_first_byte, u8_seconde_byte;
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();
800042f2:	f0 1f 00 14 	mcall	80004340 <fat_entry_check+0x54>

   u8_first_byte = u8_ptr_entry[0];
800042f6:	19 88       	ld.ub	r8,r12[0x0]
   if ( FS_ENTRY_END == u8_first_byte )
800042f8:	58 08       	cp.w	r8,0
800042fa:	c0 61       	brne	80004306 <fat_entry_check+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
800042fc:	30 a9       	mov	r9,10
800042fe:	49 28       	lddpc	r8,80004344 <fat_entry_check+0x58>
80004300:	b0 89       	st.b	r8[0x0],r9
80004302:	30 07       	mov	r7,0
      return false;
80004304:	c1 a8       	rjmp	80004338 <fat_entry_check+0x4c>
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
80004306:	30 ba       	mov	r10,11
80004308:	48 f9       	lddpc	r9,80004344 <fat_entry_check+0x58>
8000430a:	b2 8a       	st.b	r9[0x0],r10
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
8000430c:	3e 59       	mov	r9,-27
8000430e:	f2 08 18 00 	cp.b	r8,r9
80004312:	c1 20       	breq	80004336 <fat_entry_check+0x4a>
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
80004314:	32 e9       	mov	r9,46
80004316:	f2 08 18 00 	cp.b	r8,r9
8000431a:	c0 e0       	breq	80004336 <fat_entry_check+0x4a>
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
8000431c:	f9 38 00 0b 	ld.ub	r8,r12[11]
80004320:	10 99       	mov	r9,r8
80004322:	e2 19 00 08 	andl	r9,0x8,COH
80004326:	c0 81       	brne	80004336 <fat_entry_check+0x4a>
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
80004328:	e2 18 00 10 	andl	r8,0x10,COH
8000432c:	c0 60       	breq	80004338 <fat_entry_check+0x4c>
   {
      return (FS_DIR == b_type);
8000432e:	ec 17 00 01 	eorl	r7,0x1
80004332:	5c 57       	castu.b	r7
80004334:	c0 28       	rjmp	80004338 <fat_entry_check+0x4c>
80004336:	30 07       	mov	r7,0
   }else{
      return (FS_FILE == b_type);
   }
}
80004338:	0e 9c       	mov	r12,r7
8000433a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000433e:	00 00       	add	r0,r0
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	3f f0       	mov	r0,-1
80004344:	00 00       	add	r0,r0
80004346:	7c 74       	ld.w	r4,lr[0x1c]

80004348 <fat_cache_reset>:

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
80004348:	48 58       	lddpc	r8,8000435c <fat_cache_reset+0x14>
8000434a:	3f f9       	mov	r9,-1
8000434c:	b0 89       	st.b	r8[0x0],r9
   fs_g_sectorcache.u8_dirty              = false;
8000434e:	30 09       	mov	r9,0
80004350:	f1 69 00 08 	st.b	r8[8],r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
80004354:	3f f9       	mov	r9,-1
80004356:	91 39       	st.w	r8[0xc],r9
}
80004358:	5e fc       	retal	r12
8000435a:	00 00       	add	r0,r0
8000435c:	00 00       	add	r0,r0
8000435e:	7c ac       	ld.w	r12,lr[0x28]

80004360 <fat_cache_mark_sector_as_dirty>:

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
80004360:	30 19       	mov	r9,1
80004362:	48 38       	lddpc	r8,8000436c <fat_cache_mark_sector_as_dirty+0xc>
80004364:	f1 69 00 08 	st.b	r8[8],r9
}
80004368:	5e fc       	retal	r12
8000436a:	00 00       	add	r0,r0
8000436c:	00 00       	add	r0,r0
8000436e:	7c ac       	ld.w	r12,lr[0x28]

80004370 <fat_write_entry_file>:
//! OUT:
//!   fs_g_sector    Updated
//! @endverbatim
//!
void  fat_write_entry_file( void )
{
80004370:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   fat_cache_mark_sector_as_dirty();
80004372:	f0 1f 00 11 	mcall	800043b4 <fat_write_entry_file+0x44>
   ptr_entry = fat_get_ptr_entry();
80004376:	f0 1f 00 11 	mcall	800043b8 <fat_write_entry_file+0x48>
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
8000437a:	49 18       	lddpc	r8,800043bc <fat_write_entry_file+0x4c>
8000437c:	11 a9       	ld.ub	r9,r8[0x2]
8000437e:	f9 69 00 0b 	st.b	r12[11],r9

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
80004382:	f8 ca ff ec 	sub	r10,r12,-20
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
80004386:	f0 c9 ff fc 	sub	r9,r8,-4
8000438a:	13 9b       	ld.ub	r11,r9[0x1]
8000438c:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
8000438e:	13 8b       	ld.ub	r11,r9[0x0]
80004390:	b4 9b       	st.b	r10[0x1],r11
   ptr_entry += (26-20);
80004392:	f8 ca ff e6 	sub	r10,r12,-26
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
80004396:	13 bb       	ld.ub	r11,r9[0x3]
80004398:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
8000439a:	13 a9       	ld.ub	r9,r9[0x2]
8000439c:	b4 99       	st.b	r10[0x1],r9

   //! Write the size of file
   ptr_entry += (28-26);
8000439e:	2e 4c       	sub	r12,-28
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
800043a0:	2f 88       	sub	r8,-8
800043a2:	11 b9       	ld.ub	r9,r8[0x3]
800043a4:	b8 89       	st.b	r12[0x0],r9
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
800043a6:	11 a9       	ld.ub	r9,r8[0x2]
800043a8:	b8 99       	st.b	r12[0x1],r9
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
800043aa:	11 99       	ld.ub	r9,r8[0x1]
800043ac:	b8 a9       	st.b	r12[0x2],r9
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
800043ae:	11 88       	ld.ub	r8,r8[0x0]
800043b0:	b8 b8       	st.b	r12[0x3],r8
}
800043b2:	d8 02       	popm	pc
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	43 60       	lddsp	r0,sp[0xd8]
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	3f f0       	mov	r0,-1
800043bc:	00 00       	add	r0,r0
800043be:	79 e4       	ld.w	r4,r12[0x78]

800043c0 <fat_check_nav_access_file>:

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
800043c0:	49 88       	lddpc	r8,80004420 <fat_check_nav_access_file+0x60>
800043c2:	11 89       	ld.ub	r9,r8[0x0]
800043c4:	30 08       	mov	r8,0
800043c6:	f0 09 18 00 	cp.b	r9,r8
800043ca:	c2 a0       	breq	8000441e <fat_check_nav_access_file+0x5e>
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
800043cc:	49 68       	lddpc	r8,80004424 <fat_check_nav_access_file+0x64>
800043ce:	11 89       	ld.ub	r9,r8[0x0]
800043d0:	49 68       	lddpc	r8,80004428 <fat_check_nav_access_file+0x68>
800043d2:	11 88       	ld.ub	r8,r8[0x0]
800043d4:	f0 09 18 00 	cp.b	r9,r8
800043d8:	c2 31       	brne	8000441e <fat_check_nav_access_file+0x5e>
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
800043da:	49 38       	lddpc	r8,80004424 <fat_check_nav_access_file+0x64>
800043dc:	70 89       	ld.w	r9,r8[0x20]
800043de:	49 38       	lddpc	r8,80004428 <fat_check_nav_access_file+0x68>
800043e0:	70 88       	ld.w	r8,r8[0x20]
800043e2:	10 39       	cp.w	r9,r8
800043e4:	c1 d1       	brne	8000441e <fat_check_nav_access_file+0x5e>
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
800043e6:	49 28       	lddpc	r8,8000442c <fat_check_nav_access_file+0x6c>
800043e8:	90 19       	ld.sh	r9,r8[0x2]
800043ea:	48 e8       	lddpc	r8,80004420 <fat_check_nav_access_file+0x60>
800043ec:	90 18       	ld.sh	r8,r8[0x2]
800043ee:	f0 09 19 00 	cp.h	r9,r8
800043f2:	c1 61       	brne	8000441e <fat_check_nav_access_file+0x5e>
      {
         if( mode )
800043f4:	58 0c       	cp.w	r12,0
800043f6:	c0 b0       	breq	8000440c <fat_check_nav_access_file+0x4c>
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
800043f8:	48 e8       	lddpc	r8,80004430 <fat_check_nav_access_file+0x70>
800043fa:	11 89       	ld.ub	r9,r8[0x0]
800043fc:	30 08       	mov	r8,0
800043fe:	f0 09 18 00 	cp.b	r9,r8
80004402:	c0 e0       	breq	8000441e <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN;
80004404:	32 89       	mov	r9,40
80004406:	48 c8       	lddpc	r8,80004434 <fat_check_nav_access_file+0x74>
80004408:	b0 89       	st.b	r8[0x0],r9
8000440a:	5e fd       	retal	0
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
8000440c:	48 98       	lddpc	r8,80004430 <fat_check_nav_access_file+0x70>
8000440e:	11 88       	ld.ub	r8,r8[0x0]
80004410:	e2 18 00 02 	andl	r8,0x2,COH
80004414:	c0 50       	breq	8000441e <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
80004416:	32 99       	mov	r9,41
80004418:	48 78       	lddpc	r8,80004434 <fat_check_nav_access_file+0x74>
8000441a:	b0 89       	st.b	r8[0x0],r9
8000441c:	5e fd       	retal	0
               return false;  // File opened in write mode then read access not possible
8000441e:	5e ff       	retal	1
80004420:	00 00       	add	r0,r0
80004422:	7c 6c       	ld.w	r12,lr[0x18]
80004424:	00 00       	add	r0,r0
80004426:	7c 24       	ld.w	r4,lr[0x8]
80004428:	00 00       	add	r0,r0
8000442a:	7c 78       	ld.w	r8,lr[0x1c]
8000442c:	00 00       	add	r0,r0
8000442e:	7c 70       	ld.w	r0,lr[0x1c]
80004430:	00 00       	add	r0,r0
80004432:	7c 5c       	ld.w	r12,lr[0x14]
80004434:	00 00       	add	r0,r0
80004436:	7c 74       	ld.w	r4,lr[0x1c]

80004438 <fat_invert_nav>:
//! This function inverts the current navigation with another
//!
//! @param     u8_idnav    Id navigator to invert
//!
void  fat_invert_nav( uint8_t u8_idnav )
{
80004438:	d4 21       	pushm	r4-r7,lr
8000443a:	20 dd       	sub	sp,52
   _MEM_TYPE_SLOW_ uint8_t Temp[Max(Max(sizeof(Fs_management),sizeof(Fs_management_entry)),sizeof(Fs_management_fast))];

   if( u8_idnav == 0 )
8000443c:	58 0c       	cp.w	r12,0
8000443e:	c5 a0       	breq	800044f2 <fat_invert_nav+0xba>
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
80004440:	1a 97       	mov	r7,sp
80004442:	4a e8       	lddpc	r8,800044f8 <fat_invert_nav+0xc0>
80004444:	f0 ea 00 00 	ld.d	r10,r8[0]
80004448:	fa eb 00 00 	st.d	sp[0],r10
8000444c:	f0 ea 00 08 	ld.d	r10,r8[8]
80004450:	fa eb 00 08 	st.d	sp[8],r10
80004454:	f0 ea 00 10 	ld.d	r10,r8[16]
80004458:	fa eb 00 10 	st.d	sp[16],r10
8000445c:	f0 ea 00 18 	ld.d	r10,r8[24]
80004460:	fa eb 00 18 	st.d	sp[24],r10
80004464:	f0 ea 00 20 	ld.d	r10,r8[32]
80004468:	fa eb 00 20 	st.d	sp[32],r10
8000446c:	f0 ea 00 28 	ld.d	r10,r8[40]
80004470:	fa eb 00 28 	st.d	sp[40],r10
80004474:	70 c9       	ld.w	r9,r8[0x30]
80004476:	50 c9       	stdsp	sp[0x30],r9
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
80004478:	f8 c6 00 01 	sub	r6,r12,1
8000447c:	5c 56       	castu.b	r6
8000447e:	ec 04 10 34 	mul	r4,r6,52
80004482:	49 f9       	lddpc	r9,800044fc <fat_invert_nav+0xc4>
80004484:	12 04       	add	r4,r9
80004486:	33 45       	mov	r5,52
80004488:	0a 9a       	mov	r10,r5
8000448a:	08 9b       	mov	r11,r4
8000448c:	10 9c       	mov	r12,r8
8000448e:	f0 1f 00 1d 	mcall	80004500 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
80004492:	0a 9a       	mov	r10,r5
80004494:	1a 9b       	mov	r11,sp
80004496:	08 9c       	mov	r12,r4
80004498:	f0 1f 00 1a 	mcall	80004500 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
8000449c:	49 ac       	lddpc	r12,80004504 <fat_invert_nav+0xcc>
8000449e:	f8 e8 00 00 	ld.d	r8,r12[0]
800044a2:	fa e9 00 00 	st.d	sp[0],r8
800044a6:	f8 e8 00 08 	ld.d	r8,r12[8]
800044aa:	fa e9 00 08 	st.d	sp[8],r8
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
800044ae:	ec 04 15 04 	lsl	r4,r6,0x4
800044b2:	49 68       	lddpc	r8,80004508 <fat_invert_nav+0xd0>
800044b4:	10 04       	add	r4,r8
800044b6:	31 05       	mov	r5,16
800044b8:	0a 9a       	mov	r10,r5
800044ba:	08 9b       	mov	r11,r4
800044bc:	f0 1f 00 11 	mcall	80004500 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
800044c0:	0a 9a       	mov	r10,r5
800044c2:	1a 9b       	mov	r11,sp
800044c4:	08 9c       	mov	r12,r4
800044c6:	f0 1f 00 0f 	mcall	80004500 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
800044ca:	49 14       	lddpc	r4,8000450c <fat_invert_nav+0xd4>
800044cc:	30 45       	mov	r5,4
800044ce:	0a 9a       	mov	r10,r5
800044d0:	08 9b       	mov	r11,r4
800044d2:	1a 9c       	mov	r12,sp
800044d4:	f0 1f 00 0b 	mcall	80004500 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
800044d8:	48 e8       	lddpc	r8,80004510 <fat_invert_nav+0xd8>
800044da:	f0 06 00 26 	add	r6,r8,r6<<0x2
800044de:	0a 9a       	mov	r10,r5
800044e0:	0c 9b       	mov	r11,r6
800044e2:	08 9c       	mov	r12,r4
800044e4:	f0 1f 00 07 	mcall	80004500 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
800044e8:	0a 9a       	mov	r10,r5
800044ea:	1a 9b       	mov	r11,sp
800044ec:	0c 9c       	mov	r12,r6
800044ee:	f0 1f 00 05 	mcall	80004500 <fat_invert_nav+0xc8>
}
800044f2:	2f 3d       	sub	sp,-52
800044f4:	d8 22       	popm	r4-r7,pc
800044f6:	00 00       	add	r0,r0
800044f8:	00 00       	add	r0,r0
800044fa:	7c 24       	ld.w	r4,lr[0x8]
800044fc:	00 00       	add	r0,r0
800044fe:	7c 78       	ld.w	r8,lr[0x1c]
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	9f ac       	st.w	pc[0x28],r12
80004504:	00 00       	add	r0,r0
80004506:	79 e4       	ld.w	r4,r12[0x78]
80004508:	00 00       	add	r0,r0
8000450a:	7c 5c       	ld.w	r12,lr[0x14]
8000450c:	00 00       	add	r0,r0
8000450e:	7c 70       	ld.w	r0,lr[0x1c]
80004510:	00 00       	add	r0,r0
80004512:	7c 6c       	ld.w	r12,lr[0x18]

80004514 <fat_cache_flush>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
80004514:	d4 01       	pushm	lr
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
80004516:	49 08       	lddpc	r8,80004554 <fat_cache_flush+0x40>
80004518:	f1 39 00 08 	ld.ub	r9,r8[8]
8000451c:	30 18       	mov	r8,1
8000451e:	f0 09 18 00 	cp.b	r9,r8
80004522:	c1 81       	brne	80004552 <fat_cache_flush+0x3e>
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
80004524:	48 c8       	lddpc	r8,80004554 <fat_cache_flush+0x40>
80004526:	30 09       	mov	r9,0
80004528:	f1 69 00 08 	st.b	r8[8],r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000452c:	11 8c       	ld.ub	r12,r8[0x0]
8000452e:	f0 1f 00 0b 	mcall	80004558 <fat_cache_flush+0x44>
80004532:	c0 50       	breq	8000453c <fat_cache_flush+0x28>
      {
         fs_g_status = FS_LUN_WP;
80004534:	31 49       	mov	r9,20
80004536:	48 a8       	lddpc	r8,8000455c <fat_cache_flush+0x48>
80004538:	b0 89       	st.b	r8[0x0],r9
8000453a:	d8 0a       	popm	pc,r12=0
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000453c:	48 68       	lddpc	r8,80004554 <fat_cache_flush+0x40>
8000453e:	48 9a       	lddpc	r10,80004560 <fat_cache_flush+0x4c>
80004540:	70 1b       	ld.w	r11,r8[0x4]
80004542:	11 8c       	ld.ub	r12,r8[0x0]
80004544:	f0 1f 00 08 	mcall	80004564 <fat_cache_flush+0x50>
80004548:	c0 50       	breq	80004552 <fat_cache_flush+0x3e>
      {
         fs_g_status = FS_ERR_HW;
8000454a:	30 19       	mov	r9,1
8000454c:	48 48       	lddpc	r8,8000455c <fat_cache_flush+0x48>
8000454e:	b0 89       	st.b	r8[0x0],r9
80004550:	d8 0a       	popm	pc,r12=0
         return false;
80004552:	da 0a       	popm	pc,r12=1
80004554:	00 00       	add	r0,r0
80004556:	7c ac       	ld.w	r12,lr[0x28]
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	5c 28       	cpc	r8
8000455c:	00 00       	add	r0,r0
8000455e:	7c 74       	ld.w	r4,lr[0x1c]
80004560:	00 00       	add	r0,r0
80004562:	7a 24       	ld.w	r4,sp[0x8]
80004564:	80 00       	ld.sh	r0,r0[0x0]
80004566:	5b 68       	cp.w	r8,-10

80004568 <fat_cache_clear>:

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
80004568:	d4 01       	pushm	lr
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
8000456a:	e0 6a 02 00 	mov	r10,512
8000456e:	30 0b       	mov	r11,0
80004570:	48 2c       	lddpc	r12,80004578 <fat_cache_clear+0x10>
80004572:	f0 1f 00 03 	mcall	8000457c <fat_cache_clear+0x14>
}
80004576:	d8 02       	popm	pc
80004578:	00 00       	add	r0,r0
8000457a:	7a 24       	ld.w	r4,sp[0x8]
8000457c:	80 00       	ld.sh	r0,r0[0x0]
8000457e:	a0 f4       	st.b	r0[0x7],r4

80004580 <fat_cache_read_sector>:
//!   fs_g_nav.u8_lun      drive number to read
//!   fs_gu32_addrsector   address to read (unit sector)
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
80004580:	eb cd 40 80 	pushm	r7,lr
80004584:	18 97       	mov	r7,r12
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
80004586:	49 78       	lddpc	r8,800045e0 <fat_cache_read_sector+0x60>
80004588:	11 89       	ld.ub	r9,r8[0x0]
8000458a:	49 78       	lddpc	r8,800045e4 <fat_cache_read_sector+0x64>
8000458c:	11 88       	ld.ub	r8,r8[0x0]
8000458e:	f0 09 18 00 	cp.b	r9,r8
80004592:	c0 91       	brne	800045a4 <fat_cache_read_sector+0x24>
80004594:	49 38       	lddpc	r8,800045e0 <fat_cache_read_sector+0x60>
80004596:	70 19       	ld.w	r9,r8[0x4]
80004598:	49 48       	lddpc	r8,800045e8 <fat_cache_read_sector+0x68>
8000459a:	70 08       	ld.w	r8,r8[0x0]
8000459c:	10 39       	cp.w	r9,r8
8000459e:	c0 31       	brne	800045a4 <fat_cache_read_sector+0x24>
800045a0:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      return true;
   }

   // Write previous cache before fill cache with a new sector
   if( !fat_cache_flush())
800045a4:	f0 1f 00 12 	mcall	800045ec <fat_cache_read_sector+0x6c>
800045a8:	c1 90       	breq	800045da <fat_cache_read_sector+0x5a>
      return false;

   // Delete informations about the caches
   fat_cache_reset();
800045aa:	f0 1f 00 12 	mcall	800045f0 <fat_cache_read_sector+0x70>

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
800045ae:	48 f8       	lddpc	r8,800045e8 <fat_cache_read_sector+0x68>
800045b0:	70 0b       	ld.w	r11,r8[0x0]
800045b2:	48 c8       	lddpc	r8,800045e0 <fat_cache_read_sector+0x60>
800045b4:	91 1b       	st.w	r8[0x4],r11
   if( b_load )
800045b6:	58 07       	cp.w	r7,0
800045b8:	c0 c0       	breq	800045d0 <fat_cache_read_sector+0x50>
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
800045ba:	48 fa       	lddpc	r10,800045f4 <fat_cache_read_sector+0x74>
800045bc:	48 a8       	lddpc	r8,800045e4 <fat_cache_read_sector+0x64>
800045be:	11 8c       	ld.ub	r12,r8[0x0]
800045c0:	f0 1f 00 0e 	mcall	800045f8 <fat_cache_read_sector+0x78>
800045c4:	c0 60       	breq	800045d0 <fat_cache_read_sector+0x50>
      {
         fs_g_status = FS_ERR_HW;
800045c6:	30 19       	mov	r9,1
800045c8:	48 d8       	lddpc	r8,800045fc <fat_cache_read_sector+0x7c>
800045ca:	b0 89       	st.b	r8[0x0],r9
800045cc:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
800045d0:	48 58       	lddpc	r8,800045e4 <fat_cache_read_sector+0x64>
800045d2:	11 89       	ld.ub	r9,r8[0x0]
800045d4:	48 38       	lddpc	r8,800045e0 <fat_cache_read_sector+0x60>
800045d6:	b0 89       	st.b	r8[0x0],r9
800045d8:	30 1c       	mov	r12,1
   return true;
}
800045da:	e3 cd 80 80 	ldm	sp++,r7,pc
800045de:	00 00       	add	r0,r0
800045e0:	00 00       	add	r0,r0
800045e2:	7c ac       	ld.w	r12,lr[0x28]
800045e4:	00 00       	add	r0,r0
800045e6:	7c 24       	ld.w	r4,lr[0x8]
800045e8:	00 00       	add	r0,r0
800045ea:	79 e0       	ld.w	r0,r12[0x78]
800045ec:	80 00       	ld.sh	r0,r0[0x0]
800045ee:	45 14       	lddsp	r4,sp[0x144]
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	43 48       	lddsp	r8,sp[0xd0]
800045f4:	00 00       	add	r0,r0
800045f6:	7a 24       	ld.w	r4,sp[0x8]
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	5b c8       	cp.w	r8,-4
800045fc:	00 00       	add	r0,r0
800045fe:	7c 74       	ld.w	r4,lr[0x1c]

80004600 <fat_cluster_readnext>:
//!   fs_g_u16_pos_fat        read cluster position in FAT
//!   fs_g_cluster.u32_val    value of cluster read
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
80004600:	d4 01       	pushm	lr
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
80004602:	49 f8       	lddpc	r8,8000467c <fat_cluster_readnext+0x7c>
80004604:	11 89       	ld.ub	r9,r8[0x0]
80004606:	30 38       	mov	r8,3
80004608:	f0 09 18 00 	cp.b	r9,r8
8000460c:	c0 61       	brne	80004618 <fat_cluster_readnext+0x18>
   {
      fs_g_u16_pos_fat += 4;
8000460e:	49 d8       	lddpc	r8,80004680 <fat_cluster_readnext+0x80>
80004610:	90 09       	ld.sh	r9,r8[0x0]
80004612:	2f c9       	sub	r9,-4
80004614:	b0 09       	st.h	r8[0x0],r9
80004616:	c0 58       	rjmp	80004620 <fat_cluster_readnext+0x20>
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
80004618:	49 a8       	lddpc	r8,80004680 <fat_cluster_readnext+0x80>
8000461a:	90 09       	ld.sh	r9,r8[0x0]
8000461c:	2f e9       	sub	r9,-2
8000461e:	b0 09       	st.h	r8[0x0],r9
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
80004620:	49 88       	lddpc	r8,80004680 <fat_cluster_readnext+0x80>
80004622:	90 09       	ld.sh	r9,r8[0x0]
80004624:	e0 68 02 00 	mov	r8,512
80004628:	f0 09 19 00 	cp.h	r9,r8
8000462c:	c0 c1       	brne	80004644 <fat_cluster_readnext+0x44>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000462e:	30 09       	mov	r9,0
80004630:	49 48       	lddpc	r8,80004680 <fat_cluster_readnext+0x80>
80004632:	b0 09       	st.h	r8[0x0],r9
      fs_gu32_addrsector++;
80004634:	49 48       	lddpc	r8,80004684 <fat_cluster_readnext+0x84>
80004636:	70 09       	ld.w	r9,r8[0x0]
80004638:	2f f9       	sub	r9,-1
8000463a:	91 09       	st.w	r8[0x0],r9
      if( !fat_cache_read_sector( true ))
8000463c:	30 1c       	mov	r12,1
8000463e:	f0 1f 00 13 	mcall	80004688 <fat_cluster_readnext+0x88>
80004642:	c1 b0       	breq	80004678 <fat_cluster_readnext+0x78>
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
80004644:	49 28       	lddpc	r8,8000468c <fat_cluster_readnext+0x8c>
80004646:	2f c8       	sub	r8,-4
80004648:	48 e9       	lddpc	r9,80004680 <fat_cluster_readnext+0x80>
8000464a:	92 89       	ld.uh	r9,r9[0x0]
8000464c:	49 1a       	lddpc	r10,80004690 <fat_cluster_readnext+0x90>
8000464e:	f4 09 07 0b 	ld.ub	r11,r10[r9]
80004652:	b0 bb       	st.b	r8[0x3],r11
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
80004654:	12 0a       	add	r10,r9
80004656:	15 9a       	ld.ub	r10,r10[0x1]
80004658:	b0 aa       	st.b	r8[0x2],r10

   if ( Is_fat32 )
8000465a:	48 9a       	lddpc	r10,8000467c <fat_cluster_readnext+0x7c>
8000465c:	15 8b       	ld.ub	r11,r10[0x0]
8000465e:	30 3a       	mov	r10,3
80004660:	f4 0b 18 00 	cp.b	r11,r10
80004664:	c0 20       	breq	80004668 <fat_cluster_readnext+0x68>
80004666:	da 0a       	popm	pc,r12=1
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
80004668:	48 aa       	lddpc	r10,80004690 <fat_cluster_readnext+0x90>
8000466a:	f4 09 00 09 	add	r9,r10,r9
8000466e:	13 aa       	ld.ub	r10,r9[0x2]
80004670:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
80004672:	13 b9       	ld.ub	r9,r9[0x3]
80004674:	b0 89       	st.b	r8[0x0],r9
80004676:	30 1c       	mov	r12,1
   }
   return true;
}
80004678:	d8 02       	popm	pc
8000467a:	00 00       	add	r0,r0
8000467c:	00 00       	add	r0,r0
8000467e:	7c 70       	ld.w	r0,lr[0x1c]
80004680:	00 00       	add	r0,r0
80004682:	79 f4       	ld.w	r4,r12[0x7c]
80004684:	00 00       	add	r0,r0
80004686:	79 e0       	ld.w	r0,r12[0x78]
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	45 80       	lddsp	r0,sp[0x160]
8000468c:	00 00       	add	r0,r0
8000468e:	7c c4       	ld.w	r4,lr[0x30]
80004690:	00 00       	add	r0,r0
80004692:	7a 24       	ld.w	r4,sp[0x8]

80004694 <fat_cluster_val>:
//!   fs_g_u16_pos_fat        position in FAT of the cluster to read or write
//!                           value init in case of the fat_cluster_readnext() routine is used after
//! @endverbatim
//!
bool  fat_cluster_val( bool b_mode )
{
80004694:	d4 31       	pushm	r0-r7,lr
80004696:	18 95       	mov	r5,r12
   _MEM_TYPE_FAST_ uint32_t   u32_offset_fat =0;
   _MEM_TYPE_FAST_ uint8_t    u8_data1, u8_data2,u8_data3,u8_data4;
   _MEM_TYPE_FAST_ PTR_CACHE u8_ptr_cluster;

   //**** Compute the cluster position in FAT (sector address & position in sector)
   if ( Is_fat32 )
80004698:	fe f8 02 18 	ld.w	r8,pc[536]
8000469c:	11 88       	ld.ub	r8,r8[0x0]
8000469e:	30 39       	mov	r9,3
800046a0:	f2 08 18 00 	cp.b	r8,r9
800046a4:	c0 d1       	brne	800046be <fat_cluster_val+0x2a>
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
800046a6:	fe fa 02 0e 	ld.w	r10,pc[526]
800046aa:	74 09       	ld.w	r9,r10[0x0]
800046ac:	a7 99       	lsr	r9,0x7

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
800046ae:	15 bb       	ld.ub	r11,r10[0x3]
800046b0:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800046b4:	a3 6b       	lsl	r11,0x2
800046b6:	fe fa 02 02 	ld.w	r10,pc[514]
800046ba:	b4 0b       	st.h	r10[0x0],r11
800046bc:	c2 08       	rjmp	800046fc <fat_cluster_val+0x68>
   }
   else if ( Is_fat16 )
800046be:	30 29       	mov	r9,2
800046c0:	f2 08 18 00 	cp.b	r8,r9
800046c4:	c0 81       	brne	800046d4 <fat_cluster_val+0x40>
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
800046c6:	4f ca       	lddpc	r10,800048b4 <fat_cluster_val+0x220>
800046c8:	15 a9       	ld.ub	r9,r10[0x2]
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
800046ca:	15 bb       	ld.ub	r11,r10[0x3]
800046cc:	a1 7b       	lsl	r11,0x1
800046ce:	4f ba       	lddpc	r10,800048b8 <fat_cluster_val+0x224>
800046d0:	b4 0b       	st.h	r10[0x0],r11
800046d2:	c1 58       	rjmp	800046fc <fat_cluster_val+0x68>
   }
   else if ( Is_fat12 )
800046d4:	30 19       	mov	r9,1
800046d6:	f2 08 18 00 	cp.b	r8,r9
800046da:	c0 30       	breq	800046e0 <fat_cluster_val+0x4c>
800046dc:	30 09       	mov	r9,0
800046de:	c0 f8       	rjmp	800046fc <fat_cluster_val+0x68>
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
800046e0:	4f 59       	lddpc	r9,800048b4 <fat_cluster_val+0x220>
800046e2:	72 09       	ld.w	r9,r9[0x0]
800046e4:	4f 5a       	lddpc	r10,800048b8 <fat_cluster_val+0x224>
800046e6:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
800046ea:	12 0b       	add	r11,r9
800046ec:	b4 0b       	st.h	r10[0x0],r11
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
800046ee:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
800046f2:	f6 09 16 01 	lsr	r9,r11,0x1
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
800046f6:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
800046fa:	b4 8b       	st.b	r10[0x0],r11
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
800046fc:	58 05       	cp.w	r5,0
800046fe:	c2 20       	breq	80004742 <fat_cluster_val+0xae>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
80004700:	4e fa       	lddpc	r10,800048bc <fat_cluster_val+0x228>
80004702:	74 0a       	ld.w	r10,r10[0x0]
80004704:	14 39       	cp.w	r9,r10
80004706:	c0 32       	brcc	8000470c <fat_cluster_val+0x78>
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
80004708:	4e da       	lddpc	r10,800048bc <fat_cluster_val+0x228>
8000470a:	95 09       	st.w	r10[0x0],r9
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
8000470c:	4e da       	lddpc	r10,800048c0 <fat_cluster_val+0x22c>
8000470e:	74 0a       	ld.w	r10,r10[0x0]
80004710:	14 39       	cp.w	r9,r10
80004712:	e0 88 00 04 	brls	8000471a <fat_cluster_val+0x86>
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
80004716:	4e ba       	lddpc	r10,800048c0 <fat_cluster_val+0x22c>
80004718:	95 09       	st.w	r10[0x0],r9
      }
      if ( Is_fat12 )
8000471a:	30 1a       	mov	r10,1
8000471c:	f4 08 18 00 	cp.b	r8,r10
80004720:	c1 11       	brne	80004742 <fat_cluster_val+0xae>
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80004722:	4e 68       	lddpc	r8,800048b8 <fat_cluster_val+0x224>
80004724:	90 0a       	ld.sh	r10,r8[0x0]
80004726:	e0 68 01 ff 	mov	r8,511
8000472a:	f0 0a 19 00 	cp.h	r10,r8
8000472e:	c0 a1       	brne	80004742 <fat_cluster_val+0xae>
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
80004730:	f2 c8 ff ff 	sub	r8,r9,-1
80004734:	4e 3a       	lddpc	r10,800048c0 <fat_cluster_val+0x22c>
80004736:	74 0a       	ld.w	r10,r10[0x0]
80004738:	14 38       	cp.w	r8,r10
8000473a:	e0 88 00 04 	brls	80004742 <fat_cluster_val+0xae>
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
8000473e:	4e 1a       	lddpc	r10,800048c0 <fat_cluster_val+0x22c>
80004740:	95 08       	st.w	r10[0x0],r8
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
80004742:	4e 18       	lddpc	r8,800048c4 <fat_cluster_val+0x230>
80004744:	70 48       	ld.w	r8,r8[0x10]
80004746:	10 09       	add	r9,r8
80004748:	4e 08       	lddpc	r8,800048c8 <fat_cluster_val+0x234>
8000474a:	91 09       	st.w	r8[0x0],r9
   if( !fat_cache_read_sector( true ))
8000474c:	30 1c       	mov	r12,1
8000474e:	f0 1f 00 60 	mcall	800048cc <fat_cluster_val+0x238>
80004752:	e0 80 00 ad 	breq	800048ac <fat_cluster_val+0x218>
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
80004756:	4d 98       	lddpc	r8,800048b8 <fat_cluster_val+0x224>
80004758:	90 08       	ld.sh	r8,r8[0x0]
8000475a:	ed d8 c0 10 	bfextu	r6,r8,0x0,0x10
8000475e:	4d d9       	lddpc	r9,800048d0 <fat_cluster_val+0x23c>
80004760:	12 06       	add	r6,r9
   u8_data1 = u8_ptr_cluster[0];
80004762:	0c 97       	mov	r7,r6
80004764:	0f 32       	ld.ub	r2,r7++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
80004766:	0f 8b       	ld.ub	r11,r7[0x0]
   u8_data3 = u8_ptr_cluster[2];
80004768:	ec c4 ff fe 	sub	r4,r6,-2
8000476c:	09 81       	ld.ub	r1,r4[0x0]
   u8_data4 = u8_ptr_cluster[3];
8000476e:	ec c3 ff fd 	sub	r3,r6,-3
80004772:	07 80       	ld.ub	r0,r3[0x0]

   if ( Is_fat12 )
80004774:	4c f9       	lddpc	r9,800048b0 <fat_cluster_val+0x21c>
80004776:	13 8a       	ld.ub	r10,r9[0x0]
80004778:	30 19       	mov	r9,1
8000477a:	f2 0a 18 00 	cp.b	r10,r9
8000477e:	c1 11       	brne	800047a0 <fat_cluster_val+0x10c>
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80004780:	e0 69 01 ff 	mov	r9,511
80004784:	f2 08 19 00 	cp.h	r8,r9
80004788:	c0 c1       	brne	800047a0 <fat_cluster_val+0x10c>
      {  // Go to next sector
         fs_gu32_addrsector++;
8000478a:	4d 08       	lddpc	r8,800048c8 <fat_cluster_val+0x234>
8000478c:	70 09       	ld.w	r9,r8[0x0]
8000478e:	2f f9       	sub	r9,-1
80004790:	91 09       	st.w	r8[0x0],r9
         if( !fat_cache_read_sector( true ))
80004792:	30 1c       	mov	r12,1
80004794:	f0 1f 00 4e 	mcall	800048cc <fat_cluster_val+0x238>
80004798:	e0 80 00 8a 	breq	800048ac <fat_cluster_val+0x218>
           return false;
         u8_data2 = fs_g_sector[0];
8000479c:	4c d8       	lddpc	r8,800048d0 <fat_cluster_val+0x23c>
8000479e:	11 8b       	ld.ub	r11,r8[0x0]
      }
   }

   if (false == b_mode)
800047a0:	58 05       	cp.w	r5,0
800047a2:	c3 11       	brne	80004804 <fat_cluster_val+0x170>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
800047a4:	4c 48       	lddpc	r8,800048b4 <fat_cluster_val+0x220>
800047a6:	f0 c9 ff fc 	sub	r9,r8,-4
800047aa:	f0 cc ff f9 	sub	r12,r8,-7
800047ae:	b8 82       	st.b	r12[0x0],r2
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
800047b0:	2f a8       	sub	r8,-6
800047b2:	b0 8b       	st.b	r8[0x0],r11

      if ( Is_fat32 )
800047b4:	4b fa       	lddpc	r10,800048b0 <fat_cluster_val+0x21c>
800047b6:	15 8a       	ld.ub	r10,r10[0x0]
800047b8:	30 3b       	mov	r11,3
800047ba:	f6 0a 18 00 	cp.b	r10,r11
800047be:	c0 61       	brne	800047ca <fat_cluster_val+0x136>
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
800047c0:	b2 91       	st.b	r9[0x1],r1
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
800047c2:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
800047c6:	b2 80       	st.b	r9[0x0],r0
800047c8:	da 3a       	popm	r0-r7,pc,r12=1
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
800047ca:	30 0b       	mov	r11,0
800047cc:	b2 9b       	st.b	r9[0x1],r11
         LSB3( fs_g_cluster.u32_val ) = 0;
800047ce:	b2 8b       	st.b	r9[0x0],r11

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
800047d0:	30 19       	mov	r9,1
800047d2:	f2 0a 18 00 	cp.b	r10,r9
800047d6:	c0 20       	breq	800047da <fat_cluster_val+0x146>
800047d8:	da 3a       	popm	r0-r7,pc,r12=1
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
800047da:	4b 79       	lddpc	r9,800048b4 <fat_cluster_val+0x220>
800047dc:	13 b9       	ld.ub	r9,r9[0x3]
800047de:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800047e2:	c0 c0       	breq	800047fa <fat_cluster_val+0x166>
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
800047e4:	19 8b       	ld.ub	r11,r12[0x0]
800047e6:	a5 8b       	lsr	r11,0x4
800047e8:	11 89       	ld.ub	r9,r8[0x0]
800047ea:	f2 0a 15 04 	lsl	r10,r9,0x4
800047ee:	f6 0a 00 0a 	add	r10,r11,r10
800047f2:	b8 8a       	st.b	r12[0x0],r10
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
800047f4:	a5 89       	lsr	r9,0x4
800047f6:	b0 89       	st.b	r8[0x0],r9
800047f8:	da 3a       	popm	r0-r7,pc,r12=1
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
800047fa:	11 89       	ld.ub	r9,r8[0x0]
800047fc:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80004800:	b0 89       	st.b	r8[0x0],r9
80004802:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
80004804:	4a b8       	lddpc	r8,800048b0 <fat_cluster_val+0x21c>
80004806:	11 88       	ld.ub	r8,r8[0x0]
80004808:	30 19       	mov	r9,1
8000480a:	f2 08 18 00 	cp.b	r8,r9
8000480e:	c3 a1       	brne	80004882 <fat_cluster_val+0x1ee>
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80004810:	4a 98       	lddpc	r8,800048b4 <fat_cluster_val+0x220>
80004812:	11 b8       	ld.ub	r8,r8[0x3]
80004814:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004818:	c1 10       	breq	8000483a <fat_cluster_val+0x1a6>
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000481a:	eb d2 c0 04 	bfextu	r5,r2,0x0,0x4
8000481e:	4a 68       	lddpc	r8,800048b4 <fat_cluster_val+0x220>
80004820:	2f c8       	sub	r8,-4
80004822:	11 b9       	ld.ub	r9,r8[0x3]
80004824:	f2 0a 15 04 	lsl	r10,r9,0x4
80004828:	14 05       	add	r5,r10
8000482a:	5c 55       	castu.b	r5
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
8000482c:	a5 89       	lsr	r9,0x4
8000482e:	11 a8       	ld.ub	r8,r8[0x2]
80004830:	a5 68       	lsl	r8,0x4
80004832:	f2 08 00 0a 	add	r10,r9,r8
80004836:	5c 5a       	castu.b	r10
80004838:	c0 c8       	rjmp	80004850 <fat_cluster_val+0x1bc>
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
8000483a:	49 f8       	lddpc	r8,800048b4 <fat_cluster_val+0x220>
8000483c:	2f c8       	sub	r8,-4
8000483e:	11 b5       	ld.ub	r5,r8[0x3]
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
80004840:	16 9a       	mov	r10,r11
80004842:	e2 1a 00 f0 	andl	r10,0xf0,COH
80004846:	11 a8       	ld.ub	r8,r8[0x2]
80004848:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000484c:	10 0a       	add	r10,r8
8000484e:	5c 5a       	castu.b	r10
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80004850:	49 a8       	lddpc	r8,800048b8 <fat_cluster_val+0x224>
80004852:	90 09       	ld.sh	r9,r8[0x0]
80004854:	e0 68 01 ff 	mov	r8,511
80004858:	f0 09 19 00 	cp.h	r9,r8
8000485c:	c2 31       	brne	800048a2 <fat_cluster_val+0x20e>
         {
            fs_g_sector[0] = u8_data2;
8000485e:	49 d8       	lddpc	r8,800048d0 <fat_cluster_val+0x23c>
80004860:	b0 8a       	st.b	r8[0x0],r10
            fat_cache_mark_sector_as_dirty();
80004862:	f0 1f 00 1d 	mcall	800048d4 <fat_cluster_val+0x240>
            // Go to previous sector
            fs_gu32_addrsector--;
80004866:	49 98       	lddpc	r8,800048c8 <fat_cluster_val+0x234>
80004868:	70 09       	ld.w	r9,r8[0x0]
8000486a:	20 19       	sub	r9,1
8000486c:	91 09       	st.w	r8[0x0],r9
            if( !fat_cache_read_sector( true ))
8000486e:	30 1c       	mov	r12,1
80004870:	f0 1f 00 17 	mcall	800048cc <fat_cluster_val+0x238>
80004874:	c1 c0       	breq	800048ac <fat_cluster_val+0x218>
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
80004876:	49 78       	lddpc	r8,800048d0 <fat_cluster_val+0x23c>
80004878:	f1 65 01 ff 	st.b	r8[511],r5
            fat_cache_mark_sector_as_dirty();
8000487c:	f0 1f 00 16 	mcall	800048d4 <fat_cluster_val+0x240>
80004880:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
80004882:	48 d9       	lddpc	r9,800048b4 <fat_cluster_val+0x220>
80004884:	2f c9       	sub	r9,-4
80004886:	13 b5       	ld.ub	r5,r9[0x3]
         u8_data2 = LSB1( fs_g_cluster.u32_val );
80004888:	13 aa       	ld.ub	r10,r9[0x2]
         if ( Is_fat32 )
8000488a:	30 3b       	mov	r11,3
8000488c:	f6 08 18 00 	cp.b	r8,r11
80004890:	c0 91       	brne	800048a2 <fat_cluster_val+0x20e>
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
80004892:	13 98       	ld.ub	r8,r9[0x1]
80004894:	a8 88       	st.b	r4[0x0],r8
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
80004896:	e0 10 ff f0 	andl	r0,0xfff0
8000489a:	13 88       	ld.ub	r8,r9[0x0]
8000489c:	f0 00 00 00 	add	r0,r8,r0
800048a0:	a6 80       	st.b	r3[0x0],r0
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
800048a2:	ac 85       	st.b	r6[0x0],r5
      u8_ptr_cluster[1] = u8_data2;
800048a4:	ae 8a       	st.b	r7[0x0],r10
      fat_cache_mark_sector_as_dirty();
800048a6:	f0 1f 00 0c 	mcall	800048d4 <fat_cluster_val+0x240>
800048aa:	da 3a       	popm	r0-r7,pc,r12=1
800048ac:	d8 3a       	popm	r0-r7,pc,r12=0
800048ae:	00 00       	add	r0,r0
800048b0:	00 00       	add	r0,r0
800048b2:	7c 70       	ld.w	r0,lr[0x1c]
800048b4:	00 00       	add	r0,r0
800048b6:	7c c4       	ld.w	r4,lr[0x30]
800048b8:	00 00       	add	r0,r0
800048ba:	79 f4       	ld.w	r4,r12[0x7c]
800048bc:	00 00       	add	r0,r0
800048be:	7c 58       	ld.w	r8,lr[0x14]
800048c0:	00 00       	add	r0,r0
800048c2:	7a 20       	ld.w	r0,sp[0x8]
800048c4:	00 00       	add	r0,r0
800048c6:	7c 24       	ld.w	r4,lr[0x8]
800048c8:	00 00       	add	r0,r0
800048ca:	79 e0       	ld.w	r0,r12[0x78]
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	45 80       	lddsp	r0,sp[0x160]
800048d0:	00 00       	add	r0,r0
800048d2:	7a 24       	ld.w	r4,sp[0x8]
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	43 60       	lddsp	r0,sp[0xd8]

800048d8 <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
800048d8:	d4 31       	pushm	r0-r7,lr
800048da:	20 2d       	sub	sp,8
800048dc:	18 93       	mov	r3,r12
800048de:	16 97       	mov	r7,r11
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
800048e0:	30 89       	mov	r9,8
800048e2:	fe f8 02 8e 	ld.w	r8,pc[654]
800048e6:	b0 89       	st.b	r8[0x0],r9

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
800048e8:	30 38       	mov	r8,3
800048ea:	f0 0c 18 00 	cp.b	r12,r8
800048ee:	5f 0a       	sreq	r10
800048f0:	50 0a       	stdsp	sp[0x0],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
800048f2:	fe f9 02 82 	ld.w	r9,pc[642]
800048f6:	13 89       	ld.ub	r9,r9[0x0]
800048f8:	f0 09 18 00 	cp.b	r9,r8
800048fc:	5f 08       	sreq	r8
800048fe:	f5 e8 00 08 	and	r8,r10,r8
80004902:	c0 60       	breq	8000490e <fat_cluster_list+0x36>
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80004904:	3f fc       	mov	r12,-1
80004906:	f0 1f 00 9d 	mcall	80004b78 <fat_cluster_list+0x2a0>
8000490a:	e0 80 01 2f 	breq	80004b68 <fat_cluster_list+0x290>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
8000490e:	fe f8 02 6e 	ld.w	r8,pc[622]
80004912:	70 08       	ld.w	r8,r8[0x0]
80004914:	58 08       	cp.w	r8,0
80004916:	c3 b1       	brne	8000498c <fat_cluster_list+0xb4>
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
80004918:	40 09       	lddsp	r9,sp[0x0]
8000491a:	58 09       	cp.w	r9,0
8000491c:	e0 81 01 26 	brne	80004b68 <fat_cluster_list+0x290>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
80004920:	fe f8 02 54 	ld.w	r8,pc[596]
80004924:	11 88       	ld.ub	r8,r8[0x0]
80004926:	f0 ca 00 01 	sub	r10,r8,1
8000492a:	30 19       	mov	r9,1
8000492c:	f2 0a 18 00 	cp.b	r10,r9
80004930:	e0 8b 00 23 	brhi	80004976 <fat_cluster_list+0x9e>
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
80004934:	fe f8 02 48 	ld.w	r8,pc[584]
80004938:	70 18       	ld.w	r8,r8[0x4]
8000493a:	fe f9 02 46 	ld.w	r9,pc[582]
8000493e:	f3 19 00 1a 	ld.uh	r9,r9[26]
80004942:	12 38       	cp.w	r8,r9
80004944:	c1 32       	brcc	8000496a <fat_cluster_list+0x92>
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
80004946:	fe f9 02 36 	ld.w	r9,pc[566]
8000494a:	fe fa 02 36 	ld.w	r10,pc[566]
8000494e:	74 4b       	ld.w	r11,r10[0x10]
80004950:	16 08       	add	r8,r11
80004952:	f5 1b 00 18 	ld.uh	r11,r10[24]
80004956:	16 08       	add	r8,r11
80004958:	93 08       	st.w	r9[0x0],r8
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
8000495a:	f5 1a 00 1a 	ld.uh	r10,r10[26]
8000495e:	72 18       	ld.w	r8,r9[0x4]
80004960:	f4 08 01 08 	sub	r8,r10,r8
80004964:	93 18       	st.w	r9[0x4],r8
80004966:	30 1c       	mov	r12,1
            return true;
80004968:	c0 19       	rjmp	80004b6a <fat_cluster_list+0x292>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
8000496a:	31 a9       	mov	r9,26
8000496c:	fe f8 02 04 	ld.w	r8,pc[516]
80004970:	b0 89       	st.b	r8[0x0],r9
80004972:	30 0c       	mov	r12,0
            return false;        // Position outside the root area
80004974:	cf b8       	rjmp	80004b6a <fat_cluster_list+0x292>
         }
      }
      if ( Is_fat32 )
80004976:	30 39       	mov	r9,3
80004978:	f2 08 18 00 	cp.b	r8,r9
8000497c:	c0 a1       	brne	80004990 <fat_cluster_list+0xb8>
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
8000497e:	fe f8 02 02 	ld.w	r8,pc[514]
80004982:	70 69       	ld.w	r9,r8[0x18]
80004984:	fe f8 02 00 	ld.w	r8,pc[512]
80004988:	91 09       	st.w	r8[0x0],r9
8000498a:	c0 38       	rjmp	80004990 <fat_cluster_list+0xb8>
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
8000498c:	4f e9       	lddpc	r9,80004b84 <fat_cluster_list+0x2ac>
8000498e:	93 08       	st.w	r9[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
80004990:	30 38       	mov	r8,3
80004992:	f0 03 18 00 	cp.b	r3,r8
80004996:	c0 70       	breq	800049a4 <fat_cluster_list+0xcc>
   {
      if( fat_cache_clusterlist_update_read( b_for_file ) )
80004998:	0e 9c       	mov	r12,r7
8000499a:	f0 1f 00 7c 	mcall	80004b88 <fat_cluster_list+0x2b0>
8000499e:	c0 70       	breq	800049ac <fat_cluster_list+0xd4>
800049a0:	30 1c       	mov	r12,1
800049a2:	ce 48       	rjmp	80004b6a <fat_cluster_list+0x292>
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
800049a4:	f0 1f 00 7a 	mcall	80004b8c <fat_cluster_list+0x2b4>
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
800049a8:	f0 1f 00 7a 	mcall	80004b90 <fat_cluster_list+0x2b8>
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
800049ac:	4f 40       	lddpc	r0,80004b7c <fat_cluster_list+0x2a4>
800049ae:	3f f8       	mov	r8,-1
800049b0:	a0 88       	st.b	r0[0x0],r8

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
800049b2:	00 96       	mov	r6,r0
800049b4:	4f 35       	lddpc	r5,80004b80 <fat_cluster_list+0x2a8>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
800049b6:	4f 47       	lddpc	r7,80004b84 <fat_cluster_list+0x2ac>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
800049b8:	30 21       	mov	r1,2
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
800049ba:	e0 c8 ff f9 	sub	r8,r0,-7
800049be:	50 18       	stdsp	sp[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
800049c0:	30 12       	mov	r2,1
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
800049c2:	6c 19       	ld.w	r9,r6[0x4]
800049c4:	0b 98       	ld.ub	r8,r5[0x1]
800049c6:	10 39       	cp.w	r9,r8
800049c8:	c4 32       	brcc	80004a4e <fat_cluster_list+0x176>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
800049ca:	6a 4a       	ld.w	r10,r5[0x10]
800049cc:	14 09       	add	r9,r10
800049ce:	6a 5a       	ld.w	r10,r5[0x14]
800049d0:	14 09       	add	r9,r10
800049d2:	6e 0a       	ld.w	r10,r7[0x0]
800049d4:	20 2a       	sub	r10,2
800049d6:	f4 08 02 48 	mul	r8,r10,r8
800049da:	f2 08 00 08 	add	r8,r9,r8
800049de:	8d 08       	st.w	r6[0x0],r8
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
800049e0:	e2 03 18 00 	cp.b	r3,r1
800049e4:	c0 d1       	brne	800049fe <fat_cluster_list+0x126>
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
800049e6:	4e 67       	lddpc	r7,80004b7c <fat_cluster_list+0x2a4>
800049e8:	4e 68       	lddpc	r8,80004b80 <fat_cluster_list+0x2a8>
800049ea:	11 99       	ld.ub	r9,r8[0x1]
800049ec:	6e 18       	ld.w	r8,r7[0x4]
800049ee:	f2 08 01 08 	sub	r8,r9,r8
800049f2:	8f 18       	st.w	r7[0x4],r8
            fat_cache_clusterlist_update_finish();
800049f4:	f0 1f 00 68 	mcall	80004b94 <fat_cluster_list+0x2bc>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
800049f8:	30 1c       	mov	r12,1
800049fa:	8f 1c       	st.w	r7[0x4],r12
            return true;
800049fc:	cb 78       	rjmp	80004b6a <fat_cluster_list+0x292>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
800049fe:	0b 99       	ld.ub	r9,r5[0x1]
80004a00:	40 1a       	lddsp	r10,sp[0x4]
80004a02:	15 88       	ld.ub	r8,r10[0x0]
80004a04:	f2 08 01 08 	sub	r8,r9,r8
80004a08:	8d 18       	st.w	r6[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80004a0a:	e4 03 18 00 	cp.b	r3,r2
80004a0e:	c2 01       	brne	80004a4e <fat_cluster_list+0x176>
80004a10:	4d 99       	lddpc	r9,80004b74 <fat_cluster_list+0x29c>
80004a12:	13 88       	ld.ub	r8,r9[0x0]
80004a14:	e4 08 18 00 	cp.b	r8,r2
80004a18:	c1 b0       	breq	80004a4e <fat_cluster_list+0x176>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
80004a1a:	6e 04       	ld.w	r4,r7[0x0]
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80004a1c:	30 0c       	mov	r12,0
80004a1e:	f0 1f 00 5f 	mcall	80004b98 <fat_cluster_list+0x2c0>
80004a22:	e0 80 00 a3 	breq	80004b68 <fat_cluster_list+0x290>
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
80004a26:	6e 09       	ld.w	r9,r7[0x0]
80004a28:	f2 c8 ff ff 	sub	r8,r9,-1
80004a2c:	8f 08       	st.w	r7[0x0],r8
80004a2e:	6e 1a       	ld.w	r10,r7[0x4]
80004a30:	14 38       	cp.w	r8,r10
80004a32:	c0 a0       	breq	80004a46 <fat_cluster_list+0x16e>
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
80004a34:	8f 09       	st.w	r7[0x0],r9
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
80004a36:	08 19       	sub	r9,r4
80004a38:	0b 98       	ld.ub	r8,r5[0x1]
80004a3a:	b1 39       	mul	r9,r8
80004a3c:	6c 18       	ld.w	r8,r6[0x4]
80004a3e:	f2 08 00 08 	add	r8,r9,r8
80004a42:	8d 18       	st.w	r6[0x4],r8
                  break;
80004a44:	c0 58       	rjmp	80004a4e <fat_cluster_list+0x176>
               }
               if( !fat_cluster_readnext() )
80004a46:	f0 1f 00 56 	mcall	80004b9c <fat_cluster_list+0x2c4>
80004a4a:	ce e1       	brne	80004a26 <fat_cluster_list+0x14e>
80004a4c:	c8 e8       	rjmp	80004b68 <fat_cluster_list+0x290>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80004a4e:	30 0c       	mov	r12,0
80004a50:	f0 1f 00 52 	mcall	80004b98 <fat_cluster_list+0x2c0>
80004a54:	e0 80 00 8a 	breq	80004b68 <fat_cluster_list+0x290>
         return false;

      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
80004a58:	f0 1f 00 52 	mcall	80004ba0 <fat_cluster_list+0x2c8>
80004a5c:	18 94       	mov	r4,r12
      if (FS_CLUS_BAD == u8_cluster_status)
80004a5e:	e4 0c 18 00 	cp.b	r12,r2
80004a62:	e0 80 00 83 	breq	80004b68 <fat_cluster_list+0x290>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
80004a66:	01 89       	ld.ub	r9,r0[0x0]
80004a68:	3f f8       	mov	r8,-1
80004a6a:	f0 09 18 00 	cp.b	r9,r8
80004a6e:	c4 61       	brne	80004afa <fat_cluster_list+0x222>
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
80004a70:	e2 0c 18 00 	cp.b	r12,r1
80004a74:	c2 b1       	brne	80004aca <fat_cluster_list+0x1f2>
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining
80004a76:	4c 28       	lddpc	r8,80004b7c <fat_cluster_list+0x2a4>
80004a78:	70 17       	ld.w	r7,r8[0x4]

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
80004a7a:	4c b9       	lddpc	r9,80004ba4 <fat_cluster_list+0x2cc>
80004a7c:	13 89       	ld.ub	r9,r9[0x0]
80004a7e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80004a82:	4c aa       	lddpc	r10,80004ba8 <fat_cluster_list+0x2d0>
80004a84:	f4 09 00 29 	add	r9,r10,r9<<0x2
80004a88:	72 2a       	ld.w	r10,r9[0x8]
80004a8a:	0e 1a       	sub	r10,r7
80004a8c:	93 2a       	st.w	r9[0x8],r10
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80004a8e:	4b d9       	lddpc	r9,80004b80 <fat_cluster_list+0x2a8>
80004a90:	72 5b       	ld.w	r11,r9[0x14]
80004a92:	72 4a       	ld.w	r10,r9[0x10]
80004a94:	14 0b       	add	r11,r10
80004a96:	13 99       	ld.ub	r9,r9[0x1]
80004a98:	4b ba       	lddpc	r10,80004b84 <fat_cluster_list+0x2ac>
80004a9a:	74 0a       	ld.w	r10,r10[0x0]
80004a9c:	20 2a       	sub	r10,2
80004a9e:	f2 0a 02 4a 	mul	r10,r9,r10
80004aa2:	f6 0a 00 0a 	add	r10,r11,r10
80004aa6:	91 0a       	st.w	r8[0x0],r10
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
80004aa8:	91 19       	st.w	r8[0x4],r9
            if (FS_CLUST_ACT_CLR != opt_action)
80004aaa:	30 38       	mov	r8,3
80004aac:	f0 03 18 00 	cp.b	r3,r8
80004ab0:	c0 30       	breq	80004ab6 <fat_cluster_list+0x1de>
               fat_cache_clusterlist_update_finish();
80004ab2:	f0 1f 00 39 	mcall	80004b94 <fat_cluster_list+0x2bc>

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
80004ab6:	4b 28       	lddpc	r8,80004b7c <fat_cluster_list+0x2a4>
80004ab8:	4b 39       	lddpc	r9,80004b84 <fat_cluster_list+0x2ac>
80004aba:	72 09       	ld.w	r9,r9[0x0]
80004abc:	91 09       	st.w	r8[0x0],r9
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
80004abe:	91 17       	st.w	r8[0x4],r7
            fs_g_status = FS_ERR_OUT_LIST;
80004ac0:	31 a9       	mov	r9,26
80004ac2:	4a c8       	lddpc	r8,80004b70 <fat_cluster_list+0x298>
80004ac4:	b0 89       	st.b	r8[0x0],r9
80004ac6:	30 0c       	mov	r12,0
            return false;
80004ac8:	c5 18       	rjmp	80004b6a <fat_cluster_list+0x292>
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
80004aca:	0b 98       	ld.ub	r8,r5[0x1]
80004acc:	6c 19       	ld.w	r9,r6[0x4]
80004ace:	f2 08 01 08 	sub	r8,r9,r8
80004ad2:	8d 18       	st.w	r6[0x4],r8
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80004ad4:	40 0a       	lddsp	r10,sp[0x0]
80004ad6:	58 0a       	cp.w	r10,0
80004ad8:	c4 50       	breq	80004b62 <fat_cluster_list+0x28a>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
80004ada:	58 08       	cp.w	r8,0
80004adc:	c4 31       	brne	80004b62 <fat_cluster_list+0x28a>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
80004ade:	6e 18       	ld.w	r8,r7[0x4]
80004ae0:	8d 08       	st.w	r6[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
80004ae2:	e0 68 ff ff 	mov	r8,65535
80004ae6:	ea 18 0f ff 	orh	r8,0xfff
80004aea:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80004aec:	30 1c       	mov	r12,1
80004aee:	f0 1f 00 2b 	mcall	80004b98 <fat_cluster_list+0x2c0>
80004af2:	c3 b0       	breq	80004b68 <fat_cluster_list+0x290>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
80004af4:	6c 08       	ld.w	r8,r6[0x0]
80004af6:	8f 18       	st.w	r7[0x4],r8
80004af8:	c3 58       	rjmp	80004b62 <fat_cluster_list+0x28a>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
80004afa:	e4 03 18 00 	cp.b	r3,r2
80004afe:	c0 a1       	brne	80004b12 <fat_cluster_list+0x23a>
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
80004b00:	6e 09       	ld.w	r9,r7[0x0]
80004b02:	2f f9       	sub	r9,-1
80004b04:	6e 18       	ld.w	r8,r7[0x4]
80004b06:	10 39       	cp.w	r9,r8
80004b08:	c1 b0       	breq	80004b3e <fat_cluster_list+0x266>
            {
               // The cluster is not a continue cluster or a invalid cluster
               fat_cache_clusterlist_update_finish();
80004b0a:	f0 1f 00 23 	mcall	80004b94 <fat_cluster_list+0x2bc>
80004b0e:	30 1c       	mov	r12,1
               return true;                              // End of segment
80004b10:	c2 d8       	rjmp	80004b6a <fat_cluster_list+0x292>
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80004b12:	40 09       	lddsp	r9,sp[0x0]
80004b14:	58 09       	cp.w	r9,0
80004b16:	c1 40       	breq	80004b3e <fat_cluster_list+0x266>
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
80004b18:	6e 18       	ld.w	r8,r7[0x4]
80004b1a:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
80004b1c:	30 08       	mov	r8,0
80004b1e:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
80004b20:	0b 98       	ld.ub	r8,r5[0x1]
80004b22:	6c 19       	ld.w	r9,r6[0x4]
80004b24:	10 39       	cp.w	r9,r8
80004b26:	c0 62       	brcc	80004b32 <fat_cluster_list+0x25a>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
80004b28:	e0 68 ff ff 	mov	r8,65535
80004b2c:	ea 18 0f ff 	orh	r8,0xfff
80004b30:	8f 18       	st.w	r7[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80004b32:	30 1c       	mov	r12,1
80004b34:	f0 1f 00 19 	mcall	80004b98 <fat_cluster_list+0x2c0>
80004b38:	c1 80       	breq	80004b68 <fat_cluster_list+0x290>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
80004b3a:	6c 08       	ld.w	r8,r6[0x0]
80004b3c:	8f 18       	st.w	r7[0x4],r8
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
80004b3e:	e2 04 18 00 	cp.b	r4,r1
80004b42:	c0 b1       	brne	80004b58 <fat_cluster_list+0x280>
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
80004b44:	40 0a       	lddsp	r10,sp[0x0]
80004b46:	58 0a       	cp.w	r10,0
80004b48:	c0 40       	breq	80004b50 <fat_cluster_list+0x278>
            {
               return fat_update_fat2();
80004b4a:	f0 1f 00 19 	mcall	80004bac <fat_cluster_list+0x2d4>
80004b4e:	c0 e8       	rjmp	80004b6a <fat_cluster_list+0x292>
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
80004b50:	f0 1f 00 11 	mcall	80004b94 <fat_cluster_list+0x2bc>
80004b54:	30 1c       	mov	r12,1
            return true; // End of segment
80004b56:	c0 a8       	rjmp	80004b6a <fat_cluster_list+0x292>
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
80004b58:	0b 99       	ld.ub	r9,r5[0x1]
80004b5a:	6c 18       	ld.w	r8,r6[0x4]
80004b5c:	f2 08 00 08 	add	r8,r9,r8
80004b60:	8d 18       	st.w	r6[0x4],r8
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
80004b62:	6e 18       	ld.w	r8,r7[0x4]
80004b64:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
80004b66:	c2 eb       	rjmp	800049c2 <fat_cluster_list+0xea>
80004b68:	30 0c       	mov	r12,0
}
80004b6a:	2f ed       	sub	sp,-8
80004b6c:	d8 32       	popm	r0-r7,pc
80004b6e:	00 00       	add	r0,r0
80004b70:	00 00       	add	r0,r0
80004b72:	7c 74       	ld.w	r4,lr[0x1c]
80004b74:	00 00       	add	r0,r0
80004b76:	7c 70       	ld.w	r0,lr[0x1c]
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	4f 40       	lddpc	r0,80004d48 <fat_check_device+0x38>
80004b7c:	00 00       	add	r0,r0
80004b7e:	7c cc       	ld.w	r12,lr[0x30]
80004b80:	00 00       	add	r0,r0
80004b82:	7c 24       	ld.w	r4,lr[0x8]
80004b84:	00 00       	add	r0,r0
80004b86:	7c c4       	ld.w	r4,lr[0x30]
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	3e 68       	mov	r8,-26
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	3d 38       	mov	r8,-45
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	4e b4       	lddpc	r4,80004d3c <fat_check_device+0x2c>
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	3e 10       	mov	r0,-31
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	46 94       	lddsp	r4,sp[0x1a4]
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	46 00       	lddsp	r0,sp[0x180]
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	3c d8       	mov	r8,-51
80004ba4:	00 00       	add	r0,r0
80004ba6:	7c 76       	ld.w	r6,lr[0x1c]
80004ba8:	00 00       	add	r0,r0
80004baa:	79 f8       	ld.w	r8,r12[0x7c]
80004bac:	80 00       	ld.sh	r0,r0[0x0]
80004bae:	4e cc       	lddpc	r12,80004d5c <fat_check_device+0x4c>

80004bb0 <fat_read_dir>:
//!   fs_g_nav.u32_cluster_sel_dir           First cluster of current directory
//!   fs_g_nav_fast.u16_entry_pos_sel_file   Position in directory (unit entry)
//! @endverbatim
//!
bool  fat_read_dir( void )
{
80004bb0:	eb cd 40 80 	pushm	r7,lr
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);
80004bb4:	49 98       	lddpc	r8,80004c18 <fat_read_dir+0x68>
80004bb6:	90 97       	ld.uh	r7,r8[0x2]
80004bb8:	a5 87       	lsr	r7,0x4

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80004bba:	49 98       	lddpc	r8,80004c1c <fat_read_dir+0x6c>
80004bbc:	11 89       	ld.ub	r9,r8[0x0]
80004bbe:	49 98       	lddpc	r8,80004c20 <fat_read_dir+0x70>
80004bc0:	11 88       	ld.ub	r8,r8[0x0]
80004bc2:	f0 09 18 00 	cp.b	r9,r8
80004bc6:	c0 d1       	brne	80004be0 <fat_read_dir+0x30>
80004bc8:	49 58       	lddpc	r8,80004c1c <fat_read_dir+0x6c>
80004bca:	70 39       	ld.w	r9,r8[0xc]
80004bcc:	49 58       	lddpc	r8,80004c20 <fat_read_dir+0x70>
80004bce:	70 88       	ld.w	r8,r8[0x20]
80004bd0:	10 39       	cp.w	r9,r8
80004bd2:	c0 71       	brne	80004be0 <fat_read_dir+0x30>
80004bd4:	49 28       	lddpc	r8,80004c1c <fat_read_dir+0x6c>
80004bd6:	70 48       	ld.w	r8,r8[0x10]
80004bd8:	0e 38       	cp.w	r8,r7
80004bda:	c0 31       	brne	80004be0 <fat_read_dir+0x30>
80004bdc:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
         return true;      // The internal cache contains the sector asked
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
80004be0:	49 18       	lddpc	r8,80004c24 <fat_read_dir+0x74>
80004be2:	49 09       	lddpc	r9,80004c20 <fat_read_dir+0x70>
80004be4:	72 89       	ld.w	r9,r9[0x20]
80004be6:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
80004be8:	91 17       	st.w	r8[0x4],r7
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
80004bea:	30 0b       	mov	r11,0
80004bec:	30 2c       	mov	r12,2
80004bee:	f0 1f 00 0f 	mcall	80004c28 <fat_read_dir+0x78>
80004bf2:	c1 00       	breq	80004c12 <fat_read_dir+0x62>
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
80004bf4:	48 c8       	lddpc	r8,80004c24 <fat_read_dir+0x74>
80004bf6:	70 09       	ld.w	r9,r8[0x0]
80004bf8:	48 d8       	lddpc	r8,80004c2c <fat_read_dir+0x7c>
80004bfa:	91 09       	st.w	r8[0x0],r9
      if( fat_cache_read_sector( true ) )
80004bfc:	30 1c       	mov	r12,1
80004bfe:	f0 1f 00 0d 	mcall	80004c30 <fat_read_dir+0x80>
80004c02:	c0 80       	breq	80004c12 <fat_read_dir+0x62>
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
80004c04:	48 68       	lddpc	r8,80004c1c <fat_read_dir+0x6c>
80004c06:	48 79       	lddpc	r9,80004c20 <fat_read_dir+0x70>
80004c08:	72 89       	ld.w	r9,r9[0x20]
80004c0a:	91 39       	st.w	r8[0xc],r9
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
80004c0c:	91 47       	st.w	r8[0x10],r7
80004c0e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
         return true;
80004c12:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80004c16:	00 00       	add	r0,r0
80004c18:	00 00       	add	r0,r0
80004c1a:	7c 70       	ld.w	r0,lr[0x1c]
80004c1c:	00 00       	add	r0,r0
80004c1e:	7c ac       	ld.w	r12,lr[0x28]
80004c20:	00 00       	add	r0,r0
80004c22:	7c 24       	ld.w	r4,lr[0x8]
80004c24:	00 00       	add	r0,r0
80004c26:	7c cc       	ld.w	r12,lr[0x30]
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	48 d8       	lddpc	r8,80004c5c <fat_read_file+0x28>
80004c2c:	00 00       	add	r0,r0
80004c2e:	79 e0       	ld.w	r0,r12[0x78]
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	45 80       	lddsp	r0,sp[0x160]

80004c34 <fat_read_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
{
80004c34:	eb cd 40 c0 	pushm	r6-r7,lr
80004c38:	18 97       	mov	r7,r12
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;
80004c3a:	4a e8       	lddpc	r8,80004cf0 <fat_read_file+0xbc>
80004c3c:	70 38       	ld.w	r8,r8[0xc]
80004c3e:	f0 06 16 09 	lsr	r6,r8,0x9

   if(FS_CLUST_ACT_ONE  == mode)
80004c42:	30 29       	mov	r9,2
80004c44:	f2 0c 18 00 	cp.b	r12,r9
80004c48:	c1 31       	brne	80004c6e <fat_read_file+0x3a>
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80004c4a:	4a b8       	lddpc	r8,80004cf4 <fat_read_file+0xc0>
80004c4c:	11 89       	ld.ub	r9,r8[0x0]
80004c4e:	4a b8       	lddpc	r8,80004cf8 <fat_read_file+0xc4>
80004c50:	11 88       	ld.ub	r8,r8[0x0]
80004c52:	f0 09 18 00 	cp.b	r9,r8
80004c56:	c1 91       	brne	80004c88 <fat_read_file+0x54>
80004c58:	4a 78       	lddpc	r8,80004cf4 <fat_read_file+0xc0>
80004c5a:	70 39       	ld.w	r9,r8[0xc]
80004c5c:	4a 58       	lddpc	r8,80004cf0 <fat_read_file+0xbc>
80004c5e:	70 18       	ld.w	r8,r8[0x4]
80004c60:	10 39       	cp.w	r9,r8
80004c62:	c1 31       	brne	80004c88 <fat_read_file+0x54>
80004c64:	4a 48       	lddpc	r8,80004cf4 <fat_read_file+0xc0>
80004c66:	70 48       	ld.w	r8,r8[0x10]
80004c68:	0c 38       	cp.w	r8,r6
80004c6a:	c0 f1       	brne	80004c88 <fat_read_file+0x54>
80004c6c:	c3 38       	rjmp	80004cd2 <fat_read_file+0x9e>
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
80004c6e:	30 39       	mov	r9,3
80004c70:	f2 0c 18 00 	cp.b	r12,r9
80004c74:	c3 31       	brne	80004cda <fat_read_file+0xa6>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
80004c76:	49 f9       	lddpc	r9,80004cf0 <fat_read_file+0xbc>
80004c78:	72 19       	ld.w	r9,r9[0x4]
80004c7a:	58 09       	cp.w	r9,0
80004c7c:	c2 b0       	breq	80004cd2 <fat_read_file+0x9e>
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
80004c7e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004c82:	c2 c0       	breq	80004cda <fat_read_file+0xa6>
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
80004c84:	2f f6       	sub	r6,-1
80004c86:	c2 a8       	rjmp	80004cda <fat_read_file+0xa6>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80004c88:	49 d8       	lddpc	r8,80004cfc <fat_read_file+0xc8>
80004c8a:	49 a9       	lddpc	r9,80004cf0 <fat_read_file+0xbc>
80004c8c:	72 19       	ld.w	r9,r9[0x4]
80004c8e:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80004c90:	91 16       	st.w	r8[0x4],r6
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
80004c92:	30 1b       	mov	r11,1
80004c94:	16 9c       	mov	r12,r11
80004c96:	f0 1f 00 1b 	mcall	80004d00 <fat_read_file+0xcc>
80004c9a:	c1 e0       	breq	80004cd6 <fat_read_file+0xa2>
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
80004c9c:	49 88       	lddpc	r8,80004cfc <fat_read_file+0xc8>
80004c9e:	70 09       	ld.w	r9,r8[0x0]
80004ca0:	49 98       	lddpc	r8,80004d04 <fat_read_file+0xd0>
80004ca2:	91 09       	st.w	r8[0x0],r9
         if( fat_cache_read_sector( true ) )
80004ca4:	30 1c       	mov	r12,1
80004ca6:	f0 1f 00 19 	mcall	80004d08 <fat_read_file+0xd4>
80004caa:	c1 60       	breq	80004cd6 <fat_read_file+0xa2>
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
80004cac:	49 28       	lddpc	r8,80004cf4 <fat_read_file+0xc0>
80004cae:	49 19       	lddpc	r9,80004cf0 <fat_read_file+0xbc>
80004cb0:	72 19       	ld.w	r9,r9[0x4]
80004cb2:	91 39       	st.w	r8[0xc],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
80004cb4:	91 46       	st.w	r8[0x10],r6
80004cb6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
80004cba:	30 38       	mov	r8,3
80004cbc:	f0 07 18 00 	cp.b	r7,r8
80004cc0:	c0 b1       	brne	80004cd6 <fat_read_file+0xa2>
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
80004cc2:	49 38       	lddpc	r8,80004d0c <fat_read_file+0xd8>
80004cc4:	11 89       	ld.ub	r9,r8[0x0]
80004cc6:	31 a8       	mov	r8,26
80004cc8:	f0 09 18 00 	cp.b	r9,r8
80004ccc:	5f 0c       	sreq	r12
80004cce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cd2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004cd6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80004cda:	48 98       	lddpc	r8,80004cfc <fat_read_file+0xc8>
80004cdc:	48 59       	lddpc	r9,80004cf0 <fat_read_file+0xbc>
80004cde:	72 19       	ld.w	r9,r9[0x4]
80004ce0:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80004ce2:	91 16       	st.w	r8[0x4],r6
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
80004ce4:	30 1b       	mov	r11,1
80004ce6:	0e 9c       	mov	r12,r7
80004ce8:	f0 1f 00 06 	mcall	80004d00 <fat_read_file+0xcc>
80004cec:	ce 70       	breq	80004cba <fat_read_file+0x86>
80004cee:	cf 2b       	rjmp	80004cd2 <fat_read_file+0x9e>
80004cf0:	00 00       	add	r0,r0
80004cf2:	79 e4       	ld.w	r4,r12[0x78]
80004cf4:	00 00       	add	r0,r0
80004cf6:	7c ac       	ld.w	r12,lr[0x28]
80004cf8:	00 00       	add	r0,r0
80004cfa:	7c 24       	ld.w	r4,lr[0x8]
80004cfc:	00 00       	add	r0,r0
80004cfe:	7c cc       	ld.w	r12,lr[0x30]
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	48 d8       	lddpc	r8,80004d34 <fat_check_device+0x24>
80004d04:	00 00       	add	r0,r0
80004d06:	79 e0       	ld.w	r0,r12[0x78]
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	45 80       	lddsp	r0,sp[0x160]
80004d0c:	00 00       	add	r0,r0
80004d0e:	7c 74       	ld.w	r4,lr[0x1c]

80004d10 <fat_check_device>:
//! @verbatim
//! This function updates all navigator data when the device state change.
//! @endverbatim
//!
bool  fat_check_device( void )
{
80004d10:	d4 31       	pushm	r0-r7,lr
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
80004d12:	4a 28       	lddpc	r8,80004d98 <fat_check_device+0x88>
80004d14:	11 89       	ld.ub	r9,r8[0x0]
80004d16:	30 08       	mov	r8,0
80004d18:	f0 09 18 00 	cp.b	r9,r8
80004d1c:	c3 c1       	brne	80004d94 <fat_check_device+0x84>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
80004d1e:	4a 08       	lddpc	r8,80004d9c <fat_check_device+0x8c>
80004d20:	11 89       	ld.ub	r9,r8[0x0]
80004d22:	3f f8       	mov	r8,-1
80004d24:	f0 09 18 00 	cp.b	r9,r8
80004d28:	c0 51       	brne	80004d32 <fat_check_device+0x22>
   {
      fs_g_status = FS_ERR_HW;
80004d2a:	30 19       	mov	r9,1
80004d2c:	49 d8       	lddpc	r8,80004da0 <fat_check_device+0x90>
80004d2e:	b0 89       	st.b	r8[0x0],r9
80004d30:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;                                // No device selected
80004d32:	30 02       	mov	r2,0
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80004d34:	49 a5       	lddpc	r5,80004d9c <fat_check_device+0x8c>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80004d36:	49 c1       	lddpc	r1,80004da4 <fat_check_device+0x94>
80004d38:	30 06       	mov	r6,0
      Fat_file_close();                            // By default the file is not open
80004d3a:	49 c0       	lddpc	r0,80004da8 <fat_check_device+0x98>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004d3c:	49 c4       	lddpc	r4,80004dac <fat_check_device+0x9c>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
80004d3e:	49 d3       	lddpc	r3,80004db0 <fat_check_device+0xa0>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80004d40:	0b 8c       	ld.ub	r12,r5[0x0]
80004d42:	f0 1f 00 1d 	mcall	80004db4 <fat_check_device+0xa4>
80004d46:	18 97       	mov	r7,r12
      if( CTRL_GOOD       == status )
80004d48:	c2 60       	breq	80004d94 <fat_check_device+0x84>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80004d4a:	a2 86       	st.b	r1[0x0],r6
      Fat_file_close();                            // By default the file is not open
80004d4c:	a0 86       	st.b	r0[0x0],r6
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004d4e:	0b 88       	ld.ub	r8,r5[0x0]
80004d50:	09 89       	ld.ub	r9,r4[0x0]
80004d52:	f0 09 18 00 	cp.b	r9,r8
80004d56:	c0 51       	brne	80004d60 <fat_check_device+0x50>
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
80004d58:	49 89       	lddpc	r9,80004db8 <fat_check_device+0xa8>
80004d5a:	b2 86       	st.b	r9[0x0],r6
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
80004d5c:	49 89       	lddpc	r9,80004dbc <fat_check_device+0xac>
80004d5e:	b2 86       	st.b	r9[0x0],r6
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
80004d60:	07 89       	ld.ub	r9,r3[0x0]
80004d62:	f0 09 18 00 	cp.b	r9,r8
80004d66:	c0 31       	brne	80004d6c <fat_check_device+0x5c>
      {
         fat_cache_reset();
80004d68:	f0 1f 00 16 	mcall	80004dc0 <fat_check_device+0xb0>
      }
      fat_cache_clusterlist_reset();
80004d6c:	f0 1f 00 16 	mcall	80004dc4 <fat_check_device+0xb4>

      fs_g_status = FS_ERR_HW;                     // By default HW error
80004d70:	30 18       	mov	r8,1
80004d72:	48 c9       	lddpc	r9,80004da0 <fat_check_device+0x90>
80004d74:	b2 88       	st.b	r9[0x0],r8
      if( CTRL_BUSY == status )
80004d76:	58 37       	cp.w	r7,3
80004d78:	c0 81       	brne	80004d88 <fat_check_device+0x78>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
80004d7a:	10 02       	add	r2,r8
80004d7c:	5c 52       	castu.b	r2
80004d7e:	36 48       	mov	r8,100
80004d80:	f0 02 18 00 	cp.b	r2,r8
80004d84:	cd e1       	brne	80004d40 <fat_check_device+0x30>
80004d86:	c0 88       	rjmp	80004d96 <fat_check_device+0x86>

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
80004d88:	58 27       	cp.w	r7,2
80004d8a:	c0 61       	brne	80004d96 <fat_check_device+0x86>
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
80004d8c:	31 89       	mov	r9,24
80004d8e:	48 58       	lddpc	r8,80004da0 <fat_check_device+0x90>
80004d90:	b0 89       	st.b	r8[0x0],r9
80004d92:	d8 3a       	popm	r0-r7,pc,r12=0
80004d94:	da 3a       	popm	r0-r7,pc,r12=1
80004d96:	d8 3a       	popm	r0-r7,pc,r12=0
80004d98:	00 00       	add	r0,r0
80004d9a:	79 f6       	ld.w	r6,r12[0x7c]
80004d9c:	00 00       	add	r0,r0
80004d9e:	7c 24       	ld.w	r4,lr[0x8]
80004da0:	00 00       	add	r0,r0
80004da2:	7c 74       	ld.w	r4,lr[0x1c]
80004da4:	00 00       	add	r0,r0
80004da6:	7c 70       	ld.w	r0,lr[0x1c]
80004da8:	00 00       	add	r0,r0
80004daa:	79 e4       	ld.w	r4,r12[0x78]
80004dac:	00 00       	add	r0,r0
80004dae:	7c 78       	ld.w	r8,lr[0x1c]
80004db0:	00 00       	add	r0,r0
80004db2:	7c ac       	ld.w	r12,lr[0x28]
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	5c a4       	swap.h	r4
80004db8:	00 00       	add	r0,r0
80004dba:	7c 6c       	ld.w	r12,lr[0x18]
80004dbc:	00 00       	add	r0,r0
80004dbe:	7c 5c       	ld.w	r12,lr[0x14]
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	43 48       	lddsp	r8,sp[0xd0]
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	3d 38       	mov	r8,-45

80004dc8 <fat_check_noopen>:
//!
//! @return    true  no file opened
//! @return    false otherwise
//!
bool  fat_check_noopen( void )
{
80004dc8:	d4 01       	pushm	lr
   if( !fat_check_device() )
80004dca:	f0 1f 00 0b 	mcall	80004df4 <fat_check_noopen+0x2c>
80004dce:	c1 10       	breq	80004df0 <fat_check_noopen+0x28>
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80004dd0:	48 a8       	lddpc	r8,80004df8 <fat_check_noopen+0x30>
80004dd2:	11 89       	ld.ub	r9,r8[0x0]
80004dd4:	30 08       	mov	r8,0
80004dd6:	f0 09 18 00 	cp.b	r9,r8
80004dda:	c0 b0       	breq	80004df0 <fat_check_noopen+0x28>
      return true;
   if( Fat_file_is_open() )
80004ddc:	48 88       	lddpc	r8,80004dfc <fat_check_noopen+0x34>
80004dde:	11 89       	ld.ub	r9,r8[0x0]
80004de0:	30 08       	mov	r8,0
80004de2:	f0 09 18 00 	cp.b	r9,r8
80004de6:	c0 50       	breq	80004df0 <fat_check_noopen+0x28>
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
80004de8:	30 59       	mov	r9,5
80004dea:	48 68       	lddpc	r8,80004e00 <fat_check_noopen+0x38>
80004dec:	b0 89       	st.b	r8[0x0],r9
80004dee:	d8 0a       	popm	pc,r12=0
      return false;
80004df0:	da 0a       	popm	pc,r12=1
80004df2:	00 00       	add	r0,r0
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	4d 10       	lddpc	r0,80004f38 <fat_update_fat2+0x6c>
80004df8:	00 00       	add	r0,r0
80004dfa:	7c 70       	ld.w	r0,lr[0x1c]
80004dfc:	00 00       	add	r0,r0
80004dfe:	79 e4       	ld.w	r4,r12[0x78]
80004e00:	00 00       	add	r0,r0
80004e02:	7c 74       	ld.w	r4,lr[0x1c]

80004e04 <fat_check_mount>:
//!
//! @return    true  partition mounted
//! @return    false otherwise
//!
bool  fat_check_mount( void )
{
80004e04:	d4 01       	pushm	lr
   if( !fat_check_device() )
80004e06:	f0 1f 00 0a 	mcall	80004e2c <fat_check_mount+0x28>
80004e0a:	c0 f0       	breq	80004e28 <fat_check_mount+0x24>
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80004e0c:	48 98       	lddpc	r8,80004e30 <fat_check_mount+0x2c>
80004e0e:	11 89       	ld.ub	r9,r8[0x0]
80004e10:	30 08       	mov	r8,0
80004e12:	f0 09 18 00 	cp.b	r9,r8
80004e16:	c0 81       	brne	80004e26 <fat_check_mount+0x22>
   {
      if( !fat_mount() )
80004e18:	f0 1f 00 07 	mcall	80004e34 <fat_check_mount+0x30>
80004e1c:	c0 51       	brne	80004e26 <fat_check_mount+0x22>
      {
         fs_g_status = FS_ERR_NO_MOUNT;
80004e1e:	30 e9       	mov	r9,14
80004e20:	48 68       	lddpc	r8,80004e38 <fat_check_mount+0x34>
80004e22:	b0 89       	st.b	r8[0x0],r9
         return false;
80004e24:	d8 02       	popm	pc
80004e26:	30 1c       	mov	r12,1
      }
   }
   return true;
}
80004e28:	d8 02       	popm	pc
80004e2a:	00 00       	add	r0,r0
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4d 10       	lddpc	r0,80004f70 <fat_write_fat32_FSInfo+0x30>
80004e30:	00 00       	add	r0,r0
80004e32:	7c 70       	ld.w	r0,lr[0x1c]
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	4f e0       	lddpc	r0,8000502c <fat_mount+0x4c>
80004e38:	00 00       	add	r0,r0
80004e3a:	7c 74       	ld.w	r4,lr[0x1c]

80004e3c <fat_check_mount_select>:
//!
//! @return    true  partition mounted and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select( void )
{
80004e3c:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004e3e:	f0 1f 00 04 	mcall	80004e4c <fat_check_mount_select+0x10>
80004e42:	c0 30       	breq	80004e48 <fat_check_mount_select+0xc>
      return false;
   return fat_check_select();
80004e44:	f0 1f 00 03 	mcall	80004e50 <fat_check_mount_select+0x14>
}
80004e48:	d8 02       	popm	pc
80004e4a:	00 00       	add	r0,r0
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	4e 04       	lddpc	r4,80004fcc <fat_write_fat32_FSInfo+0x8c>
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	3c 9c       	mov	r12,-55

80004e54 <fat_check_mount_select_open>:
//!
//! @return    true  partition mounted and a file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_select_open( void )
{
80004e54:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004e56:	f0 1f 00 06 	mcall	80004e6c <fat_check_mount_select_open+0x18>
80004e5a:	c0 70       	breq	80004e68 <fat_check_mount_select_open+0x14>
      return false;
   if( !fat_check_select() )
80004e5c:	f0 1f 00 05 	mcall	80004e70 <fat_check_mount_select_open+0x1c>
80004e60:	c0 40       	breq	80004e68 <fat_check_mount_select_open+0x14>
      return false;
   return fat_check_open();
80004e62:	f0 1f 00 05 	mcall	80004e74 <fat_check_mount_select_open+0x20>
80004e66:	d8 02       	popm	pc
80004e68:	d8 0a       	popm	pc,r12=0
80004e6a:	00 00       	add	r0,r0
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	4e 04       	lddpc	r4,80004fec <fat_mount+0xc>
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	3c 9c       	mov	r12,-55
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	3c 7c       	mov	r12,-57

80004e78 <fat_check_mount_select_noopen>:
//!
//! @return    true  partition mounted and no file is opened and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select_noopen( void )
{
80004e78:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004e7a:	f0 1f 00 06 	mcall	80004e90 <fat_check_mount_select_noopen+0x18>
80004e7e:	c0 70       	breq	80004e8c <fat_check_mount_select_noopen+0x14>
      return false;
   if( !fat_check_select() )
80004e80:	f0 1f 00 05 	mcall	80004e94 <fat_check_mount_select_noopen+0x1c>
80004e84:	c0 40       	breq	80004e8c <fat_check_mount_select_noopen+0x14>
      return false;
   return fat_check_noopen();
80004e86:	f0 1f 00 05 	mcall	80004e98 <fat_check_mount_select_noopen+0x20>
80004e8a:	d8 02       	popm	pc
80004e8c:	d8 0a       	popm	pc,r12=0
80004e8e:	00 00       	add	r0,r0
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	4e 04       	lddpc	r4,80005010 <fat_mount+0x30>
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	3c 9c       	mov	r12,-55
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	4d c8       	lddpc	r8,80005008 <fat_mount+0x28>

80004e9c <fat_check_mount_noopen>:
//!
//! @return    true  partition mounted and no file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_noopen( void )
{
80004e9c:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004e9e:	f0 1f 00 04 	mcall	80004eac <fat_check_mount_noopen+0x10>
80004ea2:	c0 30       	breq	80004ea8 <fat_check_mount_noopen+0xc>
      return false;
   return fat_check_noopen();
80004ea4:	f0 1f 00 03 	mcall	80004eb0 <fat_check_mount_noopen+0x14>
}
80004ea8:	d8 02       	popm	pc
80004eaa:	00 00       	add	r0,r0
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	4e 04       	lddpc	r4,8000502c <fat_mount+0x4c>
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	4d c8       	lddpc	r8,80005020 <fat_mount+0x40>

80004eb4 <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
80004eb4:	3f f9       	mov	r9,-1
80004eb6:	48 48       	lddpc	r8,80004ec4 <fat_clear_info_fat_mod+0x10>
80004eb8:	91 09       	st.w	r8[0x0],r9
   fs_g_u32_last_mod_fat = 0;
80004eba:	30 09       	mov	r9,0
80004ebc:	48 38       	lddpc	r8,80004ec8 <fat_clear_info_fat_mod+0x14>
80004ebe:	91 09       	st.w	r8[0x0],r9
}
80004ec0:	5e fc       	retal	r12
80004ec2:	00 00       	add	r0,r0
80004ec4:	00 00       	add	r0,r0
80004ec6:	7c 58       	ld.w	r8,lr[0x14]
80004ec8:	00 00       	add	r0,r0
80004eca:	7a 20       	ld.w	r0,sp[0x8]

80004ecc <fat_update_fat2>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
80004ecc:	eb cd 40 fc 	pushm	r2-r7,lr
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004ed0:	49 68       	lddpc	r8,80004f28 <fat_update_fat2+0x5c>
80004ed2:	70 08       	ld.w	r8,r8[0x0]
80004ed4:	49 69       	lddpc	r9,80004f2c <fat_update_fat2+0x60>
80004ed6:	72 09       	ld.w	r9,r9[0x0]
80004ed8:	12 38       	cp.w	r8,r9
80004eda:	e0 8b 00 25 	brhi	80004f24 <fat_update_fat2+0x58>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
80004ede:	49 55       	lddpc	r5,80004f30 <fat_update_fat2+0x64>
80004ee0:	49 57       	lddpc	r7,80004f34 <fat_update_fat2+0x68>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80004ee2:	30 13       	mov	r3,1
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80004ee4:	49 16       	lddpc	r6,80004f28 <fat_update_fat2+0x5c>
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80004ee6:	30 02       	mov	r2,0
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004ee8:	49 14       	lddpc	r4,80004f2c <fat_update_fat2+0x60>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
80004eea:	6e 49       	ld.w	r9,r7[0x10]
80004eec:	12 08       	add	r8,r9
80004eee:	8b 08       	st.w	r5[0x0],r8
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80004ef0:	06 9c       	mov	r12,r3
80004ef2:	f0 1f 00 12 	mcall	80004f38 <fat_update_fat2+0x6c>
80004ef6:	c1 50       	breq	80004f20 <fat_update_fat2+0x54>
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80004ef8:	6e 19       	ld.w	r9,r7[0x4]
80004efa:	6e 48       	ld.w	r8,r7[0x10]
80004efc:	f2 08 00 08 	add	r8,r9,r8
80004f00:	6c 09       	ld.w	r9,r6[0x0]
80004f02:	12 08       	add	r8,r9
80004f04:	8b 08       	st.w	r5[0x0],r8
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80004f06:	04 9c       	mov	r12,r2
80004f08:	f0 1f 00 0c 	mcall	80004f38 <fat_update_fat2+0x6c>
80004f0c:	c0 a0       	breq	80004f20 <fat_update_fat2+0x54>
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
80004f0e:	f0 1f 00 0c 	mcall	80004f3c <fat_update_fat2+0x70>
     fs_g_u32_first_mod_fat++;
80004f12:	6c 08       	ld.w	r8,r6[0x0]
80004f14:	2f f8       	sub	r8,-1
80004f16:	8d 08       	st.w	r6[0x0],r8
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004f18:	68 09       	ld.w	r9,r4[0x0]
80004f1a:	10 39       	cp.w	r9,r8
80004f1c:	ce 72       	brcc	80004eea <fat_update_fat2+0x1e>
80004f1e:	c0 38       	rjmp	80004f24 <fat_update_fat2+0x58>
80004f20:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004f24:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80004f28:	00 00       	add	r0,r0
80004f2a:	7c 58       	ld.w	r8,lr[0x14]
80004f2c:	00 00       	add	r0,r0
80004f2e:	7a 20       	ld.w	r0,sp[0x8]
80004f30:	00 00       	add	r0,r0
80004f32:	79 e0       	ld.w	r0,r12[0x78]
80004f34:	00 00       	add	r0,r0
80004f36:	7c 24       	ld.w	r4,lr[0x8]
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	45 80       	lddsp	r0,sp[0x160]
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	43 60       	lddsp	r0,sp[0xd8]

80004f40 <fat_write_fat32_FSInfo>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
80004f40:	eb cd 40 c0 	pushm	r6-r7,lr
80004f44:	20 1d       	sub	sp,4
80004f46:	50 0c       	stdsp	sp[0x0],r12
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
80004f48:	49 c8       	lddpc	r8,80004fb8 <fat_write_fat32_FSInfo+0x78>
80004f4a:	90 c9       	ld.uh	r9,r8[0x8]
80004f4c:	70 4a       	ld.w	r10,r8[0x10]
80004f4e:	49 c8       	lddpc	r8,80004fbc <fat_write_fat32_FSInfo+0x7c>
80004f50:	12 1a       	sub	r10,r9
80004f52:	91 0a       	st.w	r8[0x0],r10

   if( !fat_cache_read_sector( false ))
80004f54:	30 0c       	mov	r12,0
80004f56:	f0 1f 00 1b 	mcall	80004fc0 <fat_write_fat32_FSInfo+0x80>
80004f5a:	c2 c0       	breq	80004fb2 <fat_write_fat32_FSInfo+0x72>
      return false;
   fat_cache_mark_sector_as_dirty();
80004f5c:	f0 1f 00 1a 	mcall	80004fc4 <fat_write_fat32_FSInfo+0x84>
   fat_cache_clear();
80004f60:	f0 1f 00 1a 	mcall	80004fc8 <fat_write_fat32_FSInfo+0x88>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
80004f64:	49 a7       	lddpc	r7,80004fcc <fat_write_fat32_FSInfo+0x8c>
80004f66:	30 46       	mov	r6,4
80004f68:	0c 9a       	mov	r10,r6
80004f6a:	49 ab       	lddpc	r11,80004fd0 <fat_write_fat32_FSInfo+0x90>
80004f6c:	0e 9c       	mov	r12,r7
80004f6e:	f0 1f 00 1a 	mcall	80004fd4 <fat_write_fat32_FSInfo+0x94>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
80004f72:	0c 9a       	mov	r10,r6
80004f74:	49 9b       	lddpc	r11,80004fd8 <fat_write_fat32_FSInfo+0x98>
80004f76:	ee cc fe 1c 	sub	r12,r7,-484
80004f7a:	f0 1f 00 17 	mcall	80004fd4 <fat_write_fat32_FSInfo+0x94>
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
80004f7e:	1b b9       	ld.ub	r9,sp[0x3]
80004f80:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
80004f84:	1b a9       	ld.ub	r9,sp[0x2]
80004f86:	ef 69 01 e9 	st.b	r7[489],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
80004f8a:	1b 99       	ld.ub	r9,sp[0x1]
80004f8c:	ef 69 01 ea 	st.b	r7[490],r9
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
80004f90:	1b 88       	ld.ub	r8,sp[0x0]
80004f92:	ef 68 01 eb 	st.b	r7[491],r8
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
80004f96:	0c 9a       	mov	r10,r6
80004f98:	e0 6b 00 ff 	mov	r11,255
80004f9c:	ee cc fe 14 	sub	r12,r7,-492
80004fa0:	f0 1f 00 0f 	mcall	80004fdc <fat_write_fat32_FSInfo+0x9c>
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
80004fa4:	35 58       	mov	r8,85
80004fa6:	ef 68 01 fe 	st.b	r7[510],r8
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
80004faa:	3a a8       	mov	r8,-86
80004fac:	ef 68 01 ff 	st.b	r7[511],r8
80004fb0:	30 1c       	mov	r12,1
   return true;
}
80004fb2:	2f fd       	sub	sp,-4
80004fb4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fb8:	00 00       	add	r0,r0
80004fba:	7c 24       	ld.w	r4,lr[0x8]
80004fbc:	00 00       	add	r0,r0
80004fbe:	79 e0       	ld.w	r0,r12[0x78]
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	45 80       	lddsp	r0,sp[0x160]
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	43 60       	lddsp	r0,sp[0xd8]
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	45 68       	lddsp	r8,sp[0x158]
80004fcc:	00 00       	add	r0,r0
80004fce:	7a 24       	ld.w	r4,sp[0x8]
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	b0 f0       	st.b	r8[0x7],r0
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	9f ac       	st.w	pc[0x28],r12
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	b0 f4       	st.b	r8[0x7],r4
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	a0 f4       	st.b	r0[0x7],r4

80004fe0 <fat_mount>:
//! If the FS_MULTI_PARTITION option is disabled
//! then the mount routine selects the first partition supported by file system. <br>
//! @endverbatim
//!
bool  fat_mount( void )
{
80004fe0:	d4 31       	pushm	r0-r7,lr
80004fe2:	20 3d       	sub	sp,12
   uint8_t  u8_tmp;
   uint16_t u16_tmp;
   uint32_t u32_tmp;

   // Select the root directory
   fs_g_nav.u32_cluster_sel_dir   = 0;
80004fe4:	30 07       	mov	r7,0
80004fe6:	fe f8 02 d2 	ld.w	r8,pc[722]
80004fea:	91 87       	st.w	r8[0x20],r7
   // No selected file
   fat_clear_entry_info_and_ptr();
80004fec:	f0 1f 00 b4 	mcall	800052bc <fat_mount+0x2dc>

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
80004ff0:	fe f8 02 d0 	ld.w	r8,pc[720]
80004ff4:	b0 87       	st.b	r8[0x0],r7
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory
80004ff6:	fe f8 02 ce 	ld.w	r8,pc[718]
80004ffa:	91 07       	st.w	r8[0x0],r7

   // Check if the drive is available
   if( !fat_check_device() )
80004ffc:	f0 1f 00 b3 	mcall	800052c8 <fat_mount+0x2e8>
80005000:	e0 80 01 58 	breq	800052b0 <fat_mount+0x2d0>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80005004:	fe f5 02 c8 	ld.w	r5,pc[712]
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
80005008:	ea c8 fe 42 	sub	r8,r5,-446
8000500c:	50 08       	stdsp	sp[0x0],r8
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000500e:	38 04       	mov	r4,-128
80005010:	30 46       	mov	r6,4
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
80005012:	30 1c       	mov	r12,1
80005014:	f0 1f 00 af 	mcall	800052d0 <fat_mount+0x2f0>
80005018:	e0 80 01 4c 	breq	800052b0 <fat_mount+0x2d0>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
8000501c:	eb 39 01 fe 	ld.ub	r9,r5[510]
80005020:	35 58       	mov	r8,85
80005022:	f0 09 18 00 	cp.b	r9,r8
80005026:	c0 d0       	breq	80005040 <fat_mount+0x60>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
80005028:	eb 39 01 ff 	ld.ub	r9,r5[511]
8000502c:	3a a8       	mov	r8,-86
8000502e:	f0 09 18 00 	cp.b	r9,r8
80005032:	c0 70       	breq	80005040 <fat_mount+0x60>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
80005034:	30 29       	mov	r9,2
80005036:	fe f8 02 9e 	ld.w	r8,pc[670]
8000503a:	b0 89       	st.b	r8[0x0],r9
8000503c:	30 0c       	mov	r12,0
         return false;
8000503e:	c3 a9       	rjmp	800052b2 <fat_mount+0x2d2>
      }

      if ( 0 == fs_gu32_addrsector )
80005040:	fe f8 02 84 	ld.w	r8,pc[644]
80005044:	70 08       	ld.w	r8,r8[0x0]
80005046:	58 08       	cp.w	r8,0
80005048:	c5 21       	brne	800050ec <fat_mount+0x10c>
8000504a:	40 08       	lddsp	r8,sp[0x0]
8000504c:	30 0a       	mov	r10,0
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000504e:	30 1e       	mov	lr,1
80005050:	30 63       	mov	r3,6
80005052:	30 e2       	mov	r2,14
80005054:	30 b1       	mov	r1,11
80005056:	30 c0       	mov	r0,12
80005058:	11 89       	ld.ub	r9,r8[0x0]
8000505a:	e8 09 18 00 	cp.b	r9,r4
8000505e:	5f 0b       	sreq	r11
80005060:	ee 09 18 00 	cp.b	r9,r7
80005064:	5f 09       	sreq	r9
80005066:	f7 e9 10 09 	or	r9,r11,r9
8000506a:	ee 09 18 00 	cp.b	r9,r7
8000506e:	c1 90       	breq	800050a0 <fat_mount+0xc0>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
80005070:	11 c9       	ld.ub	r9,r8[0x4]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80005072:	fc 09 18 00 	cp.b	r9,lr
80005076:	5f 0c       	sreq	r12
80005078:	ec 09 18 00 	cp.b	r9,r6
8000507c:	5f 0b       	sreq	r11
8000507e:	f9 eb 10 0b 	or	r11,r12,r11
80005082:	ee 0b 18 00 	cp.b	r11,r7
80005086:	c1 41       	brne	800050ae <fat_mount+0xce>
80005088:	e6 09 18 00 	cp.b	r9,r3
8000508c:	c1 10       	breq	800050ae <fat_mount+0xce>
8000508e:	e4 09 18 00 	cp.b	r9,r2
80005092:	c0 e0       	breq	800050ae <fat_mount+0xce>
80005094:	e2 09 18 00 	cp.b	r9,r1
80005098:	c0 b0       	breq	800050ae <fat_mount+0xce>
8000509a:	e0 09 18 00 	cp.b	r9,r0
8000509e:	c0 80       	breq	800050ae <fat_mount+0xce>
         //** first sector then check a MBR structure
         // Search the first partition supported
#if (FS_MULTI_PARTITION == true)
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
800050a0:	2f fa       	sub	r10,-1
800050a2:	5c 5a       	castu.b	r10
800050a4:	2f 08       	sub	r8,-16
800050a6:	ec 0a 18 00 	cp.b	r10,r6
800050aa:	cd 71       	brne	80005058 <fat_mount+0x78>
800050ac:	c2 08       	rjmp	800050ec <fat_mount+0x10c>
#else
               break;
#endif
            }
         }
         if( u8_tmp != 4 )
800050ae:	ec 0a 18 00 	cp.b	r10,r6
800050b2:	c1 d0       	breq	800050ec <fat_mount+0x10c>
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
800050b4:	fe f3 02 10 	ld.w	r3,pc[528]
800050b8:	a5 6a       	lsl	r10,0x4
800050ba:	f4 ca fe 42 	sub	r10,r10,-446
800050be:	ea 0a 00 0a 	add	r10,r5,r10
800050c2:	f5 38 00 08 	ld.ub	r8,r10[8]
800050c6:	a6 b8       	st.b	r3[0x3],r8
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
800050c8:	f5 38 00 09 	ld.ub	r8,r10[9]
800050cc:	a6 a8       	st.b	r3[0x2],r8
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
800050ce:	f5 38 00 0a 	ld.ub	r8,r10[10]
800050d2:	a6 98       	st.b	r3[0x1],r8
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
800050d4:	f5 38 00 0b 	ld.ub	r8,r10[11]
800050d8:	a6 88       	st.b	r3[0x0],r8
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
800050da:	4f 88       	lddpc	r8,800052b8 <fat_mount+0x2d8>
800050dc:	11 8c       	ld.ub	r12,r8[0x0]
800050de:	f0 1f 00 7f 	mcall	800052d8 <fat_mount+0x2f8>
800050e2:	66 08       	ld.w	r8,r3[0x0]
800050e4:	f8 08 02 48 	mul	r8,r12,r8
800050e8:	87 08       	st.w	r3[0x0],r8
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
800050ea:	c9 4b       	rjmp	80005012 <fat_mount+0x32>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
800050ec:	4f 88       	lddpc	r8,800052cc <fat_mount+0x2ec>
800050ee:	11 89       	ld.ub	r9,r8[0x0]
800050f0:	3e b8       	mov	r8,-21
800050f2:	f0 09 18 00 	cp.b	r9,r8
800050f6:	c0 f1       	brne	80005114 <fat_mount+0x134>
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
800050f8:	4f 58       	lddpc	r8,800052cc <fat_mount+0x2ec>
800050fa:	11 a9       	ld.ub	r9,r8[0x2]
800050fc:	39 08       	mov	r8,-112
800050fe:	f0 09 18 00 	cp.b	r9,r8
80005102:	c0 91       	brne	80005114 <fat_mount+0x134>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
80005104:	4f 28       	lddpc	r8,800052cc <fat_mount+0x2ec>
80005106:	f1 38 00 15 	ld.ub	r8,r8[21]
8000510a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000510e:	e0 48 00 f0 	cp.w	r8,240
80005112:	c0 60       	breq	8000511e <fat_mount+0x13e>
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
80005114:	30 39       	mov	r9,3
80005116:	4f 08       	lddpc	r8,800052d4 <fat_mount+0x2f4>
80005118:	b0 89       	st.b	r8[0x0],r9
8000511a:	30 0c       	mov	r12,0
      return false;
8000511c:	cc b8       	rjmp	800052b2 <fat_mount+0x2d2>
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
8000511e:	30 49       	mov	r9,4
80005120:	4e d8       	lddpc	r8,800052d4 <fat_mount+0x2f4>
80005122:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
80005124:	4e aa       	lddpc	r10,800052cc <fat_mount+0x2ec>
80005126:	f5 39 00 0c 	ld.ub	r9,r10[12]
8000512a:	a1 99       	lsr	r9,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
8000512c:	f5 38 00 0d 	ld.ub	r8,r10[13]
80005130:	b3 38       	mul	r8,r9
80005132:	5c 58       	castu.b	r8
80005134:	4e 1b       	lddpc	r11,800052b8 <fat_mount+0x2d8>
80005136:	b6 98       	st.b	r11[0x1],r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
80005138:	30 0b       	mov	r11,0
8000513a:	50 1b       	stdsp	sp[0x4],r11
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
8000513c:	fa cb ff fc 	sub	r11,sp,-4
80005140:	fa c7 ff f9 	sub	r7,sp,-7
80005144:	f5 3c 00 16 	ld.ub	r12,r10[22]
80005148:	ae 8c       	st.b	r7[0x0],r12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
8000514a:	fa ce ff fa 	sub	lr,sp,-6
8000514e:	f5 3a 00 17 	ld.ub	r10,r10[23]
80005152:	bc 8a       	st.b	lr[0x0],r10
   if ( 0==u32_tmp )
80005154:	40 1a       	lddsp	r10,sp[0x4]
80005156:	58 0a       	cp.w	r10,0
80005158:	c0 e1       	brne	80005174 <fat_mount+0x194>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
8000515a:	4d da       	lddpc	r10,800052cc <fat_mount+0x2ec>
8000515c:	f5 3c 00 24 	ld.ub	r12,r10[36]
80005160:	ae 8c       	st.b	r7[0x0],r12
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
80005162:	f5 3c 00 25 	ld.ub	r12,r10[37]
80005166:	bc 8c       	st.b	lr[0x0],r12
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
80005168:	f5 3c 00 26 	ld.ub	r12,r10[38]
8000516c:	b6 9c       	st.b	r11[0x1],r12
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
8000516e:	f5 3a 00 27 	ld.ub	r10,r10[39]
80005172:	b6 8a       	st.b	r11[0x0],r10
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
80005174:	12 95       	mov	r5,r9
80005176:	40 1c       	lddsp	r12,sp[0x4]
80005178:	f2 0c 02 4c 	mul	r12,r9,r12
8000517c:	4c fa       	lddpc	r10,800052b8 <fat_mount+0x2d8>
8000517e:	95 1c       	st.w	r10[0x4],r12

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80005180:	4d 3a       	lddpc	r10,800052cc <fat_mount+0x2ec>
80005182:	f5 3a 00 13 	ld.ub	r10,r10[19]
80005186:	58 0a       	cp.w	r10,0
80005188:	c1 61       	brne	800051b4 <fat_mount+0x1d4>
8000518a:	4d 16       	lddpc	r6,800052cc <fat_mount+0x2ec>
8000518c:	ed 34 00 14 	ld.ub	r4,r6[20]
80005190:	30 06       	mov	r6,0
80005192:	ec 04 18 00 	cp.b	r4,r6
80005196:	c0 f1       	brne	800051b4 <fat_mount+0x1d4>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
80005198:	4c da       	lddpc	r10,800052cc <fat_mount+0x2ec>
8000519a:	f5 36 00 20 	ld.ub	r6,r10[32]
8000519e:	ae 86       	st.b	r7[0x0],r6
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
800051a0:	f5 37 00 21 	ld.ub	r7,r10[33]
800051a4:	bc 87       	st.b	lr[0x0],r7
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
800051a6:	f5 3e 00 22 	ld.ub	lr,r10[34]
800051aa:	b6 9e       	st.b	r11[0x1],lr
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
800051ac:	f5 3a 00 23 	ld.ub	r10,r10[35]
800051b0:	b6 8a       	st.b	r11[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
800051b2:	c0 98       	rjmp	800051c4 <fat_mount+0x1e4>
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
800051b4:	ae 8a       	st.b	r7[0x0],r10
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
800051b6:	4c 6a       	lddpc	r10,800052cc <fat_mount+0x2ec>
800051b8:	f5 3a 00 14 	ld.ub	r10,r10[20]
800051bc:	bc 8a       	st.b	lr[0x0],r10
      LSB2( u32_tmp ) = 0;
800051be:	30 0a       	mov	r10,0
800051c0:	b6 9a       	st.b	r11[0x1],r10
      LSB3( u32_tmp ) = 0;
800051c2:	b6 8a       	st.b	r11[0x0],r10
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
800051c4:	40 14       	lddsp	r4,sp[0x4]

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
800051c6:	4b da       	lddpc	r10,800052b8 <fat_mount+0x2d8>
800051c8:	f8 0b 15 01 	lsl	r11,r12,0x1
800051cc:	f5 5b 00 18 	st.h	r10[24],r11

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
800051d0:	fa c6 ff f6 	sub	r6,sp,-10
800051d4:	fa c7 ff f4 	sub	r7,sp,-12
800051d8:	4b db       	lddpc	r11,800052cc <fat_mount+0x2ec>
800051da:	f7 3e 00 11 	ld.ub	lr,r11[17]
800051de:	0e fe       	st.b	--r7,lr
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
800051e0:	f7 3e 00 12 	ld.ub	lr,r11[18]
800051e4:	ac 8e       	st.b	r6[0x0],lr
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
800051e6:	f2 03 15 04 	lsl	r3,r9,0x4
800051ea:	9a de       	ld.uh	lr,sp[0xa]
800051ec:	e6 0e 00 0e 	add	lr,r3,lr
800051f0:	a5 7e       	lsl	lr,0x5
800051f2:	20 1e       	sub	lr,1
800051f4:	f2 03 15 09 	lsl	r3,r9,0x9
800051f8:	fc 03 0c 02 	divs	r2,lr,r3
800051fc:	e4 09 02 4e 	mul	lr,r2,r9
80005200:	f5 5e 00 1a 	st.h	r10[26],lr

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
80005204:	f7 33 00 0e 	ld.ub	r3,r11[14]
80005208:	ae 83       	st.b	r7[0x0],r3
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
8000520a:	f7 37 00 0f 	ld.ub	r7,r11[15]
8000520e:	ac 87       	st.b	r6[0x0],r7
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
80005210:	9a 57       	ld.sh	r7,sp[0xa]
80005212:	f7 3b 00 30 	ld.ub	r11,r11[48]
80005216:	0e 96       	mov	r6,r7
80005218:	ee 0b 01 0b 	sub	r11,r7,r11
8000521c:	b3 3b       	mul	r11,r9
8000521e:	b4 4b       	st.h	r10[0x8],r11
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
80005220:	ee 09 02 49 	mul	r9,r7,r9
80005224:	5c 79       	castu.h	r9
80005226:	4a 8b       	lddpc	r11,800052c4 <fat_mount+0x2e4>
80005228:	76 0b       	ld.w	r11,r11[0x0]
8000522a:	f2 0b 00 0b 	add	r11,r9,r11
8000522e:	95 4b       	st.w	r10[0x10],r11

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
80005230:	5c 7e       	castu.h	lr
80005232:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
80005236:	95 5c       	st.w	r10[0x14],r12
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
80005238:	58 08       	cp.w	r8,0
8000523a:	c3 b0       	breq	800052b0 <fat_mount+0x2d0>

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
8000523c:	a9 35       	mul	r5,r4
8000523e:	ea 09 01 09 	sub	r9,r5,r9
80005242:	18 19       	sub	r9,r12
80005244:	50 19       	stdsp	sp[0x4],r9

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005246:	30 1a       	mov	r10,1
80005248:	f4 08 18 00 	cp.b	r8,r10
8000524c:	c0 70       	breq	8000525a <fat_mount+0x27a>
   {
     u32_tmp  >>= 1;   // This computation round down
8000524e:	a1 99       	lsr	r9,0x1

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005250:	a1 98       	lsr	r8,0x1
80005252:	f4 08 18 00 	cp.b	r8,r10
80005256:	cf c1       	brne	8000524e <fat_mount+0x26e>
80005258:	50 19       	stdsp	sp[0x4],r9
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
8000525a:	40 18       	lddsp	r8,sp[0x4]
8000525c:	f0 ca ff fe 	sub	r10,r8,-2
80005260:	49 69       	lddpc	r9,800052b8 <fat_mount+0x2d8>
80005262:	93 3a       	st.w	r9[0xc],r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
80005264:	e0 48 0f f4 	cp.w	r8,4084
80005268:	e0 8b 00 07 	brhi	80005276 <fat_mount+0x296>
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
8000526c:	30 19       	mov	r9,1
8000526e:	49 58       	lddpc	r8,800052c0 <fat_mount+0x2e0>
80005270:	b0 89       	st.b	r8[0x0],r9
80005272:	30 1c       	mov	r12,1
80005274:	c1 f8       	rjmp	800052b2 <fat_mount+0x2d2>
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
80005276:	e0 48 ff f4 	cp.w	r8,65524
8000527a:	e0 8b 00 07 	brhi	80005288 <fat_mount+0x2a8>
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
8000527e:	30 29       	mov	r9,2
80005280:	49 08       	lddpc	r8,800052c0 <fat_mount+0x2e0>
80005282:	b0 89       	st.b	r8[0x0],r9
80005284:	30 1c       	mov	r12,1
80005286:	c1 68       	rjmp	800052b2 <fat_mount+0x2d2>
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
80005288:	30 39       	mov	r9,3
8000528a:	48 e8       	lddpc	r8,800052c0 <fat_mount+0x2e0>
8000528c:	b0 89       	st.b	r8[0x0],r9
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
8000528e:	48 b8       	lddpc	r8,800052b8 <fat_mount+0x2d8>
80005290:	2e 88       	sub	r8,-24
80005292:	48 f9       	lddpc	r9,800052cc <fat_mount+0x2ec>
80005294:	f3 3a 00 2c 	ld.ub	r10,r9[44]
80005298:	b0 ba       	st.b	r8[0x3],r10
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
8000529a:	f3 3a 00 2d 	ld.ub	r10,r9[45]
8000529e:	b0 aa       	st.b	r8[0x2],r10
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
800052a0:	f3 3a 00 2e 	ld.ub	r10,r9[46]
800052a4:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
800052a6:	f3 39 00 2f 	ld.ub	r9,r9[47]
800052aa:	b0 89       	st.b	r8[0x0],r9
800052ac:	30 1c       	mov	r12,1
800052ae:	c0 28       	rjmp	800052b2 <fat_mount+0x2d2>
800052b0:	30 0c       	mov	r12,0
   }
   }

   return true;
}
800052b2:	2f dd       	sub	sp,-12
800052b4:	d8 32       	popm	r0-r7,pc
800052b6:	00 00       	add	r0,r0
800052b8:	00 00       	add	r0,r0
800052ba:	7c 24       	ld.w	r4,lr[0x8]
800052bc:	80 00       	ld.sh	r0,r0[0x0]
800052be:	3f 8c       	mov	r12,-8
800052c0:	00 00       	add	r0,r0
800052c2:	7c 70       	ld.w	r0,lr[0x1c]
800052c4:	00 00       	add	r0,r0
800052c6:	79 e0       	ld.w	r0,r12[0x78]
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	4d 10       	lddpc	r0,8000540c <file_open+0x64>
800052cc:	00 00       	add	r0,r0
800052ce:	7a 24       	ld.w	r4,sp[0x8]
800052d0:	80 00       	ld.sh	r0,r0[0x0]
800052d2:	45 80       	lddsp	r0,sp[0x160]
800052d4:	00 00       	add	r0,r0
800052d6:	7c 74       	ld.w	r4,lr[0x1c]
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	5c 6c       	casts.b	r12

800052dc <file_eof>:
//! @return    1     the position is at the end of file
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
800052dc:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
800052de:	f0 1f 00 07 	mcall	800052f8 <file_eof+0x1c>
800052e2:	c0 41       	brne	800052ea <file_eof+0xe>
800052e4:	e0 6c 00 ff 	mov	r12,255
800052e8:	d8 02       	popm	pc
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
800052ea:	48 58       	lddpc	r8,800052fc <file_eof+0x20>
800052ec:	70 29       	ld.w	r9,r8[0x8]
800052ee:	70 38       	ld.w	r8,r8[0xc]
800052f0:	10 39       	cp.w	r9,r8
800052f2:	5f 8c       	srls	r12
}
800052f4:	d8 02       	popm	pc
800052f6:	00 00       	add	r0,r0
800052f8:	80 00       	ld.sh	r0,r0[0x0]
800052fa:	4e 54       	lddpc	r4,8000548c <nav_file_name+0x10>
800052fc:	00 00       	add	r0,r0
800052fe:	79 e4       	ld.w	r4,r12[0x78]

80005300 <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
80005300:	d4 01       	pushm	lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
80005302:	f0 1f 00 0a 	mcall	80005328 <file_close+0x28>
80005306:	c1 00       	breq	80005326 <file_close+0x26>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
80005308:	48 98       	lddpc	r8,8000532c <file_close+0x2c>
8000530a:	11 88       	ld.ub	r8,r8[0x0]
8000530c:	e2 18 00 02 	andl	r8,0x2,COH
80005310:	c0 80       	breq	80005320 <file_close+0x20>
      {
         // Write file information
         if( !fat_read_dir() )
80005312:	f0 1f 00 08 	mcall	80005330 <file_close+0x30>
80005316:	c0 80       	breq	80005326 <file_close+0x26>
            return;           // error
         fat_write_entry_file();
80005318:	f0 1f 00 07 	mcall	80005334 <file_close+0x34>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
8000531c:	f0 1f 00 07 	mcall	80005338 <file_close+0x38>
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
80005320:	30 09       	mov	r9,0
80005322:	48 38       	lddpc	r8,8000532c <file_close+0x2c>
80005324:	b0 89       	st.b	r8[0x0],r9
80005326:	d8 02       	popm	pc
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	4e 54       	lddpc	r4,800054bc <nav_file_name+0x40>
8000532c:	00 00       	add	r0,r0
8000532e:	79 e4       	ld.w	r4,r12[0x78]
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	4b b0       	lddpc	r0,8000541c <file_open+0x74>
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	43 70       	lddsp	r0,sp[0xdc]
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	45 14       	lddsp	r4,sp[0x144]

8000533c <file_getc>:
//!
//! @return    The byte read
//! @return    EOF, in case of error or end of file
//!
uint16_t   file_getc( void )
{
8000533c:	d4 01       	pushm	lr
   uint16_t   u16_byte;

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
8000533e:	49 78       	lddpc	r8,80005398 <file_getc+0x5c>
80005340:	11 88       	ld.ub	r8,r8[0x0]
80005342:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005346:	c0 51       	brne	80005350 <file_getc+0x14>
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
80005348:	31 e9       	mov	r9,30
8000534a:	49 58       	lddpc	r8,8000539c <file_getc+0x60>
8000534c:	b0 89       	st.b	r8[0x0],r9
8000534e:	dc 0a       	popm	pc,r12=-1
         break;
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
80005350:	49 28       	lddpc	r8,80005398 <file_getc+0x5c>
80005352:	70 29       	ld.w	r9,r8[0x8]
80005354:	70 38       	ld.w	r8,r8[0xc]
80005356:	10 39       	cp.w	r9,r8
80005358:	e0 8b 00 06 	brhi	80005364 <file_getc+0x28>
      {
         fs_g_status = FS_ERR_EOF;
8000535c:	32 09       	mov	r9,32
8000535e:	49 08       	lddpc	r8,8000539c <file_getc+0x60>
80005360:	b0 89       	st.b	r8[0x0],r9
80005362:	dc 0a       	popm	pc,r12=-1
         break;
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
80005364:	30 2c       	mov	r12,2
80005366:	f0 1f 00 0f 	mcall	800053a0 <file_getc+0x64>
8000536a:	c0 c1       	brne	80005382 <file_getc+0x46>
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
8000536c:	48 c8       	lddpc	r8,8000539c <file_getc+0x60>
8000536e:	11 89       	ld.ub	r9,r8[0x0]
80005370:	31 a8       	mov	r8,26
80005372:	f0 09 18 00 	cp.b	r9,r8
80005376:	c0 20       	breq	8000537a <file_getc+0x3e>
80005378:	dc 0a       	popm	pc,r12=-1
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
8000537a:	32 09       	mov	r9,32
8000537c:	48 88       	lddpc	r8,8000539c <file_getc+0x60>
8000537e:	b0 89       	st.b	r8[0x0],r9
80005380:	dc 0a       	popm	pc,r12=-1
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
80005382:	48 68       	lddpc	r8,80005398 <file_getc+0x5c>
80005384:	70 39       	ld.w	r9,r8[0xc]
80005386:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
8000538a:	48 7b       	lddpc	r11,800053a4 <file_getc+0x68>
8000538c:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
      fs_g_nav_entry.u32_pos_in_file++;
80005390:	2f f9       	sub	r9,-1
80005392:	91 39       	st.w	r8[0xc],r9
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
80005394:	d8 02       	popm	pc
80005396:	00 00       	add	r0,r0
80005398:	00 00       	add	r0,r0
8000539a:	79 e4       	ld.w	r4,r12[0x78]
8000539c:	00 00       	add	r0,r0
8000539e:	7c 74       	ld.w	r4,lr[0x1c]
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	4c 34       	lddpc	r4,800054ac <nav_file_name+0x30>
800053a4:	00 00       	add	r0,r0
800053a6:	7a 24       	ld.w	r4,sp[0x8]

800053a8 <file_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
800053a8:	eb cd 40 c0 	pushm	r6-r7,lr
800053ac:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_noopen())
800053ae:	f0 1f 00 20 	mcall	8000542c <file_open+0x84>
800053b2:	c3 a0       	breq	80005426 <file_open+0x7e>
      return false;

   if( !fat_check_is_file())
800053b4:	f0 1f 00 1f 	mcall	80005430 <file_open+0x88>
800053b8:	c3 70       	breq	80005426 <file_open+0x7e>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
800053ba:	0e 96       	mov	r6,r7
800053bc:	0e 98       	mov	r8,r7
800053be:	e2 18 00 02 	andl	r8,0x2,COH
800053c2:	c1 90       	breq	800053f4 <file_open+0x4c>
   {
      if( !fat_check_nav_access_file( true ) )
800053c4:	30 1c       	mov	r12,1
800053c6:	f0 1f 00 1c 	mcall	80005434 <file_open+0x8c>
800053ca:	c2 e0       	breq	80005426 <file_open+0x7e>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
800053cc:	49 b8       	lddpc	r8,80005438 <file_open+0x90>
800053ce:	11 a8       	ld.ub	r8,r8[0x2]
800053d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800053d4:	c0 60       	breq	800053e0 <file_open+0x38>
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
800053d6:	31 59       	mov	r9,21
800053d8:	49 98       	lddpc	r8,8000543c <file_open+0x94>
800053da:	b0 89       	st.b	r8[0x0],r9
800053dc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
800053e0:	49 88       	lddpc	r8,80005440 <file_open+0x98>
800053e2:	11 8c       	ld.ub	r12,r8[0x0]
800053e4:	f0 1f 00 18 	mcall	80005444 <file_open+0x9c>
800053e8:	c0 a0       	breq	800053fc <file_open+0x54>
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
800053ea:	31 49       	mov	r9,20
800053ec:	49 48       	lddpc	r8,8000543c <file_open+0x94>
800053ee:	b0 89       	st.b	r8[0x0],r9
800053f0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
800053f4:	30 0c       	mov	r12,0
800053f6:	f0 1f 00 10 	mcall	80005434 <file_open+0x8c>
800053fa:	c1 60       	breq	80005426 <file_open+0x7e>
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
800053fc:	0c 98       	mov	r8,r6
800053fe:	e2 18 00 04 	andl	r8,0x4,COH
80005402:	c0 40       	breq	8000540a <file_open+0x62>
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
80005404:	30 09       	mov	r9,0
80005406:	48 d8       	lddpc	r8,80005438 <file_open+0x90>
80005408:	91 29       	st.w	r8[0x8],r9
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
8000540a:	e2 16 00 08 	andl	r6,0x8,COH
8000540e:	c0 50       	breq	80005418 <file_open+0x70>
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
80005410:	30 09       	mov	r9,0
80005412:	48 a8       	lddpc	r8,80005438 <file_open+0x90>
80005414:	91 39       	st.w	r8[0xc],r9
80005416:	c0 48       	rjmp	8000541e <file_open+0x76>
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
80005418:	48 88       	lddpc	r8,80005438 <file_open+0x90>
8000541a:	70 29       	ld.w	r9,r8[0x8]
8000541c:	91 39       	st.w	r8[0xc],r9
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
8000541e:	48 78       	lddpc	r8,80005438 <file_open+0x90>
80005420:	b0 87       	st.b	r8[0x0],r7
80005422:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   return true;
80005426:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000542a:	00 00       	add	r0,r0
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	4e 78       	lddpc	r8,800055c8 <nav_filelist_set+0x68>
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	3c bc       	mov	r12,-53
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	43 c0       	lddsp	r0,sp[0xf0]
80005438:	00 00       	add	r0,r0
8000543a:	79 e4       	ld.w	r4,r12[0x78]
8000543c:	00 00       	add	r0,r0
8000543e:	7c 74       	ld.w	r4,lr[0x1c]
80005440:	00 00       	add	r0,r0
80005442:	7c 24       	ld.w	r4,lr[0x8]
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	5c 28       	cpc	r8

80005448 <nav_drive_get>:
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
80005448:	48 28       	lddpc	r8,80005450 <nav_drive_get+0x8>
8000544a:	11 8c       	ld.ub	r12,r8[0x0]
8000544c:	5e fc       	retal	r12
8000544e:	00 00       	add	r0,r0
80005450:	00 00       	add	r0,r0
80005452:	7c 24       	ld.w	r4,lr[0x8]

80005454 <nav_drive_getname>:
//! @return    'A','B',...
//! @return    'X', in case of no drive selected
//!
uint8_t    nav_drive_getname( void )
{
   if(0xFF == fs_g_nav.u8_lun)
80005454:	48 68       	lddpc	r8,8000546c <nav_drive_getname+0x18>
80005456:	11 8c       	ld.ub	r12,r8[0x0]
80005458:	3f f8       	mov	r8,-1
8000545a:	f0 0c 18 00 	cp.b	r12,r8
8000545e:	c0 31       	brne	80005464 <nav_drive_getname+0x10>
80005460:	35 8c       	mov	r12,88
80005462:	5e fc       	retal	r12
      return 'X';
#if (FS_MULTI_PARTITION  ==  true)
   return ('A' + (fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return ('A' + fs_g_nav.u8_lun);
80005464:	2b fc       	sub	r12,-65
80005466:	5c 5c       	castu.b	r12
#endif
}
80005468:	5e fc       	retal	r12
8000546a:	00 00       	add	r0,r0
8000546c:	00 00       	add	r0,r0
8000546e:	7c 24       	ld.w	r4,lr[0x8]

80005470 <nav_filelist_get>:
//! @return    FS_NO_SEL, in case of no file selected
//!
uint16_t   nav_filelist_get( void )
{
   return fs_g_nav.u16_pos_sel_file;
}
80005470:	48 28       	lddpc	r8,80005478 <nav_filelist_get+0x8>
80005472:	f1 0c 00 24 	ld.sh	r12,r8[36]
80005476:	5e fc       	retal	r12
80005478:	00 00       	add	r0,r0
8000547a:	7c 24       	ld.w	r4,lr[0x8]

8000547c <nav_file_name>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_file_name( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case  )
{
8000547c:	d4 31       	pushm	r0-r7,lr
8000547e:	20 1d       	sub	sp,4
80005480:	18 95       	mov	r5,r12
80005482:	16 96       	mov	r6,r11
80005484:	14 97       	mov	r7,r10
80005486:	12 93       	mov	r3,r9
   _MEM_TYPE_SLOW_   uint16_t u16_lgt;   // Only used if LENGTH string mode enabled
   uint16_t  u16_ptr_save_entry;
   bool  b_readshortname = false;

   if ( !fat_check_mount_select())
80005488:	f0 1f 00 2f 	mcall	80005544 <nav_file_name+0xc8>
8000548c:	c5 80       	breq	8000553c <nav_file_name+0xc0>
      return false;

   // Check if the string size is not 0
   if( (FS_NAME_GET == b_mode)
8000548e:	58 07       	cp.w	r7,0
80005490:	c0 50       	breq	8000549a <nav_file_name+0x1e>
80005492:	58 06       	cp.w	r6,0
80005494:	c0 31       	brne	8000549a <nav_file_name+0x1e>
80005496:	30 1c       	mov	r12,1
80005498:	c5 38       	rjmp	8000553e <nav_file_name+0xc2>
   {
      return true;
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
8000549a:	4a c8       	lddpc	r8,80005548 <nav_file_name+0xcc>
8000549c:	90 14       	ld.sh	r4,r8[0x2]
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000549e:	58 04       	cp.w	r4,0
800054a0:	c0 31       	brne	800054a6 <nav_file_name+0x2a>
800054a2:	30 10       	mov	r0,1
800054a4:	c0 68       	rjmp	800054b0 <nav_file_name+0x34>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
800054a6:	08 99       	mov	r9,r4
800054a8:	20 19       	sub	r9,1
800054aa:	4a 88       	lddpc	r8,80005548 <nav_file_name+0xcc>
800054ac:	b0 19       	st.h	r8[0x2],r9
800054ae:	30 00       	mov	r0,0
800054b0:	30 09       	mov	r9,0
800054b2:	50 09       	stdsp	sp[0x0],r9
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
800054b4:	31 01       	mov	r1,16
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
800054b6:	4a 52       	lddpc	r2,80005548 <nav_file_name+0xcc>
800054b8:	c0 28       	rjmp	800054bc <nav_file_name+0x40>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
800054ba:	30 10       	mov	r0,1

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
800054bc:	f0 1f 00 24 	mcall	8000554c <nav_file_name+0xd0>
800054c0:	c3 e0       	breq	8000553c <nav_file_name+0xc0>
         break; // error

      if ( b_readshortname )
800054c2:	58 00       	cp.w	r0,0
800054c4:	c0 70       	breq	800054d2 <nav_file_name+0x56>
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
800054c6:	0e 9a       	mov	r10,r7
800054c8:	0c 9b       	mov	r11,r6
800054ca:	0a 9c       	mov	r12,r5
800054cc:	f0 1f 00 21 	mcall	80005550 <nav_file_name+0xd4>
800054d0:	c3 78       	rjmp	8000553e <nav_file_name+0xc2>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
800054d2:	06 99       	mov	r9,r3
800054d4:	0e 9a       	mov	r10,r7
800054d6:	0c 9b       	mov	r11,r6
800054d8:	0a 9c       	mov	r12,r5
800054da:	f0 1f 00 1f 	mcall	80005554 <nav_file_name+0xd8>
800054de:	c1 20       	breq	80005502 <nav_file_name+0x86>
      {
         if( g_b_string_length )
800054e0:	49 e8       	lddpc	r8,80005558 <nav_file_name+0xdc>
800054e2:	11 89       	ld.ub	r9,r8[0x0]
800054e4:	30 08       	mov	r8,0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
800054e6:	f0 09 18 00 	cp.b	r9,r8
800054ea:	eb f8 12 00 	ld.shne	r8,r5[0x0]
800054ee:	fb f9 10 00 	ld.wne	r9,sp[0x0]
800054f2:	f1 d9 e1 08 	addne	r8,r8,r9
800054f6:	eb f8 1c 00 	st.hne	r5[0x0],r8
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
800054fa:	49 48       	lddpc	r8,80005548 <nav_file_name+0xcc>
800054fc:	b0 14       	st.h	r8[0x2],r4
800054fe:	30 1c       	mov	r12,1
         return true;
80005500:	c1 f8       	rjmp	8000553e <nav_file_name+0xc2>
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
80005502:	49 79       	lddpc	r9,8000555c <nav_file_name+0xe0>
80005504:	13 88       	ld.ub	r8,r9[0x0]
80005506:	e2 08 18 00 	cp.b	r8,r1
8000550a:	c0 70       	breq	80005518 <nav_file_name+0x9c>
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
8000550c:	a4 14       	st.h	r2[0x2],r4

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
8000550e:	30 b9       	mov	r9,11
80005510:	f2 08 18 00 	cp.b	r8,r9
80005514:	c1 41       	brne	8000553c <nav_file_name+0xc0>
80005516:	cd 2b       	rjmp	800054ba <nav_file_name+0x3e>
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
80005518:	49 09       	lddpc	r9,80005558 <nav_file_name+0xdc>
8000551a:	13 88       	ld.ub	r8,r9[0x0]
8000551c:	30 09       	mov	r9,0
8000551e:	f2 08 18 00 	cp.b	r8,r9
80005522:	c0 60       	breq	8000552e <nav_file_name+0xb2>
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
80005524:	40 08       	lddsp	r8,sp[0x0]
80005526:	2f 38       	sub	r8,-13
80005528:	5c 88       	casts.h	r8
8000552a:	50 08       	stdsp	sp[0x0],r8
8000552c:	c0 48       	rjmp	80005534 <nav_file_name+0xb8>
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
8000552e:	2f 35       	sub	r5,-13
         u8_size_max -= FS_SIZE_LFN_ENTRY;
80005530:	20 d6       	sub	r6,13
80005532:	5c 56       	castu.b	r6
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80005534:	84 18       	ld.sh	r8,r2[0x2]
80005536:	20 18       	sub	r8,1
80005538:	a4 18       	st.h	r2[0x2],r8
8000553a:	cc 1b       	rjmp	800054bc <nav_file_name+0x40>
8000553c:	30 0c       	mov	r12,0

   }  // end of loop while(1)
   return false;
}
8000553e:	2f fd       	sub	sp,-4
80005540:	d8 32       	popm	r0-r7,pc
80005542:	00 00       	add	r0,r0
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	4e 3c       	lddpc	r12,800056d0 <nav_filelist_reset+0x8>
80005548:	00 00       	add	r0,r0
8000554a:	7c 70       	ld.w	r0,lr[0x1c]
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	4b b0       	lddpc	r0,80005638 <nav_filelist_set+0xd8>
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	41 9c       	lddsp	r12,sp[0x64]
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	40 08       	lddsp	r8,sp[0x0]
80005558:	00 00       	add	r0,r0
8000555a:	7c 75       	ld.w	r5,lr[0x1c]
8000555c:	00 00       	add	r0,r0
8000555e:	7c 74       	ld.w	r4,lr[0x1c]

80005560 <nav_filelist_set>:
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
80005560:	d4 31       	pushm	r0-r7,lr
80005562:	20 4d       	sub	sp,16
80005564:	50 0c       	stdsp	sp[0x0],r12
80005566:	16 92       	mov	r2,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
80005568:	f0 1f 00 51 	mcall	800056ac <nav_filelist_set+0x14c>
8000556c:	e0 80 00 9e 	breq	800056a8 <nav_filelist_set+0x148>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
80005570:	4d 08       	lddpc	r8,800056b0 <nav_filelist_set+0x150>
80005572:	90 18       	ld.sh	r8,r8[0x2]
80005574:	50 28       	stdsp	sp[0x8],r8
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
80005576:	4d 08       	lddpc	r8,800056b4 <nav_filelist_set+0x154>
80005578:	f1 0a 00 24 	ld.sh	r10,r8[36]
8000557c:	50 1a       	stdsp	sp[0x4],r10
   b_save_entry_type       = fs_g_nav.b_mode_nav;
8000557e:	f1 38 00 2c 	ld.ub	r8,r8[44]
80005582:	50 38       	stdsp	sp[0xc],r8
80005584:	30 03       	mov	r3,0
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
80005586:	4c b7       	lddpc	r7,800056b0 <nav_filelist_set+0x150>
80005588:	3f f0       	mov	r0,-1
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000558a:	4c b6       	lddpc	r6,800056b4 <nav_filelist_set+0x154>
8000558c:	30 04       	mov	r4,0
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000558e:	3f e1       	mov	r1,-2
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
80005590:	4c a5       	lddpc	r5,800056b8 <nav_filelist_set+0x158>
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
80005592:	58 02       	cp.w	r2,0
80005594:	c0 31       	brne	8000559a <nav_filelist_set+0x3a>
80005596:	58 03       	cp.w	r3,0
80005598:	c0 c0       	breq	800055b0 <nav_filelist_set+0x50>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000559a:	8e 18       	ld.sh	r8,r7[0x2]
8000559c:	e2 08 19 00 	cp.h	r8,r1
800055a0:	c0 51       	brne	800055aa <nav_filelist_set+0x4a>
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
800055a2:	30 89       	mov	r9,8
800055a4:	4c 58       	lddpc	r8,800056b8 <nav_filelist_set+0x158>
800055a6:	b0 89       	st.b	r8[0x0],r9
            break;
800055a8:	c7 38       	rjmp	8000568e <nav_filelist_set+0x12e>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
800055aa:	2f f8       	sub	r8,-1
800055ac:	ae 18       	st.h	r7[0x2],r8
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
800055ae:	c1 d8       	rjmp	800055e8 <nav_filelist_set+0x88>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
800055b0:	8e 18       	ld.sh	r8,r7[0x2]
800055b2:	e0 08 19 00 	cp.h	r8,r0
800055b6:	c0 51       	brne	800055c0 <nav_filelist_set+0x60>
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
800055b8:	30 99       	mov	r9,9
800055ba:	4c 08       	lddpc	r8,800056b8 <nav_filelist_set+0x158>
800055bc:	b0 89       	st.b	r8[0x0],r9
            break;
800055be:	c6 88       	rjmp	8000568e <nav_filelist_set+0x12e>
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
800055c0:	58 08       	cp.w	r8,0
800055c2:	c1 11       	brne	800055e4 <nav_filelist_set+0x84>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
800055c4:	ed 38 00 2c 	ld.ub	r8,r6[44]
800055c8:	e8 08 18 00 	cp.b	r8,r4
800055cc:	c0 80       	breq	800055dc <nav_filelist_set+0x7c>
800055ce:	ed 38 00 2d 	ld.ub	r8,r6[45]
800055d2:	e8 08 18 00 	cp.b	r8,r4
800055d6:	c0 31       	brne	800055dc <nav_filelist_set+0x7c>
800055d8:	30 13       	mov	r3,1
800055da:	c0 78       	rjmp	800055e8 <nav_filelist_set+0x88>
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
800055dc:	30 99       	mov	r9,9
800055de:	4b 78       	lddpc	r8,800056b8 <nav_filelist_set+0x158>
800055e0:	b0 89       	st.b	r8[0x0],r9
               break;
800055e2:	c5 68       	rjmp	8000568e <nav_filelist_set+0x12e>
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
800055e4:	20 18       	sub	r8,1
800055e6:	ae 18       	st.h	r7[0x2],r8
         }
      }

      if( !fat_read_dir())
800055e8:	f0 1f 00 35 	mcall	800056bc <nav_filelist_set+0x15c>
800055ec:	c0 71       	brne	800055fa <nav_filelist_set+0x9a>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
800055ee:	0b 89       	ld.ub	r9,r5[0x0]
800055f0:	31 a8       	mov	r8,26
800055f2:	f0 09 18 00 	cp.b	r9,r8
800055f6:	c3 20       	breq	8000565a <nav_filelist_set+0xfa>
800055f8:	c4 b8       	rjmp	8000568e <nav_filelist_set+0x12e>
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
800055fa:	ed 38 00 2c 	ld.ub	r8,r6[44]
800055fe:	e8 08 18 00 	cp.b	r8,r4
80005602:	5f 1c       	srne	r12
80005604:	f0 1f 00 2f 	mcall	800056c0 <nav_filelist_set+0x160>
80005608:	c1 c0       	breq	80005640 <nav_filelist_set+0xe0>
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
8000560a:	58 03       	cp.w	r3,0
8000560c:	cc 31       	brne	80005592 <nav_filelist_set+0x32>
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
8000560e:	58 02       	cp.w	r2,0
80005610:	ed f8 12 12 	ld.shne	r8,r6[0x24]
80005614:	f7 b8 01 ff 	subne	r8,-1
80005618:	ed f8 1c 12 	st.hne	r6[0x24],r8
           else
              fs_g_nav.u16_pos_sel_file--;
8000561c:	ed f8 02 12 	ld.sheq	r8,r6[0x24]
80005620:	f7 b8 00 01 	subeq	r8,1
80005624:	ed f8 0c 12 	st.heq	r6[0x24],r8

           if (0 == u16_nb)
80005628:	40 09       	lddsp	r9,sp[0x0]
8000562a:	58 09       	cp.w	r9,0
8000562c:	c0 51       	brne	80005636 <nav_filelist_set+0xd6>
           {
              // It is the end of move then update file information
              fat_get_entry_info();
8000562e:	f0 1f 00 26 	mcall	800056c4 <nav_filelist_set+0x164>
80005632:	30 1c       	mov	r12,1
              return true;         // NB FILE FIND
80005634:	c3 a8       	rjmp	800056a8 <nav_filelist_set+0x148>
           }
           u16_nb--;
80005636:	40 08       	lddsp	r8,sp[0x0]
80005638:	20 18       	sub	r8,1
8000563a:	5c 88       	casts.h	r8
8000563c:	50 08       	stdsp	sp[0x0],r8
           continue;
8000563e:	ca ab       	rjmp	80005592 <nav_filelist_set+0x32>
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
80005640:	0b 88       	ld.ub	r8,r5[0x0]
80005642:	30 a9       	mov	r9,10
80005644:	f2 08 18 00 	cp.b	r8,r9
80005648:	5f 09       	sreq	r9
8000564a:	31 aa       	mov	r10,26
8000564c:	f4 08 18 00 	cp.b	r8,r10
80005650:	5f 08       	sreq	r8
80005652:	10 49       	or	r9,r8
80005654:	e8 09 18 00 	cp.b	r9,r4
80005658:	c9 d0       	breq	80005592 <nav_filelist_set+0x32>
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
8000565a:	58 03       	cp.w	r3,0
8000565c:	c0 50       	breq	80005666 <nav_filelist_set+0x106>
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
8000565e:	ed 64 00 2c 	st.b	r6[44],r4
80005662:	30 03       	mov	r3,0
            continue;
80005664:	c9 7b       	rjmp	80005592 <nav_filelist_set+0x32>
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
80005666:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000566a:	30 1a       	mov	r10,1
8000566c:	f4 08 18 00 	cp.b	r8,r10
80005670:	c0 60       	breq	8000567c <nav_filelist_set+0x11c>
80005672:	ed 38 00 2d 	ld.ub	r8,r6[45]
80005676:	e8 08 18 00 	cp.b	r8,r4
8000567a:	c0 50       	breq	80005684 <nav_filelist_set+0x124>
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
8000567c:	30 99       	mov	r9,9
8000567e:	48 f8       	lddpc	r8,800056b8 <nav_filelist_set+0x158>
80005680:	b0 89       	st.b	r8[0x0],r9
            break;                        // end of search
80005682:	c0 68       	rjmp	8000568e <nav_filelist_set+0x12e>
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
80005684:	ae 10       	st.h	r7[0x2],r0
            fs_g_nav.b_mode_nav = FS_FILE;
80005686:	30 19       	mov	r9,1
80005688:	ed 69 00 2c 	st.b	r6[44],r9
8000568c:	c8 3b       	rjmp	80005592 <nav_filelist_set+0x32>
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
8000568e:	48 a8       	lddpc	r8,800056b4 <nav_filelist_set+0x154>
80005690:	40 3a       	lddsp	r10,sp[0xc]
80005692:	58 0a       	cp.w	r10,0
80005694:	5f 19       	srne	r9
80005696:	f1 69 00 2c 	st.b	r8[44],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
8000569a:	48 69       	lddpc	r9,800056b0 <nav_filelist_set+0x150>
8000569c:	40 2a       	lddsp	r10,sp[0x8]
8000569e:	b2 1a       	st.h	r9[0x2],r10
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
800056a0:	40 19       	lddsp	r9,sp[0x4]
800056a2:	f1 59 00 24 	st.h	r8[36],r9
800056a6:	30 0c       	mov	r12,0
   return false;
}
800056a8:	2f cd       	sub	sp,-16
800056aa:	d8 32       	popm	r0-r7,pc
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	4e 9c       	lddpc	r12,80005850 <nav_dir_name+0xd0>
800056b0:	00 00       	add	r0,r0
800056b2:	7c 70       	ld.w	r0,lr[0x1c]
800056b4:	00 00       	add	r0,r0
800056b6:	7c 24       	ld.w	r4,lr[0x8]
800056b8:	00 00       	add	r0,r0
800056ba:	7c 74       	ld.w	r4,lr[0x1c]
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	4b b0       	lddpc	r0,800057a8 <nav_dir_name+0x28>
800056c0:	80 00       	ld.sh	r0,r0[0x0]
800056c2:	42 ec       	lddsp	r12,sp[0xb8]
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	42 a4       	lddsp	r4,sp[0xa8]

800056c8 <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
800056c8:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
800056ca:	f0 1f 00 04 	mcall	800056d8 <nav_filelist_reset+0x10>
800056ce:	c0 40       	breq	800056d6 <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
800056d0:	f0 1f 00 03 	mcall	800056dc <nav_filelist_reset+0x14>
800056d4:	30 1c       	mov	r12,1
   return true;
}
800056d6:	d8 02       	popm	pc
800056d8:	80 00       	ld.sh	r0,r0[0x0]
800056da:	4e 9c       	lddpc	r12,8000587c <nav_dir_name+0xfc>
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	3f 8c       	mov	r12,-8

800056e0 <nav_dir_gotoparent>:
//! After, the file list changes and contains the files and directories of the new directory.
//! By default, the file selected in file list is the previous (children) directory.
//! @endverbatim
//!
bool  nav_dir_gotoparent( void )
{
800056e0:	d4 21       	pushm	r4-r7,lr
   uint32_t u32_cluster_old_dir;

   if (!fat_check_mount_noopen())
800056e2:	f0 1f 00 1f 	mcall	8000575c <nav_dir_gotoparent+0x7c>
800056e6:	c3 80       	breq	80005756 <nav_dir_gotoparent+0x76>
      return false;

   if (0 == fs_g_nav.u32_cluster_sel_dir)
800056e8:	49 e8       	lddpc	r8,80005760 <nav_dir_gotoparent+0x80>
800056ea:	70 88       	ld.w	r8,r8[0x20]
800056ec:	58 08       	cp.w	r8,0
800056ee:	c0 51       	brne	800056f8 <nav_dir_gotoparent+0x18>
   {
      fs_g_status = FS_ERR_IS_ROOT;        // There aren't parent
800056f0:	31 99       	mov	r9,25
800056f2:	49 d8       	lddpc	r8,80005764 <nav_dir_gotoparent+0x84>
800056f4:	b0 89       	st.b	r8[0x0],r9
800056f6:	d8 2a       	popm	r4-r7,pc,r12=0
      return false;
   }

   // Select and read information about directory ".."
   fs_g_nav_fast.u16_entry_pos_sel_file = 1;
800056f8:	30 19       	mov	r9,1
800056fa:	49 c8       	lddpc	r8,80005768 <nav_dir_gotoparent+0x88>
800056fc:	b0 19       	st.h	r8[0x2],r9
   if ( !fat_read_dir())
800056fe:	f0 1f 00 1c 	mcall	8000576c <nav_dir_gotoparent+0x8c>
80005702:	c2 a0       	breq	80005756 <nav_dir_gotoparent+0x76>
      return false;
   fat_get_entry_info();
80005704:	f0 1f 00 1b 	mcall	80005770 <nav_dir_gotoparent+0x90>
   // Save the children directory cluster
   u32_cluster_old_dir = fs_g_nav.u32_cluster_sel_dir;
80005708:	49 68       	lddpc	r8,80005760 <nav_dir_gotoparent+0x80>
8000570a:	70 87       	ld.w	r7,r8[0x20]

   // Select the parent directory via information present in the current directory ".."
   fs_g_nav.u32_cluster_sel_dir = fs_g_nav_entry.u32_cluster;
8000570c:	49 a9       	lddpc	r9,80005774 <nav_dir_gotoparent+0x94>
8000570e:	72 19       	ld.w	r9,r9[0x4]
80005710:	91 89       	st.w	r8[0x20],r9

   // Select the children directory in new directory (=parent directory)
   if( false == nav_filelist_reset())
80005712:	f0 1f 00 1a 	mcall	80005778 <nav_dir_gotoparent+0x98>
80005716:	c2 00       	breq	80005756 <nav_dir_gotoparent+0x76>
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
80005718:	49 28       	lddpc	r8,80005760 <nav_dir_gotoparent+0x80>
8000571a:	f1 39 00 2d 	ld.ub	r9,r8[45]
8000571e:	30 08       	mov	r8,0
80005720:	f0 09 18 00 	cp.b	r9,r8
80005724:	c0 d0       	breq	8000573e <nav_dir_gotoparent+0x5e>
80005726:	48 f8       	lddpc	r8,80005760 <nav_dir_gotoparent+0x80>
80005728:	f1 39 00 2c 	ld.ub	r9,r8[44]
8000572c:	30 08       	mov	r8,0
8000572e:	f0 09 18 00 	cp.b	r9,r8
80005732:	c0 60       	breq	8000573e <nav_dir_gotoparent+0x5e>
80005734:	c1 28       	rjmp	80005758 <nav_dir_gotoparent+0x78>
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
80005736:	6c 18       	ld.w	r8,r6[0x4]
80005738:	0e 38       	cp.w	r8,r7
8000573a:	c0 51       	brne	80005744 <nav_dir_gotoparent+0x64>
8000573c:	c0 e8       	rjmp	80005758 <nav_dir_gotoparent+0x78>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000573e:	30 15       	mov	r5,1
80005740:	30 04       	mov	r4,0
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
80005742:	48 d6       	lddpc	r6,80005774 <nav_dir_gotoparent+0x94>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005744:	0a 9b       	mov	r11,r5
80005746:	08 9c       	mov	r12,r4
80005748:	f0 1f 00 0d 	mcall	8000577c <nav_dir_gotoparent+0x9c>
8000574c:	cf 51       	brne	80005736 <nav_dir_gotoparent+0x56>
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
         return true;         // It is the children directory
   }
   fs_g_status = FS_ERR_FS;
8000574e:	30 89       	mov	r9,8
80005750:	48 58       	lddpc	r8,80005764 <nav_dir_gotoparent+0x84>
80005752:	b0 89       	st.b	r8[0x0],r9
   return false;
80005754:	d8 22       	popm	r4-r7,pc
80005756:	d8 2a       	popm	r4-r7,pc,r12=0
80005758:	da 2a       	popm	r4-r7,pc,r12=1
8000575a:	00 00       	add	r0,r0
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	4e 9c       	lddpc	r12,80005900 <nav_filelist_nb+0x3c>
80005760:	00 00       	add	r0,r0
80005762:	7c 24       	ld.w	r4,lr[0x8]
80005764:	00 00       	add	r0,r0
80005766:	7c 74       	ld.w	r4,lr[0x1c]
80005768:	00 00       	add	r0,r0
8000576a:	7c 70       	ld.w	r0,lr[0x1c]
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	4b b0       	lddpc	r0,80005858 <nav_dir_name+0xd8>
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	42 a4       	lddsp	r4,sp[0xa8]
80005774:	00 00       	add	r0,r0
80005776:	79 e4       	ld.w	r4,r12[0x78]
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	56 c8       	stdsp	sp[0x1b0],r8
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	55 60       	stdsp	sp[0x158],r0

80005780 <nav_dir_name>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_dir_name( FS_STRING sz_path  , uint8_t u8_size_max  )
{
80005780:	d4 31       	pushm	r0-r7,lr
80005782:	20 2d       	sub	sp,8
80005784:	18 96       	mov	r6,r12
80005786:	16 95       	mov	r5,r11
   uint32_t save_u32_cluster      ;
   uint32_t save_u32_size         ;
   bool b_mode_nav_single_save;
   bool b_mode_nav_mode_save;

   if ( !fat_check_mount_noopen())
80005788:	f0 1f 00 37 	mcall	80005864 <nav_dir_name+0xe4>
8000578c:	c6 a0       	breq	80005860 <nav_dir_name+0xe0>
      return false;

   if (0 != fs_g_nav.u32_cluster_sel_dir)
8000578e:	4b 78       	lddpc	r8,80005868 <nav_dir_name+0xe8>
80005790:	70 87       	ld.w	r7,r8[0x20]
80005792:	58 07       	cp.w	r7,0
80005794:	c3 b0       	breq	8000580a <nav_dir_name+0x8a>
   {
      // Save context
      save_u16_entry_pos_sel_file= fs_g_nav_fast.u16_entry_pos_sel_file;
80005796:	4b 68       	lddpc	r8,8000586c <nav_dir_name+0xec>
80005798:	90 11       	ld.sh	r1,r8[0x2]
      save_u32_cluster_sel_dir   = fs_g_nav.u32_cluster_sel_dir        ;
      save_u8_attr               = fs_g_nav_entry.u8_attr              ;
8000579a:	4b 68       	lddpc	r8,80005870 <nav_dir_name+0xf0>
8000579c:	11 a0       	ld.ub	r0,r8[0x2]
      save_u32_cluster           = fs_g_nav_entry.u32_cluster          ;
8000579e:	70 19       	ld.w	r9,r8[0x4]
800057a0:	50 19       	stdsp	sp[0x4],r9
      save_u32_size              = fs_g_nav_entry.u32_size             ;
800057a2:	70 28       	ld.w	r8,r8[0x8]
800057a4:	50 08       	stdsp	sp[0x0],r8
      b_mode_nav_single_save = fs_g_nav.b_mode_nav_single;
800057a6:	4b 18       	lddpc	r8,80005868 <nav_dir_name+0xe8>
800057a8:	f1 3a 00 2d 	ld.ub	r10,r8[45]
800057ac:	30 09       	mov	r9,0
800057ae:	f2 0a 18 00 	cp.b	r10,r9
800057b2:	5f 14       	srne	r4
      b_mode_nav_mode_save   = fs_g_nav.b_mode_nav;
800057b4:	f1 3a 00 2c 	ld.ub	r10,r8[44]
800057b8:	f2 0a 18 00 	cp.b	r10,r9
800057bc:	5f 13       	srne	r3
      fs_g_nav.b_mode_nav_single = true;
800057be:	30 19       	mov	r9,1
800057c0:	f1 69 00 2d 	st.b	r8[45],r9
      fs_g_nav.b_mode_nav = FS_FILE;
800057c4:	f1 69 00 2c 	st.b	r8[44],r9
      // Go to parent directory and select the children directory
      if( !nav_dir_gotoparent() )
800057c8:	f0 1f 00 2b 	mcall	80005874 <nav_dir_name+0xf4>
800057cc:	c0 71       	brne	800057da <nav_dir_name+0x5a>
      {
         fs_g_nav.b_mode_nav_single = b_mode_nav_single_save;
800057ce:	4a 78       	lddpc	r8,80005868 <nav_dir_name+0xe8>
800057d0:	f1 64 00 2d 	st.b	r8[45],r4
         fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
800057d4:	f1 63 00 2c 	st.b	r8[44],r3
         return false;
800057d8:	c4 48       	rjmp	80005860 <nav_dir_name+0xe0>
      }
      fs_g_nav.b_mode_nav_single = b_mode_nav_single_save ;
800057da:	4a 42       	lddpc	r2,80005868 <nav_dir_name+0xe8>
800057dc:	e5 64 00 2d 	st.b	r2[45],r4
      fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
800057e0:	e5 63 00 2c 	st.b	r2[44],r3
      // Go to directory name position
      fs_g_nav_fast.u16_entry_pos_sel_file = fs_g_nav.u16_entry_pos_sel_dir;
800057e4:	4a 24       	lddpc	r4,8000586c <nav_dir_name+0xec>
800057e6:	e5 08 00 1c 	ld.sh	r8,r2[28]
800057ea:	a8 18       	st.h	r4[0x2],r8
      status = nav_file_name( sz_path  , u8_size_max , FS_NAME_GET , false  );
800057ec:	30 09       	mov	r9,0
800057ee:	30 1a       	mov	r10,1
800057f0:	0a 9b       	mov	r11,r5
800057f2:	0c 9c       	mov	r12,r6
800057f4:	f0 1f 00 21 	mcall	80005878 <nav_dir_name+0xf8>
      // Restore previous context
      fs_g_nav_fast.u16_entry_pos_sel_file= save_u16_entry_pos_sel_file;
800057f8:	a8 11       	st.h	r4[0x2],r1
      fs_g_nav.u32_cluster_sel_dir        = save_u32_cluster_sel_dir   ;
800057fa:	85 87       	st.w	r2[0x20],r7
      fs_g_nav_entry.u8_attr              = save_u8_attr               ;
800057fc:	49 d8       	lddpc	r8,80005870 <nav_dir_name+0xf0>
800057fe:	b0 a0       	st.b	r8[0x2],r0
      fs_g_nav_entry.u32_cluster          = save_u32_cluster           ;
80005800:	40 19       	lddsp	r9,sp[0x4]
80005802:	91 19       	st.w	r8[0x4],r9
      fs_g_nav_entry.u32_size             = save_u32_size              ;
80005804:	40 09       	lddsp	r9,sp[0x0]
80005806:	91 29       	st.w	r8[0x8],r9
80005808:	c2 c8       	rjmp	80005860 <nav_dir_name+0xe0>
   }
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
8000580a:	49 d8       	lddpc	r8,8000587c <nav_dir_name+0xfc>
8000580c:	11 89       	ld.ub	r9,r8[0x0]
8000580e:	30 08       	mov	r8,0
80005810:	f0 09 18 00 	cp.b	r9,r8
80005814:	c0 50       	breq	8000581e <nav_dir_name+0x9e>
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
80005816:	30 38       	mov	r8,3
80005818:	ac 08       	st.h	r6[0x0],r8
8000581a:	30 1c       	mov	r12,1
8000581c:	c2 28       	rjmp	80005860 <nav_dir_name+0xe0>
8000581e:	2f f6       	sub	r6,-1
80005820:	30 17       	mov	r7,1
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
80005822:	30 04       	mov	r4,0
80005824:	30 15       	mov	r5,1
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
80005826:	30 23       	mov	r3,2
80005828:	c0 48       	rjmp	80005830 <nav_dir_name+0xb0>
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
8000582a:	2f f6       	sub	r6,-1
8000582c:	2f f7       	sub	r7,-1
8000582e:	5c 57       	castu.b	r7
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
80005830:	0e 98       	mov	r8,r7
80005832:	20 18       	sub	r8,1
80005834:	e8 08 18 00 	cp.b	r8,r4
80005838:	c0 e0       	breq	80005854 <nav_dir_name+0xd4>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
8000583a:	ea 08 18 00 	cp.b	r8,r5
8000583e:	f9 b8 00 3a 	moveq	r8,58
80005842:	f9 b8 01 00 	movne	r8,0
80005846:	ed 68 ff ff 	st.b	r6[-1],r8
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
8000584a:	e6 07 18 00 	cp.b	r7,r3
8000584e:	fe 98 ff ee 	brls	8000582a <nav_dir_name+0xaa>
80005852:	c0 68       	rjmp	8000585e <nav_dir_name+0xde>
      {
         switch( u8_i )
         {
            case 0:
            u8_character = nav_drive_getname();    // Letter
80005854:	f0 1f 00 0b 	mcall	80005880 <nav_dir_name+0x100>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
80005858:	ed 6c ff ff 	st.b	r6[-1],r12
8000585c:	ce 7b       	rjmp	8000582a <nav_dir_name+0xaa>
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
8000585e:	30 1c       	mov	r12,1
      }
      status = true;

   }
   return status;
}
80005860:	2f ed       	sub	sp,-8
80005862:	d8 32       	popm	r0-r7,pc
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	4e 9c       	lddpc	r12,80005a08 <nav_drive_set+0xc>
80005868:	00 00       	add	r0,r0
8000586a:	7c 24       	ld.w	r4,lr[0x8]
8000586c:	00 00       	add	r0,r0
8000586e:	7c 70       	ld.w	r0,lr[0x1c]
80005870:	00 00       	add	r0,r0
80005872:	79 e4       	ld.w	r4,r12[0x78]
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	56 e0       	stdsp	sp[0x1b8],r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	54 7c       	stdsp	sp[0x11c],r12
8000587c:	00 00       	add	r0,r0
8000587e:	7c 75       	ld.w	r5,lr[0x1c]
80005880:	80 00       	ld.sh	r0,r0[0x0]
80005882:	54 54       	stdsp	sp[0x114],r4

80005884 <nav_filelist_first>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_first( bool b_type )
{
80005884:	d4 21       	pushm	r4-r7,lr
80005886:	18 97       	mov	r7,r12
   // Reset position
   if ( !nav_filelist_reset())
80005888:	f0 1f 00 0b 	mcall	800058b4 <nav_filelist_first+0x30>
8000588c:	c0 71       	brne	8000589a <nav_filelist_first+0x16>
8000588e:	d8 22       	popm	r4-r7,pc
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( b_type == fs_g_nav.b_mode_nav )
80005890:	e9 38 00 2c 	ld.ub	r8,r4[44]
80005894:	10 37       	cp.w	r7,r8
80005896:	c0 51       	brne	800058a0 <nav_filelist_first+0x1c>
80005898:	da 2a       	popm	r4-r7,pc,r12=1
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000589a:	30 16       	mov	r6,1
8000589c:	30 05       	mov	r5,0
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000589e:	48 74       	lddpc	r4,800058b8 <nav_filelist_first+0x34>
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800058a0:	0c 9b       	mov	r11,r6
800058a2:	0a 9c       	mov	r12,r5
800058a4:	f0 1f 00 06 	mcall	800058bc <nav_filelist_first+0x38>
800058a8:	cf 41       	brne	80005890 <nav_filelist_first+0xc>
   {
      if( b_type == fs_g_nav.b_mode_nav )
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
800058aa:	30 99       	mov	r9,9
800058ac:	48 58       	lddpc	r8,800058c0 <nav_filelist_first+0x3c>
800058ae:	b0 89       	st.b	r8[0x0],r9
   return false;
}
800058b0:	d8 22       	popm	r4-r7,pc
800058b2:	00 00       	add	r0,r0
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	56 c8       	stdsp	sp[0x1b0],r8
800058b8:	00 00       	add	r0,r0
800058ba:	7c 24       	ld.w	r4,lr[0x8]
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	55 60       	stdsp	sp[0x158],r0
800058c0:	00 00       	add	r0,r0
800058c2:	7c 74       	ld.w	r4,lr[0x1c]

800058c4 <nav_filelist_nb>:
//!                     FS_FILE to compute the number of files <br>
//!
//! @return    number of files or directories in file list
//!
uint16_t   nav_filelist_nb( bool b_type )
{
800058c4:	d4 31       	pushm	r0-r7,lr
800058c6:	18 90       	mov	r0,r12
   uint16_t   u16_save_position;
   uint16_t   u16_save_number_dir;
   uint16_t   u16_save_number_file;

   // Save current position
   u16_save_position = fs_g_nav.u16_pos_sel_file;
800058c8:	49 88       	lddpc	r8,80005928 <nav_filelist_nb+0x64>
800058ca:	f1 01 00 24 	ld.sh	r1,r8[36]
   // Reset position
   if ( !nav_filelist_reset())
800058ce:	f0 1f 00 18 	mcall	8000592c <nav_filelist_nb+0x68>
800058d2:	c0 31       	brne	800058d8 <nav_filelist_nb+0x14>
800058d4:	30 02       	mov	r2,0
800058d6:	c2 68       	rjmp	80005922 <nav_filelist_nb+0x5e>
800058d8:	30 02       	mov	r2,0
800058da:	04 97       	mov	r7,r2
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800058dc:	30 14       	mov	r4,1
800058de:	04 93       	mov	r3,r2
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
800058e0:	49 26       	lddpc	r6,80005928 <nav_filelist_nb+0x64>
800058e2:	30 15       	mov	r5,1
800058e4:	c0 b8       	rjmp	800058fa <nav_filelist_nb+0x36>
800058e6:	ed 38 00 2c 	ld.ub	r8,r6[44]
800058ea:	ea 08 18 00 	cp.b	r8,r5
800058ee:	c0 41       	brne	800058f6 <nav_filelist_nb+0x32>
         u16_save_number_file++;    // It is a file
800058f0:	2f f2       	sub	r2,-1
800058f2:	5c 82       	casts.h	r2
800058f4:	c0 38       	rjmp	800058fa <nav_filelist_nb+0x36>
      else
         u16_save_number_dir++;     // It is a directory
800058f6:	2f f7       	sub	r7,-1
800058f8:	5c 87       	casts.h	r7
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800058fa:	08 9b       	mov	r11,r4
800058fc:	06 9c       	mov	r12,r3
800058fe:	f0 1f 00 0d 	mcall	80005930 <nav_filelist_nb+0x6c>
80005902:	cf 21       	brne	800058e6 <nav_filelist_nb+0x22>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
80005904:	f0 1f 00 0a 	mcall	8000592c <nav_filelist_nb+0x68>
   if ( u16_save_position != FS_NO_SEL )
80005908:	3f f8       	mov	r8,-1
8000590a:	f0 01 19 00 	cp.h	r1,r8
8000590e:	c0 60       	breq	8000591a <nav_filelist_nb+0x56>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
80005910:	30 1b       	mov	r11,1
80005912:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
80005916:	f0 1f 00 07 	mcall	80005930 <nav_filelist_nb+0x6c>
   }
   // Return the value asked
   if( FS_FILE == b_type )
8000591a:	58 00       	cp.w	r0,0
8000591c:	c0 31       	brne	80005922 <nav_filelist_nb+0x5e>
8000591e:	0e 92       	mov	r2,r7
80005920:	5c 82       	casts.h	r2
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
80005922:	04 9c       	mov	r12,r2
80005924:	d8 32       	popm	r0-r7,pc
80005926:	00 00       	add	r0,r0
80005928:	00 00       	add	r0,r0
8000592a:	7c 24       	ld.w	r4,lr[0x8]
8000592c:	80 00       	ld.sh	r0,r0[0x0]
8000592e:	56 c8       	stdsp	sp[0x1b0],r8
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	55 60       	stdsp	sp[0x158],r0

80005934 <nav_filelist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filelist_goto( uint16_t u16_newpos )
{
80005934:	eb cd 40 80 	pushm	r7,lr
80005938:	18 97       	mov	r7,r12
   uint16_t u16_current_pos;

   if( FS_NO_SEL == u16_newpos )
8000593a:	3f f8       	mov	r8,-1
8000593c:	f0 0c 19 00 	cp.h	r12,r8
80005940:	c0 51       	brne	8000594a <nav_filelist_goto+0x16>
      return nav_filelist_reset();
80005942:	f0 1f 00 1d 	mcall	800059b4 <nav_filelist_goto+0x80>
80005946:	e3 cd 80 80 	ldm	sp++,r7,pc

   u16_current_pos = nav_filelist_get();
8000594a:	f0 1f 00 1c 	mcall	800059b8 <nav_filelist_goto+0x84>
8000594e:	5c 8c       	casts.h	r12
   if( u16_newpos < (u16_current_pos/2) )
80005950:	f1 dc c0 2f 	bfextu	r8,r12,0x1,0xf
80005954:	f0 07 19 00 	cp.h	r7,r8
80005958:	c0 62       	brcc	80005964 <nav_filelist_goto+0x30>
   {
      // Restart at the beginning of list to accelerate the search
      if( !nav_filelist_reset() )
8000595a:	f0 1f 00 17 	mcall	800059b4 <nav_filelist_goto+0x80>
8000595e:	c0 71       	brne	8000596c <nav_filelist_goto+0x38>
80005960:	e3 cd 80 80 	ldm	sp++,r7,pc
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
80005964:	3f f8       	mov	r8,-1
80005966:	f0 0c 19 00 	cp.h	r12,r8
8000596a:	c0 81       	brne	8000597a <nav_filelist_goto+0x46>
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
8000596c:	30 1b       	mov	r11,1
8000596e:	0e 9c       	mov	r12,r7
80005970:	5c 7c       	castu.h	r12
80005972:	f0 1f 00 13 	mcall	800059bc <nav_filelist_goto+0x88>
80005976:	e3 cd 80 80 	ldm	sp++,r7,pc
   }
   else
   {
      if (u16_newpos < u16_current_pos)
8000597a:	f8 07 19 00 	cp.h	r7,r12
8000597e:	c0 b2       	brcc	80005994 <nav_filelist_goto+0x60>
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
80005980:	ee 07 11 ff 	rsub	r7,r7,-1
80005984:	ee 0c 00 0c 	add	r12,r7,r12
80005988:	30 0b       	mov	r11,0
8000598a:	5c 7c       	castu.h	r12
8000598c:	f0 1f 00 0c 	mcall	800059bc <nav_filelist_goto+0x88>
80005990:	e3 cd 80 80 	ldm	sp++,r7,pc
      }
      if (u16_newpos > u16_current_pos)
80005994:	f8 07 19 00 	cp.h	r7,r12
80005998:	e0 8b 00 04 	brhi	800059a0 <nav_filelist_goto+0x6c>
8000599c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      {
         return nav_filelist_set( u16_newpos -u16_current_pos - 1 , FS_FIND_NEXT );
800059a0:	20 17       	sub	r7,1
800059a2:	ee 0c 01 0c 	sub	r12,r7,r12
800059a6:	30 1b       	mov	r11,1
800059a8:	5c 7c       	castu.h	r12
800059aa:	f0 1f 00 05 	mcall	800059bc <nav_filelist_goto+0x88>
      }
   }
   return true;
}
800059ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800059b2:	00 00       	add	r0,r0
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	56 c8       	stdsp	sp[0x1b0],r8
800059b8:	80 00       	ld.sh	r0,r0[0x0]
800059ba:	54 70       	stdsp	sp[0x11c],r0
800059bc:	80 00       	ld.sh	r0,r0[0x0]
800059be:	55 60       	stdsp	sp[0x158],r0

800059c0 <nav_partition_mount>:
//! then the mount routine selects the first partition supported by file system. <br>
//! After mount, the file list contains files and directories of ROOT directory
//! @endverbatim
//!
bool  nav_partition_mount( void )
{
800059c0:	d4 01       	pushm	lr
   if ( !fat_check_noopen() )
800059c2:	f0 1f 00 0a 	mcall	800059e8 <nav_partition_mount+0x28>
800059c6:	c0 f0       	breq	800059e4 <nav_partition_mount+0x24>
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
800059c8:	48 98       	lddpc	r8,800059ec <nav_partition_mount+0x2c>
800059ca:	11 89       	ld.ub	r9,r8[0x0]
800059cc:	30 08       	mov	r8,0
800059ce:	f0 09 18 00 	cp.b	r9,r8
800059d2:	c0 70       	breq	800059e0 <nav_partition_mount+0x20>
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
800059d4:	30 09       	mov	r9,0
800059d6:	48 78       	lddpc	r8,800059f0 <nav_partition_mount+0x30>
800059d8:	91 89       	st.w	r8[0x20],r9
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
800059da:	f0 1f 00 07 	mcall	800059f4 <nav_partition_mount+0x34>
800059de:	da 0a       	popm	pc,r12=1
      return true;
   }

   return fat_mount();
800059e0:	f0 1f 00 06 	mcall	800059f8 <nav_partition_mount+0x38>
}
800059e4:	d8 02       	popm	pc
800059e6:	00 00       	add	r0,r0
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	4d c8       	lddpc	r8,80005b58 <ctrl_access_lock+0x1c>
800059ec:	00 00       	add	r0,r0
800059ee:	7c 70       	ld.w	r0,lr[0x1c]
800059f0:	00 00       	add	r0,r0
800059f2:	7c 24       	ld.w	r4,lr[0x8]
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	3f 8c       	mov	r12,-8
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	4f e0       	lddpc	r0,80005bf0 <memory_2_ram+0x28>

800059fc <nav_drive_set>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_drive_set( uint8_t u8_number )
{
800059fc:	eb cd 40 80 	pushm	r7,lr
80005a00:	18 97       	mov	r7,r12
   if ( !fat_check_noopen() )
80005a02:	f0 1f 00 0f 	mcall	80005a3c <nav_drive_set+0x40>
80005a06:	c1 90       	breq	80005a38 <nav_drive_set+0x3c>
      return false;

   if (u8_number >= get_nb_lun() )
80005a08:	f0 1f 00 0e 	mcall	80005a40 <nav_drive_set+0x44>
80005a0c:	ee 0c 18 00 	cp.b	r12,r7
80005a10:	e0 8b 00 07 	brhi	80005a1e <nav_drive_set+0x22>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
80005a14:	30 69       	mov	r9,6
80005a16:	48 c8       	lddpc	r8,80005a44 <nav_drive_set+0x48>
80005a18:	b0 89       	st.b	r8[0x0],r9
80005a1a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
80005a1e:	48 b8       	lddpc	r8,80005a48 <nav_drive_set+0x4c>
80005a20:	11 88       	ld.ub	r8,r8[0x0]
80005a22:	ee 08 18 00 	cp.b	r8,r7
80005a26:	c0 31       	brne	80005a2c <nav_drive_set+0x30>
80005a28:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
80005a2c:	48 78       	lddpc	r8,80005a48 <nav_drive_set+0x4c>
80005a2e:	b0 87       	st.b	r8[0x0],r7
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
80005a30:	30 09       	mov	r9,0
80005a32:	48 78       	lddpc	r8,80005a4c <nav_drive_set+0x50>
80005a34:	b0 89       	st.b	r8[0x0],r9
80005a36:	30 1c       	mov	r12,1
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
80005a38:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	4d c8       	lddpc	r8,80005bac <ram_2_memory+0x44>
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	5b 38       	cp.w	r8,-13
80005a44:	00 00       	add	r0,r0
80005a46:	7c 74       	ld.w	r4,lr[0x1c]
80005a48:	00 00       	add	r0,r0
80005a4a:	7c 24       	ld.w	r4,lr[0x8]
80005a4c:	00 00       	add	r0,r0
80005a4e:	7c 70       	ld.w	r0,lr[0x1c]

80005a50 <nav_drive_nb>:
//! @verbatim
//! This value may be dynamic because it depends of memory drivers (e.g. Mass Storage disk on USB host mode)
//! @endverbatim
//!
uint8_t    nav_drive_nb( void )
{
80005a50:	d4 01       	pushm	lr
   return get_nb_lun(); // Number of devices = Number of lun
80005a52:	f0 1f 00 02 	mcall	80005a58 <nav_drive_nb+0x8>
}
80005a56:	d8 02       	popm	pc
80005a58:	80 00       	ld.sh	r0,r0[0x0]
80005a5a:	5b 38       	cp.w	r8,-13

80005a5c <nav_select>:
//!
//! @return    false if ID navigator don't exist
//! @return    true otherwise
//!
bool  nav_select( uint8_t u8_idnav )
{
80005a5c:	eb cd 40 80 	pushm	r7,lr
80005a60:	18 97       	mov	r7,r12
   if( FS_NB_NAVIGATOR <= u8_idnav )
80005a62:	30 18       	mov	r8,1
80005a64:	f0 0c 18 00 	cp.b	r12,r8
80005a68:	e0 88 00 07 	brls	80005a76 <nav_select+0x1a>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
80005a6c:	32 79       	mov	r9,39
80005a6e:	48 b8       	lddpc	r8,80005a98 <nav_select+0x3c>
80005a70:	b0 89       	st.b	r8[0x0],r9
80005a72:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
80005a76:	48 a8       	lddpc	r8,80005a9c <nav_select+0x40>
80005a78:	11 8c       	ld.ub	r12,r8[0x0]
80005a7a:	ee 0c 18 00 	cp.b	r12,r7
80005a7e:	c0 31       	brne	80005a84 <nav_select+0x28>
80005a80:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
80005a84:	f0 1f 00 07 	mcall	80005aa0 <nav_select+0x44>
      fat_invert_nav( u8_idnav );               // Select new navigator
80005a88:	0e 9c       	mov	r12,r7
80005a8a:	f0 1f 00 06 	mcall	80005aa0 <nav_select+0x44>
      fs_g_u8_nav_selected = u8_idnav;
80005a8e:	48 48       	lddpc	r8,80005a9c <nav_select+0x40>
80005a90:	b0 87       	st.b	r8[0x0],r7
80005a92:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80005a96:	00 00       	add	r0,r0
80005a98:	00 00       	add	r0,r0
80005a9a:	7c 74       	ld.w	r4,lr[0x1c]
80005a9c:	00 00       	add	r0,r0
80005a9e:	7c ec       	ld.w	r12,lr[0x38]
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	44 38       	lddsp	r8,sp[0x10c]

80005aa4 <nav_exit>:
//! @verbatim
//! Call this at the program exit or before a USB Device session
//! @endverbatim
//!
void  nav_exit( void )
{
80005aa4:	d4 01       	pushm	lr
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
80005aa6:	30 0c       	mov	r12,0
80005aa8:	f0 1f 00 06 	mcall	80005ac0 <nav_exit+0x1c>
      file_close();
80005aac:	f0 1f 00 06 	mcall	80005ac4 <nav_exit+0x20>
   // If you have opened files then close them
#if (FS_NB_NAVIGATOR > 1)
   uint8_t u8_i;
   for( u8_i=0; u8_i<FS_NB_NAVIGATOR; u8_i++)
   {
      nav_select(u8_i);
80005ab0:	30 1c       	mov	r12,1
80005ab2:	f0 1f 00 04 	mcall	80005ac0 <nav_exit+0x1c>
      file_close();
80005ab6:	f0 1f 00 04 	mcall	80005ac4 <nav_exit+0x20>
#else
   nav_select(0);
   file_close();
#endif
   // Flush data eventually present in FAT cache
   fat_cache_flush();
80005aba:	f0 1f 00 04 	mcall	80005ac8 <nav_exit+0x24>
}
80005abe:	d8 02       	popm	pc
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	5a 5c       	cp.w	r12,-27
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	53 00       	stdsp	sp[0xc0],r0
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	45 14       	lddsp	r4,sp[0x144]

80005acc <nav_reset>:
//! @verbatim
//! Call this at the program startup or before a new session (e.g. USB Device exit)
//! @endverbatim
//!
void  nav_reset( void )
{
80005acc:	eb cd 40 f8 	pushm	r3-r7,lr
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
80005ad0:	30 07       	mov	r7,0
80005ad2:	49 18       	lddpc	r8,80005b14 <nav_reset+0x48>
80005ad4:	b0 87       	st.b	r8[0x0],r7
   g_b_no_check_disk = false;
80005ad6:	49 18       	lddpc	r8,80005b18 <nav_reset+0x4c>
80005ad8:	b0 87       	st.b	r8[0x0],r7

   fat_cache_reset();
80005ada:	f0 1f 00 11 	mcall	80005b1c <nav_reset+0x50>
   fat_cache_clusterlist_reset();
80005ade:	f0 1f 00 11 	mcall	80005b20 <nav_reset+0x54>
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80005ae2:	30 0c       	mov	r12,0
80005ae4:	f0 1f 00 10 	mcall	80005b24 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005ae8:	49 03       	lddpc	r3,80005b28 <nav_reset+0x5c>
80005aea:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80005aec:	49 05       	lddpc	r5,80005b2c <nav_reset+0x60>
80005aee:	3f f4       	mov	r4,-1
80005af0:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80005af2:	49 06       	lddpc	r6,80005b30 <nav_reset+0x64>
80005af4:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
80005af6:	eb 67 00 2d 	st.b	r5[45],r7
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80005afa:	30 1c       	mov	r12,1
80005afc:	f0 1f 00 0a 	mcall	80005b24 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005b00:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80005b02:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80005b04:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
80005b06:	eb 67 00 2d 	st.b	r5[45],r7
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
80005b0a:	48 b8       	lddpc	r8,80005b34 <nav_reset+0x68>
80005b0c:	b0 87       	st.b	r8[0x0],r7
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
80005b0e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005b12:	00 00       	add	r0,r0
80005b14:	00 00       	add	r0,r0
80005b16:	7c 75       	ld.w	r5,lr[0x1c]
80005b18:	00 00       	add	r0,r0
80005b1a:	79 f6       	ld.w	r6,r12[0x7c]
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	43 48       	lddsp	r8,sp[0xd0]
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	3d 38       	mov	r8,-45
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	5a 5c       	cp.w	r12,-27
80005b28:	00 00       	add	r0,r0
80005b2a:	7c 70       	ld.w	r0,lr[0x1c]
80005b2c:	00 00       	add	r0,r0
80005b2e:	7c 24       	ld.w	r4,lr[0x8]
80005b30:	00 00       	add	r0,r0
80005b32:	79 e4       	ld.w	r4,r12[0x78]
80005b34:	00 00       	add	r0,r0
80005b36:	7c ec       	ld.w	r12,lr[0x38]

80005b38 <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
80005b38:	5e ff       	retal	1
80005b3a:	d7 03       	nop

80005b3c <ctrl_access_lock>:
/*! \brief Locks accesses to LUNs.
 *
 * \return \c true if the access was successfully locked, else \c false.
 */
static bool ctrl_access_lock(void)
{
80005b3c:	eb cd 40 c0 	pushm	r6-r7,lr
  // If the semaphore could not be created, there is no backup solution.
  if (!ctrl_access_semphr) return false;
80005b40:	48 88       	lddpc	r8,80005b60 <ctrl_access_lock+0x24>
80005b42:	70 08       	ld.w	r8,r8[0x0]
80005b44:	58 08       	cp.w	r8,0
80005b46:	c0 31       	brne	80005b4c <ctrl_access_lock+0x10>
80005b48:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

  // Wait for the semaphore.
  while (!xSemaphoreTake(ctrl_access_semphr, portMAX_DELAY));
80005b4c:	48 56       	lddpc	r6,80005b60 <ctrl_access_lock+0x24>
80005b4e:	3f f7       	mov	r7,-1
80005b50:	0e 9b       	mov	r11,r7
80005b52:	6c 0c       	ld.w	r12,r6[0x0]
80005b54:	f0 1f 00 04 	mcall	80005b64 <ctrl_access_lock+0x28>
80005b58:	cf c0       	breq	80005b50 <ctrl_access_lock+0x14>
80005b5a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b5e:	00 00       	add	r0,r0
80005b60:	00 00       	add	r0,r0
80005b62:	74 c8       	ld.w	r8,r10[0x30]
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	72 e4       	ld.w	r4,r9[0x38]

80005b68 <ram_2_memory>:
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
80005b68:	eb cd 40 e0 	pushm	r5-r7,lr
80005b6c:	18 97       	mov	r7,r12
80005b6e:	16 95       	mov	r5,r11
80005b70:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80005b72:	f0 1f 00 10 	mcall	80005bb0 <ram_2_memory+0x48>
80005b76:	c0 31       	brne	80005b7c <ram_2_memory+0x14>
80005b78:	30 17       	mov	r7,1
80005b7a:	c1 88       	rjmp	80005baa <ram_2_memory+0x42>

  memory_start_write_action(1);
80005b7c:	30 2c       	mov	r12,2
80005b7e:	f0 1f 00 0e 	mcall	80005bb4 <ram_2_memory+0x4c>
  status =
80005b82:	58 07       	cp.w	r7,0
80005b84:	c0 30       	breq	80005b8a <ram_2_memory+0x22>
80005b86:	30 17       	mov	r7,1
80005b88:	c0 78       	rjmp	80005b96 <ram_2_memory+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
80005b8a:	48 c8       	lddpc	r8,80005bb8 <ram_2_memory+0x50>
80005b8c:	70 68       	ld.w	r8,r8[0x18]
80005b8e:	0c 9b       	mov	r11,r6
80005b90:	0a 9c       	mov	r12,r5
80005b92:	5d 18       	icall	r8
80005b94:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_ram_2_mem(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_write_action();
80005b96:	30 2c       	mov	r12,2
80005b98:	f0 1f 00 09 	mcall	80005bbc <ram_2_memory+0x54>

  Ctrl_access_unlock();
80005b9c:	30 09       	mov	r9,0
80005b9e:	12 9a       	mov	r10,r9
80005ba0:	12 9b       	mov	r11,r9
80005ba2:	48 88       	lddpc	r8,80005bc0 <ram_2_memory+0x58>
80005ba4:	70 0c       	ld.w	r12,r8[0x0]
80005ba6:	f0 1f 00 08 	mcall	80005bc4 <ram_2_memory+0x5c>

  return status;
}
80005baa:	0e 9c       	mov	r12,r7
80005bac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	5b 3c       	cp.w	r12,-13
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	83 0c       	st.w	r1[0x0],r12
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	b0 f8       	st.b	r8[0x7],r8
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	83 68       	st.w	r1[0x18],r8
80005bc0:	00 00       	add	r0,r0
80005bc2:	74 c8       	ld.w	r8,r10[0x30]
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	74 c8       	ld.w	r8,r10[0x30]

80005bc8 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
80005bc8:	eb cd 40 e0 	pushm	r5-r7,lr
80005bcc:	18 97       	mov	r7,r12
80005bce:	16 95       	mov	r5,r11
80005bd0:	14 96       	mov	r6,r10
  Ctrl_status status;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80005bd2:	f0 1f 00 10 	mcall	80005c10 <memory_2_ram+0x48>
80005bd6:	c0 31       	brne	80005bdc <memory_2_ram+0x14>
80005bd8:	30 17       	mov	r7,1
80005bda:	c1 88       	rjmp	80005c0a <memory_2_ram+0x42>

  memory_start_read_action(1);
80005bdc:	30 1c       	mov	r12,1
80005bde:	f0 1f 00 0e 	mcall	80005c14 <memory_2_ram+0x4c>
  status =
80005be2:	58 07       	cp.w	r7,0
80005be4:	c0 30       	breq	80005bea <memory_2_ram+0x22>
80005be6:	30 17       	mov	r7,1
80005be8:	c0 78       	rjmp	80005bf6 <memory_2_ram+0x2e>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
80005bea:	48 c8       	lddpc	r8,80005c18 <memory_2_ram+0x50>
80005bec:	70 58       	ld.w	r8,r8[0x14]
80005bee:	0c 9b       	mov	r11,r6
80005bf0:	0a 9c       	mov	r12,r5
80005bf2:	5d 18       	icall	r8
80005bf4:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_mem_2_ram(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_read_action();
80005bf6:	30 1c       	mov	r12,1
80005bf8:	f0 1f 00 09 	mcall	80005c1c <memory_2_ram+0x54>

  Ctrl_access_unlock();
80005bfc:	30 09       	mov	r9,0
80005bfe:	12 9a       	mov	r10,r9
80005c00:	12 9b       	mov	r11,r9
80005c02:	48 88       	lddpc	r8,80005c20 <memory_2_ram+0x58>
80005c04:	70 0c       	ld.w	r12,r8[0x0]
80005c06:	f0 1f 00 08 	mcall	80005c24 <memory_2_ram+0x5c>

  return status;
}
80005c0a:	0e 9c       	mov	r12,r7
80005c0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	5b 3c       	cp.w	r12,-13
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	83 0c       	st.w	r1[0x0],r12
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	b0 f8       	st.b	r8[0x7],r8
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	83 68       	st.w	r1[0x18],r8
80005c20:	00 00       	add	r0,r0
80005c22:	74 c8       	ld.w	r8,r10[0x30]
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	74 c8       	ld.w	r8,r10[0x30]

80005c28 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
80005c28:	eb cd 40 80 	pushm	r7,lr
80005c2c:	18 97       	mov	r7,r12
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;
80005c2e:	f0 1f 00 0c 	mcall	80005c5c <mem_wr_protect+0x34>
80005c32:	c0 31       	brne	80005c38 <mem_wr_protect+0x10>
80005c34:	30 17       	mov	r7,1
80005c36:	c1 08       	rjmp	80005c56 <mem_wr_protect+0x2e>

  wr_protect =
80005c38:	58 07       	cp.w	r7,0
80005c3a:	c0 30       	breq	80005c40 <mem_wr_protect+0x18>
80005c3c:	30 17       	mov	r7,1
80005c3e:	c0 58       	rjmp	80005c48 <mem_wr_protect+0x20>
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
80005c40:	48 88       	lddpc	r8,80005c60 <mem_wr_protect+0x38>
80005c42:	70 3c       	ld.w	r12,r8[0xc]
80005c44:	5d 1c       	icall	r12
80005c46:	18 97       	mov	r7,r12
                                 Lun_usb_wr_protect(lun - LUN_ID_USB);
#else
                                 true;
#endif

  Ctrl_access_unlock();
80005c48:	30 09       	mov	r9,0
80005c4a:	12 9a       	mov	r10,r9
80005c4c:	12 9b       	mov	r11,r9
80005c4e:	48 68       	lddpc	r8,80005c64 <mem_wr_protect+0x3c>
80005c50:	70 0c       	ld.w	r12,r8[0x0]
80005c52:	f0 1f 00 06 	mcall	80005c68 <mem_wr_protect+0x40>

  return wr_protect;
}
80005c56:	0e 9c       	mov	r12,r7
80005c58:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	5b 3c       	cp.w	r12,-13
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	b0 f8       	st.b	r8[0x7],r8
80005c64:	00 00       	add	r0,r0
80005c66:	74 c8       	ld.w	r8,r10[0x30]
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	74 c8       	ld.w	r8,r10[0x30]

80005c6c <mem_sector_size>:
  return status;
}


U8 mem_sector_size(U8 lun)
{
80005c6c:	eb cd 40 80 	pushm	r7,lr
80005c70:	18 97       	mov	r7,r12
  U8 sector_size;

  if (!Ctrl_access_lock()) return 0;
80005c72:	f0 1f 00 0a 	mcall	80005c98 <mem_sector_size+0x2c>
80005c76:	c0 31       	brne	80005c7c <mem_sector_size+0x10>
80005c78:	30 07       	mov	r7,0
80005c7a:	c0 c8       	rjmp	80005c92 <mem_sector_size+0x26>

  sector_size =
80005c7c:	30 08       	mov	r8,0
80005c7e:	f0 07 18 00 	cp.b	r7,r8
80005c82:	5f 07       	sreq	r7
                                  Lun_usb_read_sector_size(lun - LUN_ID_USB);
#else
                                  0;
#endif

  Ctrl_access_unlock();
80005c84:	30 09       	mov	r9,0
80005c86:	12 9a       	mov	r10,r9
80005c88:	12 9b       	mov	r11,r9
80005c8a:	48 58       	lddpc	r8,80005c9c <mem_sector_size+0x30>
80005c8c:	70 0c       	ld.w	r12,r8[0x0]
80005c8e:	f0 1f 00 05 	mcall	80005ca0 <mem_sector_size+0x34>

  return sector_size;
}
80005c92:	0e 9c       	mov	r12,r7
80005c94:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c98:	80 00       	ld.sh	r0,r0[0x0]
80005c9a:	5b 3c       	cp.w	r12,-13
80005c9c:	00 00       	add	r0,r0
80005c9e:	74 c8       	ld.w	r8,r10[0x30]
80005ca0:	80 00       	ld.sh	r0,r0[0x0]
80005ca2:	74 c8       	ld.w	r8,r10[0x30]

80005ca4 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
80005ca4:	eb cd 40 80 	pushm	r7,lr
80005ca8:	18 97       	mov	r7,r12
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;
80005caa:	f0 1f 00 0c 	mcall	80005cd8 <mem_test_unit_ready+0x34>
80005cae:	c0 31       	brne	80005cb4 <mem_test_unit_ready+0x10>
80005cb0:	30 17       	mov	r7,1
80005cb2:	c1 08       	rjmp	80005cd2 <mem_test_unit_ready+0x2e>

  status =
80005cb4:	58 07       	cp.w	r7,0
80005cb6:	c0 30       	breq	80005cbc <mem_test_unit_ready+0x18>
80005cb8:	30 17       	mov	r7,1
80005cba:	c0 58       	rjmp	80005cc4 <mem_test_unit_ready+0x20>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
80005cbc:	48 88       	lddpc	r8,80005cdc <mem_test_unit_ready+0x38>
80005cbe:	70 0c       	ld.w	r12,r8[0x0]
80005cc0:	5d 1c       	icall	r12
80005cc2:	18 97       	mov	r7,r12
                             Lun_usb_test_unit_ready(lun - LUN_ID_USB);
#else
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();
80005cc4:	30 09       	mov	r9,0
80005cc6:	12 9a       	mov	r10,r9
80005cc8:	12 9b       	mov	r11,r9
80005cca:	48 68       	lddpc	r8,80005ce0 <mem_test_unit_ready+0x3c>
80005ccc:	70 0c       	ld.w	r12,r8[0x0]
80005cce:	f0 1f 00 06 	mcall	80005ce4 <mem_test_unit_ready+0x40>

  return status;
}
80005cd2:	0e 9c       	mov	r12,r7
80005cd4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	5b 3c       	cp.w	r12,-13
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	b0 f8       	st.b	r8[0x7],r8
80005ce0:	00 00       	add	r0,r0
80005ce2:	74 c8       	ld.w	r8,r10[0x30]
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	74 c8       	ld.w	r8,r10[0x30]

80005ce8 <ctrl_access_init>:


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
{
80005ce8:	d4 01       	pushm	lr
  // If the handle to the protecting semaphore is not valid,
  if (!ctrl_access_semphr)
80005cea:	48 d8       	lddpc	r8,80005d1c <ctrl_access_init+0x34>
80005cec:	70 08       	ld.w	r8,r8[0x0]
80005cee:	58 08       	cp.w	r8,0
80005cf0:	c0 20       	breq	80005cf4 <ctrl_access_init+0xc>
80005cf2:	da 0a       	popm	pc,r12=1
  {
    // try to create the semaphore.
    vSemaphoreCreateBinary(ctrl_access_semphr);
80005cf4:	30 3a       	mov	r10,3
80005cf6:	30 0b       	mov	r11,0
80005cf8:	30 1c       	mov	r12,1
80005cfa:	f0 1f 00 0a 	mcall	80005d20 <ctrl_access_init+0x38>
80005cfe:	48 88       	lddpc	r8,80005d1c <ctrl_access_init+0x34>
80005d00:	91 0c       	st.w	r8[0x0],r12
80005d02:	58 0c       	cp.w	r12,0
80005d04:	c0 a0       	breq	80005d18 <ctrl_access_init+0x30>
80005d06:	30 09       	mov	r9,0
80005d08:	12 9a       	mov	r10,r9
80005d0a:	12 9b       	mov	r11,r9
80005d0c:	f0 1f 00 06 	mcall	80005d24 <ctrl_access_init+0x3c>
//! @{


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
80005d10:	48 38       	lddpc	r8,80005d1c <ctrl_access_init+0x34>
80005d12:	70 08       	ld.w	r8,r8[0x0]
80005d14:	58 08       	cp.w	r8,0
80005d16:	5f 1c       	srne	r12
    // If the semaphore could not be created, there is no backup solution.
    if (!ctrl_access_semphr) return false;
  }

  return true;
}
80005d18:	d8 02       	popm	pc
80005d1a:	00 00       	add	r0,r0
80005d1c:	00 00       	add	r0,r0
80005d1e:	74 c8       	ld.w	r8,r10[0x30]
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	76 5c       	ld.w	r12,r11[0x14]
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	74 c8       	ld.w	r8,r10[0x30]

80005d28 <check_sd_card>:
	pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
	
}

void check_sd_card(void)
{
80005d28:	d4 01       	pushm	lr
	// NECESSARY: Initialize USART first.
	print_dbg("\r\nInit SD/MMC Driver");
80005d2a:	49 0c       	lddpc	r12,80005d68 <check_sd_card+0x40>
80005d2c:	f0 1f 00 10 	mcall	80005d6c <check_sd_card+0x44>
	print_dbg("\r\nInsert SD/MMC...");
80005d30:	49 0c       	lddpc	r12,80005d70 <check_sd_card+0x48>
80005d32:	f0 1f 00 0f 	mcall	80005d6c <check_sd_card+0x44>
		
	while (!sd_mmc_spi_mem_check());
80005d36:	f0 1f 00 10 	mcall	80005d74 <check_sd_card+0x4c>
80005d3a:	cf e0       	breq	80005d36 <check_sd_card+0xe>
	print_dbg("\r\nCard detected!");
80005d3c:	48 fc       	lddpc	r12,80005d78 <check_sd_card+0x50>
80005d3e:	f0 1f 00 0c 	mcall	80005d6c <check_sd_card+0x44>
		
	// Read Card capacity
	sd_mmc_spi_get_capacity();
80005d42:	f0 1f 00 0f 	mcall	80005d7c <check_sd_card+0x54>
	print_dbg("Capacity = ");
80005d46:	48 fc       	lddpc	r12,80005d80 <check_sd_card+0x58>
80005d48:	f0 1f 00 09 	mcall	80005d6c <check_sd_card+0x44>
	print_dbg_ulong(capacity >> 20);
80005d4c:	48 e8       	lddpc	r8,80005d84 <check_sd_card+0x5c>
80005d4e:	f0 e8 00 00 	ld.d	r8,r8[0]
80005d52:	f0 0c 16 14 	lsr	r12,r8,0x14
80005d56:	f9 e9 10 cc 	or	r12,r12,r9<<0xc
80005d5a:	f0 1f 00 0c 	mcall	80005d88 <check_sd_card+0x60>
	print_dbg(" MBytes\r\n");
80005d5e:	48 cc       	lddpc	r12,80005d8c <check_sd_card+0x64>
80005d60:	f0 1f 00 03 	mcall	80005d6c <check_sd_card+0x44>
}
80005d64:	d8 02       	popm	pc
80005d66:	00 00       	add	r0,r0
80005d68:	80 01       	ld.sh	r1,r0[0x0]
80005d6a:	ac 28       	st.h	r6[0x4],r8
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	69 a4       	ld.w	r4,r4[0x68]
80005d70:	80 01       	ld.sh	r1,r0[0x0]
80005d72:	ac 40       	st.h	r6[0x8],r0
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	34 d4       	mov	r4,77
80005d78:	80 01       	ld.sh	r1,r0[0x0]
80005d7a:	ac 54       	st.h	r6[0xa],r4
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	29 c0       	sub	r0,-100
80005d80:	80 01       	ld.sh	r1,r0[0x0]
80005d82:	ac 68       	st.h	r6[0xc],r8
80005d84:	00 00       	add	r0,r0
80005d86:	79 b4       	ld.w	r4,r12[0x6c]
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	69 90       	ld.w	r0,r4[0x64]
80005d8c:	80 01       	ld.sh	r1,r0[0x0]
80005d8e:	ac 74       	st.h	r6[0xe],r4

80005d90 <sd_mmc_resources_init>:

#include "conf_spi_sd.h"

// SPI
void sd_mmc_resources_init(void)
{
80005d90:	eb cd 40 80 	pushm	r7,lr
80005d94:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80005d96:	49 98       	lddpc	r8,80005df8 <sd_mmc_resources_init+0x68>
80005d98:	1a 97       	mov	r7,sp
80005d9a:	f0 ea 00 00 	ld.d	r10,r8[0]
80005d9e:	fa eb 00 00 	st.d	sp[0],r10
80005da2:	f0 e8 00 08 	ld.d	r8,r8[8]
80005da6:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
80005daa:	30 4b       	mov	r11,4
80005dac:	49 4c       	lddpc	r12,80005dfc <sd_mmc_resources_init+0x6c>
80005dae:	f0 1f 00 15 	mcall	80005e00 <sd_mmc_resources_init+0x70>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80005db2:	1a 9b       	mov	r11,sp
80005db4:	fe 7c 24 00 	mov	r12,-56320
80005db8:	f0 1f 00 13 	mcall	80005e04 <sd_mmc_resources_init+0x74>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
80005dbc:	30 09       	mov	r9,0
80005dbe:	12 9a       	mov	r10,r9
80005dc0:	12 9b       	mov	r11,r9
80005dc2:	fe 7c 24 00 	mov	r12,-56320
80005dc6:	f0 1f 00 11 	mcall	80005e08 <sd_mmc_resources_init+0x78>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
80005dca:	fe 7c 24 00 	mov	r12,-56320
80005dce:	f0 1f 00 10 	mcall	80005e0c <sd_mmc_resources_init+0x7c>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, PBA_HZ);
80005dd2:	20 4d       	sub	sp,16
80005dd4:	ee e8 00 00 	ld.d	r8,r7[0]
80005dd8:	fa e9 00 00 	st.d	sp[0],r8
80005ddc:	ee e8 00 08 	ld.d	r8,r7[8]
80005de0:	fa e9 00 08 	st.d	sp[8],r8
80005de4:	e0 6c 76 00 	mov	r12,30208
80005de8:	ea 1c 03 b3 	orh	r12,0x3b3
80005dec:	f0 1f 00 09 	mcall	80005e10 <sd_mmc_resources_init+0x80>
80005df0:	2f cd       	sub	sp,-16
	
}
80005df2:	2f cd       	sub	sp,-16
80005df4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005df8:	80 01       	ld.sh	r1,r0[0x0]
80005dfa:	ab f8       	*unknown*
80005dfc:	80 01       	ld.sh	r1,r0[0x0]
80005dfe:	ac 08       	st.h	r6[0x0],r8
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	84 1c       	ld.sh	r12,r2[0x2]
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	3a 3e       	mov	lr,-93
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	3a 76       	mov	r6,-89
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	3a a2       	mov	r2,-86
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	34 fc       	mov	r12,79

80005e14 <tpa6130_abdac_tx_pdca_int_handler>:
  .output_impedance    = TPA6130_OUTPUT_IMPEDANCE_DEFAULT,
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
80005e14:	d4 01       	pushm	lr
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
80005e16:	30 0c       	mov	r12,0
80005e18:	f0 1f 00 13 	mcall	80005e64 <tpa6130_abdac_tx_pdca_int_handler+0x50>
80005e1c:	e2 1c 00 02 	andl	r12,0x2,COH
80005e20:	c0 d0       	breq	80005e3a <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80005e22:	30 0c       	mov	r12,0
80005e24:	f0 1f 00 11 	mcall	80005e68 <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80005e28:	49 18       	lddpc	r8,80005e6c <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005e2a:	70 28       	ld.w	r8,r8[0x8]
80005e2c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e30:	c0 50       	breq	80005e3a <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
80005e32:	48 f8       	lddpc	r8,80005e6c <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005e34:	70 18       	ld.w	r8,r8[0x4]
80005e36:	30 1c       	mov	r12,1
80005e38:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
80005e3a:	30 0c       	mov	r12,0
80005e3c:	f0 1f 00 0a 	mcall	80005e64 <tpa6130_abdac_tx_pdca_int_handler+0x50>
80005e40:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005e44:	c0 d0       	breq	80005e5e <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80005e46:	30 0c       	mov	r12,0
80005e48:	f0 1f 00 0a 	mcall	80005e70 <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80005e4c:	48 88       	lddpc	r8,80005e6c <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005e4e:	70 28       	ld.w	r8,r8[0x8]
80005e50:	e2 18 00 02 	andl	r8,0x2,COH
80005e54:	c0 50       	breq	80005e5e <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
80005e56:	48 68       	lddpc	r8,80005e6c <tpa6130_abdac_tx_pdca_int_handler+0x58>
80005e58:	70 18       	ld.w	r8,r8[0x4]
80005e5a:	30 2c       	mov	r12,2
80005e5c:	5d 18       	icall	r8
  }
}
80005e5e:	d4 02       	popm	lr
80005e60:	d6 03       	rete
80005e62:	00 00       	add	r0,r0
80005e64:	80 00       	ld.sh	r0,r0[0x0]
80005e66:	64 ac       	ld.w	r12,r2[0x28]
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	64 e4       	ld.w	r4,r2[0x38]
80005e6c:	00 00       	add	r0,r0
80005e6e:	74 cc       	ld.w	r12,r10[0x30]
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	64 bc       	ld.w	r12,r2[0x2c]

80005e74 <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80005e74:	d4 21       	pushm	r4-r7,lr
80005e76:	20 5d       	sub	sp,20
80005e78:	18 94       	mov	r4,r12
80005e7a:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80005e7c:	f7 ec 10 88 	or	r8,r11,r12<<0x8
80005e80:	fb 58 00 12 	st.h	sp[18],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80005e84:	30 08       	mov	r8,0
80005e86:	30 09       	mov	r9,0
80005e88:	fa e9 00 00 	st.d	sp[0],r8
80005e8c:	36 08       	mov	r8,96
80005e8e:	ba 88       	st.b	sp[0x0],r8
80005e90:	fa c8 ff ee 	sub	r8,sp,-18
80005e94:	50 28       	stdsp	sp[0x8],r8
80005e96:	30 28       	mov	r8,2
80005e98:	50 38       	stdsp	sp[0xc],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
80005e9a:	1a 96       	mov	r6,sp
80005e9c:	fe 77 2c 00 	mov	r7,-54272
80005ea0:	1a 9b       	mov	r11,sp
80005ea2:	0e 9c       	mov	r12,r7
80005ea4:	f0 1f 00 05 	mcall	80005eb8 <tpa6130_write_data+0x44>
  }
  while( twi_status != TWI_SUCCESS );
80005ea8:	cf c1       	brne	80005ea0 <tpa6130_write_data+0x2c>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
80005eaa:	48 58       	lddpc	r8,80005ebc <tpa6130_write_data+0x48>
80005eac:	f0 04 00 04 	add	r4,r8,r4
80005eb0:	e9 65 ff ff 	st.b	r4[-1],r5
}
80005eb4:	2f bd       	sub	sp,-20
80005eb6:	d8 22       	popm	r4-r7,pc
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	66 a4       	ld.w	r4,r3[0x28]
80005ebc:	00 00       	add	r0,r0
80005ebe:	00 09       	add	r9,r0

80005ec0 <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
80005ec0:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
80005ec2:	33 f8       	mov	r8,63
80005ec4:	f0 0c 18 00 	cp.b	r12,r8
80005ec8:	e0 8a 00 04 	brle	80005ed0 <tpa6130_set_volume+0x10>
80005ecc:	33 fb       	mov	r11,63
80005ece:	c0 b8       	rjmp	80005ee4 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
80005ed0:	30 08       	mov	r8,0
80005ed2:	f0 0c 18 00 	cp.b	r12,r8
80005ed6:	e0 89 00 05 	brgt	80005ee0 <tpa6130_set_volume+0x20>
80005eda:	e0 6b 00 c0 	mov	r11,192
80005ede:	c0 38       	rjmp	80005ee4 <tpa6130_set_volume+0x24>
80005ee0:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
80005ee4:	30 2c       	mov	r12,2
80005ee6:	f0 1f 00 02 	mcall	80005eec <tpa6130_set_volume+0x2c>
}
80005eea:	d8 02       	popm	pc
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	5e 74       	retpl	r4

80005ef0 <tpa6130_dac_output>:
 * which contain two (16-bit) samples, one for each channel.
 *
 * \note The DACs must have been started beforehand.
 */
bool tpa6130_dac_output(void *sample_buffer, size_t sample_length)
{
80005ef0:	eb cd 40 c0 	pushm	r6-r7,lr
80005ef4:	18 96       	mov	r6,r12
80005ef6:	16 97       	mov	r7,r11
  //int global_interrupt_enabled;

  /*Wait until the PDCA loads the reload value to its transfer
   * counter register(TCRR=0). Then we are ready to set up a new
   * transfer */
  if(!(pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) &
80005ef8:	30 0c       	mov	r12,0
80005efa:	f0 1f 00 11 	mcall	80005f3c <tpa6130_dac_output+0x4c>
80005efe:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005f02:	c1 b0       	breq	80005f38 <tpa6130_dac_output+0x48>
  {
    return false;
  }

  /* Nothing to do if we get no data. */
  if(sample_length)
80005f04:	58 07       	cp.w	r7,0
80005f06:	c1 80       	breq	80005f36 <tpa6130_dac_output+0x46>
    //if((global_interrupt_enabled = cpu_irq_is_enabled()))
    //  cpu_irq_disable();

    /*FIXME This assumes a stereo 16-bit sample size */
    // one sample here consists of 2x16-bit (16-bit stereo)
    pdca_reload_channel(TPA6130_ABDAC_PDCA_CHANNEL,
80005f08:	0e 9a       	mov	r10,r7
80005f0a:	0c 9b       	mov	r11,r6
80005f0c:	30 0c       	mov	r12,0
80005f0e:	f0 1f 00 0d 	mcall	80005f40 <tpa6130_dac_output+0x50>
    //if(global_interrupt_enabled)
    //  cpu_irq_enable();

    /*TODO enable transfer complete interrupt
     * Is it possible to move this to setup or other places?*/
    if(tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80005f12:	48 d8       	lddpc	r8,80005f44 <tpa6130_dac_output+0x54>
80005f14:	70 28       	ld.w	r8,r8[0x8]
80005f16:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005f1a:	c0 40       	breq	80005f22 <tpa6130_dac_output+0x32>
      pdca_enable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80005f1c:	30 0c       	mov	r12,0
80005f1e:	f0 1f 00 0b 	mcall	80005f48 <tpa6130_dac_output+0x58>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80005f22:	48 98       	lddpc	r8,80005f44 <tpa6130_dac_output+0x54>
80005f24:	70 28       	ld.w	r8,r8[0x8]
80005f26:	e2 18 00 02 	andl	r8,0x2,COH
80005f2a:	c0 60       	breq	80005f36 <tpa6130_dac_output+0x46>
      pdca_enable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80005f2c:	30 0c       	mov	r12,0
80005f2e:	f0 1f 00 08 	mcall	80005f4c <tpa6130_dac_output+0x5c>
80005f32:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f36:	30 1c       	mov	r12,1
  }
  return true;
}
80005f38:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	64 ac       	ld.w	r12,r2[0x28]
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	65 0c       	ld.w	r12,r2[0x40]
80005f44:	00 00       	add	r0,r0
80005f46:	74 cc       	ld.w	r12,r10[0x30]
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	64 8c       	ld.w	r12,r2[0x20]
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	64 9c       	ld.w	r12,r2[0x24]

80005f50 <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
80005f50:	d4 01       	pushm	lr
80005f52:	20 5d       	sub	sp,20
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
80005f54:	58 0b       	cp.w	r11,0
80005f56:	c0 90       	breq	80005f68 <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
80005f58:	48 f8       	lddpc	r8,80005f94 <tpa6130_read_data+0x44>
80005f5a:	f0 0c 00 0c 	add	r12,r8,r12
80005f5e:	f9 38 ff ff 	ld.ub	r8,r12[-1]
80005f62:	fb 68 00 13 	st.b	sp[19],r8
80005f66:	c1 38       	rjmp	80005f8c <tpa6130_read_data+0x3c>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr[0] = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
80005f68:	30 08       	mov	r8,0
80005f6a:	30 09       	mov	r9,0
80005f6c:	fa e9 00 00 	st.d	sp[0],r8
80005f70:	36 08       	mov	r8,96
80005f72:	ba 88       	st.b	sp[0x0],r8
80005f74:	ba 9c       	st.b	sp[0x1],r12
80005f76:	30 18       	mov	r8,1
80005f78:	50 18       	stdsp	sp[0x4],r8
80005f7a:	fa c9 ff ed 	sub	r9,sp,-19
80005f7e:	50 29       	stdsp	sp[0x8],r9
80005f80:	50 38       	stdsp	sp[0xc],r8
    twi_master_read(TPA6130_TWI, &twi_package);
80005f82:	1a 9b       	mov	r11,sp
80005f84:	fe 7c 2c 00 	mov	r12,-54272
80005f88:	f0 1f 00 04 	mcall	80005f98 <tpa6130_read_data+0x48>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80005f8c:	fb 3c 00 13 	ld.ub	r12,sp[19]
80005f90:	2f bd       	sub	sp,-20
80005f92:	d8 02       	popm	pc
80005f94:	00 00       	add	r0,r0
80005f96:	00 09       	add	r9,r0
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	67 7c       	ld.w	r12,r3[0x5c]

80005f9c <tpa6130_get_volume>:
/*! \brief Gets the current volume settings.
 *  \returns Current volume settings. Value is between 0 (-59dB) and
 *  63 (4dB).
 */
int8_t tpa6130_get_volume(void)
{
80005f9c:	d4 01       	pushm	lr
  return tpa6130_read_data(TPA6130_VOLUME_AND_MUTE, TWI_READ_SR);
80005f9e:	30 1b       	mov	r11,1
80005fa0:	30 2c       	mov	r12,2
80005fa2:	f0 1f 00 03 	mcall	80005fac <tpa6130_get_volume+0x10>
}
80005fa6:	5c 5c       	castu.b	r12
80005fa8:	d8 02       	popm	pc
80005faa:	00 00       	add	r0,r0
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	5f 50       	srlt	r0

80005fb0 <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
80005fb0:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
80005fb2:	30 0b       	mov	r11,0
80005fb4:	30 1c       	mov	r12,1
80005fb6:	f0 1f 00 05 	mcall	80005fc8 <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
80005fba:	18 9b       	mov	r11,r12
80005fbc:	e2 1b 00 fe 	andl	r11,0xfe,COH
80005fc0:	30 1c       	mov	r12,1
80005fc2:	f0 1f 00 03 	mcall	80005fcc <tpa6130_powerup+0x1c>
}
80005fc6:	d8 02       	popm	pc
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	5f 50       	srlt	r0
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	5e 74       	retpl	r4

80005fd0 <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
80005fd0:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
80005fd2:	30 0b       	mov	r11,0
80005fd4:	30 1c       	mov	r12,1
80005fd6:	f0 1f 00 05 	mcall	80005fe8 <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
80005fda:	18 9b       	mov	r11,r12
80005fdc:	a1 ab       	sbr	r11,0x0
80005fde:	5c 5b       	castu.b	r11
80005fe0:	30 1c       	mov	r12,1
80005fe2:	f0 1f 00 03 	mcall	80005fec <tpa6130_shutdown+0x1c>
}
80005fe6:	d8 02       	popm	pc
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	5f 50       	srlt	r0
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	5e 74       	retpl	r4

80005ff0 <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
80005ff0:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
80005ff2:	f0 1f 00 0b 	mcall	8000601c <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
80005ff6:	fe 7c 40 00 	mov	r12,-49152
80005ffa:	f0 1f 00 0a 	mcall	80006020 <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
80005ffe:	30 0c       	mov	r12,0
80006000:	f0 1f 00 09 	mcall	80006024 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
80006004:	30 4b       	mov	r11,4
80006006:	48 9c       	lddpc	r12,80006028 <tpa6130_dac_stop+0x38>
80006008:	f0 1f 00 09 	mcall	8000602c <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
8000600c:	48 98       	lddpc	r8,80006030 <tpa6130_dac_stop+0x40>
8000600e:	30 09       	mov	r9,0
80006010:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
80006012:	30 09       	mov	r9,0
80006014:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
80006016:	91 29       	st.w	r8[0x8],r9
}
80006018:	d8 02       	popm	pc
8000601a:	00 00       	add	r0,r0
8000601c:	80 00       	ld.sh	r0,r0[0x0]
8000601e:	5f d0       	srvc	r0
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	61 94       	ld.w	r4,r0[0x64]
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	64 6c       	ld.w	r12,r2[0x18]
80006028:	80 01       	ld.sh	r1,r0[0x0]
8000602a:	ac 98       	st.b	r6[0x1],r8
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	84 64       	ld.sh	r4,r2[0xc]
80006030:	00 00       	add	r0,r0
80006032:	74 cc       	ld.w	r12,r10[0x30]

80006034 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
80006034:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
80006036:	36 0b       	mov	r11,96
80006038:	fe 7c 2c 00 	mov	r12,-54272
8000603c:	f0 1f 00 0e 	mcall	80006074 <tpa6130_init+0x40>
80006040:	c0 40       	breq	80006048 <tpa6130_init+0x14>
80006042:	e0 6c 00 fd 	mov	r12,253
80006046:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
80006048:	30 0b       	mov	r11,0
8000604a:	30 4c       	mov	r12,4
8000604c:	f0 1f 00 0b 	mcall	80006078 <tpa6130_init+0x44>
80006050:	30 28       	mov	r8,2
80006052:	f0 0c 18 00 	cp.b	r12,r8
80006056:	c0 40       	breq	8000605e <tpa6130_init+0x2a>
80006058:	e0 6c 00 f8 	mov	r12,248
8000605c:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
8000605e:	48 88       	lddpc	r8,8000607c <tpa6130_init+0x48>
80006060:	11 9b       	ld.ub	r11,r8[0x1]
80006062:	30 2c       	mov	r12,2
80006064:	f0 1f 00 07 	mcall	80006080 <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
80006068:	e0 6b 00 c0 	mov	r11,192
8000606c:	30 1c       	mov	r12,1
8000606e:	f0 1f 00 05 	mcall	80006080 <tpa6130_init+0x4c>
80006072:	d8 0a       	popm	pc,r12=0
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	67 54       	ld.w	r4,r3[0x54]
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	5f 50       	srlt	r0
8000607c:	00 00       	add	r0,r0
8000607e:	00 09       	add	r9,r0
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	5e 74       	retpl	r4

80006084 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80006084:	eb cd 40 c0 	pushm	r6-r7,lr
80006088:	20 6d       	sub	sp,24
8000608a:	18 97       	mov	r7,r12
8000608c:	12 96       	mov	r6,r9
8000608e:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
80006090:	49 a9       	lddpc	r9,800060f8 <tpa6130_dac_setup+0x74>
80006092:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80006094:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
80006096:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
80006098:	f0 1f 00 19 	mcall	800060fc <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
8000609c:	0e 9c       	mov	r12,r7
8000609e:	f0 1f 00 19 	mcall	80006100 <tpa6130_dac_setup+0x7c>
800060a2:	c0 a1       	brne	800060b6 <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
800060a4:	0e 9a       	mov	r10,r7
800060a6:	e0 6b 44 00 	mov	r11,17408
800060aa:	ea 1b 00 ac 	orh	r11,0xac
800060ae:	fe 7c 40 00 	mov	r12,-49152
800060b2:	f0 1f 00 15 	mcall	80006104 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
800060b6:	58 06       	cp.w	r6,0
800060b8:	c0 50       	breq	800060c2 <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
800060ba:	fe 7c 40 00 	mov	r12,-49152
800060be:	f0 1f 00 13 	mcall	80006108 <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
800060c2:	fe 7c 40 00 	mov	r12,-49152
800060c6:	f0 1f 00 12 	mcall	8000610c <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
800060ca:	49 28       	lddpc	r8,80006110 <tpa6130_dac_setup+0x8c>
800060cc:	1a 9b       	mov	r11,sp
800060ce:	f0 e6 00 00 	ld.d	r6,r8[0]
800060d2:	fa e7 00 00 	st.d	sp[0],r6
800060d6:	f0 e6 00 08 	ld.d	r6,r8[8]
800060da:	fa e7 00 08 	st.d	sp[8],r6
800060de:	f0 e8 00 10 	ld.d	r8,r8[16]
800060e2:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800060e6:	30 0c       	mov	r12,0
800060e8:	f0 1f 00 0b 	mcall	80006114 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
800060ec:	30 0c       	mov	r12,0
800060ee:	f0 1f 00 0b 	mcall	80006118 <tpa6130_dac_setup+0x94>

}
800060f2:	2f ad       	sub	sp,-24
800060f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060f8:	00 00       	add	r0,r0
800060fa:	74 cc       	ld.w	r12,r10[0x30]
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	60 34       	ld.w	r4,r0[0xc]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	62 40       	ld.w	r0,r1[0x10]
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	61 c2       	ld.w	r2,r0[0x70]
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	61 aa       	ld.w	r10,r0[0x68]
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	61 80       	ld.w	r0,r0[0x60]
80006110:	80 01       	ld.sh	r1,r0[0x0]
80006112:	ac 80       	st.b	r6[0x0],r0
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	65 44       	ld.w	r4,r2[0x50]
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	64 7c       	ld.w	r12,r2[0x1c]

8000611c <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
8000611c:	eb cd 40 fe 	pushm	r1-r7,lr
80006120:	fa c4 ff e0 	sub	r4,sp,-32
80006124:	18 92       	mov	r2,r12
80006126:	16 93       	mov	r3,r11
80006128:	14 95       	mov	r5,r10
8000612a:	12 97       	mov	r7,r9
8000612c:	10 96       	mov	r6,r8
8000612e:	68 01       	ld.w	r1,r4[0x0]
80006130:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
80006132:	f0 1f 00 0d 	mcall	80006164 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
80006136:	30 4b       	mov	r11,4
80006138:	48 cc       	lddpc	r12,80006168 <tpa6130_dac_start+0x4c>
8000613a:	f0 1f 00 0d 	mcall	8000616c <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
8000613e:	1a d4       	st.w	--sp,r4
80006140:	1a d1       	st.w	--sp,r1
80006142:	0c 98       	mov	r8,r6
80006144:	0e 99       	mov	r9,r7
80006146:	0a 9a       	mov	r10,r5
80006148:	06 9b       	mov	r11,r3
8000614a:	04 9c       	mov	r12,r2
8000614c:	f0 1f 00 09 	mcall	80006170 <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
80006150:	30 1a       	mov	r10,1
80006152:	36 0b       	mov	r11,96
80006154:	48 8c       	lddpc	r12,80006174 <tpa6130_dac_start+0x58>
80006156:	f0 1f 00 09 	mcall	80006178 <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
8000615a:	f0 1f 00 09 	mcall	8000617c <tpa6130_dac_start+0x60>
8000615e:	2f ed       	sub	sp,-8

}
80006160:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	5f f0       	sral	r0
80006168:	80 01       	ld.sh	r1,r0[0x0]
8000616a:	ac 98       	st.b	r6[0x1],r8
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	84 1c       	ld.sh	r12,r2[0x2]
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	60 84       	ld.w	r4,r0[0x20]
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	5e 14       	retne	r4
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	85 3c       	st.w	r2[0xc],r12
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	5f b0       	srhi	r0

80006180 <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80006180:	fe 78 0c 00 	mov	r8,-62464
80006184:	71 d9       	ld.w	r9,r8[0x74]
80006186:	a3 a9       	sbr	r9,0x2
80006188:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
8000618c:	78 28       	ld.w	r8,r12[0x8]
8000618e:	bf b8       	sbr	r8,0x1f
80006190:	99 28       	st.w	r12[0x8],r8
}
80006192:	5e fc       	retal	r12

80006194 <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
80006194:	78 28       	ld.w	r8,r12[0x8]
80006196:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000619a:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
8000619c:	fe 78 0c 00 	mov	r8,-62464
800061a0:	71 d9       	ld.w	r9,r8[0x74]
800061a2:	a3 c9       	cbr	r9,0x2
800061a4:	f1 49 00 74 	st.w	r8[116],r9
}
800061a8:	5e fc       	retal	r12

800061aa <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
800061aa:	78 28       	ld.w	r8,r12[0x8]
800061ac:	e6 18 40 00 	andh	r8,0x4000,COH
800061b0:	c0 50       	breq	800061ba <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
800061b2:	78 28       	ld.w	r8,r12[0x8]
800061b4:	bf c8       	cbr	r8,0x1e
800061b6:	99 28       	st.w	r12[0x8],r8
800061b8:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
800061ba:	78 28       	ld.w	r8,r12[0x8]
800061bc:	bf a8       	sbr	r8,0x1e
800061be:	99 28       	st.w	r12[0x8],r8
800061c0:	5e fc       	retal	r12

800061c2 <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800061c2:	fe 78 0c 00 	mov	r8,-62464
800061c6:	71 d9       	ld.w	r9,r8[0x74]
800061c8:	30 0c       	mov	r12,0
800061ca:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800061ce:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
800061d2:	71 d9       	ld.w	r9,r8[0x74]
800061d4:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800061d8:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
800061dc:	a9 6a       	lsl	r10,0x8
800061de:	16 3a       	cp.w	r10,r11
800061e0:	e0 88 00 09 	brls	800061f2 <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
800061e4:	71 d9       	ld.w	r9,r8[0x74]
800061e6:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800061ea:	f1 49 00 74 	st.w	r8[116],r9
800061ee:	31 6c       	mov	r12,22
    return EINVAL;
800061f0:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
800061f2:	f6 0a 0d 08 	divu	r8,r11,r10
800061f6:	5c 88       	casts.h	r8

  if (div > 1) {
800061f8:	30 19       	mov	r9,1
800061fa:	f2 08 19 00 	cp.h	r8,r9
800061fe:	e0 88 00 14 	brls	80006226 <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
80006202:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
80006206:	20 1c       	sub	r12,1
80006208:	5c 5c       	castu.b	r12
8000620a:	fe 79 0c 00 	mov	r9,-62464
8000620e:	73 da       	ld.w	r10,r9[0x74]
80006210:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
80006214:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
80006218:	73 da       	ld.w	r10,r9[0x74]
8000621a:	30 1c       	mov	r12,1
8000621c:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80006220:	f3 4a 00 74 	st.w	r9[116],r10
80006224:	c0 98       	rjmp	80006236 <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80006226:	fe 79 0c 00 	mov	r9,-62464
8000622a:	73 da       	ld.w	r10,r9[0x74]
8000622c:	30 0c       	mov	r12,0
8000622e:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80006232:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
80006236:	5c 78       	castu.h	r8
80006238:	a9 68       	lsl	r8,0x8
8000623a:	f6 08 0d 0a 	divu	r10,r11,r8
8000623e:	5e fa       	retal	r10

80006240 <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80006240:	e0 4c 56 22 	cp.w	r12,22050
80006244:	e0 80 00 8d 	breq	8000635e <abdac_set_dac_sample_rate+0x11e>
80006248:	e0 8b 00 12 	brhi	8000626c <abdac_set_dac_sample_rate+0x2c>
8000624c:	e0 4c 2b 11 	cp.w	r12,11025
80006250:	c3 b0       	breq	800062c6 <abdac_set_dac_sample_rate+0x86>
80006252:	e0 8b 00 06 	brhi	8000625e <abdac_set_dac_sample_rate+0x1e>
80006256:	e0 4c 1f 40 	cp.w	r12,8000
8000625a:	c1 b1       	brne	80006290 <abdac_set_dac_sample_rate+0x50>
8000625c:	c1 b8       	rjmp	80006292 <abdac_set_dac_sample_rate+0x52>
8000625e:	e0 4c 2e e0 	cp.w	r12,12000
80006262:	c4 b0       	breq	800062f8 <abdac_set_dac_sample_rate+0xb8>
80006264:	e0 4c 3e 80 	cp.w	r12,16000
80006268:	c1 41       	brne	80006290 <abdac_set_dac_sample_rate+0x50>
8000626a:	c6 18       	rjmp	8000632c <abdac_set_dac_sample_rate+0xec>
8000626c:	e0 4c 7d 00 	cp.w	r12,32000
80006270:	e0 80 00 aa 	breq	800063c4 <abdac_set_dac_sample_rate+0x184>
80006274:	e0 8b 00 06 	brhi	80006280 <abdac_set_dac_sample_rate+0x40>
80006278:	e0 4c 5d c0 	cp.w	r12,24000
8000627c:	c0 a1       	brne	80006290 <abdac_set_dac_sample_rate+0x50>
8000627e:	c8 98       	rjmp	80006390 <abdac_set_dac_sample_rate+0x150>
80006280:	e0 4c ac 44 	cp.w	r12,44100
80006284:	e0 80 00 b9 	breq	800063f6 <abdac_set_dac_sample_rate+0x1b6>
80006288:	e0 4c bb 80 	cp.w	r12,48000
8000628c:	e0 80 00 ce 	breq	80006428 <abdac_set_dac_sample_rate+0x1e8>
80006290:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80006292:	fe 78 0c 00 	mov	r8,-62464
80006296:	71 d9       	ld.w	r9,r8[0x74]
80006298:	30 ea       	mov	r10,14
8000629a:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000629e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800062a2:	71 d9       	ld.w	r9,r8[0x74]
800062a4:	30 1c       	mov	r12,1
800062a6:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800062aa:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800062ae:	71 d9       	ld.w	r9,r8[0x74]
800062b0:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800062b4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800062b8:	71 d9       	ld.w	r9,r8[0x74]
800062ba:	30 0a       	mov	r10,0
800062bc:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800062c0:	f1 49 00 74 	st.w	r8[116],r9
      break;
800062c4:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
800062c6:	fe 78 0c 00 	mov	r8,-62464
800062ca:	71 d9       	ld.w	r9,r8[0x74]
800062cc:	30 1c       	mov	r12,1
800062ce:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
800062d2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800062d6:	71 d9       	ld.w	r9,r8[0x74]
800062d8:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800062dc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800062e0:	71 d9       	ld.w	r9,r8[0x74]
800062e2:	30 0a       	mov	r10,0
800062e4:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
800062e8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
800062ec:	71 d9       	ld.w	r9,r8[0x74]
800062ee:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800062f2:	f1 49 00 74 	st.w	r8[116],r9
        break;
800062f6:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
800062f8:	fe 78 0c 00 	mov	r8,-62464
800062fc:	71 d9       	ld.w	r9,r8[0x74]
800062fe:	30 9a       	mov	r10,9
80006300:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80006304:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80006308:	71 d9       	ld.w	r9,r8[0x74]
8000630a:	30 1c       	mov	r12,1
8000630c:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80006310:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80006314:	71 d9       	ld.w	r9,r8[0x74]
80006316:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
8000631a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
8000631e:	71 d9       	ld.w	r9,r8[0x74]
80006320:	30 0a       	mov	r10,0
80006322:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80006326:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000632a:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
8000632c:	fe 78 0c 00 	mov	r8,-62464
80006330:	71 d9       	ld.w	r9,r8[0x74]
80006332:	30 5a       	mov	r10,5
80006334:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80006338:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
8000633c:	71 d9       	ld.w	r9,r8[0x74]
8000633e:	30 1c       	mov	r12,1
80006340:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80006344:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80006348:	71 d9       	ld.w	r9,r8[0x74]
8000634a:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
8000634e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80006352:	71 d9       	ld.w	r9,r8[0x74]
80006354:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80006358:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000635c:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
8000635e:	fe 78 0c 00 	mov	r8,-62464
80006362:	71 d9       	ld.w	r9,r8[0x74]
80006364:	30 0a       	mov	r10,0
80006366:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000636a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
8000636e:	71 d9       	ld.w	r9,r8[0x74]
80006370:	30 1c       	mov	r12,1
80006372:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80006376:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
8000637a:	71 d9       	ld.w	r9,r8[0x74]
8000637c:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80006380:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80006384:	71 d9       	ld.w	r9,r8[0x74]
80006386:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000638a:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000638e:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80006390:	fe 78 0c 00 	mov	r8,-62464
80006394:	71 d9       	ld.w	r9,r8[0x74]
80006396:	30 4a       	mov	r10,4
80006398:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000639c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800063a0:	71 d9       	ld.w	r9,r8[0x74]
800063a2:	30 1c       	mov	r12,1
800063a4:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800063a8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800063ac:	71 d9       	ld.w	r9,r8[0x74]
800063ae:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800063b2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800063b6:	71 d9       	ld.w	r9,r8[0x74]
800063b8:	30 0a       	mov	r10,0
800063ba:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800063be:	f1 49 00 74 	st.w	r8[116],r9
        break;
800063c2:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
800063c4:	fe 78 0c 00 	mov	r8,-62464
800063c8:	71 d9       	ld.w	r9,r8[0x74]
800063ca:	30 2a       	mov	r10,2
800063cc:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800063d0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800063d4:	71 d9       	ld.w	r9,r8[0x74]
800063d6:	30 1c       	mov	r12,1
800063d8:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800063dc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800063e0:	71 d9       	ld.w	r9,r8[0x74]
800063e2:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800063e6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
800063ea:	71 d9       	ld.w	r9,r8[0x74]
800063ec:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800063f0:	f1 49 00 74 	st.w	r8[116],r9
        break;
800063f4:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
800063f6:	fe 78 0c 00 	mov	r8,-62464
800063fa:	71 da       	ld.w	r10,r8[0x74]
800063fc:	30 09       	mov	r9,0
800063fe:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
80006402:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
80006406:	71 da       	ld.w	r10,r8[0x74]
80006408:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
8000640c:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80006410:	71 da       	ld.w	r10,r8[0x74]
80006412:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
80006416:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
8000641a:	71 d9       	ld.w	r9,r8[0x74]
8000641c:	30 1c       	mov	r12,1
8000641e:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80006422:	f1 49 00 74 	st.w	r8[116],r9
        break;
80006426:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80006428:	fe 78 0c 00 	mov	r8,-62464
8000642c:	71 d9       	ld.w	r9,r8[0x74]
8000642e:	30 1c       	mov	r12,1
80006430:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80006434:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80006438:	71 d9       	ld.w	r9,r8[0x74]
8000643a:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000643e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80006442:	71 d9       	ld.w	r9,r8[0x74]
80006444:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80006448:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
8000644c:	71 d9       	ld.w	r9,r8[0x74]
8000644e:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80006452:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
80006456:	5e fc       	retal	r12

80006458 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80006458:	30 e8       	mov	r8,14
8000645a:	f0 0c 18 00 	cp.b	r12,r8
8000645e:	e0 88 00 03 	brls	80006464 <pdca_get_handler+0xc>
80006462:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80006464:	a7 6c       	lsl	r12,0x6
80006466:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
8000646a:	5e fc       	retal	r12

8000646c <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
8000646c:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000646e:	f0 1f 00 03 	mcall	80006478 <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80006472:	30 28       	mov	r8,2
80006474:	99 58       	st.w	r12[0x14],r8
}
80006476:	d8 02       	popm	pc
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	64 58       	ld.w	r8,r2[0x14]

8000647c <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
8000647c:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000647e:	f0 1f 00 03 	mcall	80006488 <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
80006482:	30 18       	mov	r8,1
80006484:	99 58       	st.w	r12[0x14],r8
}
80006486:	d8 02       	popm	pc
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	64 58       	ld.w	r8,r2[0x14]

8000648c <pdca_enable_interrupt_transfer_complete>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
8000648c:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000648e:	f0 1f 00 03 	mcall	80006498 <pdca_enable_interrupt_transfer_complete+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80006492:	30 28       	mov	r8,2
80006494:	99 88       	st.w	r12[0x20],r8
}
80006496:	d8 02       	popm	pc
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	64 58       	ld.w	r8,r2[0x14]

8000649c <pdca_enable_interrupt_reload_counter_zero>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
8000649c:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000649e:	f0 1f 00 03 	mcall	800064a8 <pdca_enable_interrupt_reload_counter_zero+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
800064a2:	30 18       	mov	r8,1
800064a4:	99 88       	st.w	r12[0x20],r8
}
800064a6:	d8 02       	popm	pc
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	64 58       	ld.w	r8,r2[0x14]

800064ac <pdca_get_transfer_status>:

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
800064ac:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800064ae:	f0 1f 00 03 	mcall	800064b8 <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
800064b2:	78 bc       	ld.w	r12,r12[0x2c]
}
800064b4:	d8 02       	popm	pc
800064b6:	00 00       	add	r0,r0
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	64 58       	ld.w	r8,r2[0x14]

800064bc <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800064bc:	d4 01       	pushm	lr
800064be:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800064c0:	f0 1f 00 08 	mcall	800064e0 <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800064c4:	e1 b8 00 00 	mfsr	r8,0x0
800064c8:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800064ca:	d3 03       	ssrf	0x10

	return flags;
800064cc:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800064ce:	30 19       	mov	r9,1
800064d0:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800064d2:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800064d4:	e6 18 00 01 	andh	r8,0x1,COH
800064d8:	c0 21       	brne	800064dc <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
800064da:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800064dc:	2f fd       	sub	sp,-4
800064de:	d8 02       	popm	pc
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	64 58       	ld.w	r8,r2[0x14]

800064e4 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800064e4:	d4 01       	pushm	lr
800064e6:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800064e8:	f0 1f 00 08 	mcall	80006508 <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800064ec:	e1 b8 00 00 	mfsr	r8,0x0
800064f0:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800064f2:	d3 03       	ssrf	0x10

	return flags;
800064f4:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800064f6:	30 29       	mov	r9,2
800064f8:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800064fa:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800064fc:	e6 18 00 01 	andh	r8,0x1,COH
80006500:	c0 21       	brne	80006504 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
80006502:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80006504:	2f fd       	sub	sp,-4
80006506:	d8 02       	popm	pc
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	64 58       	ld.w	r8,r2[0x14]

8000650c <pdca_reload_channel>:
	return pdca_channel->tcrr;
}

void pdca_reload_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
8000650c:	eb cd 40 c0 	pushm	r6-r7,lr
80006510:	20 1d       	sub	sp,4
80006512:	16 96       	mov	r6,r11
80006514:	14 97       	mov	r7,r10
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80006516:	f0 1f 00 0b 	mcall	80006540 <pdca_reload_channel+0x34>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000651a:	e1 b8 00 00 	mfsr	r8,0x0
8000651e:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80006520:	d3 03       	ssrf	0x10

	return flags;
80006522:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	/* set up next memory address */
	pdca_channel->marr = (uint32_t)addr;
80006524:	99 36       	st.w	r12[0xc],r6
	/* set up next memory size */
	pdca_channel->tcrr = size;
80006526:	99 47       	st.w	r12[0x10],r7
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80006528:	e0 69 01 00 	mov	r9,256
8000652c:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
8000652e:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006530:	e6 18 00 01 	andh	r8,0x1,COH
80006534:	c0 21       	brne	80006538 <pdca_reload_channel+0x2c>
      cpu_irq_enable();
80006536:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80006538:	2f fd       	sub	sp,-4
8000653a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000653e:	00 00       	add	r0,r0
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	64 58       	ld.w	r8,r2[0x14]

80006544 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80006544:	eb cd 40 e0 	pushm	r5-r7,lr
80006548:	20 1d       	sub	sp,4
8000654a:	18 95       	mov	r5,r12
8000654c:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000654e:	f0 1f 00 13 	mcall	80006598 <pdca_init_channel+0x54>
80006552:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80006554:	0a 9c       	mov	r12,r5
80006556:	f0 1f 00 12 	mcall	8000659c <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
8000655a:	0a 9c       	mov	r12,r5
8000655c:	f0 1f 00 11 	mcall	800065a0 <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006560:	e1 b8 00 00 	mfsr	r8,0x0
80006564:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80006566:	d3 03       	ssrf	0x10

	return flags;
80006568:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
8000656a:	6c 09       	ld.w	r9,r6[0x0]
8000656c:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
8000656e:	6c 19       	ld.w	r9,r6[0x4]
80006570:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
80006572:	6c 49       	ld.w	r9,r6[0x10]
80006574:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
80006576:	6c 29       	ld.w	r9,r6[0x8]
80006578:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
8000657a:	6c 39       	ld.w	r9,r6[0xc]
8000657c:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
8000657e:	6c 59       	ld.w	r9,r6[0x14]
80006580:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80006582:	e0 69 01 00 	mov	r9,256
80006586:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
80006588:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000658a:	e6 18 00 01 	andh	r8,0x1,COH
8000658e:	c0 21       	brne	80006592 <pdca_init_channel+0x4e>
      cpu_irq_enable();
80006590:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80006592:	2f fd       	sub	sp,-4
80006594:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	64 58       	ld.w	r8,r2[0x14]
8000659c:	80 00       	ld.sh	r0,r0[0x0]
8000659e:	64 e4       	ld.w	r4,r2[0x38]
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	64 bc       	ld.w	r12,r2[0x2c]

800065a4 <twi_master_interrupt_handler_not_naked>:
/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
800065a4:	4a 78       	lddpc	r8,80006640 <twi_master_interrupt_handler_not_naked+0x9c>
800065a6:	70 08       	ld.w	r8,r8[0x0]
800065a8:	70 89       	ld.w	r9,r8[0x20]
800065aa:	4a 7a       	lddpc	r10,80006644 <twi_master_interrupt_handler_not_naked+0xa0>
800065ac:	74 0a       	ld.w	r10,r10[0x0]
800065ae:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800065b2:	12 9a       	mov	r10,r9
800065b4:	e2 1a 01 00 	andl	r10,0x100,COH
800065b8:	c3 91       	brne	8000662a <twi_master_interrupt_handler_not_naked+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800065ba:	12 9a       	mov	r10,r9
800065bc:	e2 1a 00 02 	andl	r10,0x2,COH
800065c0:	c1 70       	breq	800065ee <twi_master_interrupt_handler_not_naked+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800065c2:	4a 29       	lddpc	r9,80006648 <twi_master_interrupt_handler_not_naked+0xa4>
800065c4:	72 0a       	ld.w	r10,r9[0x0]
800065c6:	70 cb       	ld.w	r11,r8[0x30]
800065c8:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
800065ca:	72 0a       	ld.w	r10,r9[0x0]
800065cc:	2f fa       	sub	r10,-1
800065ce:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800065d0:	49 f9       	lddpc	r9,8000664c <twi_master_interrupt_handler_not_naked+0xa8>
800065d2:	72 0a       	ld.w	r10,r9[0x0]
800065d4:	20 1a       	sub	r10,1
800065d6:	93 0a       	st.w	r9[0x0],r10
800065d8:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800065da:	58 19       	cp.w	r9,1
800065dc:	f9 b9 00 02 	moveq	r9,2
800065e0:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800065e4:	49 a9       	lddpc	r9,8000664c <twi_master_interrupt_handler_not_naked+0xa8>
800065e6:	72 09       	ld.w	r9,r9[0x0]
800065e8:	58 09       	cp.w	r9,0
800065ea:	c2 30       	breq	80006630 <twi_master_interrupt_handler_not_naked+0x8c>
800065ec:	5e fc       	retal	r12
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800065ee:	12 9a       	mov	r10,r9
800065f0:	e2 1a 00 04 	andl	r10,0x4,COH
800065f4:	c1 70       	breq	80006622 <twi_master_interrupt_handler_not_naked+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800065f6:	49 79       	lddpc	r9,80006650 <twi_master_interrupt_handler_not_naked+0xac>
800065f8:	72 0a       	ld.w	r10,r9[0x0]
800065fa:	20 1a       	sub	r10,1
800065fc:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800065fe:	72 09       	ld.w	r9,r9[0x0]
80006600:	58 09       	cp.w	r9,0
80006602:	e0 89 00 0a 	brgt	80006616 <twi_master_interrupt_handler_not_naked+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80006606:	49 09       	lddpc	r9,80006644 <twi_master_interrupt_handler_not_naked+0xa0>
80006608:	30 1a       	mov	r10,1
8000660a:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
8000660c:	3f fa       	mov	r10,-1
8000660e:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80006610:	72 09       	ld.w	r9,r9[0x0]
80006612:	91 99       	st.w	r8[0x24],r9
80006614:	5e fc       	retal	r12
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80006616:	49 0a       	lddpc	r10,80006654 <twi_master_interrupt_handler_not_naked+0xb0>
80006618:	74 09       	ld.w	r9,r10[0x0]
8000661a:	13 3b       	ld.ub	r11,r9++
8000661c:	91 db       	st.w	r8[0x34],r11
8000661e:	95 09       	st.w	r10[0x0],r9
80006620:	5e fc       	retal	r12
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80006622:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006626:	c0 51       	brne	80006630 <twi_master_interrupt_handler_not_naked+0x8c>
80006628:	5e fc       	retal	r12
	}

	return;

nack:
	twi_nack = true;
8000662a:	30 1a       	mov	r10,1
8000662c:	48 b9       	lddpc	r9,80006658 <twi_master_interrupt_handler_not_naked+0xb4>
8000662e:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80006630:	3f f9       	mov	r9,-1
80006632:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80006634:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80006636:	30 09       	mov	r9,0
80006638:	48 98       	lddpc	r8,8000665c <twi_master_interrupt_handler_not_naked+0xb8>
8000663a:	b0 89       	st.b	r8[0x0],r9

	return;
}
8000663c:	5e fc       	retal	r12
8000663e:	00 00       	add	r0,r0
80006640:	00 00       	add	r0,r0
80006642:	74 e4       	ld.w	r4,r10[0x38]
80006644:	00 00       	add	r0,r0
80006646:	74 e0       	ld.w	r0,r10[0x38]
80006648:	00 00       	add	r0,r0
8000664a:	74 f0       	ld.w	r0,r10[0x3c]
8000664c:	00 00       	add	r0,r0
8000664e:	74 ec       	ld.w	r12,r10[0x38]
80006650:	00 00       	add	r0,r0
80006652:	74 dc       	ld.w	r12,r10[0x34]
80006654:	00 00       	add	r0,r0
80006656:	74 e8       	ld.w	r8,r10[0x38]
80006658:	00 00       	add	r0,r0
8000665a:	74 d9       	ld.w	r9,r10[0x34]
8000665c:	00 00       	add	r0,r0
8000665e:	74 d8       	ld.w	r8,r10[0x34]

80006660 <twi_master_interrupt_handler>:
#define CONF_TWI_IRQ_GROUP         AVR32_TWI_IRQ_GROUP


/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
80006660:	eb cd 00 ff 	pushm	r0-r7
80006664:	f0 1f 00 03 	mcall	80006670 <twi_master_interrupt_handler+0x10>
80006668:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000666c:	d6 03       	rete
8000666e:	00 00       	add	r0,r0
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	65 a4       	ld.w	r4,r2[0x68]

80006674 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
80006674:	18 98       	mov	r8,r12
	uint32_t val;

	if (len == 0)
80006676:	58 0b       	cp.w	r11,0
80006678:	c0 21       	brne	8000667c <twi_mk_addr+0x8>
8000667a:	5e fd       	retal	0
		return 0;

	val = addr[0];
8000667c:	19 8c       	ld.ub	r12,r12[0x0]
	if (len > 1) {
8000667e:	58 1b       	cp.w	r11,1
80006680:	e0 8a 00 05 	brle	8000668a <twi_mk_addr+0x16>
		val <<= 8;
		val |= addr[1];
80006684:	11 99       	ld.ub	r9,r8[0x1]
80006686:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
	}
	if (len > 2) {
8000668a:	58 2b       	cp.w	r11,2
8000668c:	5e ac       	retle	r12
		val <<= 8;
		val |= addr[2];
8000668e:	11 a8       	ld.ub	r8,r8[0x2]
80006690:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	}
	return val;
}
80006694:	5e fc       	retal	r12
80006696:	d7 03       	nop

80006698 <twi_is_busy>:
}


bool twi_is_busy(void)
{
	if (twi_busy) {
80006698:	48 28       	lddpc	r8,800066a0 <twi_is_busy+0x8>
8000669a:	11 8c       	ld.ub	r12,r8[0x0]
		return true;          // Still receiving/transmitting...
	} else {
		return false;
	}
}
8000669c:	5e fc       	retal	r12
8000669e:	00 00       	add	r0,r0
800066a0:	00 00       	add	r0,r0
800066a2:	74 d8       	ld.w	r8,r10[0x34]

800066a4 <twi_master_write>:
	return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800066a4:	eb cd 40 c0 	pushm	r6-r7,lr
800066a8:	18 96       	mov	r6,r12
800066aa:	16 97       	mov	r7,r11
	// No data to send
	if (package->length == 0) {
800066ac:	76 38       	ld.w	r8,r11[0xc]
800066ae:	58 08       	cp.w	r8,0
800066b0:	c0 51       	brne	800066ba <twi_master_write+0x16>
800066b2:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800066b6:	fe cf ff fc 	sub	pc,pc,-4
	// No data to send
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800066ba:	f0 1f 00 1f 	mcall	80006734 <twi_master_write+0x90>
800066be:	cf c1       	brne	800066b6 <twi_master_write+0x12>
		cpu_relax();
	};

	twi_nack = false;
800066c0:	30 09       	mov	r9,0
800066c2:	49 e8       	lddpc	r8,80006738 <twi_master_write+0x94>
800066c4:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800066c6:	30 19       	mov	r9,1
800066c8:	49 d8       	lddpc	r8,8000673c <twi_master_write+0x98>
800066ca:	b0 89       	st.b	r8[0x0],r9

	// Enable master transfer, disable slave
	twi->cr =   AVR32_TWI_CR_MSEN_MASK
800066cc:	32 48       	mov	r8,36
800066ce:	8d 08       	st.w	r6[0x0],r8
			| AVR32_TWI_CR_SVDIS_MASK
#endif
			;

	// set write mode, slave address and 3 internal address byte length
	twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800066d0:	6e 18       	ld.w	r8,r7[0x4]
800066d2:	a9 68       	lsl	r8,0x8
800066d4:	e2 18 03 00 	andl	r8,0x300,COH
800066d8:	0f 89       	ld.ub	r9,r7[0x0]
800066da:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800066de:	8d 18       	st.w	r6[0x4],r8
			(package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

	// Set pointer to TWI instance for IT
	twi_inst = twi;
800066e0:	49 88       	lddpc	r8,80006740 <twi_master_write+0x9c>
800066e2:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800066e4:	6e 1b       	ld.w	r11,r7[0x4]
800066e6:	ee cc ff ff 	sub	r12,r7,-1
800066ea:	f0 1f 00 17 	mcall	80006744 <twi_master_write+0xa0>
800066ee:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_tx_data = package->buffer;
800066f0:	6e 29       	ld.w	r9,r7[0x8]
800066f2:	49 68       	lddpc	r8,80006748 <twi_master_write+0xa4>
800066f4:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to write
	twi_tx_nb_bytes = package->length;
800066f6:	6e 3a       	ld.w	r10,r7[0xc]
800066f8:	49 59       	lddpc	r9,8000674c <twi_master_write+0xa8>
800066fa:	93 0a       	st.w	r9[0x0],r10

	// put the first byte in the Transmit Holding Register
	twi->thr = *twi_tx_data++;
800066fc:	70 09       	ld.w	r9,r8[0x0]
800066fe:	13 3a       	ld.ub	r10,r9++
80006700:	8d da       	st.w	r6[0x34],r10
80006702:	91 09       	st.w	r8[0x0],r9

	// mask NACK and TXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
80006704:	49 38       	lddpc	r8,80006750 <twi_master_write+0xac>
80006706:	e0 69 01 04 	mov	r9,260
8000670a:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
8000670c:	70 08       	ld.w	r8,r8[0x0]
8000670e:	8d 98       	st.w	r6[0x24],r8

	// send data
	while (twi_is_busy()) {
80006710:	c0 38       	rjmp	80006716 <twi_master_write+0x72>
		cpu_relax();
80006712:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// send data
	while (twi_is_busy()) {
80006716:	f0 1f 00 08 	mcall	80006734 <twi_master_write+0x90>
8000671a:	cf c1       	brne	80006712 <twi_master_write+0x6e>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
8000671c:	30 88       	mov	r8,8
8000671e:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
80006720:	48 68       	lddpc	r8,80006738 <twi_master_write+0x94>
80006722:	11 8c       	ld.ub	r12,r8[0x0]
80006724:	58 0c       	cp.w	r12,0
80006726:	f9 bc 01 fb 	movne	r12,-5
8000672a:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
8000672e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006732:	00 00       	add	r0,r0
80006734:	80 00       	ld.sh	r0,r0[0x0]
80006736:	66 98       	ld.w	r8,r3[0x24]
80006738:	00 00       	add	r0,r0
8000673a:	74 d9       	ld.w	r9,r10[0x34]
8000673c:	00 00       	add	r0,r0
8000673e:	74 d8       	ld.w	r8,r10[0x34]
80006740:	00 00       	add	r0,r0
80006742:	74 e4       	ld.w	r4,r10[0x38]
80006744:	80 00       	ld.sh	r0,r0[0x0]
80006746:	66 74       	ld.w	r4,r3[0x1c]
80006748:	00 00       	add	r0,r0
8000674a:	74 e8       	ld.w	r8,r10[0x38]
8000674c:	00 00       	add	r0,r0
8000674e:	74 dc       	ld.w	r12,r10[0x34]
80006750:	00 00       	add	r0,r0
80006752:	74 e0       	ld.w	r0,r10[0x38]

80006754 <twi_probe>:
	cpu_irq_restore(flags);
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80006754:	d4 01       	pushm	lr
80006756:	20 5d       	sub	sp,20
	twi_package_t package;
	char data[1] = {0};
80006758:	30 08       	mov	r8,0
8000675a:	ba 88       	st.b	sp[0x0],r8

	// data to send
	package.buffer = data;
8000675c:	50 3d       	stdsp	sp[0xc],sp
	// chip address
	package.chip = chip_addr;
8000675e:	ba cb       	st.b	sp[0x4],r11
	// frame length
	package.length = 1;
80006760:	30 19       	mov	r9,1
80006762:	50 49       	stdsp	sp[0x10],r9
	// address length
	package.addr_length = 0;
80006764:	30 09       	mov	r9,0
80006766:	50 29       	stdsp	sp[0x8],r9
	// internal chip address
	package.addr[0] = 0;
80006768:	ba d8       	st.b	sp[0x5],r8
	// perform a master write access
	return (twi_master_write(twi, &package));
8000676a:	fa cb ff fc 	sub	r11,sp,-4
8000676e:	f0 1f 00 03 	mcall	80006778 <twi_probe+0x24>
}
80006772:	2f bd       	sub	sp,-20
80006774:	d8 02       	popm	pc
80006776:	00 00       	add	r0,r0
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	66 a4       	ld.w	r4,r3[0x28]

8000677c <twi_master_read>:
	}
	return val;
}

int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
8000677c:	eb cd 40 c0 	pushm	r6-r7,lr
80006780:	18 96       	mov	r6,r12
80006782:	16 97       	mov	r7,r11
	// check argument
	if (package->length == 0) {
80006784:	76 38       	ld.w	r8,r11[0xc]
80006786:	58 08       	cp.w	r8,0
80006788:	c0 51       	brne	80006792 <twi_master_read+0x16>
8000678a:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
8000678e:	fe cf ff fc 	sub	pc,pc,-4
	// check argument
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
80006792:	f0 1f 00 21 	mcall	80006814 <twi_master_read+0x98>
80006796:	cf c1       	brne	8000678e <twi_master_read+0x12>
		cpu_relax();
	};

	twi_nack = false;
80006798:	30 09       	mov	r9,0
8000679a:	4a 08       	lddpc	r8,80006818 <twi_master_read+0x9c>
8000679c:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
8000679e:	30 19       	mov	r9,1
800067a0:	49 f8       	lddpc	r8,8000681c <twi_master_read+0xa0>
800067a2:	b0 89       	st.b	r8[0x0],r9

	// set read mode, slave address and 3 internal address byte length
	twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
800067a4:	0f 89       	ld.ub	r9,r7[0x0]
800067a6:	6e 18       	ld.w	r8,r7[0x4]
800067a8:	a9 68       	lsl	r8,0x8
800067aa:	e2 18 03 00 	andl	r8,0x300,COH
800067ae:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800067b2:	ad a8       	sbr	r8,0xc
800067b4:	8d 18       	st.w	r6[0x4],r8
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
			(1 << AVR32_TWI_MMR_MREAD_OFFSET);

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800067b6:	49 b8       	lddpc	r8,80006820 <twi_master_read+0xa4>
800067b8:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800067ba:	6e 1b       	ld.w	r11,r7[0x4]
800067bc:	ee cc ff ff 	sub	r12,r7,-1
800067c0:	f0 1f 00 19 	mcall	80006824 <twi_master_read+0xa8>
800067c4:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_rx_data = package->buffer;
800067c6:	6e 29       	ld.w	r9,r7[0x8]
800067c8:	49 88       	lddpc	r8,80006828 <twi_master_read+0xac>
800067ca:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to read
	twi_rx_nb_bytes = package->length;
800067cc:	6e 39       	ld.w	r9,r7[0xc]
800067ce:	49 88       	lddpc	r8,8000682c <twi_master_read+0xb0>
800067d0:	91 09       	st.w	r8[0x0],r9

	// Enable master transfer
	twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800067d2:	30 49       	mov	r9,4
800067d4:	8d 09       	st.w	r6[0x0],r9

	// Send start condition
	twi->cr = AVR32_TWI_START_MASK;
800067d6:	30 19       	mov	r9,1
800067d8:	8d 09       	st.w	r6[0x0],r9

	// only one byte to receive
	if (twi_rx_nb_bytes == 1) {
800067da:	70 08       	ld.w	r8,r8[0x0]
		// set stop bit
		twi->cr = AVR32_TWI_STOP_MASK;
800067dc:	12 38       	cp.w	r8,r9
800067de:	f9 b8 00 02 	moveq	r8,2
800067e2:	ed f8 0a 00 	st.weq	r6[0x0],r8
	}

	// mask NACK and RXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
800067e6:	49 38       	lddpc	r8,80006830 <twi_master_read+0xb4>
800067e8:	e0 69 01 02 	mov	r9,258
800067ec:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
800067ee:	70 08       	ld.w	r8,r8[0x0]
800067f0:	8d 98       	st.w	r6[0x24],r8

	// get data
	while (twi_is_busy()) {
800067f2:	c0 38       	rjmp	800067f8 <twi_master_read+0x7c>
		cpu_relax();
800067f4:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// get data
	while (twi_is_busy()) {
800067f8:	f0 1f 00 07 	mcall	80006814 <twi_master_read+0x98>
800067fc:	cf c1       	brne	800067f4 <twi_master_read+0x78>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
800067fe:	30 88       	mov	r8,8
80006800:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
80006802:	48 68       	lddpc	r8,80006818 <twi_master_read+0x9c>
80006804:	11 8c       	ld.ub	r12,r8[0x0]
80006806:	58 0c       	cp.w	r12,0
80006808:	f9 bc 01 fb 	movne	r12,-5
8000680c:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80006810:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006814:	80 00       	ld.sh	r0,r0[0x0]
80006816:	66 98       	ld.w	r8,r3[0x24]
80006818:	00 00       	add	r0,r0
8000681a:	74 d9       	ld.w	r9,r10[0x34]
8000681c:	00 00       	add	r0,r0
8000681e:	74 d8       	ld.w	r8,r10[0x34]
80006820:	00 00       	add	r0,r0
80006822:	74 e4       	ld.w	r4,r10[0x38]
80006824:	80 00       	ld.sh	r0,r0[0x0]
80006826:	66 74       	ld.w	r4,r3[0x1c]
80006828:	00 00       	add	r0,r0
8000682a:	74 f0       	ld.w	r0,r10[0x3c]
8000682c:	00 00       	add	r0,r0
8000682e:	74 ec       	ld.w	r12,r10[0x38]
80006830:	00 00       	add	r0,r0
80006832:	74 e0       	ld.w	r0,r10[0x38]

80006834 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80006834:	eb cd 40 e0 	pushm	r5-r7,lr
80006838:	20 1d       	sub	sp,4
8000683a:	18 97       	mov	r7,r12
8000683c:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
8000683e:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80006842:	4a 29       	lddpc	r9,800068c8 <twi_master_init+0x94>
80006844:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80006846:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80006848:	3f f9       	mov	r9,-1
8000684a:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
8000684c:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
8000684e:	e0 69 00 80 	mov	r9,128
80006852:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006854:	e6 18 00 01 	andh	r8,0x1,COH
80006858:	c0 21       	brne	8000685c <twi_master_init+0x28>
      cpu_irq_enable();
8000685a:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
8000685c:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000685e:	e1 b8 00 00 	mfsr	r8,0x0
80006862:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80006864:	d3 03       	ssrf	0x10

	return flags;
80006866:	40 06       	lddsp	r6,sp[0x0]

	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();
	INTC_init_interrupts(); /**/
80006868:	f0 1f 00 19 	mcall	800068cc <twi_master_init+0x98>
	INTC_register_interrupt(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL); /**/
8000686c:	30 3a       	mov	r10,3
8000686e:	e0 6b 01 60 	mov	r11,352
80006872:	49 8c       	lddpc	r12,800068d0 <twi_master_init+0x9c>
80006874:	f0 1f 00 18 	mcall	800068d4 <twi_master_init+0xa0>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006878:	e6 16 00 01 	andh	r6,0x1,COH
8000687c:	c0 21       	brne	80006880 <twi_master_init+0x4c>
      cpu_irq_enable();
8000687e:	d5 03       	csrf	0x10
	//irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE,
	//CONF_TWI_IRQ_LEVEL);
	cpu_irq_restore(flags);
	cpu_irq_enable(); /**/
80006880:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80006882:	6a 19       	ld.w	r9,r5[0x4]
80006884:	a1 79       	lsl	r9,0x1
80006886:	6a 08       	ld.w	r8,r5[0x0]
80006888:	f0 09 0d 08 	divu	r8,r8,r9
8000688c:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000688e:	e0 48 00 ff 	cp.w	r8,255
80006892:	e0 8b 00 04 	brhi	8000689a <twi_master_init+0x66>
80006896:	30 09       	mov	r9,0
80006898:	c0 f8       	rjmp	800068b6 <twi_master_init+0x82>
8000689a:	30 09       	mov	r9,0
8000689c:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
8000689e:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
800068a0:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800068a2:	e0 48 00 ff 	cp.w	r8,255
800068a6:	5f bb       	srhi	r11
800068a8:	58 69       	cp.w	r9,6
800068aa:	5f 8a       	srls	r10
800068ac:	f7 ea 00 0a 	and	r10,r11,r10
800068b0:	f8 0a 18 00 	cp.b	r10,r12
800068b4:	cf 51       	brne	8000689e <twi_master_init+0x6a>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800068b6:	b1 69       	lsl	r9,0x10
800068b8:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800068bc:	f3 e8 10 08 	or	r8,r9,r8
800068c0:	8f 48       	st.w	r7[0x10],r8

	// Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800068c2:	2f fd       	sub	sp,-4
800068c4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800068c8:	00 00       	add	r0,r0
800068ca:	74 e4       	ld.w	r4,r10[0x38]
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	85 bc       	st.w	r2[0x2c],r12
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	66 60       	ld.w	r0,r3[0x18]
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	85 3c       	st.w	r2[0xc],r12

800068d8 <print_char>:
  usart_write_line(usart, str);
}


void print_char(volatile avr32_usart_t *usart, int c)
{
800068d8:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input character with the given USART.
  usart_putchar(usart, c);
800068da:	f0 1f 00 02 	mcall	800068e0 <print_char+0x8>
}
800068de:	d8 02       	popm	pc
800068e0:	80 00       	ld.sh	r0,r0[0x0]
800068e2:	6c 64       	ld.w	r4,r6[0x18]

800068e4 <print_dbg_char>:
  print(DBG_USART, str);
}


void print_dbg_char(int c)
{
800068e4:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_char(DBG_USART, c);
800068e6:	18 9b       	mov	r11,r12
800068e8:	fe 7c 14 00 	mov	r12,-60416
800068ec:	f0 1f 00 02 	mcall	800068f4 <print_dbg_char+0x10>
}
800068f0:	d8 02       	popm	pc
800068f2:	00 00       	add	r0,r0
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	68 d8       	ld.w	r8,r4[0x34]

800068f8 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
800068f8:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
800068fa:	f0 1f 00 02 	mcall	80006900 <print+0x8>
}
800068fe:	d8 02       	popm	pc
80006900:	80 00       	ld.sh	r0,r0[0x0]
80006902:	6c 90       	ld.w	r0,r6[0x24]

80006904 <print_char_hex>:
  print(usart, tmp + i);
}


void print_char_hex(volatile avr32_usart_t *usart, unsigned char n)
{
80006904:	d4 01       	pushm	lr
80006906:	20 1d       	sub	sp,4
  char tmp[3];
  int i;

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[2] = '\0';
80006908:	30 08       	mov	r8,0
8000690a:	ba a8       	st.b	sp[0x2],r8
  for (i = 1; i >= 0; i--)
  {
    tmp[i] = HEX_DIGITS[n & 0xF];
8000690c:	48 88       	lddpc	r8,8000692c <print_char_hex+0x28>
8000690e:	f3 db c0 04 	bfextu	r9,r11,0x0,0x4
80006912:	f0 09 07 09 	ld.ub	r9,r8[r9]
80006916:	ba 99       	st.b	sp[0x1],r9
80006918:	f7 db c0 84 	bfextu	r11,r11,0x4,0x4
8000691c:	f0 0b 07 08 	ld.ub	r8,r8[r11]
80006920:	ba 88       	st.b	sp[0x0],r8
    n >>= 4;
  }

  // Transmit the resulting string with the given USART.
  print(usart, tmp);
80006922:	1a 9b       	mov	r11,sp
80006924:	f0 1f 00 03 	mcall	80006930 <print_char_hex+0x2c>
}
80006928:	2f fd       	sub	sp,-4
8000692a:	d8 02       	popm	pc
8000692c:	80 01       	ld.sh	r1,r0[0x0]
8000692e:	ac c8       	st.b	r6[0x4],r8
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	68 f8       	ld.w	r8,r4[0x3c]

80006934 <print_dbg_char_hex>:
  print_ulong(DBG_USART, n);
}


void print_dbg_char_hex(unsigned char n)
{
80006934:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_char_hex(DBG_USART, n);
80006936:	18 9b       	mov	r11,r12
80006938:	fe 7c 14 00 	mov	r12,-60416
8000693c:	f0 1f 00 02 	mcall	80006944 <print_dbg_char_hex+0x10>
}
80006940:	d8 02       	popm	pc
80006942:	00 00       	add	r0,r0
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	69 04       	ld.w	r4,r4[0x40]

80006948 <print_ulong>:
  usart_putchar(usart, c);
}


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
80006948:	eb cd 40 e0 	pushm	r5-r7,lr
8000694c:	20 3d       	sub	sp,12
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
8000694e:	30 08       	mov	r8,0
80006950:	fb 68 00 0a 	st.b	sp[10],r8
80006954:	30 a9       	mov	r9,10
  do
  {
    tmp[--i] = '0' + n % 10;
80006956:	1a 95       	mov	r5,sp
80006958:	e0 6e cc cd 	mov	lr,52429
8000695c:	ea 1e cc cc 	orh	lr,0xcccc
80006960:	20 19       	sub	r9,1
80006962:	f6 0e 06 46 	mulu.d	r6,r11,lr
80006966:	0e 98       	mov	r8,r7
80006968:	a3 98       	lsr	r8,0x3
8000696a:	f0 08 00 2a 	add	r10,r8,r8<<0x2
8000696e:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
80006972:	2d 0b       	sub	r11,-48
80006974:	ea 09 0b 0b 	st.b	r5[r9],r11
    n /= 10;
80006978:	10 9b       	mov	r11,r8
  } while (n);
8000697a:	58 08       	cp.w	r8,0
8000697c:	cf 21       	brne	80006960 <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
8000697e:	1a 9b       	mov	r11,sp
80006980:	12 0b       	add	r11,r9
80006982:	f0 1f 00 03 	mcall	8000698c <print_ulong+0x44>
}
80006986:	2f dd       	sub	sp,-12
80006988:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	68 f8       	ld.w	r8,r4[0x3c]

80006990 <print_dbg_ulong>:
  print_char(DBG_USART, c);
}


void print_dbg_ulong(unsigned long n)
{
80006990:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
80006992:	18 9b       	mov	r11,r12
80006994:	fe 7c 14 00 	mov	r12,-60416
80006998:	f0 1f 00 02 	mcall	800069a0 <print_dbg_ulong+0x10>
}
8000699c:	d8 02       	popm	pc
8000699e:	00 00       	add	r0,r0
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	69 48       	ld.w	r8,r4[0x50]

800069a4 <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
800069a4:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
800069a6:	18 9b       	mov	r11,r12
800069a8:	fe 7c 14 00 	mov	r12,-60416
800069ac:	f0 1f 00 02 	mcall	800069b4 <print_dbg+0x10>
}
800069b0:	d8 02       	popm	pc
800069b2:	00 00       	add	r0,r0
800069b4:	80 00       	ld.sh	r0,r0[0x0]
800069b6:	68 f8       	ld.w	r8,r4[0x3c]

800069b8 <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
800069b8:	eb cd 40 80 	pushm	r7,lr
800069bc:	20 3d       	sub	sp,12
800069be:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
800069c0:	50 0c       	stdsp	sp[0x0],r12
800069c2:	30 88       	mov	r8,8
800069c4:	ba c8       	st.b	sp[0x4],r8
800069c6:	30 48       	mov	r8,4
800069c8:	ba d8       	st.b	sp[0x5],r8
800069ca:	30 08       	mov	r8,0
800069cc:	ba 38       	st.h	sp[0x6],r8
800069ce:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
800069d2:	30 2b       	mov	r11,2
800069d4:	48 6c       	lddpc	r12,800069ec <init_dbg_rs232_ex+0x34>
800069d6:	f0 1f 00 07 	mcall	800069f0 <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
800069da:	0e 9a       	mov	r10,r7
800069dc:	1a 9b       	mov	r11,sp
800069de:	fe 7c 14 00 	mov	r12,-60416
800069e2:	f0 1f 00 05 	mcall	800069f4 <init_dbg_rs232_ex+0x3c>
}
800069e6:	2f dd       	sub	sp,-12
800069e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800069ec:	80 01       	ld.sh	r1,r0[0x0]
800069ee:	ac b8       	st.b	r6[0x3],r8
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	84 1c       	ld.sh	r12,r2[0x2]
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	6c e0       	ld.w	r0,r6[0x38]

800069f8 <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
800069f8:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
800069fa:	18 9b       	mov	r11,r12
800069fc:	e0 6c e1 00 	mov	r12,57600
80006a00:	f0 1f 00 02 	mcall	80006a08 <init_dbg_rs232+0x10>
}
80006a04:	d8 02       	popm	pc
80006a06:	00 00       	add	r0,r0
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	69 b8       	ld.w	r8,r4[0x6c]

80006a0c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006a0c:	fe 68 14 00 	mov	r8,-125952
80006a10:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80006a12:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006a16:	91 09       	st.w	r8[0x0],r9
}
80006a18:	5e fc       	retal	r12

80006a1a <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006a1a:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80006a1c:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006a20:	99 a8       	st.w	r12[0x28],r8
}
80006a22:	5e fc       	retal	r12

80006a24 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80006a24:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80006a26:	ec 5b bb 9f 	cp.w	r11,899999
80006a2a:	e0 8b 00 04 	brhi	80006a32 <pm_enable_osc0_crystal+0xe>
80006a2e:	30 4b       	mov	r11,4
80006a30:	c1 38       	rjmp	80006a56 <pm_enable_osc0_crystal+0x32>
80006a32:	e0 68 c6 bf 	mov	r8,50879
80006a36:	ea 18 00 2d 	orh	r8,0x2d
80006a3a:	10 3b       	cp.w	r11,r8
80006a3c:	e0 8b 00 04 	brhi	80006a44 <pm_enable_osc0_crystal+0x20>
80006a40:	30 5b       	mov	r11,5
80006a42:	c0 a8       	rjmp	80006a56 <pm_enable_osc0_crystal+0x32>
80006a44:	e0 68 12 00 	mov	r8,4608
80006a48:	ea 18 00 7a 	orh	r8,0x7a
80006a4c:	10 3b       	cp.w	r11,r8
80006a4e:	f9 bb 03 06 	movlo	r11,6
80006a52:	f9 bb 02 07 	movhs	r11,7
80006a56:	f0 1f 00 02 	mcall	80006a5c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80006a5a:	d8 02       	popm	pc
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	6a 1a       	ld.w	r10,r5[0x4]

80006a60 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006a60:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006a62:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006a66:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80006a68:	78 08       	ld.w	r8,r12[0x0]
80006a6a:	a3 a8       	sbr	r8,0x2
80006a6c:	99 08       	st.w	r12[0x0],r8
}
80006a6e:	5e fc       	retal	r12

80006a70 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006a70:	79 58       	ld.w	r8,r12[0x54]
80006a72:	e2 18 00 80 	andl	r8,0x80,COH
80006a76:	cf d0       	breq	80006a70 <pm_wait_for_clk0_ready>
}
80006a78:	5e fc       	retal	r12
80006a7a:	d7 03       	nop

80006a7c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80006a7c:	eb cd 40 80 	pushm	r7,lr
80006a80:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006a82:	f0 1f 00 04 	mcall	80006a90 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80006a86:	0e 9c       	mov	r12,r7
80006a88:	f0 1f 00 03 	mcall	80006a94 <pm_enable_clk0+0x18>
}
80006a8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	6a 60       	ld.w	r0,r5[0x18]
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	6a 70       	ld.w	r0,r5[0x1c]

80006a98 <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80006a98:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
80006a9a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80006a9e:	99 b8       	st.w	r12[0x2c],r8
}
80006aa0:	5e fc       	retal	r12
80006aa2:	d7 03       	nop

80006aa4 <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
80006aa4:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
80006aa6:	ec 5b bb 9f 	cp.w	r11,899999
80006aaa:	e0 8b 00 04 	brhi	80006ab2 <pm_enable_osc1_crystal+0xe>
80006aae:	30 4b       	mov	r11,4
80006ab0:	c1 38       	rjmp	80006ad6 <pm_enable_osc1_crystal+0x32>
80006ab2:	e0 68 c6 bf 	mov	r8,50879
80006ab6:	ea 18 00 2d 	orh	r8,0x2d
80006aba:	10 3b       	cp.w	r11,r8
80006abc:	e0 8b 00 04 	brhi	80006ac4 <pm_enable_osc1_crystal+0x20>
80006ac0:	30 5b       	mov	r11,5
80006ac2:	c0 a8       	rjmp	80006ad6 <pm_enable_osc1_crystal+0x32>
80006ac4:	e0 68 12 00 	mov	r8,4608
80006ac8:	ea 18 00 7a 	orh	r8,0x7a
80006acc:	10 3b       	cp.w	r11,r8
80006ace:	f9 bb 03 06 	movlo	r11,6
80006ad2:	f9 bb 02 07 	movhs	r11,7
80006ad6:	f0 1f 00 02 	mcall	80006adc <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80006ada:	d8 02       	popm	pc
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	6a 98       	ld.w	r8,r5[0x24]

80006ae0 <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80006ae0:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
80006ae2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80006ae6:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80006ae8:	78 08       	ld.w	r8,r12[0x0]
80006aea:	a3 b8       	sbr	r8,0x3
80006aec:	99 08       	st.w	r12[0x0],r8
}
80006aee:	5e fc       	retal	r12

80006af0 <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80006af0:	79 58       	ld.w	r8,r12[0x54]
80006af2:	e2 18 01 00 	andl	r8,0x100,COH
80006af6:	cf d0       	breq	80006af0 <pm_wait_for_clk1_ready>
}
80006af8:	5e fc       	retal	r12
80006afa:	d7 03       	nop

80006afc <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80006afc:	eb cd 40 80 	pushm	r7,lr
80006b00:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
80006b02:	f0 1f 00 04 	mcall	80006b10 <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
80006b06:	0e 9c       	mov	r12,r7
80006b08:	f0 1f 00 03 	mcall	80006b14 <pm_enable_clk1+0x18>
}
80006b0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	6a e0       	ld.w	r0,r5[0x38]
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	6a f0       	ld.w	r0,r5[0x3c]

80006b18 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80006b18:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80006b1c:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80006b20:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80006b22:	09 f7       	ld.ub	r7,r4[0x7]
80006b24:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80006b28:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80006b2c:	09 b4       	ld.ub	r4,r4[0x3]
80006b2e:	08 96       	mov	r6,r4
80006b30:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80006b34:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80006b38:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80006b3c:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80006b40:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80006b44:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80006b48:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80006b4c:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80006b50:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80006b52:	79 58       	ld.w	r8,r12[0x54]
80006b54:	e2 18 00 20 	andl	r8,0x20,COH
80006b58:	cf d0       	breq	80006b52 <pm_cksel+0x3a>
}
80006b5a:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80006b5e <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80006b5e:	eb cd 40 80 	pushm	r7,lr
80006b62:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80006b64:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80006b66:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80006b6a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006b6e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80006b72:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80006b76:	2f 8b       	sub	r11,-8
80006b78:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006b7c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006b80 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006b80:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006b82:	2f 8b       	sub	r11,-8
80006b84:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80006b88:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006b8c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006b90:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80006b94:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006b98:	d8 02       	popm	pc

80006b9a <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80006b9a:	2f 8b       	sub	r11,-8
80006b9c:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006ba0:	a1 a8       	sbr	r8,0x0
80006ba2:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80006ba6:	5e fc       	retal	r12

80006ba8 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80006ba8:	79 58       	ld.w	r8,r12[0x54]
80006baa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006bae:	cf d0       	breq	80006ba8 <pm_wait_for_pll0_locked>
}
80006bb0:	5e fc       	retal	r12

80006bb2 <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
80006bb2:	79 58       	ld.w	r8,r12[0x54]
80006bb4:	e2 18 00 02 	andl	r8,0x2,COH
80006bb8:	cf d0       	breq	80006bb2 <pm_wait_for_pll1_locked>
}
80006bba:	5e fc       	retal	r12

80006bbc <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80006bbc:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80006bbe:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80006bc2:	99 08       	st.w	r12[0x0],r8
}
80006bc4:	5e fc       	retal	r12
80006bc6:	d7 03       	nop

80006bc8 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006bc8:	eb cd 40 c0 	pushm	r6-r7,lr
80006bcc:	18 97       	mov	r7,r12
80006bce:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80006bd0:	f0 1f 00 06 	mcall	80006be8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80006bd4:	0c 9b       	mov	r11,r6
80006bd6:	0e 9c       	mov	r12,r7
80006bd8:	f0 1f 00 05 	mcall	80006bec <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006bdc:	30 1b       	mov	r11,1
80006bde:	0e 9c       	mov	r12,r7
80006be0:	f0 1f 00 04 	mcall	80006bf0 <pm_switch_to_osc0+0x28>
}
80006be4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006be8:	80 00       	ld.sh	r0,r0[0x0]
80006bea:	6a 24       	ld.w	r4,r5[0x8]
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	6a 7c       	ld.w	r12,r5[0x1c]
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	6b bc       	ld.w	r12,r5[0x6c]

80006bf4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006bf4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006bf6:	f6 08 15 04 	lsl	r8,r11,0x4
80006bfa:	14 38       	cp.w	r8,r10
80006bfc:	f9 b8 08 10 	movls	r8,16
80006c00:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006c04:	f0 0b 02 4b 	mul	r11,r8,r11
80006c08:	f6 09 16 01 	lsr	r9,r11,0x1
80006c0c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006c10:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006c14:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006c18:	f2 cb 00 01 	sub	r11,r9,1
80006c1c:	e0 4b ff fe 	cp.w	r11,65534
80006c20:	e0 88 00 03 	brls	80006c26 <usart_set_async_baudrate+0x32>
80006c24:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006c26:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006c28:	e8 6e 00 00 	mov	lr,524288
80006c2c:	59 08       	cp.w	r8,16
80006c2e:	fc 08 17 10 	movne	r8,lr
80006c32:	f9 b8 00 00 	moveq	r8,0
80006c36:	e4 1b ff f7 	andh	r11,0xfff7
80006c3a:	e0 1b fe cf 	andl	r11,0xfecf
80006c3e:	16 48       	or	r8,r11
80006c40:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006c42:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006c46:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006c4a:	99 89       	st.w	r12[0x20],r9
80006c4c:	d8 0a       	popm	pc,r12=0

80006c4e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006c4e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006c50:	e2 18 00 02 	andl	r8,0x2,COH
80006c54:	c0 31       	brne	80006c5a <usart_write_char+0xc>
80006c56:	30 2c       	mov	r12,2
80006c58:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006c5a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006c5e:	99 7b       	st.w	r12[0x1c],r11
80006c60:	5e fd       	retal	0
80006c62:	d7 03       	nop

80006c64 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006c64:	eb cd 40 e0 	pushm	r5-r7,lr
80006c68:	18 96       	mov	r6,r12
80006c6a:	16 95       	mov	r5,r11
80006c6c:	e0 67 27 0f 	mov	r7,9999
80006c70:	c0 68       	rjmp	80006c7c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006c72:	58 07       	cp.w	r7,0
80006c74:	c0 31       	brne	80006c7a <usart_putchar+0x16>
80006c76:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006c7a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006c7c:	0a 9b       	mov	r11,r5
80006c7e:	0c 9c       	mov	r12,r6
80006c80:	f0 1f 00 03 	mcall	80006c8c <usart_putchar+0x28>
80006c84:	cf 71       	brne	80006c72 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006c86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006c8a:	00 00       	add	r0,r0
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	6c 4e       	ld.w	lr,r6[0x10]

80006c90 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006c90:	eb cd 40 c0 	pushm	r6-r7,lr
80006c94:	18 96       	mov	r6,r12
80006c96:	16 97       	mov	r7,r11
  while (*string != '\0')
80006c98:	17 8b       	ld.ub	r11,r11[0x0]
80006c9a:	58 0b       	cp.w	r11,0
80006c9c:	c0 80       	breq	80006cac <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006c9e:	2f f7       	sub	r7,-1
80006ca0:	0c 9c       	mov	r12,r6
80006ca2:	f0 1f 00 04 	mcall	80006cb0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006ca6:	0f 8b       	ld.ub	r11,r7[0x0]
80006ca8:	58 0b       	cp.w	r11,0
80006caa:	cf a1       	brne	80006c9e <usart_write_line+0xe>
80006cac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006cb0:	80 00       	ld.sh	r0,r0[0x0]
80006cb2:	6c 64       	ld.w	r4,r6[0x18]

80006cb4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006cb4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006cb8:	e6 18 00 01 	andh	r8,0x1,COH
80006cbc:	c0 71       	brne	80006cca <usart_reset+0x16>
80006cbe:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006cc0:	3f f8       	mov	r8,-1
80006cc2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006cc4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006cc6:	d5 03       	csrf	0x10
80006cc8:	c0 48       	rjmp	80006cd0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006cca:	3f f8       	mov	r8,-1
80006ccc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006cce:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006cd0:	30 08       	mov	r8,0
80006cd2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006cd4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006cd6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006cd8:	ea 68 61 0c 	mov	r8,680204
80006cdc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006cde:	5e fc       	retal	r12

80006ce0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006ce0:	eb cd 40 e0 	pushm	r5-r7,lr
80006ce4:	18 96       	mov	r6,r12
80006ce6:	16 97       	mov	r7,r11
80006ce8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006cea:	f0 1f 00 2f 	mcall	80006da4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006cee:	58 07       	cp.w	r7,0
80006cf0:	c5 80       	breq	80006da0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006cf2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006cf4:	30 49       	mov	r9,4
80006cf6:	f2 08 18 00 	cp.b	r8,r9
80006cfa:	e0 88 00 53 	brls	80006da0 <usart_init_rs232+0xc0>
80006cfe:	30 99       	mov	r9,9
80006d00:	f2 08 18 00 	cp.b	r8,r9
80006d04:	e0 8b 00 4e 	brhi	80006da0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006d08:	0f d9       	ld.ub	r9,r7[0x5]
80006d0a:	30 78       	mov	r8,7
80006d0c:	f0 09 18 00 	cp.b	r9,r8
80006d10:	e0 8b 00 48 	brhi	80006da0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006d14:	8e 39       	ld.sh	r9,r7[0x6]
80006d16:	e0 68 01 01 	mov	r8,257
80006d1a:	f0 09 19 00 	cp.h	r9,r8
80006d1e:	e0 8b 00 41 	brhi	80006da0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006d22:	ef 39 00 08 	ld.ub	r9,r7[8]
80006d26:	30 38       	mov	r8,3
80006d28:	f0 09 18 00 	cp.b	r9,r8
80006d2c:	e0 8b 00 3a 	brhi	80006da0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006d30:	0a 9a       	mov	r10,r5
80006d32:	6e 0b       	ld.w	r11,r7[0x0]
80006d34:	0c 9c       	mov	r12,r6
80006d36:	f0 1f 00 1d 	mcall	80006da8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006d3a:	58 1c       	cp.w	r12,1
80006d3c:	c3 20       	breq	80006da0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006d3e:	0f c8       	ld.ub	r8,r7[0x4]
80006d40:	30 99       	mov	r9,9
80006d42:	f2 08 18 00 	cp.b	r8,r9
80006d46:	c0 51       	brne	80006d50 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006d48:	6c 18       	ld.w	r8,r6[0x4]
80006d4a:	b1 b8       	sbr	r8,0x11
80006d4c:	8d 18       	st.w	r6[0x4],r8
80006d4e:	c0 68       	rjmp	80006d5a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006d50:	6c 19       	ld.w	r9,r6[0x4]
80006d52:	20 58       	sub	r8,5
80006d54:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006d58:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006d5a:	6c 19       	ld.w	r9,r6[0x4]
80006d5c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006d60:	0f d8       	ld.ub	r8,r7[0x5]
80006d62:	a9 78       	lsl	r8,0x9
80006d64:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006d68:	12 48       	or	r8,r9
80006d6a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006d6c:	8e 38       	ld.sh	r8,r7[0x6]
80006d6e:	30 29       	mov	r9,2
80006d70:	f2 08 19 00 	cp.h	r8,r9
80006d74:	e0 88 00 09 	brls	80006d86 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006d78:	6c 18       	ld.w	r8,r6[0x4]
80006d7a:	ad b8       	sbr	r8,0xd
80006d7c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006d7e:	8e b8       	ld.uh	r8,r7[0x6]
80006d80:	20 28       	sub	r8,2
80006d82:	8d a8       	st.w	r6[0x28],r8
80006d84:	c0 68       	rjmp	80006d90 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006d86:	6c 19       	ld.w	r9,r6[0x4]
80006d88:	5c 78       	castu.h	r8
80006d8a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006d8e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006d90:	6c 18       	ld.w	r8,r6[0x4]
80006d92:	e0 18 ff f0 	andl	r8,0xfff0
80006d96:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006d98:	35 08       	mov	r8,80
80006d9a:	8d 08       	st.w	r6[0x0],r8
80006d9c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006da0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006da4:	80 00       	ld.sh	r0,r0[0x0]
80006da6:	6c b4       	ld.w	r4,r6[0x2c]
80006da8:	80 00       	ld.sh	r0,r0[0x0]
80006daa:	6b f4       	ld.w	r4,r5[0x7c]

80006dac <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006dac:	f8 c8 ff f8 	sub	r8,r12,-8
80006db0:	99 18       	st.w	r12[0x4],r8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
80006db2:	3f f9       	mov	r9,-1
80006db4:	99 29       	st.w	r12[0x8],r9

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006db6:	99 38       	st.w	r12[0xc],r8
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80006db8:	99 48       	st.w	r12[0x10],r8

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
80006dba:	30 08       	mov	r8,0
80006dbc:	99 08       	st.w	r12[0x0],r8

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80006dbe:	5e fc       	retal	r12

80006dc0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
80006dc0:	30 08       	mov	r8,0
80006dc2:	99 48       	st.w	r12[0x10],r8

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
80006dc4:	5e fc       	retal	r12

80006dc6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
80006dc6:	78 18       	ld.w	r8,r12[0x4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
80006dc8:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80006dca:	70 29       	ld.w	r9,r8[0x8]
80006dcc:	97 29       	st.w	r11[0x8],r9

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
80006dce:	70 29       	ld.w	r9,r8[0x8]
80006dd0:	93 1b       	st.w	r9[0x4],r11
    pxIndex->pxPrevious = pxNewListItem;
80006dd2:	91 2b       	st.w	r8[0x8],r11

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
80006dd4:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80006dd6:	78 08       	ld.w	r8,r12[0x0]
80006dd8:	2f f8       	sub	r8,-1
80006dda:	99 08       	st.w	r12[0x0],r8
}
80006ddc:	5e fc       	retal	r12

80006dde <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
80006dde:	d4 01       	pushm	lr
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80006de0:	76 0e       	ld.w	lr,r11[0x0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
80006de2:	5b fe       	cp.w	lr,-1
80006de4:	c0 31       	brne	80006dea <vListInsert+0xc>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
80006de6:	78 49       	ld.w	r9,r12[0x10]
80006de8:	c0 98       	rjmp	80006dfa <vListInsert+0x1c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
80006dea:	f8 c9 ff f8 	sub	r9,r12,-8
80006dee:	72 18       	ld.w	r8,r9[0x4]
80006df0:	70 0a       	ld.w	r10,r8[0x0]
80006df2:	14 3e       	cp.w	lr,r10
80006df4:	c0 33       	brcs	80006dfa <vListInsert+0x1c>
80006df6:	10 99       	mov	r9,r8
80006df8:	cf bb       	rjmp	80006dee <vListInsert+0x10>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
80006dfa:	72 18       	ld.w	r8,r9[0x4]
80006dfc:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80006dfe:	91 2b       	st.w	r8[0x8],r11
    pxNewListItem->pxPrevious = pxIterator;
80006e00:	97 29       	st.w	r11[0x8],r9
    pxIterator->pxNext = pxNewListItem;
80006e02:	93 1b       	st.w	r9[0x4],r11

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
80006e04:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80006e06:	78 08       	ld.w	r8,r12[0x0]
80006e08:	2f f8       	sub	r8,-1
80006e0a:	99 08       	st.w	r12[0x0],r8
}
80006e0c:	d8 02       	popm	pc

80006e0e <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
80006e0e:	78 48       	ld.w	r8,r12[0x10]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006e10:	78 19       	ld.w	r9,r12[0x4]
80006e12:	78 2a       	ld.w	r10,r12[0x8]
80006e14:	93 2a       	st.w	r9[0x8],r10
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006e16:	78 29       	ld.w	r9,r12[0x8]
80006e18:	78 1a       	ld.w	r10,r12[0x4]
80006e1a:	93 1a       	st.w	r9[0x4],r10

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
80006e1c:	70 19       	ld.w	r9,r8[0x4]
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
80006e1e:	18 39       	cp.w	r9,r12
80006e20:	f3 f9 00 02 	ld.weq	r9,r9[0x8]
80006e24:	f1 f9 0a 01 	st.weq	r8[0x4],r9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
80006e28:	30 09       	mov	r9,0
80006e2a:	99 49       	st.w	r12[0x10],r9
    ( pxList->uxNumberOfItems )--;
80006e2c:	70 09       	ld.w	r9,r8[0x0]
80006e2e:	20 19       	sub	r9,1
80006e30:	91 09       	st.w	r8[0x0],r9

    return pxList->uxNumberOfItems;
80006e32:	70 0c       	ld.w	r12,r8[0x0]
}
80006e34:	5e fc       	retal	r12

80006e36 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( StackType_t ) 0x08080808;					/* R8 */
80006e36:	e0 68 08 08 	mov	r8,2056
80006e3a:	ea 18 08 08 	orh	r8,0x808
80006e3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x09090909;					/* R9 */
80006e40:	e0 68 09 09 	mov	r8,2313
80006e44:	ea 18 09 09 	orh	r8,0x909
80006e48:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;					/* R10 */
80006e4a:	e0 68 0a 0a 	mov	r8,2570
80006e4e:	ea 18 0a 0a 	orh	r8,0xa0a
80006e52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;					/* R11 */
80006e54:	e0 68 0b 0b 	mov	r8,2827
80006e58:	ea 18 0b 0b 	orh	r8,0xb0b
80006e5c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pvParameters;					/* R12 */
80006e5e:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;					/* R14/LR */
80006e60:	e0 68 be ef 	mov	r8,48879
80006e64:	ea 18 de ad 	orh	r8,0xdead
80006e68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006e6a:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;				/* SR */
80006e6c:	fc 18 00 40 	movh	r8,0x40
80006e70:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;					/* R0 */
80006e72:	e0 68 00 ff 	mov	r8,255
80006e76:	ea 18 ff 00 	orh	r8,0xff00
80006e7a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x01010101;					/* R1 */
80006e7c:	e0 68 01 01 	mov	r8,257
80006e80:	ea 18 01 01 	orh	r8,0x101
80006e84:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x02020202;					/* R2 */
80006e86:	e0 68 02 02 	mov	r8,514
80006e8a:	ea 18 02 02 	orh	r8,0x202
80006e8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x03030303;					/* R3 */
80006e90:	e0 68 03 03 	mov	r8,771
80006e94:	ea 18 03 03 	orh	r8,0x303
80006e98:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x04040404;					/* R4 */
80006e9a:	e0 68 04 04 	mov	r8,1028
80006e9e:	ea 18 04 04 	orh	r8,0x404
80006ea2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x05050505;					/* R5 */
80006ea4:	e0 68 05 05 	mov	r8,1285
80006ea8:	ea 18 05 05 	orh	r8,0x505
80006eac:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x06060606;					/* R6 */
80006eae:	e0 68 06 06 	mov	r8,1542
80006eb2:	ea 18 06 06 	orh	r8,0x606
80006eb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x07070707;					/* R7 */
80006eb8:	e0 68 07 07 	mov	r8,1799
80006ebc:	ea 18 07 07 	orh	r8,0x707
80006ec0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006ec2:	30 08       	mov	r8,0
80006ec4:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006ec6:	5e fc       	retal	r12

80006ec8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006ec8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006eca:	48 38       	lddpc	r8,80006ed4 <vPortEnterCritical+0xc>
80006ecc:	70 09       	ld.w	r9,r8[0x0]
80006ece:	2f f9       	sub	r9,-1
80006ed0:	91 09       	st.w	r8[0x0],r9
}
80006ed2:	5e fc       	retal	r12
80006ed4:	00 00       	add	r0,r0
80006ed6:	00 10       	sub	r0,r0

80006ed8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
80006ed8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006eda:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006edc:	30 0a       	mov	r10,0
80006ede:	14 9b       	mov	r11,r10
80006ee0:	49 2c       	lddpc	r12,80006f28 <xPortStartScheduler+0x50>
80006ee2:	f0 1f 00 13 	mcall	80006f2c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80006ee6:	e0 68 f2 8c 	mov	r8,62092
80006eea:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006eee:	30 08       	mov	r8,0
80006ef0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006ef4:	e0 68 75 b0 	mov	r8,30128
80006ef8:	ea 18 00 00 	orh	r8,0x0
80006efc:	70 00       	ld.w	r0,r8[0x0]
80006efe:	60 0d       	ld.w	sp,r0[0x0]
80006f00:	1b 00       	ld.w	r0,sp++
80006f02:	e0 68 00 10 	mov	r8,16
80006f06:	ea 18 00 00 	orh	r8,0x0
80006f0a:	91 00       	st.w	r8[0x0],r0
80006f0c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006f10:	2f ed       	sub	sp,-8
80006f12:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006f16:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006f1a:	e3 b0 00 00 	mtsr	0x0,r0
80006f1e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006f22:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006f26:	d8 0a       	popm	pc,r12=0
80006f28:	80 00       	ld.sh	r0,r0[0x0]
80006f2a:	6f f4       	ld.w	r4,r7[0x7c]
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	85 3c       	st.w	r2[0xc],r12

80006f30 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006f30:	20 6d       	sub	sp,24
80006f32:	eb cd 00 ff 	pushm	r0-r7
80006f36:	fa c7 ff c0 	sub	r7,sp,-64
80006f3a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006f3e:	ef 40 ff e0 	st.w	r7[-32],r0
80006f42:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006f46:	ef 40 ff e4 	st.w	r7[-28],r0
80006f4a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006f4e:	e0 68 00 10 	mov	r8,16
80006f52:	ea 18 00 00 	orh	r8,0x0
80006f56:	70 00       	ld.w	r0,r8[0x0]
80006f58:	1a d0       	st.w	--sp,r0
80006f5a:	f0 1f 00 1a 	mcall	80006fc0 <LABEL_RET_SCALL_243+0x14>
80006f5e:	e0 68 75 b0 	mov	r8,30128
80006f62:	ea 18 00 00 	orh	r8,0x0
80006f66:	70 00       	ld.w	r0,r8[0x0]
80006f68:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006f6a:	f0 1f 00 17 	mcall	80006fc4 <LABEL_RET_SCALL_243+0x18>
	portRESTORE_CONTEXT_SCALL();
80006f6e:	e0 68 75 b0 	mov	r8,30128
80006f72:	ea 18 00 00 	orh	r8,0x0
80006f76:	70 00       	ld.w	r0,r8[0x0]
80006f78:	60 0d       	ld.w	sp,r0[0x0]
80006f7a:	1b 00       	ld.w	r0,sp++
80006f7c:	e0 68 00 10 	mov	r8,16
80006f80:	ea 18 00 00 	orh	r8,0x0
80006f84:	91 00       	st.w	r8[0x0],r0
80006f86:	fa c7 ff d8 	sub	r7,sp,-40
80006f8a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006f8e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006f92:	e0 61 00 10 	mov	r1,16
80006f96:	ea 11 00 00 	orh	r1,0x0
80006f9a:	62 02       	ld.w	r2,r1[0x0]
80006f9c:	58 02       	cp.w	r2,0
80006f9e:	c0 70       	breq	80006fac <LABEL_RET_SCALL_243>
80006fa0:	e4 c2 00 01 	sub	r2,r2,1
80006fa4:	83 02       	st.w	r1[0x0],r2
80006fa6:	58 02       	cp.w	r2,0
80006fa8:	c0 21       	brne	80006fac <LABEL_RET_SCALL_243>
80006faa:	b1 c0       	cbr	r0,0x10

80006fac <LABEL_RET_SCALL_243>:
80006fac:	ef 40 ff f8 	st.w	r7[-8],r0
80006fb0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006fb4:	ef 40 ff fc 	st.w	r7[-4],r0
80006fb8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006fbc:	2f ad       	sub	sp,-24
80006fbe:	d6 13       	rets
80006fc0:	80 00       	ld.sh	r0,r0[0x0]
80006fc2:	6e c8       	ld.w	r8,r7[0x30]
80006fc4:	80 00       	ld.sh	r0,r0[0x0]
80006fc6:	76 cc       	ld.w	r12,r11[0x30]

80006fc8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006fc8:	e1 b8 00 43 	mfsr	r8,0x10c
80006fcc:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006fd0:	5e fc       	retal	r12
80006fd2:	d7 03       	nop

80006fd4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006fd4:	48 78       	lddpc	r8,80006ff0 <vPortExitCritical+0x1c>
80006fd6:	70 08       	ld.w	r8,r8[0x0]
80006fd8:	58 08       	cp.w	r8,0
80006fda:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006fdc:	48 58       	lddpc	r8,80006ff0 <vPortExitCritical+0x1c>
80006fde:	70 09       	ld.w	r9,r8[0x0]
80006fe0:	20 19       	sub	r9,1
80006fe2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006fe4:	70 08       	ld.w	r8,r8[0x0]
80006fe6:	58 08       	cp.w	r8,0
80006fe8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006fea:	d5 03       	csrf	0x10
80006fec:	5e fc       	retal	r12
80006fee:	00 00       	add	r0,r0
80006ff0:	00 00       	add	r0,r0
80006ff2:	00 10       	sub	r0,r0

80006ff4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006ff4:	eb cd 00 ff 	pushm	r0-r7
80006ff8:	e0 68 00 10 	mov	r8,16
80006ffc:	ea 18 00 00 	orh	r8,0x0
80007000:	70 00       	ld.w	r0,r8[0x0]
80007002:	1a d0       	st.w	--sp,r0
80007004:	7a 90       	ld.w	r0,sp[0x24]
80007006:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000700a:	58 10       	cp.w	r0,1
8000700c:	e0 8b 00 08 	brhi	8000701c <LABEL_INT_SKIP_SAVE_CONTEXT_216>
80007010:	e0 68 75 b0 	mov	r8,30128
80007014:	ea 18 00 00 	orh	r8,0x0
80007018:	70 00       	ld.w	r0,r8[0x0]
8000701a:	81 0d       	st.w	r0[0x0],sp

8000701c <LABEL_INT_SKIP_SAVE_CONTEXT_216>:
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
		clock cycles from now. */
		prvClearCcInt();
8000701c:	f0 1f 00 12 	mcall	80007064 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80007020:	f0 1f 00 12 	mcall	80007068 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
		xTaskIncrementTick();
80007024:	f0 1f 00 12 	mcall	8000706c <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x1c>
	portEXIT_CRITICAL();
80007028:	f0 1f 00 12 	mcall	80007070 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000702c:	7a 90       	ld.w	r0,sp[0x24]
8000702e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80007032:	58 10       	cp.w	r0,1
80007034:	e0 8b 00 0e 	brhi	80007050 <LABEL_INT_SKIP_RESTORE_CONTEXT_234>
80007038:	f0 1f 00 0c 	mcall	80007068 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
8000703c:	f0 1f 00 0e 	mcall	80007074 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x24>
80007040:	f0 1f 00 0c 	mcall	80007070 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>
80007044:	e0 68 75 b0 	mov	r8,30128
80007048:	ea 18 00 00 	orh	r8,0x0
8000704c:	70 00       	ld.w	r0,r8[0x0]
8000704e:	60 0d       	ld.w	sp,r0[0x0]

80007050 <LABEL_INT_SKIP_RESTORE_CONTEXT_234>:
80007050:	1b 00       	ld.w	r0,sp++
80007052:	e0 68 00 10 	mov	r8,16
80007056:	ea 18 00 00 	orh	r8,0x0
8000705a:	91 00       	st.w	r8[0x0],r0
8000705c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80007060:	d6 03       	rete
80007062:	00 00       	add	r0,r0
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	6f c8       	ld.w	r8,r7[0x70]
80007068:	80 00       	ld.sh	r0,r0[0x0]
8000706a:	6e c8       	ld.w	r8,r7[0x30]
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	7b 18       	ld.w	r8,sp[0x44]
80007070:	80 00       	ld.sh	r0,r0[0x0]
80007072:	6f d4       	ld.w	r4,r7[0x74]
80007074:	80 00       	ld.sh	r0,r0[0x0]
80007076:	76 cc       	ld.w	r12,r11[0x30]

80007078 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80007078:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000707a:	f0 1f 00 02 	mcall	80007080 <__malloc_lock+0x8>
}
8000707e:	d8 02       	popm	pc
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	76 bc       	ld.w	r12,r11[0x2c]

80007084 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80007084:	d4 01       	pushm	lr
	xTaskResumeAll();
80007086:	f0 1f 00 02 	mcall	8000708c <__malloc_unlock+0x8>
}
8000708a:	d8 02       	popm	pc
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	7c 20       	ld.w	r0,lr[0x8]

80007090 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
80007090:	eb cd 40 80 	pushm	r7,lr
80007094:	18 97       	mov	r7,r12
    if( pv )
80007096:	58 0c       	cp.w	r12,0
80007098:	c0 80       	breq	800070a8 <vPortFree+0x18>
    {
        vTaskSuspendAll();
8000709a:	f0 1f 00 05 	mcall	800070ac <vPortFree+0x1c>
        {
            free( pv );
8000709e:	0e 9c       	mov	r12,r7
800070a0:	f0 1f 00 04 	mcall	800070b0 <vPortFree+0x20>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
800070a4:	f0 1f 00 04 	mcall	800070b4 <vPortFree+0x24>
800070a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800070ac:	80 00       	ld.sh	r0,r0[0x0]
800070ae:	76 bc       	ld.w	r12,r11[0x2c]
800070b0:	80 00       	ld.sh	r0,r0[0x0]
800070b2:	9b 58       	st.w	sp[0x14],r8
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	7c 20       	ld.w	r0,lr[0x8]

800070b8 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
800070b8:	eb cd 40 80 	pushm	r7,lr
800070bc:	18 97       	mov	r7,r12
    void * pvReturn;

    vTaskSuspendAll();
800070be:	f0 1f 00 06 	mcall	800070d4 <pvPortMalloc+0x1c>
    {
        pvReturn = malloc( xWantedSize );
800070c2:	0e 9c       	mov	r12,r7
800070c4:	f0 1f 00 05 	mcall	800070d8 <pvPortMalloc+0x20>
800070c8:	18 97       	mov	r7,r12
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
800070ca:	f0 1f 00 05 	mcall	800070dc <pvPortMalloc+0x24>
            }
        }
    #endif

    return pvReturn;
}
800070ce:	0e 9c       	mov	r12,r7
800070d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	76 bc       	ld.w	r12,r11[0x2c]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	9b 68       	st.w	sp[0x18],r8
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	7c 20       	ld.w	r0,lr[0x8]

800070e0 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
800070e0:	eb cd 40 80 	pushm	r7,lr
800070e4:	18 97       	mov	r7,r12
    BaseType_t xReturn;

    taskENTER_CRITICAL();
800070e6:	f0 1f 00 05 	mcall	800070f8 <prvIsQueueEmpty+0x18>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
800070ea:	6e e7       	ld.w	r7,r7[0x38]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
800070ec:	f0 1f 00 04 	mcall	800070fc <prvIsQueueEmpty+0x1c>
800070f0:	58 07       	cp.w	r7,0

    return xReturn;
}
800070f2:	5f 0c       	sreq	r12
800070f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	6e c8       	ld.w	r8,r7[0x30]
800070fc:	80 00       	ld.sh	r0,r0[0x0]
800070fe:	6f d4       	ld.w	r4,r7[0x74]

80007100 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
80007100:	d4 01       	pushm	lr
80007102:	16 98       	mov	r8,r11
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80007104:	79 09       	ld.w	r9,r12[0x40]
80007106:	58 09       	cp.w	r9,0
80007108:	c1 00       	breq	80007128 <prvCopyDataFromQueue+0x28>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
8000710a:	78 3a       	ld.w	r10,r12[0xc]
8000710c:	f4 09 00 09 	add	r9,r10,r9
80007110:	99 39       	st.w	r12[0xc],r9

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80007112:	78 2a       	ld.w	r10,r12[0x8]
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
80007114:	14 39       	cp.w	r9,r10
80007116:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000711a:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
8000711e:	79 0a       	ld.w	r10,r12[0x40]
80007120:	78 3b       	ld.w	r11,r12[0xc]
80007122:	10 9c       	mov	r12,r8
80007124:	f0 1f 00 02 	mcall	8000712c <prvCopyDataFromQueue+0x2c>
80007128:	d8 02       	popm	pc
8000712a:	00 00       	add	r0,r0
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	9f ac       	st.w	pc[0x28],r12

80007130 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
80007130:	d4 21       	pushm	r4-r7,lr
80007132:	18 96       	mov	r6,r12

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
80007134:	f0 1f 00 25 	mcall	800071c8 <prvUnlockQueue+0x98>
    {
        int8_t cTxLock = pxQueue->cTxLock;
80007138:	ed 37 00 45 	ld.ub	r7,r6[69]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
8000713c:	30 08       	mov	r8,0
8000713e:	f0 07 18 00 	cp.b	r7,r8
80007142:	e0 8a 00 18 	brle	80007172 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007146:	6c 98       	ld.w	r8,r6[0x24]
80007148:	58 08       	cp.w	r8,0
8000714a:	c1 40       	breq	80007172 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000714c:	ec c4 ff dc 	sub	r4,r6,-36
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80007150:	30 05       	mov	r5,0
80007152:	c0 48       	rjmp	8000715a <prvUnlockQueue+0x2a>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007154:	6c 98       	ld.w	r8,r6[0x24]
80007156:	58 08       	cp.w	r8,0
80007158:	c0 d0       	breq	80007172 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000715a:	08 9c       	mov	r12,r4
8000715c:	f0 1f 00 1c 	mcall	800071cc <prvUnlockQueue+0x9c>
80007160:	c0 30       	breq	80007166 <prvUnlockQueue+0x36>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
80007162:	f0 1f 00 1c 	mcall	800071d0 <prvUnlockQueue+0xa0>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
80007166:	20 17       	sub	r7,1
80007168:	5c 57       	castu.b	r7
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
8000716a:	ea 07 18 00 	cp.b	r7,r5
8000716e:	fe 99 ff f3 	brgt	80007154 <prvUnlockQueue+0x24>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
80007172:	3f f8       	mov	r8,-1
80007174:	ed 68 00 45 	st.b	r6[69],r8
    }
    taskEXIT_CRITICAL();
80007178:	f0 1f 00 17 	mcall	800071d4 <prvUnlockQueue+0xa4>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
8000717c:	f0 1f 00 13 	mcall	800071c8 <prvUnlockQueue+0x98>
    {
        int8_t cRxLock = pxQueue->cRxLock;
80007180:	ed 37 00 44 	ld.ub	r7,r6[68]

        while( cRxLock > queueLOCKED_UNMODIFIED )
80007184:	30 08       	mov	r8,0
80007186:	f0 07 18 00 	cp.b	r7,r8
8000718a:	e0 8a 00 18 	brle	800071ba <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000718e:	6c 48       	ld.w	r8,r6[0x10]
80007190:	58 08       	cp.w	r8,0
80007192:	c1 40       	breq	800071ba <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007194:	ec c4 ff f0 	sub	r4,r6,-16
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
80007198:	30 05       	mov	r5,0
8000719a:	c0 48       	rjmp	800071a2 <prvUnlockQueue+0x72>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000719c:	6c 48       	ld.w	r8,r6[0x10]
8000719e:	58 08       	cp.w	r8,0
800071a0:	c0 d0       	breq	800071ba <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800071a2:	08 9c       	mov	r12,r4
800071a4:	f0 1f 00 0a 	mcall	800071cc <prvUnlockQueue+0x9c>
800071a8:	c0 30       	breq	800071ae <prvUnlockQueue+0x7e>
                {
                    vTaskMissedYield();
800071aa:	f0 1f 00 0a 	mcall	800071d0 <prvUnlockQueue+0xa0>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
800071ae:	20 17       	sub	r7,1
800071b0:	5c 57       	castu.b	r7
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
800071b2:	ea 07 18 00 	cp.b	r7,r5
800071b6:	fe 99 ff f3 	brgt	8000719c <prvUnlockQueue+0x6c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
800071ba:	3f f8       	mov	r8,-1
800071bc:	ed 68 00 44 	st.b	r6[68],r8
    }
    taskEXIT_CRITICAL();
800071c0:	f0 1f 00 05 	mcall	800071d4 <prvUnlockQueue+0xa4>
}
800071c4:	d8 22       	popm	r4-r7,pc
800071c6:	00 00       	add	r0,r0
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	6e c8       	ld.w	r8,r7[0x30]
800071cc:	80 00       	ld.sh	r0,r0[0x0]
800071ce:	7a 8c       	ld.w	r12,sp[0x20]
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	77 58       	ld.w	r8,r11[0x54]
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	6f d4       	ld.w	r4,r7[0x74]

800071d8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
800071d8:	d4 31       	pushm	r0-r7,lr
800071da:	20 5d       	sub	sp,20
800071dc:	18 97       	mov	r7,r12
800071de:	50 1b       	stdsp	sp[0x4],r11
800071e0:	50 2a       	stdsp	sp[0x8],r10
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800071e2:	f8 c8 ff dc 	sub	r8,r12,-36
800071e6:	50 08       	stdsp	sp[0x0],r8
800071e8:	30 04       	mov	r4,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800071ea:	fa c3 ff f4 	sub	r3,sp,-12
800071ee:	30 10       	mov	r0,1

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
800071f0:	3f f5       	mov	r5,-1
800071f2:	30 01       	mov	r1,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071f4:	fa c2 ff f8 	sub	r2,sp,-8
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
800071f8:	f0 1f 00 30 	mcall	800072b8 <xQueueReceive+0xe0>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
800071fc:	6e e6       	ld.w	r6,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
800071fe:	58 06       	cp.w	r6,0
80007200:	c1 40       	breq	80007228 <xQueueReceive+0x50>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
80007202:	40 1b       	lddsp	r11,sp[0x4]
80007204:	0e 9c       	mov	r12,r7
80007206:	f0 1f 00 2e 	mcall	800072bc <xQueueReceive+0xe4>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
8000720a:	20 16       	sub	r6,1
8000720c:	8f e6       	st.w	r7[0x38],r6

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000720e:	6e 48       	ld.w	r8,r7[0x10]
80007210:	58 08       	cp.w	r8,0
80007212:	c0 70       	breq	80007220 <xQueueReceive+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007214:	ee cc ff f0 	sub	r12,r7,-16
80007218:	f0 1f 00 2a 	mcall	800072c0 <xQueueReceive+0xe8>
8000721c:	c0 20       	breq	80007220 <xQueueReceive+0x48>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
8000721e:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
80007220:	f0 1f 00 29 	mcall	800072c4 <xQueueReceive+0xec>
80007224:	30 1c       	mov	r12,1
                return pdPASS;
80007226:	c4 78       	rjmp	800072b4 <xQueueReceive+0xdc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007228:	40 28       	lddsp	r8,sp[0x8]
8000722a:	58 08       	cp.w	r8,0
8000722c:	c0 51       	brne	80007236 <xQueueReceive+0x5e>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
8000722e:	f0 1f 00 26 	mcall	800072c4 <xQueueReceive+0xec>
80007232:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80007234:	c4 08       	rjmp	800072b4 <xQueueReceive+0xdc>
                }
                else if( xEntryTimeSet == pdFALSE )
80007236:	58 04       	cp.w	r4,0
80007238:	c0 51       	brne	80007242 <xQueueReceive+0x6a>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000723a:	06 9c       	mov	r12,r3
8000723c:	f0 1f 00 23 	mcall	800072c8 <xQueueReceive+0xf0>
80007240:	00 94       	mov	r4,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80007242:	f0 1f 00 21 	mcall	800072c4 <xQueueReceive+0xec>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
80007246:	f0 1f 00 22 	mcall	800072cc <xQueueReceive+0xf4>
        prvLockQueue( pxQueue );
8000724a:	f0 1f 00 1c 	mcall	800072b8 <xQueueReceive+0xe0>
8000724e:	ef 38 00 44 	ld.ub	r8,r7[68]
80007252:	ea 08 18 00 	cp.b	r8,r5
80007256:	ef f1 0e 44 	st.beq	r7[0x44],r1
8000725a:	ef 38 00 45 	ld.ub	r8,r7[69]
8000725e:	ea 08 18 00 	cp.b	r8,r5
80007262:	ef f1 0e 45 	st.beq	r7[0x45],r1
80007266:	f0 1f 00 18 	mcall	800072c4 <xQueueReceive+0xec>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000726a:	04 9b       	mov	r11,r2
8000726c:	06 9c       	mov	r12,r3
8000726e:	f0 1f 00 19 	mcall	800072d0 <xQueueReceive+0xf8>
80007272:	c1 71       	brne	800072a0 <xQueueReceive+0xc8>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80007274:	0e 9c       	mov	r12,r7
80007276:	f0 1f 00 18 	mcall	800072d4 <xQueueReceive+0xfc>
8000727a:	c0 d0       	breq	80007294 <xQueueReceive+0xbc>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000727c:	40 2b       	lddsp	r11,sp[0x8]
8000727e:	40 0c       	lddsp	r12,sp[0x0]
80007280:	f0 1f 00 16 	mcall	800072d8 <xQueueReceive+0x100>
                prvUnlockQueue( pxQueue );
80007284:	0e 9c       	mov	r12,r7
80007286:	f0 1f 00 16 	mcall	800072dc <xQueueReceive+0x104>

                if( xTaskResumeAll() == pdFALSE )
8000728a:	f0 1f 00 16 	mcall	800072e0 <xQueueReceive+0x108>
8000728e:	cb 51       	brne	800071f8 <xQueueReceive+0x20>
                {
                    portYIELD_WITHIN_API();
80007290:	d7 33       	scall
80007292:	cb 3b       	rjmp	800071f8 <xQueueReceive+0x20>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
80007294:	0e 9c       	mov	r12,r7
80007296:	f0 1f 00 12 	mcall	800072dc <xQueueReceive+0x104>
                ( void ) xTaskResumeAll();
8000729a:	f0 1f 00 12 	mcall	800072e0 <xQueueReceive+0x108>
8000729e:	ca db       	rjmp	800071f8 <xQueueReceive+0x20>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
800072a0:	0e 9c       	mov	r12,r7
800072a2:	f0 1f 00 0f 	mcall	800072dc <xQueueReceive+0x104>
            ( void ) xTaskResumeAll();
800072a6:	f0 1f 00 0f 	mcall	800072e0 <xQueueReceive+0x108>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800072aa:	0e 9c       	mov	r12,r7
800072ac:	f0 1f 00 0a 	mcall	800072d4 <xQueueReceive+0xfc>
800072b0:	ca 40       	breq	800071f8 <xQueueReceive+0x20>
800072b2:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
800072b4:	2f bd       	sub	sp,-20
800072b6:	d8 32       	popm	r0-r7,pc
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	6e c8       	ld.w	r8,r7[0x30]
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	71 00       	ld.w	r0,r8[0x40]
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	7a 8c       	ld.w	r12,sp[0x20]
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	6f d4       	ld.w	r4,r7[0x74]
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	77 40       	ld.w	r0,r11[0x50]
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	76 bc       	ld.w	r12,r11[0x2c]
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	77 ac       	ld.w	r12,r11[0x68]
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	70 e0       	ld.w	r0,r8[0x38]
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	80 1c       	ld.sh	r12,r0[0x2]
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	71 30       	ld.w	r0,r8[0x4c]
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	7c 20       	ld.w	r0,lr[0x8]

800072e4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
800072e4:	d4 31       	pushm	r0-r7,lr
800072e6:	20 4d       	sub	sp,16
800072e8:	18 97       	mov	r7,r12
800072ea:	50 1b       	stdsp	sp[0x4],r11
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800072ec:	f8 c1 ff dc 	sub	r1,r12,-36
800072f0:	30 08       	mov	r8,0
800072f2:	50 08       	stdsp	sp[0x0],r8
800072f4:	10 95       	mov	r5,r8
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800072f6:	fa c4 ff f8 	sub	r4,sp,-8
800072fa:	30 10       	mov	r0,1

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
800072fc:	3f f6       	mov	r6,-1
800072fe:	30 02       	mov	r2,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007300:	fa c3 ff fc 	sub	r3,sp,-4
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
80007304:	f0 1f 00 42 	mcall	8000740c <xQueueSemaphoreTake+0x128>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
80007308:	6e e8       	ld.w	r8,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
8000730a:	58 08       	cp.w	r8,0
8000730c:	c1 60       	breq	80007338 <xQueueSemaphoreTake+0x54>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
8000730e:	20 18       	sub	r8,1
80007310:	8f e8       	st.w	r7[0x38],r8

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007312:	6e 08       	ld.w	r8,r7[0x0]
80007314:	58 08       	cp.w	r8,0
80007316:	c0 41       	brne	8000731e <xQueueSemaphoreTake+0x3a>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
80007318:	f0 1f 00 3e 	mcall	80007410 <xQueueSemaphoreTake+0x12c>
8000731c:	8f 2c       	st.w	r7[0x8],r12
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000731e:	6e 48       	ld.w	r8,r7[0x10]
80007320:	58 08       	cp.w	r8,0
80007322:	c0 70       	breq	80007330 <xQueueSemaphoreTake+0x4c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007324:	ee cc ff f0 	sub	r12,r7,-16
80007328:	f0 1f 00 3b 	mcall	80007414 <xQueueSemaphoreTake+0x130>
8000732c:	c0 20       	breq	80007330 <xQueueSemaphoreTake+0x4c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
8000732e:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
80007330:	f0 1f 00 3a 	mcall	80007418 <xQueueSemaphoreTake+0x134>
80007334:	30 1c       	mov	r12,1
                return pdPASS;
80007336:	c6 88       	rjmp	80007406 <xQueueSemaphoreTake+0x122>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007338:	40 18       	lddsp	r8,sp[0x4]
8000733a:	58 08       	cp.w	r8,0
8000733c:	c0 51       	brne	80007346 <xQueueSemaphoreTake+0x62>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
8000733e:	f0 1f 00 37 	mcall	80007418 <xQueueSemaphoreTake+0x134>
80007342:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80007344:	c6 18       	rjmp	80007406 <xQueueSemaphoreTake+0x122>
                }
                else if( xEntryTimeSet == pdFALSE )
80007346:	58 05       	cp.w	r5,0
80007348:	c0 51       	brne	80007352 <xQueueSemaphoreTake+0x6e>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000734a:	08 9c       	mov	r12,r4
8000734c:	f0 1f 00 34 	mcall	8000741c <xQueueSemaphoreTake+0x138>
80007350:	00 95       	mov	r5,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80007352:	f0 1f 00 32 	mcall	80007418 <xQueueSemaphoreTake+0x134>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
80007356:	f0 1f 00 33 	mcall	80007420 <xQueueSemaphoreTake+0x13c>
        prvLockQueue( pxQueue );
8000735a:	f0 1f 00 2d 	mcall	8000740c <xQueueSemaphoreTake+0x128>
8000735e:	ef 38 00 44 	ld.ub	r8,r7[68]
80007362:	ec 08 18 00 	cp.b	r8,r6
80007366:	ef f2 0e 44 	st.beq	r7[0x44],r2
8000736a:	ef 38 00 45 	ld.ub	r8,r7[69]
8000736e:	ec 08 18 00 	cp.b	r8,r6
80007372:	ef f2 0e 45 	st.beq	r7[0x45],r2
80007376:	f0 1f 00 29 	mcall	80007418 <xQueueSemaphoreTake+0x134>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000737a:	06 9b       	mov	r11,r3
8000737c:	08 9c       	mov	r12,r4
8000737e:	f0 1f 00 2a 	mcall	80007424 <xQueueSemaphoreTake+0x140>
80007382:	c2 21       	brne	800073c6 <xQueueSemaphoreTake+0xe2>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80007384:	0e 9c       	mov	r12,r7
80007386:	f0 1f 00 29 	mcall	80007428 <xQueueSemaphoreTake+0x144>
8000738a:	c1 80       	breq	800073ba <xQueueSemaphoreTake+0xd6>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000738c:	6e 08       	ld.w	r8,r7[0x0]
8000738e:	58 08       	cp.w	r8,0
80007390:	c0 91       	brne	800073a2 <xQueueSemaphoreTake+0xbe>
                        {
                            taskENTER_CRITICAL();
80007392:	f0 1f 00 1f 	mcall	8000740c <xQueueSemaphoreTake+0x128>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
80007396:	6e 2c       	ld.w	r12,r7[0x8]
80007398:	f0 1f 00 25 	mcall	8000742c <xQueueSemaphoreTake+0x148>
8000739c:	50 0c       	stdsp	sp[0x0],r12
                            }
                            taskEXIT_CRITICAL();
8000739e:	f0 1f 00 1f 	mcall	80007418 <xQueueSemaphoreTake+0x134>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800073a2:	40 1b       	lddsp	r11,sp[0x4]
800073a4:	02 9c       	mov	r12,r1
800073a6:	f0 1f 00 23 	mcall	80007430 <xQueueSemaphoreTake+0x14c>
                prvUnlockQueue( pxQueue );
800073aa:	0e 9c       	mov	r12,r7
800073ac:	f0 1f 00 22 	mcall	80007434 <xQueueSemaphoreTake+0x150>

                if( xTaskResumeAll() == pdFALSE )
800073b0:	f0 1f 00 22 	mcall	80007438 <xQueueSemaphoreTake+0x154>
800073b4:	ca 81       	brne	80007304 <xQueueSemaphoreTake+0x20>
                {
                    portYIELD_WITHIN_API();
800073b6:	d7 33       	scall
800073b8:	ca 6b       	rjmp	80007304 <xQueueSemaphoreTake+0x20>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
800073ba:	0e 9c       	mov	r12,r7
800073bc:	f0 1f 00 1e 	mcall	80007434 <xQueueSemaphoreTake+0x150>
                ( void ) xTaskResumeAll();
800073c0:	f0 1f 00 1e 	mcall	80007438 <xQueueSemaphoreTake+0x154>
800073c4:	ca 0b       	rjmp	80007304 <xQueueSemaphoreTake+0x20>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
800073c6:	0e 9c       	mov	r12,r7
800073c8:	f0 1f 00 1b 	mcall	80007434 <xQueueSemaphoreTake+0x150>
            ( void ) xTaskResumeAll();
800073cc:	f0 1f 00 1b 	mcall	80007438 <xQueueSemaphoreTake+0x154>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800073d0:	0e 9c       	mov	r12,r7
800073d2:	f0 1f 00 16 	mcall	80007428 <xQueueSemaphoreTake+0x144>
800073d6:	c9 70       	breq	80007304 <xQueueSemaphoreTake+0x20>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
800073d8:	40 08       	lddsp	r8,sp[0x0]
800073da:	58 08       	cp.w	r8,0
800073dc:	c0 31       	brne	800073e2 <xQueueSemaphoreTake+0xfe>
800073de:	30 0c       	mov	r12,0
800073e0:	c1 38       	rjmp	80007406 <xQueueSemaphoreTake+0x122>
                        {
                            taskENTER_CRITICAL();
800073e2:	f0 1f 00 0b 	mcall	8000740c <xQueueSemaphoreTake+0x128>
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
800073e6:	6e 98       	ld.w	r8,r7[0x24]
800073e8:	58 08       	cp.w	r8,0
800073ea:	f9 bb 00 00 	moveq	r11,0
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
800073ee:	ef f8 10 0c 	ld.wne	r8,r7[0x30]
800073f2:	f1 fb 10 00 	ld.wne	r11,r8[0x0]
800073f6:	fb bb 01 08 	rsubne	r11,8
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
800073fa:	6e 2c       	ld.w	r12,r7[0x8]
800073fc:	f0 1f 00 10 	mcall	8000743c <xQueueSemaphoreTake+0x158>
                            }
                            taskEXIT_CRITICAL();
80007400:	f0 1f 00 06 	mcall	80007418 <xQueueSemaphoreTake+0x134>
80007404:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
80007406:	2f cd       	sub	sp,-16
80007408:	d8 32       	popm	r0-r7,pc
8000740a:	00 00       	add	r0,r0
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	6e c8       	ld.w	r8,r7[0x30]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	77 8c       	ld.w	r12,r11[0x60]
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	7a 8c       	ld.w	r12,sp[0x20]
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	6f d4       	ld.w	r4,r7[0x74]
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	77 40       	ld.w	r0,r11[0x50]
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	76 bc       	ld.w	r12,r11[0x2c]
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	77 ac       	ld.w	r12,r11[0x68]
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	70 e0       	ld.w	r0,r8[0x38]
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	79 e8       	ld.w	r8,r12[0x78]
80007430:	80 00       	ld.sh	r0,r0[0x0]
80007432:	80 1c       	ld.sh	r12,r0[0x2]
80007434:	80 00       	ld.sh	r0,r0[0x0]
80007436:	71 30       	ld.w	r0,r8[0x4c]
80007438:	80 00       	ld.sh	r0,r0[0x0]
8000743a:	7c 20       	ld.w	r0,lr[0x8]
8000743c:	80 00       	ld.sh	r0,r0[0x0]
8000743e:	79 04       	ld.w	r4,r12[0x40]

80007440 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
80007440:	eb cd 40 e0 	pushm	r5-r7,lr
80007444:	18 97       	mov	r7,r12
80007446:	14 96       	mov	r6,r10
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80007448:	78 e5       	ld.w	r5,r12[0x38]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
8000744a:	79 0a       	ld.w	r10,r12[0x40]
8000744c:	58 0a       	cp.w	r10,0
8000744e:	c0 a1       	brne	80007462 <prvCopyDataToQueue+0x22>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007450:	78 08       	ld.w	r8,r12[0x0]
80007452:	58 08       	cp.w	r8,0
80007454:	c3 11       	brne	800074b6 <prvCopyDataToQueue+0x76>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
80007456:	78 2c       	ld.w	r12,r12[0x8]
80007458:	f0 1f 00 1a 	mcall	800074c0 <prvCopyDataToQueue+0x80>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
8000745c:	30 08       	mov	r8,0
8000745e:	8f 28       	st.w	r7[0x8],r8
80007460:	c2 c8       	rjmp	800074b8 <prvCopyDataToQueue+0x78>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
80007462:	58 06       	cp.w	r6,0
80007464:	c1 01       	brne	80007484 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
80007466:	78 1c       	ld.w	r12,r12[0x4]
80007468:	f0 1f 00 17 	mcall	800074c4 <prvCopyDataToQueue+0x84>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
8000746c:	6e 19       	ld.w	r9,r7[0x4]
8000746e:	6f 08       	ld.w	r8,r7[0x40]
80007470:	f2 08 00 08 	add	r8,r9,r8
80007474:	8f 18       	st.w	r7[0x4],r8

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80007476:	6e 29       	ld.w	r9,r7[0x8]
80007478:	12 38       	cp.w	r8,r9
8000747a:	c1 e3       	brcs	800074b6 <prvCopyDataToQueue+0x76>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
8000747c:	6e 08       	ld.w	r8,r7[0x0]
8000747e:	8f 18       	st.w	r7[0x4],r8
80007480:	30 0c       	mov	r12,0
80007482:	c1 b8       	rjmp	800074b8 <prvCopyDataToQueue+0x78>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
80007484:	78 3c       	ld.w	r12,r12[0xc]
80007486:	f0 1f 00 10 	mcall	800074c4 <prvCopyDataToQueue+0x84>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
8000748a:	6f 08       	ld.w	r8,r7[0x40]
8000748c:	6e 39       	ld.w	r9,r7[0xc]
8000748e:	f2 08 01 08 	sub	r8,r9,r8
80007492:	8f 38       	st.w	r7[0xc],r8

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80007494:	6e 09       	ld.w	r9,r7[0x0]
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
80007496:	12 38       	cp.w	r8,r9
80007498:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000749c:	ef f9 30 02 	ld.wcs	r9,r7[0x8]
800074a0:	f3 d8 e3 19 	subcs	r9,r9,r8
800074a4:	ef f9 3a 03 	st.wcs	r7[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
800074a8:	58 26       	cp.w	r6,2
800074aa:	c0 61       	brne	800074b6 <prvCopyDataToQueue+0x76>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
800074ac:	58 05       	cp.w	r5,0
800074ae:	c0 40       	breq	800074b6 <prvCopyDataToQueue+0x76>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
800074b0:	20 15       	sub	r5,1
800074b2:	30 0c       	mov	r12,0
800074b4:	c0 28       	rjmp	800074b8 <prvCopyDataToQueue+0x78>
800074b6:	30 0c       	mov	r12,0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
800074b8:	2f f5       	sub	r5,-1
800074ba:	8f e5       	st.w	r7[0x38],r5

    return xReturn;
}
800074bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800074c0:	80 00       	ld.sh	r0,r0[0x0]
800074c2:	79 80       	ld.w	r0,r12[0x60]
800074c4:	80 00       	ld.sh	r0,r0[0x0]
800074c6:	9f ac       	st.w	pc[0x28],r12

800074c8 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
800074c8:	d4 31       	pushm	r0-r7,lr
800074ca:	20 5d       	sub	sp,20
800074cc:	18 97       	mov	r7,r12
800074ce:	50 1b       	stdsp	sp[0x4],r11
800074d0:	50 2a       	stdsp	sp[0x8],r10
800074d2:	12 91       	mov	r1,r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800074d4:	f8 c8 ff f0 	sub	r8,r12,-16
800074d8:	50 08       	stdsp	sp[0x0],r8
800074da:	30 03       	mov	r3,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800074dc:	fa c2 ff f4 	sub	r2,sp,-12

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
800074e0:	3f f5       	mov	r5,-1

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800074e2:	fa c0 ff f8 	sub	r0,sp,-8
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
800074e6:	f0 1f 00 36 	mcall	800075bc <xQueueGenericSend+0xf4>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
800074ea:	6e e9       	ld.w	r9,r7[0x38]
800074ec:	6e f8       	ld.w	r8,r7[0x3c]
800074ee:	10 39       	cp.w	r9,r8
800074f0:	c0 33       	brcs	800074f6 <xQueueGenericSend+0x2e>
800074f2:	58 21       	cp.w	r1,2
800074f4:	c1 71       	brne	80007522 <xQueueGenericSend+0x5a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800074f6:	02 9a       	mov	r10,r1
800074f8:	40 1b       	lddsp	r11,sp[0x4]
800074fa:	0e 9c       	mov	r12,r7
800074fc:	f0 1f 00 31 	mcall	800075c0 <xQueueGenericSend+0xf8>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007500:	6e 98       	ld.w	r8,r7[0x24]
80007502:	58 08       	cp.w	r8,0
80007504:	c0 80       	breq	80007514 <xQueueGenericSend+0x4c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007506:	ee cc ff dc 	sub	r12,r7,-36
8000750a:	f0 1f 00 2f 	mcall	800075c4 <xQueueGenericSend+0xfc>
8000750e:	c0 60       	breq	8000751a <xQueueGenericSend+0x52>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
80007510:	d7 33       	scall
80007512:	c0 48       	rjmp	8000751a <xQueueGenericSend+0x52>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
80007514:	58 0c       	cp.w	r12,0
80007516:	c0 20       	breq	8000751a <xQueueGenericSend+0x52>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
80007518:	d7 33       	scall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
8000751a:	f0 1f 00 2c 	mcall	800075c8 <xQueueGenericSend+0x100>
8000751e:	30 1c       	mov	r12,1
                return pdPASS;
80007520:	c4 b8       	rjmp	800075b6 <xQueueGenericSend+0xee>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
80007522:	40 28       	lddsp	r8,sp[0x8]
80007524:	58 08       	cp.w	r8,0
80007526:	c0 51       	brne	80007530 <xQueueGenericSend+0x68>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
80007528:	f0 1f 00 28 	mcall	800075c8 <xQueueGenericSend+0x100>
8000752c:	30 0c       	mov	r12,0

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
8000752e:	c4 48       	rjmp	800075b6 <xQueueGenericSend+0xee>
                }
                else if( xEntryTimeSet == pdFALSE )
80007530:	58 03       	cp.w	r3,0
80007532:	c0 51       	brne	8000753c <xQueueGenericSend+0x74>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
80007534:	04 9c       	mov	r12,r2
80007536:	f0 1f 00 26 	mcall	800075cc <xQueueGenericSend+0x104>
8000753a:	30 13       	mov	r3,1
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
8000753c:	f0 1f 00 23 	mcall	800075c8 <xQueueGenericSend+0x100>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
80007540:	f0 1f 00 24 	mcall	800075d0 <xQueueGenericSend+0x108>
        prvLockQueue( pxQueue );
80007544:	f0 1f 00 1e 	mcall	800075bc <xQueueGenericSend+0xf4>
80007548:	ef 38 00 44 	ld.ub	r8,r7[68]
8000754c:	ea 08 18 00 	cp.b	r8,r5
80007550:	f9 b8 00 00 	moveq	r8,0
80007554:	ef f8 0e 44 	st.beq	r7[0x44],r8
80007558:	ef 38 00 45 	ld.ub	r8,r7[69]
8000755c:	ea 08 18 00 	cp.b	r8,r5
80007560:	f9 b8 00 00 	moveq	r8,0
80007564:	ef f8 0e 45 	st.beq	r7[0x45],r8
80007568:	f0 1f 00 18 	mcall	800075c8 <xQueueGenericSend+0x100>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000756c:	00 9b       	mov	r11,r0
8000756e:	04 9c       	mov	r12,r2
80007570:	f0 1f 00 19 	mcall	800075d4 <xQueueGenericSend+0x10c>
80007574:	c1 b1       	brne	800075aa <xQueueGenericSend+0xe2>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
80007576:	f0 1f 00 12 	mcall	800075bc <xQueueGenericSend+0xf4>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
8000757a:	6e e4       	ld.w	r4,r7[0x38]
8000757c:	6e f6       	ld.w	r6,r7[0x3c]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
8000757e:	f0 1f 00 13 	mcall	800075c8 <xQueueGenericSend+0x100>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
80007582:	0c 34       	cp.w	r4,r6
80007584:	c0 d1       	brne	8000759e <xQueueGenericSend+0xd6>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007586:	40 2b       	lddsp	r11,sp[0x8]
80007588:	40 0c       	lddsp	r12,sp[0x0]
8000758a:	f0 1f 00 14 	mcall	800075d8 <xQueueGenericSend+0x110>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
8000758e:	0e 9c       	mov	r12,r7
80007590:	f0 1f 00 13 	mcall	800075dc <xQueueGenericSend+0x114>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
80007594:	f0 1f 00 13 	mcall	800075e0 <xQueueGenericSend+0x118>
80007598:	ca 71       	brne	800074e6 <xQueueGenericSend+0x1e>
                {
                    portYIELD_WITHIN_API();
8000759a:	d7 33       	scall
8000759c:	ca 5b       	rjmp	800074e6 <xQueueGenericSend+0x1e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
8000759e:	0e 9c       	mov	r12,r7
800075a0:	f0 1f 00 0f 	mcall	800075dc <xQueueGenericSend+0x114>
                ( void ) xTaskResumeAll();
800075a4:	f0 1f 00 0f 	mcall	800075e0 <xQueueGenericSend+0x118>
800075a8:	c9 fb       	rjmp	800074e6 <xQueueGenericSend+0x1e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
800075aa:	0e 9c       	mov	r12,r7
800075ac:	f0 1f 00 0c 	mcall	800075dc <xQueueGenericSend+0x114>
            ( void ) xTaskResumeAll();
800075b0:	f0 1f 00 0c 	mcall	800075e0 <xQueueGenericSend+0x118>
800075b4:	30 0c       	mov	r12,0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
800075b6:	2f bd       	sub	sp,-20
800075b8:	d8 32       	popm	r0-r7,pc
800075ba:	00 00       	add	r0,r0
800075bc:	80 00       	ld.sh	r0,r0[0x0]
800075be:	6e c8       	ld.w	r8,r7[0x30]
800075c0:	80 00       	ld.sh	r0,r0[0x0]
800075c2:	74 40       	ld.w	r0,r10[0x10]
800075c4:	80 00       	ld.sh	r0,r0[0x0]
800075c6:	7a 8c       	ld.w	r12,sp[0x20]
800075c8:	80 00       	ld.sh	r0,r0[0x0]
800075ca:	6f d4       	ld.w	r4,r7[0x74]
800075cc:	80 00       	ld.sh	r0,r0[0x0]
800075ce:	77 40       	ld.w	r0,r11[0x50]
800075d0:	80 00       	ld.sh	r0,r0[0x0]
800075d2:	76 bc       	ld.w	r12,r11[0x2c]
800075d4:	80 00       	ld.sh	r0,r0[0x0]
800075d6:	77 ac       	ld.w	r12,r11[0x68]
800075d8:	80 00       	ld.sh	r0,r0[0x0]
800075da:	80 1c       	ld.sh	r12,r0[0x2]
800075dc:	80 00       	ld.sh	r0,r0[0x0]
800075de:	71 30       	ld.w	r0,r8[0x4c]
800075e0:	80 00       	ld.sh	r0,r0[0x0]
800075e2:	7c 20       	ld.w	r0,lr[0x8]

800075e4 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
800075e4:	eb cd 40 c0 	pushm	r6-r7,lr
800075e8:	18 97       	mov	r7,r12
800075ea:	16 96       	mov	r6,r11
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
800075ec:	f0 1f 00 18 	mcall	8000764c <xQueueGenericReset+0x68>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
800075f0:	6f 09       	ld.w	r9,r7[0x40]
800075f2:	6e fa       	ld.w	r10,r7[0x3c]
800075f4:	f2 0a 02 4b 	mul	r11,r9,r10
800075f8:	6e 08       	ld.w	r8,r7[0x0]
800075fa:	f0 0b 00 0b 	add	r11,r8,r11
800075fe:	8f 2b       	st.w	r7[0x8],r11
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80007600:	30 0b       	mov	r11,0
80007602:	8f eb       	st.w	r7[0x38],r11
        pxQueue->pcWriteTo = pxQueue->pcHead;
80007604:	8f 18       	st.w	r7[0x4],r8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
80007606:	20 1a       	sub	r10,1
80007608:	f4 09 02 49 	mul	r9,r10,r9
8000760c:	12 08       	add	r8,r9
8000760e:	8f 38       	st.w	r7[0xc],r8
        pxQueue->cRxLock = queueUNLOCKED;
80007610:	3f f8       	mov	r8,-1
80007612:	ef 68 00 44 	st.b	r7[68],r8
        pxQueue->cTxLock = queueUNLOCKED;
80007616:	ef 68 00 45 	st.b	r7[69],r8

        if( xNewQueue == pdFALSE )
8000761a:	58 06       	cp.w	r6,0
8000761c:	c0 b1       	brne	80007632 <xQueueGenericReset+0x4e>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000761e:	6e 48       	ld.w	r8,r7[0x10]
80007620:	58 08       	cp.w	r8,0
80007622:	c1 00       	breq	80007642 <xQueueGenericReset+0x5e>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007624:	ee cc ff f0 	sub	r12,r7,-16
80007628:	f0 1f 00 0a 	mcall	80007650 <xQueueGenericReset+0x6c>
8000762c:	c0 b0       	breq	80007642 <xQueueGenericReset+0x5e>
                {
                    queueYIELD_IF_USING_PREEMPTION();
8000762e:	d7 33       	scall
80007630:	c0 98       	rjmp	80007642 <xQueueGenericReset+0x5e>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80007632:	ee cc ff f0 	sub	r12,r7,-16
80007636:	f0 1f 00 08 	mcall	80007654 <xQueueGenericReset+0x70>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
8000763a:	ee cc ff dc 	sub	r12,r7,-36
8000763e:	f0 1f 00 06 	mcall	80007654 <xQueueGenericReset+0x70>
        }
    }
    taskEXIT_CRITICAL();
80007642:	f0 1f 00 06 	mcall	80007658 <xQueueGenericReset+0x74>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
80007646:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000764a:	00 00       	add	r0,r0
8000764c:	80 00       	ld.sh	r0,r0[0x0]
8000764e:	6e c8       	ld.w	r8,r7[0x30]
80007650:	80 00       	ld.sh	r0,r0[0x0]
80007652:	7a 8c       	ld.w	r12,sp[0x20]
80007654:	80 00       	ld.sh	r0,r0[0x0]
80007656:	6d ac       	ld.w	r12,r6[0x68]
80007658:	80 00       	ld.sh	r0,r0[0x0]
8000765a:	6f d4       	ld.w	r4,r7[0x74]

8000765c <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
8000765c:	eb cd 40 e0 	pushm	r5-r7,lr
80007660:	18 95       	mov	r5,r12
80007662:	16 96       	mov	r6,r11
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
80007664:	f6 0c 02 4c 	mul	r12,r11,r12
80007668:	2b 8c       	sub	r12,-72
8000766a:	f0 1f 00 0b 	mcall	80007694 <xQueueGenericCreate+0x38>
8000766e:	18 97       	mov	r7,r12

        if( pxNewQueue != NULL )
80007670:	c0 f0       	breq	8000768e <xQueueGenericCreate+0x32>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
80007672:	58 06       	cp.w	r6,0
80007674:	c0 31       	brne	8000767a <xQueueGenericCreate+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
80007676:	8f 0c       	st.w	r7[0x0],r12
80007678:	c0 48       	rjmp	80007680 <xQueueGenericCreate+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
8000767a:	f8 c8 ff b8 	sub	r8,r12,-72
8000767e:	99 08       	st.w	r12[0x0],r8
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
80007680:	8f f5       	st.w	r7[0x3c],r5
    pxNewQueue->uxItemSize = uxItemSize;
80007682:	ef 46 00 40 	st.w	r7[64],r6
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
80007686:	30 1b       	mov	r11,1
80007688:	0e 9c       	mov	r12,r7
8000768a:	f0 1f 00 04 	mcall	80007698 <xQueueGenericCreate+0x3c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
8000768e:	0e 9c       	mov	r12,r7
80007690:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007694:	80 00       	ld.sh	r0,r0[0x0]
80007696:	70 b8       	ld.w	r8,r8[0x2c]
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	75 e4       	ld.w	r4,r10[0x78]

8000769c <prvTaskIsTaskSuspended>:

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
8000769c:	78 59       	ld.w	r9,r12[0x14]
8000769e:	48 68       	lddpc	r8,800076b4 <prvTaskIsTaskSuspended+0x18>
800076a0:	10 39       	cp.w	r9,r8
800076a2:	c0 81       	brne	800076b2 <prvTaskIsTaskSuspended+0x16>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
800076a4:	78 a8       	ld.w	r8,r12[0x28]
800076a6:	48 59       	lddpc	r9,800076b8 <prvTaskIsTaskSuspended+0x1c>
800076a8:	12 38       	cp.w	r8,r9
800076aa:	c0 40       	breq	800076b2 <prvTaskIsTaskSuspended+0x16>
800076ac:	58 08       	cp.w	r8,0
800076ae:	5f 0c       	sreq	r12
800076b0:	5e fc       	retal	r12
800076b2:	5e fd       	retal	0
800076b4:	00 00       	add	r0,r0
800076b6:	76 18       	ld.w	r8,r11[0x4]
800076b8:	00 00       	add	r0,r0
800076ba:	75 b4       	ld.w	r4,r10[0x6c]

800076bc <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
800076bc:	48 38       	lddpc	r8,800076c8 <vTaskSuspendAll+0xc>
800076be:	70 09       	ld.w	r9,r8[0x0]
800076c0:	2f f9       	sub	r9,-1
800076c2:	91 09       	st.w	r8[0x0],r9

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
800076c4:	5e fc       	retal	r12
800076c6:	00 00       	add	r0,r0
800076c8:	00 00       	add	r0,r0
800076ca:	75 e0       	ld.w	r0,r10[0x78]

800076cc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
800076cc:	49 88       	lddpc	r8,8000772c <vTaskSwitchContext+0x60>
800076ce:	70 08       	ld.w	r8,r8[0x0]
800076d0:	58 08       	cp.w	r8,0
800076d2:	c0 50       	breq	800076dc <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
800076d4:	30 19       	mov	r9,1
800076d6:	49 78       	lddpc	r8,80007730 <vTaskSwitchContext+0x64>
800076d8:	91 09       	st.w	r8[0x0],r9
800076da:	5e fc       	retal	r12
    }
    else
    {
        xYieldPending = pdFALSE;
800076dc:	30 09       	mov	r9,0
800076de:	49 58       	lddpc	r8,80007730 <vTaskSwitchContext+0x64>
800076e0:	91 09       	st.w	r8[0x0],r9
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800076e2:	49 58       	lddpc	r8,80007734 <vTaskSwitchContext+0x68>
800076e4:	70 09       	ld.w	r9,r8[0x0]
800076e6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800076ea:	a3 68       	lsl	r8,0x2
800076ec:	49 3b       	lddpc	r11,80007738 <vTaskSwitchContext+0x6c>
800076ee:	10 0b       	add	r11,r8
800076f0:	76 0a       	ld.w	r10,r11[0x0]
800076f2:	58 0a       	cp.w	r10,0
800076f4:	c0 b1       	brne	8000770a <vTaskSwitchContext+0x3e>
800076f6:	21 48       	sub	r8,20
800076f8:	49 0a       	lddpc	r10,80007738 <vTaskSwitchContext+0x6c>
800076fa:	f4 08 00 08 	add	r8,r10,r8
800076fe:	20 19       	sub	r9,1
80007700:	10 9b       	mov	r11,r8
80007702:	70 0a       	ld.w	r10,r8[0x0]
80007704:	21 48       	sub	r8,20
80007706:	58 0a       	cp.w	r10,0
80007708:	cf b0       	breq	800076fe <vTaskSwitchContext+0x32>
8000770a:	76 18       	ld.w	r8,r11[0x4]
8000770c:	70 18       	ld.w	r8,r8[0x4]
8000770e:	97 18       	st.w	r11[0x4],r8
80007710:	f6 ca ff f8 	sub	r10,r11,-8
80007714:	14 38       	cp.w	r8,r10
80007716:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
8000771a:	f7 f8 0a 01 	st.weq	r11[0x4],r8
8000771e:	76 18       	ld.w	r8,r11[0x4]
80007720:	70 3a       	ld.w	r10,r8[0xc]
80007722:	48 78       	lddpc	r8,8000773c <vTaskSwitchContext+0x70>
80007724:	91 0a       	st.w	r8[0x0],r10
80007726:	48 48       	lddpc	r8,80007734 <vTaskSwitchContext+0x68>
80007728:	91 09       	st.w	r8[0x0],r9
8000772a:	5e fc       	retal	r12
8000772c:	00 00       	add	r0,r0
8000772e:	75 e0       	ld.w	r0,r10[0x78]
80007730:	00 00       	add	r0,r0
80007732:	76 30       	ld.w	r0,r11[0xc]
80007734:	00 00       	add	r0,r0
80007736:	76 2c       	ld.w	r12,r11[0x8]
80007738:	00 00       	add	r0,r0
8000773a:	75 0c       	ld.w	r12,r10[0x40]
8000773c:	00 00       	add	r0,r0
8000773e:	75 b0       	ld.w	r0,r10[0x6c]

80007740 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
80007740:	48 48       	lddpc	r8,80007750 <vTaskInternalSetTimeOutState+0x10>
80007742:	70 08       	ld.w	r8,r8[0x0]
80007744:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
80007746:	48 48       	lddpc	r8,80007754 <vTaskInternalSetTimeOutState+0x14>
80007748:	70 08       	ld.w	r8,r8[0x0]
8000774a:	99 18       	st.w	r12[0x4],r8
}
8000774c:	5e fc       	retal	r12
8000774e:	00 00       	add	r0,r0
80007750:	00 00       	add	r0,r0
80007752:	75 00       	ld.w	r0,r10[0x40]
80007754:	00 00       	add	r0,r0
80007756:	75 dc       	ld.w	r12,r10[0x74]

80007758 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
80007758:	30 19       	mov	r9,1
8000775a:	48 28       	lddpc	r8,80007760 <vTaskMissedYield+0x8>
8000775c:	91 09       	st.w	r8[0x0],r9
}
8000775e:	5e fc       	retal	r12
80007760:	00 00       	add	r0,r0
80007762:	76 30       	ld.w	r0,r11[0xc]

80007764 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007764:	48 88       	lddpc	r8,80007784 <prvResetNextTaskUnblockTime+0x20>
80007766:	70 08       	ld.w	r8,r8[0x0]
80007768:	70 08       	ld.w	r8,r8[0x0]
8000776a:	58 08       	cp.w	r8,0
8000776c:	c0 51       	brne	80007776 <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
8000776e:	3f f9       	mov	r9,-1
80007770:	48 68       	lddpc	r8,80007788 <prvResetNextTaskUnblockTime+0x24>
80007772:	91 09       	st.w	r8[0x0],r9
80007774:	5e fc       	retal	r12
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
80007776:	48 48       	lddpc	r8,80007784 <prvResetNextTaskUnblockTime+0x20>
80007778:	70 08       	ld.w	r8,r8[0x0]
8000777a:	70 38       	ld.w	r8,r8[0xc]
8000777c:	70 09       	ld.w	r9,r8[0x0]
8000777e:	48 38       	lddpc	r8,80007788 <prvResetNextTaskUnblockTime+0x24>
80007780:	91 09       	st.w	r8[0x0],r9
80007782:	5e fc       	retal	r12
80007784:	00 00       	add	r0,r0
80007786:	74 f8       	ld.w	r8,r10[0x3c]
80007788:	00 00       	add	r0,r0
8000778a:	74 f4       	ld.w	r4,r10[0x3c]

8000778c <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
8000778c:	48 78       	lddpc	r8,800077a8 <pvTaskIncrementMutexHeldCount+0x1c>
8000778e:	70 08       	ld.w	r8,r8[0x0]
80007790:	58 08       	cp.w	r8,0
80007792:	c0 70       	breq	800077a0 <pvTaskIncrementMutexHeldCount+0x14>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
80007794:	48 58       	lddpc	r8,800077a8 <pvTaskIncrementMutexHeldCount+0x1c>
80007796:	70 08       	ld.w	r8,r8[0x0]
80007798:	71 29       	ld.w	r9,r8[0x48]
8000779a:	2f f9       	sub	r9,-1
8000779c:	f1 49 00 48 	st.w	r8[72],r9
        }

        return pxCurrentTCB;
800077a0:	48 28       	lddpc	r8,800077a8 <pvTaskIncrementMutexHeldCount+0x1c>
800077a2:	70 0c       	ld.w	r12,r8[0x0]
    }
800077a4:	5e fc       	retal	r12
800077a6:	00 00       	add	r0,r0
800077a8:	00 00       	add	r0,r0
800077aa:	75 b0       	ld.w	r0,r10[0x6c]

800077ac <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
800077ac:	eb cd 40 c0 	pushm	r6-r7,lr
800077b0:	18 97       	mov	r7,r12
800077b2:	16 96       	mov	r6,r11
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
800077b4:	f0 1f 00 14 	mcall	80007804 <xTaskCheckForTimeOut+0x58>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
800077b8:	49 48       	lddpc	r8,80007808 <xTaskCheckForTimeOut+0x5c>
800077ba:	70 0a       	ld.w	r10,r8[0x0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
800077bc:	6e 19       	ld.w	r9,r7[0x4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
800077be:	6c 08       	ld.w	r8,r6[0x0]
800077c0:	5b f8       	cp.w	r8,-1
800077c2:	c0 31       	brne	800077c8 <xTaskCheckForTimeOut+0x1c>
800077c4:	30 07       	mov	r7,0
800077c6:	c1 a8       	rjmp	800077fa <xTaskCheckForTimeOut+0x4e>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
800077c8:	49 1b       	lddpc	r11,8000780c <xTaskCheckForTimeOut+0x60>
800077ca:	76 0b       	ld.w	r11,r11[0x0]
800077cc:	6e 0c       	ld.w	r12,r7[0x0]
800077ce:	16 3c       	cp.w	r12,r11
800077d0:	c0 70       	breq	800077de <xTaskCheckForTimeOut+0x32>
800077d2:	12 3a       	cp.w	r10,r9
800077d4:	c0 53       	brcs	800077de <xTaskCheckForTimeOut+0x32>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
800077d6:	30 08       	mov	r8,0
800077d8:	8d 08       	st.w	r6[0x0],r8
800077da:	30 17       	mov	r7,1
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
800077dc:	c0 f8       	rjmp	800077fa <xTaskCheckForTimeOut+0x4e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
800077de:	f4 09 01 09 	sub	r9,r10,r9
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
800077e2:	10 39       	cp.w	r9,r8
800077e4:	c0 82       	brcc	800077f4 <xTaskCheckForTimeOut+0x48>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
800077e6:	12 18       	sub	r8,r9
800077e8:	8d 08       	st.w	r6[0x0],r8
            vTaskInternalSetTimeOutState( pxTimeOut );
800077ea:	0e 9c       	mov	r12,r7
800077ec:	f0 1f 00 09 	mcall	80007810 <xTaskCheckForTimeOut+0x64>
800077f0:	30 07       	mov	r7,0
800077f2:	c0 48       	rjmp	800077fa <xTaskCheckForTimeOut+0x4e>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
800077f4:	30 08       	mov	r8,0
800077f6:	8d 08       	st.w	r6[0x0],r8
800077f8:	30 17       	mov	r7,1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
800077fa:	f0 1f 00 07 	mcall	80007814 <xTaskCheckForTimeOut+0x68>

    return xReturn;
}
800077fe:	0e 9c       	mov	r12,r7
80007800:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007804:	80 00       	ld.sh	r0,r0[0x0]
80007806:	6e c8       	ld.w	r8,r7[0x30]
80007808:	00 00       	add	r0,r0
8000780a:	75 dc       	ld.w	r12,r10[0x74]
8000780c:	00 00       	add	r0,r0
8000780e:	75 00       	ld.w	r0,r10[0x40]
80007810:	80 00       	ld.sh	r0,r0[0x0]
80007812:	77 40       	ld.w	r0,r11[0x50]
80007814:	80 00       	ld.sh	r0,r0[0x0]
80007816:	6f d4       	ld.w	r4,r7[0x74]

80007818 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
80007818:	eb cd 40 f8 	pushm	r3-r7,lr
8000781c:	18 97       	mov	r7,r12
8000781e:	16 95       	mov	r5,r11
80007820:	14 93       	mov	r3,r10
80007822:	12 96       	mov	r6,r9
80007824:	10 94       	mov	r4,r8

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
80007826:	f0 1f 00 31 	mcall	800078e8 <xTaskGenericNotify+0xd0>
        {
            if( pulPreviousNotificationValue != NULL )
8000782a:	58 04       	cp.w	r4,0
8000782c:	c0 60       	breq	80007838 <xTaskGenericNotify+0x20>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
8000782e:	ea c8 ff ed 	sub	r8,r5,-19
80007832:	ee 08 03 28 	ld.w	r8,r7[r8<<0x2]
80007836:	89 08       	st.w	r4[0x0],r8
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
80007838:	ee 05 00 08 	add	r8,r7,r5
8000783c:	f1 39 00 50 	ld.ub	r9,r8[80]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
80007840:	30 2a       	mov	r10,2
80007842:	f1 6a 00 50 	st.b	r8[80],r10

            switch( eAction )
80007846:	58 26       	cp.w	r6,2
80007848:	c1 20       	breq	8000786c <xTaskGenericNotify+0x54>
8000784a:	e0 8b 00 05 	brhi	80007854 <xTaskGenericNotify+0x3c>
8000784e:	58 16       	cp.w	r6,1
80007850:	c2 21       	brne	80007894 <xTaskGenericNotify+0x7c>
80007852:	c0 68       	rjmp	8000785e <xTaskGenericNotify+0x46>
80007854:	58 36       	cp.w	r6,3
80007856:	c1 20       	breq	8000787a <xTaskGenericNotify+0x62>
80007858:	58 46       	cp.w	r6,4
8000785a:	c1 d1       	brne	80007894 <xTaskGenericNotify+0x7c>
8000785c:	c1 38       	rjmp	80007882 <xTaskGenericNotify+0x6a>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
8000785e:	2e d5       	sub	r5,-19
80007860:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
80007864:	10 43       	or	r3,r8
80007866:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
8000786a:	c1 58       	rjmp	80007894 <xTaskGenericNotify+0x7c>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
8000786c:	2e d5       	sub	r5,-19
8000786e:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
80007872:	2f f8       	sub	r8,-1
80007874:	ee 05 09 28 	st.w	r7[r5<<0x2],r8
                    break;
80007878:	c0 e8       	rjmp	80007894 <xTaskGenericNotify+0x7c>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
8000787a:	2e d5       	sub	r5,-19
8000787c:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
80007880:	c0 a8       	rjmp	80007894 <xTaskGenericNotify+0x7c>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80007882:	30 28       	mov	r8,2
80007884:	f0 09 18 00 	cp.b	r9,r8
80007888:	c0 31       	brne	8000788e <xTaskGenericNotify+0x76>
8000788a:	30 07       	mov	r7,0
8000788c:	c2 88       	rjmp	800078dc <xTaskGenericNotify+0xc4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
8000788e:	2e d5       	sub	r5,-19
80007890:	ee 05 09 23 	st.w	r7[r5<<0x2],r3

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80007894:	30 18       	mov	r8,1
80007896:	f0 09 18 00 	cp.b	r9,r8
8000789a:	c2 01       	brne	800078da <xTaskGenericNotify+0xc2>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8000789c:	ee c6 ff fc 	sub	r6,r7,-4
800078a0:	0c 9c       	mov	r12,r6
800078a2:	f0 1f 00 13 	mcall	800078ec <xTaskGenericNotify+0xd4>
                prvAddTaskToReadyList( pxTCB );
800078a6:	6e bc       	ld.w	r12,r7[0x2c]
800078a8:	49 28       	lddpc	r8,800078f0 <xTaskGenericNotify+0xd8>
800078aa:	70 08       	ld.w	r8,r8[0x0]
800078ac:	10 3c       	cp.w	r12,r8
800078ae:	e0 88 00 04 	brls	800078b6 <xTaskGenericNotify+0x9e>
800078b2:	49 08       	lddpc	r8,800078f0 <xTaskGenericNotify+0xd8>
800078b4:	91 0c       	st.w	r8[0x0],r12
800078b6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800078ba:	0c 9b       	mov	r11,r6
800078bc:	48 e8       	lddpc	r8,800078f4 <xTaskGenericNotify+0xdc>
800078be:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800078c2:	f0 1f 00 0e 	mcall	800078f8 <xTaskGenericNotify+0xe0>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
800078c6:	48 e8       	lddpc	r8,800078fc <xTaskGenericNotify+0xe4>
800078c8:	70 08       	ld.w	r8,r8[0x0]
800078ca:	6e b9       	ld.w	r9,r7[0x2c]
800078cc:	70 b8       	ld.w	r8,r8[0x2c]
800078ce:	10 39       	cp.w	r9,r8
800078d0:	e0 88 00 05 	brls	800078da <xTaskGenericNotify+0xc2>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
800078d4:	d7 33       	scall
800078d6:	30 17       	mov	r7,1
800078d8:	c0 28       	rjmp	800078dc <xTaskGenericNotify+0xc4>
800078da:	30 17       	mov	r7,1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
800078dc:	f0 1f 00 09 	mcall	80007900 <xTaskGenericNotify+0xe8>

        return xReturn;
    }
800078e0:	0e 9c       	mov	r12,r7
800078e2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800078e6:	00 00       	add	r0,r0
800078e8:	80 00       	ld.sh	r0,r0[0x0]
800078ea:	6e c8       	ld.w	r8,r7[0x30]
800078ec:	80 00       	ld.sh	r0,r0[0x0]
800078ee:	6e 0e       	ld.w	lr,r7[0x0]
800078f0:	00 00       	add	r0,r0
800078f2:	76 2c       	ld.w	r12,r11[0x8]
800078f4:	00 00       	add	r0,r0
800078f6:	75 0c       	ld.w	r12,r10[0x40]
800078f8:	80 00       	ld.sh	r0,r0[0x0]
800078fa:	6d c6       	ld.w	r6,r6[0x70]
800078fc:	00 00       	add	r0,r0
800078fe:	75 b0       	ld.w	r0,r10[0x6c]
80007900:	80 00       	ld.sh	r0,r0[0x0]
80007902:	6f d4       	ld.w	r4,r7[0x74]

80007904 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
80007904:	eb cd 40 c0 	pushm	r6-r7,lr
80007908:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
8000790a:	58 0c       	cp.w	r12,0
8000790c:	c2 f0       	breq	8000796a <vTaskPriorityDisinheritAfterTimeout+0x66>
8000790e:	79 18       	ld.w	r8,r12[0x44]
80007910:	10 3b       	cp.w	r11,r8
80007912:	f0 0b 17 30 	movlo	r11,r8
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
80007916:	78 b9       	ld.w	r9,r12[0x2c]
80007918:	16 39       	cp.w	r9,r11
8000791a:	c2 80       	breq	8000796a <vTaskPriorityDisinheritAfterTimeout+0x66>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
8000791c:	79 28       	ld.w	r8,r12[0x48]
8000791e:	58 18       	cp.w	r8,1
80007920:	c2 51       	brne	8000796a <vTaskPriorityDisinheritAfterTimeout+0x66>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
80007922:	99 bb       	st.w	r12[0x2c],r11

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007924:	78 68       	ld.w	r8,r12[0x18]
80007926:	58 08       	cp.w	r8,0
80007928:	c0 45       	brlt	80007930 <vTaskPriorityDisinheritAfterTimeout+0x2c>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000792a:	f6 0b 11 08 	rsub	r11,r11,8
8000792e:	99 6b       	st.w	r12[0x18],r11
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80007930:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007934:	48 f8       	lddpc	r8,80007970 <vTaskPriorityDisinheritAfterTimeout+0x6c>
80007936:	f0 09 00 29 	add	r9,r8,r9<<0x2
8000793a:	6e 58       	ld.w	r8,r7[0x14]
8000793c:	12 38       	cp.w	r8,r9
8000793e:	c1 61       	brne	8000796a <vTaskPriorityDisinheritAfterTimeout+0x66>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007940:	ee c6 ff fc 	sub	r6,r7,-4
80007944:	0c 9c       	mov	r12,r6
80007946:	f0 1f 00 0c 	mcall	80007974 <vTaskPriorityDisinheritAfterTimeout+0x70>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
8000794a:	6e bc       	ld.w	r12,r7[0x2c]
8000794c:	48 b8       	lddpc	r8,80007978 <vTaskPriorityDisinheritAfterTimeout+0x74>
8000794e:	70 08       	ld.w	r8,r8[0x0]
80007950:	10 3c       	cp.w	r12,r8
80007952:	e0 88 00 04 	brls	8000795a <vTaskPriorityDisinheritAfterTimeout+0x56>
80007956:	48 98       	lddpc	r8,80007978 <vTaskPriorityDisinheritAfterTimeout+0x74>
80007958:	91 0c       	st.w	r8[0x0],r12
8000795a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000795e:	0c 9b       	mov	r11,r6
80007960:	48 48       	lddpc	r8,80007970 <vTaskPriorityDisinheritAfterTimeout+0x6c>
80007962:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007966:	f0 1f 00 06 	mcall	8000797c <vTaskPriorityDisinheritAfterTimeout+0x78>
8000796a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000796e:	00 00       	add	r0,r0
80007970:	00 00       	add	r0,r0
80007972:	75 0c       	ld.w	r12,r10[0x40]
80007974:	80 00       	ld.sh	r0,r0[0x0]
80007976:	6e 0e       	ld.w	lr,r7[0x0]
80007978:	00 00       	add	r0,r0
8000797a:	76 2c       	ld.w	r12,r11[0x8]
8000797c:	80 00       	ld.sh	r0,r0[0x0]
8000797e:	6d c6       	ld.w	r6,r6[0x70]

80007980 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
80007980:	eb cd 40 c0 	pushm	r6-r7,lr
80007984:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
80007986:	58 0c       	cp.w	r12,0
80007988:	c2 60       	breq	800079d4 <xTaskPriorityDisinherit+0x54>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
8000798a:	79 28       	ld.w	r8,r12[0x48]
8000798c:	20 18       	sub	r8,1
8000798e:	f9 48 00 48 	st.w	r12[72],r8

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80007992:	78 ba       	ld.w	r10,r12[0x2c]
80007994:	79 19       	ld.w	r9,r12[0x44]
80007996:	12 3a       	cp.w	r10,r9
80007998:	c1 e0       	breq	800079d4 <xTaskPriorityDisinherit+0x54>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
8000799a:	58 08       	cp.w	r8,0
8000799c:	c1 c1       	brne	800079d4 <xTaskPriorityDisinherit+0x54>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8000799e:	f8 c6 ff fc 	sub	r6,r12,-4
800079a2:	0c 9c       	mov	r12,r6
800079a4:	f0 1f 00 0d 	mcall	800079d8 <xTaskPriorityDisinherit+0x58>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
800079a8:	6f 1c       	ld.w	r12,r7[0x44]
800079aa:	8f bc       	st.w	r7[0x2c],r12

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800079ac:	f8 08 11 08 	rsub	r8,r12,8
800079b0:	8f 68       	st.w	r7[0x18],r8
                    prvAddTaskToReadyList( pxTCB );
800079b2:	48 b8       	lddpc	r8,800079dc <xTaskPriorityDisinherit+0x5c>
800079b4:	70 08       	ld.w	r8,r8[0x0]
800079b6:	10 3c       	cp.w	r12,r8
800079b8:	e0 88 00 04 	brls	800079c0 <xTaskPriorityDisinherit+0x40>
800079bc:	48 88       	lddpc	r8,800079dc <xTaskPriorityDisinherit+0x5c>
800079be:	91 0c       	st.w	r8[0x0],r12
800079c0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800079c4:	0c 9b       	mov	r11,r6
800079c6:	48 78       	lddpc	r8,800079e0 <xTaskPriorityDisinherit+0x60>
800079c8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800079cc:	f0 1f 00 06 	mcall	800079e4 <xTaskPriorityDisinherit+0x64>
800079d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800079d4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800079d8:	80 00       	ld.sh	r0,r0[0x0]
800079da:	6e 0e       	ld.w	lr,r7[0x0]
800079dc:	00 00       	add	r0,r0
800079de:	76 2c       	ld.w	r12,r11[0x8]
800079e0:	00 00       	add	r0,r0
800079e2:	75 0c       	ld.w	r12,r10[0x40]
800079e4:	80 00       	ld.sh	r0,r0[0x0]
800079e6:	6d c6       	ld.w	r6,r6[0x70]

800079e8 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
800079e8:	eb cd 40 c0 	pushm	r6-r7,lr
800079ec:	18 97       	mov	r7,r12
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
800079ee:	58 0c       	cp.w	r12,0
800079f0:	c0 31       	brne	800079f6 <xTaskPriorityInherit+0xe>
800079f2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
800079f6:	4a 18       	lddpc	r8,80007a78 <xTaskPriorityInherit+0x90>
800079f8:	70 08       	ld.w	r8,r8[0x0]
800079fa:	78 b9       	ld.w	r9,r12[0x2c]
800079fc:	70 b8       	ld.w	r8,r8[0x2c]
800079fe:	10 39       	cp.w	r9,r8
80007a00:	c3 32       	brcc	80007a66 <xTaskPriorityInherit+0x7e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80007a02:	78 68       	ld.w	r8,r12[0x18]
80007a04:	58 08       	cp.w	r8,0
80007a06:	c0 75       	brlt	80007a14 <xTaskPriorityInherit+0x2c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007a08:	49 c8       	lddpc	r8,80007a78 <xTaskPriorityInherit+0x90>
80007a0a:	70 08       	ld.w	r8,r8[0x0]
80007a0c:	70 b8       	ld.w	r8,r8[0x2c]
80007a0e:	f0 08 11 08 	rsub	r8,r8,8
80007a12:	99 68       	st.w	r12[0x18],r8
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
80007a14:	6e b8       	ld.w	r8,r7[0x2c]
80007a16:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007a1a:	49 99       	lddpc	r9,80007a7c <xTaskPriorityInherit+0x94>
80007a1c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007a20:	6e 59       	ld.w	r9,r7[0x14]
80007a22:	10 39       	cp.w	r9,r8
80007a24:	c1 b1       	brne	80007a5a <xTaskPriorityInherit+0x72>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007a26:	ee c6 ff fc 	sub	r6,r7,-4
80007a2a:	0c 9c       	mov	r12,r6
80007a2c:	f0 1f 00 15 	mcall	80007a80 <xTaskPriorityInherit+0x98>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
80007a30:	49 28       	lddpc	r8,80007a78 <xTaskPriorityInherit+0x90>
80007a32:	70 08       	ld.w	r8,r8[0x0]
80007a34:	70 bc       	ld.w	r12,r8[0x2c]
80007a36:	8f bc       	st.w	r7[0x2c],r12
                    prvAddTaskToReadyList( pxMutexHolderTCB );
80007a38:	49 38       	lddpc	r8,80007a84 <xTaskPriorityInherit+0x9c>
80007a3a:	70 08       	ld.w	r8,r8[0x0]
80007a3c:	10 3c       	cp.w	r12,r8
80007a3e:	e0 88 00 04 	brls	80007a46 <xTaskPriorityInherit+0x5e>
80007a42:	49 18       	lddpc	r8,80007a84 <xTaskPriorityInherit+0x9c>
80007a44:	91 0c       	st.w	r8[0x0],r12
80007a46:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007a4a:	0c 9b       	mov	r11,r6
80007a4c:	48 c8       	lddpc	r8,80007a7c <xTaskPriorityInherit+0x94>
80007a4e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007a52:	f0 1f 00 0e 	mcall	80007a88 <xTaskPriorityInherit+0xa0>
80007a56:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
80007a5a:	48 88       	lddpc	r8,80007a78 <xTaskPriorityInherit+0x90>
80007a5c:	70 08       	ld.w	r8,r8[0x0]
80007a5e:	70 b8       	ld.w	r8,r8[0x2c]
80007a60:	8f b8       	st.w	r7[0x2c],r8
80007a62:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
80007a66:	48 58       	lddpc	r8,80007a78 <xTaskPriorityInherit+0x90>
80007a68:	70 08       	ld.w	r8,r8[0x0]
80007a6a:	79 19       	ld.w	r9,r12[0x44]
80007a6c:	70 b8       	ld.w	r8,r8[0x2c]
80007a6e:	10 39       	cp.w	r9,r8
80007a70:	5f 3c       	srlo	r12
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
80007a72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a76:	00 00       	add	r0,r0
80007a78:	00 00       	add	r0,r0
80007a7a:	75 b0       	ld.w	r0,r10[0x6c]
80007a7c:	00 00       	add	r0,r0
80007a7e:	75 0c       	ld.w	r12,r10[0x40]
80007a80:	80 00       	ld.sh	r0,r0[0x0]
80007a82:	6e 0e       	ld.w	lr,r7[0x0]
80007a84:	00 00       	add	r0,r0
80007a86:	76 2c       	ld.w	r12,r11[0x8]
80007a88:	80 00       	ld.sh	r0,r0[0x0]
80007a8a:	6d c6       	ld.w	r6,r6[0x70]

80007a8c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
80007a8c:	eb cd 40 c0 	pushm	r6-r7,lr
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007a90:	78 38       	ld.w	r8,r12[0xc]
80007a92:	70 37       	ld.w	r7,r8[0xc]
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007a94:	ee c6 ff e8 	sub	r6,r7,-24
80007a98:	0c 9c       	mov	r12,r6
80007a9a:	f0 1f 00 18 	mcall	80007af8 <xTaskRemoveFromEventList+0x6c>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007a9e:	49 88       	lddpc	r8,80007afc <xTaskRemoveFromEventList+0x70>
80007aa0:	70 08       	ld.w	r8,r8[0x0]
80007aa2:	58 08       	cp.w	r8,0
80007aa4:	c1 71       	brne	80007ad2 <xTaskRemoveFromEventList+0x46>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80007aa6:	ee c6 ff fc 	sub	r6,r7,-4
80007aaa:	0c 9c       	mov	r12,r6
80007aac:	f0 1f 00 13 	mcall	80007af8 <xTaskRemoveFromEventList+0x6c>
        prvAddTaskToReadyList( pxUnblockedTCB );
80007ab0:	6e bc       	ld.w	r12,r7[0x2c]
80007ab2:	49 48       	lddpc	r8,80007b00 <xTaskRemoveFromEventList+0x74>
80007ab4:	70 08       	ld.w	r8,r8[0x0]
80007ab6:	10 3c       	cp.w	r12,r8
80007ab8:	e0 88 00 04 	brls	80007ac0 <xTaskRemoveFromEventList+0x34>
80007abc:	49 18       	lddpc	r8,80007b00 <xTaskRemoveFromEventList+0x74>
80007abe:	91 0c       	st.w	r8[0x0],r12
80007ac0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007ac4:	0c 9b       	mov	r11,r6
80007ac6:	49 08       	lddpc	r8,80007b04 <xTaskRemoveFromEventList+0x78>
80007ac8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007acc:	f0 1f 00 0f 	mcall	80007b08 <xTaskRemoveFromEventList+0x7c>
80007ad0:	c0 58       	rjmp	80007ada <xTaskRemoveFromEventList+0x4e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80007ad2:	0c 9b       	mov	r11,r6
80007ad4:	48 ec       	lddpc	r12,80007b0c <xTaskRemoveFromEventList+0x80>
80007ad6:	f0 1f 00 0d 	mcall	80007b08 <xTaskRemoveFromEventList+0x7c>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80007ada:	48 e8       	lddpc	r8,80007b10 <xTaskRemoveFromEventList+0x84>
80007adc:	70 08       	ld.w	r8,r8[0x0]
80007ade:	6e b9       	ld.w	r9,r7[0x2c]
80007ae0:	70 b8       	ld.w	r8,r8[0x2c]
80007ae2:	10 39       	cp.w	r9,r8
80007ae4:	e0 8b 00 04 	brhi	80007aec <xTaskRemoveFromEventList+0x60>
80007ae8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
80007aec:	30 1c       	mov	r12,1
80007aee:	48 a8       	lddpc	r8,80007b14 <xTaskRemoveFromEventList+0x88>
80007af0:	91 0c       	st.w	r8[0x0],r12
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
80007af2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007af6:	00 00       	add	r0,r0
80007af8:	80 00       	ld.sh	r0,r0[0x0]
80007afa:	6e 0e       	ld.w	lr,r7[0x0]
80007afc:	00 00       	add	r0,r0
80007afe:	75 e0       	ld.w	r0,r10[0x78]
80007b00:	00 00       	add	r0,r0
80007b02:	76 2c       	ld.w	r12,r11[0x8]
80007b04:	00 00       	add	r0,r0
80007b06:	75 0c       	ld.w	r12,r10[0x40]
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	6d c6       	ld.w	r6,r6[0x70]
80007b0c:	00 00       	add	r0,r0
80007b0e:	75 b4       	ld.w	r4,r10[0x6c]
80007b10:	00 00       	add	r0,r0
80007b12:	75 b0       	ld.w	r0,r10[0x6c]
80007b14:	00 00       	add	r0,r0
80007b16:	76 30       	ld.w	r0,r11[0xc]

80007b18 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
80007b18:	d4 31       	pushm	r0-r7,lr
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007b1a:	4b 48       	lddpc	r8,80007be8 <xTaskIncrementTick+0xd0>
80007b1c:	70 08       	ld.w	r8,r8[0x0]
80007b1e:	58 08       	cp.w	r8,0
80007b20:	c5 d1       	brne	80007bda <xTaskIncrementTick+0xc2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
80007b22:	4b 38       	lddpc	r8,80007bec <xTaskIncrementTick+0xd4>
80007b24:	70 02       	ld.w	r2,r8[0x0]
80007b26:	2f f2       	sub	r2,-1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
80007b28:	91 02       	st.w	r8[0x0],r2

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
80007b2a:	c0 d1       	brne	80007b44 <xTaskIncrementTick+0x2c>
        {
            taskSWITCH_DELAYED_LISTS();
80007b2c:	4b 19       	lddpc	r9,80007bf0 <xTaskIncrementTick+0xd8>
80007b2e:	72 0a       	ld.w	r10,r9[0x0]
80007b30:	4b 18       	lddpc	r8,80007bf4 <xTaskIncrementTick+0xdc>
80007b32:	70 0b       	ld.w	r11,r8[0x0]
80007b34:	93 0b       	st.w	r9[0x0],r11
80007b36:	91 0a       	st.w	r8[0x0],r10
80007b38:	4b 08       	lddpc	r8,80007bf8 <xTaskIncrementTick+0xe0>
80007b3a:	70 09       	ld.w	r9,r8[0x0]
80007b3c:	2f f9       	sub	r9,-1
80007b3e:	91 09       	st.w	r8[0x0],r9
80007b40:	f0 1f 00 2f 	mcall	80007bfc <xTaskIncrementTick+0xe4>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
80007b44:	4a f8       	lddpc	r8,80007c00 <xTaskIncrementTick+0xe8>
80007b46:	70 08       	ld.w	r8,r8[0x0]
80007b48:	10 32       	cp.w	r2,r8
80007b4a:	c3 63       	brcs	80007bb6 <xTaskIncrementTick+0x9e>
80007b4c:	30 06       	mov	r6,0
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007b4e:	4a 94       	lddpc	r4,80007bf0 <xTaskIncrementTick+0xd8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007b50:	4a d3       	lddpc	r3,80007c04 <xTaskIncrementTick+0xec>
80007b52:	4a e1       	lddpc	r1,80007c08 <xTaskIncrementTick+0xf0>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007b54:	4a e0       	lddpc	r0,80007c0c <xTaskIncrementTick+0xf4>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007b56:	68 08       	ld.w	r8,r4[0x0]
80007b58:	70 08       	ld.w	r8,r8[0x0]
80007b5a:	58 08       	cp.w	r8,0
80007b5c:	c0 51       	brne	80007b66 <xTaskIncrementTick+0x4e>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80007b5e:	3f f9       	mov	r9,-1
80007b60:	4a 88       	lddpc	r8,80007c00 <xTaskIncrementTick+0xe8>
80007b62:	91 09       	st.w	r8[0x0],r9
                    break;
80007b64:	c2 a8       	rjmp	80007bb8 <xTaskIncrementTick+0xa0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007b66:	68 08       	ld.w	r8,r4[0x0]
80007b68:	70 38       	ld.w	r8,r8[0xc]
80007b6a:	70 37       	ld.w	r7,r8[0xc]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80007b6c:	6e 18       	ld.w	r8,r7[0x4]

                    if( xConstTickCount < xItemValue )
80007b6e:	10 32       	cp.w	r2,r8
80007b70:	c0 42       	brcc	80007b78 <xTaskIncrementTick+0x60>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
80007b72:	4a 49       	lddpc	r9,80007c00 <xTaskIncrementTick+0xe8>
80007b74:	93 08       	st.w	r9[0x0],r8
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
80007b76:	c2 18       	rjmp	80007bb8 <xTaskIncrementTick+0xa0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007b78:	ee c5 ff fc 	sub	r5,r7,-4
80007b7c:	0a 9c       	mov	r12,r5
80007b7e:	f0 1f 00 25 	mcall	80007c10 <xTaskIncrementTick+0xf8>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80007b82:	6e a8       	ld.w	r8,r7[0x28]
80007b84:	58 08       	cp.w	r8,0
80007b86:	c0 50       	breq	80007b90 <xTaskIncrementTick+0x78>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007b88:	ee cc ff e8 	sub	r12,r7,-24
80007b8c:	f0 1f 00 21 	mcall	80007c10 <xTaskIncrementTick+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80007b90:	6e bc       	ld.w	r12,r7[0x2c]
80007b92:	66 08       	ld.w	r8,r3[0x0]
80007b94:	10 3c       	cp.w	r12,r8
80007b96:	e7 fc ba 00 	st.whi	r3[0x0],r12
80007b9a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007b9e:	0a 9b       	mov	r11,r5
80007ba0:	e2 0c 00 2c 	add	r12,r1,r12<<0x2
80007ba4:	f0 1f 00 1c 	mcall	80007c14 <xTaskIncrementTick+0xfc>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007ba8:	60 08       	ld.w	r8,r0[0x0]
80007baa:	6e b9       	ld.w	r9,r7[0x2c]
80007bac:	70 b8       	ld.w	r8,r8[0x2c]
80007bae:	10 39       	cp.w	r9,r8
80007bb0:	f9 b6 02 01 	movhs	r6,1
80007bb4:	cd 1b       	rjmp	80007b56 <xTaskIncrementTick+0x3e>
80007bb6:	30 06       	mov	r6,0
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
80007bb8:	49 58       	lddpc	r8,80007c0c <xTaskIncrementTick+0xf4>
80007bba:	70 08       	ld.w	r8,r8[0x0]
80007bbc:	70 b8       	ld.w	r8,r8[0x2c]
80007bbe:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007bc2:	49 29       	lddpc	r9,80007c08 <xTaskIncrementTick+0xf0>
80007bc4:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80007bc8:	58 28       	cp.w	r8,2
80007bca:	f9 b6 02 01 	movhs	r6,1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
80007bce:	49 38       	lddpc	r8,80007c18 <xTaskIncrementTick+0x100>
80007bd0:	70 08       	ld.w	r8,r8[0x0]
80007bd2:	58 08       	cp.w	r8,0
80007bd4:	f9 b6 01 01 	movne	r6,1
80007bd8:	c0 68       	rjmp	80007be4 <xTaskIncrementTick+0xcc>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
80007bda:	49 18       	lddpc	r8,80007c1c <xTaskIncrementTick+0x104>
80007bdc:	70 09       	ld.w	r9,r8[0x0]
80007bde:	2f f9       	sub	r9,-1
80007be0:	91 09       	st.w	r8[0x0],r9
80007be2:	30 06       	mov	r6,0
            }
        #endif
    }

    return xSwitchRequired;
}
80007be4:	0c 9c       	mov	r12,r6
80007be6:	d8 32       	popm	r0-r7,pc
80007be8:	00 00       	add	r0,r0
80007bea:	75 e0       	ld.w	r0,r10[0x78]
80007bec:	00 00       	add	r0,r0
80007bee:	75 dc       	ld.w	r12,r10[0x74]
80007bf0:	00 00       	add	r0,r0
80007bf2:	74 f8       	ld.w	r8,r10[0x3c]
80007bf4:	00 00       	add	r0,r0
80007bf6:	75 04       	ld.w	r4,r10[0x40]
80007bf8:	00 00       	add	r0,r0
80007bfa:	75 00       	ld.w	r0,r10[0x40]
80007bfc:	80 00       	ld.sh	r0,r0[0x0]
80007bfe:	77 64       	ld.w	r4,r11[0x58]
80007c00:	00 00       	add	r0,r0
80007c02:	74 f4       	ld.w	r4,r10[0x3c]
80007c04:	00 00       	add	r0,r0
80007c06:	76 2c       	ld.w	r12,r11[0x8]
80007c08:	00 00       	add	r0,r0
80007c0a:	75 0c       	ld.w	r12,r10[0x40]
80007c0c:	00 00       	add	r0,r0
80007c0e:	75 b0       	ld.w	r0,r10[0x6c]
80007c10:	80 00       	ld.sh	r0,r0[0x0]
80007c12:	6e 0e       	ld.w	lr,r7[0x0]
80007c14:	80 00       	ld.sh	r0,r0[0x0]
80007c16:	6d c6       	ld.w	r6,r6[0x70]
80007c18:	00 00       	add	r0,r0
80007c1a:	76 30       	ld.w	r0,r11[0xc]
80007c1c:	00 00       	add	r0,r0
80007c1e:	75 08       	ld.w	r8,r10[0x40]

80007c20 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
80007c20:	d4 31       	pushm	r0-r7,lr
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
80007c22:	f0 1f 00 2b 	mcall	80007ccc <xTaskResumeAll+0xac>
    {
        --uxSchedulerSuspended;
80007c26:	4a b8       	lddpc	r8,80007cd0 <xTaskResumeAll+0xb0>
80007c28:	70 09       	ld.w	r9,r8[0x0]
80007c2a:	20 19       	sub	r9,1
80007c2c:	91 09       	st.w	r8[0x0],r9

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007c2e:	70 08       	ld.w	r8,r8[0x0]
80007c30:	58 08       	cp.w	r8,0
80007c32:	c4 71       	brne	80007cc0 <xTaskResumeAll+0xa0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80007c34:	4a 88       	lddpc	r8,80007cd4 <xTaskResumeAll+0xb4>
80007c36:	70 08       	ld.w	r8,r8[0x0]
80007c38:	58 08       	cp.w	r8,0
80007c3a:	c4 30       	breq	80007cc0 <xTaskResumeAll+0xa0>
80007c3c:	30 07       	mov	r7,0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80007c3e:	4a 76       	lddpc	r6,80007cd8 <xTaskResumeAll+0xb8>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
80007c40:	4a 74       	lddpc	r4,80007cdc <xTaskResumeAll+0xbc>
80007c42:	4a 83       	lddpc	r3,80007ce0 <xTaskResumeAll+0xc0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007c44:	4a 82       	lddpc	r2,80007ce4 <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
80007c46:	4a 91       	lddpc	r1,80007ce8 <xTaskResumeAll+0xc8>
80007c48:	30 10       	mov	r0,1
80007c4a:	c1 e8       	rjmp	80007c86 <xTaskResumeAll+0x66>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80007c4c:	6c 38       	ld.w	r8,r6[0xc]
80007c4e:	70 37       	ld.w	r7,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007c50:	ee cc ff e8 	sub	r12,r7,-24
80007c54:	f0 1f 00 26 	mcall	80007cec <xTaskResumeAll+0xcc>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007c58:	ee c5 ff fc 	sub	r5,r7,-4
80007c5c:	0a 9c       	mov	r12,r5
80007c5e:	f0 1f 00 24 	mcall	80007cec <xTaskResumeAll+0xcc>
                    prvAddTaskToReadyList( pxTCB );
80007c62:	6e bc       	ld.w	r12,r7[0x2c]
80007c64:	68 08       	ld.w	r8,r4[0x0]
80007c66:	10 3c       	cp.w	r12,r8
80007c68:	e9 fc ba 00 	st.whi	r4[0x0],r12
80007c6c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007c70:	0a 9b       	mov	r11,r5
80007c72:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80007c76:	f0 1f 00 1f 	mcall	80007cf0 <xTaskResumeAll+0xd0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007c7a:	64 08       	ld.w	r8,r2[0x0]
80007c7c:	6e b9       	ld.w	r9,r7[0x2c]
80007c7e:	70 b8       	ld.w	r8,r8[0x2c]
                    {
                        xYieldPending = pdTRUE;
80007c80:	10 39       	cp.w	r9,r8
80007c82:	e3 f0 2a 00 	st.wcc	r1[0x0],r0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80007c86:	6c 08       	ld.w	r8,r6[0x0]
80007c88:	58 08       	cp.w	r8,0
80007c8a:	ce 11       	brne	80007c4c <xTaskResumeAll+0x2c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
80007c8c:	58 07       	cp.w	r7,0
80007c8e:	c0 30       	breq	80007c94 <xTaskResumeAll+0x74>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
80007c90:	f0 1f 00 19 	mcall	80007cf4 <xTaskResumeAll+0xd4>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
80007c94:	49 98       	lddpc	r8,80007cf8 <xTaskResumeAll+0xd8>
80007c96:	70 07       	ld.w	r7,r8[0x0]

                    if( xPendedCounts > ( TickType_t ) 0U )
80007c98:	58 07       	cp.w	r7,0
80007c9a:	c0 c0       	breq	80007cb2 <xTaskResumeAll+0x92>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
80007c9c:	49 36       	lddpc	r6,80007ce8 <xTaskResumeAll+0xc8>
80007c9e:	30 15       	mov	r5,1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
80007ca0:	f0 1f 00 17 	mcall	80007cfc <xTaskResumeAll+0xdc>
                            {
                                xYieldPending = pdTRUE;
80007ca4:	ed f5 1a 00 	st.wne	r6[0x0],r5
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
80007ca8:	20 17       	sub	r7,1
                        } while( xPendedCounts > ( TickType_t ) 0U );
80007caa:	cf b1       	brne	80007ca0 <xTaskResumeAll+0x80>

                        xPendedTicks = 0;
80007cac:	30 09       	mov	r9,0
80007cae:	49 38       	lddpc	r8,80007cf8 <xTaskResumeAll+0xd8>
80007cb0:	91 09       	st.w	r8[0x0],r9
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
80007cb2:	48 e8       	lddpc	r8,80007ce8 <xTaskResumeAll+0xc8>
80007cb4:	70 08       	ld.w	r8,r8[0x0]
80007cb6:	58 08       	cp.w	r8,0
80007cb8:	c0 40       	breq	80007cc0 <xTaskResumeAll+0xa0>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
80007cba:	d7 33       	scall
80007cbc:	30 17       	mov	r7,1
80007cbe:	c0 28       	rjmp	80007cc2 <xTaskResumeAll+0xa2>
80007cc0:	30 07       	mov	r7,0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
80007cc2:	f0 1f 00 10 	mcall	80007d00 <xTaskResumeAll+0xe0>

    return xAlreadyYielded;
}
80007cc6:	0e 9c       	mov	r12,r7
80007cc8:	d8 32       	popm	r0-r7,pc
80007cca:	00 00       	add	r0,r0
80007ccc:	80 00       	ld.sh	r0,r0[0x0]
80007cce:	6e c8       	ld.w	r8,r7[0x30]
80007cd0:	00 00       	add	r0,r0
80007cd2:	75 e0       	ld.w	r0,r10[0x78]
80007cd4:	00 00       	add	r0,r0
80007cd6:	75 fc       	ld.w	r12,r10[0x7c]
80007cd8:	00 00       	add	r0,r0
80007cda:	75 b4       	ld.w	r4,r10[0x6c]
80007cdc:	00 00       	add	r0,r0
80007cde:	76 2c       	ld.w	r12,r11[0x8]
80007ce0:	00 00       	add	r0,r0
80007ce2:	75 0c       	ld.w	r12,r10[0x40]
80007ce4:	00 00       	add	r0,r0
80007ce6:	75 b0       	ld.w	r0,r10[0x6c]
80007ce8:	00 00       	add	r0,r0
80007cea:	76 30       	ld.w	r0,r11[0xc]
80007cec:	80 00       	ld.sh	r0,r0[0x0]
80007cee:	6e 0e       	ld.w	lr,r7[0x0]
80007cf0:	80 00       	ld.sh	r0,r0[0x0]
80007cf2:	6d c6       	ld.w	r6,r6[0x70]
80007cf4:	80 00       	ld.sh	r0,r0[0x0]
80007cf6:	77 64       	ld.w	r4,r11[0x58]
80007cf8:	00 00       	add	r0,r0
80007cfa:	75 08       	ld.w	r8,r10[0x40]
80007cfc:	80 00       	ld.sh	r0,r0[0x0]
80007cfe:	7b 18       	ld.w	r8,sp[0x44]
80007d00:	80 00       	ld.sh	r0,r0[0x0]
80007d02:	6f d4       	ld.w	r4,r7[0x74]

80007d04 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
80007d04:	d4 21       	pushm	r4-r7,lr
80007d06:	18 97       	mov	r7,r12
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80007d08:	f0 1f 00 17 	mcall	80007d64 <xTaskResumeFromISR+0x60>
80007d0c:	c0 31       	brne	80007d12 <xTaskResumeFromISR+0xe>
80007d0e:	30 07       	mov	r7,0
80007d10:	c2 78       	rjmp	80007d5e <xTaskResumeFromISR+0x5a>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80007d12:	49 68       	lddpc	r8,80007d68 <xTaskResumeFromISR+0x64>
80007d14:	70 08       	ld.w	r8,r8[0x0]
80007d16:	58 08       	cp.w	r8,0
80007d18:	c1 d1       	brne	80007d52 <xTaskResumeFromISR+0x4e>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007d1a:	6e b5       	ld.w	r5,r7[0x2c]
80007d1c:	49 48       	lddpc	r8,80007d6c <xTaskResumeFromISR+0x68>
80007d1e:	70 08       	ld.w	r8,r8[0x0]
80007d20:	70 b4       	ld.w	r4,r8[0x2c]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007d22:	ee c6 ff fc 	sub	r6,r7,-4
80007d26:	0c 9c       	mov	r12,r6
80007d28:	f0 1f 00 12 	mcall	80007d70 <xTaskResumeFromISR+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80007d2c:	6e bc       	ld.w	r12,r7[0x2c]
80007d2e:	49 28       	lddpc	r8,80007d74 <xTaskResumeFromISR+0x70>
80007d30:	70 08       	ld.w	r8,r8[0x0]
80007d32:	10 3c       	cp.w	r12,r8
80007d34:	e0 88 00 04 	brls	80007d3c <xTaskResumeFromISR+0x38>
80007d38:	48 f8       	lddpc	r8,80007d74 <xTaskResumeFromISR+0x70>
80007d3a:	91 0c       	st.w	r8[0x0],r12
80007d3c:	08 35       	cp.w	r5,r4
80007d3e:	5f 27       	srhs	r7
80007d40:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007d44:	0c 9b       	mov	r11,r6
80007d46:	48 d8       	lddpc	r8,80007d78 <xTaskResumeFromISR+0x74>
80007d48:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007d4c:	f0 1f 00 0c 	mcall	80007d7c <xTaskResumeFromISR+0x78>
80007d50:	c0 78       	rjmp	80007d5e <xTaskResumeFromISR+0x5a>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80007d52:	ee cb ff e8 	sub	r11,r7,-24
80007d56:	48 bc       	lddpc	r12,80007d80 <xTaskResumeFromISR+0x7c>
80007d58:	f0 1f 00 09 	mcall	80007d7c <xTaskResumeFromISR+0x78>
80007d5c:	30 07       	mov	r7,0
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
80007d5e:	0e 9c       	mov	r12,r7
80007d60:	d8 22       	popm	r4-r7,pc
80007d62:	00 00       	add	r0,r0
80007d64:	80 00       	ld.sh	r0,r0[0x0]
80007d66:	76 9c       	ld.w	r12,r11[0x24]
80007d68:	00 00       	add	r0,r0
80007d6a:	75 e0       	ld.w	r0,r10[0x78]
80007d6c:	00 00       	add	r0,r0
80007d6e:	75 b0       	ld.w	r0,r10[0x6c]
80007d70:	80 00       	ld.sh	r0,r0[0x0]
80007d72:	6e 0e       	ld.w	lr,r7[0x0]
80007d74:	00 00       	add	r0,r0
80007d76:	76 2c       	ld.w	r12,r11[0x8]
80007d78:	00 00       	add	r0,r0
80007d7a:	75 0c       	ld.w	r12,r10[0x40]
80007d7c:	80 00       	ld.sh	r0,r0[0x0]
80007d7e:	6d c6       	ld.w	r6,r6[0x70]
80007d80:	00 00       	add	r0,r0
80007d82:	75 b4       	ld.w	r4,r10[0x6c]

80007d84 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
80007d84:	eb cd 40 c0 	pushm	r6-r7,lr
80007d88:	18 97       	mov	r7,r12
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
80007d8a:	49 78       	lddpc	r8,80007de4 <vTaskResume+0x60>
80007d8c:	70 08       	ld.w	r8,r8[0x0]
80007d8e:	10 3c       	cp.w	r12,r8
80007d90:	c2 70       	breq	80007dde <vTaskResume+0x5a>
80007d92:	58 0c       	cp.w	r12,0
80007d94:	c2 50       	breq	80007dde <vTaskResume+0x5a>
        {
            taskENTER_CRITICAL();
80007d96:	f0 1f 00 15 	mcall	80007de8 <vTaskResume+0x64>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80007d9a:	0e 9c       	mov	r12,r7
80007d9c:	f0 1f 00 14 	mcall	80007dec <vTaskResume+0x68>
80007da0:	c1 d0       	breq	80007dda <vTaskResume+0x56>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80007da2:	ee c6 ff fc 	sub	r6,r7,-4
80007da6:	0c 9c       	mov	r12,r6
80007da8:	f0 1f 00 12 	mcall	80007df0 <vTaskResume+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80007dac:	6e bc       	ld.w	r12,r7[0x2c]
80007dae:	49 28       	lddpc	r8,80007df4 <vTaskResume+0x70>
80007db0:	70 08       	ld.w	r8,r8[0x0]
80007db2:	10 3c       	cp.w	r12,r8
80007db4:	e0 88 00 04 	brls	80007dbc <vTaskResume+0x38>
80007db8:	48 f8       	lddpc	r8,80007df4 <vTaskResume+0x70>
80007dba:	91 0c       	st.w	r8[0x0],r12
80007dbc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007dc0:	0c 9b       	mov	r11,r6
80007dc2:	48 e8       	lddpc	r8,80007df8 <vTaskResume+0x74>
80007dc4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007dc8:	f0 1f 00 0d 	mcall	80007dfc <vTaskResume+0x78>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007dcc:	48 68       	lddpc	r8,80007de4 <vTaskResume+0x60>
80007dce:	70 08       	ld.w	r8,r8[0x0]
80007dd0:	6e b9       	ld.w	r9,r7[0x2c]
80007dd2:	70 b8       	ld.w	r8,r8[0x2c]
80007dd4:	10 39       	cp.w	r9,r8
80007dd6:	c0 23       	brcs	80007dda <vTaskResume+0x56>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
80007dd8:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
80007dda:	f0 1f 00 0a 	mcall	80007e00 <vTaskResume+0x7c>
80007dde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007de2:	00 00       	add	r0,r0
80007de4:	00 00       	add	r0,r0
80007de6:	75 b0       	ld.w	r0,r10[0x6c]
80007de8:	80 00       	ld.sh	r0,r0[0x0]
80007dea:	6e c8       	ld.w	r8,r7[0x30]
80007dec:	80 00       	ld.sh	r0,r0[0x0]
80007dee:	76 9c       	ld.w	r12,r11[0x24]
80007df0:	80 00       	ld.sh	r0,r0[0x0]
80007df2:	6e 0e       	ld.w	lr,r7[0x0]
80007df4:	00 00       	add	r0,r0
80007df6:	76 2c       	ld.w	r12,r11[0x8]
80007df8:	00 00       	add	r0,r0
80007dfa:	75 0c       	ld.w	r12,r10[0x40]
80007dfc:	80 00       	ld.sh	r0,r0[0x0]
80007dfe:	6d c6       	ld.w	r6,r6[0x70]
80007e00:	80 00       	ld.sh	r0,r0[0x0]
80007e02:	6f d4       	ld.w	r4,r7[0x74]

80007e04 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
80007e04:	eb cd 40 c0 	pushm	r6-r7,lr
80007e08:	18 97       	mov	r7,r12
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
80007e0a:	f0 1f 00 23 	mcall	80007e94 <vTaskSuspend+0x90>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
80007e0e:	58 07       	cp.w	r7,0
80007e10:	c0 31       	brne	80007e16 <vTaskSuspend+0x12>
80007e12:	4a 28       	lddpc	r8,80007e98 <vTaskSuspend+0x94>
80007e14:	70 07       	ld.w	r7,r8[0x0]

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007e16:	ee c6 ff fc 	sub	r6,r7,-4
80007e1a:	0c 9c       	mov	r12,r6
80007e1c:	f0 1f 00 20 	mcall	80007e9c <vTaskSuspend+0x98>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80007e20:	6e a8       	ld.w	r8,r7[0x28]
80007e22:	58 08       	cp.w	r8,0
80007e24:	c0 50       	breq	80007e2e <vTaskSuspend+0x2a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80007e26:	ee cc ff e8 	sub	r12,r7,-24
80007e2a:	f0 1f 00 1d 	mcall	80007e9c <vTaskSuspend+0x98>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
80007e2e:	0c 9b       	mov	r11,r6
80007e30:	49 cc       	lddpc	r12,80007ea0 <vTaskSuspend+0x9c>
80007e32:	f0 1f 00 1d 	mcall	80007ea4 <vTaskSuspend+0xa0>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
80007e36:	ef 39 00 50 	ld.ub	r9,r7[80]
80007e3a:	30 18       	mov	r8,1
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
80007e3c:	f0 09 18 00 	cp.b	r9,r8
80007e40:	f9 b8 00 00 	moveq	r8,0
80007e44:	ef f8 0e 50 	st.beq	r7[0x50],r8
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
80007e48:	f0 1f 00 18 	mcall	80007ea8 <vTaskSuspend+0xa4>

        if( xSchedulerRunning != pdFALSE )
80007e4c:	49 88       	lddpc	r8,80007eac <vTaskSuspend+0xa8>
80007e4e:	70 08       	ld.w	r8,r8[0x0]
80007e50:	58 08       	cp.w	r8,0
80007e52:	c0 70       	breq	80007e60 <vTaskSuspend+0x5c>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
80007e54:	f0 1f 00 10 	mcall	80007e94 <vTaskSuspend+0x90>
            {
                prvResetNextTaskUnblockTime();
80007e58:	f0 1f 00 16 	mcall	80007eb0 <vTaskSuspend+0xac>
            }
            taskEXIT_CRITICAL();
80007e5c:	f0 1f 00 13 	mcall	80007ea8 <vTaskSuspend+0xa4>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
80007e60:	48 e8       	lddpc	r8,80007e98 <vTaskSuspend+0x94>
80007e62:	70 08       	ld.w	r8,r8[0x0]
80007e64:	10 37       	cp.w	r7,r8
80007e66:	c1 51       	brne	80007e90 <vTaskSuspend+0x8c>
        {
            if( xSchedulerRunning != pdFALSE )
80007e68:	49 18       	lddpc	r8,80007eac <vTaskSuspend+0xa8>
80007e6a:	70 08       	ld.w	r8,r8[0x0]
80007e6c:	58 08       	cp.w	r8,0
80007e6e:	c0 40       	breq	80007e76 <vTaskSuspend+0x72>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
80007e70:	d7 33       	scall
80007e72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
80007e76:	48 b8       	lddpc	r8,80007ea0 <vTaskSuspend+0x9c>
80007e78:	70 09       	ld.w	r9,r8[0x0]
80007e7a:	48 f8       	lddpc	r8,80007eb4 <vTaskSuspend+0xb0>
80007e7c:	70 08       	ld.w	r8,r8[0x0]
80007e7e:	10 39       	cp.w	r9,r8
80007e80:	c0 61       	brne	80007e8c <vTaskSuspend+0x88>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
80007e82:	30 09       	mov	r9,0
80007e84:	48 58       	lddpc	r8,80007e98 <vTaskSuspend+0x94>
80007e86:	91 09       	st.w	r8[0x0],r9
80007e88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                }
                else
                {
                    vTaskSwitchContext();
80007e8c:	f0 1f 00 0b 	mcall	80007eb8 <vTaskSuspend+0xb4>
80007e90:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007e94:	80 00       	ld.sh	r0,r0[0x0]
80007e96:	6e c8       	ld.w	r8,r7[0x30]
80007e98:	00 00       	add	r0,r0
80007e9a:	75 b0       	ld.w	r0,r10[0x6c]
80007e9c:	80 00       	ld.sh	r0,r0[0x0]
80007e9e:	6e 0e       	ld.w	lr,r7[0x0]
80007ea0:	00 00       	add	r0,r0
80007ea2:	76 18       	ld.w	r8,r11[0x4]
80007ea4:	80 00       	ld.sh	r0,r0[0x0]
80007ea6:	6d c6       	ld.w	r6,r6[0x70]
80007ea8:	80 00       	ld.sh	r0,r0[0x0]
80007eaa:	6f d4       	ld.w	r4,r7[0x74]
80007eac:	00 00       	add	r0,r0
80007eae:	74 fc       	ld.w	r12,r10[0x3c]
80007eb0:	80 00       	ld.sh	r0,r0[0x0]
80007eb2:	77 64       	ld.w	r4,r11[0x58]
80007eb4:	00 00       	add	r0,r0
80007eb6:	75 fc       	ld.w	r12,r10[0x7c]
80007eb8:	80 00       	ld.sh	r0,r0[0x0]
80007eba:	76 cc       	ld.w	r12,r11[0x30]

80007ebc <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
80007ebc:	eb cd 40 e0 	pushm	r5-r7,lr
80007ec0:	18 97       	mov	r7,r12
80007ec2:	16 95       	mov	r5,r11
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
80007ec4:	49 b8       	lddpc	r8,80007f30 <prvAddCurrentTaskToDelayedList+0x74>
80007ec6:	70 06       	ld.w	r6,r8[0x0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80007ec8:	49 b8       	lddpc	r8,80007f34 <prvAddCurrentTaskToDelayedList+0x78>
80007eca:	70 0c       	ld.w	r12,r8[0x0]
80007ecc:	2f cc       	sub	r12,-4
80007ece:	f0 1f 00 1b 	mcall	80007f38 <prvAddCurrentTaskToDelayedList+0x7c>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80007ed2:	5b f7       	cp.w	r7,-1
80007ed4:	5f 09       	sreq	r9
80007ed6:	58 05       	cp.w	r5,0
80007ed8:	5f 18       	srne	r8
80007eda:	f3 e8 00 08 	and	r8,r9,r8
80007ede:	c0 90       	breq	80007ef0 <prvAddCurrentTaskToDelayedList+0x34>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007ee0:	49 58       	lddpc	r8,80007f34 <prvAddCurrentTaskToDelayedList+0x78>
80007ee2:	70 0b       	ld.w	r11,r8[0x0]
80007ee4:	2f cb       	sub	r11,-4
80007ee6:	49 6c       	lddpc	r12,80007f3c <prvAddCurrentTaskToDelayedList+0x80>
80007ee8:	f0 1f 00 16 	mcall	80007f40 <prvAddCurrentTaskToDelayedList+0x84>
80007eec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
80007ef0:	0c 07       	add	r7,r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80007ef2:	49 18       	lddpc	r8,80007f34 <prvAddCurrentTaskToDelayedList+0x78>
80007ef4:	70 08       	ld.w	r8,r8[0x0]
80007ef6:	91 17       	st.w	r8[0x4],r7

                if( xTimeToWake < xConstTickCount )
80007ef8:	0e 36       	cp.w	r6,r7
80007efa:	e0 88 00 0b 	brls	80007f10 <prvAddCurrentTaskToDelayedList+0x54>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007efe:	48 e8       	lddpc	r8,80007f34 <prvAddCurrentTaskToDelayedList+0x78>
80007f00:	70 0b       	ld.w	r11,r8[0x0]
80007f02:	49 18       	lddpc	r8,80007f44 <prvAddCurrentTaskToDelayedList+0x88>
80007f04:	70 0c       	ld.w	r12,r8[0x0]
80007f06:	2f cb       	sub	r11,-4
80007f08:	f0 1f 00 10 	mcall	80007f48 <prvAddCurrentTaskToDelayedList+0x8c>
80007f0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80007f10:	48 98       	lddpc	r8,80007f34 <prvAddCurrentTaskToDelayedList+0x78>
80007f12:	70 0b       	ld.w	r11,r8[0x0]
80007f14:	48 e8       	lddpc	r8,80007f4c <prvAddCurrentTaskToDelayedList+0x90>
80007f16:	70 0c       	ld.w	r12,r8[0x0]
80007f18:	2f cb       	sub	r11,-4
80007f1a:	f0 1f 00 0c 	mcall	80007f48 <prvAddCurrentTaskToDelayedList+0x8c>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
80007f1e:	48 d8       	lddpc	r8,80007f50 <prvAddCurrentTaskToDelayedList+0x94>
80007f20:	70 08       	ld.w	r8,r8[0x0]
80007f22:	10 37       	cp.w	r7,r8
80007f24:	c0 32       	brcc	80007f2a <prvAddCurrentTaskToDelayedList+0x6e>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
80007f26:	48 b8       	lddpc	r8,80007f50 <prvAddCurrentTaskToDelayedList+0x94>
80007f28:	91 07       	st.w	r8[0x0],r7
80007f2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007f2e:	00 00       	add	r0,r0
80007f30:	00 00       	add	r0,r0
80007f32:	75 dc       	ld.w	r12,r10[0x74]
80007f34:	00 00       	add	r0,r0
80007f36:	75 b0       	ld.w	r0,r10[0x6c]
80007f38:	80 00       	ld.sh	r0,r0[0x0]
80007f3a:	6e 0e       	ld.w	lr,r7[0x0]
80007f3c:	00 00       	add	r0,r0
80007f3e:	76 18       	ld.w	r8,r11[0x4]
80007f40:	80 00       	ld.sh	r0,r0[0x0]
80007f42:	6d c6       	ld.w	r6,r6[0x70]
80007f44:	00 00       	add	r0,r0
80007f46:	75 04       	ld.w	r4,r10[0x40]
80007f48:	80 00       	ld.sh	r0,r0[0x0]
80007f4a:	6d de       	ld.w	lr,r6[0x74]
80007f4c:	00 00       	add	r0,r0
80007f4e:	74 f8       	ld.w	r8,r10[0x3c]
80007f50:	00 00       	add	r0,r0
80007f52:	74 f4       	ld.w	r4,r10[0x3c]

80007f54 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
80007f54:	eb cd 40 e0 	pushm	r5-r7,lr
80007f58:	18 97       	mov	r7,r12
80007f5a:	16 95       	mov	r5,r11
80007f5c:	14 96       	mov	r6,r10
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
80007f5e:	f0 1f 00 20 	mcall	80007fdc <ulTaskGenericNotifyTake+0x88>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
80007f62:	4a 08       	lddpc	r8,80007fe0 <ulTaskGenericNotifyTake+0x8c>
80007f64:	70 08       	ld.w	r8,r8[0x0]
80007f66:	ee c9 ff ed 	sub	r9,r7,-19
80007f6a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007f6e:	58 08       	cp.w	r8,0
80007f70:	c0 e1       	brne	80007f8c <ulTaskGenericNotifyTake+0x38>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
80007f72:	49 c8       	lddpc	r8,80007fe0 <ulTaskGenericNotifyTake+0x8c>
80007f74:	70 08       	ld.w	r8,r8[0x0]
80007f76:	0e 08       	add	r8,r7
80007f78:	30 19       	mov	r9,1
80007f7a:	f1 69 00 50 	st.b	r8[80],r9

                if( xTicksToWait > ( TickType_t ) 0 )
80007f7e:	58 06       	cp.w	r6,0
80007f80:	c0 60       	breq	80007f8c <ulTaskGenericNotifyTake+0x38>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80007f82:	30 1b       	mov	r11,1
80007f84:	0c 9c       	mov	r12,r6
80007f86:	f0 1f 00 18 	mcall	80007fe4 <ulTaskGenericNotifyTake+0x90>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
80007f8a:	d7 33       	scall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80007f8c:	f0 1f 00 17 	mcall	80007fe8 <ulTaskGenericNotifyTake+0x94>

        taskENTER_CRITICAL();
80007f90:	f0 1f 00 13 	mcall	80007fdc <ulTaskGenericNotifyTake+0x88>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
80007f94:	49 38       	lddpc	r8,80007fe0 <ulTaskGenericNotifyTake+0x8c>
80007f96:	70 08       	ld.w	r8,r8[0x0]
80007f98:	ee c9 ff ed 	sub	r9,r7,-19
80007f9c:	f0 09 03 26 	ld.w	r6,r8[r9<<0x2]

            if( ulReturn != 0UL )
80007fa0:	58 06       	cp.w	r6,0
80007fa2:	c1 10       	breq	80007fc4 <ulTaskGenericNotifyTake+0x70>
            {
                if( xClearCountOnExit != pdFALSE )
80007fa4:	58 05       	cp.w	r5,0
80007fa6:	c0 70       	breq	80007fb4 <ulTaskGenericNotifyTake+0x60>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
80007fa8:	48 e8       	lddpc	r8,80007fe0 <ulTaskGenericNotifyTake+0x8c>
80007faa:	70 08       	ld.w	r8,r8[0x0]
80007fac:	30 0a       	mov	r10,0
80007fae:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007fb2:	c0 98       	rjmp	80007fc4 <ulTaskGenericNotifyTake+0x70>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
80007fb4:	48 b8       	lddpc	r8,80007fe0 <ulTaskGenericNotifyTake+0x8c>
80007fb6:	70 08       	ld.w	r8,r8[0x0]
80007fb8:	ec ca 00 01 	sub	r10,r6,1
80007fbc:	ee c9 ff ed 	sub	r9,r7,-19
80007fc0:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
80007fc4:	48 78       	lddpc	r8,80007fe0 <ulTaskGenericNotifyTake+0x8c>
80007fc6:	70 08       	ld.w	r8,r8[0x0]
80007fc8:	f0 07 00 07 	add	r7,r8,r7
80007fcc:	30 08       	mov	r8,0
80007fce:	ef 68 00 50 	st.b	r7[80],r8
        }
        taskEXIT_CRITICAL();
80007fd2:	f0 1f 00 06 	mcall	80007fe8 <ulTaskGenericNotifyTake+0x94>

        return ulReturn;
    }
80007fd6:	0c 9c       	mov	r12,r6
80007fd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007fdc:	80 00       	ld.sh	r0,r0[0x0]
80007fde:	6e c8       	ld.w	r8,r7[0x30]
80007fe0:	00 00       	add	r0,r0
80007fe2:	75 b0       	ld.w	r0,r10[0x6c]
80007fe4:	80 00       	ld.sh	r0,r0[0x0]
80007fe6:	7e bc       	ld.w	r12,pc[0x2c]
80007fe8:	80 00       	ld.sh	r0,r0[0x0]
80007fea:	6f d4       	ld.w	r4,r7[0x74]

80007fec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
80007fec:	eb cd 40 80 	pushm	r7,lr
80007ff0:	18 97       	mov	r7,r12
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
80007ff2:	58 0c       	cp.w	r12,0
80007ff4:	c0 a0       	breq	80008008 <vTaskDelay+0x1c>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
80007ff6:	f0 1f 00 07 	mcall	80008010 <vTaskDelay+0x24>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
80007ffa:	30 0b       	mov	r11,0
80007ffc:	0e 9c       	mov	r12,r7
80007ffe:	f0 1f 00 06 	mcall	80008014 <vTaskDelay+0x28>
            }
            xAlreadyYielded = xTaskResumeAll();
80008002:	f0 1f 00 06 	mcall	80008018 <vTaskDelay+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
80008006:	c0 21       	brne	8000800a <vTaskDelay+0x1e>
        {
            portYIELD_WITHIN_API();
80008008:	d7 33       	scall
8000800a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000800e:	00 00       	add	r0,r0
80008010:	80 00       	ld.sh	r0,r0[0x0]
80008012:	76 bc       	ld.w	r12,r11[0x2c]
80008014:	80 00       	ld.sh	r0,r0[0x0]
80008016:	7e bc       	ld.w	r12,pc[0x2c]
80008018:	80 00       	ld.sh	r0,r0[0x0]
8000801a:	7c 20       	ld.w	r0,lr[0x8]

8000801c <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
8000801c:	eb cd 40 80 	pushm	r7,lr
80008020:	16 97       	mov	r7,r11

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80008022:	48 68       	lddpc	r8,80008038 <vTaskPlaceOnEventList+0x1c>
80008024:	70 0b       	ld.w	r11,r8[0x0]
80008026:	2e 8b       	sub	r11,-24
80008028:	f0 1f 00 05 	mcall	8000803c <vTaskPlaceOnEventList+0x20>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
8000802c:	30 1b       	mov	r11,1
8000802e:	0e 9c       	mov	r12,r7
80008030:	f0 1f 00 04 	mcall	80008040 <vTaskPlaceOnEventList+0x24>
}
80008034:	e3 cd 80 80 	ldm	sp++,r7,pc
80008038:	00 00       	add	r0,r0
8000803a:	75 b0       	ld.w	r0,r10[0x6c]
8000803c:	80 00       	ld.sh	r0,r0[0x0]
8000803e:	6d de       	ld.w	lr,r6[0x74]
80008040:	80 00       	ld.sh	r0,r0[0x0]
80008042:	7e bc       	ld.w	r12,pc[0x2c]

80008044 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
80008044:	eb cd 40 80 	pushm	r7,lr
80008048:	18 97       	mov	r7,r12

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
8000804a:	78 cc       	ld.w	r12,r12[0x30]
8000804c:	f0 1f 00 04 	mcall	8000805c <prvDeleteTCB+0x18>
                vPortFree( pxTCB );
80008050:	0e 9c       	mov	r12,r7
80008052:	f0 1f 00 03 	mcall	8000805c <prvDeleteTCB+0x18>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
80008056:	e3 cd 80 80 	ldm	sp++,r7,pc
8000805a:	00 00       	add	r0,r0
8000805c:	80 00       	ld.sh	r0,r0[0x0]
8000805e:	70 90       	ld.w	r0,r8[0x24]

80008060 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80008060:	eb cd 40 f8 	pushm	r3-r7,lr
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80008064:	49 17       	lddpc	r7,800080a8 <prvIdleTask+0x48>
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80008066:	49 25       	lddpc	r5,800080ac <prvIdleTask+0x4c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
80008068:	49 24       	lddpc	r4,800080b0 <prvIdleTask+0x50>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
8000806a:	49 33       	lddpc	r3,800080b4 <prvIdleTask+0x54>
8000806c:	c1 48       	rjmp	80008094 <prvIdleTask+0x34>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
8000806e:	f0 1f 00 13 	mcall	800080b8 <prvIdleTask+0x58>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80008072:	6a 38       	ld.w	r8,r5[0xc]
80008074:	70 36       	ld.w	r6,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80008076:	ec cc ff fc 	sub	r12,r6,-4
8000807a:	f0 1f 00 11 	mcall	800080bc <prvIdleTask+0x5c>
                    --uxCurrentNumberOfTasks;
8000807e:	68 08       	ld.w	r8,r4[0x0]
80008080:	20 18       	sub	r8,1
80008082:	89 08       	st.w	r4[0x0],r8
                    --uxDeletedTasksWaitingCleanUp;
80008084:	6e 08       	ld.w	r8,r7[0x0]
80008086:	20 18       	sub	r8,1
80008088:	8f 08       	st.w	r7[0x0],r8
                }
                taskEXIT_CRITICAL();
8000808a:	f0 1f 00 0e 	mcall	800080c0 <prvIdleTask+0x60>

                prvDeleteTCB( pxTCB );
8000808e:	0c 9c       	mov	r12,r6
80008090:	f0 1f 00 0d 	mcall	800080c4 <prvIdleTask+0x64>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80008094:	6e 08       	ld.w	r8,r7[0x0]
80008096:	58 08       	cp.w	r8,0
80008098:	ce b1       	brne	8000806e <prvIdleTask+0xe>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
8000809a:	66 08       	ld.w	r8,r3[0x0]
8000809c:	58 18       	cp.w	r8,1
8000809e:	fe 98 ff fb 	brls	80008094 <prvIdleTask+0x34>
                {
                    taskYIELD();
800080a2:	d7 33       	scall
800080a4:	cf 8b       	rjmp	80008094 <prvIdleTask+0x34>
800080a6:	00 00       	add	r0,r0
800080a8:	00 00       	add	r0,r0
800080aa:	75 ac       	ld.w	r12,r10[0x68]
800080ac:	00 00       	add	r0,r0
800080ae:	76 00       	ld.w	r0,r11[0x0]
800080b0:	00 00       	add	r0,r0
800080b2:	75 fc       	ld.w	r12,r10[0x7c]
800080b4:	00 00       	add	r0,r0
800080b6:	75 0c       	ld.w	r12,r10[0x40]
800080b8:	80 00       	ld.sh	r0,r0[0x0]
800080ba:	6e c8       	ld.w	r8,r7[0x30]
800080bc:	80 00       	ld.sh	r0,r0[0x0]
800080be:	6e 0e       	ld.w	lr,r7[0x0]
800080c0:	80 00       	ld.sh	r0,r0[0x0]
800080c2:	6f d4       	ld.w	r4,r7[0x74]
800080c4:	80 00       	ld.sh	r0,r0[0x0]
800080c6:	80 44       	ld.sh	r4,r0[0x8]

800080c8 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
800080c8:	d4 31       	pushm	r0-r7,lr
800080ca:	20 1d       	sub	sp,4
800080cc:	50 0c       	stdsp	sp[0x0],r12
800080ce:	16 97       	mov	r7,r11
800080d0:	12 90       	mov	r0,r9
800080d2:	10 94       	mov	r4,r8
800080d4:	40 a2       	lddsp	r2,sp[0x28]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
800080d6:	e7 da c0 10 	bfextu	r3,r10,0x0,0x10
800080da:	e6 0c 15 02 	lsl	r12,r3,0x2
800080de:	f0 1f 00 61 	mcall	80008260 <xTaskCreate+0x198>
800080e2:	18 96       	mov	r6,r12

                if( pxStack != NULL )
800080e4:	c0 31       	brne	800080ea <xTaskCreate+0x22>
800080e6:	3f fc       	mov	r12,-1
800080e8:	cb a8       	rjmp	8000825c <xTaskCreate+0x194>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
800080ea:	35 4c       	mov	r12,84
800080ec:	f0 1f 00 5d 	mcall	80008260 <xTaskCreate+0x198>
800080f0:	18 95       	mov	r5,r12

                    if( pxNewTCB != NULL )
800080f2:	c0 50       	breq	800080fc <xTaskCreate+0x34>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
800080f4:	99 c6       	st.w	r12[0x30],r6
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
800080f6:	58 07       	cp.w	r7,0
800080f8:	c0 71       	brne	80008106 <xTaskCreate+0x3e>
800080fa:	c2 28       	rjmp	8000813e <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
800080fc:	0c 9c       	mov	r12,r6
800080fe:	f0 1f 00 5a 	mcall	80008264 <xTaskCreate+0x19c>
80008102:	3f fc       	mov	r12,-1
80008104:	ca c8       	rjmp	8000825c <xTaskCreate+0x194>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80008106:	0f 88       	ld.ub	r8,r7[0x0]
80008108:	f9 68 00 34 	st.b	r12[52],r8

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
8000810c:	0f 89       	ld.ub	r9,r7[0x0]
8000810e:	30 08       	mov	r8,0
80008110:	f0 09 18 00 	cp.b	r9,r8
80008114:	c1 10       	breq	80008136 <xTaskCreate+0x6e>
80008116:	2f f7       	sub	r7,-1
80008118:	f8 c8 ff cb 	sub	r8,r12,-53
8000811c:	30 19       	mov	r9,1
8000811e:	30 0b       	mov	r11,0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80008120:	0f 8a       	ld.ub	r10,r7[0x0]
80008122:	b0 8a       	st.b	r8[0x0],r10

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80008124:	0f 8a       	ld.ub	r10,r7[0x0]
80008126:	f6 0a 18 00 	cp.b	r10,r11
8000812a:	c0 60       	breq	80008136 <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
8000812c:	2f f9       	sub	r9,-1
8000812e:	2f f7       	sub	r7,-1
80008130:	2f f8       	sub	r8,-1
80008132:	59 09       	cp.w	r9,16
80008134:	cf 61       	brne	80008120 <xTaskCreate+0x58>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80008136:	30 08       	mov	r8,0
80008138:	eb 68 00 43 	st.b	r5[67],r8
8000813c:	c0 48       	rjmp	80008144 <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
8000813e:	30 08       	mov	r8,0
80008140:	f9 68 00 34 	st.b	r12[52],r8
80008144:	58 74       	cp.w	r4,7
80008146:	f9 b4 0b 07 	movhi	r4,7
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
8000814a:	8b b4       	st.w	r5[0x2c],r4
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
8000814c:	eb 44 00 44 	st.w	r5[68],r4
            pxNewTCB->uxMutexesHeld = 0;
80008150:	30 07       	mov	r7,0
80008152:	eb 47 00 48 	st.w	r5[72],r7
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80008156:	ea c1 ff fc 	sub	r1,r5,-4
8000815a:	02 9c       	mov	r12,r1
8000815c:	f0 1f 00 43 	mcall	80008268 <xTaskCreate+0x1a0>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80008160:	ea cc ff e8 	sub	r12,r5,-24
80008164:	f0 1f 00 41 	mcall	80008268 <xTaskCreate+0x1a0>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80008168:	8b 45       	st.w	r5[0x10],r5

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000816a:	e8 04 11 08 	rsub	r4,r4,8
8000816e:	8b 64       	st.w	r5[0x18],r4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80008170:	8b 95       	st.w	r5[0x24],r5
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
80008172:	ea c8 ff b4 	sub	r8,r5,-76
80008176:	91 07       	st.w	r8[0x0],r7
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
80008178:	ea c8 ff b0 	sub	r8,r5,-80
8000817c:	b0 87       	st.b	r8[0x0],r7
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
8000817e:	20 13       	sub	r3,1
80008180:	ec 03 00 26 	add	r6,r6,r3<<0x2
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80008184:	00 9a       	mov	r10,r0
80008186:	40 0b       	lddsp	r11,sp[0x0]
80008188:	0c 9c       	mov	r12,r6
8000818a:	e0 1c ff fc 	andl	r12,0xfffc
8000818e:	f0 1f 00 38 	mcall	8000826c <xTaskCreate+0x1a4>
80008192:	8b 0c       	st.w	r5[0x0],r12

    if( pxCreatedTask != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80008194:	58 02       	cp.w	r2,0
80008196:	e5 f5 1a 00 	st.wne	r2[0x0],r5

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
8000819a:	f0 1f 00 36 	mcall	80008270 <xTaskCreate+0x1a8>
    {
        uxCurrentNumberOfTasks++;
8000819e:	4b 68       	lddpc	r8,80008274 <xTaskCreate+0x1ac>
800081a0:	70 09       	ld.w	r9,r8[0x0]
800081a2:	2f f9       	sub	r9,-1
800081a4:	91 09       	st.w	r8[0x0],r9

        if( pxCurrentTCB == NULL )
800081a6:	4b 58       	lddpc	r8,80008278 <xTaskCreate+0x1b0>
800081a8:	70 08       	ld.w	r8,r8[0x0]
800081aa:	58 08       	cp.w	r8,0
800081ac:	c2 61       	brne	800081f8 <xTaskCreate+0x130>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
800081ae:	4b 38       	lddpc	r8,80008278 <xTaskCreate+0x1b0>
800081b0:	91 05       	st.w	r8[0x0],r5

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
800081b2:	4b 18       	lddpc	r8,80008274 <xTaskCreate+0x1ac>
800081b4:	70 08       	ld.w	r8,r8[0x0]
800081b6:	58 18       	cp.w	r8,1
800081b8:	c2 d1       	brne	80008212 <xTaskCreate+0x14a>
800081ba:	4b 17       	lddpc	r7,8000827c <xTaskCreate+0x1b4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
800081bc:	ee c6 ff 60 	sub	r6,r7,-160
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
800081c0:	0e 9c       	mov	r12,r7
800081c2:	f0 1f 00 30 	mcall	80008280 <xTaskCreate+0x1b8>
800081c6:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
800081c8:	0c 37       	cp.w	r7,r6
800081ca:	cf b1       	brne	800081c0 <xTaskCreate+0xf8>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
800081cc:	4a e7       	lddpc	r7,80008284 <xTaskCreate+0x1bc>
800081ce:	0e 9c       	mov	r12,r7
800081d0:	f0 1f 00 2c 	mcall	80008280 <xTaskCreate+0x1b8>
    vListInitialise( &xDelayedTaskList2 );
800081d4:	4a d6       	lddpc	r6,80008288 <xTaskCreate+0x1c0>
800081d6:	0c 9c       	mov	r12,r6
800081d8:	f0 1f 00 2a 	mcall	80008280 <xTaskCreate+0x1b8>
    vListInitialise( &xPendingReadyList );
800081dc:	4a cc       	lddpc	r12,8000828c <xTaskCreate+0x1c4>
800081de:	f0 1f 00 29 	mcall	80008280 <xTaskCreate+0x1b8>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
800081e2:	4a cc       	lddpc	r12,80008290 <xTaskCreate+0x1c8>
800081e4:	f0 1f 00 27 	mcall	80008280 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
800081e8:	4a bc       	lddpc	r12,80008294 <xTaskCreate+0x1cc>
800081ea:	f0 1f 00 26 	mcall	80008280 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
800081ee:	4a b8       	lddpc	r8,80008298 <xTaskCreate+0x1d0>
800081f0:	91 07       	st.w	r8[0x0],r7
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
800081f2:	4a b8       	lddpc	r8,8000829c <xTaskCreate+0x1d4>
800081f4:	91 06       	st.w	r8[0x0],r6
800081f6:	c0 e8       	rjmp	80008212 <xTaskCreate+0x14a>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
800081f8:	4a a8       	lddpc	r8,800082a0 <xTaskCreate+0x1d8>
800081fa:	70 08       	ld.w	r8,r8[0x0]
800081fc:	58 08       	cp.w	r8,0
800081fe:	c0 a1       	brne	80008212 <xTaskCreate+0x14a>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80008200:	49 e8       	lddpc	r8,80008278 <xTaskCreate+0x1b0>
80008202:	70 08       	ld.w	r8,r8[0x0]
80008204:	70 b9       	ld.w	r9,r8[0x2c]
80008206:	6a b8       	ld.w	r8,r5[0x2c]
80008208:	10 39       	cp.w	r9,r8
8000820a:	e0 8b 00 04 	brhi	80008212 <xTaskCreate+0x14a>
                {
                    pxCurrentTCB = pxNewTCB;
8000820e:	49 b8       	lddpc	r8,80008278 <xTaskCreate+0x1b0>
80008210:	91 05       	st.w	r8[0x0],r5
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
80008212:	4a 58       	lddpc	r8,800082a4 <xTaskCreate+0x1dc>
80008214:	70 09       	ld.w	r9,r8[0x0]
80008216:	2f f9       	sub	r9,-1
80008218:	91 09       	st.w	r8[0x0],r9
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
8000821a:	6a b8       	ld.w	r8,r5[0x2c]
8000821c:	4a 39       	lddpc	r9,800082a8 <xTaskCreate+0x1e0>
8000821e:	72 09       	ld.w	r9,r9[0x0]
80008220:	12 38       	cp.w	r8,r9
80008222:	e0 88 00 04 	brls	8000822a <xTaskCreate+0x162>
80008226:	4a 19       	lddpc	r9,800082a8 <xTaskCreate+0x1e0>
80008228:	93 08       	st.w	r9[0x0],r8
8000822a:	6a bc       	ld.w	r12,r5[0x2c]
8000822c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80008230:	02 9b       	mov	r11,r1
80008232:	49 38       	lddpc	r8,8000827c <xTaskCreate+0x1b4>
80008234:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80008238:	f0 1f 00 1d 	mcall	800082ac <xTaskCreate+0x1e4>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
8000823c:	f0 1f 00 1d 	mcall	800082b0 <xTaskCreate+0x1e8>

    if( xSchedulerRunning != pdFALSE )
80008240:	49 88       	lddpc	r8,800082a0 <xTaskCreate+0x1d8>
80008242:	70 08       	ld.w	r8,r8[0x0]
80008244:	58 08       	cp.w	r8,0
80008246:	c0 a0       	breq	8000825a <xTaskCreate+0x192>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80008248:	48 c8       	lddpc	r8,80008278 <xTaskCreate+0x1b0>
8000824a:	70 08       	ld.w	r8,r8[0x0]
8000824c:	70 b9       	ld.w	r9,r8[0x2c]
8000824e:	6a b8       	ld.w	r8,r5[0x2c]
80008250:	10 39       	cp.w	r9,r8
80008252:	c0 42       	brcc	8000825a <xTaskCreate+0x192>
        {
            taskYIELD_IF_USING_PREEMPTION();
80008254:	d7 33       	scall
80008256:	30 1c       	mov	r12,1
80008258:	c0 28       	rjmp	8000825c <xTaskCreate+0x194>
8000825a:	30 1c       	mov	r12,1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
8000825c:	2f fd       	sub	sp,-4
8000825e:	d8 32       	popm	r0-r7,pc
80008260:	80 00       	ld.sh	r0,r0[0x0]
80008262:	70 b8       	ld.w	r8,r8[0x2c]
80008264:	80 00       	ld.sh	r0,r0[0x0]
80008266:	70 90       	ld.w	r0,r8[0x24]
80008268:	80 00       	ld.sh	r0,r0[0x0]
8000826a:	6d c0       	ld.w	r0,r6[0x70]
8000826c:	80 00       	ld.sh	r0,r0[0x0]
8000826e:	6e 36       	ld.w	r6,r7[0xc]
80008270:	80 00       	ld.sh	r0,r0[0x0]
80008272:	6e c8       	ld.w	r8,r7[0x30]
80008274:	00 00       	add	r0,r0
80008276:	75 fc       	ld.w	r12,r10[0x7c]
80008278:	00 00       	add	r0,r0
8000827a:	75 b0       	ld.w	r0,r10[0x6c]
8000827c:	00 00       	add	r0,r0
8000827e:	75 0c       	ld.w	r12,r10[0x40]
80008280:	80 00       	ld.sh	r0,r0[0x0]
80008282:	6d ac       	ld.w	r12,r6[0x68]
80008284:	00 00       	add	r0,r0
80008286:	75 c8       	ld.w	r8,r10[0x70]
80008288:	00 00       	add	r0,r0
8000828a:	75 e4       	ld.w	r4,r10[0x78]
8000828c:	00 00       	add	r0,r0
8000828e:	75 b4       	ld.w	r4,r10[0x6c]
80008290:	00 00       	add	r0,r0
80008292:	76 00       	ld.w	r0,r11[0x0]
80008294:	00 00       	add	r0,r0
80008296:	76 18       	ld.w	r8,r11[0x4]
80008298:	00 00       	add	r0,r0
8000829a:	74 f8       	ld.w	r8,r10[0x3c]
8000829c:	00 00       	add	r0,r0
8000829e:	75 04       	ld.w	r4,r10[0x40]
800082a0:	00 00       	add	r0,r0
800082a2:	74 fc       	ld.w	r12,r10[0x3c]
800082a4:	00 00       	add	r0,r0
800082a6:	75 f8       	ld.w	r8,r10[0x7c]
800082a8:	00 00       	add	r0,r0
800082aa:	76 2c       	ld.w	r12,r11[0x8]
800082ac:	80 00       	ld.sh	r0,r0[0x0]
800082ae:	6d c6       	ld.w	r6,r6[0x70]
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	6f d4       	ld.w	r4,r7[0x74]

800082b4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
800082b4:	d4 01       	pushm	lr
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
800082b6:	48 e8       	lddpc	r8,800082ec <vTaskStartScheduler+0x38>
800082b8:	1a d8       	st.w	--sp,r8
800082ba:	30 08       	mov	r8,0
800082bc:	10 99       	mov	r9,r8
800082be:	e0 6a 01 00 	mov	r10,256
800082c2:	48 cb       	lddpc	r11,800082f0 <vTaskStartScheduler+0x3c>
800082c4:	48 cc       	lddpc	r12,800082f4 <vTaskStartScheduler+0x40>
800082c6:	f0 1f 00 0d 	mcall	800082f8 <vTaskStartScheduler+0x44>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
800082ca:	2f fd       	sub	sp,-4
800082cc:	58 1c       	cp.w	r12,1
800082ce:	c0 d1       	brne	800082e8 <vTaskStartScheduler+0x34>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
800082d0:	d3 03       	ssrf	0x10
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
800082d2:	3f f9       	mov	r9,-1
800082d4:	48 a8       	lddpc	r8,800082fc <vTaskStartScheduler+0x48>
800082d6:	91 09       	st.w	r8[0x0],r9
        xSchedulerRunning = pdTRUE;
800082d8:	30 19       	mov	r9,1
800082da:	48 a8       	lddpc	r8,80008300 <vTaskStartScheduler+0x4c>
800082dc:	91 09       	st.w	r8[0x0],r9
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
800082de:	30 09       	mov	r9,0
800082e0:	48 98       	lddpc	r8,80008304 <vTaskStartScheduler+0x50>
800082e2:	91 09       	st.w	r8[0x0],r9

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
800082e4:	f0 1f 00 09 	mcall	80008308 <vTaskStartScheduler+0x54>
800082e8:	d8 02       	popm	pc
800082ea:	00 00       	add	r0,r0
800082ec:	00 00       	add	r0,r0
800082ee:	76 14       	ld.w	r4,r11[0x4]
800082f0:	80 01       	ld.sh	r1,r0[0x0]
800082f2:	ac d8       	st.b	r6[0x5],r8
800082f4:	80 00       	ld.sh	r0,r0[0x0]
800082f6:	80 60       	ld.sh	r0,r0[0xc]
800082f8:	80 00       	ld.sh	r0,r0[0x0]
800082fa:	80 c8       	ld.uh	r8,r0[0x8]
800082fc:	00 00       	add	r0,r0
800082fe:	74 f4       	ld.w	r4,r10[0x3c]
80008300:	00 00       	add	r0,r0
80008302:	74 fc       	ld.w	r12,r10[0x3c]
80008304:	00 00       	add	r0,r0
80008306:	75 dc       	ld.w	r12,r10[0x74]
80008308:	80 00       	ld.sh	r0,r0[0x0]
8000830a:	6e d8       	ld.w	r8,r7[0x34]

8000830c <LED_On>:
  }
}


void LED_On(uint32_t leds)
{
8000830c:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
8000830e:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);
80008312:	49 48       	lddpc	r8,80008360 <LED_On+0x54>
80008314:	70 09       	ld.w	r9,r8[0x0]
80008316:	f9 e9 10 09 	or	r9,r12,r9
8000831a:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
8000831c:	58 0c       	cp.w	r12,0
8000831e:	c1 f0       	breq	8000835c <LED_On+0x50>
80008320:	49 18       	lddpc	r8,80008364 <LED_On+0x58>
80008322:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it on.
    led_shift = 1 + ctz(leds);
80008324:	32 1e       	mov	lr,33
80008326:	58 0c       	cp.w	r12,0
80008328:	c0 31       	brne	8000832e <LED_On+0x22>
8000832a:	1c 9a       	mov	r10,lr
8000832c:	c0 68       	rjmp	80008338 <LED_On+0x2c>
8000832e:	18 9a       	mov	r10,r12
80008330:	5c 9a       	brev	r10
80008332:	f4 0a 12 00 	clz	r10,r10
80008336:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80008338:	f4 09 15 04 	lsl	r9,r10,0x4
8000833c:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
8000833e:	70 09       	ld.w	r9,r8[0x0]
80008340:	a9 69       	lsl	r9,0x8
80008342:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrc  = led_descriptor->GPIO.PIN_MASK;
80008346:	70 1b       	ld.w	r11,r8[0x4]
80008348:	f3 4b 00 58 	st.w	r9[88],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
8000834c:	70 1b       	ld.w	r11,r8[0x4]
8000834e:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80008352:	70 1b       	ld.w	r11,r8[0x4]
80008354:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80008356:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
8000835a:	ce 61       	brne	80008326 <LED_On+0x1a>
8000835c:	d8 02       	popm	pc
8000835e:	00 00       	add	r0,r0
80008360:	00 00       	add	r0,r0
80008362:	00 14       	sub	r4,r0
80008364:	80 01       	ld.sh	r1,r0[0x0]
80008366:	ac e0       	st.b	r6[0x6],r0

80008368 <LED_Off>:
  return Tst_bits(LED_State, leds);
}


void LED_Off(uint32_t leds)
{
80008368:	d4 01       	pushm	lr
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
8000836a:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);
8000836e:	49 58       	lddpc	r8,800083c0 <LED_Off+0x58>
80008370:	70 09       	ld.w	r9,r8[0x0]
80008372:	f8 0a 11 ff 	rsub	r10,r12,-1
80008376:	f5 e9 00 09 	and	r9,r10,r9
8000837a:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
8000837c:	58 0c       	cp.w	r12,0
8000837e:	c1 f0       	breq	800083bc <LED_Off+0x54>
80008380:	49 18       	lddpc	r8,800083c4 <LED_Off+0x5c>
80008382:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it off.
    led_shift = 1 + ctz(leds);
80008384:	32 1e       	mov	lr,33
80008386:	58 0c       	cp.w	r12,0
80008388:	c0 31       	brne	8000838e <LED_Off+0x26>
8000838a:	1c 9a       	mov	r10,lr
8000838c:	c0 68       	rjmp	80008398 <LED_Off+0x30>
8000838e:	18 9a       	mov	r10,r12
80008390:	5c 9a       	brev	r10
80008392:	f4 0a 12 00 	clz	r10,r10
80008396:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80008398:	f4 09 15 04 	lsl	r9,r10,0x4
8000839c:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
8000839e:	70 09       	ld.w	r9,r8[0x0]
800083a0:	a9 69       	lsl	r9,0x8
800083a2:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
800083a6:	70 1b       	ld.w	r11,r8[0x4]
800083a8:	f3 4b 00 54 	st.w	r9[84],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
800083ac:	70 1b       	ld.w	r11,r8[0x4]
800083ae:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
800083b2:	70 1b       	ld.w	r11,r8[0x4]
800083b4:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
800083b6:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
800083ba:	ce 61       	brne	80008386 <LED_Off+0x1e>
800083bc:	d8 02       	popm	pc
800083be:	00 00       	add	r0,r0
800083c0:	00 00       	add	r0,r0
800083c2:	00 14       	sub	r4,r0
800083c4:	80 01       	ld.sh	r1,r0[0x0]
800083c6:	ac e0       	st.b	r6[0x6],r0

800083c8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800083c8:	f8 08 16 05 	lsr	r8,r12,0x5
800083cc:	a9 68       	lsl	r8,0x8
800083ce:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800083d2:	58 1b       	cp.w	r11,1
800083d4:	c0 d0       	breq	800083ee <gpio_enable_module_pin+0x26>
800083d6:	c0 63       	brcs	800083e2 <gpio_enable_module_pin+0x1a>
800083d8:	58 2b       	cp.w	r11,2
800083da:	c1 00       	breq	800083fa <gpio_enable_module_pin+0x32>
800083dc:	58 3b       	cp.w	r11,3
800083de:	c1 40       	breq	80008406 <gpio_enable_module_pin+0x3e>
800083e0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800083e2:	30 19       	mov	r9,1
800083e4:	f2 0c 09 49 	lsl	r9,r9,r12
800083e8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800083ea:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800083ec:	c1 28       	rjmp	80008410 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800083ee:	30 19       	mov	r9,1
800083f0:	f2 0c 09 49 	lsl	r9,r9,r12
800083f4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800083f6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800083f8:	c0 c8       	rjmp	80008410 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800083fa:	30 19       	mov	r9,1
800083fc:	f2 0c 09 49 	lsl	r9,r9,r12
80008400:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008402:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80008404:	c0 68       	rjmp	80008410 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80008406:	30 19       	mov	r9,1
80008408:	f2 0c 09 49 	lsl	r9,r9,r12
8000840c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000840e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008410:	30 19       	mov	r9,1
80008412:	f2 0c 09 4c 	lsl	r12,r9,r12
80008416:	91 2c       	st.w	r8[0x8],r12
80008418:	5e fd       	retal	0
8000841a:	d7 03       	nop

8000841c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000841c:	d4 21       	pushm	r4-r7,lr
8000841e:	18 97       	mov	r7,r12
80008420:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008422:	58 0b       	cp.w	r11,0
80008424:	c0 31       	brne	8000842a <gpio_enable_module+0xe>
80008426:	30 05       	mov	r5,0
80008428:	c0 d8       	rjmp	80008442 <gpio_enable_module+0x26>
8000842a:	30 06       	mov	r6,0
8000842c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000842e:	6e 1b       	ld.w	r11,r7[0x4]
80008430:	6e 0c       	ld.w	r12,r7[0x0]
80008432:	f0 1f 00 06 	mcall	80008448 <gpio_enable_module+0x2c>
80008436:	18 45       	or	r5,r12
		gpiomap++;
80008438:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000843a:	2f f6       	sub	r6,-1
8000843c:	0c 34       	cp.w	r4,r6
8000843e:	fe 9b ff f8 	brhi	8000842e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80008442:	0a 9c       	mov	r12,r5
80008444:	d8 22       	popm	r4-r7,pc
80008446:	00 00       	add	r0,r0
80008448:	80 00       	ld.sh	r0,r0[0x0]
8000844a:	83 c8       	st.w	r1[0x30],r8

8000844c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000844c:	f8 08 16 05 	lsr	r8,r12,0x5
80008450:	a9 68       	lsl	r8,0x8
80008452:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80008456:	30 19       	mov	r9,1
80008458:	f2 0c 09 4c 	lsl	r12,r9,r12
8000845c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80008460:	91 1c       	st.w	r8[0x4],r12
}
80008462:	5e fc       	retal	r12

80008464 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
80008464:	eb cd 40 e0 	pushm	r5-r7,lr
80008468:	18 97       	mov	r7,r12
8000846a:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
8000846c:	58 0b       	cp.w	r11,0
8000846e:	c0 a0       	breq	80008482 <gpio_enable_gpio+0x1e>
80008470:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
80008472:	6e 0c       	ld.w	r12,r7[0x0]
80008474:	f0 1f 00 05 	mcall	80008488 <gpio_enable_gpio+0x24>
		gpiomap++;
80008478:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
8000847a:	2f f5       	sub	r5,-1
8000847c:	0a 36       	cp.w	r6,r5
8000847e:	fe 9b ff fa 	brhi	80008472 <gpio_enable_gpio+0xe>
80008482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008486:	00 00       	add	r0,r0
80008488:	80 00       	ld.sh	r0,r0[0x0]
8000848a:	84 4c       	ld.sh	r12,r2[0x8]

8000848c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000848c:	f8 08 16 05 	lsr	r8,r12,0x5
80008490:	a9 68       	lsl	r8,0x8
80008492:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80008496:	30 19       	mov	r9,1
80008498:	f2 0c 09 4c 	lsl	r12,r9,r12
8000849c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800084a0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800084a4:	91 1c       	st.w	r8[0x4],r12
}
800084a6:	5e fc       	retal	r12

800084a8 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800084a8:	f8 08 16 05 	lsr	r8,r12,0x5
800084ac:	a9 68       	lsl	r8,0x8
800084ae:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800084b2:	30 19       	mov	r9,1
800084b4:	f2 0c 09 4c 	lsl	r12,r9,r12
800084b8:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800084bc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800084c0:	91 1c       	st.w	r8[0x4],r12
}
800084c2:	5e fc       	retal	r12

800084c4 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800084c4:	f8 08 16 05 	lsr	r8,r12,0x5
800084c8:	a9 68       	lsl	r8,0x8
800084ca:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
800084ce:	30 19       	mov	r9,1
800084d0:	f2 0c 09 4c 	lsl	r12,r9,r12
800084d4:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
800084d8:	12 3b       	cp.w	r11,r9
800084da:	c0 a0       	breq	800084ee <gpio_enable_pin_interrupt+0x2a>
800084dc:	c0 43       	brcs	800084e4 <gpio_enable_pin_interrupt+0x20>
800084de:	58 2b       	cp.w	r11,2
800084e0:	c1 11       	brne	80008502 <gpio_enable_pin_interrupt+0x3e>
800084e2:	c0 b8       	rjmp	800084f8 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800084e4:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800084e8:	f1 4c 00 b8 	st.w	r8[184],r12
800084ec:	c0 c8       	rjmp	80008504 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
800084ee:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800084f2:	f1 4c 00 b8 	st.w	r8[184],r12
800084f6:	c0 78       	rjmp	80008504 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800084f8:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
800084fc:	f1 4c 00 b4 	st.w	r8[180],r12
80008500:	c0 28       	rjmp	80008504 <gpio_enable_pin_interrupt+0x40>
80008502:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80008504:	f1 4c 00 94 	st.w	r8[148],r12
80008508:	5e fd       	retal	0

8000850a <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000850a:	f8 08 16 05 	lsr	r8,r12,0x5
8000850e:	a9 68       	lsl	r8,0x8
80008510:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80008514:	f0 f8 00 d0 	ld.w	r8,r8[208]
80008518:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000851c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80008520:	5e fc       	retal	r12

80008522 <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008522:	f8 08 16 05 	lsr	r8,r12,0x5
80008526:	a9 68       	lsl	r8,0x8
80008528:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
8000852c:	30 19       	mov	r9,1
8000852e:	f2 0c 09 4c 	lsl	r12,r9,r12
80008532:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
80008536:	5e fc       	retal	r12

80008538 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80008538:	c0 08       	rjmp	80008538 <_unhandled_interrupt>
8000853a:	d7 03       	nop

8000853c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000853c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80008540:	49 99       	lddpc	r9,800085a4 <INTC_register_interrupt+0x68>
80008542:	f2 08 00 39 	add	r9,r9,r8<<0x3
80008546:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000854a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000854c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80008550:	58 0a       	cp.w	r10,0
80008552:	c0 91       	brne	80008564 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008554:	49 59       	lddpc	r9,800085a8 <INTC_register_interrupt+0x6c>
80008556:	49 6a       	lddpc	r10,800085ac <INTC_register_interrupt+0x70>
80008558:	12 1a       	sub	r10,r9
8000855a:	fe 79 08 00 	mov	r9,-63488
8000855e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80008562:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80008564:	58 1a       	cp.w	r10,1
80008566:	c0 a1       	brne	8000857a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80008568:	49 09       	lddpc	r9,800085a8 <INTC_register_interrupt+0x6c>
8000856a:	49 2a       	lddpc	r10,800085b0 <INTC_register_interrupt+0x74>
8000856c:	12 1a       	sub	r10,r9
8000856e:	bf aa       	sbr	r10,0x1e
80008570:	fe 79 08 00 	mov	r9,-63488
80008574:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80008578:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000857a:	58 2a       	cp.w	r10,2
8000857c:	c0 a1       	brne	80008590 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000857e:	48 b9       	lddpc	r9,800085a8 <INTC_register_interrupt+0x6c>
80008580:	48 da       	lddpc	r10,800085b4 <INTC_register_interrupt+0x78>
80008582:	12 1a       	sub	r10,r9
80008584:	bf ba       	sbr	r10,0x1f
80008586:	fe 79 08 00 	mov	r9,-63488
8000858a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000858e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80008590:	48 69       	lddpc	r9,800085a8 <INTC_register_interrupt+0x6c>
80008592:	48 aa       	lddpc	r10,800085b8 <INTC_register_interrupt+0x7c>
80008594:	12 1a       	sub	r10,r9
80008596:	ea 1a c0 00 	orh	r10,0xc000
8000859a:	fe 79 08 00 	mov	r9,-63488
8000859e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800085a2:	5e fc       	retal	r12
800085a4:	80 01       	ld.sh	r1,r0[0x0]
800085a6:	ad 20       	st.d	r6++,r0
800085a8:	80 00       	ld.sh	r0,r0[0x0]
800085aa:	a4 00       	st.h	r2[0x0],r0
800085ac:	80 00       	ld.sh	r0,r0[0x0]
800085ae:	a5 04       	ld.d	r4,r2
800085b0:	80 00       	ld.sh	r0,r0[0x0]
800085b2:	a5 12       	ld.d	r2,--r2
800085b4:	80 00       	ld.sh	r0,r0[0x0]
800085b6:	a5 20       	st.d	r2++,r0
800085b8:	80 00       	ld.sh	r0,r0[0x0]
800085ba:	a5 2e       	st.d	r2++,lr

800085bc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800085bc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800085be:	49 18       	lddpc	r8,80008600 <INTC_init_interrupts+0x44>
800085c0:	e3 b8 00 01 	mtsr	0x4,r8
800085c4:	49 0e       	lddpc	lr,80008604 <INTC_init_interrupts+0x48>
800085c6:	30 07       	mov	r7,0
800085c8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800085ca:	49 0c       	lddpc	r12,80008608 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800085cc:	49 05       	lddpc	r5,8000860c <INTC_init_interrupts+0x50>
800085ce:	10 15       	sub	r5,r8
800085d0:	fe 76 08 00 	mov	r6,-63488
800085d4:	c1 08       	rjmp	800085f4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800085d6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800085d8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800085da:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800085dc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800085e0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800085e2:	10 3a       	cp.w	r10,r8
800085e4:	fe 9b ff fc 	brhi	800085dc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800085e8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800085ec:	2f f7       	sub	r7,-1
800085ee:	2f 8e       	sub	lr,-8
800085f0:	59 47       	cp.w	r7,20
800085f2:	c0 50       	breq	800085fc <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800085f4:	7c 08       	ld.w	r8,lr[0x0]
800085f6:	58 08       	cp.w	r8,0
800085f8:	ce f1       	brne	800085d6 <INTC_init_interrupts+0x1a>
800085fa:	cf 7b       	rjmp	800085e8 <INTC_init_interrupts+0x2c>
800085fc:	d8 22       	popm	r4-r7,pc
800085fe:	00 00       	add	r0,r0
80008600:	80 00       	ld.sh	r0,r0[0x0]
80008602:	a4 00       	st.h	r2[0x0],r0
80008604:	80 01       	ld.sh	r1,r0[0x0]
80008606:	ad 20       	st.d	r6++,r0
80008608:	80 00       	ld.sh	r0,r0[0x0]
8000860a:	85 38       	st.w	r2[0xc],r8
8000860c:	80 00       	ld.sh	r0,r0[0x0]
8000860e:	a5 04       	ld.d	r4,r2

80008610 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80008610:	fe 78 08 00 	mov	r8,-63488
80008614:	e0 69 00 83 	mov	r9,131
80008618:	f2 0c 01 0c 	sub	r12,r9,r12
8000861c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80008620:	f2 ca ff c0 	sub	r10,r9,-64
80008624:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008628:	58 08       	cp.w	r8,0
8000862a:	c0 21       	brne	8000862e <_get_interrupt_handler+0x1e>
8000862c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
8000862e:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80008632:	48 5a       	lddpc	r10,80008644 <_get_interrupt_handler+0x34>
80008634:	f4 09 00 39 	add	r9,r10,r9<<0x3
80008638:	f0 08 11 1f 	rsub	r8,r8,31
8000863c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000863e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80008642:	5e fc       	retal	r12
80008644:	80 01       	ld.sh	r1,r0[0x0]
80008646:	ad 20       	st.d	r6++,r0

80008648 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80008648:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000864c:	fe c0 e2 4c 	sub	r0,pc,-7604

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80008650:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80008654:	d5 53       	csrf	0x15
  cp      r0, r1
80008656:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80008658:	e0 61 74 98 	mov	r1,29848
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000865c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000865e:	c0 62       	brcc	8000866a <idata_load_loop_end>
  cp      r0, r1
80008660:	48 92       	lddpc	r2,80008684 <udata_clear_loop_end+0x4>

80008662 <idata_load_loop>:
  brlo    idata_load_loop
80008662:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80008664:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80008666:	02 30       	cp.w	r0,r1
  cp      r0, r1
80008668:	cf d3       	brcs	80008662 <idata_load_loop>

8000866a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000866a:	e0 60 74 98 	mov	r0,29848
  mov     r2, 0
  mov     r3, 0
8000866e:	e0 61 7f 40 	mov	r1,32576
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80008672:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80008674:	c0 62       	brcc	80008680 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80008676:	30 02       	mov	r2,0
80008678:	30 03       	mov	r3,0

8000867a <udata_clear_loop>:
8000867a:	a1 22       	st.d	r0++,r2
8000867c:	02 30       	cp.w	r0,r1
8000867e:	cf e3       	brcs	8000867a <udata_clear_loop>

80008680 <udata_clear_loop_end>:
80008680:	fe cf fe 38 	sub	pc,pc,-456
80008684:	80 01       	ld.sh	r1,r0[0x0]
80008686:	b1 68       	lsl	r8,0x10

80008688 <master_callback>:

	else if( arg == AUDIO_ADC_RELOAD_CB )
	{
		adc_reload_callback();;
	}
}
80008688:	5e fc       	retal	r12
8000868a:	d7 03       	nop

8000868c <RT_ISR_gpio_qt_71_not_naked>:
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
{
8000868c:	d4 01       	pushm	lr
	// ENTER, LEFT, RIGHT
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER))
8000868e:	33 ac       	mov	r12,58
80008690:	f0 1f 00 17 	mcall	800086ec <RT_ISR_gpio_qt_71_not_naked+0x60>
80008694:	c0 b0       	breq	800086aa <RT_ISR_gpio_qt_71_not_naked+0x1e>
	{
		INTC_QT_FLAG._enter = true;
80008696:	49 78       	lddpc	r8,800086f0 <RT_ISR_gpio_qt_71_not_naked+0x64>
80008698:	11 89       	ld.ub	r9,r8[0x0]
8000869a:	30 1a       	mov	r10,1
8000869c:	f3 da d0 e1 	bfins	r9,r10,0x7,0x1
800086a0:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER);
800086a2:	33 ac       	mov	r12,58
800086a4:	f0 1f 00 14 	mcall	800086f4 <RT_ISR_gpio_qt_71_not_naked+0x68>
800086a8:	c1 c8       	rjmp	800086e0 <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT))
800086aa:	33 9c       	mov	r12,57
800086ac:	f0 1f 00 10 	mcall	800086ec <RT_ISR_gpio_qt_71_not_naked+0x60>
800086b0:	c0 b0       	breq	800086c6 <RT_ISR_gpio_qt_71_not_naked+0x3a>
	{
		INTC_QT_FLAG._left = true;
800086b2:	49 08       	lddpc	r8,800086f0 <RT_ISR_gpio_qt_71_not_naked+0x64>
800086b4:	11 89       	ld.ub	r9,r8[0x0]
800086b6:	30 1a       	mov	r10,1
800086b8:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
800086bc:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT);
800086be:	33 9c       	mov	r12,57
800086c0:	f0 1f 00 0d 	mcall	800086f4 <RT_ISR_gpio_qt_71_not_naked+0x68>
800086c4:	c0 e8       	rjmp	800086e0 <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT))
800086c6:	33 8c       	mov	r12,56
800086c8:	f0 1f 00 09 	mcall	800086ec <RT_ISR_gpio_qt_71_not_naked+0x60>
800086cc:	c0 a0       	breq	800086e0 <RT_ISR_gpio_qt_71_not_naked+0x54>
	{
		INTC_QT_FLAG._right = true;
800086ce:	48 98       	lddpc	r8,800086f0 <RT_ISR_gpio_qt_71_not_naked+0x64>
800086d0:	11 89       	ld.ub	r9,r8[0x0]
800086d2:	30 1a       	mov	r10,1
800086d4:	f3 da d0 a1 	bfins	r9,r10,0x5,0x1
800086d8:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT);
800086da:	33 8c       	mov	r12,56
800086dc:	f0 1f 00 06 	mcall	800086f4 <RT_ISR_gpio_qt_71_not_naked+0x68>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
800086e0:	48 68       	lddpc	r8,800086f8 <RT_ISR_gpio_qt_71_not_naked+0x6c>
800086e2:	70 0c       	ld.w	r12,r8[0x0]
800086e4:	f0 1f 00 06 	mcall	800086fc <RT_ISR_gpio_qt_71_not_naked+0x70>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
800086e8:	5f 1c       	srne	r12
800086ea:	d8 02       	popm	pc
800086ec:	80 00       	ld.sh	r0,r0[0x0]
800086ee:	85 0a       	st.w	r2[0x0],r10
800086f0:	00 00       	add	r0,r0
800086f2:	7d 1c       	ld.w	r12,lr[0x44]
800086f4:	80 00       	ld.sh	r0,r0[0x0]
800086f6:	85 22       	st.w	r2[0x8],r2
800086f8:	00 00       	add	r0,r0
800086fa:	77 24       	ld.w	r4,r11[0x48]
800086fc:	80 00       	ld.sh	r0,r0[0x0]
800086fe:	7d 04       	ld.w	r4,lr[0x40]

80008700 <RT_ISR_gpio_qt_71>:

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
80008700:	eb cd 00 ff 	pushm	r0-r7
80008704:	e0 68 00 10 	mov	r8,16
80008708:	ea 18 00 00 	orh	r8,0x0
8000870c:	70 00       	ld.w	r0,r8[0x0]
8000870e:	1a d0       	st.w	--sp,r0
80008710:	7a 90       	ld.w	r0,sp[0x24]
80008712:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008716:	58 10       	cp.w	r0,1
80008718:	e0 8b 00 08 	brhi	80008728 <LABEL_ISR_SKIP_SAVE_CONTEXT_717>
8000871c:	e0 68 75 b0 	mov	r8,30128
80008720:	ea 18 00 00 	orh	r8,0x0
80008724:	70 00       	ld.w	r0,r8[0x0]
80008726:	81 0d       	st.w	r0[0x0],sp

80008728 <LABEL_ISR_SKIP_SAVE_CONTEXT_717>:
80008728:	f0 1f 00 10 	mcall	80008768 <LABEL_ISR_SKIP_RESTORE_CONTEXT_717+0x14>
8000872c:	7a 90       	ld.w	r0,sp[0x24]
8000872e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008732:	58 10       	cp.w	r0,1
80008734:	e0 8b 00 10 	brhi	80008754 <LABEL_ISR_SKIP_RESTORE_CONTEXT_717>
80008738:	58 1c       	cp.w	r12,1
8000873a:	c0 71       	brne	80008748 <LABEL_ISR_RESTORE_CONTEXT_717>
8000873c:	f0 1f 00 0c 	mcall	8000876c <LABEL_ISR_SKIP_RESTORE_CONTEXT_717+0x18>
80008740:	f0 1f 00 0c 	mcall	80008770 <LABEL_ISR_SKIP_RESTORE_CONTEXT_717+0x1c>
80008744:	f0 1f 00 0c 	mcall	80008774 <LABEL_ISR_SKIP_RESTORE_CONTEXT_717+0x20>

80008748 <LABEL_ISR_RESTORE_CONTEXT_717>:
80008748:	e0 68 75 b0 	mov	r8,30128
8000874c:	ea 18 00 00 	orh	r8,0x0
80008750:	70 00       	ld.w	r0,r8[0x0]
80008752:	60 0d       	ld.w	sp,r0[0x0]

80008754 <LABEL_ISR_SKIP_RESTORE_CONTEXT_717>:
80008754:	1b 00       	ld.w	r0,sp++
80008756:	e0 68 00 10 	mov	r8,16
8000875a:	ea 18 00 00 	orh	r8,0x0
8000875e:	91 00       	st.w	r8[0x0],r0
80008760:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008764:	d6 03       	rete
80008766:	00 00       	add	r0,r0
80008768:	80 00       	ld.sh	r0,r0[0x0]
8000876a:	86 8c       	ld.uh	r12,r3[0x0]
8000876c:	80 00       	ld.sh	r0,r0[0x0]
8000876e:	6e c8       	ld.w	r8,r7[0x30]
80008770:	80 00       	ld.sh	r0,r0[0x0]
80008772:	76 cc       	ld.w	r12,r11[0x30]
80008774:	80 00       	ld.sh	r0,r0[0x0]
80008776:	6f d4       	ld.w	r4,r7[0x74]

80008778 <RT_ISR_gpio_qt_70_not_naked>:
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
{
80008778:	d4 01       	pushm	lr
	// UP, DOWN
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP))
8000877a:	33 6c       	mov	r12,54
8000877c:	f0 1f 00 10 	mcall	800087bc <RT_ISR_gpio_qt_70_not_naked+0x44>
80008780:	c0 b0       	breq	80008796 <RT_ISR_gpio_qt_70_not_naked+0x1e>
	{
		INTC_QT_FLAG._up = true;
80008782:	49 08       	lddpc	r8,800087c0 <RT_ISR_gpio_qt_70_not_naked+0x48>
80008784:	11 89       	ld.ub	r9,r8[0x0]
80008786:	30 1a       	mov	r10,1
80008788:	f3 da d0 81 	bfins	r9,r10,0x4,0x1
8000878c:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP);
8000878e:	33 6c       	mov	r12,54
80008790:	f0 1f 00 0d 	mcall	800087c4 <RT_ISR_gpio_qt_70_not_naked+0x4c>
80008794:	c0 e8       	rjmp	800087b0 <RT_ISR_gpio_qt_70_not_naked+0x38>

	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN))
80008796:	33 7c       	mov	r12,55
80008798:	f0 1f 00 09 	mcall	800087bc <RT_ISR_gpio_qt_70_not_naked+0x44>
8000879c:	c0 a0       	breq	800087b0 <RT_ISR_gpio_qt_70_not_naked+0x38>
	{
		INTC_QT_FLAG._down = true;
8000879e:	48 98       	lddpc	r8,800087c0 <RT_ISR_gpio_qt_70_not_naked+0x48>
800087a0:	11 89       	ld.ub	r9,r8[0x0]
800087a2:	30 1a       	mov	r10,1
800087a4:	f3 da d0 61 	bfins	r9,r10,0x3,0x1
800087a8:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN);
800087aa:	33 7c       	mov	r12,55
800087ac:	f0 1f 00 06 	mcall	800087c4 <RT_ISR_gpio_qt_70_not_naked+0x4c>
	}

	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
800087b0:	48 68       	lddpc	r8,800087c8 <RT_ISR_gpio_qt_70_not_naked+0x50>
800087b2:	70 0c       	ld.w	r12,r8[0x0]
800087b4:	f0 1f 00 06 	mcall	800087cc <RT_ISR_gpio_qt_70_not_naked+0x54>
	return (checkIfYieldRequired ? 1 : 0);

	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
800087b8:	5f 1c       	srne	r12
800087ba:	d8 02       	popm	pc
800087bc:	80 00       	ld.sh	r0,r0[0x0]
800087be:	85 0a       	st.w	r2[0x0],r10
800087c0:	00 00       	add	r0,r0
800087c2:	7d 1c       	ld.w	r12,lr[0x44]
800087c4:	80 00       	ld.sh	r0,r0[0x0]
800087c6:	85 22       	st.w	r2[0x8],r2
800087c8:	00 00       	add	r0,r0
800087ca:	77 24       	ld.w	r4,r11[0x48]
800087cc:	80 00       	ld.sh	r0,r0[0x0]
800087ce:	7d 04       	ld.w	r4,lr[0x40]

800087d0 <RT_ISR_gpio_qt_70>:
		}
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
800087d0:	eb cd 00 ff 	pushm	r0-r7
800087d4:	e0 68 00 10 	mov	r8,16
800087d8:	ea 18 00 00 	orh	r8,0x0
800087dc:	70 00       	ld.w	r0,r8[0x0]
800087de:	1a d0       	st.w	--sp,r0
800087e0:	7a 90       	ld.w	r0,sp[0x24]
800087e2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800087e6:	58 10       	cp.w	r0,1
800087e8:	e0 8b 00 08 	brhi	800087f8 <LABEL_ISR_SKIP_SAVE_CONTEXT_696>
800087ec:	e0 68 75 b0 	mov	r8,30128
800087f0:	ea 18 00 00 	orh	r8,0x0
800087f4:	70 00       	ld.w	r0,r8[0x0]
800087f6:	81 0d       	st.w	r0[0x0],sp

800087f8 <LABEL_ISR_SKIP_SAVE_CONTEXT_696>:
800087f8:	f0 1f 00 10 	mcall	80008838 <LABEL_ISR_SKIP_RESTORE_CONTEXT_696+0x14>
800087fc:	7a 90       	ld.w	r0,sp[0x24]
800087fe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008802:	58 10       	cp.w	r0,1
80008804:	e0 8b 00 10 	brhi	80008824 <LABEL_ISR_SKIP_RESTORE_CONTEXT_696>
80008808:	58 1c       	cp.w	r12,1
8000880a:	c0 71       	brne	80008818 <LABEL_ISR_RESTORE_CONTEXT_696>
8000880c:	f0 1f 00 0c 	mcall	8000883c <LABEL_ISR_SKIP_RESTORE_CONTEXT_696+0x18>
80008810:	f0 1f 00 0c 	mcall	80008840 <LABEL_ISR_SKIP_RESTORE_CONTEXT_696+0x1c>
80008814:	f0 1f 00 0c 	mcall	80008844 <LABEL_ISR_SKIP_RESTORE_CONTEXT_696+0x20>

80008818 <LABEL_ISR_RESTORE_CONTEXT_696>:
80008818:	e0 68 75 b0 	mov	r8,30128
8000881c:	ea 18 00 00 	orh	r8,0x0
80008820:	70 00       	ld.w	r0,r8[0x0]
80008822:	60 0d       	ld.w	sp,r0[0x0]

80008824 <LABEL_ISR_SKIP_RESTORE_CONTEXT_696>:
80008824:	1b 00       	ld.w	r0,sp++
80008826:	e0 68 00 10 	mov	r8,16
8000882a:	ea 18 00 00 	orh	r8,0x0
8000882e:	91 00       	st.w	r8[0x0],r0
80008830:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008834:	d6 03       	rete
80008836:	00 00       	add	r0,r0
80008838:	80 00       	ld.sh	r0,r0[0x0]
8000883a:	87 78       	st.w	r3[0x1c],r8
8000883c:	80 00       	ld.sh	r0,r0[0x0]
8000883e:	6e c8       	ld.w	r8,r7[0x30]
80008840:	80 00       	ld.sh	r0,r0[0x0]
80008842:	76 cc       	ld.w	r12,r11[0x30]
80008844:	80 00       	ld.sh	r0,r0[0x0]
80008846:	6f d4       	ld.w	r4,r7[0x74]

80008848 <main>:
	sdramc_init(PBA_HZ);
	print_dbg("SDRAM initialized\r\n");
}

int main (void)
{
80008848:	eb cd 40 c0 	pushm	r6-r7,lr
8000884c:	21 0d       	sub	sp,64
/*! \brief Static function definitions
 */
static void init_sys_clocks(void)
{
  // Switch to OSC0 to speed up the booting
  pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
8000884e:	30 3a       	mov	r10,3
80008850:	e0 6b 1b 00 	mov	r11,6912
80008854:	ea 1b 00 b7 	orh	r11,0xb7
80008858:	fe 7c 0c 00 	mov	r12,-62464
8000885c:	f0 1f 00 a5 	mcall	80008af0 <main+0x2a8>

  // Start oscillator1
  pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
80008860:	e0 6b 44 00 	mov	r11,17408
80008864:	ea 1b 00 ac 	orh	r11,0xac
80008868:	fe 7c 0c 00 	mov	r12,-62464
8000886c:	f0 1f 00 a2 	mcall	80008af4 <main+0x2ac>
  pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
80008870:	30 3b       	mov	r11,3
80008872:	fe 7c 0c 00 	mov	r12,-62464
80008876:	f0 1f 00 a1 	mcall	80008af8 <main+0x2b0>

  // Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
  // We use OSC1 since we need a correct master clock for the SSC module to generate
  //
  pm_pll_setup(&AVR32_PM, 0,  // pll.
8000887a:	31 06       	mov	r6,16
8000887c:	1a d6       	st.w	--sp,r6
8000887e:	30 18       	mov	r8,1
80008880:	10 99       	mov	r9,r8
80008882:	30 aa       	mov	r10,10
80008884:	30 0b       	mov	r11,0
80008886:	fe 7c 0c 00 	mov	r12,-62464
8000888a:	f0 1f 00 9d 	mcall	80008afc <main+0x2b4>
    1,   // osc.
    16); // lockcount.

  // Set PLL operating range and divider (fpll = fvco/2)
  // -> PLL0 output = 62.0928 MHz
  pm_pll_set_option(&AVR32_PM, 0, // pll.
8000888e:	30 08       	mov	r8,0
80008890:	30 19       	mov	r9,1
80008892:	12 9a       	mov	r10,r9
80008894:	10 9b       	mov	r11,r8
80008896:	fe 7c 0c 00 	mov	r12,-62464
8000889a:	f0 1f 00 9a 	mcall	80008b00 <main+0x2b8>
    1,  // pll_freq.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL0 and wait for the lock
  pm_pll_enable(&AVR32_PM, 0);
8000889e:	30 0b       	mov	r11,0
800088a0:	fe 7c 0c 00 	mov	r12,-62464
800088a4:	f0 1f 00 98 	mcall	80008b04 <main+0x2bc>
  pm_wait_for_pll0_locked(&AVR32_PM);
800088a8:	fe 7c 0c 00 	mov	r12,-62464
800088ac:	f0 1f 00 97 	mcall	80008b08 <main+0x2c0>
  // Set all peripheral clocks torun at master clock rate
  pm_cksel(&AVR32_PM,
800088b0:	30 07       	mov	r7,0
800088b2:	1a d7       	st.w	--sp,r7
800088b4:	1a d7       	st.w	--sp,r7
800088b6:	0e 98       	mov	r8,r7
800088b8:	0e 99       	mov	r9,r7
800088ba:	0e 9a       	mov	r10,r7
800088bc:	0e 9b       	mov	r11,r7
800088be:	fe 7c 0c 00 	mov	r12,-62464
800088c2:	f0 1f 00 93 	mcall	80008b0c <main+0x2c4>
    0,   // pbbsel.
    0,   // hsbdiv.
    0);  // hsbsel.

  // Set one waitstate for the flash
  flashc_set_wait_state(1);
800088c6:	30 1c       	mov	r12,1
800088c8:	f0 1f 00 92 	mcall	80008b10 <main+0x2c8>

  // Switch to PLL0 as the master clock
  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
800088cc:	30 2b       	mov	r11,2
800088ce:	fe 7c 0c 00 	mov	r12,-62464
800088d2:	f0 1f 00 91 	mcall	80008b14 <main+0x2cc>

  // Use 12MHz from OSC0 and generate 96 MHz
  pm_pll_setup(&AVR32_PM, 1,  // pll.
800088d6:	1a d6       	st.w	--sp,r6
800088d8:	0e 98       	mov	r8,r7
800088da:	30 19       	mov	r9,1
800088dc:	30 7a       	mov	r10,7
800088de:	12 9b       	mov	r11,r9
800088e0:	fe 7c 0c 00 	mov	r12,-62464
800088e4:	f0 1f 00 86 	mcall	80008afc <main+0x2b4>
    7,   // mul.
    1,   // div.
    0,   // osc.
    16); // lockcount.

  pm_pll_set_option(&AVR32_PM, 1, // pll.
800088e8:	0e 98       	mov	r8,r7
800088ea:	30 19       	mov	r9,1
800088ec:	12 9a       	mov	r10,r9
800088ee:	12 9b       	mov	r11,r9
800088f0:	fe 7c 0c 00 	mov	r12,-62464
800088f4:	f0 1f 00 83 	mcall	80008b00 <main+0x2b8>
    1,  // pll_freq: choose the range 80-180MHz.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL1 and wait forl lock
  pm_pll_enable(&AVR32_PM, 1);
800088f8:	30 1b       	mov	r11,1
800088fa:	fe 7c 0c 00 	mov	r12,-62464
800088fe:	f0 1f 00 82 	mcall	80008b04 <main+0x2bc>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(&AVR32_PM);
80008902:	fe 7c 0c 00 	mov	r12,-62464
80008906:	f0 1f 00 85 	mcall	80008b18 <main+0x2d0>
{
	/* Insert system clock initialization code here (sysclk_init()). */
	init_sys_clocks();

	/* Initialize RS232 debug text output. */
	init_dbg_rs232(PBA_HZ); /**/
8000890a:	e0 6c 76 00 	mov	r12,30208
8000890e:	ea 1c 03 b3 	orh	r12,0x3b3
80008912:	f0 1f 00 83 	mcall	80008b1c <main+0x2d4>
}

static void init_tft_bl(void)
{
	avr32_pwm_channel_t pwm_channel6;
	pwm_channel6.cdty = 0;
80008916:	50 57       	stdsp	sp[0x14],r7
	pwm_channel6.cprd = 100;
80008918:	36 48       	mov	r8,100
8000891a:	50 68       	stdsp	sp[0x18],r8

	et024006_Init(PBA_HZ, PBA_HZ);
8000891c:	e0 6b 76 00 	mov	r11,30208
80008920:	ea 1b 03 b3 	orh	r11,0x3b3
80008924:	16 9c       	mov	r12,r11
80008926:	f0 1f 00 7f 	mcall	80008b20 <main+0x2d8>

	pwm_opt_t opt;
	opt.diva = 0;
8000892a:	51 17       	stdsp	sp[0x44],r7
	opt.divb = 0;
8000892c:	51 07       	stdsp	sp[0x40],r7
	opt.prea = 0;
8000892e:	51 37       	stdsp	sp[0x4c],r7
	opt.preb = 0;
80008930:	51 27       	stdsp	sp[0x48],r7

	pwm_init(&opt);
80008932:	fa cc ff c0 	sub	r12,sp,-64
80008936:	f0 1f 00 7c 	mcall	80008b24 <main+0x2dc>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
8000893a:	40 48       	lddsp	r8,sp[0x10]
8000893c:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
80008940:	a9 b8       	sbr	r8,0x9
80008942:	30 19       	mov	r9,1
80008944:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
80008948:	50 48       	stdsp	sp[0x10],r8

	pwm_channel_init(6, &pwm_channel6);
8000894a:	fa 06 00 0b 	add	r11,sp,r6
8000894e:	30 6c       	mov	r12,6
80008950:	f0 1f 00 76 	mcall	80008b28 <main+0x2e0>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
80008954:	34 0c       	mov	r12,64
80008956:	f0 1f 00 76 	mcall	80008b2c <main+0x2e4>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
8000895a:	e0 68 ff ff 	mov	r8,65535
8000895e:	e0 69 00 f0 	mov	r9,240
80008962:	e0 6a 01 40 	mov	r10,320
80008966:	0e 9b       	mov	r11,r7
80008968:	0e 9c       	mov	r12,r7
8000896a:	f0 1f 00 72 	mcall	80008b30 <main+0x2e8>
8000896e:	0c 0d       	add	sp,r6
	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80008970:	30 67       	mov	r7,6
80008972:	c1 e8       	rjmp	800089ae <main+0x166>

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
80008974:	2f f8       	sub	r8,-1
80008976:	50 18       	stdsp	sp[0x4],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
80008978:	50 48       	stdsp	sp[0x10],r8
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
8000897a:	1a 9b       	mov	r11,sp
8000897c:	0e 9c       	mov	r12,r7
8000897e:	f0 1f 00 6e 	mcall	80008b34 <main+0x2ec>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80008982:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80008986:	e0 79 d4 c0 	mov	r9,120000
8000898a:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000898e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80008992:	14 38       	cp.w	r8,r10
80008994:	e0 88 00 08 	brls	800089a4 <main+0x15c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80008998:	12 38       	cp.w	r8,r9
8000899a:	fe 98 ff fa 	brls	8000898e <main+0x146>
8000899e:	12 3a       	cp.w	r10,r9
800089a0:	c0 73       	brcs	800089ae <main+0x166>
800089a2:	cf 6b       	rjmp	8000898e <main+0x146>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800089a4:	12 38       	cp.w	r8,r9
800089a6:	e0 8b 00 04 	brhi	800089ae <main+0x166>
800089aa:	12 3a       	cp.w	r10,r9
800089ac:	cf 12       	brcc	8000898e <main+0x146>
	pwm_channel_init(6, &pwm_channel6);
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);

	et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);

	while(pwm_channel6.cdty < pwm_channel6.cprd)
800089ae:	40 18       	lddsp	r8,sp[0x4]
800089b0:	40 29       	lddsp	r9,sp[0x8]
800089b2:	12 38       	cp.w	r8,r9
800089b4:	ce 03       	brcs	80008974 <main+0x12c>
	/* TWI */
	const gpio_map_t TPA6130_TWI_GPIO_MAP =
	{
		{TPA6130_TWI_SCL_PIN, TPA6130_TWI_SCL_FUNCTION},
		{TPA6130_TWI_SDA_PIN, TPA6130_TWI_SDA_FUNCTION}
	};
800089b6:	4e 18       	lddpc	r8,80008b38 <main+0x2f0>
800089b8:	fa cc ff e0 	sub	r12,sp,-32
800089bc:	f0 ea 00 00 	ld.d	r10,r8[0]
800089c0:	f8 eb 00 00 	st.d	r12[0],r10
800089c4:	f0 e8 00 08 	ld.d	r8,r8[8]
800089c8:	f8 e9 00 08 	st.d	r12[8],r8
	const twi_options_t TPA6130_TWI_OPTIONS =
	{
		.pba_hz = PBA_HZ,
		.speed  = TPA6130_TWI_MASTER_SPEED,
		.chip   = TPA6130_TWI_ADDRESS
	};
800089cc:	4d c8       	lddpc	r8,80008b3c <main+0x2f4>
800089ce:	fa c7 ff d0 	sub	r7,sp,-48
800089d2:	f0 ea 00 00 	ld.d	r10,r8[0]
800089d6:	ee eb 00 00 	st.d	r7[0],r10
800089da:	70 28       	ld.w	r8,r8[0x8]
800089dc:	8f 28       	st.w	r7[0x8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(TPA6130_TWI_GPIO_MAP,
800089de:	30 2b       	mov	r11,2
800089e0:	f0 1f 00 58 	mcall	80008b40 <main+0x2f8>
	sizeof(TPA6130_TWI_GPIO_MAP) / sizeof(TPA6130_TWI_GPIO_MAP[0]));

	// Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
800089e4:	0e 9b       	mov	r11,r7
800089e6:	fe 7c 2c 00 	mov	r12,-54272
800089ea:	f0 1f 00 57 	mcall	80008b44 <main+0x2fc>

	/* TWA */
	tpa6130_init();
800089ee:	f0 1f 00 57 	mcall	80008b48 <main+0x300>

	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,
800089f2:	e0 67 76 00 	mov	r7,30208
800089f6:	ea 17 03 b3 	orh	r7,0x3b3
800089fa:	1a d7       	st.w	--sp,r7
800089fc:	30 38       	mov	r8,3
800089fe:	1a d8       	st.w	--sp,r8
80008a00:	4d 38       	lddpc	r8,80008b4c <main+0x304>
80008a02:	30 09       	mov	r9,0
80008a04:	31 0a       	mov	r10,16
80008a06:	30 2b       	mov	r11,2
80008a08:	e0 6c 2b 11 	mov	r12,11025
80008a0c:	f0 1f 00 51 	mcall	80008b50 <main+0x308>
						master_callback,
						AUDIO_DAC_OUT_OF_SAMPLE_CB
						| AUDIO_DAC_RELOAD_CB,
						PBA_HZ); /**/

	tpa6130_set_volume(0x35); // 2F
80008a10:	33 5c       	mov	r12,53
80008a12:	f0 1f 00 51 	mcall	80008b54 <main+0x30c>
	tpa6130_get_volume();
80008a16:	f0 1f 00 51 	mcall	80008b58 <main+0x310>

	init_tft_bl();

	init_twi_tpa();

	sd_mmc_resources_init();
80008a1a:	f0 1f 00 51 	mcall	80008b5c <main+0x314>
	check_sd_card();
80008a1e:	f0 1f 00 51 	mcall	80008b60 <main+0x318>
	et024006_PrintString("****** INIT SD/MMC ******",(const unsigned char*)&FONT8x8,10,10,BLUE,-1);
80008a22:	3f f8       	mov	r8,-1
80008a24:	1a d8       	st.w	--sp,r8
80008a26:	31 f8       	mov	r8,31
80008a28:	30 a9       	mov	r9,10
80008a2a:	12 9a       	mov	r10,r9
80008a2c:	4c eb       	lddpc	r11,80008b64 <main+0x31c>
80008a2e:	4c fc       	lddpc	r12,80008b68 <main+0x320>
80008a30:	f0 1f 00 4f 	mcall	80008b6c <main+0x324>
}

static void init_qt_interrupt(void)
{
	/* INTC */
	Disable_global_interrupt();
80008a34:	d3 03       	ssrf	0x10
	//INTC_init_interrupts();
	// QT
	INTC_register_interrupt(&RT_ISR_gpio_qt_70, 70, AVR32_INTC_INT0);
80008a36:	30 0a       	mov	r10,0
80008a38:	34 6b       	mov	r11,70
80008a3a:	4c ec       	lddpc	r12,80008b70 <main+0x328>
80008a3c:	f0 1f 00 4e 	mcall	80008b74 <main+0x32c>
	INTC_register_interrupt(&RT_ISR_gpio_qt_71, 71, AVR32_INTC_INT0);
80008a40:	30 0a       	mov	r10,0
80008a42:	34 7b       	mov	r11,71
80008a44:	4c dc       	lddpc	r12,80008b78 <main+0x330>
80008a46:	f0 1f 00 4c 	mcall	80008b74 <main+0x32c>
	Enable_global_interrupt();
80008a4a:	d5 03       	csrf	0x10

	/* GPIO */
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_UP,    GPIO_RISING_EDGE);
80008a4c:	30 1b       	mov	r11,1
80008a4e:	33 6c       	mov	r12,54
80008a50:	f0 1f 00 4b 	mcall	80008b7c <main+0x334>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_DOWN,  GPIO_RISING_EDGE);
80008a54:	30 1b       	mov	r11,1
80008a56:	33 7c       	mov	r12,55
80008a58:	f0 1f 00 49 	mcall	80008b7c <main+0x334>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_LEFT,  GPIO_RISING_EDGE);
80008a5c:	30 1b       	mov	r11,1
80008a5e:	33 9c       	mov	r12,57
80008a60:	f0 1f 00 47 	mcall	80008b7c <main+0x334>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_RIGHT, GPIO_RISING_EDGE);
80008a64:	30 1b       	mov	r11,1
80008a66:	33 8c       	mov	r12,56
80008a68:	f0 1f 00 45 	mcall	80008b7c <main+0x334>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_ENTER, GPIO_RISING_EDGE);
80008a6c:	30 1b       	mov	r11,1
80008a6e:	33 ac       	mov	r12,58
80008a70:	f0 1f 00 43 	mcall	80008b7c <main+0x334>

	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
80008a74:	30 09       	mov	r9,0
80008a76:	4c 38       	lddpc	r8,80008b80 <main+0x338>
80008a78:	b0 89       	st.b	r8[0x0],r9
}

static void init_sdram(void)
{
	// Initialize the external SDRAM chip.
	sdramc_init(PBA_HZ);
80008a7a:	0e 9c       	mov	r12,r7
80008a7c:	f0 1f 00 42 	mcall	80008b84 <main+0x33c>
	print_dbg("SDRAM initialized\r\n");
80008a80:	4c 2c       	lddpc	r12,80008b88 <main+0x340>
80008a82:	f0 1f 00 43 	mcall	80008b8c <main+0x344>
	//init_fs();
	
	init_sdram();

	// Enable LED0 and LED1
	gpio_enable_gpio_pin(LED0_GPIO);
80008a86:	33 bc       	mov	r12,59
80008a88:	f0 1f 00 42 	mcall	80008b90 <main+0x348>
	gpio_enable_gpio_pin(LED1_GPIO);
80008a8c:	33 cc       	mov	r12,60
80008a8e:	f0 1f 00 41 	mcall	80008b90 <main+0x348>

	print_dbg(MSG_WELCOME);
80008a92:	4c 1c       	lddpc	r12,80008b94 <main+0x34c>
80008a94:	f0 1f 00 3e 	mcall	80008b8c <main+0x344>

	/* Insert application code here, after the board has been initialized. */

	//uint16_t pass = 25;
	//xTaskCreate(myTask1, "taks1", 256, (void *)pass, mainLED_TASK_PRIORITY, &myTask1Handle);
	xTaskCreate(qtButtonTask,  "tQT",        256,  (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
80008a98:	4c 08       	lddpc	r8,80008b98 <main+0x350>
80008a9a:	1a d8       	st.w	--sp,r8
80008a9c:	30 28       	mov	r8,2
80008a9e:	30 09       	mov	r9,0
80008aa0:	e0 6a 01 00 	mov	r10,256
80008aa4:	4b eb       	lddpc	r11,80008b9c <main+0x354>
80008aa6:	4b fc       	lddpc	r12,80008ba0 <main+0x358>
80008aa8:	f0 1f 00 3f 	mcall	80008ba4 <main+0x35c>
	xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
80008aac:	4b f8       	lddpc	r8,80008ba8 <main+0x360>
80008aae:	1a d8       	st.w	--sp,r8
80008ab0:	30 18       	mov	r8,1
80008ab2:	30 09       	mov	r9,0
80008ab4:	e0 6a 08 00 	mov	r10,2048
80008ab8:	4b db       	lddpc	r11,80008bac <main+0x364>
80008aba:	4b ec       	lddpc	r12,80008bb0 <main+0x368>
80008abc:	f0 1f 00 3a 	mcall	80008ba4 <main+0x35c>
	xTaskCreate(fsTask,		   "tFS",		 512,  (void *) 0, mainLED_TASK_PRIORITY, &fsHandle);
80008ac0:	4b d8       	lddpc	r8,80008bb4 <main+0x36c>
80008ac2:	1a d8       	st.w	--sp,r8
80008ac4:	30 18       	mov	r8,1
80008ac6:	30 09       	mov	r9,0
80008ac8:	e0 6a 02 00 	mov	r10,512
80008acc:	4b bb       	lddpc	r11,80008bb8 <main+0x370>
80008ace:	4b cc       	lddpc	r12,80008bbc <main+0x374>
80008ad0:	f0 1f 00 35 	mcall	80008ba4 <main+0x35c>
	xTaskCreate(etTask,		   "tET",		 512,  (void *) 0, mainLED_TASK_PRIORITY, &etHandle);
80008ad4:	4b b8       	lddpc	r8,80008bc0 <main+0x378>
80008ad6:	1a d8       	st.w	--sp,r8
80008ad8:	30 18       	mov	r8,1
80008ada:	30 09       	mov	r9,0
80008adc:	e0 6a 02 00 	mov	r10,512
80008ae0:	4b 9b       	lddpc	r11,80008bc4 <main+0x37c>
80008ae2:	4b ac       	lddpc	r12,80008bc8 <main+0x380>
80008ae4:	f0 1f 00 30 	mcall	80008ba4 <main+0x35c>
	//xTaskCreate(sdramTask,     "tSDRAM",	 256,  (void *) 0, mainLED_TASK_PRIORITY, &sdramHandle);
	
	vTaskStartScheduler();
80008ae8:	f0 1f 00 39 	mcall	80008bcc <main+0x384>
80008aec:	2f 9d       	sub	sp,-28
80008aee:	c0 08       	rjmp	80008aee <main+0x2a6>
80008af0:	80 00       	ld.sh	r0,r0[0x0]
80008af2:	6b c8       	ld.w	r8,r5[0x70]
80008af4:	80 00       	ld.sh	r0,r0[0x0]
80008af6:	6a a4       	ld.w	r4,r5[0x28]
80008af8:	80 00       	ld.sh	r0,r0[0x0]
80008afa:	6a fc       	ld.w	r12,r5[0x3c]
80008afc:	80 00       	ld.sh	r0,r0[0x0]
80008afe:	6b 5e       	ld.w	lr,r5[0x54]
80008b00:	80 00       	ld.sh	r0,r0[0x0]
80008b02:	6b 80       	ld.w	r0,r5[0x60]
80008b04:	80 00       	ld.sh	r0,r0[0x0]
80008b06:	6b 9a       	ld.w	r10,r5[0x64]
80008b08:	80 00       	ld.sh	r0,r0[0x0]
80008b0a:	6b a8       	ld.w	r8,r5[0x68]
80008b0c:	80 00       	ld.sh	r0,r0[0x0]
80008b0e:	6b 18       	ld.w	r8,r5[0x44]
80008b10:	80 00       	ld.sh	r0,r0[0x0]
80008b12:	6a 0c       	ld.w	r12,r5[0x0]
80008b14:	80 00       	ld.sh	r0,r0[0x0]
80008b16:	6b bc       	ld.w	r12,r5[0x6c]
80008b18:	80 00       	ld.sh	r0,r0[0x0]
80008b1a:	6b b2       	ld.w	r2,r5[0x6c]
80008b1c:	80 00       	ld.sh	r0,r0[0x0]
80008b1e:	69 f8       	ld.w	r8,r4[0x7c]
80008b20:	80 00       	ld.sh	r0,r0[0x0]
80008b22:	25 1c       	sub	r12,81
80008b24:	80 00       	ld.sh	r0,r0[0x0]
80008b26:	39 d8       	mov	r8,-99
80008b28:	80 00       	ld.sh	r0,r0[0x0]
80008b2a:	39 68       	mov	r8,-106
80008b2c:	80 00       	ld.sh	r0,r0[0x0]
80008b2e:	39 9e       	mov	lr,-103
80008b30:	80 00       	ld.sh	r0,r0[0x0]
80008b32:	23 28       	sub	r8,50
80008b34:	80 00       	ld.sh	r0,r0[0x0]
80008b36:	39 b0       	mov	r0,-101
80008b38:	80 01       	ld.sh	r1,r0[0x0]
80008b3a:	b0 e4       	st.b	r8[0x6],r4
80008b3c:	80 01       	ld.sh	r1,r0[0x0]
80008b3e:	b0 f4       	st.b	r8[0x7],r4
80008b40:	80 00       	ld.sh	r0,r0[0x0]
80008b42:	84 1c       	ld.sh	r12,r2[0x2]
80008b44:	80 00       	ld.sh	r0,r0[0x0]
80008b46:	68 34       	ld.w	r4,r4[0xc]
80008b48:	80 00       	ld.sh	r0,r0[0x0]
80008b4a:	60 34       	ld.w	r4,r0[0xc]
80008b4c:	80 00       	ld.sh	r0,r0[0x0]
80008b4e:	86 88       	ld.uh	r8,r3[0x0]
80008b50:	80 00       	ld.sh	r0,r0[0x0]
80008b52:	61 1c       	ld.w	r12,r0[0x44]
80008b54:	80 00       	ld.sh	r0,r0[0x0]
80008b56:	5e c0       	retvs	r0
80008b58:	80 00       	ld.sh	r0,r0[0x0]
80008b5a:	5f 9c       	srgt	r12
80008b5c:	80 00       	ld.sh	r0,r0[0x0]
80008b5e:	5d 90       	*unknown*
80008b60:	80 00       	ld.sh	r0,r0[0x0]
80008b62:	5d 28       	mustr	r8
80008b64:	80 00       	ld.sh	r0,r0[0x0]
80008b66:	ac 10       	st.h	r6[0x2],r0
80008b68:	80 01       	ld.sh	r1,r0[0x0]
80008b6a:	ad c0       	cbr	r0,0xc
80008b6c:	80 00       	ld.sh	r0,r0[0x0]
80008b6e:	20 ac       	sub	r12,10
80008b70:	80 00       	ld.sh	r0,r0[0x0]
80008b72:	87 d0       	st.w	r3[0x34],r0
80008b74:	80 00       	ld.sh	r0,r0[0x0]
80008b76:	85 3c       	st.w	r2[0xc],r12
80008b78:	80 00       	ld.sh	r0,r0[0x0]
80008b7a:	87 00       	st.w	r3[0x0],r0
80008b7c:	80 00       	ld.sh	r0,r0[0x0]
80008b7e:	84 c4       	ld.uh	r4,r2[0x8]
80008b80:	00 00       	add	r0,r0
80008b82:	7d 1c       	ld.w	r12,lr[0x44]
80008b84:	80 00       	ld.sh	r0,r0[0x0]
80008b86:	36 e0       	mov	r0,110
80008b88:	80 01       	ld.sh	r1,r0[0x0]
80008b8a:	ad dc       	cbr	r12,0xd
80008b8c:	80 00       	ld.sh	r0,r0[0x0]
80008b8e:	69 a4       	ld.w	r4,r4[0x68]
80008b90:	80 00       	ld.sh	r0,r0[0x0]
80008b92:	84 4c       	ld.sh	r12,r2[0x8]
80008b94:	80 01       	ld.sh	r1,r0[0x0]
80008b96:	ad f0       	*unknown*
80008b98:	00 00       	add	r0,r0
80008b9a:	77 24       	ld.w	r4,r11[0x48]
80008b9c:	80 01       	ld.sh	r1,r0[0x0]
80008b9e:	ae 2c       	st.h	r7[0x4],r12
80008ba0:	80 00       	ld.sh	r0,r0[0x0]
80008ba2:	95 14       	st.w	r10[0x4],r4
80008ba4:	80 00       	ld.sh	r0,r0[0x0]
80008ba6:	80 c8       	ld.uh	r8,r0[0x8]
80008ba8:	00 00       	add	r0,r0
80008baa:	77 20       	ld.w	r0,r11[0x48]
80008bac:	80 01       	ld.sh	r1,r0[0x0]
80008bae:	ae 30       	st.h	r7[0x6],r0
80008bb0:	80 00       	ld.sh	r0,r0[0x0]
80008bb2:	97 f0       	st.w	r11[0x3c],r0
80008bb4:	00 00       	add	r0,r0
80008bb6:	77 6c       	ld.w	r12,r11[0x58]
80008bb8:	80 01       	ld.sh	r1,r0[0x0]
80008bba:	ae 3c       	st.h	r7[0x6],r12
80008bbc:	80 00       	ld.sh	r0,r0[0x0]
80008bbe:	92 e0       	ld.uh	r0,r9[0xc]
80008bc0:	00 00       	add	r0,r0
80008bc2:	77 30       	ld.w	r0,r11[0x4c]
80008bc4:	80 01       	ld.sh	r1,r0[0x0]
80008bc6:	ae 40       	st.h	r7[0x8],r0
80008bc8:	80 00       	ld.sh	r0,r0[0x0]
80008bca:	8b d0       	st.w	r5[0x34],r0
80008bcc:	80 00       	ld.sh	r0,r0[0x0]
80008bce:	82 b4       	ld.uh	r4,r1[0x6]

80008bd0 <etTask>:
}

// ethHandle
portTASK_FUNCTION_PROTO( etTask, p );
portTASK_FUNCTION( etTask, p )
{
80008bd0:	d4 31       	pushm	r0-r7,lr
80008bd2:	20 2d       	sub	sp,8
	while (1)
	{
		switch(state)
80008bd4:	fe f3 06 68 	ld.w	r3,pc[1640]
			print_dbg("Received for REP UD");
			print_dbg_ulong(keys.ud);
		}
	}

	if (first_time || init)
80008bd8:	fe f2 06 68 	ld.w	r2,pc[1640]
80008bdc:	30 07       	mov	r7,0
		et024006_PutPixmap(atrasarblanco, 50, 0, 0, 10, 190, 50, 50);
		et024006_PutPixmap(play, 50, 0, 0, 135, 190, 50, 50);
		et024006_PutPixmap(adelantar, 50, 0, 0, 260, 190, 50, 50);
	}

	if (keys.ud == 0 && keys.lr == 0){
80008bde:	fe f4 06 66 	ld.w	r4,pc[1638]
		}
	}
	
	if (repUdQueue != 0)
	{
		if (xQueueReceive( repUdQueue, &keys.ud, (TickType_t) 2 ))
80008be2:	e8 c8 ff ff 	sub	r8,r4,-1
80008be6:	50 08       	stdsp	sp[0x0],r8
		et024006_PutPixmap(takeonme, 70, 0, 0, 190, 140, 70, 70);
		et024006_PrintString("dur: 4:36", (const unsigned char*) &FONT8x8, 190, 220, WHITE, -1);
		
	}
	
	if (keys.ud == 0 && keys.lr == 0){
80008be8:	fe f6 06 60 	ld.w	r6,pc[1632]
		}
	}
	
	if (mainUdQueue != 0)
	{
		if (xQueueReceive( mainUdQueue, &keys.ud, (TickType_t) 2 ))
80008bec:	ec c8 ff ff 	sub	r8,r6,-1
80008bf0:	50 18       	stdsp	sp[0x4],r8
portTASK_FUNCTION_PROTO( etTask, p );
portTASK_FUNCTION( etTask, p )
{
	while (1)
	{
		switch(state)
80008bf2:	66 08       	ld.w	r8,r3[0x0]
80008bf4:	58 18       	cp.w	r8,1
80008bf6:	e0 80 01 a9 	breq	80008f48 <etTask+0x378>
80008bfa:	c0 43       	brcs	80008c02 <etTask+0x32>
80008bfc:	58 38       	cp.w	r8,3
80008bfe:	e0 88 03 19 	brls	80009230 <etTask+0x660>
static void menu_gui(bool init)
{
	static bool first_time = true;
	static menu_keys_t keys;
	
	if (mainLrQueue != 0)
80008c02:	fe f8 06 4a 	ld.w	r8,pc[1610]
80008c06:	70 0c       	ld.w	r12,r8[0x0]
80008c08:	58 0c       	cp.w	r12,0
80008c0a:	c0 d0       	breq	80008c24 <etTask+0x54>
	{
		if (xQueueReceive( mainLrQueue, &keys.lr, (TickType_t) 2 ))
80008c0c:	30 2a       	mov	r10,2
80008c0e:	0c 9b       	mov	r11,r6
80008c10:	f0 1f 01 90 	mcall	80009250 <etTask+0x680>
80008c14:	c0 80       	breq	80008c24 <etTask+0x54>
		{
			print_dbg("Received for MAIN LR");
80008c16:	fe fc 06 3e 	ld.w	r12,pc[1598]
80008c1a:	f0 1f 01 90 	mcall	80009258 <etTask+0x688>
			print_dbg_ulong(keys.lr);
80008c1e:	0d 8c       	ld.ub	r12,r6[0x0]
80008c20:	f0 1f 01 8f 	mcall	8000925c <etTask+0x68c>
		}
	}
	
	if (mainUdQueue != 0)
80008c24:	fe f8 06 3c 	ld.w	r8,pc[1596]
80008c28:	70 0c       	ld.w	r12,r8[0x0]
80008c2a:	58 0c       	cp.w	r12,0
80008c2c:	c0 d0       	breq	80008c46 <etTask+0x76>
	{
		if (xQueueReceive( mainUdQueue, &keys.ud, (TickType_t) 2 ))
80008c2e:	30 2a       	mov	r10,2
80008c30:	40 1b       	lddsp	r11,sp[0x4]
80008c32:	f0 1f 01 88 	mcall	80009250 <etTask+0x680>
80008c36:	c0 80       	breq	80008c46 <etTask+0x76>
		{
			print_dbg("Received for MAIN UD");
80008c38:	fe fc 06 2c 	ld.w	r12,pc[1580]
80008c3c:	f0 1f 01 87 	mcall	80009258 <etTask+0x688>
			print_dbg_ulong(keys.ud);
80008c40:	0d 9c       	ld.ub	r12,r6[0x1]
80008c42:	f0 1f 01 87 	mcall	8000925c <etTask+0x68c>
		}
	}
	
	if (first_time || init)
80008c46:	fe f8 06 22 	ld.w	r8,pc[1570]
80008c4a:	11 88       	ld.ub	r8,r8[0x0]
80008c4c:	ee 08 18 00 	cp.b	r8,r7
80008c50:	e0 80 00 94 	breq	80008d78 <etTask+0x1a8>
	{
		first_time = false;
80008c54:	fe f8 06 14 	ld.w	r8,pc[1556]
80008c58:	b0 87       	st.b	r8[0x0],r7
		et024006_DrawFilledRect(0, 0, 320, 240, BLACK);
80008c5a:	30 08       	mov	r8,0
80008c5c:	e0 69 00 f0 	mov	r9,240
80008c60:	e0 6a 01 40 	mov	r10,320
80008c64:	10 9b       	mov	r11,r8
80008c66:	10 9c       	mov	r12,r8
80008c68:	f0 1f 01 81 	mcall	8000926c <etTask+0x69c>
		et024006_DrawVertLine(160,0,120,WHITE);
80008c6c:	e0 69 ff ff 	mov	r9,65535
80008c70:	37 8a       	mov	r10,120
80008c72:	30 0b       	mov	r11,0
80008c74:	e0 6c 00 a0 	mov	r12,160
80008c78:	f0 1f 01 7e 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawVertLine(160,120,120,WHITE);
80008c7c:	e0 69 ff ff 	mov	r9,65535
80008c80:	37 8a       	mov	r10,120
80008c82:	14 9b       	mov	r11,r10
80008c84:	e0 6c 00 a0 	mov	r12,160
80008c88:	f0 1f 01 7a 	mcall	80009270 <etTask+0x6a0>
	
		et024006_DrawHorizLine(0,120,160,WHITE);
80008c8c:	e0 69 ff ff 	mov	r9,65535
80008c90:	e0 6a 00 a0 	mov	r10,160
80008c94:	37 8b       	mov	r11,120
80008c96:	30 0c       	mov	r12,0
80008c98:	f0 1f 01 77 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawHorizLine(160,120,160,WHITE);
80008c9c:	e0 69 ff ff 	mov	r9,65535
80008ca0:	e0 6a 00 a0 	mov	r10,160
80008ca4:	37 8b       	mov	r11,120
80008ca6:	14 9c       	mov	r12,r10
80008ca8:	f0 1f 01 73 	mcall	80009274 <etTask+0x6a4>
	
	
		et024006_PutPixmap(letdown, 70, 0, 0, 30, 140, 70, 70);
80008cac:	34 65       	mov	r5,70
80008cae:	1a d5       	st.w	--sp,r5
80008cb0:	1a d5       	st.w	--sp,r5
80008cb2:	e0 68 00 8c 	mov	r8,140
80008cb6:	1a d8       	st.w	--sp,r8
80008cb8:	31 e8       	mov	r8,30
80008cba:	30 09       	mov	r9,0
80008cbc:	12 9a       	mov	r10,r9
80008cbe:	0a 9b       	mov	r11,r5
80008cc0:	fe fc 05 b8 	ld.w	r12,pc[1464]
80008cc4:	f0 1f 01 6e 	mcall	8000927c <etTask+0x6ac>
		et024006_PrintString("dur: 4:59", (const unsigned char *) &FONT8x8, 30, 220, WHITE, -1);
80008cc8:	fe f0 05 b8 	ld.w	r0,pc[1464]
80008ccc:	3f f1       	mov	r1,-1
80008cce:	1a d1       	st.w	--sp,r1
80008cd0:	e0 68 ff ff 	mov	r8,65535
80008cd4:	e0 69 00 dc 	mov	r9,220
80008cd8:	31 ea       	mov	r10,30
80008cda:	00 9b       	mov	r11,r0
80008cdc:	fe fc 05 a8 	ld.w	r12,pc[1448]
80008ce0:	f0 1f 01 6a 	mcall	80009288 <etTask+0x6b8>
	
		et024006_PutPixmap(wearethechampions, 70, 0, 0, 30, 20, 70, 70);
80008ce4:	1a d5       	st.w	--sp,r5
80008ce6:	1a d5       	st.w	--sp,r5
80008ce8:	31 48       	mov	r8,20
80008cea:	1a d8       	st.w	--sp,r8
80008cec:	31 e8       	mov	r8,30
80008cee:	30 09       	mov	r9,0
80008cf0:	12 9a       	mov	r10,r9
80008cf2:	0a 9b       	mov	r11,r5
80008cf4:	fe fc 05 98 	ld.w	r12,pc[1432]
80008cf8:	f0 1f 01 61 	mcall	8000927c <etTask+0x6ac>
		et024006_PrintString("dur: 3:04", (const unsigned char*) &FONT8x8, 30, 100, WHITE, -1);
80008cfc:	1a d1       	st.w	--sp,r1
80008cfe:	e0 68 ff ff 	mov	r8,65535
80008d02:	36 49       	mov	r9,100
80008d04:	31 ea       	mov	r10,30
80008d06:	00 9b       	mov	r11,r0
80008d08:	fe fc 05 88 	ld.w	r12,pc[1416]
80008d0c:	f0 1f 01 5f 	mcall	80009288 <etTask+0x6b8>
	
		et024006_PutPixmap(fercaspian, 70, 0, 0, 190, 20, 70, 70);
80008d10:	2f 8d       	sub	sp,-32
80008d12:	1a d5       	st.w	--sp,r5
80008d14:	1a d5       	st.w	--sp,r5
80008d16:	31 48       	mov	r8,20
80008d18:	1a d8       	st.w	--sp,r8
80008d1a:	e0 68 00 be 	mov	r8,190
80008d1e:	30 09       	mov	r9,0
80008d20:	12 9a       	mov	r10,r9
80008d22:	0a 9b       	mov	r11,r5
80008d24:	fe fc 05 70 	ld.w	r12,pc[1392]
80008d28:	f0 1f 01 55 	mcall	8000927c <etTask+0x6ac>
		et024006_PrintString("dur: 3:04", (const unsigned char*) &FONT8x8, 190, 100, WHITE, -1);
80008d2c:	1a d1       	st.w	--sp,r1
80008d2e:	e0 68 ff ff 	mov	r8,65535
80008d32:	36 49       	mov	r9,100
80008d34:	e0 6a 00 be 	mov	r10,190
80008d38:	00 9b       	mov	r11,r0
80008d3a:	fe fc 05 56 	ld.w	r12,pc[1366]
80008d3e:	f0 1f 01 53 	mcall	80009288 <etTask+0x6b8>
	
		et024006_PutPixmap(takeonme, 70, 0, 0, 190, 140, 70, 70);
80008d42:	1a d5       	st.w	--sp,r5
80008d44:	1a d5       	st.w	--sp,r5
80008d46:	e0 68 00 8c 	mov	r8,140
80008d4a:	1a d8       	st.w	--sp,r8
80008d4c:	e0 68 00 be 	mov	r8,190
80008d50:	30 09       	mov	r9,0
80008d52:	12 9a       	mov	r10,r9
80008d54:	0a 9b       	mov	r11,r5
80008d56:	fe fc 05 42 	ld.w	r12,pc[1346]
80008d5a:	f0 1f 01 49 	mcall	8000927c <etTask+0x6ac>
		et024006_PrintString("dur: 4:36", (const unsigned char*) &FONT8x8, 190, 220, WHITE, -1);
80008d5e:	1a d1       	st.w	--sp,r1
80008d60:	e0 68 ff ff 	mov	r8,65535
80008d64:	e0 69 00 dc 	mov	r9,220
80008d68:	e0 6a 00 be 	mov	r10,190
80008d6c:	00 9b       	mov	r11,r0
80008d6e:	fe fc 05 2e 	ld.w	r12,pc[1326]
80008d72:	f0 1f 01 46 	mcall	80009288 <etTask+0x6b8>
80008d76:	2f 8d       	sub	sp,-32
		
	}
	
	if (keys.ud == 0 && keys.lr == 0){
80008d78:	0d 98       	ld.ub	r8,r6[0x1]
80008d7a:	58 08       	cp.w	r8,0
80008d7c:	c3 71       	brne	80008dea <etTask+0x21a>
80008d7e:	0d 88       	ld.ub	r8,r6[0x0]
80008d80:	ee 08 18 00 	cp.b	r8,r7
80008d84:	c6 d1       	brne	80008e5e <etTask+0x28e>
		et024006_DrawVertLine(160,0,120,WHITE);
80008d86:	e0 69 ff ff 	mov	r9,65535
80008d8a:	37 8a       	mov	r10,120
80008d8c:	30 0b       	mov	r11,0
80008d8e:	e0 6c 00 a0 	mov	r12,160
80008d92:	f0 1f 01 38 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawVertLine(160,120,120,WHITE);
80008d96:	e0 69 ff ff 	mov	r9,65535
80008d9a:	37 8a       	mov	r10,120
80008d9c:	14 9b       	mov	r11,r10
80008d9e:	e0 6c 00 a0 	mov	r12,160
80008da2:	f0 1f 01 34 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(0,120,160,WHITE);
80008da6:	e0 69 ff ff 	mov	r9,65535
80008daa:	e0 6a 00 a0 	mov	r10,160
80008dae:	37 8b       	mov	r11,120
80008db0:	30 0c       	mov	r12,0
80008db2:	f0 1f 01 31 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawHorizLine(160,120,160,WHITE);
80008db6:	e0 69 ff ff 	mov	r9,65535
80008dba:	e0 6a 00 a0 	mov	r10,160
80008dbe:	37 8b       	mov	r11,120
80008dc0:	14 9c       	mov	r12,r10
80008dc2:	f0 1f 01 2d 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawVertLine(160,0,120,GREEN);
80008dc6:	e0 69 07 e0 	mov	r9,2016
80008dca:	37 8a       	mov	r10,120
80008dcc:	30 0b       	mov	r11,0
80008dce:	e0 6c 00 a0 	mov	r12,160
80008dd2:	f0 1f 01 28 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(0,120,160,GREEN);
80008dd6:	e0 69 07 e0 	mov	r9,2016
80008dda:	e0 6a 00 a0 	mov	r10,160
80008dde:	37 8b       	mov	r11,120
80008de0:	30 0c       	mov	r12,0
80008de2:	f0 1f 01 25 	mcall	80009274 <etTask+0x6a4>
80008de6:	e0 8f 02 25 	bral	80009230 <etTask+0x660>
			//et024006_PrintString("News of the World", (const unsigned char*) &FONT8x8, 30, 60, WHITE, -1);
			//et024006_PrintString("1977", (const unsigned char*) &FONT8x8, 30, 80, WHITE, -1);
			//et024006_PrintString("dur: 3:04", (const unsigned char*) &FONT8x8, 30, 100, BLACK, -1);
		//}
	}
	else if (keys.ud == 1 && keys.lr == 0){
80008dea:	30 19       	mov	r9,1
80008dec:	f2 08 18 00 	cp.b	r8,r9
80008df0:	c6 f1       	brne	80008ece <etTask+0x2fe>
80008df2:	0d 88       	ld.ub	r8,r6[0x0]
80008df4:	ee 08 18 00 	cp.b	r8,r7
80008df8:	c7 01       	brne	80008ed8 <etTask+0x308>
		et024006_DrawVertLine(160,0,120,WHITE);
80008dfa:	e0 69 ff ff 	mov	r9,65535
80008dfe:	37 8a       	mov	r10,120
80008e00:	30 0b       	mov	r11,0
80008e02:	e0 6c 00 a0 	mov	r12,160
80008e06:	f0 1f 01 1b 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawVertLine(160,120,120,WHITE);
80008e0a:	e0 69 ff ff 	mov	r9,65535
80008e0e:	37 8a       	mov	r10,120
80008e10:	14 9b       	mov	r11,r10
80008e12:	e0 6c 00 a0 	mov	r12,160
80008e16:	f0 1f 01 17 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(0,120,160,WHITE);
80008e1a:	e0 69 ff ff 	mov	r9,65535
80008e1e:	e0 6a 00 a0 	mov	r10,160
80008e22:	37 8b       	mov	r11,120
80008e24:	30 0c       	mov	r12,0
80008e26:	f0 1f 01 14 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawHorizLine(160,120,160,WHITE);
80008e2a:	e0 69 ff ff 	mov	r9,65535
80008e2e:	e0 6a 00 a0 	mov	r10,160
80008e32:	37 8b       	mov	r11,120
80008e34:	14 9c       	mov	r12,r10
80008e36:	f0 1f 01 10 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawVertLine(160,120,120,GREEN);
80008e3a:	e0 69 07 e0 	mov	r9,2016
80008e3e:	37 8a       	mov	r10,120
80008e40:	14 9b       	mov	r11,r10
80008e42:	e0 6c 00 a0 	mov	r12,160
80008e46:	f0 1f 01 0b 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(0,120,160,GREEN);
80008e4a:	e0 69 07 e0 	mov	r9,2016
80008e4e:	e0 6a 00 a0 	mov	r10,160
80008e52:	37 8b       	mov	r11,120
80008e54:	30 0c       	mov	r12,0
80008e56:	f0 1f 01 08 	mcall	80009274 <etTask+0x6a4>
80008e5a:	e0 8f 01 eb 	bral	80009230 <etTask+0x660>
			//et024006_PrintString("Ok Computer", (const unsigned char*) &FONT8x8, 30, 180, WHITE, -1);
			//et024006_PrintString("1997", (const unsigned char*) &FONT8x8, 30, 200, WHITE, -1);
			//et024006_PrintString("dur: 4:59", (const unsigned char*) &FONT8x8, 30, 220, BLACK, -1);
		//}
	}
	else if (keys.ud == 0 && keys.lr == 1){
80008e5e:	0d 89       	ld.ub	r9,r6[0x0]
80008e60:	30 18       	mov	r8,1
80008e62:	f0 09 18 00 	cp.b	r9,r8
80008e66:	e0 81 01 e5 	brne	80009230 <etTask+0x660>
		et024006_DrawVertLine(160,0,120,WHITE);
80008e6a:	e0 69 ff ff 	mov	r9,65535
80008e6e:	37 8a       	mov	r10,120
80008e70:	30 0b       	mov	r11,0
80008e72:	e0 6c 00 a0 	mov	r12,160
80008e76:	f0 1f 00 ff 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawVertLine(160,120,120,WHITE);
80008e7a:	e0 69 ff ff 	mov	r9,65535
80008e7e:	37 8a       	mov	r10,120
80008e80:	14 9b       	mov	r11,r10
80008e82:	e0 6c 00 a0 	mov	r12,160
80008e86:	f0 1f 00 fb 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(0,120,160,WHITE);
80008e8a:	e0 69 ff ff 	mov	r9,65535
80008e8e:	e0 6a 00 a0 	mov	r10,160
80008e92:	37 8b       	mov	r11,120
80008e94:	30 0c       	mov	r12,0
80008e96:	f0 1f 00 f8 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawHorizLine(160,120,160,WHITE);
80008e9a:	e0 69 ff ff 	mov	r9,65535
80008e9e:	e0 6a 00 a0 	mov	r10,160
80008ea2:	37 8b       	mov	r11,120
80008ea4:	14 9c       	mov	r12,r10
80008ea6:	f0 1f 00 f4 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawVertLine(160,0,120,GREEN);
80008eaa:	e0 69 07 e0 	mov	r9,2016
80008eae:	37 8a       	mov	r10,120
80008eb0:	30 0b       	mov	r11,0
80008eb2:	e0 6c 00 a0 	mov	r12,160
80008eb6:	f0 1f 00 ef 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(160,120,160,GREEN);
80008eba:	e0 69 07 e0 	mov	r9,2016
80008ebe:	e0 6a 00 a0 	mov	r10,160
80008ec2:	37 8b       	mov	r11,120
80008ec4:	14 9c       	mov	r12,r10
80008ec6:	f0 1f 00 ec 	mcall	80009274 <etTask+0x6a4>
80008eca:	e0 8f 01 b3 	bral	80009230 <etTask+0x660>
			//et024006_PrintString("between days", (const unsigned char*) &FONT8x8, 190, 60, WHITE, -1);
			//et024006_PrintString("2018", (const unsigned char*) &FONT8x8, 190, 80, WHITE, -1);
			//et024006_PrintString("dur: 4:36", (const unsigned char*) &FONT8x8, 190, 100, BLACK, -1);
		//}
	}
	else if (keys.ud == 1 && keys.lr == 1){
80008ece:	30 19       	mov	r9,1
80008ed0:	f2 08 18 00 	cp.b	r8,r9
80008ed4:	e0 81 01 ae 	brne	80009230 <etTask+0x660>
80008ed8:	0d 89       	ld.ub	r9,r6[0x0]
80008eda:	30 18       	mov	r8,1
80008edc:	f0 09 18 00 	cp.b	r9,r8
80008ee0:	e0 81 01 a8 	brne	80009230 <etTask+0x660>
		et024006_DrawVertLine(160,0,120,WHITE);
80008ee4:	e0 69 ff ff 	mov	r9,65535
80008ee8:	37 8a       	mov	r10,120
80008eea:	30 0b       	mov	r11,0
80008eec:	e0 6c 00 a0 	mov	r12,160
80008ef0:	f0 1f 00 e0 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawVertLine(160,120,120,WHITE);
80008ef4:	e0 69 ff ff 	mov	r9,65535
80008ef8:	37 8a       	mov	r10,120
80008efa:	14 9b       	mov	r11,r10
80008efc:	e0 6c 00 a0 	mov	r12,160
80008f00:	f0 1f 00 dc 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(0,120,160,WHITE);
80008f04:	e0 69 ff ff 	mov	r9,65535
80008f08:	e0 6a 00 a0 	mov	r10,160
80008f0c:	37 8b       	mov	r11,120
80008f0e:	30 0c       	mov	r12,0
80008f10:	f0 1f 00 d9 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawHorizLine(160,120,160,WHITE);
80008f14:	e0 69 ff ff 	mov	r9,65535
80008f18:	e0 6a 00 a0 	mov	r10,160
80008f1c:	37 8b       	mov	r11,120
80008f1e:	14 9c       	mov	r12,r10
80008f20:	f0 1f 00 d5 	mcall	80009274 <etTask+0x6a4>
		et024006_DrawVertLine(160,120,120,GREEN);
80008f24:	e0 69 07 e0 	mov	r9,2016
80008f28:	37 8a       	mov	r10,120
80008f2a:	14 9b       	mov	r11,r10
80008f2c:	e0 6c 00 a0 	mov	r12,160
80008f30:	f0 1f 00 d0 	mcall	80009270 <etTask+0x6a0>
		et024006_DrawHorizLine(160,120,160,GREEN);
80008f34:	e0 69 07 e0 	mov	r9,2016
80008f38:	e0 6a 00 a0 	mov	r10,160
80008f3c:	37 8b       	mov	r11,120
80008f3e:	14 9c       	mov	r12,r10
80008f40:	f0 1f 00 cd 	mcall	80009274 <etTask+0x6a4>
80008f44:	e0 8f 01 76 	bral	80009230 <etTask+0x660>
static void rep_menu(bool init)
{
	static bool first_time = true;
	static menu_keys_t keys;

	if (repLrQueue != 0)
80008f48:	fe f8 03 58 	ld.w	r8,pc[856]
80008f4c:	70 0c       	ld.w	r12,r8[0x0]
80008f4e:	58 0c       	cp.w	r12,0
80008f50:	c0 d0       	breq	80008f6a <etTask+0x39a>
	{
		if (xQueueReceive( repLrQueue, &keys.lr, (TickType_t) 2 ))
80008f52:	30 2a       	mov	r10,2
80008f54:	08 9b       	mov	r11,r4
80008f56:	f0 1f 00 bf 	mcall	80009250 <etTask+0x680>
80008f5a:	c0 80       	breq	80008f6a <etTask+0x39a>
		{
			print_dbg("Received for REP LR");
80008f5c:	fe fc 03 48 	ld.w	r12,pc[840]
80008f60:	f0 1f 00 be 	mcall	80009258 <etTask+0x688>
			print_dbg_ulong(keys.lr);
80008f64:	09 8c       	ld.ub	r12,r4[0x0]
80008f66:	f0 1f 00 be 	mcall	8000925c <etTask+0x68c>
		}
	}
	
	if (repUdQueue != 0)
80008f6a:	fe f8 03 3e 	ld.w	r8,pc[830]
80008f6e:	70 0c       	ld.w	r12,r8[0x0]
80008f70:	58 0c       	cp.w	r12,0
80008f72:	c0 d0       	breq	80008f8c <etTask+0x3bc>
	{
		if (xQueueReceive( repUdQueue, &keys.ud, (TickType_t) 2 ))
80008f74:	30 2a       	mov	r10,2
80008f76:	40 0b       	lddsp	r11,sp[0x0]
80008f78:	f0 1f 00 b6 	mcall	80009250 <etTask+0x680>
80008f7c:	c0 80       	breq	80008f8c <etTask+0x3bc>
		{
			print_dbg("Received for REP UD");
80008f7e:	fe fc 03 2e 	ld.w	r12,pc[814]
80008f82:	f0 1f 00 b6 	mcall	80009258 <etTask+0x688>
			print_dbg_ulong(keys.ud);
80008f86:	09 9c       	ld.ub	r12,r4[0x1]
80008f88:	f0 1f 00 b5 	mcall	8000925c <etTask+0x68c>
		}
	}

	if (first_time || init)
80008f8c:	05 88       	ld.ub	r8,r2[0x0]
80008f8e:	ee 08 18 00 	cp.b	r8,r7
80008f92:	c6 d0       	breq	8000906c <etTask+0x49c>
	{
		first_time = false;
80008f94:	a4 87       	st.b	r2[0x0],r7
		memset(&keys, 0, sizeof(keys));
80008f96:	a8 87       	st.b	r4[0x0],r7
80008f98:	a8 97       	st.b	r4[0x1],r7

		et024006_DrawFilledRect(0, 0, 320, 240, BLACK);
80008f9a:	30 08       	mov	r8,0
80008f9c:	e0 69 00 f0 	mov	r9,240
80008fa0:	e0 6a 01 40 	mov	r10,320
80008fa4:	10 9b       	mov	r11,r8
80008fa6:	10 9c       	mov	r12,r8
80008fa8:	f0 1f 00 b1 	mcall	8000926c <etTask+0x69c>
		et024006_PrintString("Lyrics",		 (const unsigned char *) &FONT8x16, 10, 10, WHITE, -1);
80008fac:	fe f1 03 04 	ld.w	r1,pc[772]
80008fb0:	3f f5       	mov	r5,-1
80008fb2:	1a d5       	st.w	--sp,r5
80008fb4:	e0 68 ff ff 	mov	r8,65535
80008fb8:	30 a9       	mov	r9,10
80008fba:	12 9a       	mov	r10,r9
80008fbc:	02 9b       	mov	r11,r1
80008fbe:	fe fc 02 f6 	ld.w	r12,pc[758]
80008fc2:	f0 1f 00 b2 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Main",		 (const unsigned char *) &FONT8x16, 120, 10, WHITE, -1);
80008fc6:	1a d5       	st.w	--sp,r5
80008fc8:	e0 68 ff ff 	mov	r8,65535
80008fcc:	30 a9       	mov	r9,10
80008fce:	37 8a       	mov	r10,120
80008fd0:	02 9b       	mov	r11,r1
80008fd2:	fe fc 02 e6 	ld.w	r12,pc[742]
80008fd6:	f0 1f 00 ad 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Ecualizador", (const unsigned char *) &FONT8x16, 220, 10, WHITE, -1);
80008fda:	1a d5       	st.w	--sp,r5
80008fdc:	e0 68 ff ff 	mov	r8,65535
80008fe0:	30 a9       	mov	r9,10
80008fe2:	e0 6a 00 dc 	mov	r10,220
80008fe6:	02 9b       	mov	r11,r1
80008fe8:	fe fc 02 d4 	ld.w	r12,pc[724]
80008fec:	f0 1f 00 a7 	mcall	80009288 <etTask+0x6b8>

		et024006_PutPixmap(letdown, 70, 0, 0, 120, 70, 70, 70);
80008ff0:	34 6b       	mov	r11,70
80008ff2:	1a db       	st.w	--sp,r11
80008ff4:	1a db       	st.w	--sp,r11
80008ff6:	1a db       	st.w	--sp,r11
80008ff8:	37 88       	mov	r8,120
80008ffa:	30 09       	mov	r9,0
80008ffc:	12 9a       	mov	r10,r9
80008ffe:	fe fc 02 7a 	ld.w	r12,pc[634]
80009002:	f0 1f 00 9f 	mcall	8000927c <etTask+0x6ac>
		et024006_PrintString("Let Down", (const unsigned char *) &FONT8x16, 125, 160, WHITE, -1);
80009006:	1a d5       	st.w	--sp,r5
80009008:	e0 68 ff ff 	mov	r8,65535
8000900c:	e0 69 00 a0 	mov	r9,160
80009010:	37 da       	mov	r10,125
80009012:	02 9b       	mov	r11,r1
80009014:	fe fc 02 ac 	ld.w	r12,pc[684]
80009018:	f0 1f 00 9c 	mcall	80009288 <etTask+0x6b8>

		et024006_PutPixmap(atrasarblanco, 50, 0, 0, 10, 190, 50, 50);
8000901c:	33 25       	mov	r5,50
8000901e:	1a d5       	st.w	--sp,r5
80009020:	1a d5       	st.w	--sp,r5
80009022:	e0 61 00 be 	mov	r1,190
80009026:	1a d1       	st.w	--sp,r1
80009028:	30 a8       	mov	r8,10
8000902a:	30 09       	mov	r9,0
8000902c:	12 9a       	mov	r10,r9
8000902e:	0a 9b       	mov	r11,r5
80009030:	fe fc 02 94 	ld.w	r12,pc[660]
80009034:	f0 1f 00 92 	mcall	8000927c <etTask+0x6ac>
		et024006_PutPixmap(play, 50, 0, 0, 135, 190, 50, 50);
80009038:	2f 6d       	sub	sp,-40
8000903a:	1a d5       	st.w	--sp,r5
8000903c:	1a d5       	st.w	--sp,r5
8000903e:	1a d1       	st.w	--sp,r1
80009040:	e0 68 00 87 	mov	r8,135
80009044:	30 09       	mov	r9,0
80009046:	12 9a       	mov	r10,r9
80009048:	0a 9b       	mov	r11,r5
8000904a:	fe fc 02 7e 	ld.w	r12,pc[638]
8000904e:	f0 1f 00 8c 	mcall	8000927c <etTask+0x6ac>
		et024006_PutPixmap(adelantar, 50, 0, 0, 260, 190, 50, 50);
80009052:	1a d5       	st.w	--sp,r5
80009054:	1a d5       	st.w	--sp,r5
80009056:	1a d1       	st.w	--sp,r1
80009058:	e0 68 01 04 	mov	r8,260
8000905c:	30 09       	mov	r9,0
8000905e:	12 9a       	mov	r10,r9
80009060:	0a 9b       	mov	r11,r5
80009062:	fe fc 02 6a 	ld.w	r12,pc[618]
80009066:	f0 1f 00 86 	mcall	8000927c <etTask+0x6ac>
8000906a:	2f ad       	sub	sp,-24
	}

	if (keys.ud == 0 && keys.lr == 0){
8000906c:	09 98       	ld.ub	r8,r4[0x1]
8000906e:	58 08       	cp.w	r8,0
80009070:	c7 11       	brne	80009152 <etTask+0x582>
80009072:	09 88       	ld.ub	r8,r4[0x0]
80009074:	58 08       	cp.w	r8,0
80009076:	c2 51       	brne	800090c0 <etTask+0x4f0>
		et024006_PrintString("Lyrics", (const unsigned char*) &FONT8x16, 10, 10, GREEN, -1);
80009078:	fe f1 02 38 	ld.w	r1,pc[568]
8000907c:	3f f5       	mov	r5,-1
8000907e:	1a d5       	st.w	--sp,r5
80009080:	e0 68 07 e0 	mov	r8,2016
80009084:	30 a9       	mov	r9,10
80009086:	12 9a       	mov	r10,r9
80009088:	02 9b       	mov	r11,r1
8000908a:	fe fc 02 2a 	ld.w	r12,pc[554]
8000908e:	f0 1f 00 7f 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Main", (const unsigned char*) &FONT8x16, 120, 10, WHITE, -1);
80009092:	1a d5       	st.w	--sp,r5
80009094:	e0 68 ff ff 	mov	r8,65535
80009098:	30 a9       	mov	r9,10
8000909a:	37 8a       	mov	r10,120
8000909c:	02 9b       	mov	r11,r1
8000909e:	fe fc 02 1a 	ld.w	r12,pc[538]
800090a2:	f0 1f 00 7a 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Ecualizador", (const unsigned char*) &FONT8x16, 220, 10, WHITE, -1);
800090a6:	1a d5       	st.w	--sp,r5
800090a8:	e0 68 ff ff 	mov	r8,65535
800090ac:	30 a9       	mov	r9,10
800090ae:	e0 6a 00 dc 	mov	r10,220
800090b2:	02 9b       	mov	r11,r1
800090b4:	fe fc 02 08 	ld.w	r12,pc[520]
800090b8:	f0 1f 00 74 	mcall	80009288 <etTask+0x6b8>
800090bc:	2f dd       	sub	sp,-12
800090be:	cb 98       	rjmp	80009230 <etTask+0x660>
	}
	else if (keys.ud == 0 && keys.lr == 1){
800090c0:	30 19       	mov	r9,1
800090c2:	f2 08 18 00 	cp.b	r8,r9
800090c6:	c2 11       	brne	80009108 <etTask+0x538>
		et024006_PrintString("Lyrics", (const unsigned char*) &FONT8x16, 10, 10, WHITE, -1);
800090c8:	4f a1       	lddpc	r1,800092b0 <etTask+0x6e0>
800090ca:	3f f5       	mov	r5,-1
800090cc:	1a d5       	st.w	--sp,r5
800090ce:	e0 68 ff ff 	mov	r8,65535
800090d2:	30 a9       	mov	r9,10
800090d4:	12 9a       	mov	r10,r9
800090d6:	02 9b       	mov	r11,r1
800090d8:	4f 7c       	lddpc	r12,800092b4 <etTask+0x6e4>
800090da:	f0 1f 00 6c 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Main", (const unsigned char*) &FONT8x16, 120, 10, GREEN, -1);
800090de:	1a d5       	st.w	--sp,r5
800090e0:	e0 68 07 e0 	mov	r8,2016
800090e4:	30 a9       	mov	r9,10
800090e6:	37 8a       	mov	r10,120
800090e8:	02 9b       	mov	r11,r1
800090ea:	4f 4c       	lddpc	r12,800092b8 <etTask+0x6e8>
800090ec:	f0 1f 00 67 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Ecualizador", (const unsigned char*) &FONT8x16, 220, 10, WHITE, -1);
800090f0:	1a d5       	st.w	--sp,r5
800090f2:	e0 68 ff ff 	mov	r8,65535
800090f6:	30 a9       	mov	r9,10
800090f8:	e0 6a 00 dc 	mov	r10,220
800090fc:	02 9b       	mov	r11,r1
800090fe:	4f 0c       	lddpc	r12,800092bc <etTask+0x6ec>
80009100:	f0 1f 00 62 	mcall	80009288 <etTask+0x6b8>
80009104:	2f dd       	sub	sp,-12
80009106:	c9 58       	rjmp	80009230 <etTask+0x660>
	}
	else if (keys.ud == 0 && keys.lr == 2){
80009108:	30 29       	mov	r9,2
8000910a:	f2 08 18 00 	cp.b	r8,r9
8000910e:	e0 81 00 91 	brne	80009230 <etTask+0x660>
		et024006_PrintString("Lyrics", (const unsigned char*) &FONT8x16, 10, 10, WHITE, -1);
80009112:	4e 81       	lddpc	r1,800092b0 <etTask+0x6e0>
80009114:	3f f5       	mov	r5,-1
80009116:	1a d5       	st.w	--sp,r5
80009118:	e0 68 ff ff 	mov	r8,65535
8000911c:	30 a9       	mov	r9,10
8000911e:	12 9a       	mov	r10,r9
80009120:	02 9b       	mov	r11,r1
80009122:	4e 5c       	lddpc	r12,800092b4 <etTask+0x6e4>
80009124:	f0 1f 00 59 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Main", (const unsigned char*) &FONT8x16, 120, 10, WHITE, -1);
80009128:	1a d5       	st.w	--sp,r5
8000912a:	e0 68 ff ff 	mov	r8,65535
8000912e:	30 a9       	mov	r9,10
80009130:	37 8a       	mov	r10,120
80009132:	02 9b       	mov	r11,r1
80009134:	4e 1c       	lddpc	r12,800092b8 <etTask+0x6e8>
80009136:	f0 1f 00 55 	mcall	80009288 <etTask+0x6b8>
		et024006_PrintString("Ecualizador", (const unsigned char*) &FONT8x16, 220, 10, GREEN, -1);
8000913a:	1a d5       	st.w	--sp,r5
8000913c:	e0 68 07 e0 	mov	r8,2016
80009140:	30 a9       	mov	r9,10
80009142:	e0 6a 00 dc 	mov	r10,220
80009146:	02 9b       	mov	r11,r1
80009148:	4d dc       	lddpc	r12,800092bc <etTask+0x6ec>
8000914a:	f0 1f 00 50 	mcall	80009288 <etTask+0x6b8>
8000914e:	2f dd       	sub	sp,-12
80009150:	c7 08       	rjmp	80009230 <etTask+0x660>
	}
	else if (keys.ud == 2 && keys.lr == 0){
80009152:	30 29       	mov	r9,2
80009154:	f2 08 18 00 	cp.b	r8,r9
80009158:	c6 c1       	brne	80009230 <etTask+0x660>
8000915a:	09 88       	ld.ub	r8,r4[0x0]
8000915c:	58 08       	cp.w	r8,0
8000915e:	c1 81       	brne	8000918e <etTask+0x5be>
		et024006_PutPixmap(letdown, 70, 0, 0, 120, 70, 70, 70);
80009160:	34 6b       	mov	r11,70
80009162:	1a db       	st.w	--sp,r11
80009164:	1a db       	st.w	--sp,r11
80009166:	1a db       	st.w	--sp,r11
80009168:	37 88       	mov	r8,120
8000916a:	30 09       	mov	r9,0
8000916c:	12 9a       	mov	r10,r9
8000916e:	4c 3c       	lddpc	r12,80009278 <etTask+0x6a8>
80009170:	f0 1f 00 43 	mcall	8000927c <etTask+0x6ac>
		et024006_PrintString("cancion2", (const unsigned char*) &FONT8x16, 120, 170, WHITE, -1);
80009174:	3f f8       	mov	r8,-1
80009176:	1a d8       	st.w	--sp,r8
80009178:	e0 68 ff ff 	mov	r8,65535
8000917c:	e0 69 00 aa 	mov	r9,170
80009180:	37 8a       	mov	r10,120
80009182:	4c cb       	lddpc	r11,800092b0 <etTask+0x6e0>
80009184:	4d 3c       	lddpc	r12,800092d0 <etTask+0x700>
80009186:	f0 1f 00 41 	mcall	80009288 <etTask+0x6b8>
8000918a:	2f cd       	sub	sp,-16
8000918c:	c5 28       	rjmp	80009230 <etTask+0x660>

	}
	else if (keys.ud == 2 && keys.lr == 1){
8000918e:	30 19       	mov	r9,1
80009190:	f2 08 18 00 	cp.b	r8,r9
80009194:	c2 61       	brne	800091e0 <etTask+0x610>
		et024006_PutPixmap(atrasarblanco, 50, 0, 0, 10, 190, 50, 50);
80009196:	33 25       	mov	r5,50
80009198:	1a d5       	st.w	--sp,r5
8000919a:	1a d5       	st.w	--sp,r5
8000919c:	e0 61 00 be 	mov	r1,190
800091a0:	1a d1       	st.w	--sp,r1
800091a2:	30 a8       	mov	r8,10
800091a4:	30 09       	mov	r9,0
800091a6:	12 9a       	mov	r10,r9
800091a8:	0a 9b       	mov	r11,r5
800091aa:	4c 7c       	lddpc	r12,800092c4 <etTask+0x6f4>
800091ac:	f0 1f 00 34 	mcall	8000927c <etTask+0x6ac>
		et024006_PutPixmap(playverde, 50, 0, 0, 140, 190, 50, 50);
800091b0:	1a d5       	st.w	--sp,r5
800091b2:	1a d5       	st.w	--sp,r5
800091b4:	1a d1       	st.w	--sp,r1
800091b6:	e0 68 00 8c 	mov	r8,140
800091ba:	30 09       	mov	r9,0
800091bc:	12 9a       	mov	r10,r9
800091be:	0a 9b       	mov	r11,r5
800091c0:	4c 5c       	lddpc	r12,800092d4 <etTask+0x704>
800091c2:	f0 1f 00 2f 	mcall	8000927c <etTask+0x6ac>
		et024006_PutPixmap(adelantar, 50, 0, 0, 260, 190, 50, 50);
800091c6:	1a d5       	st.w	--sp,r5
800091c8:	1a d5       	st.w	--sp,r5
800091ca:	1a d1       	st.w	--sp,r1
800091cc:	e0 68 01 04 	mov	r8,260
800091d0:	30 09       	mov	r9,0
800091d2:	12 9a       	mov	r10,r9
800091d4:	0a 9b       	mov	r11,r5
800091d6:	4b ec       	lddpc	r12,800092cc <etTask+0x6fc>
800091d8:	f0 1f 00 29 	mcall	8000927c <etTask+0x6ac>
800091dc:	2f 7d       	sub	sp,-36
800091de:	c2 98       	rjmp	80009230 <etTask+0x660>
	else if(keys.ud == 2 && keys.lr == 0){
		et024006_PutPixmap(atrasarverde, 50, 0, 0, 10, 190, 50, 50);
		et024006_PutPixmap(play, 50, 0, 0, 140, 190, 50, 50);
		et024006_PutPixmap(adelantar, 50, 0, 0, 260, 190, 50, 50);
	}
	else if (keys.ud == 2 && keys.lr == 2){
800091e0:	30 29       	mov	r9,2
800091e2:	f2 08 18 00 	cp.b	r8,r9
800091e6:	c2 51       	brne	80009230 <etTask+0x660>
		et024006_PutPixmap(atrasarblanco, 50, 0, 0, 10, 190, 50, 50);
800091e8:	33 25       	mov	r5,50
800091ea:	1a d5       	st.w	--sp,r5
800091ec:	1a d5       	st.w	--sp,r5
800091ee:	e0 61 00 be 	mov	r1,190
800091f2:	1a d1       	st.w	--sp,r1
800091f4:	30 a8       	mov	r8,10
800091f6:	30 09       	mov	r9,0
800091f8:	12 9a       	mov	r10,r9
800091fa:	0a 9b       	mov	r11,r5
800091fc:	4b 2c       	lddpc	r12,800092c4 <etTask+0x6f4>
800091fe:	f0 1f 00 20 	mcall	8000927c <etTask+0x6ac>
		et024006_PutPixmap(play, 50, 0, 0, 140, 190, 50, 50);
80009202:	1a d5       	st.w	--sp,r5
80009204:	1a d5       	st.w	--sp,r5
80009206:	1a d1       	st.w	--sp,r1
80009208:	e0 68 00 8c 	mov	r8,140
8000920c:	30 09       	mov	r9,0
8000920e:	12 9a       	mov	r10,r9
80009210:	0a 9b       	mov	r11,r5
80009212:	4a ec       	lddpc	r12,800092c8 <etTask+0x6f8>
80009214:	f0 1f 00 1a 	mcall	8000927c <etTask+0x6ac>
		et024006_PutPixmap(adelantarverde, 50, 0, 0, 260, 190, 50, 50);
80009218:	1a d5       	st.w	--sp,r5
8000921a:	1a d5       	st.w	--sp,r5
8000921c:	1a d1       	st.w	--sp,r1
8000921e:	e0 68 01 04 	mov	r8,260
80009222:	30 09       	mov	r9,0
80009224:	12 9a       	mov	r10,r9
80009226:	0a 9b       	mov	r11,r5
80009228:	4a cc       	lddpc	r12,800092d8 <etTask+0x708>
8000922a:	f0 1f 00 15 	mcall	8000927c <etTask+0x6ac>
8000922e:	2f 7d       	sub	sp,-36
			case LYRICS:
				break;
			case EQ:
				break;
		}
		vTaskSuspend(NULL);
80009230:	30 0c       	mov	r12,0
80009232:	f0 1f 00 2b 	mcall	800092dc <etTask+0x70c>
	}
80009236:	fe 9f fc de 	bral	80008bf2 <etTask+0x22>
8000923a:	00 00       	add	r0,r0
8000923c:	00 00       	add	r0,r0
8000923e:	77 2c       	ld.w	r12,r11[0x48]
80009240:	00 00       	add	r0,r0
80009242:	00 18       	sub	r8,r0
80009244:	00 00       	add	r0,r0
80009246:	77 34       	ld.w	r4,r11[0x4c]
80009248:	00 00       	add	r0,r0
8000924a:	77 3c       	ld.w	r12,r11[0x4c]
8000924c:	00 00       	add	r0,r0
8000924e:	7d 34       	ld.w	r4,lr[0x4c]
80009250:	80 00       	ld.sh	r0,r0[0x0]
80009252:	71 d8       	ld.w	r8,r8[0x74]
80009254:	80 01       	ld.sh	r1,r0[0x0]
80009256:	af 38       	mul	r8,r7
80009258:	80 00       	ld.sh	r0,r0[0x0]
8000925a:	69 a4       	ld.w	r4,r4[0x68]
8000925c:	80 00       	ld.sh	r0,r0[0x0]
8000925e:	69 90       	ld.w	r0,r4[0x64]
80009260:	00 00       	add	r0,r0
80009262:	7d 24       	ld.w	r4,lr[0x48]
80009264:	80 01       	ld.sh	r1,r0[0x0]
80009266:	af 50       	asr	r0,0xf
80009268:	00 00       	add	r0,r0
8000926a:	00 19       	sub	r9,r0
8000926c:	80 00       	ld.sh	r0,r0[0x0]
8000926e:	23 28       	sub	r8,50
80009270:	80 00       	ld.sh	r0,r0[0x0]
80009272:	23 68       	sub	r8,54
80009274:	80 00       	ld.sh	r0,r0[0x0]
80009276:	23 84       	sub	r4,56
80009278:	80 01       	ld.sh	r1,r0[0x0]
8000927a:	39 20       	mov	r0,-110
8000927c:	80 00       	ld.sh	r0,r0[0x0]
8000927e:	24 04       	sub	r4,64
80009280:	80 00       	ld.sh	r0,r0[0x0]
80009282:	ac 10       	st.h	r6[0x2],r0
80009284:	80 01       	ld.sh	r1,r0[0x0]
80009286:	af 68       	lsl	r8,0xe
80009288:	80 00       	ld.sh	r0,r0[0x0]
8000928a:	20 ac       	sub	r12,10
8000928c:	80 01       	ld.sh	r1,r0[0x0]
8000928e:	85 b0       	st.w	r2[0x2c],r0
80009290:	80 01       	ld.sh	r1,r0[0x0]
80009292:	af 74       	lsl	r4,0xf
80009294:	80 00       	ld.sh	r0,r0[0x0]
80009296:	eb c8 80 01 	stm	--r8,r0,pc
8000929a:	5f 68       	srmi	r8
8000929c:	80 01       	ld.sh	r1,r0[0x0]
8000929e:	af 80       	lsr	r0,0xe
800092a0:	00 00       	add	r0,r0
800092a2:	7d 20       	ld.w	r0,lr[0x48]
800092a4:	80 01       	ld.sh	r1,r0[0x0]
800092a6:	af 8c       	lsr	r12,0xe
800092a8:	00 00       	add	r0,r0
800092aa:	7d 30       	ld.w	r0,lr[0x4c]
800092ac:	80 01       	ld.sh	r1,r0[0x0]
800092ae:	af a0       	sbr	r0,0xe
800092b0:	80 00       	ld.sh	r0,r0[0x0]
800092b2:	a6 00       	st.h	r3[0x0],r0
800092b4:	80 01       	ld.sh	r1,r0[0x0]
800092b6:	af b4       	sbr	r4,0xf
800092b8:	80 01       	ld.sh	r1,r0[0x0]
800092ba:	af bc       	sbr	r12,0xf
800092bc:	80 01       	ld.sh	r1,r0[0x0]
800092be:	af c4       	cbr	r4,0xe
800092c0:	80 01       	ld.sh	r1,r0[0x0]
800092c2:	af d0       	cbr	r0,0xf
800092c4:	80 00       	ld.sh	r0,r0[0x0]
800092c6:	d8 40       	acall	0x84
800092c8:	80 01       	ld.sh	r1,r0[0x0]
800092ca:	12 10       	sub	r0,r9
800092cc:	80 00       	ld.sh	r0,r0[0x0]
800092ce:	b1 30       	mul	r0,r8
800092d0:	80 01       	ld.sh	r1,r0[0x0]
800092d2:	af dc       	cbr	r12,0xf
800092d4:	80 01       	ld.sh	r1,r0[0x0]
800092d6:	25 98       	sub	r8,89
800092d8:	80 00       	ld.sh	r0,r0[0x0]
800092da:	c4 b8       	rjmp	80009370 <fsTask+0x90>
800092dc:	80 00       	ld.sh	r0,r0[0x0]
800092de:	7e 04       	ld.w	r4,pc[0x0]

800092e0 <fsTask>:
}

// fsHandle
portTASK_FUNCTION_PROTO( fsTask, p );
portTASK_FUNCTION( fsTask, p )
{
800092e0:	eb cd 40 fc 	pushm	r2-r7,lr
	uint8_t temp;
	uint8_t test;
	char mensaje[] = {""};
		
	if (ctrl_access_init())
800092e4:	f0 1f 00 64 	mcall	80009474 <fsTask+0x194>
800092e8:	c0 40       	breq	800092f0 <fsTask+0x10>
	{
		print_dbg("Access granted");
800092ea:	4e 4c       	lddpc	r12,80009478 <fsTask+0x198>
800092ec:	f0 1f 00 64 	mcall	8000947c <fsTask+0x19c>
	}

	temp = get_nb_lun();													//Leer LUN Actual
800092f0:	f0 1f 00 64 	mcall	80009480 <fsTask+0x1a0>
800092f4:	18 97       	mov	r7,r12
	print_dbg("\r\n LUN actual\t");
800092f6:	4e 4c       	lddpc	r12,80009484 <fsTask+0x1a4>
800092f8:	f0 1f 00 61 	mcall	8000947c <fsTask+0x19c>
	print_dbg_ulong(temp);
800092fc:	0e 9c       	mov	r12,r7
800092fe:	f0 1f 00 63 	mcall	80009488 <fsTask+0x1a8>

	print_dbg("\r\n Revisar la unidad\t");
80009302:	4e 3c       	lddpc	r12,8000948c <fsTask+0x1ac>
80009304:	f0 1f 00 5e 	mcall	8000947c <fsTask+0x19c>
	temp = nav_drive_getname();											//Leer identificador de la unidad
80009308:	f0 1f 00 62 	mcall	80009490 <fsTask+0x1b0>
8000930c:	18 97       	mov	r7,r12
	print_dbg_char_hex(temp);print_dbg("\t");print_dbg_char(temp);		//imprime identificador de la unidad @return   'A','B',...  'X', in case of no drive selected
8000930e:	f0 1f 00 62 	mcall	80009494 <fsTask+0x1b4>
80009312:	4e 2c       	lddpc	r12,80009498 <fsTask+0x1b8>
80009314:	f0 1f 00 5a 	mcall	8000947c <fsTask+0x19c>
80009318:	0e 9c       	mov	r12,r7
8000931a:	f0 1f 00 61 	mcall	8000949c <fsTask+0x1bc>
	print_dbg(": ");
8000931e:	4e 1c       	lddpc	r12,800094a0 <fsTask+0x1c0>
80009320:	f0 1f 00 57 	mcall	8000947c <fsTask+0x19c>

	test = nav_drive_nb();
80009324:	f0 1f 00 60 	mcall	800094a4 <fsTask+0x1c4>
80009328:	18 97       	mov	r7,r12
	print_dbg("\r\n Drive nb:");
8000932a:	4e 0c       	lddpc	r12,800094a8 <fsTask+0x1c8>
8000932c:	f0 1f 00 54 	mcall	8000947c <fsTask+0x19c>
	print_dbg_ulong(test);
80009330:	0e 9c       	mov	r12,r7
80009332:	f0 1f 00 56 	mcall	80009488 <fsTask+0x1a8>

	nav_drive_set(nav_drive_nb() - 1);
80009336:	f0 1f 00 5c 	mcall	800094a4 <fsTask+0x1c4>
8000933a:	20 1c       	sub	r12,1
8000933c:	5c 5c       	castu.b	r12
8000933e:	f0 1f 00 5c 	mcall	800094ac <fsTask+0x1cc>
static void init_fs(void)
{
	/*Inicialiazamos los archivos de la SD manejada por SPI, para lograr que funcionara tuvo que habilitarla mediante el
	conf_access.h y conf_explorer.h, debido a que por default viene habilitada la memoria incluida en la EVK*/

	first_ls = true;
80009342:	30 19       	mov	r9,1
80009344:	4d b8       	lddpc	r8,800094b0 <fsTask+0x1d0>
80009346:	b0 89       	st.b	r8[0x0],r9
	if (nav_drive_get() >= nav_drive_nb() || first_ls)
80009348:	f0 1f 00 5b 	mcall	800094b4 <fsTask+0x1d4>
8000934c:	18 97       	mov	r7,r12
8000934e:	f0 1f 00 56 	mcall	800094a4 <fsTask+0x1c4>
80009352:	f8 07 18 00 	cp.b	r7,r12
80009356:	c0 72       	brcc	80009364 <fsTask+0x84>
80009358:	4d 68       	lddpc	r8,800094b0 <fsTask+0x1d0>
8000935a:	11 89       	ld.ub	r9,r8[0x0]
8000935c:	30 08       	mov	r8,0
8000935e:	f0 09 18 00 	cp.b	r9,r8
80009362:	c0 e0       	breq	8000937e <fsTask+0x9e>
	{
		first_ls = false;
80009364:	30 09       	mov	r9,0
80009366:	4d 38       	lddpc	r8,800094b0 <fsTask+0x1d0>
80009368:	b0 89       	st.b	r8[0x0],r9
		// Reset navigators .
		nav_reset();
8000936a:	f0 1f 00 54 	mcall	800094b8 <fsTask+0x1d8>
		// Use the last drive available as default.
		nav_drive_set(nav_drive_nb() - 1);
8000936e:	f0 1f 00 4e 	mcall	800094a4 <fsTask+0x1c4>
80009372:	20 1c       	sub	r12,1
80009374:	5c 5c       	castu.b	r12
80009376:	f0 1f 00 4e 	mcall	800094ac <fsTask+0x1cc>
		// Mount it.
		nav_partition_mount();
8000937a:	f0 1f 00 51 	mcall	800094bc <fsTask+0x1dc>
	}
	nav_dir_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH);
8000937e:	31 eb       	mov	r11,30
80009380:	4d 0c       	lddpc	r12,800094c0 <fsTask+0x1e0>
80009382:	f0 1f 00 51 	mcall	800094c4 <fsTask+0x1e4>
	// Try to sort items by folders
	if (!nav_filelist_first(FS_DIR))
80009386:	30 0c       	mov	r12,0
80009388:	f0 1f 00 50 	mcall	800094c8 <fsTask+0x1e8>
8000938c:	c0 41       	brne	80009394 <fsTask+0xb4>
	{
		// Sort items by files
		nav_filelist_first(FS_FILE);
8000938e:	30 1c       	mov	r12,1
80009390:	f0 1f 00 4e 	mcall	800094c8 <fsTask+0x1e8>
	print_dbg_ulong(test);

	nav_drive_set(nav_drive_nb() - 1);

	init_fs();
	nav_filelist_reset();
80009394:	f0 1f 00 4e 	mcall	800094cc <fsTask+0x1ec>

	test = nav_drive_get();
80009398:	f0 1f 00 47 	mcall	800094b4 <fsTask+0x1d4>
8000939c:	18 97       	mov	r7,r12
	print_dbg("\r\n Drive get:");
8000939e:	4c dc       	lddpc	r12,800094d0 <fsTask+0x1f0>
800093a0:	f0 1f 00 37 	mcall	8000947c <fsTask+0x19c>
	print_dbg_ulong(test);
800093a4:	0e 9c       	mov	r12,r7
800093a6:	f0 1f 00 39 	mcall	80009488 <fsTask+0x1a8>

	test = nav_filelist_nb(FS_FILE);
800093aa:	30 1c       	mov	r12,1
800093ac:	f0 1f 00 4a 	mcall	800094d4 <fsTask+0x1f4>
800093b0:	ef dc b0 10 	bfexts	r7,r12,0x0,0x10
	print_dbg("\r\n Files in Drive:");
800093b4:	4c 9c       	lddpc	r12,800094d8 <fsTask+0x1f8>
800093b6:	f0 1f 00 32 	mcall	8000947c <fsTask+0x19c>
	print_dbg_ulong(test);
800093ba:	0e 9c       	mov	r12,r7
800093bc:	5c 5c       	castu.b	r12
800093be:	f0 1f 00 33 	mcall	80009488 <fsTask+0x1a8>

	temp = 0;
	print_dbg("\r Buscando Archivos: ");
800093c2:	4c 7c       	lddpc	r12,800094dc <fsTask+0x1fc>
800093c4:	f0 1f 00 2e 	mcall	8000947c <fsTask+0x19c>
	nav_filelist_reset();
800093c8:	f0 1f 00 41 	mcall	800094cc <fsTask+0x1ec>
800093cc:	30 07       	mov	r7,0
	while (nav_filelist_set(0, FS_FIND_NEXT))					// While an item can be found
800093ce:	30 16       	mov	r6,1
800093d0:	0e 95       	mov	r5,r7
800093d2:	c0 38       	rjmp	800093d8 <fsTask+0xf8>
	{
		temp++;
800093d4:	2f f7       	sub	r7,-1
800093d6:	5c 57       	castu.b	r7
	print_dbg_ulong(test);

	temp = 0;
	print_dbg("\r Buscando Archivos: ");
	nav_filelist_reset();
	while (nav_filelist_set(0, FS_FIND_NEXT))					// While an item can be found
800093d8:	0c 9b       	mov	r11,r6
800093da:	0a 9c       	mov	r12,r5
800093dc:	f0 1f 00 41 	mcall	800094e0 <fsTask+0x200>
800093e0:	cf a1       	brne	800093d4 <fsTask+0xf4>
	{
		temp++;
	}
	print_dbg_ulong(temp);
800093e2:	0e 9c       	mov	r12,r7
800093e4:	f0 1f 00 29 	mcall	80009488 <fsTask+0x1a8>
	print_dbg("\tArchivos Encontrados");
800093e8:	4b fc       	lddpc	r12,800094e4 <fsTask+0x204>
800093ea:	f0 1f 00 25 	mcall	8000947c <fsTask+0x19c>

	nav_filelist_reset();
800093ee:	f0 1f 00 38 	mcall	800094cc <fsTask+0x1ec>
	while (nav_filelist_set(0, FS_FIND_NEXT))					//
800093f2:	30 16       	mov	r6,1
800093f4:	30 07       	mov	r7,0
	{
		print_dbg("\r\n Archivo Encontrado, Contenido:\r");
800093f6:	4b d5       	lddpc	r5,800094e8 <fsTask+0x208>
		file_open(FOPEN_MODE_R);
800093f8:	30 94       	mov	r4,9
		{
			print_dbg_char(file_getc());				// Display next char from file.
		}
		// Close the file.
		file_close();
		print_dbg("\r\n");
800093fa:	4b d3       	lddpc	r3,800094ec <fsTask+0x20c>
		vTaskDelay(pdMS_TO_TICKS(1000));
800093fc:	e0 62 03 e8 	mov	r2,1000
	}
	print_dbg_ulong(temp);
	print_dbg("\tArchivos Encontrados");

	nav_filelist_reset();
	while (nav_filelist_set(0, FS_FIND_NEXT))					//
80009400:	c1 88       	rjmp	80009430 <fsTask+0x150>
	{
		print_dbg("\r\n Archivo Encontrado, Contenido:\r");
80009402:	0a 9c       	mov	r12,r5
80009404:	f0 1f 00 1e 	mcall	8000947c <fsTask+0x19c>
		file_open(FOPEN_MODE_R);
80009408:	08 9c       	mov	r12,r4
8000940a:	f0 1f 00 3a 	mcall	800094f0 <fsTask+0x210>
		while (!file_eof())							//Hasta encontrar el fin del archivo
8000940e:	c0 68       	rjmp	8000941a <fsTask+0x13a>
		{
			print_dbg_char(file_getc());				// Display next char from file.
80009410:	f0 1f 00 39 	mcall	800094f4 <fsTask+0x214>
80009414:	5c 7c       	castu.h	r12
80009416:	f0 1f 00 22 	mcall	8000949c <fsTask+0x1bc>
	nav_filelist_reset();
	while (nav_filelist_set(0, FS_FIND_NEXT))					//
	{
		print_dbg("\r\n Archivo Encontrado, Contenido:\r");
		file_open(FOPEN_MODE_R);
		while (!file_eof())							//Hasta encontrar el fin del archivo
8000941a:	f0 1f 00 38 	mcall	800094f8 <fsTask+0x218>
8000941e:	cf 90       	breq	80009410 <fsTask+0x130>
		{
			print_dbg_char(file_getc());				// Display next char from file.
		}
		// Close the file.
		file_close();
80009420:	f0 1f 00 37 	mcall	800094fc <fsTask+0x21c>
		print_dbg("\r\n");
80009424:	06 9c       	mov	r12,r3
80009426:	f0 1f 00 16 	mcall	8000947c <fsTask+0x19c>
		vTaskDelay(pdMS_TO_TICKS(1000));
8000942a:	04 9c       	mov	r12,r2
8000942c:	f0 1f 00 35 	mcall	80009500 <fsTask+0x220>
	}
	print_dbg_ulong(temp);
	print_dbg("\tArchivos Encontrados");

	nav_filelist_reset();
	while (nav_filelist_set(0, FS_FIND_NEXT))					//
80009430:	0c 9b       	mov	r11,r6
80009432:	0e 9c       	mov	r12,r7
80009434:	f0 1f 00 2b 	mcall	800094e0 <fsTask+0x200>
80009438:	ce 51       	brne	80009402 <fsTask+0x122>
		file_close();
		print_dbg("\r\n");
		vTaskDelay(pdMS_TO_TICKS(1000));
	}

	print_dbg("\r\nImprimir archivo nmero 3 \r");
8000943a:	4b 3c       	lddpc	r12,80009504 <fsTask+0x224>
8000943c:	f0 1f 00 10 	mcall	8000947c <fsTask+0x19c>
	nav_filelist_reset();
80009440:	f0 1f 00 23 	mcall	800094cc <fsTask+0x1ec>
	nav_filelist_goto( 3 );							//Imprimir antes el archivo
80009444:	30 3c       	mov	r12,3
80009446:	f0 1f 00 31 	mcall	80009508 <fsTask+0x228>
	print_dbg("\r\n Archivo 3, Contenido:\r");
8000944a:	4b 1c       	lddpc	r12,8000950c <fsTask+0x22c>
8000944c:	f0 1f 00 0c 	mcall	8000947c <fsTask+0x19c>
	file_open(FOPEN_MODE_R);
80009450:	30 9c       	mov	r12,9
80009452:	f0 1f 00 28 	mcall	800094f0 <fsTask+0x210>
	while (!file_eof())								//Hasta encontrar el fin del archivo
80009456:	c0 68       	rjmp	80009462 <fsTask+0x182>
	{
		print_dbg_char(file_getc());				// Display next char from file.
80009458:	f0 1f 00 27 	mcall	800094f4 <fsTask+0x214>
8000945c:	5c 7c       	castu.h	r12
8000945e:	f0 1f 00 10 	mcall	8000949c <fsTask+0x1bc>
	print_dbg("\r\nImprimir archivo nmero 3 \r");
	nav_filelist_reset();
	nav_filelist_goto( 3 );							//Imprimir antes el archivo
	print_dbg("\r\n Archivo 3, Contenido:\r");
	file_open(FOPEN_MODE_R);
	while (!file_eof())								//Hasta encontrar el fin del archivo
80009462:	f0 1f 00 26 	mcall	800094f8 <fsTask+0x218>
80009466:	cf 90       	breq	80009458 <fsTask+0x178>
	{
		print_dbg_char(file_getc());				// Display next char from file.
	}
	file_close();									// Close the file.
80009468:	f0 1f 00 25 	mcall	800094fc <fsTask+0x21c>

	nav_exit();										// Cerramos sistemas de archivos
8000946c:	f0 1f 00 29 	mcall	80009510 <fsTask+0x230>
80009470:	c0 08       	rjmp	80009470 <fsTask+0x190>
80009472:	00 00       	add	r0,r0
80009474:	80 00       	ld.sh	r0,r0[0x0]
80009476:	5c e8       	tnbz	r8
80009478:	80 01       	ld.sh	r1,r0[0x0]
8000947a:	af e8       	*unknown*
8000947c:	80 00       	ld.sh	r0,r0[0x0]
8000947e:	69 a4       	ld.w	r4,r4[0x68]
80009480:	80 00       	ld.sh	r0,r0[0x0]
80009482:	5b 38       	cp.w	r8,-13
80009484:	80 01       	ld.sh	r1,r0[0x0]
80009486:	af f8       	*unknown*
80009488:	80 00       	ld.sh	r0,r0[0x0]
8000948a:	69 90       	ld.w	r0,r4[0x64]
8000948c:	80 01       	ld.sh	r1,r0[0x0]
8000948e:	b0 08       	st.h	r8[0x0],r8
80009490:	80 00       	ld.sh	r0,r0[0x0]
80009492:	54 54       	stdsp	sp[0x114],r4
80009494:	80 00       	ld.sh	r0,r0[0x0]
80009496:	69 34       	ld.w	r4,r4[0x4c]
80009498:	80 01       	ld.sh	r1,r0[0x0]
8000949a:	b0 1c       	st.h	r8[0x2],r12
8000949c:	80 00       	ld.sh	r0,r0[0x0]
8000949e:	68 e4       	ld.w	r4,r4[0x38]
800094a0:	80 01       	ld.sh	r1,r0[0x0]
800094a2:	ae 7c       	st.h	r7[0xe],r12
800094a4:	80 00       	ld.sh	r0,r0[0x0]
800094a6:	5a 50       	cp.w	r0,-27
800094a8:	80 01       	ld.sh	r1,r0[0x0]
800094aa:	b0 20       	st.h	r8[0x4],r0
800094ac:	80 00       	ld.sh	r0,r0[0x0]
800094ae:	59 fc       	cp.w	r12,31
800094b0:	00 00       	add	r0,r0
800094b2:	77 28       	ld.w	r8,r11[0x48]
800094b4:	80 00       	ld.sh	r0,r0[0x0]
800094b6:	54 48       	stdsp	sp[0x110],r8
800094b8:	80 00       	ld.sh	r0,r0[0x0]
800094ba:	5a cc       	cp.w	r12,-20
800094bc:	80 00       	ld.sh	r0,r0[0x0]
800094be:	59 c0       	cp.w	r0,28
800094c0:	00 00       	add	r0,r0
800094c2:	77 48       	ld.w	r8,r11[0x50]
800094c4:	80 00       	ld.sh	r0,r0[0x0]
800094c6:	57 80       	stdsp	sp[0x1e0],r0
800094c8:	80 00       	ld.sh	r0,r0[0x0]
800094ca:	58 84       	cp.w	r4,8
800094cc:	80 00       	ld.sh	r0,r0[0x0]
800094ce:	56 c8       	stdsp	sp[0x1b0],r8
800094d0:	80 01       	ld.sh	r1,r0[0x0]
800094d2:	b0 30       	st.h	r8[0x6],r0
800094d4:	80 00       	ld.sh	r0,r0[0x0]
800094d6:	58 c4       	cp.w	r4,12
800094d8:	80 01       	ld.sh	r1,r0[0x0]
800094da:	b0 40       	st.h	r8[0x8],r0
800094dc:	80 01       	ld.sh	r1,r0[0x0]
800094de:	b0 54       	st.h	r8[0xa],r4
800094e0:	80 00       	ld.sh	r0,r0[0x0]
800094e2:	55 60       	stdsp	sp[0x158],r0
800094e4:	80 01       	ld.sh	r1,r0[0x0]
800094e6:	b0 6c       	st.h	r8[0xc],r12
800094e8:	80 01       	ld.sh	r1,r0[0x0]
800094ea:	b0 84       	st.b	r8[0x0],r4
800094ec:	80 01       	ld.sh	r1,r0[0x0]
800094ee:	ae 28       	st.h	r7[0x4],r8
800094f0:	80 00       	ld.sh	r0,r0[0x0]
800094f2:	53 a8       	stdsp	sp[0xe8],r8
800094f4:	80 00       	ld.sh	r0,r0[0x0]
800094f6:	53 3c       	stdsp	sp[0xcc],r12
800094f8:	80 00       	ld.sh	r0,r0[0x0]
800094fa:	52 dc       	stdsp	sp[0xb4],r12
800094fc:	80 00       	ld.sh	r0,r0[0x0]
800094fe:	53 00       	stdsp	sp[0xc0],r0
80009500:	80 00       	ld.sh	r0,r0[0x0]
80009502:	7f ec       	ld.w	r12,pc[0x78]
80009504:	80 01       	ld.sh	r1,r0[0x0]
80009506:	b0 a8       	st.b	r8[0x2],r8
80009508:	80 00       	ld.sh	r0,r0[0x0]
8000950a:	59 34       	cp.w	r4,19
8000950c:	80 01       	ld.sh	r1,r0[0x0]
8000950e:	b0 c8       	st.b	r8[0x4],r8
80009510:	80 00       	ld.sh	r0,r0[0x0]
80009512:	5a a4       	cp.w	r4,-22

80009514 <qtButtonTask>:
}

// qtHandle
portTASK_FUNCTION_PROTO( qtButtonTask, p );
portTASK_FUNCTION( qtButtonTask, p )
{
80009514:	d4 31       	pushm	r0-r7,lr
	gpio_set_gpio_pin(LED0_GPIO);
80009516:	33 bc       	mov	r12,59
80009518:	f0 1f 00 a3 	mcall	800097a4 <qtButtonTask+0x290>
	gpio_set_gpio_pin(LED1_GPIO);
8000951c:	33 cc       	mov	r12,60
8000951e:	f0 1f 00 a2 	mcall	800097a4 <qtButtonTask+0x290>
	gpio_set_gpio_pin(LED2_GPIO);
80009522:	30 5c       	mov	r12,5
80009524:	f0 1f 00 a0 	mcall	800097a4 <qtButtonTask+0x290>
	gpio_set_gpio_pin(LED3_GPIO);
80009528:	30 6c       	mov	r12,6
8000952a:	f0 1f 00 9f 	mcall	800097a4 <qtButtonTask+0x290>

	static uint16_t samplesToMove;
	static uint8_t lrValue = 0;
	static uint8_t udValue = 0;
	forwardQueue = xQueueCreate( 1 , sizeof(uint16_t));
8000952e:	30 0a       	mov	r10,0
80009530:	30 2b       	mov	r11,2
80009532:	30 1c       	mov	r12,1
80009534:	f0 1f 00 9d 	mcall	800097a8 <qtButtonTask+0x294>
80009538:	fe f8 02 74 	ld.w	r8,pc[628]
8000953c:	91 0c       	st.w	r8[0x0],r12
	reverseQueue = xQueueCreate( 1 , sizeof(uint16_t));
8000953e:	30 0a       	mov	r10,0
80009540:	30 2b       	mov	r11,2
80009542:	30 1c       	mov	r12,1
80009544:	f0 1f 00 99 	mcall	800097a8 <qtButtonTask+0x294>
80009548:	fe f8 02 68 	ld.w	r8,pc[616]
8000954c:	91 0c       	st.w	r8[0x0],r12
	repUdQueue = xQueueCreate( 1 , sizeof(uint8_t));
8000954e:	30 0a       	mov	r10,0
80009550:	30 1b       	mov	r11,1
80009552:	16 9c       	mov	r12,r11
80009554:	f0 1f 00 95 	mcall	800097a8 <qtButtonTask+0x294>
80009558:	fe f8 02 5c 	ld.w	r8,pc[604]
8000955c:	91 0c       	st.w	r8[0x0],r12
	repLrQueue = xQueueCreate( 1 , sizeof(uint8_t));
8000955e:	30 0a       	mov	r10,0
80009560:	30 1b       	mov	r11,1
80009562:	16 9c       	mov	r12,r11
80009564:	f0 1f 00 91 	mcall	800097a8 <qtButtonTask+0x294>
80009568:	fe f8 02 50 	ld.w	r8,pc[592]
8000956c:	91 0c       	st.w	r8[0x0],r12
	mainUdQueue = xQueueCreate( 1 , sizeof(uint8_t));
8000956e:	30 0a       	mov	r10,0
80009570:	30 1b       	mov	r11,1
80009572:	16 9c       	mov	r12,r11
80009574:	f0 1f 00 8d 	mcall	800097a8 <qtButtonTask+0x294>
80009578:	fe f8 02 44 	ld.w	r8,pc[580]
8000957c:	91 0c       	st.w	r8[0x0],r12
	mainLrQueue = xQueueCreate( 1 , sizeof(uint8_t));
8000957e:	30 0a       	mov	r10,0
80009580:	30 1b       	mov	r11,1
80009582:	16 9c       	mov	r12,r11
80009584:	f0 1f 00 89 	mcall	800097a8 <qtButtonTask+0x294>
80009588:	fe f8 02 38 	ld.w	r8,pc[568]
8000958c:	91 0c       	st.w	r8[0x0],r12

	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
8000958e:	30 06       	mov	r6,0
		if (INTC_QT_FLAG._left) {
80009590:	fe f7 02 34 	ld.w	r7,pc[564]
80009594:	30 05       	mov	r5,0
			INTC_QT_FLAG._left = false;
			//gpio_tgl_gpio_pin(LED0_GPIO);
			if (state == REPRODUCIR)
80009596:	fe f3 02 32 	ld.w	r3,pc[562]
				xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
				vTaskResume(etHandle);
			}
			else
			{
				samplesToMove = 4096;
8000959a:	fe f1 02 32 	ld.w	r1,pc[562]
8000959e:	e0 60 10 00 	mov	r0,4096
				xQueueSend( repLrQueue, &lrValue, (TickType_t) 0);
				vTaskResume(etHandle);
			}
			else if(state == MAIN)
			{
				lrValue = (lrValue > 0) ? lrValue - 1 : lrValue;
800095a2:	fe f4 02 2e 	ld.w	r4,pc[558]
				xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
800095a6:	10 92       	mov	r2,r8
	mainUdQueue = xQueueCreate( 1 , sizeof(uint8_t));
	mainLrQueue = xQueueCreate( 1 , sizeof(uint8_t));

	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
800095a8:	0c 9c       	mov	r12,r6
800095aa:	f0 1f 00 8b 	mcall	800097d4 <qtButtonTask+0x2c0>
		if (INTC_QT_FLAG._left) {
800095ae:	0f 88       	ld.ub	r8,r7[0x0]
800095b0:	10 99       	mov	r9,r8
800095b2:	e2 19 00 40 	andl	r9,0x40,COH
800095b6:	ea 09 18 00 	cp.b	r9,r5
800095ba:	c3 40       	breq	80009622 <qtButtonTask+0x10e>
			INTC_QT_FLAG._left = false;
800095bc:	0f 88       	ld.ub	r8,r7[0x0]
800095be:	f1 d6 d0 c1 	bfins	r8,r6,0x6,0x1
800095c2:	ae 88       	st.b	r7[0x0],r8
			//gpio_tgl_gpio_pin(LED0_GPIO);
			if (state == REPRODUCIR)
800095c4:	66 08       	ld.w	r8,r3[0x0]
800095c6:	58 18       	cp.w	r8,1
800095c8:	c1 21       	brne	800095ec <qtButtonTask+0xd8>
			{		
				lrValue = (lrValue > 0) ? lrValue - 1 : lrValue;
800095ca:	09 88       	ld.ub	r8,r4[0x0]
800095cc:	58 08       	cp.w	r8,0
800095ce:	c0 20       	breq	800095d2 <qtButtonTask+0xbe>
800095d0:	20 18       	sub	r8,1
800095d2:	a8 88       	st.b	r4[0x0],r8
				xQueueSend( repLrQueue, &lrValue, (TickType_t) 0);
800095d4:	0c 99       	mov	r9,r6
800095d6:	0c 9a       	mov	r10,r6
800095d8:	08 9b       	mov	r11,r4
800095da:	4f 88       	lddpc	r8,800097b8 <qtButtonTask+0x2a4>
800095dc:	70 0c       	ld.w	r12,r8[0x0]
800095de:	f0 1f 00 7f 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
800095e2:	4f f8       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
800095e4:	70 0c       	ld.w	r12,r8[0x0]
800095e6:	f0 1f 00 7f 	mcall	800097e0 <qtButtonTask+0x2cc>
800095ea:	cd fb       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			else if(state == MAIN)
800095ec:	58 08       	cp.w	r8,0
800095ee:	c1 11       	brne	80009610 <qtButtonTask+0xfc>
			{
				lrValue = (lrValue > 0) ? lrValue - 1 : lrValue;
800095f0:	09 88       	ld.ub	r8,r4[0x0]
800095f2:	58 08       	cp.w	r8,0
800095f4:	c0 20       	breq	800095f8 <qtButtonTask+0xe4>
800095f6:	20 18       	sub	r8,1
800095f8:	a8 88       	st.b	r4[0x0],r8
				xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
800095fa:	0c 99       	mov	r9,r6
800095fc:	0c 9a       	mov	r10,r6
800095fe:	08 9b       	mov	r11,r4
80009600:	64 0c       	ld.w	r12,r2[0x0]
80009602:	f0 1f 00 76 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
80009606:	4f 68       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
80009608:	70 0c       	ld.w	r12,r8[0x0]
8000960a:	f0 1f 00 76 	mcall	800097e0 <qtButtonTask+0x2cc>
8000960e:	cc db       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			else
			{
				samplesToMove = 4096;
80009610:	a2 00       	st.h	r1[0x0],r0
				xQueueSend( reverseQueue, &samplesToMove, (TickType_t) 0 );
80009612:	0c 99       	mov	r9,r6
80009614:	0c 9a       	mov	r10,r6
80009616:	02 9b       	mov	r11,r1
80009618:	4e 68       	lddpc	r8,800097b0 <qtButtonTask+0x29c>
8000961a:	70 0c       	ld.w	r12,r8[0x0]
8000961c:	f0 1f 00 6f 	mcall	800097d8 <qtButtonTask+0x2c4>
80009620:	cc 4b       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			
		}
		else if (INTC_QT_FLAG._right) {
80009622:	10 99       	mov	r9,r8
80009624:	e2 19 00 20 	andl	r9,0x20,COH
80009628:	ea 09 18 00 	cp.b	r9,r5
8000962c:	c3 a0       	breq	800096a0 <qtButtonTask+0x18c>
			INTC_QT_FLAG._right = false;
8000962e:	0f 88       	ld.ub	r8,r7[0x0]
80009630:	f1 d6 d0 a1 	bfins	r8,r6,0x5,0x1
80009634:	ae 88       	st.b	r7[0x0],r8
			//gpio_tgl_gpio_pin(LED1_GPIO);
			if (state == REPRODUCIR)
80009636:	66 08       	ld.w	r8,r3[0x0]
80009638:	58 18       	cp.w	r8,1
8000963a:	c1 51       	brne	80009664 <qtButtonTask+0x150>
			{
				lrValue = (lrValue + 1 <= 2) ? lrValue + 1 : lrValue;
8000963c:	09 88       	ld.ub	r8,r4[0x0]
8000963e:	f0 c9 ff ff 	sub	r9,r8,-1
80009642:	58 29       	cp.w	r9,2
80009644:	e0 89 00 03 	brgt	8000964a <qtButtonTask+0x136>
80009648:	2f f8       	sub	r8,-1
8000964a:	a8 88       	st.b	r4[0x0],r8
				xQueueSend( repLrQueue, &lrValue, (TickType_t) 0);
8000964c:	0c 99       	mov	r9,r6
8000964e:	0c 9a       	mov	r10,r6
80009650:	08 9b       	mov	r11,r4
80009652:	4d a8       	lddpc	r8,800097b8 <qtButtonTask+0x2a4>
80009654:	70 0c       	ld.w	r12,r8[0x0]
80009656:	f0 1f 00 61 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
8000965a:	4e 18       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
8000965c:	70 0c       	ld.w	r12,r8[0x0]
8000965e:	f0 1f 00 61 	mcall	800097e0 <qtButtonTask+0x2cc>
80009662:	ca 3b       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			else if(state == MAIN)
80009664:	58 08       	cp.w	r8,0
80009666:	c1 41       	brne	8000968e <qtButtonTask+0x17a>
			{
				lrValue = (lrValue + 1 <= 2) ? lrValue + 1 : lrValue;
80009668:	09 88       	ld.ub	r8,r4[0x0]
8000966a:	f0 c9 ff ff 	sub	r9,r8,-1
8000966e:	58 29       	cp.w	r9,2
80009670:	e0 89 00 03 	brgt	80009676 <qtButtonTask+0x162>
80009674:	2f f8       	sub	r8,-1
80009676:	a8 88       	st.b	r4[0x0],r8
				xQueueSend( mainLrQueue, &lrValue, (TickType_t) 0);
80009678:	0c 99       	mov	r9,r6
8000967a:	0c 9a       	mov	r10,r6
8000967c:	08 9b       	mov	r11,r4
8000967e:	64 0c       	ld.w	r12,r2[0x0]
80009680:	f0 1f 00 56 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
80009684:	4d 68       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
80009686:	70 0c       	ld.w	r12,r8[0x0]
80009688:	f0 1f 00 56 	mcall	800097e0 <qtButtonTask+0x2cc>
8000968c:	c8 eb       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			else
			{
				samplesToMove = 4096;
8000968e:	a2 00       	st.h	r1[0x0],r0
				xQueueSend( forwardQueue, &samplesToMove, (TickType_t) 0 );
80009690:	0c 99       	mov	r9,r6
80009692:	0c 9a       	mov	r10,r6
80009694:	02 9b       	mov	r11,r1
80009696:	4c 68       	lddpc	r8,800097ac <qtButtonTask+0x298>
80009698:	70 0c       	ld.w	r12,r8[0x0]
8000969a:	f0 1f 00 50 	mcall	800097d8 <qtButtonTask+0x2c4>
8000969e:	c8 5b       	rjmp	800095a8 <qtButtonTask+0x94>
			}
		}
		else if (INTC_QT_FLAG._up) {
800096a0:	10 99       	mov	r9,r8
800096a2:	e2 19 00 10 	andl	r9,0x10,COH
800096a6:	ea 09 18 00 	cp.b	r9,r5
800096aa:	c2 f0       	breq	80009708 <qtButtonTask+0x1f4>
			INTC_QT_FLAG._up = false;
800096ac:	0f 88       	ld.ub	r8,r7[0x0]
800096ae:	f1 d6 d0 81 	bfins	r8,r6,0x4,0x1
800096b2:	ae 88       	st.b	r7[0x0],r8
			//gpio_tgl_gpio_pin(LED2_GPIO);
			if (state == REPRODUCIR)
800096b4:	66 08       	ld.w	r8,r3[0x0]
800096b6:	58 18       	cp.w	r8,1
800096b8:	c1 31       	brne	800096de <qtButtonTask+0x1ca>
			{
				udValue = (udValue > 0) ? udValue - 1 : udValue;
800096ba:	4c b8       	lddpc	r8,800097e4 <qtButtonTask+0x2d0>
800096bc:	11 88       	ld.ub	r8,r8[0x0]
800096be:	58 08       	cp.w	r8,0
800096c0:	c0 20       	breq	800096c4 <qtButtonTask+0x1b0>
800096c2:	20 18       	sub	r8,1
800096c4:	4c 8b       	lddpc	r11,800097e4 <qtButtonTask+0x2d0>
800096c6:	b6 88       	st.b	r11[0x0],r8
				xQueueSend( repUdQueue, &udValue, (TickType_t) 0);
800096c8:	0c 99       	mov	r9,r6
800096ca:	0c 9a       	mov	r10,r6
800096cc:	4b a8       	lddpc	r8,800097b4 <qtButtonTask+0x2a0>
800096ce:	70 0c       	ld.w	r12,r8[0x0]
800096d0:	f0 1f 00 42 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
800096d4:	4c 28       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
800096d6:	70 0c       	ld.w	r12,r8[0x0]
800096d8:	f0 1f 00 42 	mcall	800097e0 <qtButtonTask+0x2cc>
800096dc:	c6 6b       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			else if(state == MAIN)
800096de:	58 08       	cp.w	r8,0
800096e0:	fe 91 ff 64 	brne	800095a8 <qtButtonTask+0x94>
			{
				udValue = (udValue > 0) ? udValue - 1 : udValue;
800096e4:	4c 08       	lddpc	r8,800097e4 <qtButtonTask+0x2d0>
800096e6:	11 88       	ld.ub	r8,r8[0x0]
800096e8:	58 08       	cp.w	r8,0
800096ea:	c0 20       	breq	800096ee <qtButtonTask+0x1da>
800096ec:	20 18       	sub	r8,1
800096ee:	4b eb       	lddpc	r11,800097e4 <qtButtonTask+0x2d0>
800096f0:	b6 88       	st.b	r11[0x0],r8
				xQueueSend( mainUdQueue, &udValue, (TickType_t) 0);
800096f2:	0c 99       	mov	r9,r6
800096f4:	0c 9a       	mov	r10,r6
800096f6:	4b 28       	lddpc	r8,800097bc <qtButtonTask+0x2a8>
800096f8:	70 0c       	ld.w	r12,r8[0x0]
800096fa:	f0 1f 00 38 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
800096fe:	4b 88       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
80009700:	70 0c       	ld.w	r12,r8[0x0]
80009702:	f0 1f 00 38 	mcall	800097e0 <qtButtonTask+0x2cc>
80009706:	c5 1b       	rjmp	800095a8 <qtButtonTask+0x94>
			}
		}
		else if (INTC_QT_FLAG._down) {
80009708:	10 99       	mov	r9,r8
8000970a:	e2 19 00 08 	andl	r9,0x8,COH
8000970e:	ea 09 18 00 	cp.b	r9,r5
80009712:	c3 50       	breq	8000977c <qtButtonTask+0x268>
			INTC_QT_FLAG._down = false;
80009714:	0f 88       	ld.ub	r8,r7[0x0]
80009716:	f1 d6 d0 61 	bfins	r8,r6,0x3,0x1
8000971a:	ae 88       	st.b	r7[0x0],r8
			//gpio_tgl_gpio_pin(LED3_GPIO);
			if (state == REPRODUCIR)
8000971c:	66 08       	ld.w	r8,r3[0x0]
8000971e:	58 18       	cp.w	r8,1
80009720:	c1 61       	brne	8000974c <qtButtonTask+0x238>
			{
				udValue = (udValue + 1 <= 2) ? udValue + 1 : udValue;
80009722:	4b 18       	lddpc	r8,800097e4 <qtButtonTask+0x2d0>
80009724:	11 88       	ld.ub	r8,r8[0x0]
80009726:	f0 c9 ff ff 	sub	r9,r8,-1
8000972a:	58 29       	cp.w	r9,2
8000972c:	e0 89 00 03 	brgt	80009732 <qtButtonTask+0x21e>
80009730:	2f f8       	sub	r8,-1
80009732:	4a db       	lddpc	r11,800097e4 <qtButtonTask+0x2d0>
80009734:	b6 88       	st.b	r11[0x0],r8
				xQueueSend( repUdQueue, &udValue, (TickType_t) 0);
80009736:	0c 99       	mov	r9,r6
80009738:	0c 9a       	mov	r10,r6
8000973a:	49 f8       	lddpc	r8,800097b4 <qtButtonTask+0x2a0>
8000973c:	70 0c       	ld.w	r12,r8[0x0]
8000973e:	f0 1f 00 27 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
80009742:	4a 78       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
80009744:	70 0c       	ld.w	r12,r8[0x0]
80009746:	f0 1f 00 27 	mcall	800097e0 <qtButtonTask+0x2cc>
8000974a:	c2 fb       	rjmp	800095a8 <qtButtonTask+0x94>
			}
			else if(state == MAIN)
8000974c:	58 08       	cp.w	r8,0
8000974e:	fe 91 ff 2d 	brne	800095a8 <qtButtonTask+0x94>
			{
				udValue = (udValue + 1 <= 2) ? udValue + 1 : udValue;
80009752:	4a 58       	lddpc	r8,800097e4 <qtButtonTask+0x2d0>
80009754:	11 88       	ld.ub	r8,r8[0x0]
80009756:	f0 c9 ff ff 	sub	r9,r8,-1
8000975a:	58 29       	cp.w	r9,2
8000975c:	e0 89 00 03 	brgt	80009762 <qtButtonTask+0x24e>
80009760:	2f f8       	sub	r8,-1
80009762:	4a 1b       	lddpc	r11,800097e4 <qtButtonTask+0x2d0>
80009764:	b6 88       	st.b	r11[0x0],r8
				xQueueSend( mainUdQueue, &udValue, (TickType_t) 0);
80009766:	0c 99       	mov	r9,r6
80009768:	0c 9a       	mov	r10,r6
8000976a:	49 58       	lddpc	r8,800097bc <qtButtonTask+0x2a8>
8000976c:	70 0c       	ld.w	r12,r8[0x0]
8000976e:	f0 1f 00 1b 	mcall	800097d8 <qtButtonTask+0x2c4>
				vTaskResume(etHandle);
80009772:	49 b8       	lddpc	r8,800097dc <qtButtonTask+0x2c8>
80009774:	70 0c       	ld.w	r12,r8[0x0]
80009776:	f0 1f 00 1b 	mcall	800097e0 <qtButtonTask+0x2cc>
8000977a:	c1 7b       	rjmp	800095a8 <qtButtonTask+0x94>
			}
		}
		else if (INTC_QT_FLAG._enter) {
8000977c:	e0 18 ff 80 	andl	r8,0xff80
80009780:	ea 08 18 00 	cp.b	r8,r5
80009784:	fe 90 ff 12 	breq	800095a8 <qtButtonTask+0x94>
			INTC_QT_FLAG._enter = false;
80009788:	0f 88       	ld.ub	r8,r7[0x0]
8000978a:	f1 d6 d0 e1 	bfins	r8,r6,0x7,0x1
8000978e:	ae 88       	st.b	r7[0x0],r8
			xTaskNotifyGive(audioHandle);
80009790:	0c 98       	mov	r8,r6
80009792:	30 29       	mov	r9,2
80009794:	0c 9a       	mov	r10,r6
80009796:	0c 9b       	mov	r11,r6
80009798:	49 4c       	lddpc	r12,800097e8 <qtButtonTask+0x2d4>
8000979a:	78 0c       	ld.w	r12,r12[0x0]
8000979c:	f0 1f 00 14 	mcall	800097ec <qtButtonTask+0x2d8>
800097a0:	c0 4b       	rjmp	800095a8 <qtButtonTask+0x94>
800097a2:	00 00       	add	r0,r0
800097a4:	80 00       	ld.sh	r0,r0[0x0]
800097a6:	84 8c       	ld.uh	r12,r2[0x0]
800097a8:	80 00       	ld.sh	r0,r0[0x0]
800097aa:	76 5c       	ld.w	r12,r11[0x14]
800097ac:	00 00       	add	r0,r0
800097ae:	7d 38       	ld.w	r8,lr[0x4c]
800097b0:	00 00       	add	r0,r0
800097b2:	7c f0       	ld.w	r0,lr[0x3c]
800097b4:	00 00       	add	r0,r0
800097b6:	7d 30       	ld.w	r0,lr[0x4c]
800097b8:	00 00       	add	r0,r0
800097ba:	7d 20       	ld.w	r0,lr[0x48]
800097bc:	00 00       	add	r0,r0
800097be:	7d 24       	ld.w	r4,lr[0x48]
800097c0:	00 00       	add	r0,r0
800097c2:	7d 34       	ld.w	r4,lr[0x4c]
800097c4:	00 00       	add	r0,r0
800097c6:	7d 1c       	ld.w	r12,lr[0x44]
800097c8:	00 00       	add	r0,r0
800097ca:	77 2c       	ld.w	r12,r11[0x48]
800097cc:	00 00       	add	r0,r0
800097ce:	77 68       	ld.w	r8,r11[0x58]
800097d0:	00 00       	add	r0,r0
800097d2:	77 71       	ld.w	r1,r11[0x5c]
800097d4:	80 00       	ld.sh	r0,r0[0x0]
800097d6:	7e 04       	ld.w	r4,pc[0x0]
800097d8:	80 00       	ld.sh	r0,r0[0x0]
800097da:	74 c8       	ld.w	r8,r10[0x30]
800097dc:	00 00       	add	r0,r0
800097de:	77 30       	ld.w	r0,r11[0x4c]
800097e0:	80 00       	ld.sh	r0,r0[0x0]
800097e2:	7d 84       	ld.w	r4,lr[0x60]
800097e4:	00 00       	add	r0,r0
800097e6:	77 70       	ld.w	r0,r11[0x5c]
800097e8:	00 00       	add	r0,r0
800097ea:	77 20       	ld.w	r0,r11[0x48]
800097ec:	80 00       	ld.sh	r0,r0[0x0]
800097ee:	78 18       	ld.w	r8,r12[0x4]

800097f0 <playAudioTask>:
}

// audioHandle
portTASK_FUNCTION_PROTO(playAudioTask, p );
portTASK_FUNCTION(playAudioTask, p )
{
800097f0:	d4 31       	pushm	r0-r7,lr
	static bool notify	  = false;
	static uint16_t samplesRx;

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
800097f2:	30 12       	mov	r2,1
800097f4:	30 03       	mov	r3,0
800097f6:	4b 11       	lddpc	r1,800098b8 <playAudioTask+0xc8>

		if (notificationValue > 0)
		{
			//playAudio = !playAudio;
			notify = !notify;
800097f8:	4b 16       	lddpc	r6,800098bc <playAudioTask+0xcc>
			//}
		}

		if (playAudio)
		{
			playAudio = false;
800097fa:	4b 25       	lddpc	r5,800098c0 <playAudioTask+0xd0>
800097fc:	30 04       	mov	r4,0
800097fe:	4b 20       	lddpc	r0,800098c4 <playAudioTask+0xd4>
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)letdownsong[i]+0x80) << 8; 
80009800:	4b 27       	lddpc	r7,800098c8 <playAudioTask+0xd8>
	static bool notify	  = false;
	static uint16_t samplesRx;

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
80009802:	04 9a       	mov	r10,r2
80009804:	04 9b       	mov	r11,r2
80009806:	06 9c       	mov	r12,r3
80009808:	f0 1f 00 31 	mcall	800098cc <playAudioTask+0xdc>
8000980c:	83 0c       	st.w	r1[0x0],r12

		if (notificationValue > 0)
8000980e:	e0 8a 00 06 	brle	8000981a <playAudioTask+0x2a>
		{
			//playAudio = !playAudio;
			notify = !notify;
80009812:	0d 88       	ld.ub	r8,r6[0x0]
80009814:	ec 18 00 01 	eorl	r8,0x1
80009818:	ac 88       	st.b	r6[0x0],r8
			//print_dbg("Notification received.");

		}

		if ((pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE) && (notify == true))
8000981a:	06 9c       	mov	r12,r3
8000981c:	f0 1f 00 2d 	mcall	800098d0 <playAudioTask+0xe0>
80009820:	e2 1c 00 02 	andl	r12,0x2,COH
80009824:	c1 90       	breq	80009856 <playAudioTask+0x66>
80009826:	0d 88       	ld.ub	r8,r6[0x0]
80009828:	e8 08 18 00 	cp.b	r8,r4
8000982c:	c1 50       	breq	80009856 <playAudioTask+0x66>
		{
			playAudio = true;
8000982e:	30 18       	mov	r8,1
80009830:	aa 88       	st.b	r5[0x0],r8
			//print_dbg("Running audio...\r\n");

			if (forwardQueue != 0)
80009832:	4a 98       	lddpc	r8,800098d4 <playAudioTask+0xe4>
80009834:	70 0c       	ld.w	r12,r8[0x0]
80009836:	58 0c       	cp.w	r12,0
80009838:	c1 30       	breq	8000985e <playAudioTask+0x6e>
			{
				if (xQueueReceive( forwardQueue, &samplesRx, (TickType_t) 2 ))
8000983a:	30 2a       	mov	r10,2
8000983c:	4a 7b       	lddpc	r11,800098d8 <playAudioTask+0xe8>
8000983e:	f0 1f 00 28 	mcall	800098dc <playAudioTask+0xec>
80009842:	c0 a0       	breq	80009856 <playAudioTask+0x66>
				{
					i = ( (i + samplesRx) <= sizeof(letdownsong) ) ? (i + samplesRx) : i;
80009844:	60 09       	ld.w	r9,r0[0x0]
80009846:	4a 58       	lddpc	r8,800098d8 <playAudioTask+0xe8>
80009848:	90 88       	ld.uh	r8,r8[0x0]
8000984a:	12 08       	add	r8,r9
8000984c:	e0 48 6f 79 	cp.w	r8,28537
80009850:	f2 08 17 20 	movhs	r8,r9
80009854:	81 08       	st.w	r0[0x0],r8
					//i = (i > samplesRx) ? (i - samplesRx) : i;
				//}
			//}
		}

		if (playAudio)
80009856:	0b 88       	ld.ub	r8,r5[0x0]
80009858:	e8 08 18 00 	cp.b	r8,r4
8000985c:	cd 30       	breq	80009802 <playAudioTask+0x12>
		{
			playAudio = false;
8000985e:	aa 84       	st.b	r5[0x0],r4
80009860:	60 08       	ld.w	r8,r0[0x0]
80009862:	4a 09       	lddpc	r9,800098e0 <playAudioTask+0xf0>
80009864:	30 2a       	mov	r10,2
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)letdownsong[i]+0x80) << 8; 
80009866:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8000986a:	28 0b       	sub	r11,-128
8000986c:	a9 6b       	lsl	r11,0x8
8000986e:	b2 0b       	st.h	r9[0x0],r11
				samples[count++] = ((uint8_t)letdownsong[i]+0x80) << 8;
80009870:	b2 1b       	st.h	r9[0x2],r11
				i++;
80009872:	2f f8       	sub	r8,-1
				if (i >= sizeof(letdownsong)) i = 0;
80009874:	e0 48 6f 78 	cp.w	r8,28536
80009878:	f9 b8 02 00 	movhs	r8,0
8000987c:	f4 cb ff fe 	sub	r11,r10,-2
80009880:	2f c9       	sub	r9,-4
		if (playAudio)
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
80009882:	e0 4a 00 ff 	cp.w	r10,255
80009886:	e0 8b 00 04 	brhi	8000988e <playAudioTask+0x9e>
8000988a:	16 9a       	mov	r10,r11
8000988c:	ce db       	rjmp	80009866 <playAudioTask+0x76>
8000988e:	81 08       	st.w	r0[0x0],r8
80009890:	49 58       	lddpc	r8,800098e4 <playAudioTask+0xf4>
80009892:	91 0a       	st.w	r8[0x0],r10
				samples[count++] = ((uint8_t)letdownsong[i]+0x80) << 8;
				i++;
				if (i >= sizeof(letdownsong)) i = 0;
			}

			gpio_set_gpio_pin(LED0_GPIO);
80009894:	33 bc       	mov	r12,59
80009896:	f0 1f 00 15 	mcall	800098e8 <playAudioTask+0xf8>
			gpio_clr_gpio_pin(LED1_GPIO);
8000989a:	33 cc       	mov	r12,60
8000989c:	f0 1f 00 14 	mcall	800098ec <playAudioTask+0xfc>

			// Play buffer
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
800098a0:	e0 6b 00 80 	mov	r11,128
800098a4:	48 fc       	lddpc	r12,800098e0 <playAudioTask+0xf0>
800098a6:	f0 1f 00 13 	mcall	800098f0 <playAudioTask+0x100>

			gpio_clr_gpio_pin(LED0_GPIO);
800098aa:	33 bc       	mov	r12,59
800098ac:	f0 1f 00 10 	mcall	800098ec <playAudioTask+0xfc>
			gpio_set_gpio_pin(LED1_GPIO);
800098b0:	33 cc       	mov	r12,60
800098b2:	f0 1f 00 0e 	mcall	800098e8 <playAudioTask+0xf8>
800098b6:	ca 6b       	rjmp	80009802 <playAudioTask+0x12>
800098b8:	00 00       	add	r0,r0
800098ba:	77 74       	ld.w	r4,r11[0x5c]
800098bc:	00 00       	add	r0,r0
800098be:	77 44       	ld.w	r4,r11[0x50]
800098c0:	00 00       	add	r0,r0
800098c2:	77 45       	ld.w	r5,r11[0x50]
800098c4:	00 00       	add	r0,r0
800098c6:	77 40       	ld.w	r0,r11[0x50]
800098c8:	00 00       	add	r0,r0
800098ca:	00 1c       	sub	r12,r0
800098cc:	80 00       	ld.sh	r0,r0[0x0]
800098ce:	7f 54       	ld.w	r4,pc[0x54]
800098d0:	80 00       	ld.sh	r0,r0[0x0]
800098d2:	64 ac       	ld.w	r12,r2[0x28]
800098d4:	00 00       	add	r0,r0
800098d6:	7d 38       	ld.w	r8,lr[0x4c]
800098d8:	00 00       	add	r0,r0
800098da:	77 3e       	ld.w	lr,r11[0x4c]
800098dc:	80 00       	ld.sh	r0,r0[0x0]
800098de:	71 d8       	ld.w	r8,r8[0x74]
800098e0:	00 00       	add	r0,r0
800098e2:	7d 3c       	ld.w	r12,lr[0x4c]
800098e4:	00 00       	add	r0,r0
800098e6:	77 38       	ld.w	r8,r11[0x4c]
800098e8:	80 00       	ld.sh	r0,r0[0x0]
800098ea:	84 8c       	ld.uh	r12,r2[0x0]
800098ec:	80 00       	ld.sh	r0,r0[0x0]
800098ee:	84 a8       	ld.uh	r8,r2[0x4]
800098f0:	80 00       	ld.sh	r0,r0[0x0]
800098f2:	5e f0       	retal	r0

800098f4 <__avr32_udiv64>:
800098f4:	d4 31       	pushm	r0-r7,lr
800098f6:	1a 97       	mov	r7,sp
800098f8:	20 3d       	sub	sp,12
800098fa:	10 9c       	mov	r12,r8
800098fc:	12 9e       	mov	lr,r9
800098fe:	14 93       	mov	r3,r10
80009900:	58 09       	cp.w	r9,0
80009902:	e0 81 00 bd 	brne	80009a7c <__avr32_udiv64+0x188>
80009906:	16 38       	cp.w	r8,r11
80009908:	e0 88 00 40 	brls	80009988 <__avr32_udiv64+0x94>
8000990c:	f0 08 12 00 	clz	r8,r8
80009910:	c0 d0       	breq	8000992a <__avr32_udiv64+0x36>
80009912:	f6 08 09 4b 	lsl	r11,r11,r8
80009916:	f0 09 11 20 	rsub	r9,r8,32
8000991a:	f8 08 09 4c 	lsl	r12,r12,r8
8000991e:	f4 09 0a 49 	lsr	r9,r10,r9
80009922:	f4 08 09 43 	lsl	r3,r10,r8
80009926:	f3 eb 10 0b 	or	r11,r9,r11
8000992a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000992e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009932:	f6 0e 0d 00 	divu	r0,r11,lr
80009936:	e6 0b 16 10 	lsr	r11,r3,0x10
8000993a:	00 99       	mov	r9,r0
8000993c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80009940:	e0 0a 02 48 	mul	r8,r0,r10
80009944:	10 3b       	cp.w	r11,r8
80009946:	c0 a2       	brcc	8000995a <__avr32_udiv64+0x66>
80009948:	20 19       	sub	r9,1
8000994a:	18 0b       	add	r11,r12
8000994c:	18 3b       	cp.w	r11,r12
8000994e:	c0 63       	brcs	8000995a <__avr32_udiv64+0x66>
80009950:	10 3b       	cp.w	r11,r8
80009952:	f7 b9 03 01 	sublo	r9,1
80009956:	f7 dc e3 0b 	addcs	r11,r11,r12
8000995a:	f6 08 01 01 	sub	r1,r11,r8
8000995e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80009962:	e2 0e 0d 00 	divu	r0,r1,lr
80009966:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000996a:	00 98       	mov	r8,r0
8000996c:	e0 0a 02 4a 	mul	r10,r0,r10
80009970:	14 33       	cp.w	r3,r10
80009972:	c0 82       	brcc	80009982 <__avr32_udiv64+0x8e>
80009974:	20 18       	sub	r8,1
80009976:	18 03       	add	r3,r12
80009978:	18 33       	cp.w	r3,r12
8000997a:	c0 43       	brcs	80009982 <__avr32_udiv64+0x8e>
8000997c:	14 33       	cp.w	r3,r10
8000997e:	f7 b8 03 01 	sublo	r8,1
80009982:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80009986:	cd f8       	rjmp	80009b44 <__avr32_udiv64+0x250>
80009988:	58 08       	cp.w	r8,0
8000998a:	c0 51       	brne	80009994 <__avr32_udiv64+0xa0>
8000998c:	30 19       	mov	r9,1
8000998e:	f2 08 0d 08 	divu	r8,r9,r8
80009992:	10 9c       	mov	r12,r8
80009994:	f8 06 12 00 	clz	r6,r12
80009998:	c0 41       	brne	800099a0 <__avr32_udiv64+0xac>
8000999a:	18 1b       	sub	r11,r12
8000999c:	30 19       	mov	r9,1
8000999e:	c4 08       	rjmp	80009a1e <__avr32_udiv64+0x12a>
800099a0:	ec 01 11 20 	rsub	r1,r6,32
800099a4:	f4 01 0a 49 	lsr	r9,r10,r1
800099a8:	f8 06 09 4c 	lsl	r12,r12,r6
800099ac:	f6 06 09 48 	lsl	r8,r11,r6
800099b0:	f6 01 0a 41 	lsr	r1,r11,r1
800099b4:	f3 e8 10 08 	or	r8,r9,r8
800099b8:	f8 03 16 10 	lsr	r3,r12,0x10
800099bc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800099c0:	e2 03 0d 00 	divu	r0,r1,r3
800099c4:	f0 0b 16 10 	lsr	r11,r8,0x10
800099c8:	00 9e       	mov	lr,r0
800099ca:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800099ce:	e0 05 02 49 	mul	r9,r0,r5
800099d2:	12 3b       	cp.w	r11,r9
800099d4:	c0 a2       	brcc	800099e8 <__avr32_udiv64+0xf4>
800099d6:	20 1e       	sub	lr,1
800099d8:	18 0b       	add	r11,r12
800099da:	18 3b       	cp.w	r11,r12
800099dc:	c0 63       	brcs	800099e8 <__avr32_udiv64+0xf4>
800099de:	12 3b       	cp.w	r11,r9
800099e0:	f7 be 03 01 	sublo	lr,1
800099e4:	f7 dc e3 0b 	addcs	r11,r11,r12
800099e8:	12 1b       	sub	r11,r9
800099ea:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
800099ee:	f6 03 0d 02 	divu	r2,r11,r3
800099f2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
800099f6:	04 99       	mov	r9,r2
800099f8:	e4 05 02 4b 	mul	r11,r2,r5
800099fc:	16 38       	cp.w	r8,r11
800099fe:	c0 a2       	brcc	80009a12 <__avr32_udiv64+0x11e>
80009a00:	20 19       	sub	r9,1
80009a02:	18 08       	add	r8,r12
80009a04:	18 38       	cp.w	r8,r12
80009a06:	c0 63       	brcs	80009a12 <__avr32_udiv64+0x11e>
80009a08:	16 38       	cp.w	r8,r11
80009a0a:	f7 b9 03 01 	sublo	r9,1
80009a0e:	f1 dc e3 08 	addcs	r8,r8,r12
80009a12:	f4 06 09 43 	lsl	r3,r10,r6
80009a16:	f0 0b 01 0b 	sub	r11,r8,r11
80009a1a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80009a1e:	f8 06 16 10 	lsr	r6,r12,0x10
80009a22:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80009a26:	f6 06 0d 00 	divu	r0,r11,r6
80009a2a:	e6 0b 16 10 	lsr	r11,r3,0x10
80009a2e:	00 9a       	mov	r10,r0
80009a30:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80009a34:	e0 0e 02 48 	mul	r8,r0,lr
80009a38:	10 3b       	cp.w	r11,r8
80009a3a:	c0 a2       	brcc	80009a4e <__avr32_udiv64+0x15a>
80009a3c:	20 1a       	sub	r10,1
80009a3e:	18 0b       	add	r11,r12
80009a40:	18 3b       	cp.w	r11,r12
80009a42:	c0 63       	brcs	80009a4e <__avr32_udiv64+0x15a>
80009a44:	10 3b       	cp.w	r11,r8
80009a46:	f7 ba 03 01 	sublo	r10,1
80009a4a:	f7 dc e3 0b 	addcs	r11,r11,r12
80009a4e:	f6 08 01 01 	sub	r1,r11,r8
80009a52:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80009a56:	e2 06 0d 00 	divu	r0,r1,r6
80009a5a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80009a5e:	00 98       	mov	r8,r0
80009a60:	e0 0e 02 4b 	mul	r11,r0,lr
80009a64:	16 33       	cp.w	r3,r11
80009a66:	c0 82       	brcc	80009a76 <__avr32_udiv64+0x182>
80009a68:	20 18       	sub	r8,1
80009a6a:	18 03       	add	r3,r12
80009a6c:	18 33       	cp.w	r3,r12
80009a6e:	c0 43       	brcs	80009a76 <__avr32_udiv64+0x182>
80009a70:	16 33       	cp.w	r3,r11
80009a72:	f7 b8 03 01 	sublo	r8,1
80009a76:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80009a7a:	c6 98       	rjmp	80009b4c <__avr32_udiv64+0x258>
80009a7c:	16 39       	cp.w	r9,r11
80009a7e:	e0 8b 00 65 	brhi	80009b48 <__avr32_udiv64+0x254>
80009a82:	f2 09 12 00 	clz	r9,r9
80009a86:	c0 b1       	brne	80009a9c <__avr32_udiv64+0x1a8>
80009a88:	10 3a       	cp.w	r10,r8
80009a8a:	5f 2a       	srhs	r10
80009a8c:	1c 3b       	cp.w	r11,lr
80009a8e:	5f b8       	srhi	r8
80009a90:	10 4a       	or	r10,r8
80009a92:	f2 0a 18 00 	cp.b	r10,r9
80009a96:	c5 90       	breq	80009b48 <__avr32_udiv64+0x254>
80009a98:	30 18       	mov	r8,1
80009a9a:	c5 98       	rjmp	80009b4c <__avr32_udiv64+0x258>
80009a9c:	f0 09 09 46 	lsl	r6,r8,r9
80009aa0:	f2 03 11 20 	rsub	r3,r9,32
80009aa4:	fc 09 09 4e 	lsl	lr,lr,r9
80009aa8:	f0 03 0a 48 	lsr	r8,r8,r3
80009aac:	f6 09 09 4c 	lsl	r12,r11,r9
80009ab0:	f4 03 0a 42 	lsr	r2,r10,r3
80009ab4:	ef 46 ff f4 	st.w	r7[-12],r6
80009ab8:	f6 03 0a 43 	lsr	r3,r11,r3
80009abc:	18 42       	or	r2,r12
80009abe:	f1 ee 10 0c 	or	r12,r8,lr
80009ac2:	f8 01 16 10 	lsr	r1,r12,0x10
80009ac6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80009aca:	e6 01 0d 04 	divu	r4,r3,r1
80009ace:	e4 03 16 10 	lsr	r3,r2,0x10
80009ad2:	08 9e       	mov	lr,r4
80009ad4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80009ad8:	e8 06 02 48 	mul	r8,r4,r6
80009adc:	10 33       	cp.w	r3,r8
80009ade:	c0 a2       	brcc	80009af2 <__avr32_udiv64+0x1fe>
80009ae0:	20 1e       	sub	lr,1
80009ae2:	18 03       	add	r3,r12
80009ae4:	18 33       	cp.w	r3,r12
80009ae6:	c0 63       	brcs	80009af2 <__avr32_udiv64+0x1fe>
80009ae8:	10 33       	cp.w	r3,r8
80009aea:	f7 be 03 01 	sublo	lr,1
80009aee:	e7 dc e3 03 	addcs	r3,r3,r12
80009af2:	10 13       	sub	r3,r8
80009af4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80009af8:	e6 01 0d 00 	divu	r0,r3,r1
80009afc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80009b00:	00 98       	mov	r8,r0
80009b02:	e0 06 02 46 	mul	r6,r0,r6
80009b06:	0c 3b       	cp.w	r11,r6
80009b08:	c0 a2       	brcc	80009b1c <__avr32_udiv64+0x228>
80009b0a:	20 18       	sub	r8,1
80009b0c:	18 0b       	add	r11,r12
80009b0e:	18 3b       	cp.w	r11,r12
80009b10:	c0 63       	brcs	80009b1c <__avr32_udiv64+0x228>
80009b12:	0c 3b       	cp.w	r11,r6
80009b14:	f7 dc e3 0b 	addcs	r11,r11,r12
80009b18:	f7 b8 03 01 	sublo	r8,1
80009b1c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80009b20:	ee f4 ff f4 	ld.w	r4,r7[-12]
80009b24:	0c 1b       	sub	r11,r6
80009b26:	f0 04 06 42 	mulu.d	r2,r8,r4
80009b2a:	06 95       	mov	r5,r3
80009b2c:	16 35       	cp.w	r5,r11
80009b2e:	e0 8b 00 0a 	brhi	80009b42 <__avr32_udiv64+0x24e>
80009b32:	5f 0b       	sreq	r11
80009b34:	f4 09 09 49 	lsl	r9,r10,r9
80009b38:	12 32       	cp.w	r2,r9
80009b3a:	5f b9       	srhi	r9
80009b3c:	f7 e9 00 09 	and	r9,r11,r9
80009b40:	c0 60       	breq	80009b4c <__avr32_udiv64+0x258>
80009b42:	20 18       	sub	r8,1
80009b44:	30 09       	mov	r9,0
80009b46:	c0 38       	rjmp	80009b4c <__avr32_udiv64+0x258>
80009b48:	30 09       	mov	r9,0
80009b4a:	12 98       	mov	r8,r9
80009b4c:	10 9a       	mov	r10,r8
80009b4e:	12 93       	mov	r3,r9
80009b50:	10 92       	mov	r2,r8
80009b52:	12 9b       	mov	r11,r9
80009b54:	2f dd       	sub	sp,-12
80009b56:	d8 32       	popm	r0-r7,pc

80009b58 <free>:
80009b58:	d4 01       	pushm	lr
80009b5a:	e0 68 74 94 	mov	r8,29844
80009b5e:	18 9b       	mov	r11,r12
80009b60:	70 0c       	ld.w	r12,r8[0x0]
80009b62:	e0 a0 03 4b 	rcall	8000a1f8 <_free_r>
80009b66:	d8 02       	popm	pc

80009b68 <malloc>:
80009b68:	d4 01       	pushm	lr
80009b6a:	e0 68 74 94 	mov	r8,29844
80009b6e:	18 9b       	mov	r11,r12
80009b70:	70 0c       	ld.w	r12,r8[0x0]
80009b72:	c0 3c       	rcall	80009b78 <_malloc_r>
80009b74:	d8 02       	popm	pc
80009b76:	d7 03       	nop

80009b78 <_malloc_r>:
80009b78:	d4 31       	pushm	r0-r7,lr
80009b7a:	f6 c8 ff f5 	sub	r8,r11,-11
80009b7e:	18 95       	mov	r5,r12
80009b80:	10 97       	mov	r7,r8
80009b82:	e0 17 ff f8 	andl	r7,0xfff8
80009b86:	59 68       	cp.w	r8,22
80009b88:	f9 b7 08 10 	movls	r7,16
80009b8c:	16 37       	cp.w	r7,r11
80009b8e:	5f 38       	srlo	r8
80009b90:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80009b94:	c0 50       	breq	80009b9e <_malloc_r+0x26>
80009b96:	30 c8       	mov	r8,12
80009b98:	99 38       	st.w	r12[0xc],r8
80009b9a:	e0 8f 01 f7 	bral	80009f88 <_malloc_r+0x410>
80009b9e:	fe b0 ea 6d 	rcall	80007078 <__malloc_lock>
80009ba2:	e0 47 01 f7 	cp.w	r7,503
80009ba6:	e0 8b 00 1d 	brhi	80009be0 <_malloc_r+0x68>
80009baa:	ee 03 16 03 	lsr	r3,r7,0x3
80009bae:	e0 68 6f 94 	mov	r8,28564
80009bb2:	f0 03 00 38 	add	r8,r8,r3<<0x3
80009bb6:	70 36       	ld.w	r6,r8[0xc]
80009bb8:	10 36       	cp.w	r6,r8
80009bba:	c0 61       	brne	80009bc6 <_malloc_r+0x4e>
80009bbc:	ec c8 ff f8 	sub	r8,r6,-8
80009bc0:	70 36       	ld.w	r6,r8[0xc]
80009bc2:	10 36       	cp.w	r6,r8
80009bc4:	c0 c0       	breq	80009bdc <_malloc_r+0x64>
80009bc6:	6c 18       	ld.w	r8,r6[0x4]
80009bc8:	e0 18 ff fc 	andl	r8,0xfffc
80009bcc:	6c 3a       	ld.w	r10,r6[0xc]
80009bce:	ec 08 00 09 	add	r9,r6,r8
80009bd2:	0a 9c       	mov	r12,r5
80009bd4:	6c 28       	ld.w	r8,r6[0x8]
80009bd6:	95 28       	st.w	r10[0x8],r8
80009bd8:	91 3a       	st.w	r8[0xc],r10
80009bda:	c4 78       	rjmp	80009c68 <_malloc_r+0xf0>
80009bdc:	2f e3       	sub	r3,-2
80009bde:	c4 d8       	rjmp	80009c78 <_malloc_r+0x100>
80009be0:	ee 03 16 09 	lsr	r3,r7,0x9
80009be4:	c0 41       	brne	80009bec <_malloc_r+0x74>
80009be6:	ee 03 16 03 	lsr	r3,r7,0x3
80009bea:	c2 68       	rjmp	80009c36 <_malloc_r+0xbe>
80009bec:	58 43       	cp.w	r3,4
80009bee:	e0 8b 00 06 	brhi	80009bfa <_malloc_r+0x82>
80009bf2:	ee 03 16 06 	lsr	r3,r7,0x6
80009bf6:	2c 83       	sub	r3,-56
80009bf8:	c1 f8       	rjmp	80009c36 <_malloc_r+0xbe>
80009bfa:	59 43       	cp.w	r3,20
80009bfc:	e0 8b 00 04 	brhi	80009c04 <_malloc_r+0x8c>
80009c00:	2a 53       	sub	r3,-91
80009c02:	c1 a8       	rjmp	80009c36 <_malloc_r+0xbe>
80009c04:	e0 43 00 54 	cp.w	r3,84
80009c08:	e0 8b 00 06 	brhi	80009c14 <_malloc_r+0x9c>
80009c0c:	ee 03 16 0c 	lsr	r3,r7,0xc
80009c10:	29 23       	sub	r3,-110
80009c12:	c1 28       	rjmp	80009c36 <_malloc_r+0xbe>
80009c14:	e0 43 01 54 	cp.w	r3,340
80009c18:	e0 8b 00 06 	brhi	80009c24 <_malloc_r+0xac>
80009c1c:	ee 03 16 0f 	lsr	r3,r7,0xf
80009c20:	28 93       	sub	r3,-119
80009c22:	c0 a8       	rjmp	80009c36 <_malloc_r+0xbe>
80009c24:	e0 43 05 54 	cp.w	r3,1364
80009c28:	e0 88 00 04 	brls	80009c30 <_malloc_r+0xb8>
80009c2c:	37 e3       	mov	r3,126
80009c2e:	c0 48       	rjmp	80009c36 <_malloc_r+0xbe>
80009c30:	ee 03 16 12 	lsr	r3,r7,0x12
80009c34:	28 43       	sub	r3,-124
80009c36:	e0 6a 6f 94 	mov	r10,28564
80009c3a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80009c3e:	74 36       	ld.w	r6,r10[0xc]
80009c40:	c1 98       	rjmp	80009c72 <_malloc_r+0xfa>
80009c42:	6c 19       	ld.w	r9,r6[0x4]
80009c44:	e0 19 ff fc 	andl	r9,0xfffc
80009c48:	f2 07 01 0b 	sub	r11,r9,r7
80009c4c:	58 fb       	cp.w	r11,15
80009c4e:	e0 8a 00 04 	brle	80009c56 <_malloc_r+0xde>
80009c52:	20 13       	sub	r3,1
80009c54:	c1 18       	rjmp	80009c76 <_malloc_r+0xfe>
80009c56:	6c 38       	ld.w	r8,r6[0xc]
80009c58:	58 0b       	cp.w	r11,0
80009c5a:	c0 b5       	brlt	80009c70 <_malloc_r+0xf8>
80009c5c:	6c 2a       	ld.w	r10,r6[0x8]
80009c5e:	ec 09 00 09 	add	r9,r6,r9
80009c62:	0a 9c       	mov	r12,r5
80009c64:	91 2a       	st.w	r8[0x8],r10
80009c66:	95 38       	st.w	r10[0xc],r8
80009c68:	72 18       	ld.w	r8,r9[0x4]
80009c6a:	a1 a8       	sbr	r8,0x0
80009c6c:	93 18       	st.w	r9[0x4],r8
80009c6e:	cb c8       	rjmp	80009de6 <_malloc_r+0x26e>
80009c70:	10 96       	mov	r6,r8
80009c72:	14 36       	cp.w	r6,r10
80009c74:	ce 71       	brne	80009c42 <_malloc_r+0xca>
80009c76:	2f f3       	sub	r3,-1
80009c78:	e0 6a 6f 94 	mov	r10,28564
80009c7c:	f4 cc ff f8 	sub	r12,r10,-8
80009c80:	78 26       	ld.w	r6,r12[0x8]
80009c82:	18 36       	cp.w	r6,r12
80009c84:	c6 c0       	breq	80009d5c <_malloc_r+0x1e4>
80009c86:	6c 19       	ld.w	r9,r6[0x4]
80009c88:	e0 19 ff fc 	andl	r9,0xfffc
80009c8c:	f2 07 01 08 	sub	r8,r9,r7
80009c90:	58 f8       	cp.w	r8,15
80009c92:	e0 89 00 8f 	brgt	80009db0 <_malloc_r+0x238>
80009c96:	99 3c       	st.w	r12[0xc],r12
80009c98:	99 2c       	st.w	r12[0x8],r12
80009c9a:	58 08       	cp.w	r8,0
80009c9c:	c0 55       	brlt	80009ca6 <_malloc_r+0x12e>
80009c9e:	ec 09 00 09 	add	r9,r6,r9
80009ca2:	0a 9c       	mov	r12,r5
80009ca4:	ce 2b       	rjmp	80009c68 <_malloc_r+0xf0>
80009ca6:	e0 49 01 ff 	cp.w	r9,511
80009caa:	e0 8b 00 13 	brhi	80009cd0 <_malloc_r+0x158>
80009cae:	a3 99       	lsr	r9,0x3
80009cb0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80009cb4:	70 2b       	ld.w	r11,r8[0x8]
80009cb6:	8d 38       	st.w	r6[0xc],r8
80009cb8:	8d 2b       	st.w	r6[0x8],r11
80009cba:	97 36       	st.w	r11[0xc],r6
80009cbc:	91 26       	st.w	r8[0x8],r6
80009cbe:	a3 49       	asr	r9,0x2
80009cc0:	74 18       	ld.w	r8,r10[0x4]
80009cc2:	30 1b       	mov	r11,1
80009cc4:	f6 09 09 49 	lsl	r9,r11,r9
80009cc8:	f1 e9 10 09 	or	r9,r8,r9
80009ccc:	95 19       	st.w	r10[0x4],r9
80009cce:	c4 78       	rjmp	80009d5c <_malloc_r+0x1e4>
80009cd0:	f2 0a 16 09 	lsr	r10,r9,0x9
80009cd4:	58 4a       	cp.w	r10,4
80009cd6:	e0 8b 00 07 	brhi	80009ce4 <_malloc_r+0x16c>
80009cda:	f2 0a 16 06 	lsr	r10,r9,0x6
80009cde:	2c 8a       	sub	r10,-56
80009ce0:	c2 08       	rjmp	80009d20 <_malloc_r+0x1a8>
80009ce2:	d7 03       	nop
80009ce4:	59 4a       	cp.w	r10,20
80009ce6:	e0 8b 00 04 	brhi	80009cee <_malloc_r+0x176>
80009cea:	2a 5a       	sub	r10,-91
80009cec:	c1 a8       	rjmp	80009d20 <_malloc_r+0x1a8>
80009cee:	e0 4a 00 54 	cp.w	r10,84
80009cf2:	e0 8b 00 06 	brhi	80009cfe <_malloc_r+0x186>
80009cf6:	f2 0a 16 0c 	lsr	r10,r9,0xc
80009cfa:	29 2a       	sub	r10,-110
80009cfc:	c1 28       	rjmp	80009d20 <_malloc_r+0x1a8>
80009cfe:	e0 4a 01 54 	cp.w	r10,340
80009d02:	e0 8b 00 06 	brhi	80009d0e <_malloc_r+0x196>
80009d06:	f2 0a 16 0f 	lsr	r10,r9,0xf
80009d0a:	28 9a       	sub	r10,-119
80009d0c:	c0 a8       	rjmp	80009d20 <_malloc_r+0x1a8>
80009d0e:	e0 4a 05 54 	cp.w	r10,1364
80009d12:	e0 88 00 04 	brls	80009d1a <_malloc_r+0x1a2>
80009d16:	37 ea       	mov	r10,126
80009d18:	c0 48       	rjmp	80009d20 <_malloc_r+0x1a8>
80009d1a:	f2 0a 16 12 	lsr	r10,r9,0x12
80009d1e:	28 4a       	sub	r10,-124
80009d20:	e0 6b 6f 94 	mov	r11,28564
80009d24:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80009d28:	68 28       	ld.w	r8,r4[0x8]
80009d2a:	08 38       	cp.w	r8,r4
80009d2c:	c0 e1       	brne	80009d48 <_malloc_r+0x1d0>
80009d2e:	76 19       	ld.w	r9,r11[0x4]
80009d30:	a3 4a       	asr	r10,0x2
80009d32:	30 1e       	mov	lr,1
80009d34:	fc 0a 09 4a 	lsl	r10,lr,r10
80009d38:	f3 ea 10 0a 	or	r10,r9,r10
80009d3c:	10 99       	mov	r9,r8
80009d3e:	97 1a       	st.w	r11[0x4],r10
80009d40:	c0 a8       	rjmp	80009d54 <_malloc_r+0x1dc>
80009d42:	70 28       	ld.w	r8,r8[0x8]
80009d44:	08 38       	cp.w	r8,r4
80009d46:	c0 60       	breq	80009d52 <_malloc_r+0x1da>
80009d48:	70 1a       	ld.w	r10,r8[0x4]
80009d4a:	e0 1a ff fc 	andl	r10,0xfffc
80009d4e:	14 39       	cp.w	r9,r10
80009d50:	cf 93       	brcs	80009d42 <_malloc_r+0x1ca>
80009d52:	70 39       	ld.w	r9,r8[0xc]
80009d54:	8d 39       	st.w	r6[0xc],r9
80009d56:	8d 28       	st.w	r6[0x8],r8
80009d58:	91 36       	st.w	r8[0xc],r6
80009d5a:	93 26       	st.w	r9[0x8],r6
80009d5c:	e6 08 14 02 	asr	r8,r3,0x2
80009d60:	30 1b       	mov	r11,1
80009d62:	e0 64 6f 94 	mov	r4,28564
80009d66:	f6 08 09 4b 	lsl	r11,r11,r8
80009d6a:	68 18       	ld.w	r8,r4[0x4]
80009d6c:	10 3b       	cp.w	r11,r8
80009d6e:	e0 8b 00 6b 	brhi	80009e44 <_malloc_r+0x2cc>
80009d72:	f7 e8 00 09 	and	r9,r11,r8
80009d76:	c0 b1       	brne	80009d8c <_malloc_r+0x214>
80009d78:	e0 13 ff fc 	andl	r3,0xfffc
80009d7c:	a1 7b       	lsl	r11,0x1
80009d7e:	2f c3       	sub	r3,-4
80009d80:	c0 38       	rjmp	80009d86 <_malloc_r+0x20e>
80009d82:	2f c3       	sub	r3,-4
80009d84:	a1 7b       	lsl	r11,0x1
80009d86:	f7 e8 00 09 	and	r9,r11,r8
80009d8a:	cf c0       	breq	80009d82 <_malloc_r+0x20a>
80009d8c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80009d90:	06 92       	mov	r2,r3
80009d92:	1c 91       	mov	r1,lr
80009d94:	62 36       	ld.w	r6,r1[0xc]
80009d96:	c2 e8       	rjmp	80009df2 <_malloc_r+0x27a>
80009d98:	6c 1a       	ld.w	r10,r6[0x4]
80009d9a:	e0 1a ff fc 	andl	r10,0xfffc
80009d9e:	f4 07 01 08 	sub	r8,r10,r7
80009da2:	58 f8       	cp.w	r8,15
80009da4:	e0 8a 00 15 	brle	80009dce <_malloc_r+0x256>
80009da8:	6c 3a       	ld.w	r10,r6[0xc]
80009daa:	6c 29       	ld.w	r9,r6[0x8]
80009dac:	95 29       	st.w	r10[0x8],r9
80009dae:	93 3a       	st.w	r9[0xc],r10
80009db0:	0e 99       	mov	r9,r7
80009db2:	ec 07 00 07 	add	r7,r6,r7
80009db6:	a1 a9       	sbr	r9,0x0
80009db8:	99 37       	st.w	r12[0xc],r7
80009dba:	99 27       	st.w	r12[0x8],r7
80009dbc:	8d 19       	st.w	r6[0x4],r9
80009dbe:	ee 08 09 08 	st.w	r7[r8],r8
80009dc2:	8f 2c       	st.w	r7[0x8],r12
80009dc4:	8f 3c       	st.w	r7[0xc],r12
80009dc6:	a1 a8       	sbr	r8,0x0
80009dc8:	0a 9c       	mov	r12,r5
80009dca:	8f 18       	st.w	r7[0x4],r8
80009dcc:	c0 d8       	rjmp	80009de6 <_malloc_r+0x26e>
80009dce:	6c 39       	ld.w	r9,r6[0xc]
80009dd0:	58 08       	cp.w	r8,0
80009dd2:	c0 f5       	brlt	80009df0 <_malloc_r+0x278>
80009dd4:	ec 0a 00 0a 	add	r10,r6,r10
80009dd8:	74 18       	ld.w	r8,r10[0x4]
80009dda:	a1 a8       	sbr	r8,0x0
80009ddc:	0a 9c       	mov	r12,r5
80009dde:	95 18       	st.w	r10[0x4],r8
80009de0:	6c 28       	ld.w	r8,r6[0x8]
80009de2:	93 28       	st.w	r9[0x8],r8
80009de4:	91 39       	st.w	r8[0xc],r9
80009de6:	fe b0 e9 4f 	rcall	80007084 <__malloc_unlock>
80009dea:	ec cc ff f8 	sub	r12,r6,-8
80009dee:	d8 32       	popm	r0-r7,pc
80009df0:	12 96       	mov	r6,r9
80009df2:	02 36       	cp.w	r6,r1
80009df4:	cd 21       	brne	80009d98 <_malloc_r+0x220>
80009df6:	2f f2       	sub	r2,-1
80009df8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80009dfc:	c0 30       	breq	80009e02 <_malloc_r+0x28a>
80009dfe:	2f 81       	sub	r1,-8
80009e00:	cc ab       	rjmp	80009d94 <_malloc_r+0x21c>
80009e02:	1c 98       	mov	r8,lr
80009e04:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80009e08:	c0 81       	brne	80009e18 <_malloc_r+0x2a0>
80009e0a:	68 19       	ld.w	r9,r4[0x4]
80009e0c:	f6 08 11 ff 	rsub	r8,r11,-1
80009e10:	f3 e8 00 08 	and	r8,r9,r8
80009e14:	89 18       	st.w	r4[0x4],r8
80009e16:	c0 78       	rjmp	80009e24 <_malloc_r+0x2ac>
80009e18:	f0 c9 00 08 	sub	r9,r8,8
80009e1c:	20 13       	sub	r3,1
80009e1e:	70 08       	ld.w	r8,r8[0x0]
80009e20:	12 38       	cp.w	r8,r9
80009e22:	cf 10       	breq	80009e04 <_malloc_r+0x28c>
80009e24:	a1 7b       	lsl	r11,0x1
80009e26:	68 18       	ld.w	r8,r4[0x4]
80009e28:	10 3b       	cp.w	r11,r8
80009e2a:	e0 8b 00 0d 	brhi	80009e44 <_malloc_r+0x2cc>
80009e2e:	58 0b       	cp.w	r11,0
80009e30:	c0 a0       	breq	80009e44 <_malloc_r+0x2cc>
80009e32:	04 93       	mov	r3,r2
80009e34:	c0 38       	rjmp	80009e3a <_malloc_r+0x2c2>
80009e36:	2f c3       	sub	r3,-4
80009e38:	a1 7b       	lsl	r11,0x1
80009e3a:	f7 e8 00 09 	and	r9,r11,r8
80009e3e:	ca 71       	brne	80009d8c <_malloc_r+0x214>
80009e40:	cf bb       	rjmp	80009e36 <_malloc_r+0x2be>
80009e42:	d7 03       	nop
80009e44:	68 23       	ld.w	r3,r4[0x8]
80009e46:	66 12       	ld.w	r2,r3[0x4]
80009e48:	e0 12 ff fc 	andl	r2,0xfffc
80009e4c:	0e 32       	cp.w	r2,r7
80009e4e:	5f 39       	srlo	r9
80009e50:	e4 07 01 08 	sub	r8,r2,r7
80009e54:	58 f8       	cp.w	r8,15
80009e56:	5f aa       	srle	r10
80009e58:	f5 e9 10 09 	or	r9,r10,r9
80009e5c:	e0 80 00 98 	breq	80009f8c <_malloc_r+0x414>
80009e60:	e0 68 77 80 	mov	r8,30592
80009e64:	70 01       	ld.w	r1,r8[0x0]
80009e66:	e0 68 73 a0 	mov	r8,29600
80009e6a:	2f 01       	sub	r1,-16
80009e6c:	70 08       	ld.w	r8,r8[0x0]
80009e6e:	0e 01       	add	r1,r7
80009e70:	5b f8       	cp.w	r8,-1
80009e72:	c0 40       	breq	80009e7a <_malloc_r+0x302>
80009e74:	28 11       	sub	r1,-127
80009e76:	e0 11 ff 80 	andl	r1,0xff80
80009e7a:	02 9b       	mov	r11,r1
80009e7c:	0a 9c       	mov	r12,r5
80009e7e:	c4 3d       	rcall	8000a104 <_sbrk_r>
80009e80:	18 96       	mov	r6,r12
80009e82:	5b fc       	cp.w	r12,-1
80009e84:	c7 30       	breq	80009f6a <_malloc_r+0x3f2>
80009e86:	e6 02 00 08 	add	r8,r3,r2
80009e8a:	10 3c       	cp.w	r12,r8
80009e8c:	c0 32       	brcc	80009e92 <_malloc_r+0x31a>
80009e8e:	08 33       	cp.w	r3,r4
80009e90:	c6 d1       	brne	80009f6a <_malloc_r+0x3f2>
80009e92:	e0 6a 77 84 	mov	r10,30596
80009e96:	74 09       	ld.w	r9,r10[0x0]
80009e98:	e2 09 00 09 	add	r9,r1,r9
80009e9c:	95 09       	st.w	r10[0x0],r9
80009e9e:	10 36       	cp.w	r6,r8
80009ea0:	c0 a1       	brne	80009eb4 <_malloc_r+0x33c>
80009ea2:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80009ea6:	c0 71       	brne	80009eb4 <_malloc_r+0x33c>
80009ea8:	e2 02 00 02 	add	r2,r1,r2
80009eac:	68 28       	ld.w	r8,r4[0x8]
80009eae:	a1 a2       	sbr	r2,0x0
80009eb0:	91 12       	st.w	r8[0x4],r2
80009eb2:	c4 d8       	rjmp	80009f4c <_malloc_r+0x3d4>
80009eb4:	e0 6a 73 a0 	mov	r10,29600
80009eb8:	74 0b       	ld.w	r11,r10[0x0]
80009eba:	5b fb       	cp.w	r11,-1
80009ebc:	c0 31       	brne	80009ec2 <_malloc_r+0x34a>
80009ebe:	95 06       	st.w	r10[0x0],r6
80009ec0:	c0 78       	rjmp	80009ece <_malloc_r+0x356>
80009ec2:	ec 09 00 09 	add	r9,r6,r9
80009ec6:	e0 6a 77 84 	mov	r10,30596
80009eca:	10 19       	sub	r9,r8
80009ecc:	95 09       	st.w	r10[0x0],r9
80009ece:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80009ed2:	f0 09 11 08 	rsub	r9,r8,8
80009ed6:	58 08       	cp.w	r8,0
80009ed8:	f2 08 17 10 	movne	r8,r9
80009edc:	ed d8 e1 06 	addne	r6,r6,r8
80009ee0:	28 08       	sub	r8,-128
80009ee2:	ec 01 00 01 	add	r1,r6,r1
80009ee6:	0a 9c       	mov	r12,r5
80009ee8:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80009eec:	f0 01 01 01 	sub	r1,r8,r1
80009ef0:	02 9b       	mov	r11,r1
80009ef2:	c0 9d       	rcall	8000a104 <_sbrk_r>
80009ef4:	e0 68 77 84 	mov	r8,30596
80009ef8:	5b fc       	cp.w	r12,-1
80009efa:	ec 0c 17 00 	moveq	r12,r6
80009efe:	f9 b1 00 00 	moveq	r1,0
80009f02:	70 09       	ld.w	r9,r8[0x0]
80009f04:	0c 1c       	sub	r12,r6
80009f06:	89 26       	st.w	r4[0x8],r6
80009f08:	02 0c       	add	r12,r1
80009f0a:	12 01       	add	r1,r9
80009f0c:	a1 ac       	sbr	r12,0x0
80009f0e:	91 01       	st.w	r8[0x0],r1
80009f10:	8d 1c       	st.w	r6[0x4],r12
80009f12:	08 33       	cp.w	r3,r4
80009f14:	c1 c0       	breq	80009f4c <_malloc_r+0x3d4>
80009f16:	58 f2       	cp.w	r2,15
80009f18:	e0 8b 00 05 	brhi	80009f22 <_malloc_r+0x3aa>
80009f1c:	30 18       	mov	r8,1
80009f1e:	8d 18       	st.w	r6[0x4],r8
80009f20:	c2 58       	rjmp	80009f6a <_malloc_r+0x3f2>
80009f22:	30 59       	mov	r9,5
80009f24:	20 c2       	sub	r2,12
80009f26:	e0 12 ff f8 	andl	r2,0xfff8
80009f2a:	e6 02 00 08 	add	r8,r3,r2
80009f2e:	91 29       	st.w	r8[0x8],r9
80009f30:	91 19       	st.w	r8[0x4],r9
80009f32:	66 18       	ld.w	r8,r3[0x4]
80009f34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009f38:	e5 e8 10 08 	or	r8,r2,r8
80009f3c:	87 18       	st.w	r3[0x4],r8
80009f3e:	58 f2       	cp.w	r2,15
80009f40:	e0 88 00 06 	brls	80009f4c <_malloc_r+0x3d4>
80009f44:	e6 cb ff f8 	sub	r11,r3,-8
80009f48:	0a 9c       	mov	r12,r5
80009f4a:	c5 7d       	rcall	8000a1f8 <_free_r>
80009f4c:	e0 69 77 7c 	mov	r9,30588
80009f50:	72 0a       	ld.w	r10,r9[0x0]
80009f52:	e0 68 77 84 	mov	r8,30596
80009f56:	70 08       	ld.w	r8,r8[0x0]
80009f58:	14 38       	cp.w	r8,r10
80009f5a:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80009f5e:	e0 69 77 78 	mov	r9,30584
80009f62:	72 0a       	ld.w	r10,r9[0x0]
80009f64:	14 38       	cp.w	r8,r10
80009f66:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80009f6a:	68 28       	ld.w	r8,r4[0x8]
80009f6c:	70 18       	ld.w	r8,r8[0x4]
80009f6e:	e0 18 ff fc 	andl	r8,0xfffc
80009f72:	0e 38       	cp.w	r8,r7
80009f74:	5f 39       	srlo	r9
80009f76:	0e 18       	sub	r8,r7
80009f78:	58 f8       	cp.w	r8,15
80009f7a:	5f aa       	srle	r10
80009f7c:	f5 e9 10 09 	or	r9,r10,r9
80009f80:	c0 60       	breq	80009f8c <_malloc_r+0x414>
80009f82:	0a 9c       	mov	r12,r5
80009f84:	fe b0 e8 80 	rcall	80007084 <__malloc_unlock>
80009f88:	d8 3a       	popm	r0-r7,pc,r12=0
80009f8a:	d7 03       	nop
80009f8c:	68 26       	ld.w	r6,r4[0x8]
80009f8e:	a1 a8       	sbr	r8,0x0
80009f90:	0e 99       	mov	r9,r7
80009f92:	a1 a9       	sbr	r9,0x0
80009f94:	8d 19       	st.w	r6[0x4],r9
80009f96:	ec 07 00 07 	add	r7,r6,r7
80009f9a:	0a 9c       	mov	r12,r5
80009f9c:	89 27       	st.w	r4[0x8],r7
80009f9e:	8f 18       	st.w	r7[0x4],r8
80009fa0:	fe b0 e8 72 	rcall	80007084 <__malloc_unlock>
80009fa4:	ec cc ff f8 	sub	r12,r6,-8
80009fa8:	d8 32       	popm	r0-r7,pc
80009faa:	d7 03       	nop

80009fac <memcpy>:
80009fac:	58 8a       	cp.w	r10,8
80009fae:	c2 f5       	brlt	8000a00c <memcpy+0x60>
80009fb0:	f9 eb 10 09 	or	r9,r12,r11
80009fb4:	e2 19 00 03 	andl	r9,0x3,COH
80009fb8:	e0 81 00 97 	brne	8000a0e6 <memcpy+0x13a>
80009fbc:	e0 4a 00 20 	cp.w	r10,32
80009fc0:	c3 b4       	brge	8000a036 <memcpy+0x8a>
80009fc2:	f4 08 14 02 	asr	r8,r10,0x2
80009fc6:	f0 09 11 08 	rsub	r9,r8,8
80009fca:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80009fce:	76 69       	ld.w	r9,r11[0x18]
80009fd0:	99 69       	st.w	r12[0x18],r9
80009fd2:	76 59       	ld.w	r9,r11[0x14]
80009fd4:	99 59       	st.w	r12[0x14],r9
80009fd6:	76 49       	ld.w	r9,r11[0x10]
80009fd8:	99 49       	st.w	r12[0x10],r9
80009fda:	76 39       	ld.w	r9,r11[0xc]
80009fdc:	99 39       	st.w	r12[0xc],r9
80009fde:	76 29       	ld.w	r9,r11[0x8]
80009fe0:	99 29       	st.w	r12[0x8],r9
80009fe2:	76 19       	ld.w	r9,r11[0x4]
80009fe4:	99 19       	st.w	r12[0x4],r9
80009fe6:	76 09       	ld.w	r9,r11[0x0]
80009fe8:	99 09       	st.w	r12[0x0],r9
80009fea:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80009fee:	f8 08 00 28 	add	r8,r12,r8<<0x2
80009ff2:	e0 1a 00 03 	andl	r10,0x3
80009ff6:	f4 0a 11 04 	rsub	r10,r10,4
80009ffa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80009ffe:	17 a9       	ld.ub	r9,r11[0x2]
8000a000:	b0 a9       	st.b	r8[0x2],r9
8000a002:	17 99       	ld.ub	r9,r11[0x1]
8000a004:	b0 99       	st.b	r8[0x1],r9
8000a006:	17 89       	ld.ub	r9,r11[0x0]
8000a008:	b0 89       	st.b	r8[0x0],r9
8000a00a:	5e fc       	retal	r12
8000a00c:	f4 0a 11 09 	rsub	r10,r10,9
8000a010:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a014:	17 f9       	ld.ub	r9,r11[0x7]
8000a016:	b8 f9       	st.b	r12[0x7],r9
8000a018:	17 e9       	ld.ub	r9,r11[0x6]
8000a01a:	b8 e9       	st.b	r12[0x6],r9
8000a01c:	17 d9       	ld.ub	r9,r11[0x5]
8000a01e:	b8 d9       	st.b	r12[0x5],r9
8000a020:	17 c9       	ld.ub	r9,r11[0x4]
8000a022:	b8 c9       	st.b	r12[0x4],r9
8000a024:	17 b9       	ld.ub	r9,r11[0x3]
8000a026:	b8 b9       	st.b	r12[0x3],r9
8000a028:	17 a9       	ld.ub	r9,r11[0x2]
8000a02a:	b8 a9       	st.b	r12[0x2],r9
8000a02c:	17 99       	ld.ub	r9,r11[0x1]
8000a02e:	b8 99       	st.b	r12[0x1],r9
8000a030:	17 89       	ld.ub	r9,r11[0x0]
8000a032:	b8 89       	st.b	r12[0x0],r9
8000a034:	5e fc       	retal	r12
8000a036:	eb cd 40 c0 	pushm	r6-r7,lr
8000a03a:	18 99       	mov	r9,r12
8000a03c:	22 0a       	sub	r10,32
8000a03e:	b7 07       	ld.d	r6,r11++
8000a040:	b3 26       	st.d	r9++,r6
8000a042:	b7 07       	ld.d	r6,r11++
8000a044:	b3 26       	st.d	r9++,r6
8000a046:	b7 07       	ld.d	r6,r11++
8000a048:	b3 26       	st.d	r9++,r6
8000a04a:	b7 07       	ld.d	r6,r11++
8000a04c:	b3 26       	st.d	r9++,r6
8000a04e:	22 0a       	sub	r10,32
8000a050:	cf 74       	brge	8000a03e <memcpy+0x92>
8000a052:	2f 0a       	sub	r10,-16
8000a054:	c0 65       	brlt	8000a060 <memcpy+0xb4>
8000a056:	b7 07       	ld.d	r6,r11++
8000a058:	b3 26       	st.d	r9++,r6
8000a05a:	b7 07       	ld.d	r6,r11++
8000a05c:	b3 26       	st.d	r9++,r6
8000a05e:	21 0a       	sub	r10,16
8000a060:	5c 3a       	neg	r10
8000a062:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a066:	d7 03       	nop
8000a068:	d7 03       	nop
8000a06a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a06e:	f3 66 00 0e 	st.b	r9[14],r6
8000a072:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a076:	f3 66 00 0d 	st.b	r9[13],r6
8000a07a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a07e:	f3 66 00 0c 	st.b	r9[12],r6
8000a082:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a086:	f3 66 00 0b 	st.b	r9[11],r6
8000a08a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a08e:	f3 66 00 0a 	st.b	r9[10],r6
8000a092:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a096:	f3 66 00 09 	st.b	r9[9],r6
8000a09a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a09e:	f3 66 00 08 	st.b	r9[8],r6
8000a0a2:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a0a6:	f3 66 00 07 	st.b	r9[7],r6
8000a0aa:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a0ae:	f3 66 00 06 	st.b	r9[6],r6
8000a0b2:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a0b6:	f3 66 00 05 	st.b	r9[5],r6
8000a0ba:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a0be:	f3 66 00 04 	st.b	r9[4],r6
8000a0c2:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a0c6:	f3 66 00 03 	st.b	r9[3],r6
8000a0ca:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a0ce:	f3 66 00 02 	st.b	r9[2],r6
8000a0d2:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a0d6:	f3 66 00 01 	st.b	r9[1],r6
8000a0da:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a0de:	f3 66 00 00 	st.b	r9[0],r6
8000a0e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a0e6:	20 1a       	sub	r10,1
8000a0e8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a0ec:	f8 0a 0b 09 	st.b	r12[r10],r9
8000a0f0:	cf b1       	brne	8000a0e6 <memcpy+0x13a>
8000a0f2:	5e fc       	retal	r12

8000a0f4 <memset>:
8000a0f4:	18 98       	mov	r8,r12
8000a0f6:	c0 38       	rjmp	8000a0fc <memset+0x8>
8000a0f8:	10 cb       	st.b	r8++,r11
8000a0fa:	20 1a       	sub	r10,1
8000a0fc:	58 0a       	cp.w	r10,0
8000a0fe:	cf d1       	brne	8000a0f8 <memset+0x4>
8000a100:	5e fc       	retal	r12
8000a102:	d7 03       	nop

8000a104 <_sbrk_r>:
8000a104:	d4 21       	pushm	r4-r7,lr
8000a106:	30 08       	mov	r8,0
8000a108:	18 97       	mov	r7,r12
8000a10a:	e0 66 7f 3c 	mov	r6,32572
8000a10e:	16 9c       	mov	r12,r11
8000a110:	8d 08       	st.w	r6[0x0],r8
8000a112:	c0 9c       	rcall	8000a124 <_sbrk>
8000a114:	5b fc       	cp.w	r12,-1
8000a116:	c0 51       	brne	8000a120 <_sbrk_r+0x1c>
8000a118:	6c 08       	ld.w	r8,r6[0x0]
8000a11a:	58 08       	cp.w	r8,0
8000a11c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a120:	d8 22       	popm	r4-r7,pc
8000a122:	d7 03       	nop

8000a124 <_sbrk>:
8000a124:	d4 01       	pushm	lr
8000a126:	e0 68 77 ac 	mov	r8,30636
8000a12a:	70 09       	ld.w	r9,r8[0x0]
8000a12c:	58 09       	cp.w	r9,0
8000a12e:	c0 41       	brne	8000a136 <_sbrk+0x12>
8000a130:	e0 69 7f 40 	mov	r9,32576
8000a134:	91 09       	st.w	r8[0x0],r9
8000a136:	e0 69 77 ac 	mov	r9,30636
8000a13a:	e0 6a f0 00 	mov	r10,61440
8000a13e:	72 08       	ld.w	r8,r9[0x0]
8000a140:	f0 0c 00 0c 	add	r12,r8,r12
8000a144:	14 3c       	cp.w	r12,r10
8000a146:	e0 8b 00 04 	brhi	8000a14e <_sbrk+0x2a>
8000a14a:	93 0c       	st.w	r9[0x0],r12
8000a14c:	c0 58       	rjmp	8000a156 <_sbrk+0x32>
8000a14e:	c0 7c       	rcall	8000a15c <__errno>
8000a150:	30 c8       	mov	r8,12
8000a152:	99 08       	st.w	r12[0x0],r8
8000a154:	3f f8       	mov	r8,-1
8000a156:	10 9c       	mov	r12,r8
8000a158:	d8 02       	popm	pc
8000a15a:	d7 03       	nop

8000a15c <__errno>:
8000a15c:	e0 68 74 94 	mov	r8,29844
8000a160:	70 0c       	ld.w	r12,r8[0x0]
8000a162:	2f 4c       	sub	r12,-12
8000a164:	5e fc       	retal	r12
8000a166:	d7 03       	nop

8000a168 <_malloc_trim_r>:
8000a168:	d4 21       	pushm	r4-r7,lr
8000a16a:	16 95       	mov	r5,r11
8000a16c:	18 97       	mov	r7,r12
8000a16e:	fe b0 e7 85 	rcall	80007078 <__malloc_lock>
8000a172:	e0 64 6f 94 	mov	r4,28564
8000a176:	68 28       	ld.w	r8,r4[0x8]
8000a178:	70 16       	ld.w	r6,r8[0x4]
8000a17a:	e0 16 ff fc 	andl	r6,0xfffc
8000a17e:	ec c8 ff 91 	sub	r8,r6,-111
8000a182:	f0 05 01 05 	sub	r5,r8,r5
8000a186:	e0 15 ff 80 	andl	r5,0xff80
8000a18a:	ea c5 00 80 	sub	r5,r5,128
8000a18e:	e0 45 00 7f 	cp.w	r5,127
8000a192:	e0 8a 00 22 	brle	8000a1d6 <_malloc_trim_r+0x6e>
8000a196:	30 0b       	mov	r11,0
8000a198:	0e 9c       	mov	r12,r7
8000a19a:	cb 5f       	rcall	8000a104 <_sbrk_r>
8000a19c:	68 28       	ld.w	r8,r4[0x8]
8000a19e:	0c 08       	add	r8,r6
8000a1a0:	10 3c       	cp.w	r12,r8
8000a1a2:	c1 a1       	brne	8000a1d6 <_malloc_trim_r+0x6e>
8000a1a4:	ea 0b 11 00 	rsub	r11,r5,0
8000a1a8:	0e 9c       	mov	r12,r7
8000a1aa:	ca df       	rcall	8000a104 <_sbrk_r>
8000a1ac:	5b fc       	cp.w	r12,-1
8000a1ae:	c1 81       	brne	8000a1de <_malloc_trim_r+0x76>
8000a1b0:	30 0b       	mov	r11,0
8000a1b2:	0e 9c       	mov	r12,r7
8000a1b4:	ca 8f       	rcall	8000a104 <_sbrk_r>
8000a1b6:	68 28       	ld.w	r8,r4[0x8]
8000a1b8:	f8 08 01 09 	sub	r9,r12,r8
8000a1bc:	58 f9       	cp.w	r9,15
8000a1be:	e0 8a 00 0c 	brle	8000a1d6 <_malloc_trim_r+0x6e>
8000a1c2:	a1 a9       	sbr	r9,0x0
8000a1c4:	91 19       	st.w	r8[0x4],r9
8000a1c6:	e0 68 73 a0 	mov	r8,29600
8000a1ca:	70 09       	ld.w	r9,r8[0x0]
8000a1cc:	e0 68 77 84 	mov	r8,30596
8000a1d0:	f8 09 01 09 	sub	r9,r12,r9
8000a1d4:	91 09       	st.w	r8[0x0],r9
8000a1d6:	0e 9c       	mov	r12,r7
8000a1d8:	fe b0 e7 56 	rcall	80007084 <__malloc_unlock>
8000a1dc:	d8 2a       	popm	r4-r7,pc,r12=0
8000a1de:	68 28       	ld.w	r8,r4[0x8]
8000a1e0:	0a 16       	sub	r6,r5
8000a1e2:	a1 a6       	sbr	r6,0x0
8000a1e4:	91 16       	st.w	r8[0x4],r6
8000a1e6:	e0 68 77 84 	mov	r8,30596
8000a1ea:	70 09       	ld.w	r9,r8[0x0]
8000a1ec:	0a 19       	sub	r9,r5
8000a1ee:	0e 9c       	mov	r12,r7
8000a1f0:	91 09       	st.w	r8[0x0],r9
8000a1f2:	fe b0 e7 49 	rcall	80007084 <__malloc_unlock>
8000a1f6:	da 2a       	popm	r4-r7,pc,r12=1

8000a1f8 <_free_r>:
8000a1f8:	d4 21       	pushm	r4-r7,lr
8000a1fa:	16 96       	mov	r6,r11
8000a1fc:	18 97       	mov	r7,r12
8000a1fe:	58 0b       	cp.w	r11,0
8000a200:	e0 80 00 c0 	breq	8000a380 <_free_r+0x188>
8000a204:	fe b0 e7 3a 	rcall	80007078 <__malloc_lock>
8000a208:	20 86       	sub	r6,8
8000a20a:	e0 6a 6f 94 	mov	r10,28564
8000a20e:	6c 18       	ld.w	r8,r6[0x4]
8000a210:	74 2e       	ld.w	lr,r10[0x8]
8000a212:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a216:	a1 c8       	cbr	r8,0x0
8000a218:	ec 08 00 09 	add	r9,r6,r8
8000a21c:	72 1b       	ld.w	r11,r9[0x4]
8000a21e:	e0 1b ff fc 	andl	r11,0xfffc
8000a222:	1c 39       	cp.w	r9,lr
8000a224:	c1 e1       	brne	8000a260 <_free_r+0x68>
8000a226:	f6 08 00 08 	add	r8,r11,r8
8000a22a:	58 0c       	cp.w	r12,0
8000a22c:	c0 81       	brne	8000a23c <_free_r+0x44>
8000a22e:	6c 09       	ld.w	r9,r6[0x0]
8000a230:	12 16       	sub	r6,r9
8000a232:	12 08       	add	r8,r9
8000a234:	6c 3b       	ld.w	r11,r6[0xc]
8000a236:	6c 29       	ld.w	r9,r6[0x8]
8000a238:	97 29       	st.w	r11[0x8],r9
8000a23a:	93 3b       	st.w	r9[0xc],r11
8000a23c:	10 99       	mov	r9,r8
8000a23e:	95 26       	st.w	r10[0x8],r6
8000a240:	a1 a9       	sbr	r9,0x0
8000a242:	8d 19       	st.w	r6[0x4],r9
8000a244:	e0 69 73 9c 	mov	r9,29596
8000a248:	72 09       	ld.w	r9,r9[0x0]
8000a24a:	12 38       	cp.w	r8,r9
8000a24c:	c0 63       	brcs	8000a258 <_free_r+0x60>
8000a24e:	e0 68 77 80 	mov	r8,30592
8000a252:	0e 9c       	mov	r12,r7
8000a254:	70 0b       	ld.w	r11,r8[0x0]
8000a256:	c8 9f       	rcall	8000a168 <_malloc_trim_r>
8000a258:	0e 9c       	mov	r12,r7
8000a25a:	fe b0 e7 15 	rcall	80007084 <__malloc_unlock>
8000a25e:	d8 22       	popm	r4-r7,pc
8000a260:	93 1b       	st.w	r9[0x4],r11
8000a262:	58 0c       	cp.w	r12,0
8000a264:	c0 30       	breq	8000a26a <_free_r+0x72>
8000a266:	30 0c       	mov	r12,0
8000a268:	c1 08       	rjmp	8000a288 <_free_r+0x90>
8000a26a:	6c 0e       	ld.w	lr,r6[0x0]
8000a26c:	f4 c5 ff f8 	sub	r5,r10,-8
8000a270:	1c 16       	sub	r6,lr
8000a272:	1c 08       	add	r8,lr
8000a274:	6c 2e       	ld.w	lr,r6[0x8]
8000a276:	0a 3e       	cp.w	lr,r5
8000a278:	f9 bc 00 01 	moveq	r12,1
8000a27c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a280:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a284:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a288:	f2 0b 00 0e 	add	lr,r9,r11
8000a28c:	7c 1e       	ld.w	lr,lr[0x4]
8000a28e:	ed be 00 00 	bld	lr,0x0
8000a292:	c1 40       	breq	8000a2ba <_free_r+0xc2>
8000a294:	16 08       	add	r8,r11
8000a296:	58 0c       	cp.w	r12,0
8000a298:	c0 d1       	brne	8000a2b2 <_free_r+0xba>
8000a29a:	e0 6e 6f 94 	mov	lr,28564
8000a29e:	72 2b       	ld.w	r11,r9[0x8]
8000a2a0:	2f 8e       	sub	lr,-8
8000a2a2:	1c 3b       	cp.w	r11,lr
8000a2a4:	c0 71       	brne	8000a2b2 <_free_r+0xba>
8000a2a6:	97 36       	st.w	r11[0xc],r6
8000a2a8:	97 26       	st.w	r11[0x8],r6
8000a2aa:	8d 2b       	st.w	r6[0x8],r11
8000a2ac:	8d 3b       	st.w	r6[0xc],r11
8000a2ae:	30 1c       	mov	r12,1
8000a2b0:	c0 58       	rjmp	8000a2ba <_free_r+0xc2>
8000a2b2:	72 2b       	ld.w	r11,r9[0x8]
8000a2b4:	72 39       	ld.w	r9,r9[0xc]
8000a2b6:	93 2b       	st.w	r9[0x8],r11
8000a2b8:	97 39       	st.w	r11[0xc],r9
8000a2ba:	10 99       	mov	r9,r8
8000a2bc:	ec 08 09 08 	st.w	r6[r8],r8
8000a2c0:	a1 a9       	sbr	r9,0x0
8000a2c2:	8d 19       	st.w	r6[0x4],r9
8000a2c4:	58 0c       	cp.w	r12,0
8000a2c6:	c5 a1       	brne	8000a37a <_free_r+0x182>
8000a2c8:	e0 48 01 ff 	cp.w	r8,511
8000a2cc:	e0 8b 00 13 	brhi	8000a2f2 <_free_r+0xfa>
8000a2d0:	a3 98       	lsr	r8,0x3
8000a2d2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a2d6:	72 2b       	ld.w	r11,r9[0x8]
8000a2d8:	8d 39       	st.w	r6[0xc],r9
8000a2da:	8d 2b       	st.w	r6[0x8],r11
8000a2dc:	97 36       	st.w	r11[0xc],r6
8000a2de:	93 26       	st.w	r9[0x8],r6
8000a2e0:	a3 48       	asr	r8,0x2
8000a2e2:	74 19       	ld.w	r9,r10[0x4]
8000a2e4:	30 1b       	mov	r11,1
8000a2e6:	f6 08 09 48 	lsl	r8,r11,r8
8000a2ea:	f3 e8 10 08 	or	r8,r9,r8
8000a2ee:	95 18       	st.w	r10[0x4],r8
8000a2f0:	c4 58       	rjmp	8000a37a <_free_r+0x182>
8000a2f2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a2f6:	58 4b       	cp.w	r11,4
8000a2f8:	e0 8b 00 06 	brhi	8000a304 <_free_r+0x10c>
8000a2fc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a300:	2c 8b       	sub	r11,-56
8000a302:	c2 08       	rjmp	8000a342 <_free_r+0x14a>
8000a304:	59 4b       	cp.w	r11,20
8000a306:	e0 8b 00 04 	brhi	8000a30e <_free_r+0x116>
8000a30a:	2a 5b       	sub	r11,-91
8000a30c:	c1 b8       	rjmp	8000a342 <_free_r+0x14a>
8000a30e:	e0 4b 00 54 	cp.w	r11,84
8000a312:	e0 8b 00 06 	brhi	8000a31e <_free_r+0x126>
8000a316:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a31a:	29 2b       	sub	r11,-110
8000a31c:	c1 38       	rjmp	8000a342 <_free_r+0x14a>
8000a31e:	e0 4b 01 54 	cp.w	r11,340
8000a322:	e0 8b 00 06 	brhi	8000a32e <_free_r+0x136>
8000a326:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a32a:	28 9b       	sub	r11,-119
8000a32c:	c0 b8       	rjmp	8000a342 <_free_r+0x14a>
8000a32e:	e0 4b 05 54 	cp.w	r11,1364
8000a332:	e0 88 00 05 	brls	8000a33c <_free_r+0x144>
8000a336:	37 eb       	mov	r11,126
8000a338:	c0 58       	rjmp	8000a342 <_free_r+0x14a>
8000a33a:	d7 03       	nop
8000a33c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a340:	28 4b       	sub	r11,-124
8000a342:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a346:	78 29       	ld.w	r9,r12[0x8]
8000a348:	18 39       	cp.w	r9,r12
8000a34a:	c0 e1       	brne	8000a366 <_free_r+0x16e>
8000a34c:	74 18       	ld.w	r8,r10[0x4]
8000a34e:	a3 4b       	asr	r11,0x2
8000a350:	30 1c       	mov	r12,1
8000a352:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a356:	f1 eb 10 0b 	or	r11,r8,r11
8000a35a:	12 98       	mov	r8,r9
8000a35c:	95 1b       	st.w	r10[0x4],r11
8000a35e:	c0 a8       	rjmp	8000a372 <_free_r+0x17a>
8000a360:	72 29       	ld.w	r9,r9[0x8]
8000a362:	18 39       	cp.w	r9,r12
8000a364:	c0 60       	breq	8000a370 <_free_r+0x178>
8000a366:	72 1a       	ld.w	r10,r9[0x4]
8000a368:	e0 1a ff fc 	andl	r10,0xfffc
8000a36c:	14 38       	cp.w	r8,r10
8000a36e:	cf 93       	brcs	8000a360 <_free_r+0x168>
8000a370:	72 38       	ld.w	r8,r9[0xc]
8000a372:	8d 38       	st.w	r6[0xc],r8
8000a374:	8d 29       	st.w	r6[0x8],r9
8000a376:	93 36       	st.w	r9[0xc],r6
8000a378:	91 26       	st.w	r8[0x8],r6
8000a37a:	0e 9c       	mov	r12,r7
8000a37c:	fe b0 e6 84 	rcall	80007084 <__malloc_unlock>
8000a380:	d8 22       	popm	r4-r7,pc
8000a382:	d7 03       	nop

Disassembly of section .exception:

8000a400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000a400:	c0 08       	rjmp	8000a400 <_evba>
	...

8000a404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000a404:	c0 08       	rjmp	8000a404 <_handle_TLB_Multiple_Hit>
	...

8000a408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000a408:	c0 08       	rjmp	8000a408 <_handle_Bus_Error_Data_Fetch>
	...

8000a40c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000a40c:	c0 08       	rjmp	8000a40c <_handle_Bus_Error_Instruction_Fetch>
	...

8000a410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000a410:	c0 08       	rjmp	8000a410 <_handle_NMI>
	...

8000a414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000a414:	c0 08       	rjmp	8000a414 <_handle_Instruction_Address>
	...

8000a418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000a418:	c0 08       	rjmp	8000a418 <_handle_ITLB_Protection>
	...

8000a41c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000a41c:	c0 08       	rjmp	8000a41c <_handle_Breakpoint>
	...

8000a420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000a420:	c0 08       	rjmp	8000a420 <_handle_Illegal_Opcode>
	...

8000a424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000a424:	c0 08       	rjmp	8000a424 <_handle_Unimplemented_Instruction>
	...

8000a428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000a428:	c0 08       	rjmp	8000a428 <_handle_Privilege_Violation>
	...

8000a42c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000a42c:	c0 08       	rjmp	8000a42c <_handle_Floating_Point>
	...

8000a430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000a430:	c0 08       	rjmp	8000a430 <_handle_Coprocessor_Absent>
	...

8000a434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000a434:	c0 08       	rjmp	8000a434 <_handle_Data_Address_Read>
	...

8000a438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000a438:	c0 08       	rjmp	8000a438 <_handle_Data_Address_Write>
	...

8000a43c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000a43c:	c0 08       	rjmp	8000a43c <_handle_DTLB_Protection_Read>
	...

8000a440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000a440:	c0 08       	rjmp	8000a440 <_handle_DTLB_Protection_Write>
	...

8000a444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000a444:	c0 08       	rjmp	8000a444 <_handle_DTLB_Modified>
	...

8000a450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000a450:	c0 08       	rjmp	8000a450 <_handle_ITLB_Miss>
	...

8000a460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000a460:	c0 08       	rjmp	8000a460 <_handle_DTLB_Miss_Read>
	...

8000a470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000a470:	c0 08       	rjmp	8000a470 <_handle_DTLB_Miss_Write>
	...

8000a500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000a500:	fe cf 35 d0 	sub	pc,pc,13776

8000a504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000a504:	30 0c       	mov	r12,0
8000a506:	fe b0 f0 85 	rcall	80008610 <_get_interrupt_handler>
8000a50a:	58 0c       	cp.w	r12,0
8000a50c:	f8 0f 17 10 	movne	pc,r12
8000a510:	d6 03       	rete

8000a512 <_int1>:
8000a512:	30 1c       	mov	r12,1
8000a514:	fe b0 f0 7e 	rcall	80008610 <_get_interrupt_handler>
8000a518:	58 0c       	cp.w	r12,0
8000a51a:	f8 0f 17 10 	movne	pc,r12
8000a51e:	d6 03       	rete

8000a520 <_int2>:
8000a520:	30 2c       	mov	r12,2
8000a522:	fe b0 f0 77 	rcall	80008610 <_get_interrupt_handler>
8000a526:	58 0c       	cp.w	r12,0
8000a528:	f8 0f 17 10 	movne	pc,r12
8000a52c:	d6 03       	rete

8000a52e <_int3>:
8000a52e:	30 3c       	mov	r12,3
8000a530:	fe b0 f0 70 	rcall	80008610 <_get_interrupt_handler>
8000a534:	58 0c       	cp.w	r12,0
8000a536:	f8 0f 17 10 	movne	pc,r12
8000a53a:	d6 03       	rete
8000a53c:	d7 03       	nop
8000a53e:	d7 03       	nop
8000a540:	d7 03       	nop
8000a542:	d7 03       	nop
8000a544:	d7 03       	nop
8000a546:	d7 03       	nop
8000a548:	d7 03       	nop
8000a54a:	d7 03       	nop
8000a54c:	d7 03       	nop
8000a54e:	d7 03       	nop
8000a550:	d7 03       	nop
8000a552:	d7 03       	nop
8000a554:	d7 03       	nop
8000a556:	d7 03       	nop
8000a558:	d7 03       	nop
8000a55a:	d7 03       	nop
8000a55c:	d7 03       	nop
8000a55e:	d7 03       	nop
8000a560:	d7 03       	nop
8000a562:	d7 03       	nop
8000a564:	d7 03       	nop
8000a566:	d7 03       	nop
8000a568:	d7 03       	nop
8000a56a:	d7 03       	nop
8000a56c:	d7 03       	nop
8000a56e:	d7 03       	nop
8000a570:	d7 03       	nop
8000a572:	d7 03       	nop
8000a574:	d7 03       	nop
8000a576:	d7 03       	nop
8000a578:	d7 03       	nop
8000a57a:	d7 03       	nop
8000a57c:	d7 03       	nop
8000a57e:	d7 03       	nop
8000a580:	d7 03       	nop
8000a582:	d7 03       	nop
8000a584:	d7 03       	nop
8000a586:	d7 03       	nop
8000a588:	d7 03       	nop
8000a58a:	d7 03       	nop
8000a58c:	d7 03       	nop
8000a58e:	d7 03       	nop
8000a590:	d7 03       	nop
8000a592:	d7 03       	nop
8000a594:	d7 03       	nop
8000a596:	d7 03       	nop
8000a598:	d7 03       	nop
8000a59a:	d7 03       	nop
8000a59c:	d7 03       	nop
8000a59e:	d7 03       	nop
8000a5a0:	d7 03       	nop
8000a5a2:	d7 03       	nop
8000a5a4:	d7 03       	nop
8000a5a6:	d7 03       	nop
8000a5a8:	d7 03       	nop
8000a5aa:	d7 03       	nop
8000a5ac:	d7 03       	nop
8000a5ae:	d7 03       	nop
8000a5b0:	d7 03       	nop
8000a5b2:	d7 03       	nop
8000a5b4:	d7 03       	nop
8000a5b6:	d7 03       	nop
8000a5b8:	d7 03       	nop
8000a5ba:	d7 03       	nop
8000a5bc:	d7 03       	nop
8000a5be:	d7 03       	nop
8000a5c0:	d7 03       	nop
8000a5c2:	d7 03       	nop
8000a5c4:	d7 03       	nop
8000a5c6:	d7 03       	nop
8000a5c8:	d7 03       	nop
8000a5ca:	d7 03       	nop
8000a5cc:	d7 03       	nop
8000a5ce:	d7 03       	nop
8000a5d0:	d7 03       	nop
8000a5d2:	d7 03       	nop
8000a5d4:	d7 03       	nop
8000a5d6:	d7 03       	nop
8000a5d8:	d7 03       	nop
8000a5da:	d7 03       	nop
8000a5dc:	d7 03       	nop
8000a5de:	d7 03       	nop
8000a5e0:	d7 03       	nop
8000a5e2:	d7 03       	nop
8000a5e4:	d7 03       	nop
8000a5e6:	d7 03       	nop
8000a5e8:	d7 03       	nop
8000a5ea:	d7 03       	nop
8000a5ec:	d7 03       	nop
8000a5ee:	d7 03       	nop
8000a5f0:	d7 03       	nop
8000a5f2:	d7 03       	nop
8000a5f4:	d7 03       	nop
8000a5f6:	d7 03       	nop
8000a5f8:	d7 03       	nop
8000a5fa:	d7 03       	nop
8000a5fc:	d7 03       	nop
8000a5fe:	d7 03       	nop
