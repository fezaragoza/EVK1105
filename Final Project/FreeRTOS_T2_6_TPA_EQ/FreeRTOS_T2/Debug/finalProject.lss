
finalProject.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000031e8  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80005200  80005200  00005600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00030a10  80005400  80005400  00005800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000050c  00000008  80035e10  00036408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000514  8003631c  00036914  2**0
                  ALLOC
  8 .bss          000004c8  00000518  00000518  00000000  2**2
                  ALLOC
  9 .heap         0000e620  000009e0  000009e0  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00036914  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000ef8  00000000  00000000  00036948  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002528  00000000  00000000  00037840  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00018576  00000000  00000000  00039d68  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00003665  00000000  00000000  000522de  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000b85e  00000000  00000000  00055943  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  000026f0  00000000  00000000  000611a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00005283  00000000  00000000  00063894  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000069cd  00000000  00000000  00068b17  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00f1fe84  00000000  00000000  0006f4e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000f00  00000000  00000000  00f8f368  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf bc 8c 	sub	pc,pc,-17268

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf dc 90 	sub	pc,pc,-9072

Disassembly of section .text:

80002008 <tpa6130_abdac_tx_pdca_int_handler>:
80002008:	d4 01       	pushm	lr
8000200a:	30 0c       	mov	r12,0
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
8000200c:	f0 1f 00 13 	mcall	80002058 <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002010:	e2 1c 00 02 	andl	r12,0x2,COH
80002014:	c0 d0       	breq	8000202e <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002016:	30 0c       	mov	r12,0
80002018:	f0 1f 00 11 	mcall	8000205c <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
8000201c:	49 18       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
8000201e:	70 28       	ld.w	r8,r8[0x8]
80002020:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002024:	c0 50       	breq	8000202e <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
80002026:	48 f8       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002028:	70 18       	ld.w	r8,r8[0x4]
8000202a:	30 1c       	mov	r12,1
8000202c:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
8000202e:	30 0c       	mov	r12,0
80002030:	f0 1f 00 0a 	mcall	80002058 <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002034:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002038:	c0 d0       	breq	80002052 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
8000203a:	30 0c       	mov	r12,0
8000203c:	f0 1f 00 0a 	mcall	80002064 <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002040:	48 88       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002042:	70 28       	ld.w	r8,r8[0x8]
80002044:	e2 18 00 02 	andl	r8,0x2,COH
80002048:	c0 50       	breq	80002052 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
8000204a:	48 68       	lddpc	r8,80002060 <tpa6130_abdac_tx_pdca_int_handler+0x58>
8000204c:	70 18       	ld.w	r8,r8[0x4]
8000204e:	30 2c       	mov	r12,2
80002050:	5d 18       	icall	r8
  }
}
80002052:	d4 02       	popm	lr
80002054:	d6 03       	rete
80002056:	00 00       	add	r0,r0
80002058:	80 00       	ld.sh	r0,r0[0x0]
8000205a:	26 a0       	sub	r0,106
8000205c:	80 00       	ld.sh	r0,r0[0x0]
8000205e:	26 d8       	sub	r8,109
80002060:	00 00       	add	r0,r0
80002062:	05 18       	ld.sh	r8,r2++
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	26 b0       	sub	r0,107

80002068 <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80002068:	d4 21       	pushm	r4-r7,lr
8000206a:	20 5d       	sub	sp,20
8000206c:	18 94       	mov	r4,r12
8000206e:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80002070:	f7 ec 10 88 	or	r8,r11,r12<<0x8
80002074:	fb 58 00 12 	st.h	sp[18],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80002078:	30 08       	mov	r8,0
8000207a:	30 09       	mov	r9,0
8000207c:	fa e9 00 00 	st.d	sp[0],r8
80002080:	36 08       	mov	r8,96
80002082:	ba 88       	st.b	sp[0x0],r8
80002084:	fa c8 ff ee 	sub	r8,sp,-18
80002088:	50 28       	stdsp	sp[0x8],r8
8000208a:	30 28       	mov	r8,2
8000208c:	50 38       	stdsp	sp[0xc],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
8000208e:	1a 96       	mov	r6,sp
80002090:	fe 77 2c 00 	mov	r7,-54272
80002094:	1a 9b       	mov	r11,sp
80002096:	0e 9c       	mov	r12,r7
80002098:	f0 1f 00 05 	mcall	800020ac <tpa6130_write_data+0x44>
  }
  while( twi_status != TWI_SUCCESS );
8000209c:	cf c1       	brne	80002094 <tpa6130_write_data+0x2c>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
8000209e:	48 58       	lddpc	r8,800020b0 <tpa6130_write_data+0x48>
800020a0:	f0 04 00 04 	add	r4,r8,r4
800020a4:	e9 65 ff ff 	st.b	r4[-1],r5
}
800020a8:	2f bd       	sub	sp,-20
800020aa:	d8 22       	popm	r4-r7,pc
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	28 98       	sub	r8,-119
800020b0:	00 00       	add	r0,r0
800020b2:	00 08       	add	r8,r0

800020b4 <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
800020b4:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
800020b6:	33 f8       	mov	r8,63
800020b8:	f0 0c 18 00 	cp.b	r12,r8
800020bc:	e0 8a 00 04 	brle	800020c4 <tpa6130_set_volume+0x10>
800020c0:	33 fb       	mov	r11,63
800020c2:	c0 b8       	rjmp	800020d8 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
800020c4:	30 08       	mov	r8,0
800020c6:	f0 0c 18 00 	cp.b	r12,r8
800020ca:	e0 89 00 05 	brgt	800020d4 <tpa6130_set_volume+0x20>
800020ce:	e0 6b 00 c0 	mov	r11,192
800020d2:	c0 38       	rjmp	800020d8 <tpa6130_set_volume+0x24>
800020d4:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
800020d8:	30 2c       	mov	r12,2
800020da:	f0 1f 00 02 	mcall	800020e0 <tpa6130_set_volume+0x2c>
}
800020de:	d8 02       	popm	pc
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	20 68       	sub	r8,6

800020e4 <tpa6130_dac_output>:
 * which contain two (16-bit) samples, one for each channel.
 *
 * \note The DACs must have been started beforehand.
 */
bool tpa6130_dac_output(void *sample_buffer, size_t sample_length)
{
800020e4:	eb cd 40 c0 	pushm	r6-r7,lr
800020e8:	18 96       	mov	r6,r12
800020ea:	16 97       	mov	r7,r11
  //int global_interrupt_enabled;

  /*Wait until the PDCA loads the reload value to its transfer
   * counter register(TCRR=0). Then we are ready to set up a new
   * transfer */
  if(!(pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) &
800020ec:	30 0c       	mov	r12,0
800020ee:	f0 1f 00 11 	mcall	80002130 <tpa6130_dac_output+0x4c>
800020f2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800020f6:	c1 b0       	breq	8000212c <tpa6130_dac_output+0x48>
  {
    return false;
  }

  /* Nothing to do if we get no data. */
  if(sample_length)
800020f8:	58 07       	cp.w	r7,0
800020fa:	c1 80       	breq	8000212a <tpa6130_dac_output+0x46>
    //if((global_interrupt_enabled = cpu_irq_is_enabled()))
    //  cpu_irq_disable();

    /*FIXME This assumes a stereo 16-bit sample size */
    // one sample here consists of 2x16-bit (16-bit stereo)
    pdca_reload_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800020fc:	0e 9a       	mov	r10,r7
800020fe:	0c 9b       	mov	r11,r6
80002100:	30 0c       	mov	r12,0
80002102:	f0 1f 00 0d 	mcall	80002134 <tpa6130_dac_output+0x50>
    //if(global_interrupt_enabled)
    //  cpu_irq_enable();

    /*TODO enable transfer complete interrupt
     * Is it possible to move this to setup or other places?*/
    if(tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80002106:	48 d8       	lddpc	r8,80002138 <tpa6130_dac_output+0x54>
80002108:	70 28       	ld.w	r8,r8[0x8]
8000210a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000210e:	c0 40       	breq	80002116 <tpa6130_dac_output+0x32>
      pdca_enable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002110:	30 0c       	mov	r12,0
80002112:	f0 1f 00 0b 	mcall	8000213c <tpa6130_dac_output+0x58>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002116:	48 98       	lddpc	r8,80002138 <tpa6130_dac_output+0x54>
80002118:	70 28       	ld.w	r8,r8[0x8]
8000211a:	e2 18 00 02 	andl	r8,0x2,COH
8000211e:	c0 60       	breq	8000212a <tpa6130_dac_output+0x46>
      pdca_enable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002120:	30 0c       	mov	r12,0
80002122:	f0 1f 00 08 	mcall	80002140 <tpa6130_dac_output+0x5c>
80002126:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000212a:	30 1c       	mov	r12,1
  }
  return true;
}
8000212c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	26 a0       	sub	r0,106
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	27 00       	sub	r0,112
80002138:	00 00       	add	r0,r0
8000213a:	05 18       	ld.sh	r8,r2++
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	26 80       	sub	r0,104
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	26 90       	sub	r0,105

80002144 <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
80002144:	d4 01       	pushm	lr
80002146:	20 5d       	sub	sp,20
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
80002148:	58 0b       	cp.w	r11,0
8000214a:	c0 90       	breq	8000215c <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
8000214c:	48 f8       	lddpc	r8,80002188 <tpa6130_read_data+0x44>
8000214e:	f0 0c 00 0c 	add	r12,r8,r12
80002152:	f9 38 ff ff 	ld.ub	r8,r12[-1]
80002156:	fb 68 00 13 	st.b	sp[19],r8
8000215a:	c1 38       	rjmp	80002180 <tpa6130_read_data+0x3c>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr[0] = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
8000215c:	30 08       	mov	r8,0
8000215e:	30 09       	mov	r9,0
80002160:	fa e9 00 00 	st.d	sp[0],r8
80002164:	36 08       	mov	r8,96
80002166:	ba 88       	st.b	sp[0x0],r8
80002168:	ba 9c       	st.b	sp[0x1],r12
8000216a:	30 18       	mov	r8,1
8000216c:	50 18       	stdsp	sp[0x4],r8
8000216e:	fa c9 ff ed 	sub	r9,sp,-19
80002172:	50 29       	stdsp	sp[0x8],r9
80002174:	50 38       	stdsp	sp[0xc],r8
    twi_master_read(TPA6130_TWI, &twi_package);
80002176:	1a 9b       	mov	r11,sp
80002178:	fe 7c 2c 00 	mov	r12,-54272
8000217c:	f0 1f 00 04 	mcall	8000218c <tpa6130_read_data+0x48>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80002180:	fb 3c 00 13 	ld.ub	r12,sp[19]
80002184:	2f bd       	sub	sp,-20
80002186:	d8 02       	popm	pc
80002188:	00 00       	add	r0,r0
8000218a:	00 08       	add	r8,r0
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	29 70       	sub	r0,-105

80002190 <tpa6130_get_volume>:
/*! \brief Gets the current volume settings.
 *  \returns Current volume settings. Value is between 0 (-59dB) and
 *  63 (4dB).
 */
int8_t tpa6130_get_volume(void)
{
80002190:	d4 01       	pushm	lr
  return tpa6130_read_data(TPA6130_VOLUME_AND_MUTE, TWI_READ_SR);
80002192:	30 1b       	mov	r11,1
80002194:	30 2c       	mov	r12,2
80002196:	f0 1f 00 03 	mcall	800021a0 <tpa6130_get_volume+0x10>
}
8000219a:	5c 5c       	castu.b	r12
8000219c:	d8 02       	popm	pc
8000219e:	00 00       	add	r0,r0
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	21 44       	sub	r4,20

800021a4 <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
800021a4:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
800021a6:	30 0b       	mov	r11,0
800021a8:	30 1c       	mov	r12,1
800021aa:	f0 1f 00 05 	mcall	800021bc <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
800021ae:	18 9b       	mov	r11,r12
800021b0:	e2 1b 00 fe 	andl	r11,0xfe,COH
800021b4:	30 1c       	mov	r12,1
800021b6:	f0 1f 00 03 	mcall	800021c0 <tpa6130_powerup+0x1c>
}
800021ba:	d8 02       	popm	pc
800021bc:	80 00       	ld.sh	r0,r0[0x0]
800021be:	21 44       	sub	r4,20
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	20 68       	sub	r8,6

800021c4 <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
800021c4:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
800021c6:	30 0b       	mov	r11,0
800021c8:	30 1c       	mov	r12,1
800021ca:	f0 1f 00 05 	mcall	800021dc <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
800021ce:	18 9b       	mov	r11,r12
800021d0:	a1 ab       	sbr	r11,0x0
800021d2:	5c 5b       	castu.b	r11
800021d4:	30 1c       	mov	r12,1
800021d6:	f0 1f 00 03 	mcall	800021e0 <tpa6130_shutdown+0x1c>
}
800021da:	d8 02       	popm	pc
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	21 44       	sub	r4,20
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	20 68       	sub	r8,6

800021e4 <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
800021e4:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
800021e6:	f0 1f 00 0b 	mcall	80002210 <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
800021ea:	fe 7c 40 00 	mov	r12,-49152
800021ee:	f0 1f 00 0a 	mcall	80002214 <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
800021f2:	30 0c       	mov	r12,0
800021f4:	f0 1f 00 09 	mcall	80002218 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
800021f8:	30 4b       	mov	r11,4
800021fa:	48 9c       	lddpc	r12,8000221c <tpa6130_dac_stop+0x38>
800021fc:	f0 1f 00 09 	mcall	80002220 <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
80002200:	48 98       	lddpc	r8,80002224 <tpa6130_dac_stop+0x40>
80002202:	30 09       	mov	r9,0
80002204:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
80002206:	30 09       	mov	r9,0
80002208:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
8000220a:	91 29       	st.w	r8[0x8],r9
}
8000220c:	d8 02       	popm	pc
8000220e:	00 00       	add	r0,r0
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	21 c4       	sub	r4,28
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	23 88       	sub	r8,56
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	26 60       	sub	r0,102
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	54 18       	stdsp	sp[0x104],r8
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	41 90       	lddsp	r0,sp[0x64]
80002224:	00 00       	add	r0,r0
80002226:	05 18       	ld.sh	r8,r2++

80002228 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
80002228:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
8000222a:	36 0b       	mov	r11,96
8000222c:	fe 7c 2c 00 	mov	r12,-54272
80002230:	f0 1f 00 0e 	mcall	80002268 <tpa6130_init+0x40>
80002234:	c0 40       	breq	8000223c <tpa6130_init+0x14>
80002236:	e0 6c 00 fd 	mov	r12,253
8000223a:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
8000223c:	30 0b       	mov	r11,0
8000223e:	30 4c       	mov	r12,4
80002240:	f0 1f 00 0b 	mcall	8000226c <tpa6130_init+0x44>
80002244:	30 28       	mov	r8,2
80002246:	f0 0c 18 00 	cp.b	r12,r8
8000224a:	c0 40       	breq	80002252 <tpa6130_init+0x2a>
8000224c:	e0 6c 00 f8 	mov	r12,248
80002250:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
80002252:	48 88       	lddpc	r8,80002270 <tpa6130_init+0x48>
80002254:	11 9b       	ld.ub	r11,r8[0x1]
80002256:	30 2c       	mov	r12,2
80002258:	f0 1f 00 07 	mcall	80002274 <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
8000225c:	e0 6b 00 c0 	mov	r11,192
80002260:	30 1c       	mov	r12,1
80002262:	f0 1f 00 05 	mcall	80002274 <tpa6130_init+0x4c>
80002266:	d8 0a       	popm	pc,r12=0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	29 48       	sub	r8,-108
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	21 44       	sub	r4,20
80002270:	00 00       	add	r0,r0
80002272:	00 08       	add	r8,r0
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	20 68       	sub	r8,6

80002278 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002278:	eb cd 40 c0 	pushm	r6-r7,lr
8000227c:	20 6d       	sub	sp,24
8000227e:	18 97       	mov	r7,r12
80002280:	12 96       	mov	r6,r9
80002282:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
80002284:	49 a9       	lddpc	r9,800022ec <tpa6130_dac_setup+0x74>
80002286:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80002288:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
8000228a:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
8000228c:	f0 1f 00 19 	mcall	800022f0 <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
80002290:	0e 9c       	mov	r12,r7
80002292:	f0 1f 00 19 	mcall	800022f4 <tpa6130_dac_setup+0x7c>
80002296:	c0 a1       	brne	800022aa <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
80002298:	0e 9a       	mov	r10,r7
8000229a:	e0 6b 44 00 	mov	r11,17408
8000229e:	ea 1b 00 ac 	orh	r11,0xac
800022a2:	fe 7c 40 00 	mov	r12,-49152
800022a6:	f0 1f 00 15 	mcall	800022f8 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
800022aa:	58 06       	cp.w	r6,0
800022ac:	c0 50       	breq	800022b6 <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
800022ae:	fe 7c 40 00 	mov	r12,-49152
800022b2:	f0 1f 00 13 	mcall	800022fc <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
800022b6:	fe 7c 40 00 	mov	r12,-49152
800022ba:	f0 1f 00 12 	mcall	80002300 <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
800022be:	49 28       	lddpc	r8,80002304 <tpa6130_dac_setup+0x8c>
800022c0:	1a 9b       	mov	r11,sp
800022c2:	f0 e6 00 00 	ld.d	r6,r8[0]
800022c6:	fa e7 00 00 	st.d	sp[0],r6
800022ca:	f0 e6 00 08 	ld.d	r6,r8[8]
800022ce:	fa e7 00 08 	st.d	sp[8],r6
800022d2:	f0 e8 00 10 	ld.d	r8,r8[16]
800022d6:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
800022da:	30 0c       	mov	r12,0
800022dc:	f0 1f 00 0b 	mcall	80002308 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
800022e0:	30 0c       	mov	r12,0
800022e2:	f0 1f 00 0b 	mcall	8000230c <tpa6130_dac_setup+0x94>

}
800022e6:	2f ad       	sub	sp,-24
800022e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800022ec:	00 00       	add	r0,r0
800022ee:	05 18       	ld.sh	r8,r2++
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	22 28       	sub	r8,34
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	24 34       	sub	r4,67
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	23 b6       	sub	r6,59
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	23 9e       	sub	lr,57
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	23 74       	sub	r4,55
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	54 00       	stdsp	sp[0x100],r0
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	27 38       	sub	r8,115
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	26 70       	sub	r0,103

80002310 <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002310:	eb cd 40 fe 	pushm	r1-r7,lr
80002314:	fa c4 ff e0 	sub	r4,sp,-32
80002318:	18 92       	mov	r2,r12
8000231a:	16 93       	mov	r3,r11
8000231c:	14 95       	mov	r5,r10
8000231e:	12 97       	mov	r7,r9
80002320:	10 96       	mov	r6,r8
80002322:	68 01       	ld.w	r1,r4[0x0]
80002324:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
80002326:	f0 1f 00 0d 	mcall	80002358 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
8000232a:	30 4b       	mov	r11,4
8000232c:	48 cc       	lddpc	r12,8000235c <tpa6130_dac_start+0x4c>
8000232e:	f0 1f 00 0d 	mcall	80002360 <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
80002332:	1a d4       	st.w	--sp,r4
80002334:	1a d1       	st.w	--sp,r1
80002336:	0c 98       	mov	r8,r6
80002338:	0e 99       	mov	r9,r7
8000233a:	0a 9a       	mov	r10,r5
8000233c:	06 9b       	mov	r11,r3
8000233e:	04 9c       	mov	r12,r2
80002340:	f0 1f 00 09 	mcall	80002364 <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
80002344:	30 1a       	mov	r10,1
80002346:	36 0b       	mov	r11,96
80002348:	48 8c       	lddpc	r12,80002368 <tpa6130_dac_start+0x58>
8000234a:	f0 1f 00 09 	mcall	8000236c <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
8000234e:	f0 1f 00 09 	mcall	80002370 <tpa6130_dac_start+0x60>
80002352:	2f ed       	sub	sp,-8

}
80002354:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	21 e4       	sub	r4,30
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	54 18       	stdsp	sp[0x104],r8
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	41 48       	lddsp	r8,sp[0x50]
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	22 78       	sub	r8,39
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	20 08       	sub	r8,0
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	42 68       	lddsp	r8,sp[0x98]
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	21 a4       	sub	r4,26

80002374 <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80002374:	fe 78 0c 00 	mov	r8,-62464
80002378:	71 d9       	ld.w	r9,r8[0x74]
8000237a:	a3 a9       	sbr	r9,0x2
8000237c:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80002380:	78 28       	ld.w	r8,r12[0x8]
80002382:	bf b8       	sbr	r8,0x1f
80002384:	99 28       	st.w	r12[0x8],r8
}
80002386:	5e fc       	retal	r12

80002388 <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
80002388:	78 28       	ld.w	r8,r12[0x8]
8000238a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000238e:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
80002390:	fe 78 0c 00 	mov	r8,-62464
80002394:	71 d9       	ld.w	r9,r8[0x74]
80002396:	a3 c9       	cbr	r9,0x2
80002398:	f1 49 00 74 	st.w	r8[116],r9
}
8000239c:	5e fc       	retal	r12

8000239e <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
8000239e:	78 28       	ld.w	r8,r12[0x8]
800023a0:	e6 18 40 00 	andh	r8,0x4000,COH
800023a4:	c0 50       	breq	800023ae <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
800023a6:	78 28       	ld.w	r8,r12[0x8]
800023a8:	bf c8       	cbr	r8,0x1e
800023aa:	99 28       	st.w	r12[0x8],r8
800023ac:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
800023ae:	78 28       	ld.w	r8,r12[0x8]
800023b0:	bf a8       	sbr	r8,0x1e
800023b2:	99 28       	st.w	r12[0x8],r8
800023b4:	5e fc       	retal	r12

800023b6 <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800023b6:	fe 78 0c 00 	mov	r8,-62464
800023ba:	71 d9       	ld.w	r9,r8[0x74]
800023bc:	30 0c       	mov	r12,0
800023be:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800023c2:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
800023c6:	71 d9       	ld.w	r9,r8[0x74]
800023c8:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800023cc:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
800023d0:	a9 6a       	lsl	r10,0x8
800023d2:	16 3a       	cp.w	r10,r11
800023d4:	e0 88 00 09 	brls	800023e6 <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
800023d8:	71 d9       	ld.w	r9,r8[0x74]
800023da:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800023de:	f1 49 00 74 	st.w	r8[116],r9
800023e2:	31 6c       	mov	r12,22
    return EINVAL;
800023e4:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
800023e6:	f6 0a 0d 08 	divu	r8,r11,r10
800023ea:	5c 88       	casts.h	r8

  if (div > 1) {
800023ec:	30 19       	mov	r9,1
800023ee:	f2 08 19 00 	cp.h	r8,r9
800023f2:	e0 88 00 14 	brls	8000241a <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
800023f6:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
800023fa:	20 1c       	sub	r12,1
800023fc:	5c 5c       	castu.b	r12
800023fe:	fe 79 0c 00 	mov	r9,-62464
80002402:	73 da       	ld.w	r10,r9[0x74]
80002404:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
80002408:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
8000240c:	73 da       	ld.w	r10,r9[0x74]
8000240e:	30 1c       	mov	r12,1
80002410:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80002414:	f3 4a 00 74 	st.w	r9[116],r10
80002418:	c0 98       	rjmp	8000242a <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
8000241a:	fe 79 0c 00 	mov	r9,-62464
8000241e:	73 da       	ld.w	r10,r9[0x74]
80002420:	30 0c       	mov	r12,0
80002422:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80002426:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
8000242a:	5c 78       	castu.h	r8
8000242c:	a9 68       	lsl	r8,0x8
8000242e:	f6 08 0d 0a 	divu	r10,r11,r8
80002432:	5e fa       	retal	r10

80002434 <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80002434:	e0 4c 56 22 	cp.w	r12,22050
80002438:	e0 80 00 8d 	breq	80002552 <abdac_set_dac_sample_rate+0x11e>
8000243c:	e0 8b 00 12 	brhi	80002460 <abdac_set_dac_sample_rate+0x2c>
80002440:	e0 4c 2b 11 	cp.w	r12,11025
80002444:	c3 b0       	breq	800024ba <abdac_set_dac_sample_rate+0x86>
80002446:	e0 8b 00 06 	brhi	80002452 <abdac_set_dac_sample_rate+0x1e>
8000244a:	e0 4c 1f 40 	cp.w	r12,8000
8000244e:	c1 b1       	brne	80002484 <abdac_set_dac_sample_rate+0x50>
80002450:	c1 b8       	rjmp	80002486 <abdac_set_dac_sample_rate+0x52>
80002452:	e0 4c 2e e0 	cp.w	r12,12000
80002456:	c4 b0       	breq	800024ec <abdac_set_dac_sample_rate+0xb8>
80002458:	e0 4c 3e 80 	cp.w	r12,16000
8000245c:	c1 41       	brne	80002484 <abdac_set_dac_sample_rate+0x50>
8000245e:	c6 18       	rjmp	80002520 <abdac_set_dac_sample_rate+0xec>
80002460:	e0 4c 7d 00 	cp.w	r12,32000
80002464:	e0 80 00 aa 	breq	800025b8 <abdac_set_dac_sample_rate+0x184>
80002468:	e0 8b 00 06 	brhi	80002474 <abdac_set_dac_sample_rate+0x40>
8000246c:	e0 4c 5d c0 	cp.w	r12,24000
80002470:	c0 a1       	brne	80002484 <abdac_set_dac_sample_rate+0x50>
80002472:	c8 98       	rjmp	80002584 <abdac_set_dac_sample_rate+0x150>
80002474:	e0 4c ac 44 	cp.w	r12,44100
80002478:	e0 80 00 b9 	breq	800025ea <abdac_set_dac_sample_rate+0x1b6>
8000247c:	e0 4c bb 80 	cp.w	r12,48000
80002480:	e0 80 00 ce 	breq	8000261c <abdac_set_dac_sample_rate+0x1e8>
80002484:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80002486:	fe 78 0c 00 	mov	r8,-62464
8000248a:	71 d9       	ld.w	r9,r8[0x74]
8000248c:	30 ea       	mov	r10,14
8000248e:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80002492:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80002496:	71 d9       	ld.w	r9,r8[0x74]
80002498:	30 1c       	mov	r12,1
8000249a:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000249e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800024a2:	71 d9       	ld.w	r9,r8[0x74]
800024a4:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800024a8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800024ac:	71 d9       	ld.w	r9,r8[0x74]
800024ae:	30 0a       	mov	r10,0
800024b0:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800024b4:	f1 49 00 74 	st.w	r8[116],r9
      break;
800024b8:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
800024ba:	fe 78 0c 00 	mov	r8,-62464
800024be:	71 d9       	ld.w	r9,r8[0x74]
800024c0:	30 1c       	mov	r12,1
800024c2:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
800024c6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800024ca:	71 d9       	ld.w	r9,r8[0x74]
800024cc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800024d0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
800024d4:	71 d9       	ld.w	r9,r8[0x74]
800024d6:	30 0a       	mov	r10,0
800024d8:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
800024dc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
800024e0:	71 d9       	ld.w	r9,r8[0x74]
800024e2:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800024e6:	f1 49 00 74 	st.w	r8[116],r9
        break;
800024ea:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
800024ec:	fe 78 0c 00 	mov	r8,-62464
800024f0:	71 d9       	ld.w	r9,r8[0x74]
800024f2:	30 9a       	mov	r10,9
800024f4:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800024f8:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800024fc:	71 d9       	ld.w	r9,r8[0x74]
800024fe:	30 1c       	mov	r12,1
80002500:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80002504:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80002508:	71 d9       	ld.w	r9,r8[0x74]
8000250a:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
8000250e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80002512:	71 d9       	ld.w	r9,r8[0x74]
80002514:	30 0a       	mov	r10,0
80002516:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
8000251a:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000251e:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80002520:	fe 78 0c 00 	mov	r8,-62464
80002524:	71 d9       	ld.w	r9,r8[0x74]
80002526:	30 5a       	mov	r10,5
80002528:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000252c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80002530:	71 d9       	ld.w	r9,r8[0x74]
80002532:	30 1c       	mov	r12,1
80002534:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80002538:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
8000253c:	71 d9       	ld.w	r9,r8[0x74]
8000253e:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80002542:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80002546:	71 d9       	ld.w	r9,r8[0x74]
80002548:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000254c:	f1 49 00 74 	st.w	r8[116],r9
        break;
80002550:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80002552:	fe 78 0c 00 	mov	r8,-62464
80002556:	71 d9       	ld.w	r9,r8[0x74]
80002558:	30 0a       	mov	r10,0
8000255a:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
8000255e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80002562:	71 d9       	ld.w	r9,r8[0x74]
80002564:	30 1c       	mov	r12,1
80002566:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000256a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
8000256e:	71 d9       	ld.w	r9,r8[0x74]
80002570:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80002574:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80002578:	71 d9       	ld.w	r9,r8[0x74]
8000257a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
8000257e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80002582:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80002584:	fe 78 0c 00 	mov	r8,-62464
80002588:	71 d9       	ld.w	r9,r8[0x74]
8000258a:	30 4a       	mov	r10,4
8000258c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80002590:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80002594:	71 d9       	ld.w	r9,r8[0x74]
80002596:	30 1c       	mov	r12,1
80002598:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
8000259c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800025a0:	71 d9       	ld.w	r9,r8[0x74]
800025a2:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800025a6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
800025aa:	71 d9       	ld.w	r9,r8[0x74]
800025ac:	30 0a       	mov	r10,0
800025ae:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
800025b2:	f1 49 00 74 	st.w	r8[116],r9
        break;
800025b6:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
800025b8:	fe 78 0c 00 	mov	r8,-62464
800025bc:	71 d9       	ld.w	r9,r8[0x74]
800025be:	30 2a       	mov	r10,2
800025c0:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
800025c4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
800025c8:	71 d9       	ld.w	r9,r8[0x74]
800025ca:	30 1c       	mov	r12,1
800025cc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
800025d0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
800025d4:	71 d9       	ld.w	r9,r8[0x74]
800025d6:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
800025da:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
800025de:	71 d9       	ld.w	r9,r8[0x74]
800025e0:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
800025e4:	f1 49 00 74 	st.w	r8[116],r9
        break;
800025e8:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
800025ea:	fe 78 0c 00 	mov	r8,-62464
800025ee:	71 da       	ld.w	r10,r8[0x74]
800025f0:	30 09       	mov	r9,0
800025f2:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
800025f6:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
800025fa:	71 da       	ld.w	r10,r8[0x74]
800025fc:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80002600:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80002604:	71 da       	ld.w	r10,r8[0x74]
80002606:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
8000260a:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
8000260e:	71 d9       	ld.w	r9,r8[0x74]
80002610:	30 1c       	mov	r12,1
80002612:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80002616:	f1 49 00 74 	st.w	r8[116],r9
        break;
8000261a:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
8000261c:	fe 78 0c 00 	mov	r8,-62464
80002620:	71 d9       	ld.w	r9,r8[0x74]
80002622:	30 1c       	mov	r12,1
80002624:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80002628:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
8000262c:	71 d9       	ld.w	r9,r8[0x74]
8000262e:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80002632:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80002636:	71 d9       	ld.w	r9,r8[0x74]
80002638:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
8000263c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80002640:	71 d9       	ld.w	r9,r8[0x74]
80002642:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80002646:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
8000264a:	5e fc       	retal	r12

8000264c <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000264c:	30 e8       	mov	r8,14
8000264e:	f0 0c 18 00 	cp.b	r12,r8
80002652:	e0 88 00 03 	brls	80002658 <pdca_get_handler+0xc>
80002656:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002658:	a7 6c       	lsl	r12,0x6
8000265a:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
8000265e:	5e fc       	retal	r12

80002660 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80002660:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002662:	f0 1f 00 03 	mcall	8000266c <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80002666:	30 28       	mov	r8,2
80002668:	99 58       	st.w	r12[0x14],r8
}
8000266a:	d8 02       	popm	pc
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	26 4c       	sub	r12,100

80002670 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
80002670:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002672:	f0 1f 00 03 	mcall	8000267c <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
80002676:	30 18       	mov	r8,1
80002678:	99 58       	st.w	r12[0x14],r8
}
8000267a:	d8 02       	popm	pc
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	26 4c       	sub	r12,100

80002680 <pdca_enable_interrupt_transfer_complete>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
80002680:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002682:	f0 1f 00 03 	mcall	8000268c <pdca_enable_interrupt_transfer_complete+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80002686:	30 28       	mov	r8,2
80002688:	99 88       	st.w	r12[0x20],r8
}
8000268a:	d8 02       	popm	pc
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	26 4c       	sub	r12,100

80002690 <pdca_enable_interrupt_reload_counter_zero>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80002690:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002692:	f0 1f 00 03 	mcall	8000269c <pdca_enable_interrupt_reload_counter_zero+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
80002696:	30 18       	mov	r8,1
80002698:	99 88       	st.w	r12[0x20],r8
}
8000269a:	d8 02       	popm	pc
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	26 4c       	sub	r12,100

800026a0 <pdca_get_transfer_status>:

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
800026a0:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800026a2:	f0 1f 00 03 	mcall	800026ac <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
800026a6:	78 bc       	ld.w	r12,r12[0x2c]
}
800026a8:	d8 02       	popm	pc
800026aa:	00 00       	add	r0,r0
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	26 4c       	sub	r12,100

800026b0 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800026b0:	d4 01       	pushm	lr
800026b2:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800026b4:	f0 1f 00 08 	mcall	800026d4 <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026b8:	e1 b8 00 00 	mfsr	r8,0x0
800026bc:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800026be:	d3 03       	ssrf	0x10

	return flags;
800026c0:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800026c2:	30 19       	mov	r9,1
800026c4:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800026c6:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800026c8:	e6 18 00 01 	andh	r8,0x1,COH
800026cc:	c0 21       	brne	800026d0 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
800026ce:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800026d0:	2f fd       	sub	sp,-4
800026d2:	d8 02       	popm	pc
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	26 4c       	sub	r12,100

800026d8 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800026d8:	d4 01       	pushm	lr
800026da:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800026dc:	f0 1f 00 08 	mcall	800026fc <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026e0:	e1 b8 00 00 	mfsr	r8,0x0
800026e4:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800026e6:	d3 03       	ssrf	0x10

	return flags;
800026e8:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800026ea:	30 29       	mov	r9,2
800026ec:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800026ee:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800026f0:	e6 18 00 01 	andh	r8,0x1,COH
800026f4:	c0 21       	brne	800026f8 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800026f6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800026f8:	2f fd       	sub	sp,-4
800026fa:	d8 02       	popm	pc
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	26 4c       	sub	r12,100

80002700 <pdca_reload_channel>:
	return pdca_channel->tcrr;
}

void pdca_reload_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
80002700:	eb cd 40 c0 	pushm	r6-r7,lr
80002704:	20 1d       	sub	sp,4
80002706:	16 96       	mov	r6,r11
80002708:	14 97       	mov	r7,r10
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000270a:	f0 1f 00 0b 	mcall	80002734 <pdca_reload_channel+0x34>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000270e:	e1 b8 00 00 	mfsr	r8,0x0
80002712:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80002714:	d3 03       	ssrf	0x10

	return flags;
80002716:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	/* set up next memory address */
	pdca_channel->marr = (uint32_t)addr;
80002718:	99 36       	st.w	r12[0xc],r6
	/* set up next memory size */
	pdca_channel->tcrr = size;
8000271a:	99 47       	st.w	r12[0x10],r7
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000271c:	e0 69 01 00 	mov	r9,256
80002720:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
80002722:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002724:	e6 18 00 01 	andh	r8,0x1,COH
80002728:	c0 21       	brne	8000272c <pdca_reload_channel+0x2c>
      cpu_irq_enable();
8000272a:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
8000272c:	2f fd       	sub	sp,-4
8000272e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002732:	00 00       	add	r0,r0
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	26 4c       	sub	r12,100

80002738 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80002738:	eb cd 40 e0 	pushm	r5-r7,lr
8000273c:	20 1d       	sub	sp,4
8000273e:	18 95       	mov	r5,r12
80002740:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80002742:	f0 1f 00 13 	mcall	8000278c <pdca_init_channel+0x54>
80002746:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80002748:	0a 9c       	mov	r12,r5
8000274a:	f0 1f 00 12 	mcall	80002790 <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
8000274e:	0a 9c       	mov	r12,r5
80002750:	f0 1f 00 11 	mcall	80002794 <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002754:	e1 b8 00 00 	mfsr	r8,0x0
80002758:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
8000275a:	d3 03       	ssrf	0x10

	return flags;
8000275c:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
8000275e:	6c 09       	ld.w	r9,r6[0x0]
80002760:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
80002762:	6c 19       	ld.w	r9,r6[0x4]
80002764:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
80002766:	6c 49       	ld.w	r9,r6[0x10]
80002768:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
8000276a:	6c 29       	ld.w	r9,r6[0x8]
8000276c:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
8000276e:	6c 39       	ld.w	r9,r6[0xc]
80002770:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
80002772:	6c 59       	ld.w	r9,r6[0x14]
80002774:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80002776:	e0 69 01 00 	mov	r9,256
8000277a:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
8000277c:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000277e:	e6 18 00 01 	andh	r8,0x1,COH
80002782:	c0 21       	brne	80002786 <pdca_init_channel+0x4e>
      cpu_irq_enable();
80002784:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80002786:	2f fd       	sub	sp,-4
80002788:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	26 4c       	sub	r12,100
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	26 d8       	sub	r8,109
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	26 b0       	sub	r0,107

80002798 <twi_master_interrupt_handler_not_naked>:
/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80002798:	4a 78       	lddpc	r8,80002834 <twi_master_interrupt_handler_not_naked+0x9c>
8000279a:	70 08       	ld.w	r8,r8[0x0]
8000279c:	70 89       	ld.w	r9,r8[0x20]
8000279e:	4a 7a       	lddpc	r10,80002838 <twi_master_interrupt_handler_not_naked+0xa0>
800027a0:	74 0a       	ld.w	r10,r10[0x0]
800027a2:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800027a6:	12 9a       	mov	r10,r9
800027a8:	e2 1a 01 00 	andl	r10,0x100,COH
800027ac:	c3 91       	brne	8000281e <twi_master_interrupt_handler_not_naked+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800027ae:	12 9a       	mov	r10,r9
800027b0:	e2 1a 00 02 	andl	r10,0x2,COH
800027b4:	c1 70       	breq	800027e2 <twi_master_interrupt_handler_not_naked+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800027b6:	4a 29       	lddpc	r9,8000283c <twi_master_interrupt_handler_not_naked+0xa4>
800027b8:	72 0a       	ld.w	r10,r9[0x0]
800027ba:	70 cb       	ld.w	r11,r8[0x30]
800027bc:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
800027be:	72 0a       	ld.w	r10,r9[0x0]
800027c0:	2f fa       	sub	r10,-1
800027c2:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800027c4:	49 f9       	lddpc	r9,80002840 <twi_master_interrupt_handler_not_naked+0xa8>
800027c6:	72 0a       	ld.w	r10,r9[0x0]
800027c8:	20 1a       	sub	r10,1
800027ca:	93 0a       	st.w	r9[0x0],r10
800027cc:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800027ce:	58 19       	cp.w	r9,1
800027d0:	f9 b9 00 02 	moveq	r9,2
800027d4:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800027d8:	49 a9       	lddpc	r9,80002840 <twi_master_interrupt_handler_not_naked+0xa8>
800027da:	72 09       	ld.w	r9,r9[0x0]
800027dc:	58 09       	cp.w	r9,0
800027de:	c2 30       	breq	80002824 <twi_master_interrupt_handler_not_naked+0x8c>
800027e0:	5e fc       	retal	r12
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800027e2:	12 9a       	mov	r10,r9
800027e4:	e2 1a 00 04 	andl	r10,0x4,COH
800027e8:	c1 70       	breq	80002816 <twi_master_interrupt_handler_not_naked+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800027ea:	49 79       	lddpc	r9,80002844 <twi_master_interrupt_handler_not_naked+0xac>
800027ec:	72 0a       	ld.w	r10,r9[0x0]
800027ee:	20 1a       	sub	r10,1
800027f0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800027f2:	72 09       	ld.w	r9,r9[0x0]
800027f4:	58 09       	cp.w	r9,0
800027f6:	e0 89 00 0a 	brgt	8000280a <twi_master_interrupt_handler_not_naked+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800027fa:	49 09       	lddpc	r9,80002838 <twi_master_interrupt_handler_not_naked+0xa0>
800027fc:	30 1a       	mov	r10,1
800027fe:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80002800:	3f fa       	mov	r10,-1
80002802:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80002804:	72 09       	ld.w	r9,r9[0x0]
80002806:	91 99       	st.w	r8[0x24],r9
80002808:	5e fc       	retal	r12
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
8000280a:	49 0a       	lddpc	r10,80002848 <twi_master_interrupt_handler_not_naked+0xb0>
8000280c:	74 09       	ld.w	r9,r10[0x0]
8000280e:	13 3b       	ld.ub	r11,r9++
80002810:	91 db       	st.w	r8[0x34],r11
80002812:	95 09       	st.w	r10[0x0],r9
80002814:	5e fc       	retal	r12
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80002816:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000281a:	c0 51       	brne	80002824 <twi_master_interrupt_handler_not_naked+0x8c>
8000281c:	5e fc       	retal	r12
	}

	return;

nack:
	twi_nack = true;
8000281e:	30 1a       	mov	r10,1
80002820:	48 b9       	lddpc	r9,8000284c <twi_master_interrupt_handler_not_naked+0xb4>
80002822:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80002824:	3f f9       	mov	r9,-1
80002826:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80002828:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
8000282a:	30 09       	mov	r9,0
8000282c:	48 98       	lddpc	r8,80002850 <twi_master_interrupt_handler_not_naked+0xb8>
8000282e:	b0 89       	st.b	r8[0x0],r9

	return;
}
80002830:	5e fc       	retal	r12
80002832:	00 00       	add	r0,r0
80002834:	00 00       	add	r0,r0
80002836:	05 30       	ld.ub	r0,r2++
80002838:	00 00       	add	r0,r0
8000283a:	05 2c       	ld.uh	r12,r2++
8000283c:	00 00       	add	r0,r0
8000283e:	05 3c       	ld.ub	r12,r2++
80002840:	00 00       	add	r0,r0
80002842:	05 38       	ld.ub	r8,r2++
80002844:	00 00       	add	r0,r0
80002846:	05 28       	ld.uh	r8,r2++
80002848:	00 00       	add	r0,r0
8000284a:	05 34       	ld.ub	r4,r2++
8000284c:	00 00       	add	r0,r0
8000284e:	05 25       	ld.uh	r5,r2++
80002850:	00 00       	add	r0,r0
80002852:	05 24       	ld.uh	r4,r2++

80002854 <twi_master_interrupt_handler>:
#define CONF_TWI_IRQ_GROUP         AVR32_TWI_IRQ_GROUP


/*! \brief TWI interrupt handler.
 */
ISR_FREERTOS(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
80002854:	eb cd 00 ff 	pushm	r0-r7
80002858:	f0 1f 00 03 	mcall	80002864 <twi_master_interrupt_handler+0x10>
8000285c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002860:	d6 03       	rete
80002862:	00 00       	add	r0,r0
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	27 98       	sub	r8,121

80002868 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
80002868:	18 98       	mov	r8,r12
	uint32_t val;

	if (len == 0)
8000286a:	58 0b       	cp.w	r11,0
8000286c:	c0 21       	brne	80002870 <twi_mk_addr+0x8>
8000286e:	5e fd       	retal	0
		return 0;

	val = addr[0];
80002870:	19 8c       	ld.ub	r12,r12[0x0]
	if (len > 1) {
80002872:	58 1b       	cp.w	r11,1
80002874:	e0 8a 00 05 	brle	8000287e <twi_mk_addr+0x16>
		val <<= 8;
		val |= addr[1];
80002878:	11 99       	ld.ub	r9,r8[0x1]
8000287a:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
	}
	if (len > 2) {
8000287e:	58 2b       	cp.w	r11,2
80002880:	5e ac       	retle	r12
		val <<= 8;
		val |= addr[2];
80002882:	11 a8       	ld.ub	r8,r8[0x2]
80002884:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	}
	return val;
}
80002888:	5e fc       	retal	r12
8000288a:	d7 03       	nop

8000288c <twi_is_busy>:
}


bool twi_is_busy(void)
{
	if (twi_busy) {
8000288c:	48 28       	lddpc	r8,80002894 <twi_is_busy+0x8>
8000288e:	11 8c       	ld.ub	r12,r8[0x0]
		return true;          // Still receiving/transmitting...
	} else {
		return false;
	}
}
80002890:	5e fc       	retal	r12
80002892:	00 00       	add	r0,r0
80002894:	00 00       	add	r0,r0
80002896:	05 24       	ld.uh	r4,r2++

80002898 <twi_master_write>:
	return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80002898:	eb cd 40 c0 	pushm	r6-r7,lr
8000289c:	18 96       	mov	r6,r12
8000289e:	16 97       	mov	r7,r11
	// No data to send
	if (package->length == 0) {
800028a0:	76 38       	ld.w	r8,r11[0xc]
800028a2:	58 08       	cp.w	r8,0
800028a4:	c0 51       	brne	800028ae <twi_master_write+0x16>
800028a6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
800028aa:	fe cf ff fc 	sub	pc,pc,-4
	// No data to send
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
800028ae:	f0 1f 00 1f 	mcall	80002928 <twi_master_write+0x90>
800028b2:	cf c1       	brne	800028aa <twi_master_write+0x12>
		cpu_relax();
	};

	twi_nack = false;
800028b4:	30 09       	mov	r9,0
800028b6:	49 e8       	lddpc	r8,8000292c <twi_master_write+0x94>
800028b8:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
800028ba:	30 19       	mov	r9,1
800028bc:	49 d8       	lddpc	r8,80002930 <twi_master_write+0x98>
800028be:	b0 89       	st.b	r8[0x0],r9

	// Enable master transfer, disable slave
	twi->cr =   AVR32_TWI_CR_MSEN_MASK
800028c0:	32 48       	mov	r8,36
800028c2:	8d 08       	st.w	r6[0x0],r8
			| AVR32_TWI_CR_SVDIS_MASK
#endif
			;

	// set write mode, slave address and 3 internal address byte length
	twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800028c4:	6e 18       	ld.w	r8,r7[0x4]
800028c6:	a9 68       	lsl	r8,0x8
800028c8:	e2 18 03 00 	andl	r8,0x300,COH
800028cc:	0f 89       	ld.ub	r9,r7[0x0]
800028ce:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800028d2:	8d 18       	st.w	r6[0x4],r8
			(package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

	// Set pointer to TWI instance for IT
	twi_inst = twi;
800028d4:	49 88       	lddpc	r8,80002934 <twi_master_write+0x9c>
800028d6:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800028d8:	6e 1b       	ld.w	r11,r7[0x4]
800028da:	ee cc ff ff 	sub	r12,r7,-1
800028de:	f0 1f 00 17 	mcall	80002938 <twi_master_write+0xa0>
800028e2:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_tx_data = package->buffer;
800028e4:	6e 29       	ld.w	r9,r7[0x8]
800028e6:	49 68       	lddpc	r8,8000293c <twi_master_write+0xa4>
800028e8:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to write
	twi_tx_nb_bytes = package->length;
800028ea:	6e 3a       	ld.w	r10,r7[0xc]
800028ec:	49 59       	lddpc	r9,80002940 <twi_master_write+0xa8>
800028ee:	93 0a       	st.w	r9[0x0],r10

	// put the first byte in the Transmit Holding Register
	twi->thr = *twi_tx_data++;
800028f0:	70 09       	ld.w	r9,r8[0x0]
800028f2:	13 3a       	ld.ub	r10,r9++
800028f4:	8d da       	st.w	r6[0x34],r10
800028f6:	91 09       	st.w	r8[0x0],r9

	// mask NACK and TXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
800028f8:	49 38       	lddpc	r8,80002944 <twi_master_write+0xac>
800028fa:	e0 69 01 04 	mov	r9,260
800028fe:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
80002900:	70 08       	ld.w	r8,r8[0x0]
80002902:	8d 98       	st.w	r6[0x24],r8

	// send data
	while (twi_is_busy()) {
80002904:	c0 38       	rjmp	8000290a <twi_master_write+0x72>
		cpu_relax();
80002906:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// send data
	while (twi_is_busy()) {
8000290a:	f0 1f 00 08 	mcall	80002928 <twi_master_write+0x90>
8000290e:	cf c1       	brne	80002906 <twi_master_write+0x6e>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80002910:	30 88       	mov	r8,8
80002912:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
80002914:	48 68       	lddpc	r8,8000292c <twi_master_write+0x94>
80002916:	11 8c       	ld.ub	r12,r8[0x0]
80002918:	58 0c       	cp.w	r12,0
8000291a:	f9 bc 01 fb 	movne	r12,-5
8000291e:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80002922:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002926:	00 00       	add	r0,r0
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	28 8c       	sub	r12,-120
8000292c:	00 00       	add	r0,r0
8000292e:	05 25       	ld.uh	r5,r2++
80002930:	00 00       	add	r0,r0
80002932:	05 24       	ld.uh	r4,r2++
80002934:	00 00       	add	r0,r0
80002936:	05 30       	ld.ub	r0,r2++
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	28 68       	sub	r8,-122
8000293c:	00 00       	add	r0,r0
8000293e:	05 34       	ld.ub	r4,r2++
80002940:	00 00       	add	r0,r0
80002942:	05 28       	ld.uh	r8,r2++
80002944:	00 00       	add	r0,r0
80002946:	05 2c       	ld.uh	r12,r2++

80002948 <twi_probe>:
	cpu_irq_restore(flags);
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80002948:	d4 01       	pushm	lr
8000294a:	20 5d       	sub	sp,20
	twi_package_t package;
	char data[1] = {0};
8000294c:	30 08       	mov	r8,0
8000294e:	ba 88       	st.b	sp[0x0],r8

	// data to send
	package.buffer = data;
80002950:	50 3d       	stdsp	sp[0xc],sp
	// chip address
	package.chip = chip_addr;
80002952:	ba cb       	st.b	sp[0x4],r11
	// frame length
	package.length = 1;
80002954:	30 19       	mov	r9,1
80002956:	50 49       	stdsp	sp[0x10],r9
	// address length
	package.addr_length = 0;
80002958:	30 09       	mov	r9,0
8000295a:	50 29       	stdsp	sp[0x8],r9
	// internal chip address
	package.addr[0] = 0;
8000295c:	ba d8       	st.b	sp[0x5],r8
	// perform a master write access
	return (twi_master_write(twi, &package));
8000295e:	fa cb ff fc 	sub	r11,sp,-4
80002962:	f0 1f 00 03 	mcall	8000296c <twi_probe+0x24>
}
80002966:	2f bd       	sub	sp,-20
80002968:	d8 02       	popm	pc
8000296a:	00 00       	add	r0,r0
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	28 98       	sub	r8,-119

80002970 <twi_master_read>:
	}
	return val;
}

int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80002970:	eb cd 40 c0 	pushm	r6-r7,lr
80002974:	18 96       	mov	r6,r12
80002976:	16 97       	mov	r7,r11
	// check argument
	if (package->length == 0) {
80002978:	76 38       	ld.w	r8,r11[0xc]
8000297a:	58 08       	cp.w	r8,0
8000297c:	c0 51       	brne	80002986 <twi_master_read+0x16>
8000297e:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
		cpu_relax();
80002982:	fe cf ff fc 	sub	pc,pc,-4
	// check argument
	if (package->length == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	while (twi_is_busy()) {
80002986:	f0 1f 00 21 	mcall	80002a08 <twi_master_read+0x98>
8000298a:	cf c1       	brne	80002982 <twi_master_read+0x12>
		cpu_relax();
	};

	twi_nack = false;
8000298c:	30 09       	mov	r9,0
8000298e:	4a 08       	lddpc	r8,80002a0c <twi_master_read+0x9c>
80002990:	b0 89       	st.b	r8[0x0],r9
	twi_busy = true;
80002992:	30 19       	mov	r9,1
80002994:	49 f8       	lddpc	r8,80002a10 <twi_master_read+0xa0>
80002996:	b0 89       	st.b	r8[0x0],r9

	// set read mode, slave address and 3 internal address byte length
	twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
80002998:	0f 89       	ld.ub	r9,r7[0x0]
8000299a:	6e 18       	ld.w	r8,r7[0x4]
8000299c:	a9 68       	lsl	r8,0x8
8000299e:	e2 18 03 00 	andl	r8,0x300,COH
800029a2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800029a6:	ad a8       	sbr	r8,0xc
800029a8:	8d 18       	st.w	r6[0x4],r8
			((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
			(1 << AVR32_TWI_MMR_MREAD_OFFSET);

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800029aa:	49 b8       	lddpc	r8,80002a14 <twi_master_read+0xa4>
800029ac:	91 06       	st.w	r8[0x0],r6

	// set internal address for remote chip
	twi->iadr = twi_mk_addr(package->addr, package->addr_length);
800029ae:	6e 1b       	ld.w	r11,r7[0x4]
800029b0:	ee cc ff ff 	sub	r12,r7,-1
800029b4:	f0 1f 00 19 	mcall	80002a18 <twi_master_read+0xa8>
800029b8:	8d 3c       	st.w	r6[0xc],r12

	// get a pointer to applicative data
	twi_rx_data = package->buffer;
800029ba:	6e 29       	ld.w	r9,r7[0x8]
800029bc:	49 88       	lddpc	r8,80002a1c <twi_master_read+0xac>
800029be:	91 09       	st.w	r8[0x0],r9

	// get a copy of nb bytes to read
	twi_rx_nb_bytes = package->length;
800029c0:	6e 39       	ld.w	r9,r7[0xc]
800029c2:	49 88       	lddpc	r8,80002a20 <twi_master_read+0xb0>
800029c4:	91 09       	st.w	r8[0x0],r9

	// Enable master transfer
	twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800029c6:	30 49       	mov	r9,4
800029c8:	8d 09       	st.w	r6[0x0],r9

	// Send start condition
	twi->cr = AVR32_TWI_START_MASK;
800029ca:	30 19       	mov	r9,1
800029cc:	8d 09       	st.w	r6[0x0],r9

	// only one byte to receive
	if (twi_rx_nb_bytes == 1) {
800029ce:	70 08       	ld.w	r8,r8[0x0]
		// set stop bit
		twi->cr = AVR32_TWI_STOP_MASK;
800029d0:	12 38       	cp.w	r8,r9
800029d2:	f9 b8 00 02 	moveq	r8,2
800029d6:	ed f8 0a 00 	st.weq	r6[0x0],r8
	}

	// mask NACK and RXRDY interrupts
	twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
800029da:	49 38       	lddpc	r8,80002a24 <twi_master_read+0xb4>
800029dc:	e0 69 01 02 	mov	r9,258
800029e0:	91 09       	st.w	r8[0x0],r9

	// update IMR through IER
	twi->ier = twi_it_mask;
800029e2:	70 08       	ld.w	r8,r8[0x0]
800029e4:	8d 98       	st.w	r6[0x24],r8

	// get data
	while (twi_is_busy()) {
800029e6:	c0 38       	rjmp	800029ec <twi_master_read+0x7c>
		cpu_relax();
800029e8:	fe cf ff fc 	sub	pc,pc,-4

	// update IMR through IER
	twi->ier = twi_it_mask;

	// get data
	while (twi_is_busy()) {
800029ec:	f0 1f 00 07 	mcall	80002a08 <twi_master_read+0x98>
800029f0:	cf c1       	brne	800029e8 <twi_master_read+0x78>
		cpu_relax();
	}

	// Disable master transfer
	twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
800029f2:	30 88       	mov	r8,8
800029f4:	8d 08       	st.w	r6[0x0],r8

	if (twi_nack) {
800029f6:	48 68       	lddpc	r8,80002a0c <twi_master_read+0x9c>
800029f8:	11 8c       	ld.ub	r12,r8[0x0]
800029fa:	58 0c       	cp.w	r12,0
800029fc:	f9 bc 01 fb 	movne	r12,-5
80002a00:	f9 bc 00 00 	moveq	r12,0
		return TWI_RECEIVE_NACK;
	}

	return TWI_SUCCESS;
}
80002a04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	28 8c       	sub	r12,-120
80002a0c:	00 00       	add	r0,r0
80002a0e:	05 25       	ld.uh	r5,r2++
80002a10:	00 00       	add	r0,r0
80002a12:	05 24       	ld.uh	r4,r2++
80002a14:	00 00       	add	r0,r0
80002a16:	05 30       	ld.ub	r0,r2++
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	28 68       	sub	r8,-122
80002a1c:	00 00       	add	r0,r0
80002a1e:	05 3c       	ld.ub	r12,r2++
80002a20:	00 00       	add	r0,r0
80002a22:	05 38       	ld.ub	r8,r2++
80002a24:	00 00       	add	r0,r0
80002a26:	05 2c       	ld.uh	r12,r2++

80002a28 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80002a28:	eb cd 40 e0 	pushm	r5-r7,lr
80002a2c:	20 1d       	sub	sp,4
80002a2e:	18 97       	mov	r7,r12
80002a30:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80002a32:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80002a36:	4a 29       	lddpc	r9,80002abc <twi_master_init+0x94>
80002a38:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80002a3a:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80002a3c:	3f f9       	mov	r9,-1
80002a3e:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80002a40:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80002a42:	e0 69 00 80 	mov	r9,128
80002a46:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002a48:	e6 18 00 01 	andh	r8,0x1,COH
80002a4c:	c0 21       	brne	80002a50 <twi_master_init+0x28>
      cpu_irq_enable();
80002a4e:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80002a50:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002a52:	e1 b8 00 00 	mfsr	r8,0x0
80002a56:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80002a58:	d3 03       	ssrf	0x10

	return flags;
80002a5a:	40 06       	lddsp	r6,sp[0x0]

	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();
	INTC_init_interrupts(); /**/
80002a5c:	f0 1f 00 19 	mcall	80002ac0 <twi_master_init+0x98>
	INTC_register_interrupt(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL); /**/
80002a60:	30 3a       	mov	r10,3
80002a62:	e0 6b 01 60 	mov	r11,352
80002a66:	49 8c       	lddpc	r12,80002ac4 <twi_master_init+0x9c>
80002a68:	f0 1f 00 18 	mcall	80002ac8 <twi_master_init+0xa0>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002a6c:	e6 16 00 01 	andh	r6,0x1,COH
80002a70:	c0 21       	brne	80002a74 <twi_master_init+0x4c>
      cpu_irq_enable();
80002a72:	d5 03       	csrf	0x10
	//irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE,
	//CONF_TWI_IRQ_LEVEL);
	cpu_irq_restore(flags);
	cpu_irq_enable(); /**/
80002a74:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80002a76:	6a 19       	ld.w	r9,r5[0x4]
80002a78:	a1 79       	lsl	r9,0x1
80002a7a:	6a 08       	ld.w	r8,r5[0x0]
80002a7c:	f0 09 0d 08 	divu	r8,r8,r9
80002a80:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80002a82:	e0 48 00 ff 	cp.w	r8,255
80002a86:	e0 8b 00 04 	brhi	80002a8e <twi_master_init+0x66>
80002a8a:	30 09       	mov	r9,0
80002a8c:	c0 f8       	rjmp	80002aaa <twi_master_init+0x82>
80002a8e:	30 09       	mov	r9,0
80002a90:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80002a92:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80002a94:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80002a96:	e0 48 00 ff 	cp.w	r8,255
80002a9a:	5f bb       	srhi	r11
80002a9c:	58 69       	cp.w	r9,6
80002a9e:	5f 8a       	srls	r10
80002aa0:	f7 ea 00 0a 	and	r10,r11,r10
80002aa4:	f8 0a 18 00 	cp.b	r10,r12
80002aa8:	cf 51       	brne	80002a92 <twi_master_init+0x6a>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80002aaa:	b1 69       	lsl	r9,0x10
80002aac:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80002ab0:	f3 e8 10 08 	or	r8,r9,r8
80002ab4:	8f 48       	st.w	r7[0x10],r8

	// Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80002ab6:	2f fd       	sub	sp,-4
80002ab8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80002abc:	00 00       	add	r0,r0
80002abe:	05 30       	ld.ub	r0,r2++
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	42 e8       	lddsp	r8,sp[0xb8]
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	28 54       	sub	r4,-123
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	42 68       	lddsp	r8,sp[0x98]

80002acc <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80002acc:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80002ace:	f0 1f 00 02 	mcall	80002ad4 <print+0x8>
}
80002ad2:	d8 02       	popm	pc
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	2d c4       	sub	r4,-36

80002ad8 <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
80002ad8:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
80002ada:	18 9b       	mov	r11,r12
80002adc:	fe 7c 14 00 	mov	r12,-60416
80002ae0:	f0 1f 00 02 	mcall	80002ae8 <print_dbg+0x10>
}
80002ae4:	d8 02       	popm	pc
80002ae6:	00 00       	add	r0,r0
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2a cc       	sub	r12,-84

80002aec <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
80002aec:	eb cd 40 80 	pushm	r7,lr
80002af0:	20 3d       	sub	sp,12
80002af2:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
80002af4:	50 0c       	stdsp	sp[0x0],r12
80002af6:	30 88       	mov	r8,8
80002af8:	ba c8       	st.b	sp[0x4],r8
80002afa:	30 48       	mov	r8,4
80002afc:	ba d8       	st.b	sp[0x5],r8
80002afe:	30 08       	mov	r8,0
80002b00:	ba 38       	st.h	sp[0x6],r8
80002b02:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
80002b06:	30 2b       	mov	r11,2
80002b08:	48 6c       	lddpc	r12,80002b20 <init_dbg_rs232_ex+0x34>
80002b0a:	f0 1f 00 07 	mcall	80002b24 <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
80002b0e:	0e 9a       	mov	r10,r7
80002b10:	1a 9b       	mov	r11,sp
80002b12:	fe 7c 14 00 	mov	r12,-60416
80002b16:	f0 1f 00 05 	mcall	80002b28 <init_dbg_rs232_ex+0x3c>
}
80002b1a:	2f dd       	sub	sp,-12
80002b1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	54 38       	stdsp	sp[0x10c],r8
80002b24:	80 00       	ld.sh	r0,r0[0x0]
80002b26:	41 48       	lddsp	r8,sp[0x50]
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	2e 14       	sub	r4,-31

80002b2c <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80002b2c:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
80002b2e:	18 9b       	mov	r11,r12
80002b30:	e0 6c e1 00 	mov	r12,57600
80002b34:	f0 1f 00 02 	mcall	80002b3c <init_dbg_rs232+0x10>
}
80002b38:	d8 02       	popm	pc
80002b3a:	00 00       	add	r0,r0
80002b3c:	80 00       	ld.sh	r0,r0[0x0]
80002b3e:	2a ec       	sub	r12,-82

80002b40 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80002b40:	fe 68 14 00 	mov	r8,-125952
80002b44:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80002b46:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80002b4a:	91 09       	st.w	r8[0x0],r9
}
80002b4c:	5e fc       	retal	r12

80002b4e <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002b4e:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002b50:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002b54:	99 a8       	st.w	r12[0x28],r8
}
80002b56:	5e fc       	retal	r12

80002b58 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002b58:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002b5a:	ec 5b bb 9f 	cp.w	r11,899999
80002b5e:	e0 8b 00 04 	brhi	80002b66 <pm_enable_osc0_crystal+0xe>
80002b62:	30 4b       	mov	r11,4
80002b64:	c1 38       	rjmp	80002b8a <pm_enable_osc0_crystal+0x32>
80002b66:	e0 68 c6 bf 	mov	r8,50879
80002b6a:	ea 18 00 2d 	orh	r8,0x2d
80002b6e:	10 3b       	cp.w	r11,r8
80002b70:	e0 8b 00 04 	brhi	80002b78 <pm_enable_osc0_crystal+0x20>
80002b74:	30 5b       	mov	r11,5
80002b76:	c0 a8       	rjmp	80002b8a <pm_enable_osc0_crystal+0x32>
80002b78:	e0 68 12 00 	mov	r8,4608
80002b7c:	ea 18 00 7a 	orh	r8,0x7a
80002b80:	10 3b       	cp.w	r11,r8
80002b82:	f9 bb 03 06 	movlo	r11,6
80002b86:	f9 bb 02 07 	movhs	r11,7
80002b8a:	f0 1f 00 02 	mcall	80002b90 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002b8e:	d8 02       	popm	pc
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	2b 4e       	sub	lr,-76

80002b94 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002b94:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002b96:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002b9a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002b9c:	78 08       	ld.w	r8,r12[0x0]
80002b9e:	a3 a8       	sbr	r8,0x2
80002ba0:	99 08       	st.w	r12[0x0],r8
}
80002ba2:	5e fc       	retal	r12

80002ba4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002ba4:	79 58       	ld.w	r8,r12[0x54]
80002ba6:	e2 18 00 80 	andl	r8,0x80,COH
80002baa:	cf d0       	breq	80002ba4 <pm_wait_for_clk0_ready>
}
80002bac:	5e fc       	retal	r12
80002bae:	d7 03       	nop

80002bb0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002bb0:	eb cd 40 80 	pushm	r7,lr
80002bb4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002bb6:	f0 1f 00 04 	mcall	80002bc4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002bba:	0e 9c       	mov	r12,r7
80002bbc:	f0 1f 00 03 	mcall	80002bc8 <pm_enable_clk0+0x18>
}
80002bc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	2b 94       	sub	r4,-71
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	2b a4       	sub	r4,-70

80002bcc <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80002bcc:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
80002bce:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80002bd2:	99 b8       	st.w	r12[0x2c],r8
}
80002bd4:	5e fc       	retal	r12
80002bd6:	d7 03       	nop

80002bd8 <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
80002bd8:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
80002bda:	ec 5b bb 9f 	cp.w	r11,899999
80002bde:	e0 8b 00 04 	brhi	80002be6 <pm_enable_osc1_crystal+0xe>
80002be2:	30 4b       	mov	r11,4
80002be4:	c1 38       	rjmp	80002c0a <pm_enable_osc1_crystal+0x32>
80002be6:	e0 68 c6 bf 	mov	r8,50879
80002bea:	ea 18 00 2d 	orh	r8,0x2d
80002bee:	10 3b       	cp.w	r11,r8
80002bf0:	e0 8b 00 04 	brhi	80002bf8 <pm_enable_osc1_crystal+0x20>
80002bf4:	30 5b       	mov	r11,5
80002bf6:	c0 a8       	rjmp	80002c0a <pm_enable_osc1_crystal+0x32>
80002bf8:	e0 68 12 00 	mov	r8,4608
80002bfc:	ea 18 00 7a 	orh	r8,0x7a
80002c00:	10 3b       	cp.w	r11,r8
80002c02:	f9 bb 03 06 	movlo	r11,6
80002c06:	f9 bb 02 07 	movhs	r11,7
80002c0a:	f0 1f 00 02 	mcall	80002c10 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80002c0e:	d8 02       	popm	pc
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	2b cc       	sub	r12,-68

80002c14 <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80002c14:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
80002c16:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
80002c1a:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80002c1c:	78 08       	ld.w	r8,r12[0x0]
80002c1e:	a3 b8       	sbr	r8,0x3
80002c20:	99 08       	st.w	r12[0x0],r8
}
80002c22:	5e fc       	retal	r12

80002c24 <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80002c24:	79 58       	ld.w	r8,r12[0x54]
80002c26:	e2 18 01 00 	andl	r8,0x100,COH
80002c2a:	cf d0       	breq	80002c24 <pm_wait_for_clk1_ready>
}
80002c2c:	5e fc       	retal	r12
80002c2e:	d7 03       	nop

80002c30 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80002c30:	eb cd 40 80 	pushm	r7,lr
80002c34:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
80002c36:	f0 1f 00 04 	mcall	80002c44 <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
80002c3a:	0e 9c       	mov	r12,r7
80002c3c:	f0 1f 00 03 	mcall	80002c48 <pm_enable_clk1+0x18>
}
80002c40:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c44:	80 00       	ld.sh	r0,r0[0x0]
80002c46:	2c 14       	sub	r4,-63
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	2c 24       	sub	r4,-62

80002c4c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80002c4c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80002c50:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80002c54:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80002c56:	09 f7       	ld.ub	r7,r4[0x7]
80002c58:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80002c5c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80002c60:	09 b4       	ld.ub	r4,r4[0x3]
80002c62:	08 96       	mov	r6,r4
80002c64:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80002c68:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80002c6c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80002c70:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80002c74:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80002c78:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80002c7c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80002c80:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80002c84:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80002c86:	79 58       	ld.w	r8,r12[0x54]
80002c88:	e2 18 00 20 	andl	r8,0x20,COH
80002c8c:	cf d0       	breq	80002c86 <pm_cksel+0x3a>
}
80002c8e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80002c92 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80002c92:	eb cd 40 80 	pushm	r7,lr
80002c96:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80002c98:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80002c9a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80002c9e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80002ca2:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80002ca6:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80002caa:	2f 8b       	sub	r11,-8
80002cac:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80002cb0:	e3 cd 80 80 	ldm	sp++,r7,pc

80002cb4 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80002cb4:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80002cb6:	2f 8b       	sub	r11,-8
80002cb8:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80002cbc:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80002cc0:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80002cc4:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80002cc8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80002ccc:	d8 02       	popm	pc

80002cce <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80002cce:	2f 8b       	sub	r11,-8
80002cd0:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80002cd4:	a1 a8       	sbr	r8,0x0
80002cd6:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80002cda:	5e fc       	retal	r12

80002cdc <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80002cdc:	79 58       	ld.w	r8,r12[0x54]
80002cde:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002ce2:	cf d0       	breq	80002cdc <pm_wait_for_pll0_locked>
}
80002ce4:	5e fc       	retal	r12

80002ce6 <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
80002ce6:	79 58       	ld.w	r8,r12[0x54]
80002ce8:	e2 18 00 02 	andl	r8,0x2,COH
80002cec:	cf d0       	breq	80002ce6 <pm_wait_for_pll1_locked>
}
80002cee:	5e fc       	retal	r12

80002cf0 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002cf0:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002cf2:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002cf6:	99 08       	st.w	r12[0x0],r8
}
80002cf8:	5e fc       	retal	r12
80002cfa:	d7 03       	nop

80002cfc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002cfc:	eb cd 40 c0 	pushm	r6-r7,lr
80002d00:	18 97       	mov	r7,r12
80002d02:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002d04:	f0 1f 00 06 	mcall	80002d1c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002d08:	0c 9b       	mov	r11,r6
80002d0a:	0e 9c       	mov	r12,r7
80002d0c:	f0 1f 00 05 	mcall	80002d20 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002d10:	30 1b       	mov	r11,1
80002d12:	0e 9c       	mov	r12,r7
80002d14:	f0 1f 00 04 	mcall	80002d24 <pm_switch_to_osc0+0x28>
}
80002d18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	2b 58       	sub	r8,-75
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	2b b0       	sub	r0,-69
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	2c f0       	sub	r0,-49

80002d28 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002d28:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002d2a:	f6 08 15 04 	lsl	r8,r11,0x4
80002d2e:	14 38       	cp.w	r8,r10
80002d30:	f9 b8 08 10 	movls	r8,16
80002d34:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002d38:	f0 0b 02 4b 	mul	r11,r8,r11
80002d3c:	f6 09 16 01 	lsr	r9,r11,0x1
80002d40:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80002d44:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002d48:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002d4c:	f2 cb 00 01 	sub	r11,r9,1
80002d50:	e0 4b ff fe 	cp.w	r11,65534
80002d54:	e0 88 00 03 	brls	80002d5a <usart_set_async_baudrate+0x32>
80002d58:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002d5a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002d5c:	e8 6e 00 00 	mov	lr,524288
80002d60:	59 08       	cp.w	r8,16
80002d62:	fc 08 17 10 	movne	r8,lr
80002d66:	f9 b8 00 00 	moveq	r8,0
80002d6a:	e4 1b ff f7 	andh	r11,0xfff7
80002d6e:	e0 1b fe cf 	andl	r11,0xfecf
80002d72:	16 48       	or	r8,r11
80002d74:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002d76:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80002d7a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002d7e:	99 89       	st.w	r12[0x20],r9
80002d80:	d8 0a       	popm	pc,r12=0

80002d82 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002d82:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80002d84:	e2 18 00 02 	andl	r8,0x2,COH
80002d88:	c0 31       	brne	80002d8e <usart_write_char+0xc>
80002d8a:	30 2c       	mov	r12,2
80002d8c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002d8e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002d92:	99 7b       	st.w	r12[0x1c],r11
80002d94:	5e fd       	retal	0
80002d96:	d7 03       	nop

80002d98 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80002d98:	eb cd 40 e0 	pushm	r5-r7,lr
80002d9c:	18 96       	mov	r6,r12
80002d9e:	16 95       	mov	r5,r11
80002da0:	e0 67 27 0f 	mov	r7,9999
80002da4:	c0 68       	rjmp	80002db0 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80002da6:	58 07       	cp.w	r7,0
80002da8:	c0 31       	brne	80002dae <usart_putchar+0x16>
80002daa:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80002dae:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80002db0:	0a 9b       	mov	r11,r5
80002db2:	0c 9c       	mov	r12,r6
80002db4:	f0 1f 00 03 	mcall	80002dc0 <usart_putchar+0x28>
80002db8:	cf 71       	brne	80002da6 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80002dba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002dbe:	00 00       	add	r0,r0
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	2d 82       	sub	r2,-40

80002dc4 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80002dc4:	eb cd 40 c0 	pushm	r6-r7,lr
80002dc8:	18 96       	mov	r6,r12
80002dca:	16 97       	mov	r7,r11
  while (*string != '\0')
80002dcc:	17 8b       	ld.ub	r11,r11[0x0]
80002dce:	58 0b       	cp.w	r11,0
80002dd0:	c0 80       	breq	80002de0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80002dd2:	2f f7       	sub	r7,-1
80002dd4:	0c 9c       	mov	r12,r6
80002dd6:	f0 1f 00 04 	mcall	80002de4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002dda:	0f 8b       	ld.ub	r11,r7[0x0]
80002ddc:	58 0b       	cp.w	r11,0
80002dde:	cf a1       	brne	80002dd2 <usart_write_line+0xe>
80002de0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	2d 98       	sub	r8,-39

80002de8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002de8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002dec:	e6 18 00 01 	andh	r8,0x1,COH
80002df0:	c0 71       	brne	80002dfe <usart_reset+0x16>
80002df2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80002df4:	3f f8       	mov	r8,-1
80002df6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002df8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002dfa:	d5 03       	csrf	0x10
80002dfc:	c0 48       	rjmp	80002e04 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80002dfe:	3f f8       	mov	r8,-1
80002e00:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002e02:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80002e04:	30 08       	mov	r8,0
80002e06:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80002e08:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80002e0a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002e0c:	ea 68 61 0c 	mov	r8,680204
80002e10:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002e12:	5e fc       	retal	r12

80002e14 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002e14:	eb cd 40 e0 	pushm	r5-r7,lr
80002e18:	18 96       	mov	r6,r12
80002e1a:	16 97       	mov	r7,r11
80002e1c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002e1e:	f0 1f 00 2f 	mcall	80002ed8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80002e22:	58 07       	cp.w	r7,0
80002e24:	c5 80       	breq	80002ed4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80002e26:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002e28:	30 49       	mov	r9,4
80002e2a:	f2 08 18 00 	cp.b	r8,r9
80002e2e:	e0 88 00 53 	brls	80002ed4 <usart_init_rs232+0xc0>
80002e32:	30 99       	mov	r9,9
80002e34:	f2 08 18 00 	cp.b	r8,r9
80002e38:	e0 8b 00 4e 	brhi	80002ed4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002e3c:	0f d9       	ld.ub	r9,r7[0x5]
80002e3e:	30 78       	mov	r8,7
80002e40:	f0 09 18 00 	cp.b	r9,r8
80002e44:	e0 8b 00 48 	brhi	80002ed4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80002e48:	8e 39       	ld.sh	r9,r7[0x6]
80002e4a:	e0 68 01 01 	mov	r8,257
80002e4e:	f0 09 19 00 	cp.h	r9,r8
80002e52:	e0 8b 00 41 	brhi	80002ed4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80002e56:	ef 39 00 08 	ld.ub	r9,r7[8]
80002e5a:	30 38       	mov	r8,3
80002e5c:	f0 09 18 00 	cp.b	r9,r8
80002e60:	e0 8b 00 3a 	brhi	80002ed4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002e64:	0a 9a       	mov	r10,r5
80002e66:	6e 0b       	ld.w	r11,r7[0x0]
80002e68:	0c 9c       	mov	r12,r6
80002e6a:	f0 1f 00 1d 	mcall	80002edc <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002e6e:	58 1c       	cp.w	r12,1
80002e70:	c3 20       	breq	80002ed4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80002e72:	0f c8       	ld.ub	r8,r7[0x4]
80002e74:	30 99       	mov	r9,9
80002e76:	f2 08 18 00 	cp.b	r8,r9
80002e7a:	c0 51       	brne	80002e84 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002e7c:	6c 18       	ld.w	r8,r6[0x4]
80002e7e:	b1 b8       	sbr	r8,0x11
80002e80:	8d 18       	st.w	r6[0x4],r8
80002e82:	c0 68       	rjmp	80002e8e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002e84:	6c 19       	ld.w	r9,r6[0x4]
80002e86:	20 58       	sub	r8,5
80002e88:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80002e8c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002e8e:	6c 19       	ld.w	r9,r6[0x4]
80002e90:	ef 3a 00 08 	ld.ub	r10,r7[8]
80002e94:	0f d8       	ld.ub	r8,r7[0x5]
80002e96:	a9 78       	lsl	r8,0x9
80002e98:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80002e9c:	12 48       	or	r8,r9
80002e9e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002ea0:	8e 38       	ld.sh	r8,r7[0x6]
80002ea2:	30 29       	mov	r9,2
80002ea4:	f2 08 19 00 	cp.h	r8,r9
80002ea8:	e0 88 00 09 	brls	80002eba <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002eac:	6c 18       	ld.w	r8,r6[0x4]
80002eae:	ad b8       	sbr	r8,0xd
80002eb0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002eb2:	8e b8       	ld.uh	r8,r7[0x6]
80002eb4:	20 28       	sub	r8,2
80002eb6:	8d a8       	st.w	r6[0x28],r8
80002eb8:	c0 68       	rjmp	80002ec4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002eba:	6c 19       	ld.w	r9,r6[0x4]
80002ebc:	5c 78       	castu.h	r8
80002ebe:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80002ec2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002ec4:	6c 18       	ld.w	r8,r6[0x4]
80002ec6:	e0 18 ff f0 	andl	r8,0xfff0
80002eca:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002ecc:	35 08       	mov	r8,80
80002ece:	8d 08       	st.w	r6[0x0],r8
80002ed0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002ed4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	2d e8       	sub	r8,-34
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	2d 28       	sub	r8,-46

80002ee0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002ee0:	f8 c8 ff f8 	sub	r8,r12,-8
80002ee4:	99 18       	st.w	r12[0x4],r8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
80002ee6:	3f f9       	mov	r9,-1
80002ee8:	99 29       	st.w	r12[0x8],r9

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002eea:	99 38       	st.w	r12[0xc],r8
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002eec:	99 48       	st.w	r12[0x10],r8

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
80002eee:	30 08       	mov	r8,0
80002ef0:	99 08       	st.w	r12[0x0],r8

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80002ef2:	5e fc       	retal	r12

80002ef4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
80002ef4:	30 08       	mov	r8,0
80002ef6:	99 48       	st.w	r12[0x10],r8

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
80002ef8:	5e fc       	retal	r12

80002efa <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
80002efa:	78 18       	ld.w	r8,r12[0x4]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
80002efc:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80002efe:	70 29       	ld.w	r9,r8[0x8]
80002f00:	97 29       	st.w	r11[0x8],r9

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
80002f02:	70 29       	ld.w	r9,r8[0x8]
80002f04:	93 1b       	st.w	r9[0x4],r11
    pxIndex->pxPrevious = pxNewListItem;
80002f06:	91 2b       	st.w	r8[0x8],r11

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
80002f08:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80002f0a:	78 08       	ld.w	r8,r12[0x0]
80002f0c:	2f f8       	sub	r8,-1
80002f0e:	99 08       	st.w	r12[0x0],r8
}
80002f10:	5e fc       	retal	r12

80002f12 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
80002f12:	d4 01       	pushm	lr
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80002f14:	76 0e       	ld.w	lr,r11[0x0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
80002f16:	5b fe       	cp.w	lr,-1
80002f18:	c0 31       	brne	80002f1e <vListInsert+0xc>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
80002f1a:	78 49       	ld.w	r9,r12[0x10]
80002f1c:	c0 98       	rjmp	80002f2e <vListInsert+0x1c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
80002f1e:	f8 c9 ff f8 	sub	r9,r12,-8
80002f22:	72 18       	ld.w	r8,r9[0x4]
80002f24:	70 0a       	ld.w	r10,r8[0x0]
80002f26:	14 3e       	cp.w	lr,r10
80002f28:	c0 33       	brcs	80002f2e <vListInsert+0x1c>
80002f2a:	10 99       	mov	r9,r8
80002f2c:	cf bb       	rjmp	80002f22 <vListInsert+0x10>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
80002f2e:	72 18       	ld.w	r8,r9[0x4]
80002f30:	97 18       	st.w	r11[0x4],r8
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80002f32:	91 2b       	st.w	r8[0x8],r11
    pxNewListItem->pxPrevious = pxIterator;
80002f34:	97 29       	st.w	r11[0x8],r9
    pxIterator->pxNext = pxNewListItem;
80002f36:	93 1b       	st.w	r9[0x4],r11

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
80002f38:	97 4c       	st.w	r11[0x10],r12

    ( pxList->uxNumberOfItems )++;
80002f3a:	78 08       	ld.w	r8,r12[0x0]
80002f3c:	2f f8       	sub	r8,-1
80002f3e:	99 08       	st.w	r12[0x0],r8
}
80002f40:	d8 02       	popm	pc

80002f42 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
80002f42:	78 48       	ld.w	r8,r12[0x10]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002f44:	78 19       	ld.w	r9,r12[0x4]
80002f46:	78 2a       	ld.w	r10,r12[0x8]
80002f48:	93 2a       	st.w	r9[0x8],r10
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002f4a:	78 29       	ld.w	r9,r12[0x8]
80002f4c:	78 1a       	ld.w	r10,r12[0x4]
80002f4e:	93 1a       	st.w	r9[0x4],r10

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
80002f50:	70 19       	ld.w	r9,r8[0x4]
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
80002f52:	18 39       	cp.w	r9,r12
80002f54:	f3 f9 00 02 	ld.weq	r9,r9[0x8]
80002f58:	f1 f9 0a 01 	st.weq	r8[0x4],r9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
80002f5c:	30 09       	mov	r9,0
80002f5e:	99 49       	st.w	r12[0x10],r9
    ( pxList->uxNumberOfItems )--;
80002f60:	70 09       	ld.w	r9,r8[0x0]
80002f62:	20 19       	sub	r9,1
80002f64:	91 09       	st.w	r8[0x0],r9

    return pxList->uxNumberOfItems;
80002f66:	70 0c       	ld.w	r12,r8[0x0]
}
80002f68:	5e fc       	retal	r12

80002f6a <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( StackType_t ) 0x08080808;					/* R8 */
80002f6a:	e0 68 08 08 	mov	r8,2056
80002f6e:	ea 18 08 08 	orh	r8,0x808
80002f72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x09090909;					/* R9 */
80002f74:	e0 68 09 09 	mov	r8,2313
80002f78:	ea 18 09 09 	orh	r8,0x909
80002f7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;					/* R10 */
80002f7e:	e0 68 0a 0a 	mov	r8,2570
80002f82:	ea 18 0a 0a 	orh	r8,0xa0a
80002f86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;					/* R11 */
80002f88:	e0 68 0b 0b 	mov	r8,2827
80002f8c:	ea 18 0b 0b 	orh	r8,0xb0b
80002f90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pvParameters;					/* R12 */
80002f92:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;					/* R14/LR */
80002f94:	e0 68 be ef 	mov	r8,48879
80002f98:	ea 18 de ad 	orh	r8,0xdead
80002f9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80002f9e:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;				/* SR */
80002fa0:	fc 18 00 40 	movh	r8,0x40
80002fa4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;					/* R0 */
80002fa6:	e0 68 00 ff 	mov	r8,255
80002faa:	ea 18 ff 00 	orh	r8,0xff00
80002fae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x01010101;					/* R1 */
80002fb0:	e0 68 01 01 	mov	r8,257
80002fb4:	ea 18 01 01 	orh	r8,0x101
80002fb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x02020202;					/* R2 */
80002fba:	e0 68 02 02 	mov	r8,514
80002fbe:	ea 18 02 02 	orh	r8,0x202
80002fc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x03030303;					/* R3 */
80002fc4:	e0 68 03 03 	mov	r8,771
80002fc8:	ea 18 03 03 	orh	r8,0x303
80002fcc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x04040404;					/* R4 */
80002fce:	e0 68 04 04 	mov	r8,1028
80002fd2:	ea 18 04 04 	orh	r8,0x404
80002fd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x05050505;					/* R5 */
80002fd8:	e0 68 05 05 	mov	r8,1285
80002fdc:	ea 18 05 05 	orh	r8,0x505
80002fe0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x06060606;					/* R6 */
80002fe2:	e0 68 06 06 	mov	r8,1542
80002fe6:	ea 18 06 06 	orh	r8,0x606
80002fea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( StackType_t ) 0x07070707;					/* R7 */
80002fec:	e0 68 07 07 	mov	r8,1799
80002ff0:	ea 18 07 07 	orh	r8,0x707
80002ff4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80002ff6:	30 08       	mov	r8,0
80002ff8:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80002ffa:	5e fc       	retal	r12

80002ffc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002ffc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80002ffe:	48 38       	lddpc	r8,80003008 <vPortEnterCritical+0xc>
80003000:	70 09       	ld.w	r9,r8[0x0]
80003002:	2f f9       	sub	r9,-1
80003004:	91 09       	st.w	r8[0x0],r9
}
80003006:	5e fc       	retal	r12
80003008:	00 00       	add	r0,r0
8000300a:	00 0c       	add	r12,r0

8000300c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
8000300c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000300e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80003010:	30 0a       	mov	r10,0
80003012:	14 9b       	mov	r11,r10
80003014:	49 2c       	lddpc	r12,8000305c <xPortStartScheduler+0x50>
80003016:	f0 1f 00 13 	mcall	80003060 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000301a:	e0 68 2e e0 	mov	r8,12000
8000301e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80003022:	30 08       	mov	r8,0
80003024:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80003028:	e0 68 05 fc 	mov	r8,1532
8000302c:	ea 18 00 00 	orh	r8,0x0
80003030:	70 00       	ld.w	r0,r8[0x0]
80003032:	60 0d       	ld.w	sp,r0[0x0]
80003034:	1b 00       	ld.w	r0,sp++
80003036:	e0 68 00 0c 	mov	r8,12
8000303a:	ea 18 00 00 	orh	r8,0x0
8000303e:	91 00       	st.w	r8[0x0],r0
80003040:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003044:	2f ed       	sub	sp,-8
80003046:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000304a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000304e:	e3 b0 00 00 	mtsr	0x0,r0
80003052:	fa f0 ff dc 	ld.w	r0,sp[-36]
80003056:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000305a:	d8 0a       	popm	pc,r12=0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	31 28       	mov	r8,18
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	42 68       	lddsp	r8,sp[0x98]

80003064 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80003064:	20 6d       	sub	sp,24
80003066:	eb cd 00 ff 	pushm	r0-r7
8000306a:	fa c7 ff c0 	sub	r7,sp,-64
8000306e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80003072:	ef 40 ff e0 	st.w	r7[-32],r0
80003076:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000307a:	ef 40 ff e4 	st.w	r7[-28],r0
8000307e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80003082:	e0 68 00 0c 	mov	r8,12
80003086:	ea 18 00 00 	orh	r8,0x0
8000308a:	70 00       	ld.w	r0,r8[0x0]
8000308c:	1a d0       	st.w	--sp,r0
8000308e:	f0 1f 00 1a 	mcall	800030f4 <LABEL_RET_SCALL_243+0x14>
80003092:	e0 68 05 fc 	mov	r8,1532
80003096:	ea 18 00 00 	orh	r8,0x0
8000309a:	70 00       	ld.w	r0,r8[0x0]
8000309c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000309e:	f0 1f 00 17 	mcall	800030f8 <LABEL_RET_SCALL_243+0x18>
	portRESTORE_CONTEXT_SCALL();
800030a2:	e0 68 05 fc 	mov	r8,1532
800030a6:	ea 18 00 00 	orh	r8,0x0
800030aa:	70 00       	ld.w	r0,r8[0x0]
800030ac:	60 0d       	ld.w	sp,r0[0x0]
800030ae:	1b 00       	ld.w	r0,sp++
800030b0:	e0 68 00 0c 	mov	r8,12
800030b4:	ea 18 00 00 	orh	r8,0x0
800030b8:	91 00       	st.w	r8[0x0],r0
800030ba:	fa c7 ff d8 	sub	r7,sp,-40
800030be:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800030c2:	ee f0 ff e0 	ld.w	r0,r7[-32]
800030c6:	e0 61 00 0c 	mov	r1,12
800030ca:	ea 11 00 00 	orh	r1,0x0
800030ce:	62 02       	ld.w	r2,r1[0x0]
800030d0:	58 02       	cp.w	r2,0
800030d2:	c0 70       	breq	800030e0 <LABEL_RET_SCALL_243>
800030d4:	e4 c2 00 01 	sub	r2,r2,1
800030d8:	83 02       	st.w	r1[0x0],r2
800030da:	58 02       	cp.w	r2,0
800030dc:	c0 21       	brne	800030e0 <LABEL_RET_SCALL_243>
800030de:	b1 c0       	cbr	r0,0x10

800030e0 <LABEL_RET_SCALL_243>:
800030e0:	ef 40 ff f8 	st.w	r7[-8],r0
800030e4:	ee f0 ff e4 	ld.w	r0,r7[-28]
800030e8:	ef 40 ff fc 	st.w	r7[-4],r0
800030ec:	e3 cd 00 ff 	ldm	sp++,r0-r7
800030f0:	2f ad       	sub	sp,-24
800030f2:	d6 13       	rets
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	2f fc       	sub	r12,-1
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	36 a4       	mov	r4,106

800030fc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800030fc:	e1 b8 00 43 	mfsr	r8,0x10c
80003100:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80003104:	5e fc       	retal	r12
80003106:	d7 03       	nop

80003108 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80003108:	48 78       	lddpc	r8,80003124 <vPortExitCritical+0x1c>
8000310a:	70 08       	ld.w	r8,r8[0x0]
8000310c:	58 08       	cp.w	r8,0
8000310e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80003110:	48 58       	lddpc	r8,80003124 <vPortExitCritical+0x1c>
80003112:	70 09       	ld.w	r9,r8[0x0]
80003114:	20 19       	sub	r9,1
80003116:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80003118:	70 08       	ld.w	r8,r8[0x0]
8000311a:	58 08       	cp.w	r8,0
8000311c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000311e:	d5 03       	csrf	0x10
80003120:	5e fc       	retal	r12
80003122:	00 00       	add	r0,r0
80003124:	00 00       	add	r0,r0
80003126:	00 0c       	add	r12,r0

80003128 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80003128:	eb cd 00 ff 	pushm	r0-r7
8000312c:	e0 68 00 0c 	mov	r8,12
80003130:	ea 18 00 00 	orh	r8,0x0
80003134:	70 00       	ld.w	r0,r8[0x0]
80003136:	1a d0       	st.w	--sp,r0
80003138:	7a 90       	ld.w	r0,sp[0x24]
8000313a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000313e:	58 10       	cp.w	r0,1
80003140:	e0 8b 00 08 	brhi	80003150 <LABEL_INT_SKIP_SAVE_CONTEXT_216>
80003144:	e0 68 05 fc 	mov	r8,1532
80003148:	ea 18 00 00 	orh	r8,0x0
8000314c:	70 00       	ld.w	r0,r8[0x0]
8000314e:	81 0d       	st.w	r0[0x0],sp

80003150 <LABEL_INT_SKIP_SAVE_CONTEXT_216>:
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
		clock cycles from now. */
		prvClearCcInt();
80003150:	f0 1f 00 12 	mcall	80003198 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80003154:	f0 1f 00 12 	mcall	8000319c <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
		xTaskIncrementTick();
80003158:	f0 1f 00 12 	mcall	800031a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x1c>
	portEXIT_CRITICAL();
8000315c:	f0 1f 00 12 	mcall	800031a4 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80003160:	7a 90       	ld.w	r0,sp[0x24]
80003162:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80003166:	58 10       	cp.w	r0,1
80003168:	e0 8b 00 0e 	brhi	80003184 <LABEL_INT_SKIP_RESTORE_CONTEXT_234>
8000316c:	f0 1f 00 0c 	mcall	8000319c <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x18>
80003170:	f0 1f 00 0e 	mcall	800031a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x24>
80003174:	f0 1f 00 0c 	mcall	800031a4 <LABEL_INT_SKIP_RESTORE_CONTEXT_234+0x20>
80003178:	e0 68 05 fc 	mov	r8,1532
8000317c:	ea 18 00 00 	orh	r8,0x0
80003180:	70 00       	ld.w	r0,r8[0x0]
80003182:	60 0d       	ld.w	sp,r0[0x0]

80003184 <LABEL_INT_SKIP_RESTORE_CONTEXT_234>:
80003184:	1b 00       	ld.w	r0,sp++
80003186:	e0 68 00 0c 	mov	r8,12
8000318a:	ea 18 00 00 	orh	r8,0x0
8000318e:	91 00       	st.w	r8[0x0],r0
80003190:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003194:	d6 03       	rete
80003196:	00 00       	add	r0,r0
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	30 fc       	mov	r12,15
8000319c:	80 00       	ld.sh	r0,r0[0x0]
8000319e:	2f fc       	sub	r12,-1
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	39 b0       	mov	r0,-101
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	31 08       	mov	r8,16
800031a8:	80 00       	ld.sh	r0,r0[0x0]
800031aa:	36 a4       	mov	r4,106

800031ac <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800031ac:	d4 01       	pushm	lr
	vTaskSuspendAll();
800031ae:	f0 1f 00 02 	mcall	800031b4 <__malloc_lock+0x8>
}
800031b2:	d8 02       	popm	pc
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	36 94       	mov	r4,105

800031b8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800031b8:	d4 01       	pushm	lr
	xTaskResumeAll();
800031ba:	f0 1f 00 02 	mcall	800031c0 <__malloc_unlock+0x8>
}
800031be:	d8 02       	popm	pc
800031c0:	80 00       	ld.sh	r0,r0[0x0]
800031c2:	3a b8       	mov	r8,-85

800031c4 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
800031c4:	eb cd 40 80 	pushm	r7,lr
800031c8:	18 97       	mov	r7,r12
    if( pv )
800031ca:	58 0c       	cp.w	r12,0
800031cc:	c0 80       	breq	800031dc <vPortFree+0x18>
    {
        vTaskSuspendAll();
800031ce:	f0 1f 00 05 	mcall	800031e0 <vPortFree+0x1c>
        {
            free( pv );
800031d2:	0e 9c       	mov	r12,r7
800031d4:	f0 1f 00 04 	mcall	800031e4 <vPortFree+0x20>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
800031d8:	f0 1f 00 04 	mcall	800031e8 <vPortFree+0x24>
800031dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	36 94       	mov	r4,105
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	49 d4       	lddpc	r4,80003258 <prvCopyDataFromQueue+0x24>
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	3a b8       	mov	r8,-85

800031ec <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
800031ec:	eb cd 40 80 	pushm	r7,lr
800031f0:	18 97       	mov	r7,r12
    void * pvReturn;

    vTaskSuspendAll();
800031f2:	f0 1f 00 06 	mcall	80003208 <pvPortMalloc+0x1c>
    {
        pvReturn = malloc( xWantedSize );
800031f6:	0e 9c       	mov	r12,r7
800031f8:	f0 1f 00 05 	mcall	8000320c <pvPortMalloc+0x20>
800031fc:	18 97       	mov	r7,r12
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
800031fe:	f0 1f 00 05 	mcall	80003210 <pvPortMalloc+0x24>
            }
        }
    #endif

    return pvReturn;
}
80003202:	0e 9c       	mov	r12,r7
80003204:	e3 cd 80 80 	ldm	sp++,r7,pc
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	36 94       	mov	r4,105
8000320c:	80 00       	ld.sh	r0,r0[0x0]
8000320e:	49 e4       	lddpc	r4,80003284 <prvUnlockQueue+0x20>
80003210:	80 00       	ld.sh	r0,r0[0x0]
80003212:	3a b8       	mov	r8,-85

80003214 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
80003214:	eb cd 40 80 	pushm	r7,lr
80003218:	18 97       	mov	r7,r12
    BaseType_t xReturn;

    taskENTER_CRITICAL();
8000321a:	f0 1f 00 05 	mcall	8000322c <prvIsQueueEmpty+0x18>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
8000321e:	6e e7       	ld.w	r7,r7[0x38]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
80003220:	f0 1f 00 04 	mcall	80003230 <prvIsQueueEmpty+0x1c>
80003224:	58 07       	cp.w	r7,0

    return xReturn;
}
80003226:	5f 0c       	sreq	r12
80003228:	e3 cd 80 80 	ldm	sp++,r7,pc
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	2f fc       	sub	r12,-1
80003230:	80 00       	ld.sh	r0,r0[0x0]
80003232:	31 08       	mov	r8,16

80003234 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
80003234:	d4 01       	pushm	lr
80003236:	16 98       	mov	r8,r11
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80003238:	79 09       	ld.w	r9,r12[0x40]
8000323a:	58 09       	cp.w	r9,0
8000323c:	c1 00       	breq	8000325c <prvCopyDataFromQueue+0x28>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
8000323e:	78 3a       	ld.w	r10,r12[0xc]
80003240:	f4 09 00 09 	add	r9,r10,r9
80003244:	99 39       	st.w	r12[0xc],r9

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80003246:	78 2a       	ld.w	r10,r12[0x8]
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
80003248:	14 39       	cp.w	r9,r10
8000324a:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000324e:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
80003252:	79 0a       	ld.w	r10,r12[0x40]
80003254:	78 3b       	ld.w	r11,r12[0xc]
80003256:	10 9c       	mov	r12,r8
80003258:	f0 1f 00 02 	mcall	80003260 <prvCopyDataFromQueue+0x2c>
8000325c:	d8 02       	popm	pc
8000325e:	00 00       	add	r0,r0
80003260:	80 00       	ld.sh	r0,r0[0x0]
80003262:	4e 28       	lddpc	r8,800033e8 <xQueueReceive+0xdc>

80003264 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
80003264:	d4 21       	pushm	r4-r7,lr
80003266:	18 96       	mov	r6,r12

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
80003268:	f0 1f 00 25 	mcall	800032fc <prvUnlockQueue+0x98>
    {
        int8_t cTxLock = pxQueue->cTxLock;
8000326c:	ed 37 00 45 	ld.ub	r7,r6[69]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80003270:	30 08       	mov	r8,0
80003272:	f0 07 18 00 	cp.b	r7,r8
80003276:	e0 8a 00 18 	brle	800032a6 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000327a:	6c 98       	ld.w	r8,r6[0x24]
8000327c:	58 08       	cp.w	r8,0
8000327e:	c1 40       	breq	800032a6 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003280:	ec c4 ff dc 	sub	r4,r6,-36
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
80003284:	30 05       	mov	r5,0
80003286:	c0 48       	rjmp	8000328e <prvUnlockQueue+0x2a>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003288:	6c 98       	ld.w	r8,r6[0x24]
8000328a:	58 08       	cp.w	r8,0
8000328c:	c0 d0       	breq	800032a6 <prvUnlockQueue+0x42>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000328e:	08 9c       	mov	r12,r4
80003290:	f0 1f 00 1c 	mcall	80003300 <prvUnlockQueue+0x9c>
80003294:	c0 30       	breq	8000329a <prvUnlockQueue+0x36>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
80003296:	f0 1f 00 1c 	mcall	80003304 <prvUnlockQueue+0xa0>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
8000329a:	20 17       	sub	r7,1
8000329c:	5c 57       	castu.b	r7
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
8000329e:	ea 07 18 00 	cp.b	r7,r5
800032a2:	fe 99 ff f3 	brgt	80003288 <prvUnlockQueue+0x24>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
800032a6:	3f f8       	mov	r8,-1
800032a8:	ed 68 00 45 	st.b	r6[69],r8
    }
    taskEXIT_CRITICAL();
800032ac:	f0 1f 00 17 	mcall	80003308 <prvUnlockQueue+0xa4>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
800032b0:	f0 1f 00 13 	mcall	800032fc <prvUnlockQueue+0x98>
    {
        int8_t cRxLock = pxQueue->cRxLock;
800032b4:	ed 37 00 44 	ld.ub	r7,r6[68]

        while( cRxLock > queueLOCKED_UNMODIFIED )
800032b8:	30 08       	mov	r8,0
800032ba:	f0 07 18 00 	cp.b	r7,r8
800032be:	e0 8a 00 18 	brle	800032ee <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800032c2:	6c 48       	ld.w	r8,r6[0x10]
800032c4:	58 08       	cp.w	r8,0
800032c6:	c1 40       	breq	800032ee <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800032c8:	ec c4 ff f0 	sub	r4,r6,-16
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
800032cc:	30 05       	mov	r5,0
800032ce:	c0 48       	rjmp	800032d6 <prvUnlockQueue+0x72>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800032d0:	6c 48       	ld.w	r8,r6[0x10]
800032d2:	58 08       	cp.w	r8,0
800032d4:	c0 d0       	breq	800032ee <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800032d6:	08 9c       	mov	r12,r4
800032d8:	f0 1f 00 0a 	mcall	80003300 <prvUnlockQueue+0x9c>
800032dc:	c0 30       	breq	800032e2 <prvUnlockQueue+0x7e>
                {
                    vTaskMissedYield();
800032de:	f0 1f 00 0a 	mcall	80003304 <prvUnlockQueue+0xa0>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
800032e2:	20 17       	sub	r7,1
800032e4:	5c 57       	castu.b	r7
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
800032e6:	ea 07 18 00 	cp.b	r7,r5
800032ea:	fe 99 ff f3 	brgt	800032d0 <prvUnlockQueue+0x6c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
800032ee:	3f f8       	mov	r8,-1
800032f0:	ed 68 00 44 	st.b	r6[68],r8
    }
    taskEXIT_CRITICAL();
800032f4:	f0 1f 00 05 	mcall	80003308 <prvUnlockQueue+0xa4>
}
800032f8:	d8 22       	popm	r4-r7,pc
800032fa:	00 00       	add	r0,r0
800032fc:	80 00       	ld.sh	r0,r0[0x0]
800032fe:	2f fc       	sub	r12,-1
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	39 24       	mov	r4,-110
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	37 30       	mov	r0,115
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	31 08       	mov	r8,16

8000330c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
8000330c:	d4 31       	pushm	r0-r7,lr
8000330e:	20 5d       	sub	sp,20
80003310:	18 97       	mov	r7,r12
80003312:	50 1b       	stdsp	sp[0x4],r11
80003314:	50 2a       	stdsp	sp[0x8],r10
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80003316:	f8 c8 ff dc 	sub	r8,r12,-36
8000331a:	50 08       	stdsp	sp[0x0],r8
8000331c:	30 04       	mov	r4,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000331e:	fa c3 ff f4 	sub	r3,sp,-12
80003322:	30 10       	mov	r0,1

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
80003324:	3f f5       	mov	r5,-1
80003326:	30 01       	mov	r1,0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003328:	fa c2 ff f8 	sub	r2,sp,-8
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
8000332c:	f0 1f 00 30 	mcall	800033ec <xQueueReceive+0xe0>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80003330:	6e e6       	ld.w	r6,r7[0x38]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80003332:	58 06       	cp.w	r6,0
80003334:	c1 40       	breq	8000335c <xQueueReceive+0x50>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
80003336:	40 1b       	lddsp	r11,sp[0x4]
80003338:	0e 9c       	mov	r12,r7
8000333a:	f0 1f 00 2e 	mcall	800033f0 <xQueueReceive+0xe4>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
8000333e:	20 16       	sub	r6,1
80003340:	8f e6       	st.w	r7[0x38],r6

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80003342:	6e 48       	ld.w	r8,r7[0x10]
80003344:	58 08       	cp.w	r8,0
80003346:	c0 70       	breq	80003354 <xQueueReceive+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80003348:	ee cc ff f0 	sub	r12,r7,-16
8000334c:	f0 1f 00 2a 	mcall	800033f4 <xQueueReceive+0xe8>
80003350:	c0 20       	breq	80003354 <xQueueReceive+0x48>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
80003352:	d7 33       	scall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
80003354:	f0 1f 00 29 	mcall	800033f8 <xQueueReceive+0xec>
80003358:	30 1c       	mov	r12,1
                return pdPASS;
8000335a:	c4 78       	rjmp	800033e8 <xQueueReceive+0xdc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
8000335c:	40 28       	lddsp	r8,sp[0x8]
8000335e:	58 08       	cp.w	r8,0
80003360:	c0 51       	brne	8000336a <xQueueReceive+0x5e>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
80003362:	f0 1f 00 26 	mcall	800033f8 <xQueueReceive+0xec>
80003366:	30 0c       	mov	r12,0
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
80003368:	c4 08       	rjmp	800033e8 <xQueueReceive+0xdc>
                }
                else if( xEntryTimeSet == pdFALSE )
8000336a:	58 04       	cp.w	r4,0
8000336c:	c0 51       	brne	80003376 <xQueueReceive+0x6a>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000336e:	06 9c       	mov	r12,r3
80003370:	f0 1f 00 23 	mcall	800033fc <xQueueReceive+0xf0>
80003374:	00 94       	mov	r4,r0
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80003376:	f0 1f 00 21 	mcall	800033f8 <xQueueReceive+0xec>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
8000337a:	f0 1f 00 22 	mcall	80003400 <xQueueReceive+0xf4>
        prvLockQueue( pxQueue );
8000337e:	f0 1f 00 1c 	mcall	800033ec <xQueueReceive+0xe0>
80003382:	ef 38 00 44 	ld.ub	r8,r7[68]
80003386:	ea 08 18 00 	cp.b	r8,r5
8000338a:	ef f1 0e 44 	st.beq	r7[0x44],r1
8000338e:	ef 38 00 45 	ld.ub	r8,r7[69]
80003392:	ea 08 18 00 	cp.b	r8,r5
80003396:	ef f1 0e 45 	st.beq	r7[0x45],r1
8000339a:	f0 1f 00 18 	mcall	800033f8 <xQueueReceive+0xec>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000339e:	04 9b       	mov	r11,r2
800033a0:	06 9c       	mov	r12,r3
800033a2:	f0 1f 00 19 	mcall	80003404 <xQueueReceive+0xf8>
800033a6:	c1 71       	brne	800033d4 <xQueueReceive+0xc8>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800033a8:	0e 9c       	mov	r12,r7
800033aa:	f0 1f 00 18 	mcall	80003408 <xQueueReceive+0xfc>
800033ae:	c0 d0       	breq	800033c8 <xQueueReceive+0xbc>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800033b0:	40 2b       	lddsp	r11,sp[0x8]
800033b2:	40 0c       	lddsp	r12,sp[0x0]
800033b4:	f0 1f 00 16 	mcall	8000340c <xQueueReceive+0x100>
                prvUnlockQueue( pxQueue );
800033b8:	0e 9c       	mov	r12,r7
800033ba:	f0 1f 00 16 	mcall	80003410 <xQueueReceive+0x104>

                if( xTaskResumeAll() == pdFALSE )
800033be:	f0 1f 00 16 	mcall	80003414 <xQueueReceive+0x108>
800033c2:	cb 51       	brne	8000332c <xQueueReceive+0x20>
                {
                    portYIELD_WITHIN_API();
800033c4:	d7 33       	scall
800033c6:	cb 3b       	rjmp	8000332c <xQueueReceive+0x20>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
800033c8:	0e 9c       	mov	r12,r7
800033ca:	f0 1f 00 12 	mcall	80003410 <xQueueReceive+0x104>
                ( void ) xTaskResumeAll();
800033ce:	f0 1f 00 12 	mcall	80003414 <xQueueReceive+0x108>
800033d2:	ca db       	rjmp	8000332c <xQueueReceive+0x20>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
800033d4:	0e 9c       	mov	r12,r7
800033d6:	f0 1f 00 0f 	mcall	80003410 <xQueueReceive+0x104>
            ( void ) xTaskResumeAll();
800033da:	f0 1f 00 0f 	mcall	80003414 <xQueueReceive+0x108>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800033de:	0e 9c       	mov	r12,r7
800033e0:	f0 1f 00 0a 	mcall	80003408 <xQueueReceive+0xfc>
800033e4:	ca 40       	breq	8000332c <xQueueReceive+0x20>
800033e6:	30 0c       	mov	r12,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
800033e8:	2f bd       	sub	sp,-20
800033ea:	d8 32       	popm	r0-r7,pc
800033ec:	80 00       	ld.sh	r0,r0[0x0]
800033ee:	2f fc       	sub	r12,-1
800033f0:	80 00       	ld.sh	r0,r0[0x0]
800033f2:	32 34       	mov	r4,35
800033f4:	80 00       	ld.sh	r0,r0[0x0]
800033f6:	39 24       	mov	r4,-110
800033f8:	80 00       	ld.sh	r0,r0[0x0]
800033fa:	31 08       	mov	r8,16
800033fc:	80 00       	ld.sh	r0,r0[0x0]
800033fe:	37 18       	mov	r8,113
80003400:	80 00       	ld.sh	r0,r0[0x0]
80003402:	36 94       	mov	r4,105
80003404:	80 00       	ld.sh	r0,r0[0x0]
80003406:	37 64       	mov	r4,118
80003408:	80 00       	ld.sh	r0,r0[0x0]
8000340a:	32 14       	mov	r4,33
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	3e 04       	mov	r4,-32
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	32 64       	mov	r4,38
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	3a b8       	mov	r8,-85

80003418 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
80003418:	eb cd 40 e0 	pushm	r5-r7,lr
8000341c:	18 97       	mov	r7,r12
8000341e:	14 96       	mov	r6,r10
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80003420:	78 e5       	ld.w	r5,r12[0x38]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80003422:	79 0a       	ld.w	r10,r12[0x40]
80003424:	58 0a       	cp.w	r10,0
80003426:	c0 a1       	brne	8000343a <prvCopyDataToQueue+0x22>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80003428:	78 08       	ld.w	r8,r12[0x0]
8000342a:	58 08       	cp.w	r8,0
8000342c:	c3 11       	brne	8000348e <prvCopyDataToQueue+0x76>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
8000342e:	78 2c       	ld.w	r12,r12[0x8]
80003430:	f0 1f 00 1a 	mcall	80003498 <prvCopyDataToQueue+0x80>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
80003434:	30 08       	mov	r8,0
80003436:	8f 28       	st.w	r7[0x8],r8
80003438:	c2 c8       	rjmp	80003490 <prvCopyDataToQueue+0x78>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
8000343a:	58 06       	cp.w	r6,0
8000343c:	c1 01       	brne	8000345c <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
8000343e:	78 1c       	ld.w	r12,r12[0x4]
80003440:	f0 1f 00 17 	mcall	8000349c <prvCopyDataToQueue+0x84>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
80003444:	6e 19       	ld.w	r9,r7[0x4]
80003446:	6f 08       	ld.w	r8,r7[0x40]
80003448:	f2 08 00 08 	add	r8,r9,r8
8000344c:	8f 18       	st.w	r7[0x4],r8

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
8000344e:	6e 29       	ld.w	r9,r7[0x8]
80003450:	12 38       	cp.w	r8,r9
80003452:	c1 e3       	brcs	8000348e <prvCopyDataToQueue+0x76>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
80003454:	6e 08       	ld.w	r8,r7[0x0]
80003456:	8f 18       	st.w	r7[0x4],r8
80003458:	30 0c       	mov	r12,0
8000345a:	c1 b8       	rjmp	80003490 <prvCopyDataToQueue+0x78>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
8000345c:	78 3c       	ld.w	r12,r12[0xc]
8000345e:	f0 1f 00 10 	mcall	8000349c <prvCopyDataToQueue+0x84>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
80003462:	6f 08       	ld.w	r8,r7[0x40]
80003464:	6e 39       	ld.w	r9,r7[0xc]
80003466:	f2 08 01 08 	sub	r8,r9,r8
8000346a:	8f 38       	st.w	r7[0xc],r8

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
8000346c:	6e 09       	ld.w	r9,r7[0x0]
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
8000346e:	12 38       	cp.w	r8,r9
80003470:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80003474:	ef f9 30 02 	ld.wcs	r9,r7[0x8]
80003478:	f3 d8 e3 19 	subcs	r9,r9,r8
8000347c:	ef f9 3a 03 	st.wcs	r7[0xc],r9
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
80003480:	58 26       	cp.w	r6,2
80003482:	c0 61       	brne	8000348e <prvCopyDataToQueue+0x76>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80003484:	58 05       	cp.w	r5,0
80003486:	c0 40       	breq	8000348e <prvCopyDataToQueue+0x76>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
80003488:	20 15       	sub	r5,1
8000348a:	30 0c       	mov	r12,0
8000348c:	c0 28       	rjmp	80003490 <prvCopyDataToQueue+0x78>
8000348e:	30 0c       	mov	r12,0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
80003490:	2f f5       	sub	r5,-1
80003492:	8f e5       	st.w	r7[0x38],r5

    return xReturn;
}
80003494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003498:	80 00       	ld.sh	r0,r0[0x0]
8000349a:	38 bc       	mov	r12,-117
8000349c:	80 00       	ld.sh	r0,r0[0x0]
8000349e:	4e 28       	lddpc	r8,80003624 <xQueueGenericReset+0x68>

800034a0 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
800034a0:	d4 31       	pushm	r0-r7,lr
800034a2:	20 5d       	sub	sp,20
800034a4:	18 97       	mov	r7,r12
800034a6:	50 1b       	stdsp	sp[0x4],r11
800034a8:	50 2a       	stdsp	sp[0x8],r10
800034aa:	12 91       	mov	r1,r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800034ac:	f8 c8 ff f0 	sub	r8,r12,-16
800034b0:	50 08       	stdsp	sp[0x0],r8
800034b2:	30 03       	mov	r3,0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
800034b4:	fa c2 ff f4 	sub	r2,sp,-12

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
        prvLockQueue( pxQueue );
800034b8:	3f f5       	mov	r5,-1

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800034ba:	fa c0 ff f8 	sub	r0,sp,-8
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
800034be:	f0 1f 00 36 	mcall	80003594 <xQueueGenericSend+0xf4>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
800034c2:	6e e9       	ld.w	r9,r7[0x38]
800034c4:	6e f8       	ld.w	r8,r7[0x3c]
800034c6:	10 39       	cp.w	r9,r8
800034c8:	c0 33       	brcs	800034ce <xQueueGenericSend+0x2e>
800034ca:	58 21       	cp.w	r1,2
800034cc:	c1 71       	brne	800034fa <xQueueGenericSend+0x5a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800034ce:	02 9a       	mov	r10,r1
800034d0:	40 1b       	lddsp	r11,sp[0x4]
800034d2:	0e 9c       	mov	r12,r7
800034d4:	f0 1f 00 31 	mcall	80003598 <xQueueGenericSend+0xf8>

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800034d8:	6e 98       	ld.w	r8,r7[0x24]
800034da:	58 08       	cp.w	r8,0
800034dc:	c0 80       	breq	800034ec <xQueueGenericSend+0x4c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800034de:	ee cc ff dc 	sub	r12,r7,-36
800034e2:	f0 1f 00 2f 	mcall	8000359c <xQueueGenericSend+0xfc>
800034e6:	c0 60       	breq	800034f2 <xQueueGenericSend+0x52>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
800034e8:	d7 33       	scall
800034ea:	c0 48       	rjmp	800034f2 <xQueueGenericSend+0x52>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
800034ec:	58 0c       	cp.w	r12,0
800034ee:	c0 20       	breq	800034f2 <xQueueGenericSend+0x52>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
800034f0:	d7 33       	scall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
800034f2:	f0 1f 00 2c 	mcall	800035a0 <xQueueGenericSend+0x100>
800034f6:	30 1c       	mov	r12,1
                return pdPASS;
800034f8:	c4 b8       	rjmp	8000358e <xQueueGenericSend+0xee>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
800034fa:	40 28       	lddsp	r8,sp[0x8]
800034fc:	58 08       	cp.w	r8,0
800034fe:	c0 51       	brne	80003508 <xQueueGenericSend+0x68>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
80003500:	f0 1f 00 28 	mcall	800035a0 <xQueueGenericSend+0x100>
80003504:	30 0c       	mov	r12,0

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
80003506:	c4 48       	rjmp	8000358e <xQueueGenericSend+0xee>
                }
                else if( xEntryTimeSet == pdFALSE )
80003508:	58 03       	cp.w	r3,0
8000350a:	c0 51       	brne	80003514 <xQueueGenericSend+0x74>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
8000350c:	04 9c       	mov	r12,r2
8000350e:	f0 1f 00 26 	mcall	800035a4 <xQueueGenericSend+0x104>
80003512:	30 13       	mov	r3,1
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
80003514:	f0 1f 00 23 	mcall	800035a0 <xQueueGenericSend+0x100>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
80003518:	f0 1f 00 24 	mcall	800035a8 <xQueueGenericSend+0x108>
        prvLockQueue( pxQueue );
8000351c:	f0 1f 00 1e 	mcall	80003594 <xQueueGenericSend+0xf4>
80003520:	ef 38 00 44 	ld.ub	r8,r7[68]
80003524:	ea 08 18 00 	cp.b	r8,r5
80003528:	f9 b8 00 00 	moveq	r8,0
8000352c:	ef f8 0e 44 	st.beq	r7[0x44],r8
80003530:	ef 38 00 45 	ld.ub	r8,r7[69]
80003534:	ea 08 18 00 	cp.b	r8,r5
80003538:	f9 b8 00 00 	moveq	r8,0
8000353c:	ef f8 0e 45 	st.beq	r7[0x45],r8
80003540:	f0 1f 00 18 	mcall	800035a0 <xQueueGenericSend+0x100>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003544:	00 9b       	mov	r11,r0
80003546:	04 9c       	mov	r12,r2
80003548:	f0 1f 00 19 	mcall	800035ac <xQueueGenericSend+0x10c>
8000354c:	c1 b1       	brne	80003582 <xQueueGenericSend+0xe2>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
8000354e:	f0 1f 00 12 	mcall	80003594 <xQueueGenericSend+0xf4>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
80003552:	6e e4       	ld.w	r4,r7[0x38]
80003554:	6e f6       	ld.w	r6,r7[0x3c]
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
80003556:	f0 1f 00 13 	mcall	800035a0 <xQueueGenericSend+0x100>
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
8000355a:	0c 34       	cp.w	r4,r6
8000355c:	c0 d1       	brne	80003576 <xQueueGenericSend+0xd6>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000355e:	40 2b       	lddsp	r11,sp[0x8]
80003560:	40 0c       	lddsp	r12,sp[0x0]
80003562:	f0 1f 00 14 	mcall	800035b0 <xQueueGenericSend+0x110>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
80003566:	0e 9c       	mov	r12,r7
80003568:	f0 1f 00 13 	mcall	800035b4 <xQueueGenericSend+0x114>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
8000356c:	f0 1f 00 13 	mcall	800035b8 <xQueueGenericSend+0x118>
80003570:	ca 71       	brne	800034be <xQueueGenericSend+0x1e>
                {
                    portYIELD_WITHIN_API();
80003572:	d7 33       	scall
80003574:	ca 5b       	rjmp	800034be <xQueueGenericSend+0x1e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
80003576:	0e 9c       	mov	r12,r7
80003578:	f0 1f 00 0f 	mcall	800035b4 <xQueueGenericSend+0x114>
                ( void ) xTaskResumeAll();
8000357c:	f0 1f 00 0f 	mcall	800035b8 <xQueueGenericSend+0x118>
80003580:	c9 fb       	rjmp	800034be <xQueueGenericSend+0x1e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
80003582:	0e 9c       	mov	r12,r7
80003584:	f0 1f 00 0c 	mcall	800035b4 <xQueueGenericSend+0x114>
            ( void ) xTaskResumeAll();
80003588:	f0 1f 00 0c 	mcall	800035b8 <xQueueGenericSend+0x118>
8000358c:	30 0c       	mov	r12,0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
8000358e:	2f bd       	sub	sp,-20
80003590:	d8 32       	popm	r0-r7,pc
80003592:	00 00       	add	r0,r0
80003594:	80 00       	ld.sh	r0,r0[0x0]
80003596:	2f fc       	sub	r12,-1
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	34 18       	mov	r8,65
8000359c:	80 00       	ld.sh	r0,r0[0x0]
8000359e:	39 24       	mov	r4,-110
800035a0:	80 00       	ld.sh	r0,r0[0x0]
800035a2:	31 08       	mov	r8,16
800035a4:	80 00       	ld.sh	r0,r0[0x0]
800035a6:	37 18       	mov	r8,113
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	36 94       	mov	r4,105
800035ac:	80 00       	ld.sh	r0,r0[0x0]
800035ae:	37 64       	mov	r4,118
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	3e 04       	mov	r4,-32
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	32 64       	mov	r4,38
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	3a b8       	mov	r8,-85

800035bc <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
800035bc:	eb cd 40 c0 	pushm	r6-r7,lr
800035c0:	18 97       	mov	r7,r12
800035c2:	16 96       	mov	r6,r11
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
800035c4:	f0 1f 00 18 	mcall	80003624 <xQueueGenericReset+0x68>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
800035c8:	6f 09       	ld.w	r9,r7[0x40]
800035ca:	6e fa       	ld.w	r10,r7[0x3c]
800035cc:	f2 0a 02 4b 	mul	r11,r9,r10
800035d0:	6e 08       	ld.w	r8,r7[0x0]
800035d2:	f0 0b 00 0b 	add	r11,r8,r11
800035d6:	8f 2b       	st.w	r7[0x8],r11
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
800035d8:	30 0b       	mov	r11,0
800035da:	8f eb       	st.w	r7[0x38],r11
        pxQueue->pcWriteTo = pxQueue->pcHead;
800035dc:	8f 18       	st.w	r7[0x4],r8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
800035de:	20 1a       	sub	r10,1
800035e0:	f4 09 02 49 	mul	r9,r10,r9
800035e4:	12 08       	add	r8,r9
800035e6:	8f 38       	st.w	r7[0xc],r8
        pxQueue->cRxLock = queueUNLOCKED;
800035e8:	3f f8       	mov	r8,-1
800035ea:	ef 68 00 44 	st.b	r7[68],r8
        pxQueue->cTxLock = queueUNLOCKED;
800035ee:	ef 68 00 45 	st.b	r7[69],r8

        if( xNewQueue == pdFALSE )
800035f2:	58 06       	cp.w	r6,0
800035f4:	c0 b1       	brne	8000360a <xQueueGenericReset+0x4e>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800035f6:	6e 48       	ld.w	r8,r7[0x10]
800035f8:	58 08       	cp.w	r8,0
800035fa:	c1 00       	breq	8000361a <xQueueGenericReset+0x5e>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800035fc:	ee cc ff f0 	sub	r12,r7,-16
80003600:	f0 1f 00 0a 	mcall	80003628 <xQueueGenericReset+0x6c>
80003604:	c0 b0       	breq	8000361a <xQueueGenericReset+0x5e>
                {
                    queueYIELD_IF_USING_PREEMPTION();
80003606:	d7 33       	scall
80003608:	c0 98       	rjmp	8000361a <xQueueGenericReset+0x5e>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
8000360a:	ee cc ff f0 	sub	r12,r7,-16
8000360e:	f0 1f 00 08 	mcall	8000362c <xQueueGenericReset+0x70>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
80003612:	ee cc ff dc 	sub	r12,r7,-36
80003616:	f0 1f 00 06 	mcall	8000362c <xQueueGenericReset+0x70>
        }
    }
    taskEXIT_CRITICAL();
8000361a:	f0 1f 00 06 	mcall	80003630 <xQueueGenericReset+0x74>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
8000361e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003622:	00 00       	add	r0,r0
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	2f fc       	sub	r12,-1
80003628:	80 00       	ld.sh	r0,r0[0x0]
8000362a:	39 24       	mov	r4,-110
8000362c:	80 00       	ld.sh	r0,r0[0x0]
8000362e:	2e e0       	sub	r0,-18
80003630:	80 00       	ld.sh	r0,r0[0x0]
80003632:	31 08       	mov	r8,16

80003634 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
80003634:	eb cd 40 e0 	pushm	r5-r7,lr
80003638:	18 95       	mov	r5,r12
8000363a:	16 96       	mov	r6,r11
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
8000363c:	f6 0c 02 4c 	mul	r12,r11,r12
80003640:	2b 8c       	sub	r12,-72
80003642:	f0 1f 00 0b 	mcall	8000366c <xQueueGenericCreate+0x38>
80003646:	18 97       	mov	r7,r12

        if( pxNewQueue != NULL )
80003648:	c0 f0       	breq	80003666 <xQueueGenericCreate+0x32>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
8000364a:	58 06       	cp.w	r6,0
8000364c:	c0 31       	brne	80003652 <xQueueGenericCreate+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
8000364e:	8f 0c       	st.w	r7[0x0],r12
80003650:	c0 48       	rjmp	80003658 <xQueueGenericCreate+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
80003652:	f8 c8 ff b8 	sub	r8,r12,-72
80003656:	99 08       	st.w	r12[0x0],r8
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
80003658:	8f f5       	st.w	r7[0x3c],r5
    pxNewQueue->uxItemSize = uxItemSize;
8000365a:	ef 46 00 40 	st.w	r7[64],r6
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
8000365e:	30 1b       	mov	r11,1
80003660:	0e 9c       	mov	r12,r7
80003662:	f0 1f 00 04 	mcall	80003670 <xQueueGenericCreate+0x3c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
80003666:	0e 9c       	mov	r12,r7
80003668:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	31 ec       	mov	r12,30
80003670:	80 00       	ld.sh	r0,r0[0x0]
80003672:	35 bc       	mov	r12,91

80003674 <prvTaskIsTaskSuspended>:

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80003674:	78 59       	ld.w	r9,r12[0x14]
80003676:	48 68       	lddpc	r8,8000368c <prvTaskIsTaskSuspended+0x18>
80003678:	10 39       	cp.w	r9,r8
8000367a:	c0 81       	brne	8000368a <prvTaskIsTaskSuspended+0x16>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
8000367c:	78 a8       	ld.w	r8,r12[0x28]
8000367e:	48 59       	lddpc	r9,80003690 <prvTaskIsTaskSuspended+0x1c>
80003680:	12 38       	cp.w	r8,r9
80003682:	c0 40       	breq	8000368a <prvTaskIsTaskSuspended+0x16>
80003684:	58 08       	cp.w	r8,0
80003686:	5f 0c       	sreq	r12
80003688:	5e fc       	retal	r12
8000368a:	5e fd       	retal	0
8000368c:	00 00       	add	r0,r0
8000368e:	06 64       	and	r4,r3
80003690:	00 00       	add	r0,r0
80003692:	06 00       	add	r0,r3

80003694 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
80003694:	48 38       	lddpc	r8,800036a0 <vTaskSuspendAll+0xc>
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	2f f9       	sub	r9,-1
8000369a:	91 09       	st.w	r8[0x0],r9

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
8000369c:	5e fc       	retal	r12
8000369e:	00 00       	add	r0,r0
800036a0:	00 00       	add	r0,r0
800036a2:	06 2c       	rsub	r12,r3

800036a4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
800036a4:	49 88       	lddpc	r8,80003704 <vTaskSwitchContext+0x60>
800036a6:	70 08       	ld.w	r8,r8[0x0]
800036a8:	58 08       	cp.w	r8,0
800036aa:	c0 50       	breq	800036b4 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
800036ac:	30 19       	mov	r9,1
800036ae:	49 78       	lddpc	r8,80003708 <vTaskSwitchContext+0x64>
800036b0:	91 09       	st.w	r8[0x0],r9
800036b2:	5e fc       	retal	r12
    }
    else
    {
        xYieldPending = pdFALSE;
800036b4:	30 09       	mov	r9,0
800036b6:	49 58       	lddpc	r8,80003708 <vTaskSwitchContext+0x64>
800036b8:	91 09       	st.w	r8[0x0],r9
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800036ba:	49 58       	lddpc	r8,8000370c <vTaskSwitchContext+0x68>
800036bc:	70 09       	ld.w	r9,r8[0x0]
800036be:	f2 09 00 28 	add	r8,r9,r9<<0x2
800036c2:	a3 68       	lsl	r8,0x2
800036c4:	49 3b       	lddpc	r11,80003710 <vTaskSwitchContext+0x6c>
800036c6:	10 0b       	add	r11,r8
800036c8:	76 0a       	ld.w	r10,r11[0x0]
800036ca:	58 0a       	cp.w	r10,0
800036cc:	c0 b1       	brne	800036e2 <vTaskSwitchContext+0x3e>
800036ce:	21 48       	sub	r8,20
800036d0:	49 0a       	lddpc	r10,80003710 <vTaskSwitchContext+0x6c>
800036d2:	f4 08 00 08 	add	r8,r10,r8
800036d6:	20 19       	sub	r9,1
800036d8:	10 9b       	mov	r11,r8
800036da:	70 0a       	ld.w	r10,r8[0x0]
800036dc:	21 48       	sub	r8,20
800036de:	58 0a       	cp.w	r10,0
800036e0:	cf b0       	breq	800036d6 <vTaskSwitchContext+0x32>
800036e2:	76 18       	ld.w	r8,r11[0x4]
800036e4:	70 18       	ld.w	r8,r8[0x4]
800036e6:	97 18       	st.w	r11[0x4],r8
800036e8:	f6 ca ff f8 	sub	r10,r11,-8
800036ec:	14 38       	cp.w	r8,r10
800036ee:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
800036f2:	f7 f8 0a 01 	st.weq	r11[0x4],r8
800036f6:	76 18       	ld.w	r8,r11[0x4]
800036f8:	70 3a       	ld.w	r10,r8[0xc]
800036fa:	48 78       	lddpc	r8,80003714 <vTaskSwitchContext+0x70>
800036fc:	91 0a       	st.w	r8[0x0],r10
800036fe:	48 48       	lddpc	r8,8000370c <vTaskSwitchContext+0x68>
80003700:	91 09       	st.w	r8[0x0],r9
80003702:	5e fc       	retal	r12
80003704:	00 00       	add	r0,r0
80003706:	06 2c       	rsub	r12,r3
80003708:	00 00       	add	r0,r0
8000370a:	06 7c       	tst	r12,r3
8000370c:	00 00       	add	r0,r0
8000370e:	06 78       	tst	r8,r3
80003710:	00 00       	add	r0,r0
80003712:	05 58       	ld.sh	r8,--r2
80003714:	00 00       	add	r0,r0
80003716:	05 fc       	ld.ub	r12,r2[0x7]

80003718 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
80003718:	48 48       	lddpc	r8,80003728 <vTaskInternalSetTimeOutState+0x10>
8000371a:	70 08       	ld.w	r8,r8[0x0]
8000371c:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
8000371e:	48 48       	lddpc	r8,8000372c <vTaskInternalSetTimeOutState+0x14>
80003720:	70 08       	ld.w	r8,r8[0x0]
80003722:	99 18       	st.w	r12[0x4],r8
}
80003724:	5e fc       	retal	r12
80003726:	00 00       	add	r0,r0
80003728:	00 00       	add	r0,r0
8000372a:	05 4c       	ld.w	r12,--r2
8000372c:	00 00       	add	r0,r0
8000372e:	06 28       	rsub	r8,r3

80003730 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
80003730:	30 19       	mov	r9,1
80003732:	48 28       	lddpc	r8,80003738 <vTaskMissedYield+0x8>
80003734:	91 09       	st.w	r8[0x0],r9
}
80003736:	5e fc       	retal	r12
80003738:	00 00       	add	r0,r0
8000373a:	06 7c       	tst	r12,r3

8000373c <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000373c:	48 88       	lddpc	r8,8000375c <prvResetNextTaskUnblockTime+0x20>
8000373e:	70 08       	ld.w	r8,r8[0x0]
80003740:	70 08       	ld.w	r8,r8[0x0]
80003742:	58 08       	cp.w	r8,0
80003744:	c0 51       	brne	8000374e <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
80003746:	3f f9       	mov	r9,-1
80003748:	48 68       	lddpc	r8,80003760 <prvResetNextTaskUnblockTime+0x24>
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	5e fc       	retal	r12
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
8000374e:	48 48       	lddpc	r8,8000375c <prvResetNextTaskUnblockTime+0x20>
80003750:	70 08       	ld.w	r8,r8[0x0]
80003752:	70 38       	ld.w	r8,r8[0xc]
80003754:	70 09       	ld.w	r9,r8[0x0]
80003756:	48 38       	lddpc	r8,80003760 <prvResetNextTaskUnblockTime+0x24>
80003758:	91 09       	st.w	r8[0x0],r9
8000375a:	5e fc       	retal	r12
8000375c:	00 00       	add	r0,r0
8000375e:	05 44       	ld.w	r4,--r2
80003760:	00 00       	add	r0,r0
80003762:	05 40       	ld.w	r0,--r2

80003764 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
80003764:	eb cd 40 c0 	pushm	r6-r7,lr
80003768:	18 97       	mov	r7,r12
8000376a:	16 96       	mov	r6,r11
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
8000376c:	f0 1f 00 14 	mcall	800037bc <xTaskCheckForTimeOut+0x58>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
80003770:	49 48       	lddpc	r8,800037c0 <xTaskCheckForTimeOut+0x5c>
80003772:	70 0a       	ld.w	r10,r8[0x0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
80003774:	6e 19       	ld.w	r9,r7[0x4]
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
80003776:	6c 08       	ld.w	r8,r6[0x0]
80003778:	5b f8       	cp.w	r8,-1
8000377a:	c0 31       	brne	80003780 <xTaskCheckForTimeOut+0x1c>
8000377c:	30 07       	mov	r7,0
8000377e:	c1 a8       	rjmp	800037b2 <xTaskCheckForTimeOut+0x4e>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80003780:	49 1b       	lddpc	r11,800037c4 <xTaskCheckForTimeOut+0x60>
80003782:	76 0b       	ld.w	r11,r11[0x0]
80003784:	6e 0c       	ld.w	r12,r7[0x0]
80003786:	16 3c       	cp.w	r12,r11
80003788:	c0 70       	breq	80003796 <xTaskCheckForTimeOut+0x32>
8000378a:	12 3a       	cp.w	r10,r9
8000378c:	c0 53       	brcs	80003796 <xTaskCheckForTimeOut+0x32>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
8000378e:	30 08       	mov	r8,0
80003790:	8d 08       	st.w	r6[0x0],r8
80003792:	30 17       	mov	r7,1
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80003794:	c0 f8       	rjmp	800037b2 <xTaskCheckForTimeOut+0x4e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
80003796:	f4 09 01 09 	sub	r9,r10,r9
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
8000379a:	10 39       	cp.w	r9,r8
8000379c:	c0 82       	brcc	800037ac <xTaskCheckForTimeOut+0x48>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
8000379e:	12 18       	sub	r8,r9
800037a0:	8d 08       	st.w	r6[0x0],r8
            vTaskInternalSetTimeOutState( pxTimeOut );
800037a2:	0e 9c       	mov	r12,r7
800037a4:	f0 1f 00 09 	mcall	800037c8 <xTaskCheckForTimeOut+0x64>
800037a8:	30 07       	mov	r7,0
800037aa:	c0 48       	rjmp	800037b2 <xTaskCheckForTimeOut+0x4e>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
800037ac:	30 08       	mov	r8,0
800037ae:	8d 08       	st.w	r6[0x0],r8
800037b0:	30 17       	mov	r7,1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
800037b2:	f0 1f 00 07 	mcall	800037cc <xTaskCheckForTimeOut+0x68>

    return xReturn;
}
800037b6:	0e 9c       	mov	r12,r7
800037b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800037bc:	80 00       	ld.sh	r0,r0[0x0]
800037be:	2f fc       	sub	r12,-1
800037c0:	00 00       	add	r0,r0
800037c2:	06 28       	rsub	r8,r3
800037c4:	00 00       	add	r0,r0
800037c6:	05 4c       	ld.w	r12,--r2
800037c8:	80 00       	ld.sh	r0,r0[0x0]
800037ca:	37 18       	mov	r8,113
800037cc:	80 00       	ld.sh	r0,r0[0x0]
800037ce:	31 08       	mov	r8,16

800037d0 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
800037d0:	eb cd 40 f8 	pushm	r3-r7,lr
800037d4:	18 97       	mov	r7,r12
800037d6:	16 95       	mov	r5,r11
800037d8:	14 93       	mov	r3,r10
800037da:	12 96       	mov	r6,r9
800037dc:	10 94       	mov	r4,r8

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
800037de:	f0 1f 00 31 	mcall	800038a0 <xTaskGenericNotify+0xd0>
        {
            if( pulPreviousNotificationValue != NULL )
800037e2:	58 04       	cp.w	r4,0
800037e4:	c0 60       	breq	800037f0 <xTaskGenericNotify+0x20>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
800037e6:	ea c8 ff ed 	sub	r8,r5,-19
800037ea:	ee 08 03 28 	ld.w	r8,r7[r8<<0x2]
800037ee:	89 08       	st.w	r4[0x0],r8
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
800037f0:	ee 05 00 08 	add	r8,r7,r5
800037f4:	f1 39 00 50 	ld.ub	r9,r8[80]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
800037f8:	30 2a       	mov	r10,2
800037fa:	f1 6a 00 50 	st.b	r8[80],r10

            switch( eAction )
800037fe:	58 26       	cp.w	r6,2
80003800:	c1 20       	breq	80003824 <xTaskGenericNotify+0x54>
80003802:	e0 8b 00 05 	brhi	8000380c <xTaskGenericNotify+0x3c>
80003806:	58 16       	cp.w	r6,1
80003808:	c2 21       	brne	8000384c <xTaskGenericNotify+0x7c>
8000380a:	c0 68       	rjmp	80003816 <xTaskGenericNotify+0x46>
8000380c:	58 36       	cp.w	r6,3
8000380e:	c1 20       	breq	80003832 <xTaskGenericNotify+0x62>
80003810:	58 46       	cp.w	r6,4
80003812:	c1 d1       	brne	8000384c <xTaskGenericNotify+0x7c>
80003814:	c1 38       	rjmp	8000383a <xTaskGenericNotify+0x6a>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
80003816:	2e d5       	sub	r5,-19
80003818:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
8000381c:	10 43       	or	r3,r8
8000381e:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
80003822:	c1 58       	rjmp	8000384c <xTaskGenericNotify+0x7c>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
80003824:	2e d5       	sub	r5,-19
80003826:	ee 05 03 28 	ld.w	r8,r7[r5<<0x2]
8000382a:	2f f8       	sub	r8,-1
8000382c:	ee 05 09 28 	st.w	r7[r5<<0x2],r8
                    break;
80003830:	c0 e8       	rjmp	8000384c <xTaskGenericNotify+0x7c>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
80003832:	2e d5       	sub	r5,-19
80003834:	ee 05 09 23 	st.w	r7[r5<<0x2],r3
                    break;
80003838:	c0 a8       	rjmp	8000384c <xTaskGenericNotify+0x7c>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
8000383a:	30 28       	mov	r8,2
8000383c:	f0 09 18 00 	cp.b	r9,r8
80003840:	c0 31       	brne	80003846 <xTaskGenericNotify+0x76>
80003842:	30 07       	mov	r7,0
80003844:	c2 88       	rjmp	80003894 <xTaskGenericNotify+0xc4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
80003846:	2e d5       	sub	r5,-19
80003848:	ee 05 09 23 	st.w	r7[r5<<0x2],r3

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
8000384c:	30 18       	mov	r8,1
8000384e:	f0 09 18 00 	cp.b	r9,r8
80003852:	c2 01       	brne	80003892 <xTaskGenericNotify+0xc2>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003854:	ee c6 ff fc 	sub	r6,r7,-4
80003858:	0c 9c       	mov	r12,r6
8000385a:	f0 1f 00 13 	mcall	800038a4 <xTaskGenericNotify+0xd4>
                prvAddTaskToReadyList( pxTCB );
8000385e:	6e bc       	ld.w	r12,r7[0x2c]
80003860:	49 28       	lddpc	r8,800038a8 <xTaskGenericNotify+0xd8>
80003862:	70 08       	ld.w	r8,r8[0x0]
80003864:	10 3c       	cp.w	r12,r8
80003866:	e0 88 00 04 	brls	8000386e <xTaskGenericNotify+0x9e>
8000386a:	49 08       	lddpc	r8,800038a8 <xTaskGenericNotify+0xd8>
8000386c:	91 0c       	st.w	r8[0x0],r12
8000386e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003872:	0c 9b       	mov	r11,r6
80003874:	48 e8       	lddpc	r8,800038ac <xTaskGenericNotify+0xdc>
80003876:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000387a:	f0 1f 00 0e 	mcall	800038b0 <xTaskGenericNotify+0xe0>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
8000387e:	48 e8       	lddpc	r8,800038b4 <xTaskGenericNotify+0xe4>
80003880:	70 08       	ld.w	r8,r8[0x0]
80003882:	6e b9       	ld.w	r9,r7[0x2c]
80003884:	70 b8       	ld.w	r8,r8[0x2c]
80003886:	10 39       	cp.w	r9,r8
80003888:	e0 88 00 05 	brls	80003892 <xTaskGenericNotify+0xc2>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
8000388c:	d7 33       	scall
8000388e:	30 17       	mov	r7,1
80003890:	c0 28       	rjmp	80003894 <xTaskGenericNotify+0xc4>
80003892:	30 17       	mov	r7,1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80003894:	f0 1f 00 09 	mcall	800038b8 <xTaskGenericNotify+0xe8>

        return xReturn;
    }
80003898:	0e 9c       	mov	r12,r7
8000389a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000389e:	00 00       	add	r0,r0
800038a0:	80 00       	ld.sh	r0,r0[0x0]
800038a2:	2f fc       	sub	r12,-1
800038a4:	80 00       	ld.sh	r0,r0[0x0]
800038a6:	2f 42       	sub	r2,-12
800038a8:	00 00       	add	r0,r0
800038aa:	06 78       	tst	r8,r3
800038ac:	00 00       	add	r0,r0
800038ae:	05 58       	ld.sh	r8,--r2
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	2e fa       	sub	r10,-17
800038b4:	00 00       	add	r0,r0
800038b6:	05 fc       	ld.ub	r12,r2[0x7]
800038b8:	80 00       	ld.sh	r0,r0[0x0]
800038ba:	31 08       	mov	r8,16

800038bc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
800038bc:	eb cd 40 c0 	pushm	r6-r7,lr
800038c0:	18 97       	mov	r7,r12
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
800038c2:	58 0c       	cp.w	r12,0
800038c4:	c2 60       	breq	80003910 <xTaskPriorityDisinherit+0x54>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
800038c6:	79 28       	ld.w	r8,r12[0x48]
800038c8:	20 18       	sub	r8,1
800038ca:	f9 48 00 48 	st.w	r12[72],r8

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800038ce:	78 ba       	ld.w	r10,r12[0x2c]
800038d0:	79 19       	ld.w	r9,r12[0x44]
800038d2:	12 3a       	cp.w	r10,r9
800038d4:	c1 e0       	breq	80003910 <xTaskPriorityDisinherit+0x54>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
800038d6:	58 08       	cp.w	r8,0
800038d8:	c1 c1       	brne	80003910 <xTaskPriorityDisinherit+0x54>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
800038da:	f8 c6 ff fc 	sub	r6,r12,-4
800038de:	0c 9c       	mov	r12,r6
800038e0:	f0 1f 00 0d 	mcall	80003914 <xTaskPriorityDisinherit+0x58>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
800038e4:	6f 1c       	ld.w	r12,r7[0x44]
800038e6:	8f bc       	st.w	r7[0x2c],r12

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800038e8:	f8 08 11 08 	rsub	r8,r12,8
800038ec:	8f 68       	st.w	r7[0x18],r8
                    prvAddTaskToReadyList( pxTCB );
800038ee:	48 b8       	lddpc	r8,80003918 <xTaskPriorityDisinherit+0x5c>
800038f0:	70 08       	ld.w	r8,r8[0x0]
800038f2:	10 3c       	cp.w	r12,r8
800038f4:	e0 88 00 04 	brls	800038fc <xTaskPriorityDisinherit+0x40>
800038f8:	48 88       	lddpc	r8,80003918 <xTaskPriorityDisinherit+0x5c>
800038fa:	91 0c       	st.w	r8[0x0],r12
800038fc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003900:	0c 9b       	mov	r11,r6
80003902:	48 78       	lddpc	r8,8000391c <xTaskPriorityDisinherit+0x60>
80003904:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003908:	f0 1f 00 06 	mcall	80003920 <xTaskPriorityDisinherit+0x64>
8000390c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003910:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	2f 42       	sub	r2,-12
80003918:	00 00       	add	r0,r0
8000391a:	06 78       	tst	r8,r3
8000391c:	00 00       	add	r0,r0
8000391e:	05 58       	ld.sh	r8,--r2
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	2e fa       	sub	r10,-17

80003924 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
80003924:	eb cd 40 c0 	pushm	r6-r7,lr
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003928:	78 38       	ld.w	r8,r12[0xc]
8000392a:	70 37       	ld.w	r7,r8[0xc]
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000392c:	ee c6 ff e8 	sub	r6,r7,-24
80003930:	0c 9c       	mov	r12,r6
80003932:	f0 1f 00 18 	mcall	80003990 <xTaskRemoveFromEventList+0x6c>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003936:	49 88       	lddpc	r8,80003994 <xTaskRemoveFromEventList+0x70>
80003938:	70 08       	ld.w	r8,r8[0x0]
8000393a:	58 08       	cp.w	r8,0
8000393c:	c1 71       	brne	8000396a <xTaskRemoveFromEventList+0x46>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
8000393e:	ee c6 ff fc 	sub	r6,r7,-4
80003942:	0c 9c       	mov	r12,r6
80003944:	f0 1f 00 13 	mcall	80003990 <xTaskRemoveFromEventList+0x6c>
        prvAddTaskToReadyList( pxUnblockedTCB );
80003948:	6e bc       	ld.w	r12,r7[0x2c]
8000394a:	49 48       	lddpc	r8,80003998 <xTaskRemoveFromEventList+0x74>
8000394c:	70 08       	ld.w	r8,r8[0x0]
8000394e:	10 3c       	cp.w	r12,r8
80003950:	e0 88 00 04 	brls	80003958 <xTaskRemoveFromEventList+0x34>
80003954:	49 18       	lddpc	r8,80003998 <xTaskRemoveFromEventList+0x74>
80003956:	91 0c       	st.w	r8[0x0],r12
80003958:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000395c:	0c 9b       	mov	r11,r6
8000395e:	49 08       	lddpc	r8,8000399c <xTaskRemoveFromEventList+0x78>
80003960:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003964:	f0 1f 00 0f 	mcall	800039a0 <xTaskRemoveFromEventList+0x7c>
80003968:	c0 58       	rjmp	80003972 <xTaskRemoveFromEventList+0x4e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000396a:	0c 9b       	mov	r11,r6
8000396c:	48 ec       	lddpc	r12,800039a4 <xTaskRemoveFromEventList+0x80>
8000396e:	f0 1f 00 0d 	mcall	800039a0 <xTaskRemoveFromEventList+0x7c>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80003972:	48 e8       	lddpc	r8,800039a8 <xTaskRemoveFromEventList+0x84>
80003974:	70 08       	ld.w	r8,r8[0x0]
80003976:	6e b9       	ld.w	r9,r7[0x2c]
80003978:	70 b8       	ld.w	r8,r8[0x2c]
8000397a:	10 39       	cp.w	r9,r8
8000397c:	e0 8b 00 04 	brhi	80003984 <xTaskRemoveFromEventList+0x60>
80003980:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
80003984:	30 1c       	mov	r12,1
80003986:	48 a8       	lddpc	r8,800039ac <xTaskRemoveFromEventList+0x88>
80003988:	91 0c       	st.w	r8[0x0],r12
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
8000398a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000398e:	00 00       	add	r0,r0
80003990:	80 00       	ld.sh	r0,r0[0x0]
80003992:	2f 42       	sub	r2,-12
80003994:	00 00       	add	r0,r0
80003996:	06 2c       	rsub	r12,r3
80003998:	00 00       	add	r0,r0
8000399a:	06 78       	tst	r8,r3
8000399c:	00 00       	add	r0,r0
8000399e:	05 58       	ld.sh	r8,--r2
800039a0:	80 00       	ld.sh	r0,r0[0x0]
800039a2:	2e fa       	sub	r10,-17
800039a4:	00 00       	add	r0,r0
800039a6:	06 00       	add	r0,r3
800039a8:	00 00       	add	r0,r0
800039aa:	05 fc       	ld.ub	r12,r2[0x7]
800039ac:	00 00       	add	r0,r0
800039ae:	06 7c       	tst	r12,r3

800039b0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
800039b0:	d4 31       	pushm	r0-r7,lr
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
800039b2:	4b 48       	lddpc	r8,80003a80 <xTaskIncrementTick+0xd0>
800039b4:	70 08       	ld.w	r8,r8[0x0]
800039b6:	58 08       	cp.w	r8,0
800039b8:	c5 d1       	brne	80003a72 <xTaskIncrementTick+0xc2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
800039ba:	4b 38       	lddpc	r8,80003a84 <xTaskIncrementTick+0xd4>
800039bc:	70 02       	ld.w	r2,r8[0x0]
800039be:	2f f2       	sub	r2,-1

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
800039c0:	91 02       	st.w	r8[0x0],r2

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
800039c2:	c0 d1       	brne	800039dc <xTaskIncrementTick+0x2c>
        {
            taskSWITCH_DELAYED_LISTS();
800039c4:	4b 19       	lddpc	r9,80003a88 <xTaskIncrementTick+0xd8>
800039c6:	72 0a       	ld.w	r10,r9[0x0]
800039c8:	4b 18       	lddpc	r8,80003a8c <xTaskIncrementTick+0xdc>
800039ca:	70 0b       	ld.w	r11,r8[0x0]
800039cc:	93 0b       	st.w	r9[0x0],r11
800039ce:	91 0a       	st.w	r8[0x0],r10
800039d0:	4b 08       	lddpc	r8,80003a90 <xTaskIncrementTick+0xe0>
800039d2:	70 09       	ld.w	r9,r8[0x0]
800039d4:	2f f9       	sub	r9,-1
800039d6:	91 09       	st.w	r8[0x0],r9
800039d8:	f0 1f 00 2f 	mcall	80003a94 <xTaskIncrementTick+0xe4>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
800039dc:	4a f8       	lddpc	r8,80003a98 <xTaskIncrementTick+0xe8>
800039de:	70 08       	ld.w	r8,r8[0x0]
800039e0:	10 32       	cp.w	r2,r8
800039e2:	c3 63       	brcs	80003a4e <xTaskIncrementTick+0x9e>
800039e4:	30 06       	mov	r6,0
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800039e6:	4a 94       	lddpc	r4,80003a88 <xTaskIncrementTick+0xd8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
800039e8:	4a d3       	lddpc	r3,80003a9c <xTaskIncrementTick+0xec>
800039ea:	4a e1       	lddpc	r1,80003aa0 <xTaskIncrementTick+0xf0>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800039ec:	4a e0       	lddpc	r0,80003aa4 <xTaskIncrementTick+0xf4>
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800039ee:	68 08       	ld.w	r8,r4[0x0]
800039f0:	70 08       	ld.w	r8,r8[0x0]
800039f2:	58 08       	cp.w	r8,0
800039f4:	c0 51       	brne	800039fe <xTaskIncrementTick+0x4e>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800039f6:	3f f9       	mov	r9,-1
800039f8:	4a 88       	lddpc	r8,80003a98 <xTaskIncrementTick+0xe8>
800039fa:	91 09       	st.w	r8[0x0],r9
                    break;
800039fc:	c2 a8       	rjmp	80003a50 <xTaskIncrementTick+0xa0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
800039fe:	68 08       	ld.w	r8,r4[0x0]
80003a00:	70 38       	ld.w	r8,r8[0xc]
80003a02:	70 37       	ld.w	r7,r8[0xc]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80003a04:	6e 18       	ld.w	r8,r7[0x4]

                    if( xConstTickCount < xItemValue )
80003a06:	10 32       	cp.w	r2,r8
80003a08:	c0 42       	brcc	80003a10 <xTaskIncrementTick+0x60>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
80003a0a:	4a 49       	lddpc	r9,80003a98 <xTaskIncrementTick+0xe8>
80003a0c:	93 08       	st.w	r9[0x0],r8
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
80003a0e:	c2 18       	rjmp	80003a50 <xTaskIncrementTick+0xa0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003a10:	ee c5 ff fc 	sub	r5,r7,-4
80003a14:	0a 9c       	mov	r12,r5
80003a16:	f0 1f 00 25 	mcall	80003aa8 <xTaskIncrementTick+0xf8>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80003a1a:	6e a8       	ld.w	r8,r7[0x28]
80003a1c:	58 08       	cp.w	r8,0
80003a1e:	c0 50       	breq	80003a28 <xTaskIncrementTick+0x78>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80003a20:	ee cc ff e8 	sub	r12,r7,-24
80003a24:	f0 1f 00 21 	mcall	80003aa8 <xTaskIncrementTick+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
80003a28:	6e bc       	ld.w	r12,r7[0x2c]
80003a2a:	66 08       	ld.w	r8,r3[0x0]
80003a2c:	10 3c       	cp.w	r12,r8
80003a2e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80003a32:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003a36:	0a 9b       	mov	r11,r5
80003a38:	e2 0c 00 2c 	add	r12,r1,r12<<0x2
80003a3c:	f0 1f 00 1c 	mcall	80003aac <xTaskIncrementTick+0xfc>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003a40:	60 08       	ld.w	r8,r0[0x0]
80003a42:	6e b9       	ld.w	r9,r7[0x2c]
80003a44:	70 b8       	ld.w	r8,r8[0x2c]
80003a46:	10 39       	cp.w	r9,r8
80003a48:	f9 b6 02 01 	movhs	r6,1
80003a4c:	cd 1b       	rjmp	800039ee <xTaskIncrementTick+0x3e>
80003a4e:	30 06       	mov	r6,0
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
80003a50:	49 58       	lddpc	r8,80003aa4 <xTaskIncrementTick+0xf4>
80003a52:	70 08       	ld.w	r8,r8[0x0]
80003a54:	70 b8       	ld.w	r8,r8[0x2c]
80003a56:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003a5a:	49 29       	lddpc	r9,80003aa0 <xTaskIncrementTick+0xf0>
80003a5c:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80003a60:	58 28       	cp.w	r8,2
80003a62:	f9 b6 02 01 	movhs	r6,1
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
80003a66:	49 38       	lddpc	r8,80003ab0 <xTaskIncrementTick+0x100>
80003a68:	70 08       	ld.w	r8,r8[0x0]
80003a6a:	58 08       	cp.w	r8,0
80003a6c:	f9 b6 01 01 	movne	r6,1
80003a70:	c0 68       	rjmp	80003a7c <xTaskIncrementTick+0xcc>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
80003a72:	49 18       	lddpc	r8,80003ab4 <xTaskIncrementTick+0x104>
80003a74:	70 09       	ld.w	r9,r8[0x0]
80003a76:	2f f9       	sub	r9,-1
80003a78:	91 09       	st.w	r8[0x0],r9
80003a7a:	30 06       	mov	r6,0
            }
        #endif
    }

    return xSwitchRequired;
}
80003a7c:	0c 9c       	mov	r12,r6
80003a7e:	d8 32       	popm	r0-r7,pc
80003a80:	00 00       	add	r0,r0
80003a82:	06 2c       	rsub	r12,r3
80003a84:	00 00       	add	r0,r0
80003a86:	06 28       	rsub	r8,r3
80003a88:	00 00       	add	r0,r0
80003a8a:	05 44       	ld.w	r4,--r2
80003a8c:	00 00       	add	r0,r0
80003a8e:	05 50       	ld.sh	r0,--r2
80003a90:	00 00       	add	r0,r0
80003a92:	05 4c       	ld.w	r12,--r2
80003a94:	80 00       	ld.sh	r0,r0[0x0]
80003a96:	37 3c       	mov	r12,115
80003a98:	00 00       	add	r0,r0
80003a9a:	05 40       	ld.w	r0,--r2
80003a9c:	00 00       	add	r0,r0
80003a9e:	06 78       	tst	r8,r3
80003aa0:	00 00       	add	r0,r0
80003aa2:	05 58       	ld.sh	r8,--r2
80003aa4:	00 00       	add	r0,r0
80003aa6:	05 fc       	ld.ub	r12,r2[0x7]
80003aa8:	80 00       	ld.sh	r0,r0[0x0]
80003aaa:	2f 42       	sub	r2,-12
80003aac:	80 00       	ld.sh	r0,r0[0x0]
80003aae:	2e fa       	sub	r10,-17
80003ab0:	00 00       	add	r0,r0
80003ab2:	06 7c       	tst	r12,r3
80003ab4:	00 00       	add	r0,r0
80003ab6:	05 54       	ld.sh	r4,--r2

80003ab8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
80003ab8:	d4 31       	pushm	r0-r7,lr
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
80003aba:	f0 1f 00 2b 	mcall	80003b64 <xTaskResumeAll+0xac>
    {
        --uxSchedulerSuspended;
80003abe:	4a b8       	lddpc	r8,80003b68 <xTaskResumeAll+0xb0>
80003ac0:	70 09       	ld.w	r9,r8[0x0]
80003ac2:	20 19       	sub	r9,1
80003ac4:	91 09       	st.w	r8[0x0],r9

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003ac6:	70 08       	ld.w	r8,r8[0x0]
80003ac8:	58 08       	cp.w	r8,0
80003aca:	c4 71       	brne	80003b58 <xTaskResumeAll+0xa0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80003acc:	4a 88       	lddpc	r8,80003b6c <xTaskResumeAll+0xb4>
80003ace:	70 08       	ld.w	r8,r8[0x0]
80003ad0:	58 08       	cp.w	r8,0
80003ad2:	c4 30       	breq	80003b58 <xTaskResumeAll+0xa0>
80003ad4:	30 07       	mov	r7,0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80003ad6:	4a 76       	lddpc	r6,80003b70 <xTaskResumeAll+0xb8>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
80003ad8:	4a 74       	lddpc	r4,80003b74 <xTaskResumeAll+0xbc>
80003ada:	4a 83       	lddpc	r3,80003b78 <xTaskResumeAll+0xc0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003adc:	4a 82       	lddpc	r2,80003b7c <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
80003ade:	4a 91       	lddpc	r1,80003b80 <xTaskResumeAll+0xc8>
80003ae0:	30 10       	mov	r0,1
80003ae2:	c1 e8       	rjmp	80003b1e <xTaskResumeAll+0x66>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003ae4:	6c 38       	ld.w	r8,r6[0xc]
80003ae6:	70 37       	ld.w	r7,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80003ae8:	ee cc ff e8 	sub	r12,r7,-24
80003aec:	f0 1f 00 26 	mcall	80003b84 <xTaskResumeAll+0xcc>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003af0:	ee c5 ff fc 	sub	r5,r7,-4
80003af4:	0a 9c       	mov	r12,r5
80003af6:	f0 1f 00 24 	mcall	80003b84 <xTaskResumeAll+0xcc>
                    prvAddTaskToReadyList( pxTCB );
80003afa:	6e bc       	ld.w	r12,r7[0x2c]
80003afc:	68 08       	ld.w	r8,r4[0x0]
80003afe:	10 3c       	cp.w	r12,r8
80003b00:	e9 fc ba 00 	st.whi	r4[0x0],r12
80003b04:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003b08:	0a 9b       	mov	r11,r5
80003b0a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80003b0e:	f0 1f 00 1f 	mcall	80003b88 <xTaskResumeAll+0xd0>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003b12:	64 08       	ld.w	r8,r2[0x0]
80003b14:	6e b9       	ld.w	r9,r7[0x2c]
80003b16:	70 b8       	ld.w	r8,r8[0x2c]
                    {
                        xYieldPending = pdTRUE;
80003b18:	10 39       	cp.w	r9,r8
80003b1a:	e3 f0 2a 00 	st.wcc	r1[0x0],r0
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80003b1e:	6c 08       	ld.w	r8,r6[0x0]
80003b20:	58 08       	cp.w	r8,0
80003b22:	ce 11       	brne	80003ae4 <xTaskResumeAll+0x2c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
80003b24:	58 07       	cp.w	r7,0
80003b26:	c0 30       	breq	80003b2c <xTaskResumeAll+0x74>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
80003b28:	f0 1f 00 19 	mcall	80003b8c <xTaskResumeAll+0xd4>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
80003b2c:	49 98       	lddpc	r8,80003b90 <xTaskResumeAll+0xd8>
80003b2e:	70 07       	ld.w	r7,r8[0x0]

                    if( xPendedCounts > ( TickType_t ) 0U )
80003b30:	58 07       	cp.w	r7,0
80003b32:	c0 c0       	breq	80003b4a <xTaskResumeAll+0x92>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
80003b34:	49 36       	lddpc	r6,80003b80 <xTaskResumeAll+0xc8>
80003b36:	30 15       	mov	r5,1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
80003b38:	f0 1f 00 17 	mcall	80003b94 <xTaskResumeAll+0xdc>
                            {
                                xYieldPending = pdTRUE;
80003b3c:	ed f5 1a 00 	st.wne	r6[0x0],r5
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
80003b40:	20 17       	sub	r7,1
                        } while( xPendedCounts > ( TickType_t ) 0U );
80003b42:	cf b1       	brne	80003b38 <xTaskResumeAll+0x80>

                        xPendedTicks = 0;
80003b44:	30 09       	mov	r9,0
80003b46:	49 38       	lddpc	r8,80003b90 <xTaskResumeAll+0xd8>
80003b48:	91 09       	st.w	r8[0x0],r9
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
80003b4a:	48 e8       	lddpc	r8,80003b80 <xTaskResumeAll+0xc8>
80003b4c:	70 08       	ld.w	r8,r8[0x0]
80003b4e:	58 08       	cp.w	r8,0
80003b50:	c0 40       	breq	80003b58 <xTaskResumeAll+0xa0>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
80003b52:	d7 33       	scall
80003b54:	30 17       	mov	r7,1
80003b56:	c0 28       	rjmp	80003b5a <xTaskResumeAll+0xa2>
80003b58:	30 07       	mov	r7,0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
80003b5a:	f0 1f 00 10 	mcall	80003b98 <xTaskResumeAll+0xe0>

    return xAlreadyYielded;
}
80003b5e:	0e 9c       	mov	r12,r7
80003b60:	d8 32       	popm	r0-r7,pc
80003b62:	00 00       	add	r0,r0
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	2f fc       	sub	r12,-1
80003b68:	00 00       	add	r0,r0
80003b6a:	06 2c       	rsub	r12,r3
80003b6c:	00 00       	add	r0,r0
80003b6e:	06 48       	or	r8,r3
80003b70:	00 00       	add	r0,r0
80003b72:	06 00       	add	r0,r3
80003b74:	00 00       	add	r0,r0
80003b76:	06 78       	tst	r8,r3
80003b78:	00 00       	add	r0,r0
80003b7a:	05 58       	ld.sh	r8,--r2
80003b7c:	00 00       	add	r0,r0
80003b7e:	05 fc       	ld.ub	r12,r2[0x7]
80003b80:	00 00       	add	r0,r0
80003b82:	06 7c       	tst	r12,r3
80003b84:	80 00       	ld.sh	r0,r0[0x0]
80003b86:	2f 42       	sub	r2,-12
80003b88:	80 00       	ld.sh	r0,r0[0x0]
80003b8a:	2e fa       	sub	r10,-17
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	37 3c       	mov	r12,115
80003b90:	00 00       	add	r0,r0
80003b92:	05 54       	ld.sh	r4,--r2
80003b94:	80 00       	ld.sh	r0,r0[0x0]
80003b96:	39 b0       	mov	r0,-101
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	31 08       	mov	r8,16

80003b9c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
80003b9c:	d4 21       	pushm	r4-r7,lr
80003b9e:	18 97       	mov	r7,r12
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80003ba0:	f0 1f 00 17 	mcall	80003bfc <xTaskResumeFromISR+0x60>
80003ba4:	c0 31       	brne	80003baa <xTaskResumeFromISR+0xe>
80003ba6:	30 07       	mov	r7,0
80003ba8:	c2 78       	rjmp	80003bf6 <xTaskResumeFromISR+0x5a>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003baa:	49 68       	lddpc	r8,80003c00 <xTaskResumeFromISR+0x64>
80003bac:	70 08       	ld.w	r8,r8[0x0]
80003bae:	58 08       	cp.w	r8,0
80003bb0:	c1 d1       	brne	80003bea <xTaskResumeFromISR+0x4e>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003bb2:	6e b5       	ld.w	r5,r7[0x2c]
80003bb4:	49 48       	lddpc	r8,80003c04 <xTaskResumeFromISR+0x68>
80003bb6:	70 08       	ld.w	r8,r8[0x0]
80003bb8:	70 b4       	ld.w	r4,r8[0x2c]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003bba:	ee c6 ff fc 	sub	r6,r7,-4
80003bbe:	0c 9c       	mov	r12,r6
80003bc0:	f0 1f 00 12 	mcall	80003c08 <xTaskResumeFromISR+0x6c>
                    prvAddTaskToReadyList( pxTCB );
80003bc4:	6e bc       	ld.w	r12,r7[0x2c]
80003bc6:	49 28       	lddpc	r8,80003c0c <xTaskResumeFromISR+0x70>
80003bc8:	70 08       	ld.w	r8,r8[0x0]
80003bca:	10 3c       	cp.w	r12,r8
80003bcc:	e0 88 00 04 	brls	80003bd4 <xTaskResumeFromISR+0x38>
80003bd0:	48 f8       	lddpc	r8,80003c0c <xTaskResumeFromISR+0x70>
80003bd2:	91 0c       	st.w	r8[0x0],r12
80003bd4:	08 35       	cp.w	r5,r4
80003bd6:	5f 27       	srhs	r7
80003bd8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003bdc:	0c 9b       	mov	r11,r6
80003bde:	48 d8       	lddpc	r8,80003c10 <xTaskResumeFromISR+0x74>
80003be0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003be4:	f0 1f 00 0c 	mcall	80003c14 <xTaskResumeFromISR+0x78>
80003be8:	c0 78       	rjmp	80003bf6 <xTaskResumeFromISR+0x5a>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80003bea:	ee cb ff e8 	sub	r11,r7,-24
80003bee:	48 bc       	lddpc	r12,80003c18 <xTaskResumeFromISR+0x7c>
80003bf0:	f0 1f 00 09 	mcall	80003c14 <xTaskResumeFromISR+0x78>
80003bf4:	30 07       	mov	r7,0
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
80003bf6:	0e 9c       	mov	r12,r7
80003bf8:	d8 22       	popm	r4-r7,pc
80003bfa:	00 00       	add	r0,r0
80003bfc:	80 00       	ld.sh	r0,r0[0x0]
80003bfe:	36 74       	mov	r4,103
80003c00:	00 00       	add	r0,r0
80003c02:	06 2c       	rsub	r12,r3
80003c04:	00 00       	add	r0,r0
80003c06:	05 fc       	ld.ub	r12,r2[0x7]
80003c08:	80 00       	ld.sh	r0,r0[0x0]
80003c0a:	2f 42       	sub	r2,-12
80003c0c:	00 00       	add	r0,r0
80003c0e:	06 78       	tst	r8,r3
80003c10:	00 00       	add	r0,r0
80003c12:	05 58       	ld.sh	r8,--r2
80003c14:	80 00       	ld.sh	r0,r0[0x0]
80003c16:	2e fa       	sub	r10,-17
80003c18:	00 00       	add	r0,r0
80003c1a:	06 00       	add	r0,r3

80003c1c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
80003c1c:	eb cd 40 c0 	pushm	r6-r7,lr
80003c20:	18 97       	mov	r7,r12
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
80003c22:	f0 1f 00 23 	mcall	80003cac <vTaskSuspend+0x90>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
80003c26:	58 07       	cp.w	r7,0
80003c28:	c0 31       	brne	80003c2e <vTaskSuspend+0x12>
80003c2a:	4a 28       	lddpc	r8,80003cb0 <vTaskSuspend+0x94>
80003c2c:	70 07       	ld.w	r7,r8[0x0]

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80003c2e:	ee c6 ff fc 	sub	r6,r7,-4
80003c32:	0c 9c       	mov	r12,r6
80003c34:	f0 1f 00 20 	mcall	80003cb4 <vTaskSuspend+0x98>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80003c38:	6e a8       	ld.w	r8,r7[0x28]
80003c3a:	58 08       	cp.w	r8,0
80003c3c:	c0 50       	breq	80003c46 <vTaskSuspend+0x2a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80003c3e:	ee cc ff e8 	sub	r12,r7,-24
80003c42:	f0 1f 00 1d 	mcall	80003cb4 <vTaskSuspend+0x98>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
80003c46:	0c 9b       	mov	r11,r6
80003c48:	49 cc       	lddpc	r12,80003cb8 <vTaskSuspend+0x9c>
80003c4a:	f0 1f 00 1d 	mcall	80003cbc <vTaskSuspend+0xa0>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
80003c4e:	ef 39 00 50 	ld.ub	r9,r7[80]
80003c52:	30 18       	mov	r8,1
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
80003c54:	f0 09 18 00 	cp.b	r9,r8
80003c58:	f9 b8 00 00 	moveq	r8,0
80003c5c:	ef f8 0e 50 	st.beq	r7[0x50],r8
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
80003c60:	f0 1f 00 18 	mcall	80003cc0 <vTaskSuspend+0xa4>

        if( xSchedulerRunning != pdFALSE )
80003c64:	49 88       	lddpc	r8,80003cc4 <vTaskSuspend+0xa8>
80003c66:	70 08       	ld.w	r8,r8[0x0]
80003c68:	58 08       	cp.w	r8,0
80003c6a:	c0 70       	breq	80003c78 <vTaskSuspend+0x5c>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
80003c6c:	f0 1f 00 10 	mcall	80003cac <vTaskSuspend+0x90>
            {
                prvResetNextTaskUnblockTime();
80003c70:	f0 1f 00 16 	mcall	80003cc8 <vTaskSuspend+0xac>
            }
            taskEXIT_CRITICAL();
80003c74:	f0 1f 00 13 	mcall	80003cc0 <vTaskSuspend+0xa4>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
80003c78:	48 e8       	lddpc	r8,80003cb0 <vTaskSuspend+0x94>
80003c7a:	70 08       	ld.w	r8,r8[0x0]
80003c7c:	10 37       	cp.w	r7,r8
80003c7e:	c1 51       	brne	80003ca8 <vTaskSuspend+0x8c>
        {
            if( xSchedulerRunning != pdFALSE )
80003c80:	49 18       	lddpc	r8,80003cc4 <vTaskSuspend+0xa8>
80003c82:	70 08       	ld.w	r8,r8[0x0]
80003c84:	58 08       	cp.w	r8,0
80003c86:	c0 40       	breq	80003c8e <vTaskSuspend+0x72>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
80003c88:	d7 33       	scall
80003c8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
80003c8e:	48 b8       	lddpc	r8,80003cb8 <vTaskSuspend+0x9c>
80003c90:	70 09       	ld.w	r9,r8[0x0]
80003c92:	48 f8       	lddpc	r8,80003ccc <vTaskSuspend+0xb0>
80003c94:	70 08       	ld.w	r8,r8[0x0]
80003c96:	10 39       	cp.w	r9,r8
80003c98:	c0 61       	brne	80003ca4 <vTaskSuspend+0x88>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
80003c9a:	30 09       	mov	r9,0
80003c9c:	48 58       	lddpc	r8,80003cb0 <vTaskSuspend+0x94>
80003c9e:	91 09       	st.w	r8[0x0],r9
80003ca0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                }
                else
                {
                    vTaskSwitchContext();
80003ca4:	f0 1f 00 0b 	mcall	80003cd0 <vTaskSuspend+0xb4>
80003ca8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	2f fc       	sub	r12,-1
80003cb0:	00 00       	add	r0,r0
80003cb2:	05 fc       	ld.ub	r12,r2[0x7]
80003cb4:	80 00       	ld.sh	r0,r0[0x0]
80003cb6:	2f 42       	sub	r2,-12
80003cb8:	00 00       	add	r0,r0
80003cba:	06 64       	and	r4,r3
80003cbc:	80 00       	ld.sh	r0,r0[0x0]
80003cbe:	2e fa       	sub	r10,-17
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	31 08       	mov	r8,16
80003cc4:	00 00       	add	r0,r0
80003cc6:	05 48       	ld.w	r8,--r2
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	37 3c       	mov	r12,115
80003ccc:	00 00       	add	r0,r0
80003cce:	06 48       	or	r8,r3
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	36 a4       	mov	r4,106

80003cd4 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
80003cd4:	eb cd 40 e0 	pushm	r5-r7,lr
80003cd8:	18 97       	mov	r7,r12
80003cda:	16 95       	mov	r5,r11
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
80003cdc:	49 b8       	lddpc	r8,80003d48 <prvAddCurrentTaskToDelayedList+0x74>
80003cde:	70 06       	ld.w	r6,r8[0x0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80003ce0:	49 b8       	lddpc	r8,80003d4c <prvAddCurrentTaskToDelayedList+0x78>
80003ce2:	70 0c       	ld.w	r12,r8[0x0]
80003ce4:	2f cc       	sub	r12,-4
80003ce6:	f0 1f 00 1b 	mcall	80003d50 <prvAddCurrentTaskToDelayedList+0x7c>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80003cea:	5b f7       	cp.w	r7,-1
80003cec:	5f 09       	sreq	r9
80003cee:	58 05       	cp.w	r5,0
80003cf0:	5f 18       	srne	r8
80003cf2:	f3 e8 00 08 	and	r8,r9,r8
80003cf6:	c0 90       	breq	80003d08 <prvAddCurrentTaskToDelayedList+0x34>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003cf8:	49 58       	lddpc	r8,80003d4c <prvAddCurrentTaskToDelayedList+0x78>
80003cfa:	70 0b       	ld.w	r11,r8[0x0]
80003cfc:	2f cb       	sub	r11,-4
80003cfe:	49 6c       	lddpc	r12,80003d54 <prvAddCurrentTaskToDelayedList+0x80>
80003d00:	f0 1f 00 16 	mcall	80003d58 <prvAddCurrentTaskToDelayedList+0x84>
80003d04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
80003d08:	0c 07       	add	r7,r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80003d0a:	49 18       	lddpc	r8,80003d4c <prvAddCurrentTaskToDelayedList+0x78>
80003d0c:	70 08       	ld.w	r8,r8[0x0]
80003d0e:	91 17       	st.w	r8[0x4],r7

                if( xTimeToWake < xConstTickCount )
80003d10:	0e 36       	cp.w	r6,r7
80003d12:	e0 88 00 0b 	brls	80003d28 <prvAddCurrentTaskToDelayedList+0x54>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003d16:	48 e8       	lddpc	r8,80003d4c <prvAddCurrentTaskToDelayedList+0x78>
80003d18:	70 0b       	ld.w	r11,r8[0x0]
80003d1a:	49 18       	lddpc	r8,80003d5c <prvAddCurrentTaskToDelayedList+0x88>
80003d1c:	70 0c       	ld.w	r12,r8[0x0]
80003d1e:	2f cb       	sub	r11,-4
80003d20:	f0 1f 00 10 	mcall	80003d60 <prvAddCurrentTaskToDelayedList+0x8c>
80003d24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003d28:	48 98       	lddpc	r8,80003d4c <prvAddCurrentTaskToDelayedList+0x78>
80003d2a:	70 0b       	ld.w	r11,r8[0x0]
80003d2c:	48 e8       	lddpc	r8,80003d64 <prvAddCurrentTaskToDelayedList+0x90>
80003d2e:	70 0c       	ld.w	r12,r8[0x0]
80003d30:	2f cb       	sub	r11,-4
80003d32:	f0 1f 00 0c 	mcall	80003d60 <prvAddCurrentTaskToDelayedList+0x8c>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
80003d36:	48 d8       	lddpc	r8,80003d68 <prvAddCurrentTaskToDelayedList+0x94>
80003d38:	70 08       	ld.w	r8,r8[0x0]
80003d3a:	10 37       	cp.w	r7,r8
80003d3c:	c0 32       	brcc	80003d42 <prvAddCurrentTaskToDelayedList+0x6e>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
80003d3e:	48 b8       	lddpc	r8,80003d68 <prvAddCurrentTaskToDelayedList+0x94>
80003d40:	91 07       	st.w	r8[0x0],r7
80003d42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003d46:	00 00       	add	r0,r0
80003d48:	00 00       	add	r0,r0
80003d4a:	06 28       	rsub	r8,r3
80003d4c:	00 00       	add	r0,r0
80003d4e:	05 fc       	ld.ub	r12,r2[0x7]
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	2f 42       	sub	r2,-12
80003d54:	00 00       	add	r0,r0
80003d56:	06 64       	and	r4,r3
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	2e fa       	sub	r10,-17
80003d5c:	00 00       	add	r0,r0
80003d5e:	05 50       	ld.sh	r0,--r2
80003d60:	80 00       	ld.sh	r0,r0[0x0]
80003d62:	2f 12       	sub	r2,-15
80003d64:	00 00       	add	r0,r0
80003d66:	05 44       	ld.w	r4,--r2
80003d68:	00 00       	add	r0,r0
80003d6a:	05 40       	ld.w	r0,--r2

80003d6c <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
80003d6c:	eb cd 40 e0 	pushm	r5-r7,lr
80003d70:	18 97       	mov	r7,r12
80003d72:	16 95       	mov	r5,r11
80003d74:	14 96       	mov	r6,r10
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
80003d76:	f0 1f 00 20 	mcall	80003df4 <ulTaskGenericNotifyTake+0x88>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
80003d7a:	4a 08       	lddpc	r8,80003df8 <ulTaskGenericNotifyTake+0x8c>
80003d7c:	70 08       	ld.w	r8,r8[0x0]
80003d7e:	ee c9 ff ed 	sub	r9,r7,-19
80003d82:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80003d86:	58 08       	cp.w	r8,0
80003d88:	c0 e1       	brne	80003da4 <ulTaskGenericNotifyTake+0x38>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
80003d8a:	49 c8       	lddpc	r8,80003df8 <ulTaskGenericNotifyTake+0x8c>
80003d8c:	70 08       	ld.w	r8,r8[0x0]
80003d8e:	0e 08       	add	r8,r7
80003d90:	30 19       	mov	r9,1
80003d92:	f1 69 00 50 	st.b	r8[80],r9

                if( xTicksToWait > ( TickType_t ) 0 )
80003d96:	58 06       	cp.w	r6,0
80003d98:	c0 60       	breq	80003da4 <ulTaskGenericNotifyTake+0x38>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80003d9a:	30 1b       	mov	r11,1
80003d9c:	0c 9c       	mov	r12,r6
80003d9e:	f0 1f 00 18 	mcall	80003dfc <ulTaskGenericNotifyTake+0x90>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
80003da2:	d7 33       	scall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
80003da4:	f0 1f 00 17 	mcall	80003e00 <ulTaskGenericNotifyTake+0x94>

        taskENTER_CRITICAL();
80003da8:	f0 1f 00 13 	mcall	80003df4 <ulTaskGenericNotifyTake+0x88>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
80003dac:	49 38       	lddpc	r8,80003df8 <ulTaskGenericNotifyTake+0x8c>
80003dae:	70 08       	ld.w	r8,r8[0x0]
80003db0:	ee c9 ff ed 	sub	r9,r7,-19
80003db4:	f0 09 03 26 	ld.w	r6,r8[r9<<0x2]

            if( ulReturn != 0UL )
80003db8:	58 06       	cp.w	r6,0
80003dba:	c1 10       	breq	80003ddc <ulTaskGenericNotifyTake+0x70>
            {
                if( xClearCountOnExit != pdFALSE )
80003dbc:	58 05       	cp.w	r5,0
80003dbe:	c0 70       	breq	80003dcc <ulTaskGenericNotifyTake+0x60>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
80003dc0:	48 e8       	lddpc	r8,80003df8 <ulTaskGenericNotifyTake+0x8c>
80003dc2:	70 08       	ld.w	r8,r8[0x0]
80003dc4:	30 0a       	mov	r10,0
80003dc6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80003dca:	c0 98       	rjmp	80003ddc <ulTaskGenericNotifyTake+0x70>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
80003dcc:	48 b8       	lddpc	r8,80003df8 <ulTaskGenericNotifyTake+0x8c>
80003dce:	70 08       	ld.w	r8,r8[0x0]
80003dd0:	ec ca 00 01 	sub	r10,r6,1
80003dd4:	ee c9 ff ed 	sub	r9,r7,-19
80003dd8:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
80003ddc:	48 78       	lddpc	r8,80003df8 <ulTaskGenericNotifyTake+0x8c>
80003dde:	70 08       	ld.w	r8,r8[0x0]
80003de0:	f0 07 00 07 	add	r7,r8,r7
80003de4:	30 08       	mov	r8,0
80003de6:	ef 68 00 50 	st.b	r7[80],r8
        }
        taskEXIT_CRITICAL();
80003dea:	f0 1f 00 06 	mcall	80003e00 <ulTaskGenericNotifyTake+0x94>

        return ulReturn;
    }
80003dee:	0c 9c       	mov	r12,r6
80003df0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	2f fc       	sub	r12,-1
80003df8:	00 00       	add	r0,r0
80003dfa:	05 fc       	ld.ub	r12,r2[0x7]
80003dfc:	80 00       	ld.sh	r0,r0[0x0]
80003dfe:	3c d4       	mov	r4,-51
80003e00:	80 00       	ld.sh	r0,r0[0x0]
80003e02:	31 08       	mov	r8,16

80003e04 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
80003e04:	eb cd 40 80 	pushm	r7,lr
80003e08:	16 97       	mov	r7,r11

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80003e0a:	48 68       	lddpc	r8,80003e20 <vTaskPlaceOnEventList+0x1c>
80003e0c:	70 0b       	ld.w	r11,r8[0x0]
80003e0e:	2e 8b       	sub	r11,-24
80003e10:	f0 1f 00 05 	mcall	80003e24 <vTaskPlaceOnEventList+0x20>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80003e14:	30 1b       	mov	r11,1
80003e16:	0e 9c       	mov	r12,r7
80003e18:	f0 1f 00 04 	mcall	80003e28 <vTaskPlaceOnEventList+0x24>
}
80003e1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e20:	00 00       	add	r0,r0
80003e22:	05 fc       	ld.ub	r12,r2[0x7]
80003e24:	80 00       	ld.sh	r0,r0[0x0]
80003e26:	2f 12       	sub	r2,-15
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	3c d4       	mov	r4,-51

80003e2c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
80003e2c:	eb cd 40 80 	pushm	r7,lr
80003e30:	18 97       	mov	r7,r12

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
80003e32:	78 cc       	ld.w	r12,r12[0x30]
80003e34:	f0 1f 00 04 	mcall	80003e44 <prvDeleteTCB+0x18>
                vPortFree( pxTCB );
80003e38:	0e 9c       	mov	r12,r7
80003e3a:	f0 1f 00 03 	mcall	80003e44 <prvDeleteTCB+0x18>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
80003e3e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e42:	00 00       	add	r0,r0
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	31 c4       	mov	r4,28

80003e48 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80003e48:	eb cd 40 f8 	pushm	r3-r7,lr
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80003e4c:	49 17       	lddpc	r7,80003e90 <prvIdleTask+0x48>
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003e4e:	49 25       	lddpc	r5,80003e94 <prvIdleTask+0x4c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
80003e50:	49 24       	lddpc	r4,80003e98 <prvIdleTask+0x50>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80003e52:	49 33       	lddpc	r3,80003e9c <prvIdleTask+0x54>
80003e54:	c1 48       	rjmp	80003e7c <prvIdleTask+0x34>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
80003e56:	f0 1f 00 13 	mcall	80003ea0 <prvIdleTask+0x58>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
80003e5a:	6a 38       	ld.w	r8,r5[0xc]
80003e5c:	70 36       	ld.w	r6,r8[0xc]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003e5e:	ec cc ff fc 	sub	r12,r6,-4
80003e62:	f0 1f 00 11 	mcall	80003ea4 <prvIdleTask+0x5c>
                    --uxCurrentNumberOfTasks;
80003e66:	68 08       	ld.w	r8,r4[0x0]
80003e68:	20 18       	sub	r8,1
80003e6a:	89 08       	st.w	r4[0x0],r8
                    --uxDeletedTasksWaitingCleanUp;
80003e6c:	6e 08       	ld.w	r8,r7[0x0]
80003e6e:	20 18       	sub	r8,1
80003e70:	8f 08       	st.w	r7[0x0],r8
                }
                taskEXIT_CRITICAL();
80003e72:	f0 1f 00 0e 	mcall	80003ea8 <prvIdleTask+0x60>

                prvDeleteTCB( pxTCB );
80003e76:	0c 9c       	mov	r12,r6
80003e78:	f0 1f 00 0d 	mcall	80003eac <prvIdleTask+0x64>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80003e7c:	6e 08       	ld.w	r8,r7[0x0]
80003e7e:	58 08       	cp.w	r8,0
80003e80:	ce b1       	brne	80003e56 <prvIdleTask+0xe>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80003e82:	66 08       	ld.w	r8,r3[0x0]
80003e84:	58 18       	cp.w	r8,1
80003e86:	fe 98 ff fb 	brls	80003e7c <prvIdleTask+0x34>
                {
                    taskYIELD();
80003e8a:	d7 33       	scall
80003e8c:	cf 8b       	rjmp	80003e7c <prvIdleTask+0x34>
80003e8e:	00 00       	add	r0,r0
80003e90:	00 00       	add	r0,r0
80003e92:	05 f8       	ld.ub	r8,r2[0x7]
80003e94:	00 00       	add	r0,r0
80003e96:	06 4c       	or	r12,r3
80003e98:	00 00       	add	r0,r0
80003e9a:	06 48       	or	r8,r3
80003e9c:	00 00       	add	r0,r0
80003e9e:	05 58       	ld.sh	r8,--r2
80003ea0:	80 00       	ld.sh	r0,r0[0x0]
80003ea2:	2f fc       	sub	r12,-1
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	2f 42       	sub	r2,-12
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	31 08       	mov	r8,16
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	3e 2c       	mov	r12,-30

80003eb0 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
80003eb0:	d4 31       	pushm	r0-r7,lr
80003eb2:	20 1d       	sub	sp,4
80003eb4:	50 0c       	stdsp	sp[0x0],r12
80003eb6:	16 97       	mov	r7,r11
80003eb8:	12 90       	mov	r0,r9
80003eba:	10 94       	mov	r4,r8
80003ebc:	40 a2       	lddsp	r2,sp[0x28]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
80003ebe:	e7 da c0 10 	bfextu	r3,r10,0x0,0x10
80003ec2:	e6 0c 15 02 	lsl	r12,r3,0x2
80003ec6:	f0 1f 00 61 	mcall	80004048 <xTaskCreate+0x198>
80003eca:	18 96       	mov	r6,r12

                if( pxStack != NULL )
80003ecc:	c0 31       	brne	80003ed2 <xTaskCreate+0x22>
80003ece:	3f fc       	mov	r12,-1
80003ed0:	cb a8       	rjmp	80004044 <xTaskCreate+0x194>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
80003ed2:	35 4c       	mov	r12,84
80003ed4:	f0 1f 00 5d 	mcall	80004048 <xTaskCreate+0x198>
80003ed8:	18 95       	mov	r5,r12

                    if( pxNewTCB != NULL )
80003eda:	c0 50       	breq	80003ee4 <xTaskCreate+0x34>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
80003edc:	99 c6       	st.w	r12[0x30],r6
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
80003ede:	58 07       	cp.w	r7,0
80003ee0:	c0 71       	brne	80003eee <xTaskCreate+0x3e>
80003ee2:	c2 28       	rjmp	80003f26 <xTaskCreate+0x76>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
80003ee4:	0c 9c       	mov	r12,r6
80003ee6:	f0 1f 00 5a 	mcall	8000404c <xTaskCreate+0x19c>
80003eea:	3f fc       	mov	r12,-1
80003eec:	ca c8       	rjmp	80004044 <xTaskCreate+0x194>
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80003eee:	0f 88       	ld.ub	r8,r7[0x0]
80003ef0:	f9 68 00 34 	st.b	r12[52],r8

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80003ef4:	0f 89       	ld.ub	r9,r7[0x0]
80003ef6:	30 08       	mov	r8,0
80003ef8:	f0 09 18 00 	cp.b	r9,r8
80003efc:	c1 10       	breq	80003f1e <xTaskCreate+0x6e>
80003efe:	2f f7       	sub	r7,-1
80003f00:	f8 c8 ff cb 	sub	r8,r12,-53
80003f04:	30 19       	mov	r9,1
80003f06:	30 0b       	mov	r11,0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80003f08:	0f 8a       	ld.ub	r10,r7[0x0]
80003f0a:	b0 8a       	st.b	r8[0x0],r10

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
80003f0c:	0f 8a       	ld.ub	r10,r7[0x0]
80003f0e:	f6 0a 18 00 	cp.b	r10,r11
80003f12:	c0 60       	breq	80003f1e <xTaskCreate+0x6e>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80003f14:	2f f9       	sub	r9,-1
80003f16:	2f f7       	sub	r7,-1
80003f18:	2f f8       	sub	r8,-1
80003f1a:	59 09       	cp.w	r9,16
80003f1c:	cf 61       	brne	80003f08 <xTaskCreate+0x58>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80003f1e:	30 08       	mov	r8,0
80003f20:	eb 68 00 43 	st.b	r5[67],r8
80003f24:	c0 48       	rjmp	80003f2c <xTaskCreate+0x7c>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
80003f26:	30 08       	mov	r8,0
80003f28:	f9 68 00 34 	st.b	r12[52],r8
80003f2c:	58 74       	cp.w	r4,7
80003f2e:	f9 b4 0b 07 	movhi	r4,7
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
80003f32:	8b b4       	st.w	r5[0x2c],r4
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
80003f34:	eb 44 00 44 	st.w	r5[68],r4
            pxNewTCB->uxMutexesHeld = 0;
80003f38:	30 07       	mov	r7,0
80003f3a:	eb 47 00 48 	st.w	r5[72],r7
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80003f3e:	ea c1 ff fc 	sub	r1,r5,-4
80003f42:	02 9c       	mov	r12,r1
80003f44:	f0 1f 00 43 	mcall	80004050 <xTaskCreate+0x1a0>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80003f48:	ea cc ff e8 	sub	r12,r5,-24
80003f4c:	f0 1f 00 41 	mcall	80004050 <xTaskCreate+0x1a0>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80003f50:	8b 45       	st.w	r5[0x10],r5

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80003f52:	e8 04 11 08 	rsub	r4,r4,8
80003f56:	8b 64       	st.w	r5[0x18],r4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80003f58:	8b 95       	st.w	r5[0x24],r5
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
80003f5a:	ea c8 ff b4 	sub	r8,r5,-76
80003f5e:	91 07       	st.w	r8[0x0],r7
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
80003f60:	ea c8 ff b0 	sub	r8,r5,-80
80003f64:	b0 87       	st.b	r8[0x0],r7
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
80003f66:	20 13       	sub	r3,1
80003f68:	ec 03 00 26 	add	r6,r6,r3<<0x2
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003f6c:	00 9a       	mov	r10,r0
80003f6e:	40 0b       	lddsp	r11,sp[0x0]
80003f70:	0c 9c       	mov	r12,r6
80003f72:	e0 1c ff fc 	andl	r12,0xfffc
80003f76:	f0 1f 00 38 	mcall	80004054 <xTaskCreate+0x1a4>
80003f7a:	8b 0c       	st.w	r5[0x0],r12

    if( pxCreatedTask != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80003f7c:	58 02       	cp.w	r2,0
80003f7e:	e5 f5 1a 00 	st.wne	r2[0x0],r5

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
80003f82:	f0 1f 00 36 	mcall	80004058 <xTaskCreate+0x1a8>
    {
        uxCurrentNumberOfTasks++;
80003f86:	4b 68       	lddpc	r8,8000405c <xTaskCreate+0x1ac>
80003f88:	70 09       	ld.w	r9,r8[0x0]
80003f8a:	2f f9       	sub	r9,-1
80003f8c:	91 09       	st.w	r8[0x0],r9

        if( pxCurrentTCB == NULL )
80003f8e:	4b 58       	lddpc	r8,80004060 <xTaskCreate+0x1b0>
80003f90:	70 08       	ld.w	r8,r8[0x0]
80003f92:	58 08       	cp.w	r8,0
80003f94:	c2 61       	brne	80003fe0 <xTaskCreate+0x130>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
80003f96:	4b 38       	lddpc	r8,80004060 <xTaskCreate+0x1b0>
80003f98:	91 05       	st.w	r8[0x0],r5

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80003f9a:	4b 18       	lddpc	r8,8000405c <xTaskCreate+0x1ac>
80003f9c:	70 08       	ld.w	r8,r8[0x0]
80003f9e:	58 18       	cp.w	r8,1
80003fa0:	c2 d1       	brne	80003ffa <xTaskCreate+0x14a>
80003fa2:	4b 17       	lddpc	r7,80004064 <xTaskCreate+0x1b4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
80003fa4:	ee c6 ff 60 	sub	r6,r7,-160
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
80003fa8:	0e 9c       	mov	r12,r7
80003faa:	f0 1f 00 30 	mcall	80004068 <xTaskCreate+0x1b8>
80003fae:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80003fb0:	0c 37       	cp.w	r7,r6
80003fb2:	cf b1       	brne	80003fa8 <xTaskCreate+0xf8>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
80003fb4:	4a e7       	lddpc	r7,8000406c <xTaskCreate+0x1bc>
80003fb6:	0e 9c       	mov	r12,r7
80003fb8:	f0 1f 00 2c 	mcall	80004068 <xTaskCreate+0x1b8>
    vListInitialise( &xDelayedTaskList2 );
80003fbc:	4a d6       	lddpc	r6,80004070 <xTaskCreate+0x1c0>
80003fbe:	0c 9c       	mov	r12,r6
80003fc0:	f0 1f 00 2a 	mcall	80004068 <xTaskCreate+0x1b8>
    vListInitialise( &xPendingReadyList );
80003fc4:	4a cc       	lddpc	r12,80004074 <xTaskCreate+0x1c4>
80003fc6:	f0 1f 00 29 	mcall	80004068 <xTaskCreate+0x1b8>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
80003fca:	4a cc       	lddpc	r12,80004078 <xTaskCreate+0x1c8>
80003fcc:	f0 1f 00 27 	mcall	80004068 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
80003fd0:	4a bc       	lddpc	r12,8000407c <xTaskCreate+0x1cc>
80003fd2:	f0 1f 00 26 	mcall	80004068 <xTaskCreate+0x1b8>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
80003fd6:	4a b8       	lddpc	r8,80004080 <xTaskCreate+0x1d0>
80003fd8:	91 07       	st.w	r8[0x0],r7
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
80003fda:	4a b8       	lddpc	r8,80004084 <xTaskCreate+0x1d4>
80003fdc:	91 06       	st.w	r8[0x0],r6
80003fde:	c0 e8       	rjmp	80003ffa <xTaskCreate+0x14a>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
80003fe0:	4a a8       	lddpc	r8,80004088 <xTaskCreate+0x1d8>
80003fe2:	70 08       	ld.w	r8,r8[0x0]
80003fe4:	58 08       	cp.w	r8,0
80003fe6:	c0 a1       	brne	80003ffa <xTaskCreate+0x14a>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80003fe8:	49 e8       	lddpc	r8,80004060 <xTaskCreate+0x1b0>
80003fea:	70 08       	ld.w	r8,r8[0x0]
80003fec:	70 b9       	ld.w	r9,r8[0x2c]
80003fee:	6a b8       	ld.w	r8,r5[0x2c]
80003ff0:	10 39       	cp.w	r9,r8
80003ff2:	e0 8b 00 04 	brhi	80003ffa <xTaskCreate+0x14a>
                {
                    pxCurrentTCB = pxNewTCB;
80003ff6:	49 b8       	lddpc	r8,80004060 <xTaskCreate+0x1b0>
80003ff8:	91 05       	st.w	r8[0x0],r5
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
80003ffa:	4a 58       	lddpc	r8,8000408c <xTaskCreate+0x1dc>
80003ffc:	70 09       	ld.w	r9,r8[0x0]
80003ffe:	2f f9       	sub	r9,-1
80004000:	91 09       	st.w	r8[0x0],r9
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
80004002:	6a b8       	ld.w	r8,r5[0x2c]
80004004:	4a 39       	lddpc	r9,80004090 <xTaskCreate+0x1e0>
80004006:	72 09       	ld.w	r9,r9[0x0]
80004008:	12 38       	cp.w	r8,r9
8000400a:	e0 88 00 04 	brls	80004012 <xTaskCreate+0x162>
8000400e:	4a 19       	lddpc	r9,80004090 <xTaskCreate+0x1e0>
80004010:	93 08       	st.w	r9[0x0],r8
80004012:	6a bc       	ld.w	r12,r5[0x2c]
80004014:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004018:	02 9b       	mov	r11,r1
8000401a:	49 38       	lddpc	r8,80004064 <xTaskCreate+0x1b4>
8000401c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004020:	f0 1f 00 1d 	mcall	80004094 <xTaskCreate+0x1e4>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
80004024:	f0 1f 00 1d 	mcall	80004098 <xTaskCreate+0x1e8>

    if( xSchedulerRunning != pdFALSE )
80004028:	49 88       	lddpc	r8,80004088 <xTaskCreate+0x1d8>
8000402a:	70 08       	ld.w	r8,r8[0x0]
8000402c:	58 08       	cp.w	r8,0
8000402e:	c0 a0       	breq	80004042 <xTaskCreate+0x192>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80004030:	48 c8       	lddpc	r8,80004060 <xTaskCreate+0x1b0>
80004032:	70 08       	ld.w	r8,r8[0x0]
80004034:	70 b9       	ld.w	r9,r8[0x2c]
80004036:	6a b8       	ld.w	r8,r5[0x2c]
80004038:	10 39       	cp.w	r9,r8
8000403a:	c0 42       	brcc	80004042 <xTaskCreate+0x192>
        {
            taskYIELD_IF_USING_PREEMPTION();
8000403c:	d7 33       	scall
8000403e:	30 1c       	mov	r12,1
80004040:	c0 28       	rjmp	80004044 <xTaskCreate+0x194>
80004042:	30 1c       	mov	r12,1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
80004044:	2f fd       	sub	sp,-4
80004046:	d8 32       	popm	r0-r7,pc
80004048:	80 00       	ld.sh	r0,r0[0x0]
8000404a:	31 ec       	mov	r12,30
8000404c:	80 00       	ld.sh	r0,r0[0x0]
8000404e:	31 c4       	mov	r4,28
80004050:	80 00       	ld.sh	r0,r0[0x0]
80004052:	2e f4       	sub	r4,-17
80004054:	80 00       	ld.sh	r0,r0[0x0]
80004056:	2f 6a       	sub	r10,-10
80004058:	80 00       	ld.sh	r0,r0[0x0]
8000405a:	2f fc       	sub	r12,-1
8000405c:	00 00       	add	r0,r0
8000405e:	06 48       	or	r8,r3
80004060:	00 00       	add	r0,r0
80004062:	05 fc       	ld.ub	r12,r2[0x7]
80004064:	00 00       	add	r0,r0
80004066:	05 58       	ld.sh	r8,--r2
80004068:	80 00       	ld.sh	r0,r0[0x0]
8000406a:	2e e0       	sub	r0,-18
8000406c:	00 00       	add	r0,r0
8000406e:	06 14       	sub	r4,r3
80004070:	00 00       	add	r0,r0
80004072:	06 30       	cp.w	r0,r3
80004074:	00 00       	add	r0,r0
80004076:	06 00       	add	r0,r3
80004078:	00 00       	add	r0,r0
8000407a:	06 4c       	or	r12,r3
8000407c:	00 00       	add	r0,r0
8000407e:	06 64       	and	r4,r3
80004080:	00 00       	add	r0,r0
80004082:	05 44       	ld.w	r4,--r2
80004084:	00 00       	add	r0,r0
80004086:	05 50       	ld.sh	r0,--r2
80004088:	00 00       	add	r0,r0
8000408a:	05 48       	ld.w	r8,--r2
8000408c:	00 00       	add	r0,r0
8000408e:	06 44       	or	r4,r3
80004090:	00 00       	add	r0,r0
80004092:	06 78       	tst	r8,r3
80004094:	80 00       	ld.sh	r0,r0[0x0]
80004096:	2e fa       	sub	r10,-17
80004098:	80 00       	ld.sh	r0,r0[0x0]
8000409a:	31 08       	mov	r8,16

8000409c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
8000409c:	d4 01       	pushm	lr
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
8000409e:	48 e8       	lddpc	r8,800040d4 <vTaskStartScheduler+0x38>
800040a0:	1a d8       	st.w	--sp,r8
800040a2:	30 08       	mov	r8,0
800040a4:	10 99       	mov	r9,r8
800040a6:	e0 6a 01 00 	mov	r10,256
800040aa:	48 cb       	lddpc	r11,800040d8 <vTaskStartScheduler+0x3c>
800040ac:	48 cc       	lddpc	r12,800040dc <vTaskStartScheduler+0x40>
800040ae:	f0 1f 00 0d 	mcall	800040e0 <vTaskStartScheduler+0x44>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
800040b2:	2f fd       	sub	sp,-4
800040b4:	58 1c       	cp.w	r12,1
800040b6:	c0 d1       	brne	800040d0 <vTaskStartScheduler+0x34>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
800040b8:	d3 03       	ssrf	0x10
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
800040ba:	3f f9       	mov	r9,-1
800040bc:	48 a8       	lddpc	r8,800040e4 <vTaskStartScheduler+0x48>
800040be:	91 09       	st.w	r8[0x0],r9
        xSchedulerRunning = pdTRUE;
800040c0:	30 19       	mov	r9,1
800040c2:	48 a8       	lddpc	r8,800040e8 <vTaskStartScheduler+0x4c>
800040c4:	91 09       	st.w	r8[0x0],r9
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
800040c6:	30 09       	mov	r9,0
800040c8:	48 98       	lddpc	r8,800040ec <vTaskStartScheduler+0x50>
800040ca:	91 09       	st.w	r8[0x0],r9

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
800040cc:	f0 1f 00 09 	mcall	800040f0 <vTaskStartScheduler+0x54>
800040d0:	d8 02       	popm	pc
800040d2:	00 00       	add	r0,r0
800040d4:	00 00       	add	r0,r0
800040d6:	06 60       	and	r0,r3
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	54 48       	stdsp	sp[0x110],r8
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	3e 48       	mov	r8,-28
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	3e b0       	mov	r0,-21
800040e4:	00 00       	add	r0,r0
800040e6:	05 40       	ld.w	r0,--r2
800040e8:	00 00       	add	r0,r0
800040ea:	05 48       	ld.w	r8,--r2
800040ec:	00 00       	add	r0,r0
800040ee:	06 28       	rsub	r8,r3
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	30 0c       	mov	r12,0

800040f4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800040f4:	f8 08 16 05 	lsr	r8,r12,0x5
800040f8:	a9 68       	lsl	r8,0x8
800040fa:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800040fe:	58 1b       	cp.w	r11,1
80004100:	c0 d0       	breq	8000411a <gpio_enable_module_pin+0x26>
80004102:	c0 63       	brcs	8000410e <gpio_enable_module_pin+0x1a>
80004104:	58 2b       	cp.w	r11,2
80004106:	c1 00       	breq	80004126 <gpio_enable_module_pin+0x32>
80004108:	58 3b       	cp.w	r11,3
8000410a:	c1 40       	breq	80004132 <gpio_enable_module_pin+0x3e>
8000410c:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000410e:	30 19       	mov	r9,1
80004110:	f2 0c 09 49 	lsl	r9,r9,r12
80004114:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004116:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004118:	c1 28       	rjmp	8000413c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000411a:	30 19       	mov	r9,1
8000411c:	f2 0c 09 49 	lsl	r9,r9,r12
80004120:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004122:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004124:	c0 c8       	rjmp	8000413c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004126:	30 19       	mov	r9,1
80004128:	f2 0c 09 49 	lsl	r9,r9,r12
8000412c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000412e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004130:	c0 68       	rjmp	8000413c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004132:	30 19       	mov	r9,1
80004134:	f2 0c 09 49 	lsl	r9,r9,r12
80004138:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000413a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000413c:	30 19       	mov	r9,1
8000413e:	f2 0c 09 4c 	lsl	r12,r9,r12
80004142:	91 2c       	st.w	r8[0x8],r12
80004144:	5e fd       	retal	0
80004146:	d7 03       	nop

80004148 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004148:	d4 21       	pushm	r4-r7,lr
8000414a:	18 97       	mov	r7,r12
8000414c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000414e:	58 0b       	cp.w	r11,0
80004150:	c0 31       	brne	80004156 <gpio_enable_module+0xe>
80004152:	30 05       	mov	r5,0
80004154:	c0 d8       	rjmp	8000416e <gpio_enable_module+0x26>
80004156:	30 06       	mov	r6,0
80004158:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000415a:	6e 1b       	ld.w	r11,r7[0x4]
8000415c:	6e 0c       	ld.w	r12,r7[0x0]
8000415e:	f0 1f 00 06 	mcall	80004174 <gpio_enable_module+0x2c>
80004162:	18 45       	or	r5,r12
		gpiomap++;
80004164:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004166:	2f f6       	sub	r6,-1
80004168:	0c 34       	cp.w	r4,r6
8000416a:	fe 9b ff f8 	brhi	8000415a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000416e:	0a 9c       	mov	r12,r5
80004170:	d8 22       	popm	r4-r7,pc
80004172:	00 00       	add	r0,r0
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	40 f4       	lddsp	r4,sp[0x3c]

80004178 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004178:	f8 08 16 05 	lsr	r8,r12,0x5
8000417c:	a9 68       	lsl	r8,0x8
8000417e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004182:	30 19       	mov	r9,1
80004184:	f2 0c 09 4c 	lsl	r12,r9,r12
80004188:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000418c:	91 1c       	st.w	r8[0x4],r12
}
8000418e:	5e fc       	retal	r12

80004190 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
80004190:	eb cd 40 e0 	pushm	r5-r7,lr
80004194:	18 97       	mov	r7,r12
80004196:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
80004198:	58 0b       	cp.w	r11,0
8000419a:	c0 a0       	breq	800041ae <gpio_enable_gpio+0x1e>
8000419c:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
8000419e:	6e 0c       	ld.w	r12,r7[0x0]
800041a0:	f0 1f 00 05 	mcall	800041b4 <gpio_enable_gpio+0x24>
		gpiomap++;
800041a4:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
800041a6:	2f f5       	sub	r5,-1
800041a8:	0a 36       	cp.w	r6,r5
800041aa:	fe 9b ff fa 	brhi	8000419e <gpio_enable_gpio+0xe>
800041ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800041b2:	00 00       	add	r0,r0
800041b4:	80 00       	ld.sh	r0,r0[0x0]
800041b6:	41 78       	lddsp	r8,sp[0x5c]

800041b8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800041b8:	f8 08 16 05 	lsr	r8,r12,0x5
800041bc:	a9 68       	lsl	r8,0x8
800041be:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800041c2:	30 19       	mov	r9,1
800041c4:	f2 0c 09 4c 	lsl	r12,r9,r12
800041c8:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800041cc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800041d0:	91 1c       	st.w	r8[0x4],r12
}
800041d2:	5e fc       	retal	r12

800041d4 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800041d4:	f8 08 16 05 	lsr	r8,r12,0x5
800041d8:	a9 68       	lsl	r8,0x8
800041da:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800041de:	30 19       	mov	r9,1
800041e0:	f2 0c 09 4c 	lsl	r12,r9,r12
800041e4:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800041e8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800041ec:	91 1c       	st.w	r8[0x4],r12
}
800041ee:	5e fc       	retal	r12

800041f0 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800041f0:	f8 08 16 05 	lsr	r8,r12,0x5
800041f4:	a9 68       	lsl	r8,0x8
800041f6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
800041fa:	30 19       	mov	r9,1
800041fc:	f2 0c 09 4c 	lsl	r12,r9,r12
80004200:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80004204:	12 3b       	cp.w	r11,r9
80004206:	c0 a0       	breq	8000421a <gpio_enable_pin_interrupt+0x2a>
80004208:	c0 43       	brcs	80004210 <gpio_enable_pin_interrupt+0x20>
8000420a:	58 2b       	cp.w	r11,2
8000420c:	c1 11       	brne	8000422e <gpio_enable_pin_interrupt+0x3e>
8000420e:	c0 b8       	rjmp	80004224 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80004210:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80004214:	f1 4c 00 b8 	st.w	r8[184],r12
80004218:	c0 c8       	rjmp	80004230 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
8000421a:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
8000421e:	f1 4c 00 b8 	st.w	r8[184],r12
80004222:	c0 78       	rjmp	80004230 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80004224:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
80004228:	f1 4c 00 b4 	st.w	r8[180],r12
8000422c:	c0 28       	rjmp	80004230 <gpio_enable_pin_interrupt+0x40>
8000422e:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80004230:	f1 4c 00 94 	st.w	r8[148],r12
80004234:	5e fd       	retal	0

80004236 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004236:	f8 08 16 05 	lsr	r8,r12,0x5
8000423a:	a9 68       	lsl	r8,0x8
8000423c:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80004240:	f0 f8 00 d0 	ld.w	r8,r8[208]
80004244:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80004248:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000424c:	5e fc       	retal	r12

8000424e <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000424e:	f8 08 16 05 	lsr	r8,r12,0x5
80004252:	a9 68       	lsl	r8,0x8
80004254:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80004258:	30 19       	mov	r9,1
8000425a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000425e:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
80004262:	5e fc       	retal	r12

80004264 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004264:	c0 08       	rjmp	80004264 <_unhandled_interrupt>
80004266:	d7 03       	nop

80004268 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004268:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000426c:	49 99       	lddpc	r9,800042d0 <INTC_register_interrupt+0x68>
8000426e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004272:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004276:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004278:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000427c:	58 0a       	cp.w	r10,0
8000427e:	c0 91       	brne	80004290 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004280:	49 59       	lddpc	r9,800042d4 <INTC_register_interrupt+0x6c>
80004282:	49 6a       	lddpc	r10,800042d8 <INTC_register_interrupt+0x70>
80004284:	12 1a       	sub	r10,r9
80004286:	fe 79 08 00 	mov	r9,-63488
8000428a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000428e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004290:	58 1a       	cp.w	r10,1
80004292:	c0 a1       	brne	800042a6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004294:	49 09       	lddpc	r9,800042d4 <INTC_register_interrupt+0x6c>
80004296:	49 2a       	lddpc	r10,800042dc <INTC_register_interrupt+0x74>
80004298:	12 1a       	sub	r10,r9
8000429a:	bf aa       	sbr	r10,0x1e
8000429c:	fe 79 08 00 	mov	r9,-63488
800042a0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800042a4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800042a6:	58 2a       	cp.w	r10,2
800042a8:	c0 a1       	brne	800042bc <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800042aa:	48 b9       	lddpc	r9,800042d4 <INTC_register_interrupt+0x6c>
800042ac:	48 da       	lddpc	r10,800042e0 <INTC_register_interrupt+0x78>
800042ae:	12 1a       	sub	r10,r9
800042b0:	bf ba       	sbr	r10,0x1f
800042b2:	fe 79 08 00 	mov	r9,-63488
800042b6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800042ba:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800042bc:	48 69       	lddpc	r9,800042d4 <INTC_register_interrupt+0x6c>
800042be:	48 aa       	lddpc	r10,800042e4 <INTC_register_interrupt+0x7c>
800042c0:	12 1a       	sub	r10,r9
800042c2:	ea 1a c0 00 	orh	r10,0xc000
800042c6:	fe 79 08 00 	mov	r9,-63488
800042ca:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800042ce:	5e fc       	retal	r12
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	54 50       	stdsp	sp[0x114],r0
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	52 00       	stdsp	sp[0x80],r0
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	53 04       	stdsp	sp[0xc0],r4
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	53 12       	stdsp	sp[0xc4],r2
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	53 20       	stdsp	sp[0xc8],r0
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	53 2e       	stdsp	sp[0xc8],lr

800042e8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800042e8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800042ea:	49 18       	lddpc	r8,8000432c <INTC_init_interrupts+0x44>
800042ec:	e3 b8 00 01 	mtsr	0x4,r8
800042f0:	49 0e       	lddpc	lr,80004330 <INTC_init_interrupts+0x48>
800042f2:	30 07       	mov	r7,0
800042f4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800042f6:	49 0c       	lddpc	r12,80004334 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800042f8:	49 05       	lddpc	r5,80004338 <INTC_init_interrupts+0x50>
800042fa:	10 15       	sub	r5,r8
800042fc:	fe 76 08 00 	mov	r6,-63488
80004300:	c1 08       	rjmp	80004320 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004302:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004304:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004306:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004308:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000430c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000430e:	10 3a       	cp.w	r10,r8
80004310:	fe 9b ff fc 	brhi	80004308 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004314:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004318:	2f f7       	sub	r7,-1
8000431a:	2f 8e       	sub	lr,-8
8000431c:	59 47       	cp.w	r7,20
8000431e:	c0 50       	breq	80004328 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004320:	7c 08       	ld.w	r8,lr[0x0]
80004322:	58 08       	cp.w	r8,0
80004324:	ce f1       	brne	80004302 <INTC_init_interrupts+0x1a>
80004326:	cf 7b       	rjmp	80004314 <INTC_init_interrupts+0x2c>
80004328:	d8 22       	popm	r4-r7,pc
8000432a:	00 00       	add	r0,r0
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	52 00       	stdsp	sp[0x80],r0
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	54 50       	stdsp	sp[0x114],r0
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	42 64       	lddsp	r4,sp[0x98]
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	53 04       	stdsp	sp[0xc0],r4

8000433c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000433c:	fe 78 08 00 	mov	r8,-63488
80004340:	e0 69 00 83 	mov	r9,131
80004344:	f2 0c 01 0c 	sub	r12,r9,r12
80004348:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000434c:	f2 ca ff c0 	sub	r10,r9,-64
80004350:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004354:	58 08       	cp.w	r8,0
80004356:	c0 21       	brne	8000435a <_get_interrupt_handler+0x1e>
80004358:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
8000435a:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000435e:	48 5a       	lddpc	r10,80004370 <_get_interrupt_handler+0x34>
80004360:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004364:	f0 08 11 1f 	rsub	r8,r8,31
80004368:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000436a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000436e:	5e fc       	retal	r12
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	54 50       	stdsp	sp[0x114],r0

80004374 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004374:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004378:	fe c0 f1 78 	sub	r0,pc,-3720

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000437c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004380:	d5 53       	csrf	0x15
  cp      r0, r1
80004382:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80004384:	e0 61 05 18 	mov	r1,1304
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004388:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000438a:	c0 62       	brcc	80004396 <idata_load_loop_end>
  cp      r0, r1
8000438c:	48 92       	lddpc	r2,800043b0 <udata_clear_loop_end+0x4>

8000438e <idata_load_loop>:
  brlo    idata_load_loop
8000438e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004390:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004392:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004394:	cf d3       	brcs	8000438e <idata_load_loop>

80004396 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004396:	e0 60 05 18 	mov	r0,1304
  mov     r2, 0
  mov     r3, 0
8000439a:	e0 61 09 e0 	mov	r1,2528
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000439e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
800043a0:	c0 62       	brcc	800043ac <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800043a2:	30 02       	mov	r2,0
800043a4:	30 03       	mov	r3,0

800043a6 <udata_clear_loop>:
800043a6:	a1 22       	st.d	r0++,r2
800043a8:	02 30       	cp.w	r0,r1
800043aa:	cf e3       	brcs	800043a6 <udata_clear_loop>

800043ac <udata_clear_loop_end>:
800043ac:	fe cf ff f4 	sub	pc,pc,-12
800043b0:	80 03       	ld.sh	r3,r0[0x0]
800043b2:	5e 10       	retne	r0

800043b4 <master_callback>:

	else if( arg == AUDIO_ADC_RELOAD_CB )
	{
		adc_reload_callback();;
	}
}
800043b4:	5e fc       	retal	r12
800043b6:	d7 03       	nop

800043b8 <main>:
		
	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
}

int main (void)
{
800043b8:	eb cd 40 e0 	pushm	r5-r7,lr
800043bc:	20 7d       	sub	sp,28
/*! \brief Static function definitions
 */
static void init_sys_clocks(void)
{
  // Switch to OSC0 to speed up the booting
  pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
800043be:	30 3a       	mov	r10,3
800043c0:	e0 6b 1b 00 	mov	r11,6912
800043c4:	ea 1b 00 b7 	orh	r11,0xb7
800043c8:	fe 7c 0c 00 	mov	r12,-62464
800043cc:	f0 1f 00 69 	mcall	80004570 <main+0x1b8>

  // Start oscillator1
  pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
800043d0:	e0 6b 44 00 	mov	r11,17408
800043d4:	ea 1b 00 ac 	orh	r11,0xac
800043d8:	fe 7c 0c 00 	mov	r12,-62464
800043dc:	f0 1f 00 66 	mcall	80004574 <main+0x1bc>
  pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
800043e0:	30 3b       	mov	r11,3
800043e2:	fe 7c 0c 00 	mov	r12,-62464
800043e6:	f0 1f 00 65 	mcall	80004578 <main+0x1c0>

  // Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
  // We use OSC1 since we need a correct master clock for the SSC module to generate
  // 
  pm_pll_setup(&AVR32_PM, 0,  // pll.
800043ea:	31 05       	mov	r5,16
800043ec:	1a d5       	st.w	--sp,r5
800043ee:	30 18       	mov	r8,1
800043f0:	10 99       	mov	r9,r8
800043f2:	30 aa       	mov	r10,10
800043f4:	30 0b       	mov	r11,0
800043f6:	fe 7c 0c 00 	mov	r12,-62464
800043fa:	f0 1f 00 61 	mcall	8000457c <main+0x1c4>
    1,   // osc.
    16); // lockcount.

  // Set PLL operating range and divider (fpll = fvco/2)
  // -> PLL0 output = 62.0928 MHz
  pm_pll_set_option(&AVR32_PM, 0, // pll.
800043fe:	30 08       	mov	r8,0
80004400:	30 19       	mov	r9,1
80004402:	12 9a       	mov	r10,r9
80004404:	10 9b       	mov	r11,r8
80004406:	fe 7c 0c 00 	mov	r12,-62464
8000440a:	f0 1f 00 5e 	mcall	80004580 <main+0x1c8>
    1,  // pll_freq.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL0 and wait for the lock
  pm_pll_enable(&AVR32_PM, 0);
8000440e:	30 0b       	mov	r11,0
80004410:	fe 7c 0c 00 	mov	r12,-62464
80004414:	f0 1f 00 5c 	mcall	80004584 <main+0x1cc>
  pm_wait_for_pll0_locked(&AVR32_PM);
80004418:	fe 7c 0c 00 	mov	r12,-62464
8000441c:	f0 1f 00 5b 	mcall	80004588 <main+0x1d0>
  // Set all peripheral clocks torun at master clock rate
  pm_cksel(&AVR32_PM,
80004420:	30 07       	mov	r7,0
80004422:	1a d7       	st.w	--sp,r7
80004424:	1a d7       	st.w	--sp,r7
80004426:	0e 98       	mov	r8,r7
80004428:	0e 99       	mov	r9,r7
8000442a:	0e 9a       	mov	r10,r7
8000442c:	0e 9b       	mov	r11,r7
8000442e:	fe 7c 0c 00 	mov	r12,-62464
80004432:	f0 1f 00 57 	mcall	8000458c <main+0x1d4>
    0,   // pbbsel.
    0,   // hsbdiv.
    0);  // hsbsel.

  // Set one waitstate for the flash
  flashc_set_wait_state(1);
80004436:	30 1c       	mov	r12,1
80004438:	f0 1f 00 56 	mcall	80004590 <main+0x1d8>

  // Switch to PLL0 as the master clock
  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
8000443c:	30 2b       	mov	r11,2
8000443e:	fe 7c 0c 00 	mov	r12,-62464
80004442:	f0 1f 00 55 	mcall	80004594 <main+0x1dc>

  // Use 12MHz from OSC0 and generate 96 MHz
  pm_pll_setup(&AVR32_PM, 1,  // pll.
80004446:	1a d5       	st.w	--sp,r5
80004448:	0e 98       	mov	r8,r7
8000444a:	30 19       	mov	r9,1
8000444c:	30 7a       	mov	r10,7
8000444e:	12 9b       	mov	r11,r9
80004450:	fe 7c 0c 00 	mov	r12,-62464
80004454:	f0 1f 00 4a 	mcall	8000457c <main+0x1c4>
    7,   // mul.
    1,   // div.
    0,   // osc.
    16); // lockcount.

  pm_pll_set_option(&AVR32_PM, 1, // pll.
80004458:	0e 98       	mov	r8,r7
8000445a:	30 19       	mov	r9,1
8000445c:	12 9a       	mov	r10,r9
8000445e:	12 9b       	mov	r11,r9
80004460:	fe 7c 0c 00 	mov	r12,-62464
80004464:	f0 1f 00 47 	mcall	80004580 <main+0x1c8>
    1,  // pll_freq: choose the range 80-180MHz.
    1,  // pll_div2.
    0); // pll_wbwdisable.

  // start PLL1 and wait forl lock
  pm_pll_enable(&AVR32_PM, 1);
80004468:	30 1b       	mov	r11,1
8000446a:	fe 7c 0c 00 	mov	r12,-62464
8000446e:	f0 1f 00 46 	mcall	80004584 <main+0x1cc>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(&AVR32_PM);
80004472:	fe 7c 0c 00 	mov	r12,-62464
80004476:	f0 1f 00 49 	mcall	80004598 <main+0x1e0>
{
	/* Insert system clock initialization code here (sysclk_init()). */
	init_sys_clocks();
	
	/* Initialize RS232 debug text output. */
	init_dbg_rs232(FPBA_HZ); /**/
8000447a:	e0 6c 76 00 	mov	r12,30208
8000447e:	ea 1c 03 b3 	orh	r12,0x3b3
80004482:	f0 1f 00 47 	mcall	8000459c <main+0x1e4>
	/* TWI */
	const gpio_map_t TPA6130_TWI_GPIO_MAP =
	{
		{TPA6130_TWI_SCL_PIN, TPA6130_TWI_SCL_FUNCTION},
		{TPA6130_TWI_SDA_PIN, TPA6130_TWI_SDA_FUNCTION}
	};
80004486:	4c 78       	lddpc	r8,800045a0 <main+0x1e8>
80004488:	fa 05 00 0c 	add	r12,sp,r5
8000448c:	f0 ea 00 00 	ld.d	r10,r8[0]
80004490:	f8 eb 00 00 	st.d	r12[0],r10
80004494:	f0 e8 00 08 	ld.d	r8,r8[8]
80004498:	f8 e9 00 08 	st.d	r12[8],r8
	const twi_options_t TPA6130_TWI_OPTIONS =
	{
		.pba_hz = FPBA_HZ,
		.speed  = TPA6130_TWI_MASTER_SPEED,
		.chip   = TPA6130_TWI_ADDRESS
	};
8000449c:	4c 28       	lddpc	r8,800045a4 <main+0x1ec>
8000449e:	fa c6 ff e0 	sub	r6,sp,-32
800044a2:	f0 ea 00 00 	ld.d	r10,r8[0]
800044a6:	ec eb 00 00 	st.d	r6[0],r10
800044aa:	70 28       	ld.w	r8,r8[0x8]
800044ac:	8d 28       	st.w	r6[0x8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(TPA6130_TWI_GPIO_MAP,
800044ae:	30 2b       	mov	r11,2
800044b0:	f0 1f 00 3e 	mcall	800045a8 <main+0x1f0>
	sizeof(TPA6130_TWI_GPIO_MAP) / sizeof(TPA6130_TWI_GPIO_MAP[0]));

	// Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
800044b4:	0c 9b       	mov	r11,r6
800044b6:	fe 7c 2c 00 	mov	r12,-54272
800044ba:	f0 1f 00 3d 	mcall	800045ac <main+0x1f4>
	
	/* TWA */
	tpa6130_init();
800044be:	f0 1f 00 3d 	mcall	800045b0 <main+0x1f8>
	
	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,
800044c2:	e0 68 76 00 	mov	r8,30208
800044c6:	ea 18 03 b3 	orh	r8,0x3b3
800044ca:	1a d8       	st.w	--sp,r8
800044cc:	30 38       	mov	r8,3
800044ce:	1a d8       	st.w	--sp,r8
800044d0:	4b 98       	lddpc	r8,800045b4 <main+0x1fc>
800044d2:	0e 99       	mov	r9,r7
800044d4:	0a 9a       	mov	r10,r5
800044d6:	30 2b       	mov	r11,2
800044d8:	e0 6c 2b 11 	mov	r12,11025
800044dc:	f0 1f 00 37 	mcall	800045b8 <main+0x200>
						master_callback,
						AUDIO_DAC_OUT_OF_SAMPLE_CB
						| AUDIO_DAC_RELOAD_CB,
						FPBA_HZ); /**/

	tpa6130_set_volume(0x20); // 2F
800044e0:	32 0c       	mov	r12,32
800044e2:	f0 1f 00 37 	mcall	800045bc <main+0x204>
	tpa6130_get_volume();
800044e6:	f0 1f 00 37 	mcall	800045c0 <main+0x208>
}

static void init_qt_interrupt(void)
{
	/* INTC */
	Disable_global_interrupt();
800044ea:	d3 03       	ssrf	0x10
	//INTC_init_interrupts();
	// QT
	INTC_register_interrupt(&RT_ISR_gpio_qt_70, 70, AVR32_INTC_INT0);
800044ec:	0e 9a       	mov	r10,r7
800044ee:	34 6b       	mov	r11,70
800044f0:	4b 5c       	lddpc	r12,800045c4 <main+0x20c>
800044f2:	f0 1f 00 36 	mcall	800045c8 <main+0x210>
	INTC_register_interrupt(&RT_ISR_gpio_qt_71, 71, AVR32_INTC_INT0);
800044f6:	0e 9a       	mov	r10,r7
800044f8:	34 7b       	mov	r11,71
800044fa:	4b 5c       	lddpc	r12,800045cc <main+0x214>
800044fc:	f0 1f 00 33 	mcall	800045c8 <main+0x210>
	Enable_global_interrupt();
80004500:	d5 03       	csrf	0x10
		
	/* GPIO */
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_UP,    GPIO_RISING_EDGE);
80004502:	30 1b       	mov	r11,1
80004504:	33 6c       	mov	r12,54
80004506:	f0 1f 00 33 	mcall	800045d0 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_DOWN,  GPIO_RISING_EDGE);
8000450a:	30 1b       	mov	r11,1
8000450c:	33 7c       	mov	r12,55
8000450e:	f0 1f 00 31 	mcall	800045d0 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_LEFT,  GPIO_RISING_EDGE);
80004512:	30 1b       	mov	r11,1
80004514:	33 9c       	mov	r12,57
80004516:	f0 1f 00 2f 	mcall	800045d0 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_RIGHT, GPIO_RISING_EDGE);
8000451a:	30 1b       	mov	r11,1
8000451c:	33 8c       	mov	r12,56
8000451e:	f0 1f 00 2d 	mcall	800045d0 <main+0x218>
	gpio_enable_pin_interrupt(QT1081_TOUCH_SENSOR_ENTER, GPIO_RISING_EDGE);
80004522:	30 1b       	mov	r11,1
80004524:	33 ac       	mov	r12,58
80004526:	f0 1f 00 2b 	mcall	800045d0 <main+0x218>
		
	memset(&INTC_QT_FLAG, 0, sizeof(INTC_QT_FLAG));
8000452a:	4a b8       	lddpc	r8,800045d4 <main+0x21c>
8000452c:	b0 87       	st.b	r8[0x0],r7
	init_twi_tpa();
	
	init_qt_interrupt();
	
	// Enable LED0 and LED1
	gpio_enable_gpio_pin(LED0_GPIO);
8000452e:	33 bc       	mov	r12,59
80004530:	f0 1f 00 2a 	mcall	800045d8 <main+0x220>
	gpio_enable_gpio_pin(LED1_GPIO);
80004534:	33 cc       	mov	r12,60
80004536:	f0 1f 00 29 	mcall	800045d8 <main+0x220>
	
	print_dbg(MSG_WELCOME);
8000453a:	4a 9c       	lddpc	r12,800045dc <main+0x224>
8000453c:	f0 1f 00 29 	mcall	800045e0 <main+0x228>
	
	/* Insert application code here, after the board has been initialized. */
	
	//uint16_t pass = 25;
	//xTaskCreate(myTask1, "taks1", 256, (void *)pass, mainLED_TASK_PRIORITY, &myTask1Handle);
	xTaskCreate(qtButtonTask,  "tQT",        256, (void *) 0, mainCOM_TEST_PRIORITY, &qtHandle);
80004540:	4a 98       	lddpc	r8,800045e4 <main+0x22c>
80004542:	1a d8       	st.w	--sp,r8
80004544:	30 28       	mov	r8,2
80004546:	0e 99       	mov	r9,r7
80004548:	e0 6a 01 00 	mov	r10,256
8000454c:	4a 7b       	lddpc	r11,800045e8 <main+0x230>
8000454e:	4a 8c       	lddpc	r12,800045ec <main+0x234>
80004550:	f0 1f 00 28 	mcall	800045f0 <main+0x238>
	xTaskCreate(playAudioTask, "tPlayAudio", 2048, (void *) 0, mainLED_TASK_PRIORITY, &audioHandle);
80004554:	4a 88       	lddpc	r8,800045f4 <main+0x23c>
80004556:	1a d8       	st.w	--sp,r8
80004558:	30 18       	mov	r8,1
8000455a:	0e 99       	mov	r9,r7
8000455c:	e0 6a 08 00 	mov	r10,2048
80004560:	4a 6b       	lddpc	r11,800045f8 <main+0x240>
80004562:	4a 7c       	lddpc	r12,800045fc <main+0x244>
80004564:	f0 1f 00 23 	mcall	800045f0 <main+0x238>
	
	vTaskStartScheduler();
80004568:	2f 8d       	sub	sp,-32
8000456a:	f0 1f 00 26 	mcall	80004600 <main+0x248>
8000456e:	c0 08       	rjmp	8000456e <main+0x1b6>
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	2c fc       	sub	r12,-49
80004574:	80 00       	ld.sh	r0,r0[0x0]
80004576:	2b d8       	sub	r8,-67
80004578:	80 00       	ld.sh	r0,r0[0x0]
8000457a:	2c 30       	sub	r0,-61
8000457c:	80 00       	ld.sh	r0,r0[0x0]
8000457e:	2c 92       	sub	r2,-55
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	2c b4       	sub	r4,-53
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	2c ce       	sub	lr,-52
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	2c dc       	sub	r12,-51
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	2c 4c       	sub	r12,-60
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	2b 40       	sub	r0,-76
80004594:	80 00       	ld.sh	r0,r0[0x0]
80004596:	2c f0       	sub	r0,-49
80004598:	80 00       	ld.sh	r0,r0[0x0]
8000459a:	2c e6       	sub	r6,-50
8000459c:	80 00       	ld.sh	r0,r0[0x0]
8000459e:	2b 2c       	sub	r12,-78
800045a0:	80 03       	ld.sh	r3,r0[0x0]
800045a2:	5d 44       	*unknown*
800045a4:	80 03       	ld.sh	r3,r0[0x0]
800045a6:	5d a0       	*unknown*
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	41 48       	lddsp	r8,sp[0x50]
800045ac:	80 00       	ld.sh	r0,r0[0x0]
800045ae:	2a 28       	sub	r8,-94
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	22 28       	sub	r8,34
800045b4:	80 00       	ld.sh	r0,r0[0x0]
800045b6:	43 b4       	lddsp	r4,sp[0xec]
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	23 10       	sub	r0,49
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	20 b4       	sub	r4,11
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	21 90       	sub	r0,25
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	47 48       	lddsp	r8,sp[0x1d0]
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	42 68       	lddsp	r8,sp[0x98]
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	46 78       	lddsp	r8,sp[0x19c]
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	41 f0       	lddsp	r0,sp[0x7c]
800045d4:	00 00       	add	r0,r0
800045d6:	07 cc       	ld.ub	r12,r3[0x4]
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	41 78       	lddsp	r8,sp[0x5c]
800045dc:	80 03       	ld.sh	r3,r0[0x0]
800045de:	5d 54       	*unknown*
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	2a d8       	sub	r8,-83
800045e4:	00 00       	add	r0,r0
800045e6:	07 80       	ld.ub	r0,r3[0x0]
800045e8:	80 03       	ld.sh	r3,r0[0x0]
800045ea:	5d 90       	*unknown*
800045ec:	80 00       	ld.sh	r0,r0[0x0]
800045ee:	47 c0       	lddsp	r0,sp[0x1f0]
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	3e b0       	mov	r0,-21
800045f4:	00 00       	add	r0,r0
800045f6:	07 84       	ld.ub	r4,r3[0x0]
800045f8:	80 03       	ld.sh	r3,r0[0x0]
800045fa:	5d 94       	*unknown*
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	48 d0       	lddpc	r0,80004630 <RT_ISR_gpio_qt_71_not_naked+0x2c>
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	40 9c       	lddsp	r12,sp[0x24]

80004604 <RT_ISR_gpio_qt_71_not_naked>:
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
{
80004604:	d4 01       	pushm	lr
	// ENTER, LEFT, RIGHT
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER))
80004606:	33 ac       	mov	r12,58
80004608:	f0 1f 00 17 	mcall	80004664 <RT_ISR_gpio_qt_71_not_naked+0x60>
8000460c:	c0 b0       	breq	80004622 <RT_ISR_gpio_qt_71_not_naked+0x1e>
	{
		INTC_QT_FLAG._enter = true;
8000460e:	49 78       	lddpc	r8,80004668 <RT_ISR_gpio_qt_71_not_naked+0x64>
80004610:	11 89       	ld.ub	r9,r8[0x0]
80004612:	30 1a       	mov	r10,1
80004614:	f3 da d0 e1 	bfins	r9,r10,0x7,0x1
80004618:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_ENTER);
8000461a:	33 ac       	mov	r12,58
8000461c:	f0 1f 00 14 	mcall	8000466c <RT_ISR_gpio_qt_71_not_naked+0x68>
80004620:	c1 c8       	rjmp	80004658 <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT))
80004622:	33 9c       	mov	r12,57
80004624:	f0 1f 00 10 	mcall	80004664 <RT_ISR_gpio_qt_71_not_naked+0x60>
80004628:	c0 b0       	breq	8000463e <RT_ISR_gpio_qt_71_not_naked+0x3a>
	{
		INTC_QT_FLAG._left = true;
8000462a:	49 08       	lddpc	r8,80004668 <RT_ISR_gpio_qt_71_not_naked+0x64>
8000462c:	11 89       	ld.ub	r9,r8[0x0]
8000462e:	30 1a       	mov	r10,1
80004630:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
80004634:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_LEFT);
80004636:	33 9c       	mov	r12,57
80004638:	f0 1f 00 0d 	mcall	8000466c <RT_ISR_gpio_qt_71_not_naked+0x68>
8000463c:	c0 e8       	rjmp	80004658 <RT_ISR_gpio_qt_71_not_naked+0x54>
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT))
8000463e:	33 8c       	mov	r12,56
80004640:	f0 1f 00 09 	mcall	80004664 <RT_ISR_gpio_qt_71_not_naked+0x60>
80004644:	c0 a0       	breq	80004658 <RT_ISR_gpio_qt_71_not_naked+0x54>
	{
		INTC_QT_FLAG._right = true;
80004646:	48 98       	lddpc	r8,80004668 <RT_ISR_gpio_qt_71_not_naked+0x64>
80004648:	11 89       	ld.ub	r9,r8[0x0]
8000464a:	30 1a       	mov	r10,1
8000464c:	f3 da d0 a1 	bfins	r9,r10,0x5,0x1
80004650:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_RIGHT);
80004652:	33 8c       	mov	r12,56
80004654:	f0 1f 00 06 	mcall	8000466c <RT_ISR_gpio_qt_71_not_naked+0x68>
	}
	
	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
80004658:	48 68       	lddpc	r8,80004670 <RT_ISR_gpio_qt_71_not_naked+0x6c>
8000465a:	70 0c       	ld.w	r12,r8[0x0]
8000465c:	f0 1f 00 06 	mcall	80004674 <RT_ISR_gpio_qt_71_not_naked+0x70>
	return (checkIfYieldRequired ? 1 : 0);
	
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80004660:	5f 1c       	srne	r12
80004662:	d8 02       	popm	pc
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	42 36       	lddsp	r6,sp[0x8c]
80004668:	00 00       	add	r0,r0
8000466a:	07 cc       	ld.ub	r12,r3[0x4]
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	42 4e       	lddsp	lr,sp[0x90]
80004670:	00 00       	add	r0,r0
80004672:	07 80       	ld.ub	r0,r3[0x0]
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	3b 9c       	mov	r12,-71

80004678 <RT_ISR_gpio_qt_71>:
	
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}

ISR_FREERTOS(RT_ISR_gpio_qt_71, 70, 0)
80004678:	eb cd 00 ff 	pushm	r0-r7
8000467c:	e0 68 00 0c 	mov	r8,12
80004680:	ea 18 00 00 	orh	r8,0x0
80004684:	70 00       	ld.w	r0,r8[0x0]
80004686:	1a d0       	st.w	--sp,r0
80004688:	7a 90       	ld.w	r0,sp[0x24]
8000468a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000468e:	58 10       	cp.w	r0,1
80004690:	e0 8b 00 08 	brhi	800046a0 <LABEL_ISR_SKIP_SAVE_CONTEXT_406>
80004694:	e0 68 05 fc 	mov	r8,1532
80004698:	ea 18 00 00 	orh	r8,0x0
8000469c:	70 00       	ld.w	r0,r8[0x0]
8000469e:	81 0d       	st.w	r0[0x0],sp

800046a0 <LABEL_ISR_SKIP_SAVE_CONTEXT_406>:
800046a0:	f0 1f 00 10 	mcall	800046e0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_406+0x14>
800046a4:	7a 90       	ld.w	r0,sp[0x24]
800046a6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800046aa:	58 10       	cp.w	r0,1
800046ac:	e0 8b 00 10 	brhi	800046cc <LABEL_ISR_SKIP_RESTORE_CONTEXT_406>
800046b0:	58 1c       	cp.w	r12,1
800046b2:	c0 71       	brne	800046c0 <LABEL_ISR_RESTORE_CONTEXT_406>
800046b4:	f0 1f 00 0c 	mcall	800046e4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_406+0x18>
800046b8:	f0 1f 00 0c 	mcall	800046e8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_406+0x1c>
800046bc:	f0 1f 00 0c 	mcall	800046ec <LABEL_ISR_SKIP_RESTORE_CONTEXT_406+0x20>

800046c0 <LABEL_ISR_RESTORE_CONTEXT_406>:
800046c0:	e0 68 05 fc 	mov	r8,1532
800046c4:	ea 18 00 00 	orh	r8,0x0
800046c8:	70 00       	ld.w	r0,r8[0x0]
800046ca:	60 0d       	ld.w	sp,r0[0x0]

800046cc <LABEL_ISR_SKIP_RESTORE_CONTEXT_406>:
800046cc:	1b 00       	ld.w	r0,sp++
800046ce:	e0 68 00 0c 	mov	r8,12
800046d2:	ea 18 00 00 	orh	r8,0x0
800046d6:	91 00       	st.w	r8[0x0],r0
800046d8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800046dc:	d6 03       	rete
800046de:	00 00       	add	r0,r0
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	46 04       	lddsp	r4,sp[0x180]
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	2f fc       	sub	r12,-1
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	36 a4       	mov	r4,106
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	31 08       	mov	r8,16

800046f0 <RT_ISR_gpio_qt_70_not_naked>:
	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
{
800046f0:	d4 01       	pushm	lr
	// UP, DOWN
	if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP))
800046f2:	33 6c       	mov	r12,54
800046f4:	f0 1f 00 10 	mcall	80004734 <RT_ISR_gpio_qt_70_not_naked+0x44>
800046f8:	c0 b0       	breq	8000470e <RT_ISR_gpio_qt_70_not_naked+0x1e>
	{
		INTC_QT_FLAG._up = true;
800046fa:	49 08       	lddpc	r8,80004738 <RT_ISR_gpio_qt_70_not_naked+0x48>
800046fc:	11 89       	ld.ub	r9,r8[0x0]
800046fe:	30 1a       	mov	r10,1
80004700:	f3 da d0 81 	bfins	r9,r10,0x4,0x1
80004704:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_UP);
80004706:	33 6c       	mov	r12,54
80004708:	f0 1f 00 0d 	mcall	8000473c <RT_ISR_gpio_qt_70_not_naked+0x4c>
8000470c:	c0 e8       	rjmp	80004728 <RT_ISR_gpio_qt_70_not_naked+0x38>
		
	} else if (gpio_get_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN))
8000470e:	33 7c       	mov	r12,55
80004710:	f0 1f 00 09 	mcall	80004734 <RT_ISR_gpio_qt_70_not_naked+0x44>
80004714:	c0 a0       	breq	80004728 <RT_ISR_gpio_qt_70_not_naked+0x38>
	{
		INTC_QT_FLAG._down = true;
80004716:	48 98       	lddpc	r8,80004738 <RT_ISR_gpio_qt_70_not_naked+0x48>
80004718:	11 89       	ld.ub	r9,r8[0x0]
8000471a:	30 1a       	mov	r10,1
8000471c:	f3 da d0 61 	bfins	r9,r10,0x3,0x1
80004720:	b0 89       	st.b	r8[0x0],r9
		gpio_clear_pin_interrupt_flag(QT1081_TOUCH_SENSOR_DOWN);
80004722:	33 7c       	mov	r12,55
80004724:	f0 1f 00 06 	mcall	8000473c <RT_ISR_gpio_qt_70_not_naked+0x4c>
	}
	
	BaseType_t checkIfYieldRequired = xTaskResumeFromISR(qtHandle);
80004728:	48 68       	lddpc	r8,80004740 <RT_ISR_gpio_qt_70_not_naked+0x50>
8000472a:	70 0c       	ld.w	r12,r8[0x0]
8000472c:	f0 1f 00 06 	mcall	80004744 <RT_ISR_gpio_qt_70_not_naked+0x54>
	return (checkIfYieldRequired ? 1 : 0);
	
	//vTaskNotifyGiveFromISR(playAudioHandle, 0);
	//return 1;
}
80004730:	5f 1c       	srne	r12
80004732:	d8 02       	popm	pc
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	42 36       	lddsp	r6,sp[0x8c]
80004738:	00 00       	add	r0,r0
8000473a:	07 cc       	ld.ub	r12,r3[0x4]
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	42 4e       	lddsp	lr,sp[0x90]
80004740:	00 00       	add	r0,r0
80004742:	07 80       	ld.ub	r0,r3[0x0]
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	3b 9c       	mov	r12,-71

80004748 <RT_ISR_gpio_qt_70>:

	}
}

// ISR
ISR_FREERTOS(RT_ISR_gpio_qt_70, 70, 0)
80004748:	eb cd 00 ff 	pushm	r0-r7
8000474c:	e0 68 00 0c 	mov	r8,12
80004750:	ea 18 00 00 	orh	r8,0x0
80004754:	70 00       	ld.w	r0,r8[0x0]
80004756:	1a d0       	st.w	--sp,r0
80004758:	7a 90       	ld.w	r0,sp[0x24]
8000475a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000475e:	58 10       	cp.w	r0,1
80004760:	e0 8b 00 08 	brhi	80004770 <LABEL_ISR_SKIP_SAVE_CONTEXT_385>
80004764:	e0 68 05 fc 	mov	r8,1532
80004768:	ea 18 00 00 	orh	r8,0x0
8000476c:	70 00       	ld.w	r0,r8[0x0]
8000476e:	81 0d       	st.w	r0[0x0],sp

80004770 <LABEL_ISR_SKIP_SAVE_CONTEXT_385>:
80004770:	f0 1f 00 10 	mcall	800047b0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_385+0x14>
80004774:	7a 90       	ld.w	r0,sp[0x24]
80004776:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000477a:	58 10       	cp.w	r0,1
8000477c:	e0 8b 00 10 	brhi	8000479c <LABEL_ISR_SKIP_RESTORE_CONTEXT_385>
80004780:	58 1c       	cp.w	r12,1
80004782:	c0 71       	brne	80004790 <LABEL_ISR_RESTORE_CONTEXT_385>
80004784:	f0 1f 00 0c 	mcall	800047b4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_385+0x18>
80004788:	f0 1f 00 0c 	mcall	800047b8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_385+0x1c>
8000478c:	f0 1f 00 0c 	mcall	800047bc <LABEL_ISR_SKIP_RESTORE_CONTEXT_385+0x20>

80004790 <LABEL_ISR_RESTORE_CONTEXT_385>:
80004790:	e0 68 05 fc 	mov	r8,1532
80004794:	ea 18 00 00 	orh	r8,0x0
80004798:	70 00       	ld.w	r0,r8[0x0]
8000479a:	60 0d       	ld.w	sp,r0[0x0]

8000479c <LABEL_ISR_SKIP_RESTORE_CONTEXT_385>:
8000479c:	1b 00       	ld.w	r0,sp++
8000479e:	e0 68 00 0c 	mov	r8,12
800047a2:	ea 18 00 00 	orh	r8,0x0
800047a6:	91 00       	st.w	r8[0x0],r0
800047a8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800047ac:	d6 03       	rete
800047ae:	00 00       	add	r0,r0
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	46 f0       	lddsp	r0,sp[0x1bc]
800047b4:	80 00       	ld.sh	r0,r0[0x0]
800047b6:	2f fc       	sub	r12,-1
800047b8:	80 00       	ld.sh	r0,r0[0x0]
800047ba:	36 a4       	mov	r4,106
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	31 08       	mov	r8,16

800047c0 <qtButtonTask>:
}

// qtHandle
portTASK_FUNCTION_PROTO( qtButtonTask, p );
portTASK_FUNCTION( qtButtonTask, p )
{
800047c0:	d4 31       	pushm	r0-r7,lr
	gpio_set_gpio_pin(LED0_GPIO);
800047c2:	33 bc       	mov	r12,59
800047c4:	f0 1f 00 39 	mcall	800048a8 <qtButtonTask+0xe8>
	gpio_set_gpio_pin(LED1_GPIO);
800047c8:	33 cc       	mov	r12,60
800047ca:	f0 1f 00 38 	mcall	800048a8 <qtButtonTask+0xe8>
	gpio_set_gpio_pin(LED2_GPIO);
800047ce:	30 5c       	mov	r12,5
800047d0:	f0 1f 00 36 	mcall	800048a8 <qtButtonTask+0xe8>
	gpio_set_gpio_pin(LED3_GPIO);
800047d4:	30 6c       	mov	r12,6
800047d6:	f0 1f 00 35 	mcall	800048a8 <qtButtonTask+0xe8>
	
	static uint16_t samplesToMove;
	forwardQueue = xQueueCreate( 1 , sizeof(uint16_t));
800047da:	30 0a       	mov	r10,0
800047dc:	30 2b       	mov	r11,2
800047de:	30 1c       	mov	r12,1
800047e0:	f0 1f 00 33 	mcall	800048ac <qtButtonTask+0xec>
800047e4:	4b 38       	lddpc	r8,800048b0 <qtButtonTask+0xf0>
800047e6:	91 0c       	st.w	r8[0x0],r12
	reverseQueue = xQueueCreate( 1 , sizeof(uint16_t));
800047e8:	30 0a       	mov	r10,0
800047ea:	30 2b       	mov	r11,2
800047ec:	30 1c       	mov	r12,1
800047ee:	f0 1f 00 30 	mcall	800048ac <qtButtonTask+0xec>
800047f2:	4b 18       	lddpc	r8,800048b4 <qtButtonTask+0xf4>
800047f4:	91 0c       	st.w	r8[0x0],r12
	
	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
800047f6:	30 07       	mov	r7,0
		if (INTC_QT_FLAG._left) {
800047f8:	4b 05       	lddpc	r5,800048b8 <qtButtonTask+0xf8>
800047fa:	30 06       	mov	r6,0
			INTC_QT_FLAG._left = false;
			//gpio_tgl_gpio_pin(LED0_GPIO);
			samplesToMove = 4096;
800047fc:	4b 04       	lddpc	r4,800048bc <qtButtonTask+0xfc>
800047fe:	e0 63 10 00 	mov	r3,4096
			xQueueSend( reverseQueue, &samplesToMove, (TickType_t) 0 );
80004802:	10 92       	mov	r2,r8
			INTC_QT_FLAG._down = false;
			//gpio_tgl_gpio_pin(LED3_GPIO);
		}
		else if (INTC_QT_FLAG._enter) {
			INTC_QT_FLAG._enter = false;
			xTaskNotifyGive(audioHandle);
80004804:	4a f0       	lddpc	r0,800048c0 <qtButtonTask+0x100>
		}
		else if (INTC_QT_FLAG._right) {
			INTC_QT_FLAG._right = false;
			//gpio_tgl_gpio_pin(LED1_GPIO);
			samplesToMove = 4096;
			xQueueSend( forwardQueue, &samplesToMove, (TickType_t) 0 );
80004806:	4a b1       	lddpc	r1,800048b0 <qtButtonTask+0xf0>
	forwardQueue = xQueueCreate( 1 , sizeof(uint16_t));
	reverseQueue = xQueueCreate( 1 , sizeof(uint16_t));
	
	while (1)
	{
		vTaskSuspend(NULL); // Suspend itself at start, remain there and wait for an external event to resume it.
80004808:	0e 9c       	mov	r12,r7
8000480a:	f0 1f 00 2f 	mcall	800048c4 <qtButtonTask+0x104>
		if (INTC_QT_FLAG._left) {
8000480e:	0b 88       	ld.ub	r8,r5[0x0]
80004810:	10 99       	mov	r9,r8
80004812:	e2 19 00 40 	andl	r9,0x40,COH
80004816:	ec 09 18 00 	cp.b	r9,r6
8000481a:	c0 d0       	breq	80004834 <qtButtonTask+0x74>
			INTC_QT_FLAG._left = false;
8000481c:	0b 88       	ld.ub	r8,r5[0x0]
8000481e:	f1 d7 d0 c1 	bfins	r8,r7,0x6,0x1
80004822:	aa 88       	st.b	r5[0x0],r8
			//gpio_tgl_gpio_pin(LED0_GPIO);
			samplesToMove = 4096;
80004824:	a8 03       	st.h	r4[0x0],r3
			xQueueSend( reverseQueue, &samplesToMove, (TickType_t) 0 );
80004826:	0e 99       	mov	r9,r7
80004828:	0e 9a       	mov	r10,r7
8000482a:	08 9b       	mov	r11,r4
8000482c:	64 0c       	ld.w	r12,r2[0x0]
8000482e:	f0 1f 00 27 	mcall	800048c8 <qtButtonTask+0x108>
80004832:	ce bb       	rjmp	80004808 <qtButtonTask+0x48>
		}
		else if (INTC_QT_FLAG._right) {
80004834:	10 99       	mov	r9,r8
80004836:	e2 19 00 20 	andl	r9,0x20,COH
8000483a:	ec 09 18 00 	cp.b	r9,r6
8000483e:	c0 d0       	breq	80004858 <qtButtonTask+0x98>
			INTC_QT_FLAG._right = false;
80004840:	0b 88       	ld.ub	r8,r5[0x0]
80004842:	f1 d7 d0 a1 	bfins	r8,r7,0x5,0x1
80004846:	aa 88       	st.b	r5[0x0],r8
			//gpio_tgl_gpio_pin(LED1_GPIO);
			samplesToMove = 4096;
80004848:	a8 03       	st.h	r4[0x0],r3
			xQueueSend( forwardQueue, &samplesToMove, (TickType_t) 0 );
8000484a:	0e 99       	mov	r9,r7
8000484c:	0e 9a       	mov	r10,r7
8000484e:	08 9b       	mov	r11,r4
80004850:	62 0c       	ld.w	r12,r1[0x0]
80004852:	f0 1f 00 1e 	mcall	800048c8 <qtButtonTask+0x108>
80004856:	cd 9b       	rjmp	80004808 <qtButtonTask+0x48>
		}
		else if (INTC_QT_FLAG._up) {
80004858:	10 99       	mov	r9,r8
8000485a:	e2 19 00 10 	andl	r9,0x10,COH
8000485e:	ec 09 18 00 	cp.b	r9,r6
80004862:	c0 60       	breq	8000486e <qtButtonTask+0xae>
			INTC_QT_FLAG._up = false;
80004864:	0b 88       	ld.ub	r8,r5[0x0]
80004866:	f1 d7 d0 81 	bfins	r8,r7,0x4,0x1
8000486a:	aa 88       	st.b	r5[0x0],r8
8000486c:	cc eb       	rjmp	80004808 <qtButtonTask+0x48>
			//gpio_tgl_gpio_pin(LED2_GPIO);
		}
		else if (INTC_QT_FLAG._down) {
8000486e:	10 99       	mov	r9,r8
80004870:	e2 19 00 08 	andl	r9,0x8,COH
80004874:	ec 09 18 00 	cp.b	r9,r6
80004878:	c0 60       	breq	80004884 <qtButtonTask+0xc4>
			INTC_QT_FLAG._down = false;
8000487a:	0b 88       	ld.ub	r8,r5[0x0]
8000487c:	f1 d7 d0 61 	bfins	r8,r7,0x3,0x1
80004880:	aa 88       	st.b	r5[0x0],r8
80004882:	cc 3b       	rjmp	80004808 <qtButtonTask+0x48>
			//gpio_tgl_gpio_pin(LED3_GPIO);
		}
		else if (INTC_QT_FLAG._enter) {
80004884:	e0 18 ff 80 	andl	r8,0xff80
80004888:	ec 08 18 00 	cp.b	r8,r6
8000488c:	cb e0       	breq	80004808 <qtButtonTask+0x48>
			INTC_QT_FLAG._enter = false;
8000488e:	0b 88       	ld.ub	r8,r5[0x0]
80004890:	f1 d7 d0 e1 	bfins	r8,r7,0x7,0x1
80004894:	aa 88       	st.b	r5[0x0],r8
			xTaskNotifyGive(audioHandle);
80004896:	0e 98       	mov	r8,r7
80004898:	30 29       	mov	r9,2
8000489a:	0e 9a       	mov	r10,r7
8000489c:	0e 9b       	mov	r11,r7
8000489e:	60 0c       	ld.w	r12,r0[0x0]
800048a0:	f0 1f 00 0b 	mcall	800048cc <qtButtonTask+0x10c>
800048a4:	cb 2b       	rjmp	80004808 <qtButtonTask+0x48>
800048a6:	00 00       	add	r0,r0
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	41 b8       	lddsp	r8,sp[0x6c]
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	36 34       	mov	r4,99
800048b0:	00 00       	add	r0,r0
800048b2:	07 d4       	ld.ub	r4,r3[0x5]
800048b4:	00 00       	add	r0,r0
800048b6:	07 c8       	ld.ub	r8,r3[0x4]
800048b8:	00 00       	add	r0,r0
800048ba:	07 cc       	ld.ub	r12,r3[0x4]
800048bc:	00 00       	add	r0,r0
800048be:	07 7c       	ld.ub	r12,--r3
800048c0:	00 00       	add	r0,r0
800048c2:	07 84       	ld.ub	r4,r3[0x0]
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	3c 1c       	mov	r12,-63
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	34 a0       	mov	r0,74
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	37 d0       	mov	r0,125

800048d0 <playAudioTask>:
}

// audioHandle
portTASK_FUNCTION_PROTO(playAudioTask, p );
portTASK_FUNCTION(playAudioTask, p )
{
800048d0:	d4 31       	pushm	r0-r7,lr
	static bool notify	  = false;
	static uint16_t samplesRx;

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
800048d2:	30 12       	mov	r2,1
800048d4:	30 03       	mov	r3,0
800048d6:	4b 11       	lddpc	r1,80004998 <playAudioTask+0xc8>
		
		if (notificationValue > 0)
		{
			//playAudio = !playAudio;
			notify = !notify;
800048d8:	4b 16       	lddpc	r6,8000499c <playAudioTask+0xcc>
			//}
		}
		
		if (playAudio)
		{
			playAudio = false;
800048da:	4b 25       	lddpc	r5,800049a0 <playAudioTask+0xd0>
800048dc:	30 04       	mov	r4,0
800048de:	4b 20       	lddpc	r0,800049a4 <playAudioTask+0xd4>
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
800048e0:	4b 27       	lddpc	r7,800049a8 <playAudioTask+0xd8>
	static bool notify	  = false;
	static uint16_t samplesRx;

	while(true)
	{
		notificationValue = ulTaskNotifyTake( pdTRUE, (TickType_t) 1 );
800048e2:	04 9a       	mov	r10,r2
800048e4:	04 9b       	mov	r11,r2
800048e6:	06 9c       	mov	r12,r3
800048e8:	f0 1f 00 31 	mcall	800049ac <playAudioTask+0xdc>
800048ec:	83 0c       	st.w	r1[0x0],r12
		
		if (notificationValue > 0)
800048ee:	e0 8a 00 06 	brle	800048fa <playAudioTask+0x2a>
		{
			//playAudio = !playAudio;
			notify = !notify;
800048f2:	0d 88       	ld.ub	r8,r6[0x0]
800048f4:	ec 18 00 01 	eorl	r8,0x1
800048f8:	ac 88       	st.b	r6[0x0],r8
			//print_dbg("Notification received.");

		}

		if ((pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE) && (notify == true))
800048fa:	06 9c       	mov	r12,r3
800048fc:	f0 1f 00 2d 	mcall	800049b0 <playAudioTask+0xe0>
80004900:	e2 1c 00 02 	andl	r12,0x2,COH
80004904:	c1 90       	breq	80004936 <playAudioTask+0x66>
80004906:	0d 88       	ld.ub	r8,r6[0x0]
80004908:	e8 08 18 00 	cp.b	r8,r4
8000490c:	c1 50       	breq	80004936 <playAudioTask+0x66>
		{
			playAudio = true;
8000490e:	30 18       	mov	r8,1
80004910:	aa 88       	st.b	r5[0x0],r8
			//print_dbg("Running audio...\r\n");
					
			if (forwardQueue != 0)
80004912:	4a 98       	lddpc	r8,800049b4 <playAudioTask+0xe4>
80004914:	70 0c       	ld.w	r12,r8[0x0]
80004916:	58 0c       	cp.w	r12,0
80004918:	c1 30       	breq	8000493e <playAudioTask+0x6e>
			{
				if (xQueueReceive( forwardQueue, &samplesRx, (TickType_t) 2 ))
8000491a:	30 2a       	mov	r10,2
8000491c:	4a 7b       	lddpc	r11,800049b8 <playAudioTask+0xe8>
8000491e:	f0 1f 00 28 	mcall	800049bc <playAudioTask+0xec>
80004922:	c0 a0       	breq	80004936 <playAudioTask+0x66>
				{
					i = ( (i + samplesRx) <= sizeof(sound_table) ) ? (i + samplesRx) : i;
80004924:	60 09       	ld.w	r9,r0[0x0]
80004926:	4a 58       	lddpc	r8,800049b8 <playAudioTask+0xe8>
80004928:	90 88       	ld.uh	r8,r8[0x0]
8000492a:	12 08       	add	r8,r9
8000492c:	e2 58 08 55 	cp.w	r8,198741
80004930:	f2 08 17 20 	movhs	r8,r9
80004934:	81 08       	st.w	r0[0x0],r8
					//i = (i > samplesRx) ? (i - samplesRx) : i;
				//}
			//}
		}
		
		if (playAudio)
80004936:	0b 88       	ld.ub	r8,r5[0x0]
80004938:	e8 08 18 00 	cp.b	r8,r4
8000493c:	cd 30       	breq	800048e2 <playAudioTask+0x12>
		{
			playAudio = false;
8000493e:	aa 84       	st.b	r5[0x0],r4
80004940:	60 08       	ld.w	r8,r0[0x0]
80004942:	4a 09       	lddpc	r9,800049c0 <playAudioTask+0xf0>
80004944:	30 2a       	mov	r10,2
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
80004946:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8000494a:	28 0b       	sub	r11,-128
8000494c:	a9 6b       	lsl	r11,0x8
8000494e:	b2 0b       	st.h	r9[0x0],r11
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
80004950:	b2 1b       	st.h	r9[0x2],r11
				i++;
80004952:	2f f8       	sub	r8,-1
				if (i >= sizeof(sound_table)) i = 0;
80004954:	e2 58 08 54 	cp.w	r8,198740
80004958:	f9 b8 02 00 	movhs	r8,0
8000495c:	f4 cb ff fe 	sub	r11,r10,-2
80004960:	2f c9       	sub	r9,-4
		if (playAudio)
		{
			playAudio = false;
			count = 0;
			// Store sample from the sound_table array
			while(count < (SOUND_SAMPLES)){
80004962:	e0 4a 00 ff 	cp.w	r10,255
80004966:	e0 8b 00 04 	brhi	8000496e <playAudioTask+0x9e>
8000496a:	16 9a       	mov	r10,r11
8000496c:	ce db       	rjmp	80004946 <playAudioTask+0x76>
8000496e:	81 08       	st.w	r0[0x0],r8
80004970:	49 58       	lddpc	r8,800049c4 <playAudioTask+0xf4>
80004972:	91 0a       	st.w	r8[0x0],r10
				samples[count++] = ((uint8_t)sound_table[i]+0x80) << 8;
				i++;
				if (i >= sizeof(sound_table)) i = 0;
			}
			
			gpio_set_gpio_pin(LED0_GPIO);
80004974:	33 bc       	mov	r12,59
80004976:	f0 1f 00 15 	mcall	800049c8 <playAudioTask+0xf8>
			gpio_clr_gpio_pin(LED1_GPIO);
8000497a:	33 cc       	mov	r12,60
8000497c:	f0 1f 00 14 	mcall	800049cc <playAudioTask+0xfc>

			// Play buffer
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
80004980:	e0 6b 00 80 	mov	r11,128
80004984:	48 fc       	lddpc	r12,800049c0 <playAudioTask+0xf0>
80004986:	f0 1f 00 13 	mcall	800049d0 <playAudioTask+0x100>

			gpio_clr_gpio_pin(LED0_GPIO);
8000498a:	33 bc       	mov	r12,59
8000498c:	f0 1f 00 10 	mcall	800049cc <playAudioTask+0xfc>
			gpio_set_gpio_pin(LED1_GPIO);
80004990:	33 cc       	mov	r12,60
80004992:	f0 1f 00 0e 	mcall	800049c8 <playAudioTask+0xf8>
80004996:	ca 6b       	rjmp	800048e2 <playAudioTask+0x12>
80004998:	00 00       	add	r0,r0
8000499a:	07 70       	ld.ub	r0,--r3
8000499c:	00 00       	add	r0,r0
8000499e:	07 8c       	ld.ub	r12,r3[0x0]
800049a0:	00 00       	add	r0,r0
800049a2:	07 74       	ld.ub	r4,--r3
800049a4:	00 00       	add	r0,r0
800049a6:	07 88       	ld.ub	r8,r3[0x0]
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	54 f0       	stdsp	sp[0x13c],r0
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	3d 6c       	mov	r12,-42
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	26 a0       	sub	r0,106
800049b4:	00 00       	add	r0,r0
800049b6:	07 d4       	ld.ub	r4,r3[0x5]
800049b8:	00 00       	add	r0,r0
800049ba:	07 6c       	ld.uh	r12,--r3
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	33 0c       	mov	r12,48
800049c0:	00 00       	add	r0,r0
800049c2:	07 d8       	ld.ub	r8,r3[0x5]
800049c4:	00 00       	add	r0,r0
800049c6:	07 78       	ld.ub	r8,--r3
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	41 b8       	lddsp	r8,sp[0x6c]
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	41 d4       	lddsp	r4,sp[0x74]
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	20 e4       	sub	r4,14

800049d4 <free>:
800049d4:	d4 01       	pushm	lr
800049d6:	e0 68 01 00 	mov	r8,256
800049da:	18 9b       	mov	r11,r12
800049dc:	70 0c       	ld.w	r12,r8[0x0]
800049de:	e0 a0 03 43 	rcall	80005064 <_free_r>
800049e2:	d8 02       	popm	pc

800049e4 <malloc>:
800049e4:	d4 01       	pushm	lr
800049e6:	e0 68 01 00 	mov	r8,256
800049ea:	18 9b       	mov	r11,r12
800049ec:	70 0c       	ld.w	r12,r8[0x0]
800049ee:	c0 3c       	rcall	800049f4 <_malloc_r>
800049f0:	d8 02       	popm	pc
800049f2:	d7 03       	nop

800049f4 <_malloc_r>:
800049f4:	d4 31       	pushm	r0-r7,lr
800049f6:	f6 c8 ff f5 	sub	r8,r11,-11
800049fa:	18 95       	mov	r5,r12
800049fc:	10 97       	mov	r7,r8
800049fe:	e0 17 ff f8 	andl	r7,0xfff8
80004a02:	59 68       	cp.w	r8,22
80004a04:	f9 b7 08 10 	movls	r7,16
80004a08:	16 37       	cp.w	r7,r11
80004a0a:	5f 38       	srlo	r8
80004a0c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004a10:	c0 50       	breq	80004a1a <_malloc_r+0x26>
80004a12:	30 c8       	mov	r8,12
80004a14:	99 38       	st.w	r12[0xc],r8
80004a16:	e0 8f 01 f7 	bral	80004e04 <_malloc_r+0x410>
80004a1a:	fe b0 f3 c9 	rcall	800031ac <__malloc_lock>
80004a1e:	e0 47 01 f7 	cp.w	r7,503
80004a22:	e0 8b 00 1d 	brhi	80004a5c <_malloc_r+0x68>
80004a26:	ee 03 16 03 	lsr	r3,r7,0x3
80004a2a:	e0 68 01 04 	mov	r8,260
80004a2e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004a32:	70 36       	ld.w	r6,r8[0xc]
80004a34:	10 36       	cp.w	r6,r8
80004a36:	c0 61       	brne	80004a42 <_malloc_r+0x4e>
80004a38:	ec c8 ff f8 	sub	r8,r6,-8
80004a3c:	70 36       	ld.w	r6,r8[0xc]
80004a3e:	10 36       	cp.w	r6,r8
80004a40:	c0 c0       	breq	80004a58 <_malloc_r+0x64>
80004a42:	6c 18       	ld.w	r8,r6[0x4]
80004a44:	e0 18 ff fc 	andl	r8,0xfffc
80004a48:	6c 3a       	ld.w	r10,r6[0xc]
80004a4a:	ec 08 00 09 	add	r9,r6,r8
80004a4e:	0a 9c       	mov	r12,r5
80004a50:	6c 28       	ld.w	r8,r6[0x8]
80004a52:	95 28       	st.w	r10[0x8],r8
80004a54:	91 3a       	st.w	r8[0xc],r10
80004a56:	c4 78       	rjmp	80004ae4 <_malloc_r+0xf0>
80004a58:	2f e3       	sub	r3,-2
80004a5a:	c4 d8       	rjmp	80004af4 <_malloc_r+0x100>
80004a5c:	ee 03 16 09 	lsr	r3,r7,0x9
80004a60:	c0 41       	brne	80004a68 <_malloc_r+0x74>
80004a62:	ee 03 16 03 	lsr	r3,r7,0x3
80004a66:	c2 68       	rjmp	80004ab2 <_malloc_r+0xbe>
80004a68:	58 43       	cp.w	r3,4
80004a6a:	e0 8b 00 06 	brhi	80004a76 <_malloc_r+0x82>
80004a6e:	ee 03 16 06 	lsr	r3,r7,0x6
80004a72:	2c 83       	sub	r3,-56
80004a74:	c1 f8       	rjmp	80004ab2 <_malloc_r+0xbe>
80004a76:	59 43       	cp.w	r3,20
80004a78:	e0 8b 00 04 	brhi	80004a80 <_malloc_r+0x8c>
80004a7c:	2a 53       	sub	r3,-91
80004a7e:	c1 a8       	rjmp	80004ab2 <_malloc_r+0xbe>
80004a80:	e0 43 00 54 	cp.w	r3,84
80004a84:	e0 8b 00 06 	brhi	80004a90 <_malloc_r+0x9c>
80004a88:	ee 03 16 0c 	lsr	r3,r7,0xc
80004a8c:	29 23       	sub	r3,-110
80004a8e:	c1 28       	rjmp	80004ab2 <_malloc_r+0xbe>
80004a90:	e0 43 01 54 	cp.w	r3,340
80004a94:	e0 8b 00 06 	brhi	80004aa0 <_malloc_r+0xac>
80004a98:	ee 03 16 0f 	lsr	r3,r7,0xf
80004a9c:	28 93       	sub	r3,-119
80004a9e:	c0 a8       	rjmp	80004ab2 <_malloc_r+0xbe>
80004aa0:	e0 43 05 54 	cp.w	r3,1364
80004aa4:	e0 88 00 04 	brls	80004aac <_malloc_r+0xb8>
80004aa8:	37 e3       	mov	r3,126
80004aaa:	c0 48       	rjmp	80004ab2 <_malloc_r+0xbe>
80004aac:	ee 03 16 12 	lsr	r3,r7,0x12
80004ab0:	28 43       	sub	r3,-124
80004ab2:	e0 6a 01 04 	mov	r10,260
80004ab6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004aba:	74 36       	ld.w	r6,r10[0xc]
80004abc:	c1 98       	rjmp	80004aee <_malloc_r+0xfa>
80004abe:	6c 19       	ld.w	r9,r6[0x4]
80004ac0:	e0 19 ff fc 	andl	r9,0xfffc
80004ac4:	f2 07 01 0b 	sub	r11,r9,r7
80004ac8:	58 fb       	cp.w	r11,15
80004aca:	e0 8a 00 04 	brle	80004ad2 <_malloc_r+0xde>
80004ace:	20 13       	sub	r3,1
80004ad0:	c1 18       	rjmp	80004af2 <_malloc_r+0xfe>
80004ad2:	6c 38       	ld.w	r8,r6[0xc]
80004ad4:	58 0b       	cp.w	r11,0
80004ad6:	c0 b5       	brlt	80004aec <_malloc_r+0xf8>
80004ad8:	6c 2a       	ld.w	r10,r6[0x8]
80004ada:	ec 09 00 09 	add	r9,r6,r9
80004ade:	0a 9c       	mov	r12,r5
80004ae0:	91 2a       	st.w	r8[0x8],r10
80004ae2:	95 38       	st.w	r10[0xc],r8
80004ae4:	72 18       	ld.w	r8,r9[0x4]
80004ae6:	a1 a8       	sbr	r8,0x0
80004ae8:	93 18       	st.w	r9[0x4],r8
80004aea:	cb c8       	rjmp	80004c62 <_malloc_r+0x26e>
80004aec:	10 96       	mov	r6,r8
80004aee:	14 36       	cp.w	r6,r10
80004af0:	ce 71       	brne	80004abe <_malloc_r+0xca>
80004af2:	2f f3       	sub	r3,-1
80004af4:	e0 6a 01 04 	mov	r10,260
80004af8:	f4 cc ff f8 	sub	r12,r10,-8
80004afc:	78 26       	ld.w	r6,r12[0x8]
80004afe:	18 36       	cp.w	r6,r12
80004b00:	c6 c0       	breq	80004bd8 <_malloc_r+0x1e4>
80004b02:	6c 19       	ld.w	r9,r6[0x4]
80004b04:	e0 19 ff fc 	andl	r9,0xfffc
80004b08:	f2 07 01 08 	sub	r8,r9,r7
80004b0c:	58 f8       	cp.w	r8,15
80004b0e:	e0 89 00 8f 	brgt	80004c2c <_malloc_r+0x238>
80004b12:	99 3c       	st.w	r12[0xc],r12
80004b14:	99 2c       	st.w	r12[0x8],r12
80004b16:	58 08       	cp.w	r8,0
80004b18:	c0 55       	brlt	80004b22 <_malloc_r+0x12e>
80004b1a:	ec 09 00 09 	add	r9,r6,r9
80004b1e:	0a 9c       	mov	r12,r5
80004b20:	ce 2b       	rjmp	80004ae4 <_malloc_r+0xf0>
80004b22:	e0 49 01 ff 	cp.w	r9,511
80004b26:	e0 8b 00 13 	brhi	80004b4c <_malloc_r+0x158>
80004b2a:	a3 99       	lsr	r9,0x3
80004b2c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004b30:	70 2b       	ld.w	r11,r8[0x8]
80004b32:	8d 38       	st.w	r6[0xc],r8
80004b34:	8d 2b       	st.w	r6[0x8],r11
80004b36:	97 36       	st.w	r11[0xc],r6
80004b38:	91 26       	st.w	r8[0x8],r6
80004b3a:	a3 49       	asr	r9,0x2
80004b3c:	74 18       	ld.w	r8,r10[0x4]
80004b3e:	30 1b       	mov	r11,1
80004b40:	f6 09 09 49 	lsl	r9,r11,r9
80004b44:	f1 e9 10 09 	or	r9,r8,r9
80004b48:	95 19       	st.w	r10[0x4],r9
80004b4a:	c4 78       	rjmp	80004bd8 <_malloc_r+0x1e4>
80004b4c:	f2 0a 16 09 	lsr	r10,r9,0x9
80004b50:	58 4a       	cp.w	r10,4
80004b52:	e0 8b 00 07 	brhi	80004b60 <_malloc_r+0x16c>
80004b56:	f2 0a 16 06 	lsr	r10,r9,0x6
80004b5a:	2c 8a       	sub	r10,-56
80004b5c:	c2 08       	rjmp	80004b9c <_malloc_r+0x1a8>
80004b5e:	d7 03       	nop
80004b60:	59 4a       	cp.w	r10,20
80004b62:	e0 8b 00 04 	brhi	80004b6a <_malloc_r+0x176>
80004b66:	2a 5a       	sub	r10,-91
80004b68:	c1 a8       	rjmp	80004b9c <_malloc_r+0x1a8>
80004b6a:	e0 4a 00 54 	cp.w	r10,84
80004b6e:	e0 8b 00 06 	brhi	80004b7a <_malloc_r+0x186>
80004b72:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004b76:	29 2a       	sub	r10,-110
80004b78:	c1 28       	rjmp	80004b9c <_malloc_r+0x1a8>
80004b7a:	e0 4a 01 54 	cp.w	r10,340
80004b7e:	e0 8b 00 06 	brhi	80004b8a <_malloc_r+0x196>
80004b82:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004b86:	28 9a       	sub	r10,-119
80004b88:	c0 a8       	rjmp	80004b9c <_malloc_r+0x1a8>
80004b8a:	e0 4a 05 54 	cp.w	r10,1364
80004b8e:	e0 88 00 04 	brls	80004b96 <_malloc_r+0x1a2>
80004b92:	37 ea       	mov	r10,126
80004b94:	c0 48       	rjmp	80004b9c <_malloc_r+0x1a8>
80004b96:	f2 0a 16 12 	lsr	r10,r9,0x12
80004b9a:	28 4a       	sub	r10,-124
80004b9c:	e0 6b 01 04 	mov	r11,260
80004ba0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004ba4:	68 28       	ld.w	r8,r4[0x8]
80004ba6:	08 38       	cp.w	r8,r4
80004ba8:	c0 e1       	brne	80004bc4 <_malloc_r+0x1d0>
80004baa:	76 19       	ld.w	r9,r11[0x4]
80004bac:	a3 4a       	asr	r10,0x2
80004bae:	30 1e       	mov	lr,1
80004bb0:	fc 0a 09 4a 	lsl	r10,lr,r10
80004bb4:	f3 ea 10 0a 	or	r10,r9,r10
80004bb8:	10 99       	mov	r9,r8
80004bba:	97 1a       	st.w	r11[0x4],r10
80004bbc:	c0 a8       	rjmp	80004bd0 <_malloc_r+0x1dc>
80004bbe:	70 28       	ld.w	r8,r8[0x8]
80004bc0:	08 38       	cp.w	r8,r4
80004bc2:	c0 60       	breq	80004bce <_malloc_r+0x1da>
80004bc4:	70 1a       	ld.w	r10,r8[0x4]
80004bc6:	e0 1a ff fc 	andl	r10,0xfffc
80004bca:	14 39       	cp.w	r9,r10
80004bcc:	cf 93       	brcs	80004bbe <_malloc_r+0x1ca>
80004bce:	70 39       	ld.w	r9,r8[0xc]
80004bd0:	8d 39       	st.w	r6[0xc],r9
80004bd2:	8d 28       	st.w	r6[0x8],r8
80004bd4:	91 36       	st.w	r8[0xc],r6
80004bd6:	93 26       	st.w	r9[0x8],r6
80004bd8:	e6 08 14 02 	asr	r8,r3,0x2
80004bdc:	30 1b       	mov	r11,1
80004bde:	e0 64 01 04 	mov	r4,260
80004be2:	f6 08 09 4b 	lsl	r11,r11,r8
80004be6:	68 18       	ld.w	r8,r4[0x4]
80004be8:	10 3b       	cp.w	r11,r8
80004bea:	e0 8b 00 6b 	brhi	80004cc0 <_malloc_r+0x2cc>
80004bee:	f7 e8 00 09 	and	r9,r11,r8
80004bf2:	c0 b1       	brne	80004c08 <_malloc_r+0x214>
80004bf4:	e0 13 ff fc 	andl	r3,0xfffc
80004bf8:	a1 7b       	lsl	r11,0x1
80004bfa:	2f c3       	sub	r3,-4
80004bfc:	c0 38       	rjmp	80004c02 <_malloc_r+0x20e>
80004bfe:	2f c3       	sub	r3,-4
80004c00:	a1 7b       	lsl	r11,0x1
80004c02:	f7 e8 00 09 	and	r9,r11,r8
80004c06:	cf c0       	breq	80004bfe <_malloc_r+0x20a>
80004c08:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004c0c:	06 92       	mov	r2,r3
80004c0e:	1c 91       	mov	r1,lr
80004c10:	62 36       	ld.w	r6,r1[0xc]
80004c12:	c2 e8       	rjmp	80004c6e <_malloc_r+0x27a>
80004c14:	6c 1a       	ld.w	r10,r6[0x4]
80004c16:	e0 1a ff fc 	andl	r10,0xfffc
80004c1a:	f4 07 01 08 	sub	r8,r10,r7
80004c1e:	58 f8       	cp.w	r8,15
80004c20:	e0 8a 00 15 	brle	80004c4a <_malloc_r+0x256>
80004c24:	6c 3a       	ld.w	r10,r6[0xc]
80004c26:	6c 29       	ld.w	r9,r6[0x8]
80004c28:	95 29       	st.w	r10[0x8],r9
80004c2a:	93 3a       	st.w	r9[0xc],r10
80004c2c:	0e 99       	mov	r9,r7
80004c2e:	ec 07 00 07 	add	r7,r6,r7
80004c32:	a1 a9       	sbr	r9,0x0
80004c34:	99 37       	st.w	r12[0xc],r7
80004c36:	99 27       	st.w	r12[0x8],r7
80004c38:	8d 19       	st.w	r6[0x4],r9
80004c3a:	ee 08 09 08 	st.w	r7[r8],r8
80004c3e:	8f 2c       	st.w	r7[0x8],r12
80004c40:	8f 3c       	st.w	r7[0xc],r12
80004c42:	a1 a8       	sbr	r8,0x0
80004c44:	0a 9c       	mov	r12,r5
80004c46:	8f 18       	st.w	r7[0x4],r8
80004c48:	c0 d8       	rjmp	80004c62 <_malloc_r+0x26e>
80004c4a:	6c 39       	ld.w	r9,r6[0xc]
80004c4c:	58 08       	cp.w	r8,0
80004c4e:	c0 f5       	brlt	80004c6c <_malloc_r+0x278>
80004c50:	ec 0a 00 0a 	add	r10,r6,r10
80004c54:	74 18       	ld.w	r8,r10[0x4]
80004c56:	a1 a8       	sbr	r8,0x0
80004c58:	0a 9c       	mov	r12,r5
80004c5a:	95 18       	st.w	r10[0x4],r8
80004c5c:	6c 28       	ld.w	r8,r6[0x8]
80004c5e:	93 28       	st.w	r9[0x8],r8
80004c60:	91 39       	st.w	r8[0xc],r9
80004c62:	fe b0 f2 ab 	rcall	800031b8 <__malloc_unlock>
80004c66:	ec cc ff f8 	sub	r12,r6,-8
80004c6a:	d8 32       	popm	r0-r7,pc
80004c6c:	12 96       	mov	r6,r9
80004c6e:	02 36       	cp.w	r6,r1
80004c70:	cd 21       	brne	80004c14 <_malloc_r+0x220>
80004c72:	2f f2       	sub	r2,-1
80004c74:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004c78:	c0 30       	breq	80004c7e <_malloc_r+0x28a>
80004c7a:	2f 81       	sub	r1,-8
80004c7c:	cc ab       	rjmp	80004c10 <_malloc_r+0x21c>
80004c7e:	1c 98       	mov	r8,lr
80004c80:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004c84:	c0 81       	brne	80004c94 <_malloc_r+0x2a0>
80004c86:	68 19       	ld.w	r9,r4[0x4]
80004c88:	f6 08 11 ff 	rsub	r8,r11,-1
80004c8c:	f3 e8 00 08 	and	r8,r9,r8
80004c90:	89 18       	st.w	r4[0x4],r8
80004c92:	c0 78       	rjmp	80004ca0 <_malloc_r+0x2ac>
80004c94:	f0 c9 00 08 	sub	r9,r8,8
80004c98:	20 13       	sub	r3,1
80004c9a:	70 08       	ld.w	r8,r8[0x0]
80004c9c:	12 38       	cp.w	r8,r9
80004c9e:	cf 10       	breq	80004c80 <_malloc_r+0x28c>
80004ca0:	a1 7b       	lsl	r11,0x1
80004ca2:	68 18       	ld.w	r8,r4[0x4]
80004ca4:	10 3b       	cp.w	r11,r8
80004ca6:	e0 8b 00 0d 	brhi	80004cc0 <_malloc_r+0x2cc>
80004caa:	58 0b       	cp.w	r11,0
80004cac:	c0 a0       	breq	80004cc0 <_malloc_r+0x2cc>
80004cae:	04 93       	mov	r3,r2
80004cb0:	c0 38       	rjmp	80004cb6 <_malloc_r+0x2c2>
80004cb2:	2f c3       	sub	r3,-4
80004cb4:	a1 7b       	lsl	r11,0x1
80004cb6:	f7 e8 00 09 	and	r9,r11,r8
80004cba:	ca 71       	brne	80004c08 <_malloc_r+0x214>
80004cbc:	cf bb       	rjmp	80004cb2 <_malloc_r+0x2be>
80004cbe:	d7 03       	nop
80004cc0:	68 23       	ld.w	r3,r4[0x8]
80004cc2:	66 12       	ld.w	r2,r3[0x4]
80004cc4:	e0 12 ff fc 	andl	r2,0xfffc
80004cc8:	0e 32       	cp.w	r2,r7
80004cca:	5f 39       	srlo	r9
80004ccc:	e4 07 01 08 	sub	r8,r2,r7
80004cd0:	58 f8       	cp.w	r8,15
80004cd2:	5f aa       	srle	r10
80004cd4:	f5 e9 10 09 	or	r9,r10,r9
80004cd8:	e0 80 00 98 	breq	80004e08 <_malloc_r+0x414>
80004cdc:	e0 68 07 98 	mov	r8,1944
80004ce0:	70 01       	ld.w	r1,r8[0x0]
80004ce2:	e0 68 05 10 	mov	r8,1296
80004ce6:	2f 01       	sub	r1,-16
80004ce8:	70 08       	ld.w	r8,r8[0x0]
80004cea:	0e 01       	add	r1,r7
80004cec:	5b f8       	cp.w	r8,-1
80004cee:	c0 40       	breq	80004cf6 <_malloc_r+0x302>
80004cf0:	28 11       	sub	r1,-127
80004cf2:	e0 11 ff 80 	andl	r1,0xff80
80004cf6:	02 9b       	mov	r11,r1
80004cf8:	0a 9c       	mov	r12,r5
80004cfa:	c3 bd       	rcall	80004f70 <_sbrk_r>
80004cfc:	18 96       	mov	r6,r12
80004cfe:	5b fc       	cp.w	r12,-1
80004d00:	c7 30       	breq	80004de6 <_malloc_r+0x3f2>
80004d02:	e6 02 00 08 	add	r8,r3,r2
80004d06:	10 3c       	cp.w	r12,r8
80004d08:	c0 32       	brcc	80004d0e <_malloc_r+0x31a>
80004d0a:	08 33       	cp.w	r3,r4
80004d0c:	c6 d1       	brne	80004de6 <_malloc_r+0x3f2>
80004d0e:	e0 6a 07 9c 	mov	r10,1948
80004d12:	74 09       	ld.w	r9,r10[0x0]
80004d14:	e2 09 00 09 	add	r9,r1,r9
80004d18:	95 09       	st.w	r10[0x0],r9
80004d1a:	10 36       	cp.w	r6,r8
80004d1c:	c0 a1       	brne	80004d30 <_malloc_r+0x33c>
80004d1e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004d22:	c0 71       	brne	80004d30 <_malloc_r+0x33c>
80004d24:	e2 02 00 02 	add	r2,r1,r2
80004d28:	68 28       	ld.w	r8,r4[0x8]
80004d2a:	a1 a2       	sbr	r2,0x0
80004d2c:	91 12       	st.w	r8[0x4],r2
80004d2e:	c4 d8       	rjmp	80004dc8 <_malloc_r+0x3d4>
80004d30:	e0 6a 05 10 	mov	r10,1296
80004d34:	74 0b       	ld.w	r11,r10[0x0]
80004d36:	5b fb       	cp.w	r11,-1
80004d38:	c0 31       	brne	80004d3e <_malloc_r+0x34a>
80004d3a:	95 06       	st.w	r10[0x0],r6
80004d3c:	c0 78       	rjmp	80004d4a <_malloc_r+0x356>
80004d3e:	ec 09 00 09 	add	r9,r6,r9
80004d42:	e0 6a 07 9c 	mov	r10,1948
80004d46:	10 19       	sub	r9,r8
80004d48:	95 09       	st.w	r10[0x0],r9
80004d4a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004d4e:	f0 09 11 08 	rsub	r9,r8,8
80004d52:	58 08       	cp.w	r8,0
80004d54:	f2 08 17 10 	movne	r8,r9
80004d58:	ed d8 e1 06 	addne	r6,r6,r8
80004d5c:	28 08       	sub	r8,-128
80004d5e:	ec 01 00 01 	add	r1,r6,r1
80004d62:	0a 9c       	mov	r12,r5
80004d64:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004d68:	f0 01 01 01 	sub	r1,r8,r1
80004d6c:	02 9b       	mov	r11,r1
80004d6e:	c0 1d       	rcall	80004f70 <_sbrk_r>
80004d70:	e0 68 07 9c 	mov	r8,1948
80004d74:	5b fc       	cp.w	r12,-1
80004d76:	ec 0c 17 00 	moveq	r12,r6
80004d7a:	f9 b1 00 00 	moveq	r1,0
80004d7e:	70 09       	ld.w	r9,r8[0x0]
80004d80:	0c 1c       	sub	r12,r6
80004d82:	89 26       	st.w	r4[0x8],r6
80004d84:	02 0c       	add	r12,r1
80004d86:	12 01       	add	r1,r9
80004d88:	a1 ac       	sbr	r12,0x0
80004d8a:	91 01       	st.w	r8[0x0],r1
80004d8c:	8d 1c       	st.w	r6[0x4],r12
80004d8e:	08 33       	cp.w	r3,r4
80004d90:	c1 c0       	breq	80004dc8 <_malloc_r+0x3d4>
80004d92:	58 f2       	cp.w	r2,15
80004d94:	e0 8b 00 05 	brhi	80004d9e <_malloc_r+0x3aa>
80004d98:	30 18       	mov	r8,1
80004d9a:	8d 18       	st.w	r6[0x4],r8
80004d9c:	c2 58       	rjmp	80004de6 <_malloc_r+0x3f2>
80004d9e:	30 59       	mov	r9,5
80004da0:	20 c2       	sub	r2,12
80004da2:	e0 12 ff f8 	andl	r2,0xfff8
80004da6:	e6 02 00 08 	add	r8,r3,r2
80004daa:	91 29       	st.w	r8[0x8],r9
80004dac:	91 19       	st.w	r8[0x4],r9
80004dae:	66 18       	ld.w	r8,r3[0x4]
80004db0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004db4:	e5 e8 10 08 	or	r8,r2,r8
80004db8:	87 18       	st.w	r3[0x4],r8
80004dba:	58 f2       	cp.w	r2,15
80004dbc:	e0 88 00 06 	brls	80004dc8 <_malloc_r+0x3d4>
80004dc0:	e6 cb ff f8 	sub	r11,r3,-8
80004dc4:	0a 9c       	mov	r12,r5
80004dc6:	c4 fd       	rcall	80005064 <_free_r>
80004dc8:	e0 69 07 94 	mov	r9,1940
80004dcc:	72 0a       	ld.w	r10,r9[0x0]
80004dce:	e0 68 07 9c 	mov	r8,1948
80004dd2:	70 08       	ld.w	r8,r8[0x0]
80004dd4:	14 38       	cp.w	r8,r10
80004dd6:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004dda:	e0 69 07 90 	mov	r9,1936
80004dde:	72 0a       	ld.w	r10,r9[0x0]
80004de0:	14 38       	cp.w	r8,r10
80004de2:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004de6:	68 28       	ld.w	r8,r4[0x8]
80004de8:	70 18       	ld.w	r8,r8[0x4]
80004dea:	e0 18 ff fc 	andl	r8,0xfffc
80004dee:	0e 38       	cp.w	r8,r7
80004df0:	5f 39       	srlo	r9
80004df2:	0e 18       	sub	r8,r7
80004df4:	58 f8       	cp.w	r8,15
80004df6:	5f aa       	srle	r10
80004df8:	f5 e9 10 09 	or	r9,r10,r9
80004dfc:	c0 60       	breq	80004e08 <_malloc_r+0x414>
80004dfe:	0a 9c       	mov	r12,r5
80004e00:	fe b0 f1 dc 	rcall	800031b8 <__malloc_unlock>
80004e04:	d8 3a       	popm	r0-r7,pc,r12=0
80004e06:	d7 03       	nop
80004e08:	68 26       	ld.w	r6,r4[0x8]
80004e0a:	a1 a8       	sbr	r8,0x0
80004e0c:	0e 99       	mov	r9,r7
80004e0e:	a1 a9       	sbr	r9,0x0
80004e10:	8d 19       	st.w	r6[0x4],r9
80004e12:	ec 07 00 07 	add	r7,r6,r7
80004e16:	0a 9c       	mov	r12,r5
80004e18:	89 27       	st.w	r4[0x8],r7
80004e1a:	8f 18       	st.w	r7[0x4],r8
80004e1c:	fe b0 f1 ce 	rcall	800031b8 <__malloc_unlock>
80004e20:	ec cc ff f8 	sub	r12,r6,-8
80004e24:	d8 32       	popm	r0-r7,pc
80004e26:	d7 03       	nop

80004e28 <memcpy>:
80004e28:	58 8a       	cp.w	r10,8
80004e2a:	c2 f5       	brlt	80004e88 <memcpy+0x60>
80004e2c:	f9 eb 10 09 	or	r9,r12,r11
80004e30:	e2 19 00 03 	andl	r9,0x3,COH
80004e34:	e0 81 00 97 	brne	80004f62 <memcpy+0x13a>
80004e38:	e0 4a 00 20 	cp.w	r10,32
80004e3c:	c3 b4       	brge	80004eb2 <memcpy+0x8a>
80004e3e:	f4 08 14 02 	asr	r8,r10,0x2
80004e42:	f0 09 11 08 	rsub	r9,r8,8
80004e46:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004e4a:	76 69       	ld.w	r9,r11[0x18]
80004e4c:	99 69       	st.w	r12[0x18],r9
80004e4e:	76 59       	ld.w	r9,r11[0x14]
80004e50:	99 59       	st.w	r12[0x14],r9
80004e52:	76 49       	ld.w	r9,r11[0x10]
80004e54:	99 49       	st.w	r12[0x10],r9
80004e56:	76 39       	ld.w	r9,r11[0xc]
80004e58:	99 39       	st.w	r12[0xc],r9
80004e5a:	76 29       	ld.w	r9,r11[0x8]
80004e5c:	99 29       	st.w	r12[0x8],r9
80004e5e:	76 19       	ld.w	r9,r11[0x4]
80004e60:	99 19       	st.w	r12[0x4],r9
80004e62:	76 09       	ld.w	r9,r11[0x0]
80004e64:	99 09       	st.w	r12[0x0],r9
80004e66:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80004e6a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80004e6e:	e0 1a 00 03 	andl	r10,0x3
80004e72:	f4 0a 11 04 	rsub	r10,r10,4
80004e76:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004e7a:	17 a9       	ld.ub	r9,r11[0x2]
80004e7c:	b0 a9       	st.b	r8[0x2],r9
80004e7e:	17 99       	ld.ub	r9,r11[0x1]
80004e80:	b0 99       	st.b	r8[0x1],r9
80004e82:	17 89       	ld.ub	r9,r11[0x0]
80004e84:	b0 89       	st.b	r8[0x0],r9
80004e86:	5e fc       	retal	r12
80004e88:	f4 0a 11 09 	rsub	r10,r10,9
80004e8c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004e90:	17 f9       	ld.ub	r9,r11[0x7]
80004e92:	b8 f9       	st.b	r12[0x7],r9
80004e94:	17 e9       	ld.ub	r9,r11[0x6]
80004e96:	b8 e9       	st.b	r12[0x6],r9
80004e98:	17 d9       	ld.ub	r9,r11[0x5]
80004e9a:	b8 d9       	st.b	r12[0x5],r9
80004e9c:	17 c9       	ld.ub	r9,r11[0x4]
80004e9e:	b8 c9       	st.b	r12[0x4],r9
80004ea0:	17 b9       	ld.ub	r9,r11[0x3]
80004ea2:	b8 b9       	st.b	r12[0x3],r9
80004ea4:	17 a9       	ld.ub	r9,r11[0x2]
80004ea6:	b8 a9       	st.b	r12[0x2],r9
80004ea8:	17 99       	ld.ub	r9,r11[0x1]
80004eaa:	b8 99       	st.b	r12[0x1],r9
80004eac:	17 89       	ld.ub	r9,r11[0x0]
80004eae:	b8 89       	st.b	r12[0x0],r9
80004eb0:	5e fc       	retal	r12
80004eb2:	eb cd 40 c0 	pushm	r6-r7,lr
80004eb6:	18 99       	mov	r9,r12
80004eb8:	22 0a       	sub	r10,32
80004eba:	b7 07       	ld.d	r6,r11++
80004ebc:	b3 26       	st.d	r9++,r6
80004ebe:	b7 07       	ld.d	r6,r11++
80004ec0:	b3 26       	st.d	r9++,r6
80004ec2:	b7 07       	ld.d	r6,r11++
80004ec4:	b3 26       	st.d	r9++,r6
80004ec6:	b7 07       	ld.d	r6,r11++
80004ec8:	b3 26       	st.d	r9++,r6
80004eca:	22 0a       	sub	r10,32
80004ecc:	cf 74       	brge	80004eba <memcpy+0x92>
80004ece:	2f 0a       	sub	r10,-16
80004ed0:	c0 65       	brlt	80004edc <memcpy+0xb4>
80004ed2:	b7 07       	ld.d	r6,r11++
80004ed4:	b3 26       	st.d	r9++,r6
80004ed6:	b7 07       	ld.d	r6,r11++
80004ed8:	b3 26       	st.d	r9++,r6
80004eda:	21 0a       	sub	r10,16
80004edc:	5c 3a       	neg	r10
80004ede:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80004ee2:	d7 03       	nop
80004ee4:	d7 03       	nop
80004ee6:	f7 36 00 0e 	ld.ub	r6,r11[14]
80004eea:	f3 66 00 0e 	st.b	r9[14],r6
80004eee:	f7 36 00 0d 	ld.ub	r6,r11[13]
80004ef2:	f3 66 00 0d 	st.b	r9[13],r6
80004ef6:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004efa:	f3 66 00 0c 	st.b	r9[12],r6
80004efe:	f7 36 00 0b 	ld.ub	r6,r11[11]
80004f02:	f3 66 00 0b 	st.b	r9[11],r6
80004f06:	f7 36 00 0a 	ld.ub	r6,r11[10]
80004f0a:	f3 66 00 0a 	st.b	r9[10],r6
80004f0e:	f7 36 00 09 	ld.ub	r6,r11[9]
80004f12:	f3 66 00 09 	st.b	r9[9],r6
80004f16:	f7 36 00 08 	ld.ub	r6,r11[8]
80004f1a:	f3 66 00 08 	st.b	r9[8],r6
80004f1e:	f7 36 00 07 	ld.ub	r6,r11[7]
80004f22:	f3 66 00 07 	st.b	r9[7],r6
80004f26:	f7 36 00 06 	ld.ub	r6,r11[6]
80004f2a:	f3 66 00 06 	st.b	r9[6],r6
80004f2e:	f7 36 00 05 	ld.ub	r6,r11[5]
80004f32:	f3 66 00 05 	st.b	r9[5],r6
80004f36:	f7 36 00 04 	ld.ub	r6,r11[4]
80004f3a:	f3 66 00 04 	st.b	r9[4],r6
80004f3e:	f7 36 00 03 	ld.ub	r6,r11[3]
80004f42:	f3 66 00 03 	st.b	r9[3],r6
80004f46:	f7 36 00 02 	ld.ub	r6,r11[2]
80004f4a:	f3 66 00 02 	st.b	r9[2],r6
80004f4e:	f7 36 00 01 	ld.ub	r6,r11[1]
80004f52:	f3 66 00 01 	st.b	r9[1],r6
80004f56:	f7 36 00 00 	ld.ub	r6,r11[0]
80004f5a:	f3 66 00 00 	st.b	r9[0],r6
80004f5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f62:	20 1a       	sub	r10,1
80004f64:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004f68:	f8 0a 0b 09 	st.b	r12[r10],r9
80004f6c:	cf b1       	brne	80004f62 <memcpy+0x13a>
80004f6e:	5e fc       	retal	r12

80004f70 <_sbrk_r>:
80004f70:	d4 21       	pushm	r4-r7,lr
80004f72:	30 08       	mov	r8,0
80004f74:	18 97       	mov	r7,r12
80004f76:	e0 66 09 d8 	mov	r6,2520
80004f7a:	16 9c       	mov	r12,r11
80004f7c:	8d 08       	st.w	r6[0x0],r8
80004f7e:	c0 9c       	rcall	80004f90 <_sbrk>
80004f80:	5b fc       	cp.w	r12,-1
80004f82:	c0 51       	brne	80004f8c <_sbrk_r+0x1c>
80004f84:	6c 08       	ld.w	r8,r6[0x0]
80004f86:	58 08       	cp.w	r8,0
80004f88:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004f8c:	d8 22       	popm	r4-r7,pc
80004f8e:	d7 03       	nop

80004f90 <_sbrk>:
80004f90:	d4 01       	pushm	lr
80004f92:	e0 68 07 c4 	mov	r8,1988
80004f96:	70 09       	ld.w	r9,r8[0x0]
80004f98:	58 09       	cp.w	r9,0
80004f9a:	c0 41       	brne	80004fa2 <_sbrk+0x12>
80004f9c:	e0 69 09 e0 	mov	r9,2528
80004fa0:	91 09       	st.w	r8[0x0],r9
80004fa2:	e0 69 07 c4 	mov	r9,1988
80004fa6:	e0 6a f0 00 	mov	r10,61440
80004faa:	72 08       	ld.w	r8,r9[0x0]
80004fac:	f0 0c 00 0c 	add	r12,r8,r12
80004fb0:	14 3c       	cp.w	r12,r10
80004fb2:	e0 8b 00 04 	brhi	80004fba <_sbrk+0x2a>
80004fb6:	93 0c       	st.w	r9[0x0],r12
80004fb8:	c0 58       	rjmp	80004fc2 <_sbrk+0x32>
80004fba:	c0 7c       	rcall	80004fc8 <__errno>
80004fbc:	30 c8       	mov	r8,12
80004fbe:	99 08       	st.w	r12[0x0],r8
80004fc0:	3f f8       	mov	r8,-1
80004fc2:	10 9c       	mov	r12,r8
80004fc4:	d8 02       	popm	pc
80004fc6:	d7 03       	nop

80004fc8 <__errno>:
80004fc8:	e0 68 01 00 	mov	r8,256
80004fcc:	70 0c       	ld.w	r12,r8[0x0]
80004fce:	2f 4c       	sub	r12,-12
80004fd0:	5e fc       	retal	r12
80004fd2:	d7 03       	nop

80004fd4 <_malloc_trim_r>:
80004fd4:	d4 21       	pushm	r4-r7,lr
80004fd6:	16 95       	mov	r5,r11
80004fd8:	18 97       	mov	r7,r12
80004fda:	fe b0 f0 e9 	rcall	800031ac <__malloc_lock>
80004fde:	e0 64 01 04 	mov	r4,260
80004fe2:	68 28       	ld.w	r8,r4[0x8]
80004fe4:	70 16       	ld.w	r6,r8[0x4]
80004fe6:	e0 16 ff fc 	andl	r6,0xfffc
80004fea:	ec c8 ff 91 	sub	r8,r6,-111
80004fee:	f0 05 01 05 	sub	r5,r8,r5
80004ff2:	e0 15 ff 80 	andl	r5,0xff80
80004ff6:	ea c5 00 80 	sub	r5,r5,128
80004ffa:	e0 45 00 7f 	cp.w	r5,127
80004ffe:	e0 8a 00 22 	brle	80005042 <_malloc_trim_r+0x6e>
80005002:	30 0b       	mov	r11,0
80005004:	0e 9c       	mov	r12,r7
80005006:	cb 5f       	rcall	80004f70 <_sbrk_r>
80005008:	68 28       	ld.w	r8,r4[0x8]
8000500a:	0c 08       	add	r8,r6
8000500c:	10 3c       	cp.w	r12,r8
8000500e:	c1 a1       	brne	80005042 <_malloc_trim_r+0x6e>
80005010:	ea 0b 11 00 	rsub	r11,r5,0
80005014:	0e 9c       	mov	r12,r7
80005016:	ca df       	rcall	80004f70 <_sbrk_r>
80005018:	5b fc       	cp.w	r12,-1
8000501a:	c1 81       	brne	8000504a <_malloc_trim_r+0x76>
8000501c:	30 0b       	mov	r11,0
8000501e:	0e 9c       	mov	r12,r7
80005020:	ca 8f       	rcall	80004f70 <_sbrk_r>
80005022:	68 28       	ld.w	r8,r4[0x8]
80005024:	f8 08 01 09 	sub	r9,r12,r8
80005028:	58 f9       	cp.w	r9,15
8000502a:	e0 8a 00 0c 	brle	80005042 <_malloc_trim_r+0x6e>
8000502e:	a1 a9       	sbr	r9,0x0
80005030:	91 19       	st.w	r8[0x4],r9
80005032:	e0 68 05 10 	mov	r8,1296
80005036:	70 09       	ld.w	r9,r8[0x0]
80005038:	e0 68 07 9c 	mov	r8,1948
8000503c:	f8 09 01 09 	sub	r9,r12,r9
80005040:	91 09       	st.w	r8[0x0],r9
80005042:	0e 9c       	mov	r12,r7
80005044:	fe b0 f0 ba 	rcall	800031b8 <__malloc_unlock>
80005048:	d8 2a       	popm	r4-r7,pc,r12=0
8000504a:	68 28       	ld.w	r8,r4[0x8]
8000504c:	0a 16       	sub	r6,r5
8000504e:	a1 a6       	sbr	r6,0x0
80005050:	91 16       	st.w	r8[0x4],r6
80005052:	e0 68 07 9c 	mov	r8,1948
80005056:	70 09       	ld.w	r9,r8[0x0]
80005058:	0a 19       	sub	r9,r5
8000505a:	0e 9c       	mov	r12,r7
8000505c:	91 09       	st.w	r8[0x0],r9
8000505e:	fe b0 f0 ad 	rcall	800031b8 <__malloc_unlock>
80005062:	da 2a       	popm	r4-r7,pc,r12=1

80005064 <_free_r>:
80005064:	d4 21       	pushm	r4-r7,lr
80005066:	16 96       	mov	r6,r11
80005068:	18 97       	mov	r7,r12
8000506a:	58 0b       	cp.w	r11,0
8000506c:	e0 80 00 c0 	breq	800051ec <_free_r+0x188>
80005070:	fe b0 f0 9e 	rcall	800031ac <__malloc_lock>
80005074:	20 86       	sub	r6,8
80005076:	e0 6a 01 04 	mov	r10,260
8000507a:	6c 18       	ld.w	r8,r6[0x4]
8000507c:	74 2e       	ld.w	lr,r10[0x8]
8000507e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005082:	a1 c8       	cbr	r8,0x0
80005084:	ec 08 00 09 	add	r9,r6,r8
80005088:	72 1b       	ld.w	r11,r9[0x4]
8000508a:	e0 1b ff fc 	andl	r11,0xfffc
8000508e:	1c 39       	cp.w	r9,lr
80005090:	c1 e1       	brne	800050cc <_free_r+0x68>
80005092:	f6 08 00 08 	add	r8,r11,r8
80005096:	58 0c       	cp.w	r12,0
80005098:	c0 81       	brne	800050a8 <_free_r+0x44>
8000509a:	6c 09       	ld.w	r9,r6[0x0]
8000509c:	12 16       	sub	r6,r9
8000509e:	12 08       	add	r8,r9
800050a0:	6c 3b       	ld.w	r11,r6[0xc]
800050a2:	6c 29       	ld.w	r9,r6[0x8]
800050a4:	97 29       	st.w	r11[0x8],r9
800050a6:	93 3b       	st.w	r9[0xc],r11
800050a8:	10 99       	mov	r9,r8
800050aa:	95 26       	st.w	r10[0x8],r6
800050ac:	a1 a9       	sbr	r9,0x0
800050ae:	8d 19       	st.w	r6[0x4],r9
800050b0:	e0 69 05 0c 	mov	r9,1292
800050b4:	72 09       	ld.w	r9,r9[0x0]
800050b6:	12 38       	cp.w	r8,r9
800050b8:	c0 63       	brcs	800050c4 <_free_r+0x60>
800050ba:	e0 68 07 98 	mov	r8,1944
800050be:	0e 9c       	mov	r12,r7
800050c0:	70 0b       	ld.w	r11,r8[0x0]
800050c2:	c8 9f       	rcall	80004fd4 <_malloc_trim_r>
800050c4:	0e 9c       	mov	r12,r7
800050c6:	fe b0 f0 79 	rcall	800031b8 <__malloc_unlock>
800050ca:	d8 22       	popm	r4-r7,pc
800050cc:	93 1b       	st.w	r9[0x4],r11
800050ce:	58 0c       	cp.w	r12,0
800050d0:	c0 30       	breq	800050d6 <_free_r+0x72>
800050d2:	30 0c       	mov	r12,0
800050d4:	c1 08       	rjmp	800050f4 <_free_r+0x90>
800050d6:	6c 0e       	ld.w	lr,r6[0x0]
800050d8:	f4 c5 ff f8 	sub	r5,r10,-8
800050dc:	1c 16       	sub	r6,lr
800050de:	1c 08       	add	r8,lr
800050e0:	6c 2e       	ld.w	lr,r6[0x8]
800050e2:	0a 3e       	cp.w	lr,r5
800050e4:	f9 bc 00 01 	moveq	r12,1
800050e8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800050ec:	eb fe 1a 02 	st.wne	r5[0x8],lr
800050f0:	fd f5 1a 03 	st.wne	lr[0xc],r5
800050f4:	f2 0b 00 0e 	add	lr,r9,r11
800050f8:	7c 1e       	ld.w	lr,lr[0x4]
800050fa:	ed be 00 00 	bld	lr,0x0
800050fe:	c1 40       	breq	80005126 <_free_r+0xc2>
80005100:	16 08       	add	r8,r11
80005102:	58 0c       	cp.w	r12,0
80005104:	c0 d1       	brne	8000511e <_free_r+0xba>
80005106:	e0 6e 01 04 	mov	lr,260
8000510a:	72 2b       	ld.w	r11,r9[0x8]
8000510c:	2f 8e       	sub	lr,-8
8000510e:	1c 3b       	cp.w	r11,lr
80005110:	c0 71       	brne	8000511e <_free_r+0xba>
80005112:	97 36       	st.w	r11[0xc],r6
80005114:	97 26       	st.w	r11[0x8],r6
80005116:	8d 2b       	st.w	r6[0x8],r11
80005118:	8d 3b       	st.w	r6[0xc],r11
8000511a:	30 1c       	mov	r12,1
8000511c:	c0 58       	rjmp	80005126 <_free_r+0xc2>
8000511e:	72 2b       	ld.w	r11,r9[0x8]
80005120:	72 39       	ld.w	r9,r9[0xc]
80005122:	93 2b       	st.w	r9[0x8],r11
80005124:	97 39       	st.w	r11[0xc],r9
80005126:	10 99       	mov	r9,r8
80005128:	ec 08 09 08 	st.w	r6[r8],r8
8000512c:	a1 a9       	sbr	r9,0x0
8000512e:	8d 19       	st.w	r6[0x4],r9
80005130:	58 0c       	cp.w	r12,0
80005132:	c5 a1       	brne	800051e6 <_free_r+0x182>
80005134:	e0 48 01 ff 	cp.w	r8,511
80005138:	e0 8b 00 13 	brhi	8000515e <_free_r+0xfa>
8000513c:	a3 98       	lsr	r8,0x3
8000513e:	f4 08 00 39 	add	r9,r10,r8<<0x3
80005142:	72 2b       	ld.w	r11,r9[0x8]
80005144:	8d 39       	st.w	r6[0xc],r9
80005146:	8d 2b       	st.w	r6[0x8],r11
80005148:	97 36       	st.w	r11[0xc],r6
8000514a:	93 26       	st.w	r9[0x8],r6
8000514c:	a3 48       	asr	r8,0x2
8000514e:	74 19       	ld.w	r9,r10[0x4]
80005150:	30 1b       	mov	r11,1
80005152:	f6 08 09 48 	lsl	r8,r11,r8
80005156:	f3 e8 10 08 	or	r8,r9,r8
8000515a:	95 18       	st.w	r10[0x4],r8
8000515c:	c4 58       	rjmp	800051e6 <_free_r+0x182>
8000515e:	f0 0b 16 09 	lsr	r11,r8,0x9
80005162:	58 4b       	cp.w	r11,4
80005164:	e0 8b 00 06 	brhi	80005170 <_free_r+0x10c>
80005168:	f0 0b 16 06 	lsr	r11,r8,0x6
8000516c:	2c 8b       	sub	r11,-56
8000516e:	c2 08       	rjmp	800051ae <_free_r+0x14a>
80005170:	59 4b       	cp.w	r11,20
80005172:	e0 8b 00 04 	brhi	8000517a <_free_r+0x116>
80005176:	2a 5b       	sub	r11,-91
80005178:	c1 b8       	rjmp	800051ae <_free_r+0x14a>
8000517a:	e0 4b 00 54 	cp.w	r11,84
8000517e:	e0 8b 00 06 	brhi	8000518a <_free_r+0x126>
80005182:	f0 0b 16 0c 	lsr	r11,r8,0xc
80005186:	29 2b       	sub	r11,-110
80005188:	c1 38       	rjmp	800051ae <_free_r+0x14a>
8000518a:	e0 4b 01 54 	cp.w	r11,340
8000518e:	e0 8b 00 06 	brhi	8000519a <_free_r+0x136>
80005192:	f0 0b 16 0f 	lsr	r11,r8,0xf
80005196:	28 9b       	sub	r11,-119
80005198:	c0 b8       	rjmp	800051ae <_free_r+0x14a>
8000519a:	e0 4b 05 54 	cp.w	r11,1364
8000519e:	e0 88 00 05 	brls	800051a8 <_free_r+0x144>
800051a2:	37 eb       	mov	r11,126
800051a4:	c0 58       	rjmp	800051ae <_free_r+0x14a>
800051a6:	d7 03       	nop
800051a8:	f0 0b 16 12 	lsr	r11,r8,0x12
800051ac:	28 4b       	sub	r11,-124
800051ae:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
800051b2:	78 29       	ld.w	r9,r12[0x8]
800051b4:	18 39       	cp.w	r9,r12
800051b6:	c0 e1       	brne	800051d2 <_free_r+0x16e>
800051b8:	74 18       	ld.w	r8,r10[0x4]
800051ba:	a3 4b       	asr	r11,0x2
800051bc:	30 1c       	mov	r12,1
800051be:	f8 0b 09 4b 	lsl	r11,r12,r11
800051c2:	f1 eb 10 0b 	or	r11,r8,r11
800051c6:	12 98       	mov	r8,r9
800051c8:	95 1b       	st.w	r10[0x4],r11
800051ca:	c0 a8       	rjmp	800051de <_free_r+0x17a>
800051cc:	72 29       	ld.w	r9,r9[0x8]
800051ce:	18 39       	cp.w	r9,r12
800051d0:	c0 60       	breq	800051dc <_free_r+0x178>
800051d2:	72 1a       	ld.w	r10,r9[0x4]
800051d4:	e0 1a ff fc 	andl	r10,0xfffc
800051d8:	14 38       	cp.w	r8,r10
800051da:	cf 93       	brcs	800051cc <_free_r+0x168>
800051dc:	72 38       	ld.w	r8,r9[0xc]
800051de:	8d 38       	st.w	r6[0xc],r8
800051e0:	8d 29       	st.w	r6[0x8],r9
800051e2:	93 36       	st.w	r9[0xc],r6
800051e4:	91 26       	st.w	r8[0x8],r6
800051e6:	0e 9c       	mov	r12,r7
800051e8:	fe b0 ef e8 	rcall	800031b8 <__malloc_unlock>
800051ec:	d8 22       	popm	r4-r7,pc
800051ee:	d7 03       	nop

Disassembly of section .exception:

80005200 <_evba>:
80005200:	c0 08       	rjmp	80005200 <_evba>
	...

80005204 <_handle_TLB_Multiple_Hit>:
	rjmp $

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80005204:	c0 08       	rjmp	80005204 <_handle_TLB_Multiple_Hit>
	...

80005208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80005208:	c0 08       	rjmp	80005208 <_handle_Bus_Error_Data_Fetch>
	...

8000520c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000520c:	c0 08       	rjmp	8000520c <_handle_Bus_Error_Instruction_Fetch>
	...

80005210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80005210:	c0 08       	rjmp	80005210 <_handle_NMI>
	...

80005214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80005214:	c0 08       	rjmp	80005214 <_handle_Instruction_Address>
	...

80005218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80005218:	c0 08       	rjmp	80005218 <_handle_ITLB_Protection>
	...

8000521c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000521c:	c0 08       	rjmp	8000521c <_handle_Breakpoint>
	...

80005220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80005220:	c0 08       	rjmp	80005220 <_handle_Illegal_Opcode>
	...

80005224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80005224:	c0 08       	rjmp	80005224 <_handle_Unimplemented_Instruction>
	...

80005228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80005228:	c0 08       	rjmp	80005228 <_handle_Privilege_Violation>
	...

8000522c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000522c:	c0 08       	rjmp	8000522c <_handle_Floating_Point>
	...

80005230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80005230:	c0 08       	rjmp	80005230 <_handle_Coprocessor_Absent>
	...

80005234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80005234:	c0 08       	rjmp	80005234 <_handle_Data_Address_Read>
	...

80005238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80005238:	c0 08       	rjmp	80005238 <_handle_Data_Address_Write>
	...

8000523c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000523c:	c0 08       	rjmp	8000523c <_handle_DTLB_Protection_Read>
	...

80005240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80005240:	c0 08       	rjmp	80005240 <_handle_DTLB_Protection_Write>
	...

80005244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80005244:	c0 08       	rjmp	80005244 <_handle_DTLB_Modified>
	...

80005250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80005250:	c0 08       	rjmp	80005250 <_handle_ITLB_Miss>
	...

80005260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80005260:	c0 08       	rjmp	80005260 <_handle_DTLB_Miss_Read>
	...

80005270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80005270:	c0 08       	rjmp	80005270 <_handle_DTLB_Miss_Write>
	...

80005300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80005300:	fe cf 22 9c 	sub	pc,pc,8860

80005304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80005304:	30 0c       	mov	r12,0
80005306:	fe b0 f8 1b 	rcall	8000433c <_get_interrupt_handler>
8000530a:	58 0c       	cp.w	r12,0
8000530c:	f8 0f 17 10 	movne	pc,r12
80005310:	d6 03       	rete

80005312 <_int1>:
80005312:	30 1c       	mov	r12,1
80005314:	fe b0 f8 14 	rcall	8000433c <_get_interrupt_handler>
80005318:	58 0c       	cp.w	r12,0
8000531a:	f8 0f 17 10 	movne	pc,r12
8000531e:	d6 03       	rete

80005320 <_int2>:
80005320:	30 2c       	mov	r12,2
80005322:	fe b0 f8 0d 	rcall	8000433c <_get_interrupt_handler>
80005326:	58 0c       	cp.w	r12,0
80005328:	f8 0f 17 10 	movne	pc,r12
8000532c:	d6 03       	rete

8000532e <_int3>:
8000532e:	30 3c       	mov	r12,3
80005330:	fe b0 f8 06 	rcall	8000433c <_get_interrupt_handler>
80005334:	58 0c       	cp.w	r12,0
80005336:	f8 0f 17 10 	movne	pc,r12
8000533a:	d6 03       	rete
8000533c:	d7 03       	nop
8000533e:	d7 03       	nop
80005340:	d7 03       	nop
80005342:	d7 03       	nop
80005344:	d7 03       	nop
80005346:	d7 03       	nop
80005348:	d7 03       	nop
8000534a:	d7 03       	nop
8000534c:	d7 03       	nop
8000534e:	d7 03       	nop
80005350:	d7 03       	nop
80005352:	d7 03       	nop
80005354:	d7 03       	nop
80005356:	d7 03       	nop
80005358:	d7 03       	nop
8000535a:	d7 03       	nop
8000535c:	d7 03       	nop
8000535e:	d7 03       	nop
80005360:	d7 03       	nop
80005362:	d7 03       	nop
80005364:	d7 03       	nop
80005366:	d7 03       	nop
80005368:	d7 03       	nop
8000536a:	d7 03       	nop
8000536c:	d7 03       	nop
8000536e:	d7 03       	nop
80005370:	d7 03       	nop
80005372:	d7 03       	nop
80005374:	d7 03       	nop
80005376:	d7 03       	nop
80005378:	d7 03       	nop
8000537a:	d7 03       	nop
8000537c:	d7 03       	nop
8000537e:	d7 03       	nop
80005380:	d7 03       	nop
80005382:	d7 03       	nop
80005384:	d7 03       	nop
80005386:	d7 03       	nop
80005388:	d7 03       	nop
8000538a:	d7 03       	nop
8000538c:	d7 03       	nop
8000538e:	d7 03       	nop
80005390:	d7 03       	nop
80005392:	d7 03       	nop
80005394:	d7 03       	nop
80005396:	d7 03       	nop
80005398:	d7 03       	nop
8000539a:	d7 03       	nop
8000539c:	d7 03       	nop
8000539e:	d7 03       	nop
800053a0:	d7 03       	nop
800053a2:	d7 03       	nop
800053a4:	d7 03       	nop
800053a6:	d7 03       	nop
800053a8:	d7 03       	nop
800053aa:	d7 03       	nop
800053ac:	d7 03       	nop
800053ae:	d7 03       	nop
800053b0:	d7 03       	nop
800053b2:	d7 03       	nop
800053b4:	d7 03       	nop
800053b6:	d7 03       	nop
800053b8:	d7 03       	nop
800053ba:	d7 03       	nop
800053bc:	d7 03       	nop
800053be:	d7 03       	nop
800053c0:	d7 03       	nop
800053c2:	d7 03       	nop
800053c4:	d7 03       	nop
800053c6:	d7 03       	nop
800053c8:	d7 03       	nop
800053ca:	d7 03       	nop
800053cc:	d7 03       	nop
800053ce:	d7 03       	nop
800053d0:	d7 03       	nop
800053d2:	d7 03       	nop
800053d4:	d7 03       	nop
800053d6:	d7 03       	nop
800053d8:	d7 03       	nop
800053da:	d7 03       	nop
800053dc:	d7 03       	nop
800053de:	d7 03       	nop
800053e0:	d7 03       	nop
800053e2:	d7 03       	nop
800053e4:	d7 03       	nop
800053e6:	d7 03       	nop
800053e8:	d7 03       	nop
800053ea:	d7 03       	nop
800053ec:	d7 03       	nop
800053ee:	d7 03       	nop
800053f0:	d7 03       	nop
800053f2:	d7 03       	nop
800053f4:	d7 03       	nop
800053f6:	d7 03       	nop
800053f8:	d7 03       	nop
800053fa:	d7 03       	nop
800053fc:	d7 03       	nop
800053fe:	d7 03       	nop
